require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"SPE-min":[function(require,module,exports){
/* shader-particle-engine 1.0.0
 * 
 * (c) 2015 Luke Moody (http://www.github.com/squarefeet)
 *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).
 *
 * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)
 */
var SPE = {
    distributions: {
        BOX: 1,
        SPHERE: 2,
        DISC: 3
    },
    valueOverLifetimeLength: 4
};
"function" == typeof define && define.amd ? define("spe", SPE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = SPE), SPE.TypedArrayHelper = function(a, b, c, d) {
    "use strict";
    this.componentSize = c || 1, this.size = b || 1, this.TypedArrayConstructor = a || Float32Array, this.array = new a(b * this.componentSize), this.indexOffset = d || 0
}, SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper, SPE.TypedArrayHelper.prototype.setSize = function(a, b) {
    "use strict";
    var c = this.array.length;
    return b || (a *= this.componentSize), c > a ? this.shrink(a) : a > c ? this.grow(a) : void console.info("TypedArray is already of size:", a + ".", "Will not resize.")
}, SPE.TypedArrayHelper.prototype.shrink = function(a) {
    "use strict";
    return this.array = this.array.subarray(0, a), this.size = a, this
}, SPE.TypedArrayHelper.prototype.grow = function(a) {
    "use strict";
    var b = this.array,
        c = new this.TypedArrayConstructor(a);
    return c.set(b), this.array = c, this.size = a, this
}, SPE.TypedArrayHelper.prototype.splice = function(a, b) {
    "use strict";
    a *= this.componentSize, b *= this.componentSize;
    for (var c = [], d = this.array, e = d.length, f = 0; e > f; ++f)
        (a > f || f >= b) && c.push(d[f]);
    return this.setFromArray(0, c), this
}, SPE.TypedArrayHelper.prototype.setFromArray = function(a, b) {
    "use strict";
    var c = b.length,
        d = a + c;
    return d > this.array.length ? this.grow(d) : d < this.array.length && this.shrink(d), this.array.set(b, this.indexOffset + a), this
}, SPE.TypedArrayHelper.prototype.setVec2 = function(a, b) {
    "use strict";
    return this.setVec2Components(a, b.x, b.y)
}, SPE.TypedArrayHelper.prototype.setVec2Components = function(a, b, c) {
    "use strict";
    var d = this.array,
        e = this.indexOffset + a * this.componentSize;
    return d[e] = b, d[e + 1] = c, this
}, SPE.TypedArrayHelper.prototype.setVec3 = function(a, b) {
    "use strict";
    return this.setVec3Components(a, b.x, b.y, b.z)
}, SPE.TypedArrayHelper.prototype.setVec3Components = function(a, b, c, d) {
    "use strict";
    var e = this.array,
        f = this.indexOffset + a * this.componentSize;
    return e[f] = b, e[f + 1] = c, e[f + 2] = d, this
}, SPE.TypedArrayHelper.prototype.setVec4 = function(a, b) {
    "use strict";
    return this.setVec4Components(a, b.x, b.y, b.z, b.w)
}, SPE.TypedArrayHelper.prototype.setVec4Components = function(a, b, c, d, e) {
    "use strict";
    var f = this.array,
        g = this.indexOffset + a * this.componentSize;
    return f[g] = b, f[g + 1] = c, f[g + 2] = d, f[g + 3] = e, this
}, SPE.TypedArrayHelper.prototype.setMat3 = function(a, b) {
    "use strict";
    return this.setFromArray(this.indexOffset + a * this.componentSize, b.elements)
}, SPE.TypedArrayHelper.prototype.setMat4 = function(a, b) {
    "use strict";
    return this.setFromArray(this.indexOffset + a * this.componentSize, b.elements)
}, SPE.TypedArrayHelper.prototype.setColor = function(a, b) {
    "use strict";
    return this.setVec3Components(a, b.r, b.g, b.b)
}, SPE.TypedArrayHelper.prototype.setNumber = function(a, b) {
    "use strict";
    return this.array[this.indexOffset + a * this.componentSize] = b, this
}, SPE.TypedArrayHelper.prototype.getValueAtIndex = function(a) {
    "use strict";
    return this.array[this.indexOffset + a]
}, SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(a) {
    "use strict";
    return this.array.subarray(this.indexOffset + a * this.componentSize);
}, SPE.ShaderAttribute = function(a, b, c) {
    "use strict";
    var d = SPE.ShaderAttribute.typeSizeMap;
    this.type = "string" == typeof a && d.hasOwnProperty(a) ? a : "f", this.componentSize = d[this.type], this.arrayType = c || Float32Array, this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!b, this.updateMin = 0, this.updateMax = 0
}, SPE.ShaderAttribute.constructor = SPE.ShaderAttribute, SPE.ShaderAttribute.typeSizeMap = {
    f: 1,
    v2: 2,
    v3: 3,
    v4: 4,
    c: 3,
    m3: 9,
    m4: 16
}, SPE.ShaderAttribute.prototype.setUpdateRange = function(a, b) {
    "use strict";
    this.updateMin = Math.min(a * this.componentSize, this.updateMin * this.componentSize), this.updateMax = Math.max(b * this.componentSize, this.updateMax * this.componentSize)
}, SPE.ShaderAttribute.prototype.flagUpdate = function() {
    "use strict";
    var a = this.bufferAttribute,
        b = a.updateRange;
    b.offset = this.updateMin, b.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), a.needsUpdate = !0
}, SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
    "use strict";
    this.updateMin = 0, this.updateMax = 0;
}, SPE.ShaderAttribute.prototype.resetDynamic = function() {
    "use strict";
    this.bufferAttribute.dynamic = this.dynamicBuffer
}, SPE.ShaderAttribute.prototype.splice = function(a, b) {
    "use strict";
    this.typedArray.splice(a, b), this.forceUpdateAll()
}, SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
    "use strict";
    this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.dynamic = !1, this.bufferAttribute.needsUpdate = !0
}, SPE.ShaderAttribute.prototype._ensureTypedArray = function(a) {
    "use strict";
    (null === this.typedArray || this.typedArray.size !== a * this.componentSize) && (null !== this.typedArray && this.typedArray.size !== a ? this.typedArray.setSize(a) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, a, this.componentSize)))
}, SPE.ShaderAttribute.prototype._createBufferAttribute = function(a) {
    "use strict";
    return this._ensureTypedArray(a), null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array,
    void (this.bufferAttribute.needsUpdate = !0)) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), void (this.bufferAttribute.dynamic = this.dynamicBuffer))
}, SPE.ShaderAttribute.prototype.getLength = function() {
    "use strict";
    return null === this.typedArray ? 0 : this.typedArray.array.length
}, SPE.shaderChunks = {
    defines: ["#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0"].join("\n"),
    uniforms: ["uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D texture;", "uniform vec4 textureAnimation;", "uniform float scale;"].join("\n"),
    attributes: ["attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;"].join("\n"),
    varyings: ["varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif"].join("\n"),
    branchAvoidanceFunctions: ["float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}"].join("\n"),
    unpackColor: ["vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}"].join("\n"),
    floatOverLifetime: ["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}"].join("\n"),
    colorOverLifetime: ["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}"].join("\n"),
    paramFetchingFunctions: ["float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}"].join("\n"),
    forceFetchingFunctions: ["vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}"].join("\n"),
    rotationFunctions: ["#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      vec3 axis = unpackColor( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = pos - rotationCenter;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return vec3( rotationMatrix * vec4( translated, 0.0 ) ) - center;", "   }", "#endif"].join("\n"),
    rotateTexture: ["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( texture, vUv );"].join("\n")
}, SPE.shaders = {
    vertex: [SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPos.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPos;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragment: [SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", THREE.ShaderChunk.fog_fragment, "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", "}"].join("\n")
}, SPE.utils = {
    types: {
        BOOLEAN: "boolean",
        STRING: "string",
        NUMBER: "number",
        OBJECT: "object"
    },
    ensureTypedArg: function(a, b, c) {
        "use strict";
        return typeof a === b ? a : c
    },
    ensureArrayTypedArg: function(a, b, c) {
        "use strict";
        if (Array.isArray(a)) {
            for (var d = a.length - 1; d >= 0; --d)
                if (typeof a[d] !== b)
                    return c;
            return a
        }
        return this.ensureTypedArg(a, b, c)
    },
    ensureInstanceOf: function(a, b, c) {
        "use strict";
        return void 0 !== b && a instanceof b ? a : c;
    },
    ensureArrayInstanceOf: function(a, b, c) {
        "use strict";
        if (Array.isArray(a)) {
            for (var d = a.length - 1; d >= 0; --d)
                if (void 0 !== b && a[d] instanceof b == !1)
                    return c;
            return a
        }
        return this.ensureInstanceOf(a, b, c)
    },
    ensureValueOverLifetimeCompliance: function(a, b, c) {
        "use strict";
        b = b || 3, c = c || 3, Array.isArray(a._value) === !1 && (a._value = [a._value]), Array.isArray(a._spread) === !1 && (a._spread = [a._spread]);
        var d = this.clamp(a._value.length, b, c),
            e = this.clamp(a._spread.length, b, c),
            f = Math.max(d, e);
        a._value.length !== f && (a._value = this.interpolateArray(a._value, f)), a._spread.length !== f && (a._spread = this.interpolateArray(a._spread, f))
    },
    interpolateArray: function(a, b) {
        "use strict";
        for (var c = a.length, d = ["function" == typeof a[0].clone ? a[0].clone() : a[0]], e = (c - 1) / (b - 1), f = 1; b - 1 > f; ++f) {
            var g = f * e,
                h = Math.floor(g),
                i = Math.ceil(g),
                j = g - h;
            d[f] = this.lerpTypeAgnostic(a[h], a[i], j)
        }
        return d.push("function" == typeof a[c - 1].clone ? a[c - 1].clone() : a[c - 1]), d
    },
    clamp: function(a, b, c) {
        "use strict";
        return Math.max(b, Math.min(a, c))
    },
    zeroToEpsilon: function(a, b) {
        "use strict";
        var c = 1e-5,
            d = a;
        return d = b ? Math.random() * c * 10 : c, 0 > a && a > -c && (d = -d), d
    },
    lerpTypeAgnostic: function(a, b, c) {
        "use strict";
        var d,
            e = this.types;
        return typeof a === e.NUMBER && typeof b === e.NUMBER ? a + (b - a) * c : a instanceof THREE.Vector2 && b instanceof THREE.Vector2 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d) : a instanceof THREE.Vector3 && b instanceof THREE.Vector3 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d.z = this.lerp(a.z, b.z, c), d) : a instanceof THREE.Vector4 && b instanceof THREE.Vector4 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d.z = this.lerp(a.z, b.z, c), d.w = this.lerp(a.w, b.w, c), d) : a instanceof THREE.Color && b instanceof THREE.Color ? (d = a.clone(), d.r = this.lerp(a.r, b.r, c), d.g = this.lerp(a.g, b.g, c), d.b = this.lerp(a.b, b.b, c), d) : void console.warn("Invalid argument types, or argument types do not match:", a, b)
    },
    lerp: function(a, b, c) {
        "use strict";
        return a + (b - a) * c
    },
    roundToNearestMultiple: function(a, b) {
        "use strict";
        var c = 0;
        return 0 === b ? a : (c = Math.abs(a) % b,
        0 === c ? a : 0 > a ? -(Math.abs(a) - c) : a + b - c)
    },
    arrayValuesAreEqual: function(a) {
        "use strict";
        for (var b = 0; b < a.length - 1; ++b)
            if (a[b] !== a[b + 1])
                return !1;
        return !0
    },
    randomFloat: function(a, b) {
        "use strict";
        return a + b * (Math.random() - .5)
    },
    randomVector3: function(a, b, c, d, e) {
        "use strict";
        var f = c.x + (Math.random() * d.x - .5 * d.x),
            g = c.y + (Math.random() * d.y - .5 * d.y),
            h = c.z + (Math.random() * d.z - .5 * d.z);
        e && (f = .5 * -e.x + this.roundToNearestMultiple(f, e.x), g = .5 * -e.y + this.roundToNearestMultiple(g, e.y), h = .5 * -e.z + this.roundToNearestMultiple(h, e.z)), a.typedArray.setVec3Components(b, f, g, h)
    },
    randomColor: function(a, b, c, d) {
        "use strict";
        var e = c.r + Math.random() * d.x,
            f = c.g + Math.random() * d.y,
            g = c.b + Math.random() * d.z;
        e = this.clamp(e, 0, 1), f = this.clamp(f, 0, 1), g = this.clamp(g, 0, 1), a.typedArray.setVec3Components(b, e, f, g)
    },
    randomColorAsHex: function() {
        "use strict";
        var a = new THREE.Color;
        return function(b, c, d, e) {
            for (var f = d.length, g = [], h = 0; f > h; ++h) {
                var i = e[h];
                a.copy(d[h]), a.r += Math.random() * i.x - .5 * i.x, a.g += Math.random() * i.y - .5 * i.y, a.b += Math.random() * i.z - .5 * i.z,
                a.r = this.clamp(a.r, 0, 1), a.g = this.clamp(a.g, 0, 1), a.b = this.clamp(a.b, 0, 1), g.push(a.getHex())
            }
            b.typedArray.setVec4Components(c, g[0], g[1], g[2], g[3])
        }
    }(),
    randomVector3OnSphere: function(a, b, c, d, e, f, g, h) {
        "use strict";
        var i = 2 * Math.random() - 1,
            j = 6.2832 * Math.random(),
            k = Math.sqrt(1 - i * i),
            l = this.randomFloat(d, e),
            m = 0,
            n = 0,
            o = 0;
        g && (l = Math.round(l / g) * g), m = k * Math.cos(j) * l, n = k * Math.sin(j) * l, o = i * l, m *= f.x, n *= f.y, o *= f.z, m += c.x, n += c.y, o += c.z, a.typedArray.setVec3Components(b, m, n, o)
    },
    seededRandom: function(a) {
        var b = 1e4 * Math.sin(a);
        return b - (0 | b)
    },
    randomVector3OnDisc: function(a, b, c, d, e, f, g) {
        "use strict";
        var h = 6.2832 * Math.random(),
            i = Math.abs(this.randomFloat(d, e)),
            j = 0,
            k = 0,
            l = 0;
        g && (i = Math.round(i / g) * g), j = Math.cos(h) * i, k = Math.sin(h) * i, j *= f.x, k *= f.y, j += c.x, k += c.y, l += c.z, a.typedArray.setVec3Components(b, j, k, l)
    },
    randomDirectionVector3OnSphere: function() {
        "use strict";
        var a = new THREE.Vector3;
        return function(b, c, d, e, f, g, h, i) {
            a.copy(g), a.x -= d, a.y -= e, a.z -= f, a.normalize().multiplyScalar(-this.randomFloat(h, i)), b.typedArray.setVec3Components(c, a.x, a.y, a.z);
        }
    }(),
    randomDirectionVector3OnDisc: function() {
        "use strict";
        var a = new THREE.Vector3;
        return function(b, c, d, e, f, g, h, i) {
            a.copy(g), a.x -= d, a.y -= e, a.z -= f, a.normalize().multiplyScalar(-this.randomFloat(h, i)), b.typedArray.setVec3Components(c, a.x, a.y, 0)
        }
    }(),
    getPackedRotationAxis: function() {
        "use strict";
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Color;
        return function(d, e) {
            return a.copy(d).normalize(), b.copy(e).normalize(), a.x += .5 * -e.x + Math.random() * e.x, a.y += .5 * -e.y + Math.random() * e.y, a.z += .5 * -e.z + Math.random() * e.z, a.x = Math.abs(a.x), a.y = Math.abs(a.y), a.z = Math.abs(a.z), a.normalize(), c.setRGB(a.x, a.y, a.z), c.getHex()
        }
    }()
}, SPE.Group = function(a) {
    "use strict";
    var b = SPE.utils,
        c = b.types;
    a = b.ensureTypedArg(a, c.OBJECT, {}), a.texture = b.ensureTypedArg(a.texture, c.OBJECT, {}), this.uuid = THREE.Math.generateUUID(), this.fixedTimeStep = b.ensureTypedArg(a.fixedTimeStep, c.NUMBER, .016), this.texture = b.ensureInstanceOf(a.texture.value, THREE.Texture, null), this.textureFrames = b.ensureInstanceOf(a.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1)),
    this.textureFrameCount = b.ensureTypedArg(a.texture.frameCount, c.NUMBER, this.textureFrames.x * this.textureFrames.y), this.textureLoop = b.ensureTypedArg(a.texture.loop, c.NUMBER, 1), this.textureFrames.max(new THREE.Vector2(1, 1)), this.hasPerspective = b.ensureTypedArg(a.hasPerspective, c.BOOLEAN, !0), this.colorize = b.ensureTypedArg(a.colorize, c.BOOLEAN, !0), this.maxParticleCount = b.ensureTypedArg(a.maxParticleCount, c.NUMBER, null), this.blending = b.ensureTypedArg(a.blending, c.NUMBER, THREE.AdditiveBlending), this.transparent = b.ensureTypedArg(a.transparent, c.BOOLEAN, !0), this.alphaTest = parseFloat(b.ensureTypedArg(a.alphaTest, c.NUMBER, 0)), this.depthWrite = b.ensureTypedArg(a.depthWrite, c.BOOLEAN, !1), this.depthTest = b.ensureTypedArg(a.depthTest, c.BOOLEAN, !0), this.fog = b.ensureTypedArg(a.fog, c.BOOLEAN, !0), this.scale = b.ensureTypedArg(a.scale, c.NUMBER, 300), this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !1,
    this.particleCount = 0, this.uniforms = {
        texture: {
            type: "t",
            value: this.texture
        },
        textureAnimation: {
            type: "v4",
            value: new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))
        },
        fogColor: {
            type: "c",
            value: null
        },
        fogNear: {
            type: "f",
            value: 10
        },
        fogFar: {
            type: "f",
            value: 200
        },
        fogDensity: {
            type: "f",
            value: .5
        },
        deltaTime: {
            type: "f",
            value: 0
        },
        runTime: {
            type: "f",
            value: 0
        },
        scale: {
            type: "f",
            value: this.scale
        }
    }, this.defines = {
        HAS_PERSPECTIVE: this.hasPerspective,
        COLORIZE: this.colorize,
        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,
        SHOULD_ROTATE_TEXTURE: !1,
        SHOULD_ROTATE_PARTICLES: !1,
        SHOULD_WIGGLE_PARTICLES: !1,
        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
    }, this.attributes = {
        position: new SPE.ShaderAttribute("v3", !0),
        acceleration: new SPE.ShaderAttribute("v4", !0),
        velocity: new SPE.ShaderAttribute("v3", !0),
        rotation: new SPE.ShaderAttribute("v4", !0),
        rotationCenter: new SPE.ShaderAttribute("v3", !0),
        params: new SPE.ShaderAttribute("v4", !0),
        size: new SPE.ShaderAttribute("v4", !0),
        angle: new SPE.ShaderAttribute("v4", !0),
        color: new SPE.ShaderAttribute("v4", !0),
        opacity: new SPE.ShaderAttribute("v4", !0)
    }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: SPE.shaders.vertex,
        fragmentShader: SPE.shaders.fragment,
        blending: this.blending,
        transparent: this.transparent,
        alphaTest: this.alphaTest,
        depthWrite: this.depthWrite,
        depthTest: this.depthTest,
        defines: this.defines,
        fog: this.fog
    }), this.geometry = new THREE.BufferGeometry, this.mesh = new THREE.Points(this.geometry, this.material), null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.")
}, SPE.Group.constructor = SPE.Group, SPE.Group.prototype._updateDefines = function() {
    "use strict";
    var a,
        b = this.emitters,
        c = b.length - 1,
        d = this.defines;
    for (c; c >= 0; --c)
        a = b[c], d.SHOULD_CALCULATE_SPRITE || (d.SHOULD_ROTATE_TEXTURE = d.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, a.angle.value), Math.max.apply(null, a.angle.spread))),
        d.SHOULD_ROTATE_PARTICLES = d.SHOULD_ROTATE_PARTICLES || !!Math.max(a.rotation.angle, a.rotation.angleSpread), d.SHOULD_WIGGLE_PARTICLES = d.SHOULD_WIGGLE_PARTICLES || !!Math.max(a.wiggle.value, a.wiggle.spread);
    this.material.needsUpdate = !0
}, SPE.Group.prototype._applyAttributesToGeometry = function() {
    "use strict";
    var a,
        b,
        c = this.attributes,
        d = this.geometry,
        e = d.attributes;
    for (var f in c)
        c.hasOwnProperty(f) && (a = c[f], b = e[f], b ? b.array = a.typedArray.array : d.addAttribute(f, a.bufferAttribute), a.bufferAttribute.needsUpdate = !0);
    this.geometry.setDrawRange(0, this.particleCount)
}, SPE.Group.prototype.addEmitter = function(a) {
    "use strict";
    if (a instanceof SPE.Emitter == !1)
        return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
    if (this.emitterIDs.indexOf(a.uuid) > -1)
        return void console.error("Emitter already exists in this group. Will not add again.");
    if (null !== a.group)
        return void console.error("Emitter already belongs to another group. Will not add to requested group.");
    var b = this.attributes,
        c = this.particleCount,
        d = c + a.particleCount;
    this.particleCount = d, null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), a._calculatePPSValue(a.maxAge._value + a.maxAge._spread), a._setBufferUpdateRanges(this.attributeKeys), a._setAttributeOffset(c), a.group = this, a.attributes = this.attributes;
    for (var e in b)
        b.hasOwnProperty(e) && b[e]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
    for (var f = c; d > f; ++f)
        a._assignPositionValue(f), a._assignForceValue(f, "velocity"), a._assignForceValue(f, "acceleration"), a._assignAbsLifetimeValue(f, "opacity"), a._assignAbsLifetimeValue(f, "size"), a._assignAngleValue(f), a._assignRotationValue(f), a._assignParamsValue(f), a._assignColorValue(f);
    return this._applyAttributesToGeometry(), this.emitters.push(a), this.emitterIDs.push(a.uuid), this._updateDefines(a), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0,
    this
}, SPE.Group.prototype.removeEmitter = function(a) {
    "use strict";
    var b = this.emitterIDs.indexOf(a.uuid);
    if (a instanceof SPE.Emitter == !1)
        return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
    if (-1 === b)
        return void console.error("Emitter does not exist in this group. Will not remove.");
    for (var c = a.attributeOffset, d = c + a.particleCount, e = this.attributes.params.typedArray, f = c; d > f; ++f)
        e.array[4 * f] = 0, e.array[4 * f + 1] = 0;
    this.emitters.splice(b, 1), this.emitterIDs.splice(b, 1);
    for (var g in this.attributes)
        this.attributes.hasOwnProperty(g) && this.attributes[g].splice(c, d);
    this.particleCount -= a.particleCount, a._onRemove(), this._attributesNeedRefresh = !0
}, SPE.Group.prototype.getFromPool = function() {
    "use strict";
    var a = this._pool,
        b = this._createNewWhenPoolEmpty;
    return a.length ? a.pop() : b ? new SPE.Emitter(this._poolCreationSettings) : null
}, SPE.Group.prototype.releaseIntoPool = function(a) {
    "use strict";
    return a instanceof SPE.Emitter == !1 ? void console.error("Argument is not instanceof SPE.Emitter:", a) : (a.reset(),
    this._pool.unshift(a), this)
}, SPE.Group.prototype.getPool = function() {
    "use strict";
    return this._pool
}, SPE.Group.prototype.addPool = function(a, b, c) {
    "use strict";
    var d;
    this._poolCreationSettings = b, this._createNewWhenPoolEmpty = !!c;
    for (var e = 0; a > e; ++e)
        d = Array.isArray(b) ? new SPE.Emitter(b[e]) : new SPE.Emitter(b), this.addEmitter(d), this.releaseIntoPool(d);
    return this
}, SPE.Group.prototype._triggerSingleEmitter = function(a) {
    "use strict";
    var b = this.getFromPool(),
        c = this;
    return null === b ? void console.log("SPE.Group pool ran out.") : (a instanceof THREE.Vector3 && (b.position.value.copy(a), b.position.value = b.position.value), b.enable(), setTimeout(function() {
        b.disable(), c.releaseIntoPool(b)
    }, 1e3 * (b.maxAge.value + b.maxAge.spread)), this)
}, SPE.Group.prototype.triggerPoolEmitter = function(a, b) {
    "use strict";
    if ("number" == typeof a && a > 1)
        for (var c = 0; a > c; ++c)
            this._triggerSingleEmitter(b);
    else
        this._triggerSingleEmitter(b);
    return this
}, SPE.Group.prototype._updateUniforms = function(a) {
    "use strict";
    this.uniforms.runTime.value += a,
    this.uniforms.deltaTime.value = a
}, SPE.Group.prototype._resetBufferRanges = function() {
    "use strict";
    var a = this.attributeKeys,
        b = this.attributeCount - 1,
        c = this.attributes;
    for (b; b >= 0; --b)
        c[a[b]].resetUpdateRange()
}, SPE.Group.prototype._updateBuffers = function(a) {
    "use strict";
    var b,
        c,
        d,
        e = this.attributeKeys,
        f = this.attributeCount - 1,
        g = this.attributes,
        h = a.bufferUpdateRanges;
    for (f; f >= 0; --f)
        b = e[f], c = h[b], d = g[b], d.setUpdateRange(c.min, c.max), d.flagUpdate()
}, SPE.Group.prototype.tick = function(a) {
    "use strict";
    var b,
        c = this.emitters,
        d = c.length,
        e = a || this.fixedTimeStep,
        f = this.attributeKeys,
        g = this.attributes;
    if (this._updateUniforms(e), this._resetBufferRanges(), 0 !== d || this._attributesNeedRefresh !== !1 || this._attributesNeedDynamicReset !== !1) {
        for (var h, b = 0; d > b; ++b)
            h = c[b], h.tick(e), this._updateBuffers(h);
        if (this._attributesNeedDynamicReset === !0) {
            for (b = this.attributeCount - 1; b >= 0; --b)
                g[f[b]].resetDynamic();
            this._attributesNeedDynamicReset = !1
        }
        if (this._attributesNeedRefresh === !0) {
            for (b = this.attributeCount - 1; b >= 0; --b)
                g[f[b]].forceUpdateAll();
            this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !0
        }
    }
}, SPE.Group.prototype.dispose = function() {
    "use strict";
    return this.geometry.dispose(), this.material.dispose(), this
}, SPE.Emitter = function(a) {
    "use strict";
    var b = SPE.utils,
        c = b.types,
        d = SPE.valueOverLifetimeLength;
    a = b.ensureTypedArg(a, c.OBJECT, {}), a.position = b.ensureTypedArg(a.position, c.OBJECT, {}), a.velocity = b.ensureTypedArg(a.velocity, c.OBJECT, {}), a.acceleration = b.ensureTypedArg(a.acceleration, c.OBJECT, {}), a.radius = b.ensureTypedArg(a.radius, c.OBJECT, {}), a.drag = b.ensureTypedArg(a.drag, c.OBJECT, {}), a.rotation = b.ensureTypedArg(a.rotation, c.OBJECT, {}), a.color = b.ensureTypedArg(a.color, c.OBJECT, {}), a.opacity = b.ensureTypedArg(a.opacity, c.OBJECT, {}), a.size = b.ensureTypedArg(a.size, c.OBJECT, {}), a.angle = b.ensureTypedArg(a.angle, c.OBJECT, {}), a.wiggle = b.ensureTypedArg(a.wiggle, c.OBJECT, {}), a.maxAge = b.ensureTypedArg(a.maxAge, c.OBJECT, {}), a.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."),
    this.uuid = THREE.Math.generateUUID(), this.type = b.ensureTypedArg(a.type, c.NUMBER, SPE.distributions.BOX), this.position = {
        _value: b.ensureInstanceOf(a.position.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.position.spread, THREE.Vector3, new THREE.Vector3),
        _spreadClamp: b.ensureInstanceOf(a.position.spreadClamp, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.position.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1),
        _radius: b.ensureTypedArg(a.position.radius, c.NUMBER, 10),
        _radiusScale: b.ensureInstanceOf(a.position.scale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),
        _distributionClamp: b.ensureTypedArg(a.position.distributionClamp, c.NUMBER, 0)
    }, this.velocity = {
        _value: b.ensureInstanceOf(a.velocity.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.velocity.spread, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.velocity.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.acceleration = {
        _value: b.ensureInstanceOf(a.acceleration.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.acceleration.spread, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.acceleration.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.drag = {
        _value: b.ensureTypedArg(a.drag.value, c.NUMBER, 0),
        _spread: b.ensureTypedArg(a.drag.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.wiggle = {
        _value: b.ensureTypedArg(a.wiggle.value, c.NUMBER, 0),
        _spread: b.ensureTypedArg(a.wiggle.spread, c.NUMBER, 0)
    }, this.rotation = {
        _axis: b.ensureInstanceOf(a.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)),
        _axisSpread: b.ensureInstanceOf(a.rotation.axisSpread, THREE.Vector3, new THREE.Vector3),
        _angle: b.ensureTypedArg(a.rotation.angle, c.NUMBER, 0),
        _angleSpread: b.ensureTypedArg(a.rotation.angleSpread, c.NUMBER, 0),
        _static: b.ensureTypedArg(a.rotation["static"], c.BOOLEAN, !1),
        _center: b.ensureInstanceOf(a.rotation.center, THREE.Vector3, this.position._value.clone()),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.maxAge = {
        _value: b.ensureTypedArg(a.maxAge.value, c.NUMBER, 2),
        _spread: b.ensureTypedArg(a.maxAge.spread, c.NUMBER, 0)
    }, this.color = {
        _value: b.ensureArrayInstanceOf(a.color.value, THREE.Color, new THREE.Color),
        _spread: b.ensureArrayInstanceOf(a.color.spread, THREE.Vector3, new THREE.Vector3),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.opacity = {
        _value: b.ensureArrayTypedArg(a.opacity.value, c.NUMBER, 1),
        _spread: b.ensureArrayTypedArg(a.opacity.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.size = {
        _value: b.ensureArrayTypedArg(a.size.value, c.NUMBER, 1),
        _spread: b.ensureArrayTypedArg(a.size.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.angle = {
        _value: b.ensureArrayTypedArg(a.angle.value, c.NUMBER, 0),
        _spread: b.ensureArrayTypedArg(a.angle.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.particleCount = b.ensureTypedArg(a.particleCount, c.NUMBER, 100),
    this.duration = b.ensureTypedArg(a.duration, c.NUMBER, null), this.isStatic = b.ensureTypedArg(a.isStatic, c.BOOLEAN, !1), this.activeMultiplier = b.ensureTypedArg(a.activeMultiplier, c.NUMBER, 1), this.direction = b.ensureTypedArg(a.direction, c.NUMBER, 1), this.alive = b.ensureTypedArg(a.alive, c.BOOLEAN, !0), this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.resetFlags = {
        position: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1) || b.ensureTypedArg(a.radius.randomise, c.BOOLEAN, !1),
        velocity: b.ensureTypedArg(a.velocity.randomise, c.BOOLEAN, !1),
        acceleration: b.ensureTypedArg(a.acceleration.randomise, c.BOOLEAN, !1) || b.ensureTypedArg(a.drag.randomise, c.BOOLEAN, !1),
        rotation: b.ensureTypedArg(a.rotation.randomise, c.BOOLEAN, !1),
        rotationCenter: b.ensureTypedArg(a.rotation.randomise, c.BOOLEAN, !1),
        size: b.ensureTypedArg(a.size.randomise, c.BOOLEAN, !1),
        color: b.ensureTypedArg(a.color.randomise, c.BOOLEAN, !1),
        opacity: b.ensureTypedArg(a.opacity.randomise, c.BOOLEAN, !1),
        angle: b.ensureTypedArg(a.angle.randomise, c.BOOLEAN, !1)
    }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = {
        maxAge: "params",
        position: "position",
        velocity: "velocity",
        acceleration: "acceleration",
        drag: "acceleration",
        wiggle: "params",
        rotation: "rotation",
        size: "size",
        color: "color",
        opacity: "opacity",
        angle: "angle"
    };
    for (var e in this.updateMap)
        this.updateMap.hasOwnProperty(e) && (this.updateCounts[this.updateMap[e]] = 0, this.updateFlags[this.updateMap[e]] = !1, this._createGetterSetters(this[e], e));
    this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, b.ensureValueOverLifetimeCompliance(this.color, d, d), b.ensureValueOverLifetimeCompliance(this.opacity, d, d), b.ensureValueOverLifetimeCompliance(this.size, d, d), b.ensureValueOverLifetimeCompliance(this.angle, d, d)
}, SPE.Emitter.constructor = SPE.Emitter, SPE.Emitter.prototype._createGetterSetters = function(a, b) {
    "use strict";
    var c = this;
    for (var d in a)
        if (a.hasOwnProperty(d)) {
            var e = d.replace("_", "");
            Object.defineProperty(a, e, {
                get: function(a) {
                    return function() {
                        return this[a]
                    }
                }(d),
                set: function(a) {
                    return function(d) {
                        var e = c.updateMap[b],
                            f = this[a],
                            g = SPE.valueOverLifetimeLength;
                        "_rotationCenter" === a ? (c.updateFlags.rotationCenter = !0, c.updateCounts.rotationCenter = 0) : "_randomise" === a ? c.resetFlags[e] = d : (c.updateFlags[e] = !0, c.updateCounts[e] = 0), c.group._updateDefines(), this[a] = d, Array.isArray(f) && SPE.utils.ensureValueOverLifetimeCompliance(c[b], g, g)
                    }
                }(d)
            })
        }
}, SPE.Emitter.prototype._setBufferUpdateRanges = function(a) {
    "use strict";
    this.attributeKeys = a, this.attributeCount = a.length;
    for (var b = this.attributeCount - 1; b >= 0; --b)
        this.bufferUpdateRanges[a[b]] = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        }
}, SPE.Emitter.prototype._calculatePPSValue = function(a) {
    "use strict";
    var b = this.particleCount;
    this.duration ? this.particlesPerSecond = b / (a < this.duration ? a : this.duration) : this.particlesPerSecond = b / a
}, SPE.Emitter.prototype._setAttributeOffset = function(a) {
    this.attributeOffset = a, this.activationIndex = a,
    this.activationEnd = a + this.particleCount
}, SPE.Emitter.prototype._assignValue = function(a, b) {
    "use strict";
    switch (a) {
    case "position":
        this._assignPositionValue(b);
        break;
    case "velocity":
    case "acceleration":
        this._assignForceValue(b, a);
        break;
    case "size":
    case "opacity":
        this._assignAbsLifetimeValue(b, a);
        break;
    case "angle":
        this._assignAngleValue(b);
        break;
    case "params":
        this._assignParamsValue(b);
        break;
    case "rotation":
        this._assignRotationValue(b);
        break;
    case "color":
        this._assignColorValue(b)
    }
}, SPE.Emitter.prototype._assignPositionValue = function(a) {
    "use strict";
    var b = SPE.distributions,
        c = SPE.utils,
        d = this.position,
        e = this.attributes.position,
        f = d._value,
        g = d._spread,
        h = d._distribution;
    switch (h) {
    case b.BOX:
        c.randomVector3(e, a, f, g, d._spreadClamp);
        break;
    case b.SPHERE:
        c.randomVector3OnSphere(e, a, f, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x, d._distributionClamp || this.particleCount);
        break;
    case b.DISC:
        c.randomVector3OnDisc(e, a, f, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x)
    }
}, SPE.Emitter.prototype._assignForceValue = function(a, b) {
    "use strict";
    var c,
        d,
        e,
        f,
        g,
        h = SPE.distributions,
        i = SPE.utils,
        j = this[b],
        k = j._value,
        l = j._spread,
        m = j._distribution;
    switch (m) {
    case h.BOX:
        i.randomVector3(this.attributes[b], a, k, l);
        break;
    case h.SPHERE:
        c = this.attributes.position.typedArray.array, g = 3 * a, d = c[g], e = c[g + 1], f = c[g + 2], i.randomDirectionVector3OnSphere(this.attributes[b], a, d, e, f, this.position._value, j._value.x, j._spread.x);
        break;
    case h.DISC:
        c = this.attributes.position.typedArray.array, g = 3 * a, d = c[g], e = c[g + 1], f = c[g + 2], i.randomDirectionVector3OnDisc(this.attributes[b], a, d, e, f, this.position._value, j._value.x, j._spread.x)
    }
    if ("acceleration" === b) {
        var n = i.clamp(i.randomFloat(this.drag._value, this.drag._spread), 0, 1);
        this.attributes.acceleration.typedArray.array[4 * a + 3] = n
    }
}, SPE.Emitter.prototype._assignAbsLifetimeValue = function(a, b) {
    "use strict";
    var c,
        d = this.attributes[b].typedArray,
        e = this[b],
        f = SPE.utils;
    f.arrayValuesAreEqual(e._value) && f.arrayValuesAreEqual(e._spread) ? (c = Math.abs(f.randomFloat(e._value[0], e._spread[0])), d.setVec4Components(a, c, c, c, c)) : d.setVec4Components(a, Math.abs(f.randomFloat(e._value[0], e._spread[0])), Math.abs(f.randomFloat(e._value[1], e._spread[1])), Math.abs(f.randomFloat(e._value[2], e._spread[2])), Math.abs(f.randomFloat(e._value[3], e._spread[3])));
}, SPE.Emitter.prototype._assignAngleValue = function(a) {
    "use strict";
    var b,
        c = this.attributes.angle.typedArray,
        d = this.angle,
        e = SPE.utils;
    e.arrayValuesAreEqual(d._value) && e.arrayValuesAreEqual(d._spread) ? (b = e.randomFloat(d._value[0], d._spread[0]), c.setVec4Components(a, b, b, b, b)) : c.setVec4Components(a, e.randomFloat(d._value[0], d._spread[0]), e.randomFloat(d._value[1], d._spread[1]), e.randomFloat(d._value[2], d._spread[2]), e.randomFloat(d._value[3], d._spread[3]))
}, SPE.Emitter.prototype._assignParamsValue = function(a) {
    "use strict";
    this.attributes.params.typedArray.setVec4Components(a, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread))
}, SPE.Emitter.prototype._assignRotationValue = function(a) {
    "use strict";
    this.attributes.rotation.typedArray.setVec3Components(a, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1),
    this.attributes.rotationCenter.typedArray.setVec3(a, this.rotation._center)
}, SPE.Emitter.prototype._assignColorValue = function(a) {
    "use strict";
    SPE.utils.randomColorAsHex(this.attributes.color, a, this.color._value, this.color._spread)
}, SPE.Emitter.prototype._resetParticle = function(a) {
    "use strict";
    for (var b, c, d = this.resetFlags, e = this.updateFlags, f = this.updateCounts, g = this.attributeKeys, h = this.attributeCount - 1; h >= 0; --h)
        b = g[h], c = e[b], (d[b] === !0 || c === !0) && (this._assignValue(b, a), this._updateAttributeUpdateRange(b, a), c === !0 && f[b] === this.particleCount ? (e[b] = !1, f[b] = 0) : 1 == c && ++f[b])
}, SPE.Emitter.prototype._updateAttributeUpdateRange = function(a, b) {
    "use strict";
    var c = this.bufferUpdateRanges[a];
    c.min = Math.min(b, c.min), c.max = Math.max(b, c.max)
}, SPE.Emitter.prototype._resetBufferRanges = function() {
    "use strict";
    var a,
        b = this.bufferUpdateRanges,
        c = this.bufferUpdateKeys,
        d = this.bufferUpdateCount - 1;
    for (d; d >= 0; --d)
        a = c[d], b[a].min = Number.POSITIVE_INFINITY, b[a].max = Number.NEGATIVE_INFINITY
}, SPE.Emitter.prototype._onRemove = function() {
    "use strict";
    this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.age = 0
}, SPE.Emitter.prototype._decrementParticleCount = function() {
    "use strict";
    --this.activeParticleCount
}, SPE.Emitter.prototype._incrementParticleCount = function() {
    "use strict";
    ++this.activeParticleCount
}, SPE.Emitter.prototype._checkParticleAges = function(a, b, c, d) {
    "use strict";
    for (var e, f, g, h, i = b - 1; i >= a; --i)
        e = 4 * i, h = c[e], 0 !== h && (g = c[e + 1], f = c[e + 2], 1 === this.direction ? (g += d, g >= f && (g = 0, h = 0, this._decrementParticleCount())) : (g -= d, 0 >= g && (g = f, h = 0, this._decrementParticleCount())), c[e] = h, c[e + 1] = g, this._updateAttributeUpdateRange("params", i))
}, SPE.Emitter.prototype._activateParticles = function(a, b, c, d) {
    "use strict";
    for (var e, f, g = this.direction, h = a; b > h; ++h)
        e = 4 * h, (0 == c[e] || 1 === this.particleCount) && (this._incrementParticleCount(), c[e] = 1, this._resetParticle(h), f = d * (h - a), c[e + 1] = -1 === g ? c[e + 2] - f : f, this._updateAttributeUpdateRange("params", h));
}, SPE.Emitter.prototype.tick = function(a) {
    "use strict";
    if (!this.isStatic) {
        null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
        var b = this.attributeOffset,
            c = b + this.particleCount,
            d = this.paramsArray,
            e = this.particlesPerSecond * this.activeMultiplier * a,
            f = this.activationIndex;
        if (this._resetBufferRanges(), this._checkParticleAges(b, c, d, a), this.alive === !1)
            return void (this.age = 0);
        if (null !== this.duration && this.age > this.duration)
            return this.alive = !1, void (this.age = 0);
        var g = 1 === this.particleCount ? f : 0 | f,
            h = Math.min(g + e, this.activationEnd),
            i = h - this.activationIndex | 0,
            j = i > 0 ? a / i : 0;
        this._activateParticles(g, h, d, j), this.activationIndex += e, this.activationIndex > c && (this.activationIndex = b), this.age += a
    }
}, SPE.Emitter.prototype.reset = function(a) {
    "use strict";
    if (this.age = 0, this.alive = !1, a === !0) {
        for (var b, c = this.attributeOffset, d = c + this.particleCount, e = this.paramsArray, f = this.attributes.params.bufferAttribute, g = d - 1; g >= c; --g)
            b = 4 * g, e[b] = 0, e[b + 1] = 0;
        f.updateRange.offset = 0, f.updateRange.count = -1,
        f.needsUpdate = !0
    }
    return this
}, SPE.Emitter.prototype.enable = function() {
    "use strict";
    return this.alive = !0, this
}, SPE.Emitter.prototype.disable = function() {
    "use strict";
    return this.alive = !1, this
}, SPE.Emitter.prototype.remove = function() {
    "use strict";
    return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this
};

},{}],"THREE-r72":[function(require,module,exports){
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = {
    REVISION: '72'
};

//

if ( typeof define === 'function' && define.amd ) {

    define( 'three', THREE );

}
else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

    module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

    // Missing in Android stock browser.

    ( function() {

        var lastTime = 0;
        var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

        for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x ) {

            self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
            self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

        }

        if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

            self.requestAnimationFrame = function( callback ) {

                var currTime = Date.now(),
                    timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
                var id = self.setTimeout( function() {

                    callback( currTime + timeToCall );

                }, timeToCall );
                lastTime = currTime + timeToCall;
                return id;

            };

        }

        if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

            self.cancelAnimationFrame = function( id ) {

                self.clearTimeout( id );

            };

        }

    }() );

}

if ( Math.sign === undefined ) {

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    Math.sign = function( x ) {

        return ( x < 0 ) ? -1 : ( x > 0 ) ? 1 : +x;

    };

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    Object.defineProperty( Function.prototype, 'name', {

        get: function() {

            return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

        }

    } );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// DEPRECATED

THREE.Projector = function() {

    console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    this.projectVector = function( vector, camera ) {

        console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
        vector.project( camera );

    };

    this.unprojectVector = function( vector, camera ) {

        console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
        vector.unproject( camera );

    };

    this.pickingRay = function( vector, camera ) {

        console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    };

};

THREE.CanvasRenderer = function() {

    console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    this.domElement = document.createElement( 'canvas' );
    this.clear = function() {};
    this.render = function() {};
    this.setClearColor = function() {};
    this.setSize = function() {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function( color ) {

    if ( arguments.length === 3 ) {

        return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

    }

    return this.set( color );

};

THREE.Color.prototype = {

    constructor: THREE.Color,

    r: 1,
    g: 1,
    b: 1,

    set: function( value ) {

        if ( value instanceof THREE.Color ) {

            this.copy( value );

        }
        else if ( typeof value === 'number' ) {

            this.setHex( value );

        }
        else if ( typeof value === 'string' ) {

            this.setStyle( value );

        }

        return this;

    },

    setHex: function( hex ) {

        hex = Math.floor( hex );

        this.r = ( hex >> 16 & 255 ) / 255;
        this.g = ( hex >> 8 & 255 ) / 255;
        this.b = ( hex & 255 ) / 255;

        return this;

    },

    setRGB: function( r, g, b ) {

        this.r = r;
        this.g = g;
        this.b = b;

        return this;

    },

    setHSL: function() {

        function hue2rgb( p, q, t ) {

            if ( t < 0 ) t += 1;
            if ( t > 1 ) t -= 1;
            if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
            if ( t < 1 / 2 ) return q;
            if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
            return p;

        }

        return function( h, s, l ) {

            // h,s,l ranges are in 0.0 - 1.0
            h = THREE.Math.euclideanModulo( h, 1 );
            s = THREE.Math.clamp( s, 0, 1 );
            l = THREE.Math.clamp( l, 0, 1 );

            if ( s === 0 ) {

                this.r = this.g = this.b = l;

            }
            else {

                var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
                var q = ( 2 * l ) - p;

                this.r = hue2rgb( q, p, h + 1 / 3 );
                this.g = hue2rgb( q, p, h );
                this.b = hue2rgb( q, p, h - 1 / 3 );

            }

            return this;

        };

    }(),

    setStyle: function( style ) {

        var parseAlpha = function( strAlpha ) {

            var alpha = parseFloat( strAlpha );

            if ( alpha < 1 ) {

                console.warn( 'THREE.Color: Alpha component of color ' + style + ' will be ignored.' );

            }

            return alpha;

        }


        var m;

        if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

            // rgb / hsl

            var color;
            var name = m[ 1 ];
            var components = m[ 2 ];

            switch ( name ) {

                case 'rgb':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*$/.exec( components ) ) {

                        // rgb(255,0,0)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

                        // rgb(100%,0%,0%)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

                        return this;

                    }

                    break;

                case 'rgba':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // rgba(255,0,0,0.5)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
                        parseAlpha( color[ 4 ] );

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // rgba(100%,0%,0%,0.5)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
                        parseAlpha( color[ 4 ] );

                        return this;

                    }

                    break;

                case 'hsl':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

                        // hsl(120,50%,50%)
                        var h = parseFloat( color[ 1 ] );
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;

                        return this.setHSL( h, s, l );

                    }

                    break;

                case 'hsla':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // hsla(120,50%,50%,0.5)
                        var h = parseFloat( color[ 1 ] );
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;
                        parseAlpha( color[ 4 ] );

                        return this.setHSL( h, s, l );

                    }

                    break;

            }

        }
        else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

            // hex color

            var hex = m[ 1 ];
            var size = hex.length;

            if ( size === 3 ) {

                // #ff0
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

                return this;

            }
            else if ( size === 6 ) {

                // #ff0000
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

                return this;

            }

        }

        if ( style && style.length > 0 ) {

            // color keywords
            var hex = THREE.ColorKeywords[ style ];

            if ( hex !== undefined ) {

                // red
                this.setHex( hex );

            }
            else {

                // unknown color
                console.warn( 'THREE.Color: Unknown color ' + style );

            }

        }

        return this;

    },

    clone: function() {

        return new this.constructor( this.r, this.g, this.b );

    },

    copy: function( color ) {

        this.r = color.r;
        this.g = color.g;
        this.b = color.b;

        return this;

    },

    copyGammaToLinear: function( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        this.r = Math.pow( color.r, gammaFactor );
        this.g = Math.pow( color.g, gammaFactor );
        this.b = Math.pow( color.b, gammaFactor );

        return this;

    },

    copyLinearToGamma: function( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

        this.r = Math.pow( color.r, safeInverse );
        this.g = Math.pow( color.g, safeInverse );
        this.b = Math.pow( color.b, safeInverse );

        return this;

    },

    convertGammaToLinear: function() {

        var r = this.r,
            g = this.g,
            b = this.b;

        this.r = r * r;
        this.g = g * g;
        this.b = b * b;

        return this;

    },

    convertLinearToGamma: function() {

        this.r = Math.sqrt( this.r );
        this.g = Math.sqrt( this.g );
        this.b = Math.sqrt( this.b );

        return this;

    },

    getHex: function() {

        return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    },

    getHexString: function() {

        return ( '000000' + this.getHex().toString( 16 ) ).slice( -6 );

    },

    getHSL: function( optionalTarget ) {

        // h,s,l ranges are in 0.0 - 1.0

        var hsl = optionalTarget || {
            h: 0,
            s: 0,
            l: 0
        };

        var r = this.r,
            g = this.g,
            b = this.b;

        var max = Math.max( r, g, b );
        var min = Math.min( r, g, b );

        var hue, saturation;
        var lightness = ( min + max ) / 2.0;

        if ( min === max ) {

            hue = 0;
            saturation = 0;

        }
        else {

            var delta = max - min;

            saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

            switch ( max ) {

                case r:
                    hue = ( g - b ) / delta + ( g < b ? 6 : 0 );
                    break;
                case g:
                    hue = ( b - r ) / delta + 2;
                    break;
                case b:
                    hue = ( r - g ) / delta + 4;
                    break;

            }

            hue /= 6;

        }

        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;

        return hsl;

    },

    getStyle: function() {

        return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    },

    offsetHSL: function( h, s, l ) {

        var hsl = this.getHSL();

        hsl.h += h;
        hsl.s += s;
        hsl.l += l;

        this.setHSL( hsl.h, hsl.s, hsl.l );

        return this;

    },

    add: function( color ) {

        this.r += color.r;
        this.g += color.g;
        this.b += color.b;

        return this;

    },

    addColors: function( color1, color2 ) {

        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;

        return this;

    },

    addScalar: function( s ) {

        this.r += s;
        this.g += s;
        this.b += s;

        return this;

    },

    multiply: function( color ) {

        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;

        return this;

    },

    multiplyScalar: function( s ) {

        this.r *= s;
        this.g *= s;
        this.b *= s;

        return this;

    },

    lerp: function( color, alpha ) {

        this.r += ( color.r - this.r ) * alpha;
        this.g += ( color.g - this.g ) * alpha;
        this.b += ( color.b - this.b ) * alpha;

        return this;

    },

    equals: function( c ) {

        return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    },

    fromArray: function( array ) {

        this.r = array[ 0 ];
        this.g = array[ 1 ];
        this.b = array[ 2 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.r;
        array[ offset + 1 ] = this.g;
        array[ offset + 2 ] = this.b;

        return array;

    }

};

THREE.ColorKeywords = {
    'aliceblue': 0xF0F8FF,
    'antiquewhite': 0xFAEBD7,
    'aqua': 0x00FFFF,
    'aquamarine': 0x7FFFD4,
    'azure': 0xF0FFFF,
    'beige': 0xF5F5DC,
    'bisque': 0xFFE4C4,
    'black': 0x000000,
    'blanchedalmond': 0xFFEBCD,
    'blue': 0x0000FF,
    'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A,
    'burlywood': 0xDEB887,
    'cadetblue': 0x5F9EA0,
    'chartreuse': 0x7FFF00,
    'chocolate': 0xD2691E,
    'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED,
    'cornsilk': 0xFFF8DC,
    'crimson': 0xDC143C,
    'cyan': 0x00FFFF,
    'darkblue': 0x00008B,
    'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B,
    'darkgray': 0xA9A9A9,
    'darkgreen': 0x006400,
    'darkgrey': 0xA9A9A9,
    'darkkhaki': 0xBDB76B,
    'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F,
    'darkorange': 0xFF8C00,
    'darkorchid': 0x9932CC,
    'darkred': 0x8B0000,
    'darksalmon': 0xE9967A,
    'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B,
    'darkslategray': 0x2F4F4F,
    'darkslategrey': 0x2F4F4F,
    'darkturquoise': 0x00CED1,
    'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493,
    'deepskyblue': 0x00BFFF,
    'dimgray': 0x696969,
    'dimgrey': 0x696969,
    'dodgerblue': 0x1E90FF,
    'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0,
    'forestgreen': 0x228B22,
    'fuchsia': 0xFF00FF,
    'gainsboro': 0xDCDCDC,
    'ghostwhite': 0xF8F8FF,
    'gold': 0xFFD700,
    'goldenrod': 0xDAA520,
    'gray': 0x808080,
    'green': 0x008000,
    'greenyellow': 0xADFF2F,
    'grey': 0x808080,
    'honeydew': 0xF0FFF0,
    'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C,
    'indigo': 0x4B0082,
    'ivory': 0xFFFFF0,
    'khaki': 0xF0E68C,
    'lavender': 0xE6E6FA,
    'lavenderblush': 0xFFF0F5,
    'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD,
    'lightblue': 0xADD8E6,
    'lightcoral': 0xF08080,
    'lightcyan': 0xE0FFFF,
    'lightgoldenrodyellow': 0xFAFAD2,
    'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90,
    'lightgrey': 0xD3D3D3,
    'lightpink': 0xFFB6C1,
    'lightsalmon': 0xFFA07A,
    'lightseagreen': 0x20B2AA,
    'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899,
    'lightslategrey': 0x778899,
    'lightsteelblue': 0xB0C4DE,
    'lightyellow': 0xFFFFE0,
    'lime': 0x00FF00,
    'limegreen': 0x32CD32,
    'linen': 0xFAF0E6,
    'magenta': 0xFF00FF,
    'maroon': 0x800000,
    'mediumaquamarine': 0x66CDAA,
    'mediumblue': 0x0000CD,
    'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB,
    'mediumseagreen': 0x3CB371,
    'mediumslateblue': 0x7B68EE,
    'mediumspringgreen': 0x00FA9A,
    'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585,
    'midnightblue': 0x191970,
    'mintcream': 0xF5FFFA,
    'mistyrose': 0xFFE4E1,
    'moccasin': 0xFFE4B5,
    'navajowhite': 0xFFDEAD,
    'navy': 0x000080,
    'oldlace': 0xFDF5E6,
    'olive': 0x808000,
    'olivedrab': 0x6B8E23,
    'orange': 0xFFA500,
    'orangered': 0xFF4500,
    'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA,
    'palegreen': 0x98FB98,
    'paleturquoise': 0xAFEEEE,
    'palevioletred': 0xDB7093,
    'papayawhip': 0xFFEFD5,
    'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F,
    'pink': 0xFFC0CB,
    'plum': 0xDDA0DD,
    'powderblue': 0xB0E0E6,
    'purple': 0x800080,
    'red': 0xFF0000,
    'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1,
    'saddlebrown': 0x8B4513,
    'salmon': 0xFA8072,
    'sandybrown': 0xF4A460,
    'seagreen': 0x2E8B57,
    'seashell': 0xFFF5EE,
    'sienna': 0xA0522D,
    'silver': 0xC0C0C0,
    'skyblue': 0x87CEEB,
    'slateblue': 0x6A5ACD,
    'slategray': 0x708090,
    'slategrey': 0x708090,
    'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F,
    'steelblue': 0x4682B4,
    'tan': 0xD2B48C,
    'teal': 0x008080,
    'thistle': 0xD8BFD8,
    'tomato': 0xFF6347,
    'turquoise': 0x40E0D0,
    'violet': 0xEE82EE,
    'wheat': 0xF5DEB3,
    'white': 0xFFFFFF,
    'whitesmoke': 0xF5F5F5,
    'yellow': 0xFFFF00,
    'yellowgreen': 0x9ACD32
};

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function( x, y, z, w ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

    constructor: THREE.Quaternion,

    get x() {

        return this._x;

    },

    set x( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y() {

        return this._y;

    },

    set y( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z() {

        return this._z;

    },

    set z( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get w() {

        return this._w;

    },

    set w( value ) {

        this._w = value;
        this.onChangeCallback();

    },

    set: function( x, y, z, w ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;

        this.onChangeCallback();

        return this;

    },

    clone: function() {

        return new this.constructor( this._x, this._y, this._z, this._w );

    },

    copy: function( quaternion ) {

        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;

        this.onChangeCallback();

        return this;

    },

    setFromEuler: function( euler, update ) {

        if ( euler instanceof THREE.Euler === false ) {

            throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m

        var c1 = Math.cos( euler._x / 2 );
        var c2 = Math.cos( euler._y / 2 );
        var c3 = Math.cos( euler._z / 2 );
        var s1 = Math.sin( euler._x / 2 );
        var s2 = Math.sin( euler._y / 2 );
        var s3 = Math.sin( euler._z / 2 );

        var order = euler.order;

        if ( order === 'XYZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'YXZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }
        else if ( order === 'ZXY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'ZYX' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }
        else if ( order === 'YZX' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'XZY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromAxisAngle: function( axis, angle ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

        // assumes axis is normalized

        var halfAngle = angle / 2,
            s = Math.sin( halfAngle );

        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos( halfAngle );

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements,

            m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ],
            m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ],
            m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {

            s = 0.5 / Math.sqrt( trace + 1.0 );

            this._w = 0.25 / s;
            this._x = ( m32 - m23 ) * s;
            this._y = ( m13 - m31 ) * s;
            this._z = ( m21 - m12 ) * s;

        }
        else if ( m11 > m22 && m11 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            this._w = ( m32 - m23 ) / s;
            this._x = 0.25 * s;
            this._y = ( m12 + m21 ) / s;
            this._z = ( m13 + m31 ) / s;

        }
        else if ( m22 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            this._w = ( m13 - m31 ) / s;
            this._x = ( m12 + m21 ) / s;
            this._y = 0.25 * s;
            this._z = ( m23 + m32 ) / s;

        }
        else {

            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            this._w = ( m21 - m12 ) / s;
            this._x = ( m13 + m31 ) / s;
            this._y = ( m23 + m32 ) / s;
            this._z = 0.25 * s;

        }

        this.onChangeCallback();

        return this;

    },

    setFromUnitVectors: function() {

        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

        // assumes direction vectors vFrom and vTo are normalized

        var v1, r;

        var EPS = 0.000001;

        return function( vFrom, vTo ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            r = vFrom.dot( vTo ) + 1;

            if ( r < EPS ) {

                r = 0;

                if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

                    v1.set( -vFrom.y, vFrom.x, 0 );

                }
                else {

                    v1.set( 0, -vFrom.z, vFrom.y );

                }

            }
            else {

                v1.crossVectors( vFrom, vTo );

            }

            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;

            this.normalize();

            return this;

        }

    }(),

    inverse: function() {

        this.conjugate().normalize();

        return this;

    },

    conjugate: function() {

        this._x *= -1;
        this._y *= -1;
        this._z *= -1;

        this.onChangeCallback();

        return this;

    },

    dot: function( v ) {

        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    },

    lengthSq: function() {

        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    },

    length: function() {

        return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    },

    normalize: function() {

        var l = this.length();

        if ( l === 0 ) {

            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;

        }
        else {

            l = 1 / l;

            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;

        }

        this.onChangeCallback();

        return this;

    },

    multiply: function( q, p ) {

        if ( p !== undefined ) {

            console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
            return this.multiplyQuaternions( q, p );

        }

        return this.multiplyQuaternions( this, q );

    },

    multiplyQuaternions: function( a, b ) {

        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

        var qax = a._x,
            qay = a._y,
            qaz = a._z,
            qaw = a._w;
        var qbx = b._x,
            qby = b._y,
            qbz = b._z,
            qbw = b._w;

        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        this.onChangeCallback();

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
        return vector.applyQuaternion( this );

    },

    slerp: function( qb, t ) {

        if ( t === 0 ) return this;
        if ( t === 1 ) return this.copy( qb );

        var x = this._x,
            y = this._y,
            z = this._z,
            w = this._w;

        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

        if ( cosHalfTheta < 0 ) {

            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;

            cosHalfTheta = -cosHalfTheta;

        }
        else {

            this.copy( qb );

        }

        if ( cosHalfTheta >= 1.0 ) {

            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;

            return this;

        }

        var halfTheta = Math.acos( cosHalfTheta );
        var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

        if ( Math.abs( sinHalfTheta ) < 0.001 ) {

            this._w = 0.5 * ( w + this._w );
            this._x = 0.5 * ( x + this._x );
            this._y = 0.5 * ( y + this._y );
            this._z = 0.5 * ( z + this._z );

            return this;

        }

        var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
            ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        this._w = ( w * ratioA + this._w * ratioB );
        this._x = ( x * ratioA + this._x * ratioB );
        this._y = ( y * ratioA + this._y * ratioB );
        this._z = ( z * ratioA + this._z * ratioB );

        this.onChangeCallback();

        return this;

    },

    equals: function( quaternion ) {

        return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this._x = array[ offset ];
        this._y = array[ offset + 1 ];
        this._z = array[ offset + 2 ];
        this._w = array[ offset + 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._w;

        return array;

    },

    onChange: function( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function() {}

};

THREE.Quaternion.slerp = function( qa, qb, qm, t ) {

    return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function( x, y ) {

    this.x = x || 0;
    this.y = y || 0;

};

THREE.Vector2.prototype = {

    constructor: THREE.Vector2,

    set: function( x, y ) {

        this.x = x;
        this.y = y;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;

        return this;

    },

    multiply: function( v ) {

        this.x *= v.x;
        this.y *= v.y;

        return this;

    },

    multiplyScalar: function( s ) {

        this.x *= s;
        this.y *= s;

        return this;

    },

    divide: function( v ) {

        this.x /= v.x;
        this.y /= v.y;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;

        }

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector2();
                max = new THREE.Vector2();

            }

            min.set( minVal, minVal );
            max.set( maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    distanceTo: function( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function( v ) {

        var dx = this.x - v.x,
            dy = this.y - v.y;
        return dx * dx + dy * dy;

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];

        return this;

    }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function( x, y, z ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

};

THREE.Vector3.prototype = {

    constructor: THREE.Vector3,

    set: function( x, y, z ) {

        this.x = x;
        this.y = y;
        this.z = z;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setZ: function( z ) {

        this.z = z;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y, this.z );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;
        this.z += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;

        return this;

    },

    multiply: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
            return this.multiplyVectors( v, w );

        }

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;

        return this;

    },

    multiplyScalar: function( scalar ) {

        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;

        return this;

    },

    multiplyVectors: function( a, b ) {

        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;

        return this;

    },

    applyEuler: function() {

        var quaternion;

        return function applyEuler( euler ) {

            if ( euler instanceof THREE.Euler === false ) {

                console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

            }

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromEuler( euler ) );

            return this;

        };

    }(),

    applyAxisAngle: function() {

        var quaternion;

        return function applyAxisAngle( axis, angle ) {

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

            return this;

        };

    }(),

    applyMatrix3: function( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
        this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
        this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

        return this;

    },

    applyMatrix4: function( m ) {

        // input: THREE.Matrix4 affine matrix

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ];
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ];
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

        return this;

    },

    applyProjection: function( m ) {

        // input: THREE.Matrix4 projection matrix

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;
        var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

        this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * d;
        this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * d;
        this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

        return this;

    },

    applyQuaternion: function( q ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vector

        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return this;

    },

    project: function() {

        var matrix;

        return function project( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
            return this.applyProjection( matrix );

        };

    }(),

    unproject: function() {

        var matrix;

        return function unproject( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
            return this.applyProjection( matrix );

        };

    }(),

    transformDirection: function( m ) {

        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

        this.normalize();

        return this;

    },

    divide: function( v ) {

        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;
            this.z = 0;

        }

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        if ( this.z > v.z ) {

            this.z = v.z;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        if ( this.z < v.z ) {

            this.z = v.z;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        if ( this.z < min.z ) {

            this.z = min.z;

        }
        else if ( this.z > max.z ) {

            this.z = max.z;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector3();
                max = new THREE.Vector3();

            }

            min.set( minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y + this.z * this.z;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    cross: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
            return this.crossVectors( v, w );

        }

        var x = this.x,
            y = this.y,
            z = this.z;

        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;

        return this;

    },

    crossVectors: function( a, b ) {

        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;

    },

    projectOnVector: function() {

        var v1, dot;

        return function projectOnVector( vector ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( vector ).normalize();

            dot = this.dot( v1 );

            return this.copy( v1 ).multiplyScalar( dot );

        };

    }(),

    projectOnPlane: function() {

        var v1;

        return function projectOnPlane( planeNormal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( this ).projectOnVector( planeNormal );

            return this.sub( v1 );

        }

    }(),

    reflect: function() {

        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length

        var v1;

        return function reflect( normal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

        }

    }(),

    angleTo: function( v ) {

        var theta = this.dot( v ) / ( this.length() * v.length() );

        // clamp, to handle numerical problems

        return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

    },

    distanceTo: function( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function( v ) {

        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;

        return dx * dx + dy * dy + dz * dz;

    },

    setEulerFromRotationMatrix: function( m, order ) {

        console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

    },

    setEulerFromQuaternion: function( q, order ) {

        console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

    },

    getPositionFromMatrix: function( m ) {

        console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

        return this.setFromMatrixPosition( m );

    },

    getScaleFromMatrix: function( m ) {

        console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

        return this.setFromMatrixScale( m );

    },

    getColumnFromMatrix: function( index, matrix ) {

        console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

        return this.setFromMatrixColumn( index, matrix );

    },

    setFromMatrixPosition: function( m ) {

        this.x = m.elements[ 12 ];
        this.y = m.elements[ 13 ];
        this.z = m.elements[ 14 ];

        return this;

    },

    setFromMatrixScale: function( m ) {

        var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
        var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
        var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

        this.x = sx;
        this.y = sy;
        this.z = sz;

        return this;

    },

    setFromMatrixColumn: function( index, matrix ) {

        var offset = index * 4;

        var me = matrix.elements;

        this.x = me[ offset ];
        this.y = me[ offset + 1 ];
        this.z = me[ offset + 2 ];

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];

        return this;

    }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function( x, y, z, w ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

    constructor: THREE.Vector4,

    set: function( x, y, z, w ) {

        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setZ: function( z ) {

        this.z = z;

        return this;

    },

    setW: function( w ) {

        this.w = w;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y, this.z, this.w );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = ( v.w !== undefined ) ? v.w : 1;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;

        return this;

    },

    multiplyScalar: function( scalar ) {

        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;

        return this;

    },

    applyMatrix4: function( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
        this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;
            this.w *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;

        }

        return this;

    },

    setAxisAngleFromQuaternion: function( q ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

        // q is assumed to be normalized

        this.w = 2 * Math.acos( q.w );

        var s = Math.sqrt( 1 - q.w * q.w );

        if ( s < 0.0001 ) {

            this.x = 1;
            this.y = 0;
            this.z = 0;

        }
        else {

            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;

        }

        return this;

    },

    setAxisAngleFromRotationMatrix: function( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var angle, x, y, z, // variables for result
            epsilon = 0.01, // margin to allow for rounding errors
            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees

            te = m.elements,

            m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ],
            m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ],
            m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ];

        if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) {

            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms

            if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

                // this singularity is identity matrix so angle = 0

                this.set( 1, 0, 0, 0 );

                return this; // zero angle, arbitrary axis

            }

            // otherwise this singularity is angle = 180

            angle = Math.PI;

            var xx = ( m11 + 1 ) / 2;
            var yy = ( m22 + 1 ) / 2;
            var zz = ( m33 + 1 ) / 2;
            var xy = ( m12 + m21 ) / 4;
            var xz = ( m13 + m31 ) / 4;
            var yz = ( m23 + m32 ) / 4;

            if ( ( xx > yy ) && ( xx > zz ) ) {

                // m11 is the largest diagonal term

                if ( xx < epsilon ) {

                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;

                }
                else {

                    x = Math.sqrt( xx );
                    y = xy / x;
                    z = xz / x;

                }

            }
            else if ( yy > zz ) {

                // m22 is the largest diagonal term

                if ( yy < epsilon ) {

                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;

                }
                else {

                    y = Math.sqrt( yy );
                    x = xy / y;
                    z = yz / y;

                }

            }
            else {

                // m33 is the largest diagonal term so base result on this

                if ( zz < epsilon ) {

                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;

                }
                else {

                    z = Math.sqrt( zz );
                    x = xz / z;
                    y = yz / z;

                }

            }

            this.set( x, y, z, angle );

            return this; // return 180 deg rotation

        }

        // as we have reached here there are no singularities so we can handle normally

        var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

        if ( Math.abs( s ) < 0.001 ) s = 1;

        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case

        this.x = ( m32 - m23 ) / s;
        this.y = ( m13 - m31 ) / s;
        this.z = ( m21 - m12 ) / s;
        this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        if ( this.z > v.z ) {

            this.z = v.z;

        }

        if ( this.w > v.w ) {

            this.w = v.w;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        if ( this.z < v.z ) {

            this.z = v.z;

        }

        if ( this.w < v.w ) {

            this.w = v.w;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        if ( this.z < min.z ) {

            this.z = min.z;

        }
        else if ( this.z > max.z ) {

            this.z = max.z;

        }

        if ( this.w < min.w ) {

            this.w = min.w;

        }
        else if ( this.w > max.w ) {

            this.w = max.w;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector4();
                max = new THREE.Vector4();

            }

            min.set( minVal, minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;
        this.w += ( v.w - this.w ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];
        this.w = array[ offset + 3 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;
        array[ offset + 3 ] = this.w;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];
        this.w = attribute.array[ index + 3 ];

        return this;

    }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function( x, y, z, order ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

    constructor: THREE.Euler,

    get x() {

        return this._x;

    },

    set x( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y() {

        return this._y;

    },

    set y( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z() {

        return this._z;

    },

    set z( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get order() {

        return this._order;

    },

    set order( value ) {

        this._order = value;
        this.onChangeCallback();

    },

    set: function( x, y, z, order ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;

        this.onChangeCallback();

        return this;

    },

    clone: function() {

        return new this.constructor( this._x, this._y, this._z, this._order );

    },

    copy: function( euler ) {

        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function( m, order, update ) {

        var clamp = THREE.Math.clamp;

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements;
        var m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ];
        var m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ];
        var m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ];

        order = order || this._order;

        if ( order === 'XYZ' ) {

            this._y = Math.asin( clamp( m13, -1, 1 ) );

            if ( Math.abs( m13 ) < 0.99999 ) {

                this._x = Math.atan2( -m23, m33 );
                this._z = Math.atan2( -m12, m11 );

            }
            else {

                this._x = Math.atan2( m32, m22 );
                this._z = 0;

            }

        }
        else if ( order === 'YXZ' ) {

            this._x = Math.asin( -clamp( m23, -1, 1 ) );

            if ( Math.abs( m23 ) < 0.99999 ) {

                this._y = Math.atan2( m13, m33 );
                this._z = Math.atan2( m21, m22 );

            }
            else {

                this._y = Math.atan2( -m31, m11 );
                this._z = 0;

            }

        }
        else if ( order === 'ZXY' ) {

            this._x = Math.asin( clamp( m32, -1, 1 ) );

            if ( Math.abs( m32 ) < 0.99999 ) {

                this._y = Math.atan2( -m31, m33 );
                this._z = Math.atan2( -m12, m22 );

            }
            else {

                this._y = 0;
                this._z = Math.atan2( m21, m11 );

            }

        }
        else if ( order === 'ZYX' ) {

            this._y = Math.asin( -clamp( m31, -1, 1 ) );

            if ( Math.abs( m31 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m33 );
                this._z = Math.atan2( m21, m11 );

            }
            else {

                this._x = 0;
                this._z = Math.atan2( -m12, m22 );

            }

        }
        else if ( order === 'YZX' ) {

            this._z = Math.asin( clamp( m21, -1, 1 ) );

            if ( Math.abs( m21 ) < 0.99999 ) {

                this._x = Math.atan2( -m23, m22 );
                this._y = Math.atan2( -m31, m11 );

            }
            else {

                this._x = 0;
                this._y = Math.atan2( m13, m33 );

            }

        }
        else if ( order === 'XZY' ) {

            this._z = Math.asin( -clamp( m12, -1, 1 ) );

            if ( Math.abs( m12 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m22 );
                this._y = Math.atan2( m13, m11 );

            }
            else {

                this._x = Math.atan2( -m23, m33 );
                this._y = 0;

            }

        }
        else {

            console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

        }

        this._order = order;

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromQuaternion: function() {

        var matrix;

        return function( q, order, update ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();
            matrix.makeRotationFromQuaternion( q );
            this.setFromRotationMatrix( matrix, order, update );

            return this;

        };

    }(),

    setFromVector3: function( v, order ) {

        return this.set( v.x, v.y, v.z, order || this._order );

    },

    reorder: function() {

        // WARNING: this discards revolution information -bhouston

        var q = new THREE.Quaternion();

        return function( newOrder ) {

            q.setFromEuler( this );
            this.setFromQuaternion( q, newOrder );

        };

    }(),

    equals: function( euler ) {

        return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    },

    fromArray: function( array ) {

        this._x = array[ 0 ];
        this._y = array[ 1 ];
        this._z = array[ 2 ];
        if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._order;

        return array;

    },

    toVector3: function( optionalResult ) {

        if ( optionalResult ) {

            return optionalResult.set( this._x, this._y, this._z );

        }
        else {

            return new THREE.Vector3( this._x, this._y, this._z );

        }

    },

    onChange: function( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function() {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function( start, end ) {

    this.start = ( start !== undefined ) ? start : new THREE.Vector3();
    this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

    constructor: THREE.Line3,

    set: function( start, end ) {

        this.start.copy( start );
        this.end.copy( end );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( line ) {

        this.start.copy( line.start );
        this.end.copy( line.end );

        return this;

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    },

    delta: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.end, this.start );

    },

    distanceSq: function() {

        return this.start.distanceToSquared( this.end );

    },

    distance: function() {

        return this.start.distanceTo( this.end );

    },

    at: function( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    closestPointToPointParameter: function() {

        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();

        return function( point, clampToLine ) {

            startP.subVectors( point, this.start );
            startEnd.subVectors( this.end, this.start );

            var startEnd2 = startEnd.dot( startEnd );
            var startEnd_startP = startEnd.dot( startP );

            var t = startEnd_startP / startEnd2;

            if ( clampToLine ) {

                t = THREE.Math.clamp( t, 0, 1 );

            }

            return t;

        };

    }(),

    closestPointToPoint: function( point, clampToLine, optionalTarget ) {

        var t = this.closestPointToPointParameter( point, clampToLine );

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    applyMatrix4: function( matrix ) {

        this.start.applyMatrix4( matrix );
        this.end.applyMatrix4( matrix );

        return this;

    },

    equals: function( line ) {

        return line.start.equals( this.start ) && line.end.equals( this.end );

    }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.Box2.prototype = {

    constructor: THREE.Box2,

    set: function( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i++ ) {

            this.expandByPoint( points[ i ] )

        }

        return this;

    },

    setFromCenterAndSize: function() {

        var v1 = new THREE.Vector2();

        return function( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function() {

        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;

        return this;

    },

    empty: function() {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function( scalar ) {

        this.min.addScalar( -scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ) {

            return false;

        }

        return true;

    },

    containsBox: function( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

            return true;

        }

        return false;

    },

    getParameter: function( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector2();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ), ( point.y - this.min.y ) / ( this.max.y - this.min.y )
        );

    },

    isIntersectionBox: function( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ) {

            return false;

        }

        return true;

    },

    clampPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function() {

        var v1 = new THREE.Vector2();

        return function( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    intersect: function( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    translate: function( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.Box3.prototype = {

    constructor: THREE.Box3,

    set: function( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i++ ) {

            this.expandByPoint( points[ i ] );

        }

        return this;

    },

    setFromCenterAndSize: function() {

        var v1 = new THREE.Vector3();

        return function( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    setFromObject: function() {

        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms

        var v1 = new THREE.Vector3();

        return function( object ) {

            var scope = this;

            object.updateMatrixWorld( true );

            this.makeEmpty();

            object.traverse( function( node ) {

                var geometry = node.geometry;

                if ( geometry !== undefined ) {

                    if ( geometry instanceof THREE.Geometry ) {

                        var vertices = geometry.vertices;

                        for ( var i = 0, il = vertices.length; i < il; i++ ) {

                            v1.copy( vertices[ i ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }
                    else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

                        var positions = geometry.attributes[ 'position' ].array;

                        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                            v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }

                }

            } );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function() {

        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;

        return this;

    },

    empty: function() {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function( scalar ) {

        this.min.addScalar( -scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ||
            point.z < this.min.z || point.z > this.max.z ) {

            return false;

        }

        return true;

    },

    containsBox: function( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
            ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

            return true;

        }

        return false;

    },

    getParameter: function( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector3();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ), ( point.y - this.min.y ) / ( this.max.y - this.min.y ), ( point.z - this.min.z ) / ( this.max.z - this.min.z )
        );

    },

    isIntersectionBox: function( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ||
            box.max.z < this.min.z || box.min.z > this.max.z ) {

            return false;

        }

        return true;

    },

    clampPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function() {

        var v1 = new THREE.Vector3();

        return function( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    getBoundingSphere: function() {

        var v1 = new THREE.Vector3();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Sphere();

            result.center = this.center();
            result.radius = this.size( v1 ).length() * 0.5;

            return result;

        };

    }(),

    intersect: function( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    applyMatrix4: function() {

        var points = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];

        return function( matrix ) {

            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
            points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
            points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
            points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
            points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
            points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
            points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
            points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

            this.makeEmpty();
            this.setFromPoints( points );

            return this;

        };

    }(),

    translate: function( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function() {

    this.elements = new Float32Array( [

        1, 0, 0,
        0, 1, 0,
        0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix3.prototype = {

    constructor: THREE.Matrix3,

    set: function( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

        var te = this.elements;

        te[ 0 ] = n11;
        te[ 3 ] = n12;
        te[ 6 ] = n13;
        te[ 1 ] = n21;
        te[ 4 ] = n22;
        te[ 7 ] = n23;
        te[ 2 ] = n31;
        te[ 5 ] = n32;
        te[ 8 ] = n33;

        return this;

    },

    identity: function() {

        this.set(

            1, 0, 0,
            0, 1, 0,
            0, 0, 1

        );

        return this;

    },

    clone: function() {

        return new this.constructor().fromArray( this.elements );

    },

    copy: function( m ) {

        var me = m.elements;

        this.set(

            me[ 0 ], me[ 3 ], me[ 6 ],
            me[ 1 ], me[ 4 ], me[ 7 ],
            me[ 2 ], me[ 5 ], me[ 8 ]

        );

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
        return vector.applyMatrix3( this );

    },

    multiplyVector3Array: function( a ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function() {

        var v1;

        return function( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix3( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function() {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i++, j++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix3( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    multiplyScalar: function( s ) {

        var te = this.elements;

        te[ 0 ] *= s;
        te[ 3 ] *= s;
        te[ 6 ] *= s;
        te[ 1 ] *= s;
        te[ 4 ] *= s;
        te[ 7 ] *= s;
        te[ 2 ] *= s;
        te[ 5 ] *= s;
        te[ 8 ] *= s;

        return this;

    },

    determinant: function() {

        var te = this.elements;

        var a = te[ 0 ],
            b = te[ 1 ],
            c = te[ 2 ],
            d = te[ 3 ],
            e = te[ 4 ],
            f = te[ 5 ],
            g = te[ 6 ],
            h = te[ 7 ],
            i = te[ 8 ];

        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    },

    getInverse: function( matrix, throwOnInvertible ) {

        // input: THREE.Matrix4
        // ( based on http://code.google.com/p/webgl-mjs/ )

        var me = matrix.elements;
        var te = this.elements;

        te[ 0 ] = me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
        te[ 1 ] = -me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
        te[ 2 ] = me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
        te[ 3 ] = -me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
        te[ 4 ] = me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
        te[ 5 ] = -me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
        te[ 6 ] = me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
        te[ 7 ] = -me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
        te[ 8 ] = me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

        // no inverse

        if ( det === 0 ) {

            var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            }
            else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1.0 / det );

        return this;

    },

    transpose: function() {

        var tmp, m = this.elements;

        tmp = m[ 1 ];
        m[ 1 ] = m[ 3 ];
        m[ 3 ] = tmp;
        tmp = m[ 2 ];
        m[ 2 ] = m[ 6 ];
        m[ 6 ] = tmp;
        tmp = m[ 5 ];
        m[ 5 ] = m[ 7 ];
        m[ 7 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ] = te[ 8 ];

        return array;

    },

    getNormalMatrix: function( m ) {

        // input: THREE.Matrix4

        this.getInverse( m ).transpose();

        return this;

    },

    transposeIntoArray: function( r ) {

        var m = this.elements;

        r[ 0 ] = m[ 0 ];
        r[ 1 ] = m[ 3 ];
        r[ 2 ] = m[ 6 ];
        r[ 3 ] = m[ 1 ];
        r[ 4 ] = m[ 4 ];
        r[ 5 ] = m[ 7 ];
        r[ 6 ] = m[ 2 ];
        r[ 7 ] = m[ 5 ];
        r[ 8 ] = m[ 8 ];

        return this;

    },

    fromArray: function( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function() {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ],
            te[ 3 ], te[ 4 ], te[ 5 ],
            te[ 6 ], te[ 7 ], te[ 8 ]
        ];

    }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function() {

    this.elements = new Float32Array( [

        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix4.prototype = {

    constructor: THREE.Matrix4,

    set: function( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

        var te = this.elements;

        te[ 0 ] = n11;
        te[ 4 ] = n12;
        te[ 8 ] = n13;
        te[ 12 ] = n14;
        te[ 1 ] = n21;
        te[ 5 ] = n22;
        te[ 9 ] = n23;
        te[ 13 ] = n24;
        te[ 2 ] = n31;
        te[ 6 ] = n32;
        te[ 10 ] = n33;
        te[ 14 ] = n34;
        te[ 3 ] = n41;
        te[ 7 ] = n42;
        te[ 11 ] = n43;
        te[ 15 ] = n44;

        return this;

    },

    identity: function() {

        this.set(

            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    clone: function() {

        return new THREE.Matrix4().fromArray( this.elements );

    },

    copy: function( m ) {

        this.elements.set( m.elements );

        return this;

    },

    extractPosition: function( m ) {

        console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
        return this.copyPosition( m );

    },

    copyPosition: function( m ) {

        var te = this.elements;
        var me = m.elements;

        te[ 12 ] = me[ 12 ];
        te[ 13 ] = me[ 13 ];
        te[ 14 ] = me[ 14 ];

        return this;

    },

    extractBasis: function( xAxis, yAxis, zAxis ) {

        var te = this.elements;

        xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
        yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
        zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

        return this;

    },

    makeBasis: function( xAxis, yAxis, zAxis ) {

        this.set(
            xAxis.x, yAxis.x, zAxis.x, 0,
            xAxis.y, yAxis.y, zAxis.y, 0,
            xAxis.z, yAxis.z, zAxis.z, 0,
            0, 0, 0, 1
        );

        return this;

    },

    extractRotation: function() {

        var v1;

        return function( m ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            var te = this.elements;
            var me = m.elements;

            var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
            var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
            var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

            te[ 0 ] = me[ 0 ] * scaleX;
            te[ 1 ] = me[ 1 ] * scaleX;
            te[ 2 ] = me[ 2 ] * scaleX;

            te[ 4 ] = me[ 4 ] * scaleY;
            te[ 5 ] = me[ 5 ] * scaleY;
            te[ 6 ] = me[ 6 ] * scaleY;

            te[ 8 ] = me[ 8 ] * scaleZ;
            te[ 9 ] = me[ 9 ] * scaleZ;
            te[ 10 ] = me[ 10 ] * scaleZ;

            return this;

        };

    }(),

    makeRotationFromEuler: function( euler ) {

        if ( euler instanceof THREE.Euler === false ) {

            console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        var te = this.elements;

        var x = euler.x,
            y = euler.y,
            z = euler.z;
        var a = Math.cos( x ),
            b = Math.sin( x );
        var c = Math.cos( y ),
            d = Math.sin( y );
        var e = Math.cos( z ),
            f = Math.sin( z );

        if ( euler.order === 'XYZ' ) {

            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = -c * f;
            te[ 8 ] = d;

            te[ 1 ] = af + be * d;
            te[ 5 ] = ae - bf * d;
            te[ 9 ] = -b * c;

            te[ 2 ] = bf - ae * d;
            te[ 6 ] = be + af * d;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'YXZ' ) {

            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;

            te[ 0 ] = ce + df * b;
            te[ 4 ] = de * b - cf;
            te[ 8 ] = a * d;

            te[ 1 ] = a * f;
            te[ 5 ] = a * e;
            te[ 9 ] = -b;

            te[ 2 ] = cf * b - de;
            te[ 6 ] = df + ce * b;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'ZXY' ) {

            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;

            te[ 0 ] = ce - df * b;
            te[ 4 ] = -a * f;
            te[ 8 ] = de + cf * b;

            te[ 1 ] = cf + de * b;
            te[ 5 ] = a * e;
            te[ 9 ] = df - ce * b;

            te[ 2 ] = -a * d;
            te[ 6 ] = b;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'ZYX' ) {

            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = be * d - af;
            te[ 8 ] = ae * d + bf;

            te[ 1 ] = c * f;
            te[ 5 ] = bf * d + ae;
            te[ 9 ] = af * d - be;

            te[ 2 ] = -d;
            te[ 6 ] = b * c;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'YZX' ) {

            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = bd - ac * f;
            te[ 8 ] = bc * f + ad;

            te[ 1 ] = f;
            te[ 5 ] = a * e;
            te[ 9 ] = -b * e;

            te[ 2 ] = -d * e;
            te[ 6 ] = ad * f + bc;
            te[ 10 ] = ac - bd * f;

        }
        else if ( euler.order === 'XZY' ) {

            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = -f;
            te[ 8 ] = d * e;

            te[ 1 ] = ac * f + bd;
            te[ 5 ] = a * e;
            te[ 9 ] = ad * f - bc;

            te[ 2 ] = bc * f - ad;
            te[ 6 ] = b * e;
            te[ 10 ] = bd * f + ac;

        }

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    setRotationFromQuaternion: function( q ) {

        console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

        return this.makeRotationFromQuaternion( q );

    },

    makeRotationFromQuaternion: function( q ) {

        var te = this.elements;

        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        te[ 0 ] = 1 - ( yy + zz );
        te[ 4 ] = xy - wz;
        te[ 8 ] = xz + wy;

        te[ 1 ] = xy + wz;
        te[ 5 ] = 1 - ( xx + zz );
        te[ 9 ] = yz - wx;

        te[ 2 ] = xz - wy;
        te[ 6 ] = yz + wx;
        te[ 10 ] = 1 - ( xx + yy );

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    lookAt: function() {

        var x, y, z;

        return function( eye, target, up ) {

            if ( x === undefined ) x = new THREE.Vector3();
            if ( y === undefined ) y = new THREE.Vector3();
            if ( z === undefined ) z = new THREE.Vector3();

            var te = this.elements;

            z.subVectors( eye, target ).normalize();

            if ( z.length() === 0 ) {

                z.z = 1;

            }

            x.crossVectors( up, z ).normalize();

            if ( x.length() === 0 ) {

                z.x += 0.0001;
                x.crossVectors( up, z ).normalize();

            }

            y.crossVectors( z, x );


            te[ 0 ] = x.x;
            te[ 4 ] = y.x;
            te[ 8 ] = z.x;
            te[ 1 ] = x.y;
            te[ 5 ] = y.y;
            te[ 9 ] = z.y;
            te[ 2 ] = x.z;
            te[ 6 ] = y.z;
            te[ 10 ] = z.z;

            return this;

        };

    }(),

    multiply: function( m, n ) {

        if ( n !== undefined ) {

            console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
            return this.multiplyMatrices( m, n );

        }

        return this.multiplyMatrices( this, m );

    },

    multiplyMatrices: function( a, b ) {

        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;

        var a11 = ae[ 0 ],
            a12 = ae[ 4 ],
            a13 = ae[ 8 ],
            a14 = ae[ 12 ];
        var a21 = ae[ 1 ],
            a22 = ae[ 5 ],
            a23 = ae[ 9 ],
            a24 = ae[ 13 ];
        var a31 = ae[ 2 ],
            a32 = ae[ 6 ],
            a33 = ae[ 10 ],
            a34 = ae[ 14 ];
        var a41 = ae[ 3 ],
            a42 = ae[ 7 ],
            a43 = ae[ 11 ],
            a44 = ae[ 15 ];

        var b11 = be[ 0 ],
            b12 = be[ 4 ],
            b13 = be[ 8 ],
            b14 = be[ 12 ];
        var b21 = be[ 1 ],
            b22 = be[ 5 ],
            b23 = be[ 9 ],
            b24 = be[ 13 ];
        var b31 = be[ 2 ],
            b32 = be[ 6 ],
            b33 = be[ 10 ],
            b34 = be[ 14 ];
        var b41 = be[ 3 ],
            b42 = be[ 7 ],
            b43 = be[ 11 ],
            b44 = be[ 15 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

        te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

        return this;

    },

    multiplyToArray: function( a, b, r ) {

        var te = this.elements;

        this.multiplyMatrices( a, b );

        r[ 0 ] = te[ 0 ];
        r[ 1 ] = te[ 1 ];
        r[ 2 ] = te[ 2 ];
        r[ 3 ] = te[ 3 ];
        r[ 4 ] = te[ 4 ];
        r[ 5 ] = te[ 5 ];
        r[ 6 ] = te[ 6 ];
        r[ 7 ] = te[ 7 ];
        r[ 8 ] = te[ 8 ];
        r[ 9 ] = te[ 9 ];
        r[ 10 ] = te[ 10 ];
        r[ 11 ] = te[ 11 ];
        r[ 12 ] = te[ 12 ];
        r[ 13 ] = te[ 13 ];
        r[ 14 ] = te[ 14 ];
        r[ 15 ] = te[ 15 ];

        return this;

    },

    multiplyScalar: function( s ) {

        var te = this.elements;

        te[ 0 ] *= s;
        te[ 4 ] *= s;
        te[ 8 ] *= s;
        te[ 12 ] *= s;
        te[ 1 ] *= s;
        te[ 5 ] *= s;
        te[ 9 ] *= s;
        te[ 13 ] *= s;
        te[ 2 ] *= s;
        te[ 6 ] *= s;
        te[ 10 ] *= s;
        te[ 14 ] *= s;
        te[ 3 ] *= s;
        te[ 7 ] *= s;
        te[ 11 ] *= s;
        te[ 15 ] *= s;

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
        return vector.applyProjection( this );

    },

    multiplyVector4: function( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    multiplyVector3Array: function( a ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function() {

        var v1;

        return function( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix4( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function() {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i++, j++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix4( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    rotateAxis: function( v ) {

        console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

        v.transformDirection( this );

    },

    crossVector: function( vector ) {

        console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    determinant: function() {

        var te = this.elements;

        var n11 = te[ 0 ],
            n12 = te[ 4 ],
            n13 = te[ 8 ],
            n14 = te[ 12 ];
        var n21 = te[ 1 ],
            n22 = te[ 5 ],
            n23 = te[ 9 ],
            n24 = te[ 13 ];
        var n31 = te[ 2 ],
            n32 = te[ 6 ],
            n33 = te[ 10 ],
            n34 = te[ 14 ];
        var n41 = te[ 3 ],
            n42 = te[ 7 ],
            n43 = te[ 11 ],
            n44 = te[ 15 ];

        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

        return (
            n41 * ( +n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34 ) +
            n42 * ( +n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31 ) +
            n43 * ( +n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31 ) +
            n44 * ( -n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31 )

        );

    },

    transpose: function() {

        var te = this.elements;
        var tmp;

        tmp = te[ 1 ];
        te[ 1 ] = te[ 4 ];
        te[ 4 ] = tmp;
        tmp = te[ 2 ];
        te[ 2 ] = te[ 8 ];
        te[ 8 ] = tmp;
        tmp = te[ 6 ];
        te[ 6 ] = te[ 9 ];
        te[ 9 ] = tmp;

        tmp = te[ 3 ];
        te[ 3 ] = te[ 12 ];
        te[ 12 ] = tmp;
        tmp = te[ 7 ];
        te[ 7 ] = te[ 13 ];
        te[ 13 ] = tmp;
        tmp = te[ 11 ];
        te[ 11 ] = te[ 14 ];
        te[ 14 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];
        array[ offset + 3 ] = te[ 3 ];

        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];
        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];

        array[ offset + 8 ] = te[ 8 ];
        array[ offset + 9 ] = te[ 9 ];
        array[ offset + 10 ] = te[ 10 ];
        array[ offset + 11 ] = te[ 11 ];

        array[ offset + 12 ] = te[ 12 ];
        array[ offset + 13 ] = te[ 13 ];
        array[ offset + 14 ] = te[ 14 ];
        array[ offset + 15 ] = te[ 15 ];

        return array;

    },

    getPosition: function() {

        var v1;

        return function() {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

            var te = this.elements;
            return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

        };

    }(),

    setPosition: function( v ) {

        var te = this.elements;

        te[ 12 ] = v.x;
        te[ 13 ] = v.y;
        te[ 14 ] = v.z;

        return this;

    },

    getInverse: function( m, throwOnInvertible ) {

        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements;
        var me = m.elements;

        var n11 = me[ 0 ],
            n12 = me[ 4 ],
            n13 = me[ 8 ],
            n14 = me[ 12 ];
        var n21 = me[ 1 ],
            n22 = me[ 5 ],
            n23 = me[ 9 ],
            n24 = me[ 13 ];
        var n31 = me[ 2 ],
            n32 = me[ 6 ],
            n33 = me[ 10 ],
            n34 = me[ 14 ];
        var n41 = me[ 3 ],
            n42 = me[ 7 ],
            n43 = me[ 11 ],
            n44 = me[ 15 ];

        te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

        var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

        if ( det === 0 ) {

            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            }
            else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1 / det );

        return this;

    },

    translate: function( v ) {

        console.error( 'THREE.Matrix4: .translate() has been removed.' );

    },

    rotateX: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

    },

    rotateY: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

    },

    rotateZ: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

    },

    rotateByAxis: function( axis, angle ) {

        console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

    },

    scale: function( v ) {

        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;

        te[ 0 ] *= x;
        te[ 4 ] *= y;
        te[ 8 ] *= z;
        te[ 1 ] *= x;
        te[ 5 ] *= y;
        te[ 9 ] *= z;
        te[ 2 ] *= x;
        te[ 6 ] *= y;
        te[ 10 ] *= z;
        te[ 3 ] *= x;
        te[ 7 ] *= y;
        te[ 11 ] *= z;

        return this;

    },

    getMaxScaleOnAxis: function() {

        var te = this.elements;

        var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
        var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
        var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

        return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

    },

    makeTranslation: function( x, y, z ) {

        this.set(

            1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationX: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            1, 0, 0, 0,
            0, c, -s, 0,
            0, s, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationY: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            c, 0, s, 0,
            0, 1, 0, 0, -s, 0, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationZ: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            c, -s, 0, 0,
            s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationAxis: function( axis, angle ) {

        // Based on http://www.gamedev.net/reference/articles/article1199.asp

        var c = Math.cos( angle );
        var s = Math.sin( angle );
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;

        this.set(

            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeScale: function( x, y, z ) {

        this.set(

            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1

        );

        return this;

    },

    compose: function( position, quaternion, scale ) {

        this.makeRotationFromQuaternion( quaternion );
        this.scale( scale );
        this.setPosition( position );

        return this;

    },

    decompose: function() {

        var vector, matrix;

        return function( position, quaternion, scale ) {

            if ( vector === undefined ) vector = new THREE.Vector3();
            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            var te = this.elements;

            var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
            var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
            var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if ( det < 0 ) {

                sx = -sx;

            }

            position.x = te[ 12 ];
            position.y = te[ 13 ];
            position.z = te[ 14 ];

            // scale the rotation part

            matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;

            matrix.elements[ 0 ] *= invSX;
            matrix.elements[ 1 ] *= invSX;
            matrix.elements[ 2 ] *= invSX;

            matrix.elements[ 4 ] *= invSY;
            matrix.elements[ 5 ] *= invSY;
            matrix.elements[ 6 ] *= invSY;

            matrix.elements[ 8 ] *= invSZ;
            matrix.elements[ 9 ] *= invSZ;
            matrix.elements[ 10 ] *= invSZ;

            quaternion.setFromRotationMatrix( matrix );

            scale.x = sx;
            scale.y = sy;
            scale.z = sz;

            return this;

        };

    }(),

    makeFrustum: function( left, right, bottom, top, near, far ) {

        var te = this.elements;
        var x = 2 * near / ( right - left );
        var y = 2 * near / ( top - bottom );

        var a = ( right + left ) / ( right - left );
        var b = ( top + bottom ) / ( top - bottom );
        var c = -( far + near ) / ( far - near );
        var d = -2 * far * near / ( far - near );

        te[ 0 ] = x;
        te[ 4 ] = 0;
        te[ 8 ] = a;
        te[ 12 ] = 0;
        te[ 1 ] = 0;
        te[ 5 ] = y;
        te[ 9 ] = b;
        te[ 13 ] = 0;
        te[ 2 ] = 0;
        te[ 6 ] = 0;
        te[ 10 ] = c;
        te[ 14 ] = d;
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = -1;
        te[ 15 ] = 0;

        return this;

    },

    makePerspective: function( fov, aspect, near, far ) {

        var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;

        return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    },

    makeOrthographic: function( left, right, top, bottom, near, far ) {

        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;

        var x = ( right + left ) / w;
        var y = ( top + bottom ) / h;
        var z = ( far + near ) / p;

        te[ 0 ] = 2 / w;
        te[ 4 ] = 0;
        te[ 8 ] = 0;
        te[ 12 ] = -x;
        te[ 1 ] = 0;
        te[ 5 ] = 2 / h;
        te[ 9 ] = 0;
        te[ 13 ] = -y;
        te[ 2 ] = 0;
        te[ 6 ] = 0;
        te[ 10 ] = -2 / p;
        te[ 14 ] = -z;
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    equals: function( matrix ) {

        var te = this.elements;
        var me = matrix.elements;

        for ( var i = 0; i < 16; i++ ) {

            if ( te[ i ] !== me[ i ] ) return false;

        }

        return true;

    },

    fromArray: function( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function() {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
            te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
            te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
            te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
        ];

    }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function( origin, direction ) {

    this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
    this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

    constructor: THREE.Ray,

    set: function( origin, direction ) {

        this.origin.copy( origin );
        this.direction.copy( direction );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( ray ) {

        this.origin.copy( ray.origin );
        this.direction.copy( ray.direction );

        return this;

    },

    at: function( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    },

    recast: function() {

        var v1 = new THREE.Vector3();

        return function( t ) {

            this.origin.copy( this.at( t, v1 ) );

            return this;

        };

    }(),

    closestPointToPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        result.subVectors( point, this.origin );
        var directionDistance = result.dot( this.direction );

        if ( directionDistance < 0 ) {

            return result.copy( this.origin );

        }

        return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    },

    distanceToPoint: function( point ) {

        return Math.sqrt( this.distanceSqToPoint( point ) );

    },

    distanceSqToPoint: function() {

        var v1 = new THREE.Vector3();

        return function( point ) {

            var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

            // point behind the ray

            if ( directionDistance < 0 ) {

                return this.origin.distanceToSquared( point );

            }

            v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

            return v1.distanceToSquared( point );

        };

    }(),

    distanceSqToSegment: function() {

        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();

        return function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

            // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment

            segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
            segDir.copy( v1 ).sub( v0 ).normalize();
            diff.copy( this.origin ).sub( segCenter );

            var segExtent = v0.distanceTo( v1 ) * 0.5;
            var a01 = -this.direction.dot( segDir );
            var b0 = diff.dot( this.direction );
            var b1 = -diff.dot( segDir );
            var c = diff.lengthSq();
            var det = Math.abs( 1 - a01 * a01 );
            var s0, s1, sqrDist, extDet;

            if ( det > 0 ) {

                // The ray and segment are not parallel.

                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;

                if ( s0 >= 0 ) {

                    if ( s1 >= -extDet ) {

                        if ( s1 <= extDet ) {

                            // region 0
                            // Minimum at interior points of ray and segment.

                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

                        }
                        else {

                            // region 1

                            s1 = segExtent;
                            s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                            sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                        }

                    }
                    else {

                        // region 5

                        s1 = -segExtent;
                        s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }
                else {

                    if ( s1 <= -extDet ) {

                        // region 4

                        s0 = Math.max( 0, -( -a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? -segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }
                    else if ( s1 <= extDet ) {

                        // region 3

                        s0 = 0;
                        s1 = Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = s1 * ( s1 + 2 * b1 ) + c;

                    }
                    else {

                        // region 2

                        s0 = Math.max( 0, -( a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }

            }
            else {

                // Ray and segment are parallel.

                s1 = ( a01 > 0 ) ? -segExtent : segExtent;
                s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

            if ( optionalPointOnRay ) {

                optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

            }

            if ( optionalPointOnSegment ) {

                optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

            }

            return sqrDist;

        };

    }(),


    isIntersectionSphere: function( sphere ) {

        return this.distanceToPoint( sphere.center ) <= sphere.radius;

    },

    intersectSphere: function() {

        // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

        var v1 = new THREE.Vector3();

        return function( sphere, optionalTarget ) {

            v1.subVectors( sphere.center, this.origin );

            var tca = v1.dot( this.direction );

            var d2 = v1.dot( v1 ) - tca * tca;

            var radius2 = sphere.radius * sphere.radius;

            if ( d2 > radius2 ) return null;

            var thc = Math.sqrt( radius2 - d2 );

            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;

            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;

            // test to see if both t0 and t1 are behind the ray - if so, return null
            if ( t0 < 0 && t1 < 0 ) return null;

            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if ( t0 < 0 ) return this.at( t1, optionalTarget );

            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at( t0, optionalTarget );

        }

    }(),

    isIntersectionPlane: function( plane ) {

        // check if the ray lies on the plane first

        var distToPoint = plane.distanceToPoint( this.origin );

        if ( distToPoint === 0 ) {

            return true;

        }

        var denominator = plane.normal.dot( this.direction );

        if ( denominator * distToPoint < 0 ) {

            return true;

        }

        // ray origin is behind the plane (and is pointing behind it)

        return false;

    },

    distanceToPlane: function( plane ) {

        var denominator = plane.normal.dot( this.direction );
        if ( denominator === 0 ) {

            // line is coplanar, return origin
            if ( plane.distanceToPoint( this.origin ) === 0 ) {

                return 0;

            }

            // Null is preferable to undefined since undefined means.... it is undefined

            return null;

        }

        var t = -( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

        // Return if the ray never intersects the plane

        return t >= 0 ? t : null;

    },

    intersectPlane: function( plane, optionalTarget ) {

        var t = this.distanceToPlane( plane );

        if ( t === null ) {

            return null;

        }

        return this.at( t, optionalTarget );

    },

    isIntersectionBox: function() {

        var v = new THREE.Vector3();

        return function( box ) {

            return this.intersectBox( box, v ) !== null;

        };

    }(),

    intersectBox: function( box, optionalTarget ) {

        // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

        var tmin, tmax, tymin, tymax, tzmin, tzmax;

        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;

        var origin = this.origin;

        if ( invdirx >= 0 ) {

            tmin = ( box.min.x - origin.x ) * invdirx;
            tmax = ( box.max.x - origin.x ) * invdirx;

        }
        else {

            tmin = ( box.max.x - origin.x ) * invdirx;
            tmax = ( box.min.x - origin.x ) * invdirx;

        }

        if ( invdiry >= 0 ) {

            tymin = ( box.min.y - origin.y ) * invdiry;
            tymax = ( box.max.y - origin.y ) * invdiry;

        }
        else {

            tymin = ( box.max.y - origin.y ) * invdiry;
            tymax = ( box.min.y - origin.y ) * invdiry;

        }

        if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

        if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

        if ( invdirz >= 0 ) {

            tzmin = ( box.min.z - origin.z ) * invdirz;
            tzmax = ( box.max.z - origin.z ) * invdirz;

        }
        else {

            tzmin = ( box.max.z - origin.z ) * invdirz;
            tzmax = ( box.min.z - origin.z ) * invdirz;

        }

        if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

        if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

        if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

        //return point closest to the ray (positive side)

        if ( tmax < 0 ) return null;

        return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    },

    intersectTriangle: function() {

        // Compute the offset origin, edges, and normal.
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();

        return function( a, b, c, backfaceCulling, optionalTarget ) {

            // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

            edge1.subVectors( b, a );
            edge2.subVectors( c, a );
            normal.crossVectors( edge1, edge2 );

            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot( normal );
            var sign;

            if ( DdN > 0 ) {

                if ( backfaceCulling ) return null;
                sign = 1;

            }
            else if ( DdN < 0 ) {

                sign = -1;
                DdN = -DdN;

            }
            else {

                return null;

            }

            diff.subVectors( this.origin, a );
            var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

            // b1 < 0, no intersection
            if ( DdQxE2 < 0 ) {

                return null;

            }

            var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

            // b2 < 0, no intersection
            if ( DdE1xQ < 0 ) {

                return null;

            }

            // b1+b2 > 1, no intersection
            if ( DdQxE2 + DdE1xQ > DdN ) {

                return null;

            }

            // Line intersects triangle, check if ray does.
            var QdN = -sign * diff.dot( normal );

            // t < 0, no intersection
            if ( QdN < 0 ) {

                return null;

            }

            // Ray intersects triangle.
            return this.at( QdN / DdN, optionalTarget );

        };

    }(),

    applyMatrix4: function( matrix4 ) {

        this.direction.add( this.origin ).applyMatrix4( matrix4 );
        this.origin.applyMatrix4( matrix4 );
        this.direction.sub( this.origin );
        this.direction.normalize();

        return this;

    },

    equals: function( ray ) {

        return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function( center, radius ) {

    this.center = ( center !== undefined ) ? center : new THREE.Vector3();
    this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

    constructor: THREE.Sphere,

    set: function( center, radius ) {

        this.center.copy( center );
        this.radius = radius;

        return this;

    },

    setFromPoints: function() {

        var box = new THREE.Box3();

        return function( points, optionalCenter ) {

            var center = this.center;

            if ( optionalCenter !== undefined ) {

                center.copy( optionalCenter );

            }
            else {

                box.setFromPoints( points ).center( center );

            }

            var maxRadiusSq = 0;

            for ( var i = 0, il = points.length; i < il; i++ ) {

                maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

            }

            this.radius = Math.sqrt( maxRadiusSq );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( sphere ) {

        this.center.copy( sphere.center );
        this.radius = sphere.radius;

        return this;

    },

    empty: function() {

        return ( this.radius <= 0 );

    },

    containsPoint: function( point ) {

        return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    },

    distanceToPoint: function( point ) {

        return ( point.distanceTo( this.center ) - this.radius );

    },

    intersectsSphere: function( sphere ) {

        var radiusSum = this.radius + sphere.radius;

        return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    },

    clampPoint: function( point, optionalTarget ) {

        var deltaLengthSq = this.center.distanceToSquared( point );

        var result = optionalTarget || new THREE.Vector3();
        result.copy( point );

        if ( deltaLengthSq > ( this.radius * this.radius ) ) {

            result.sub( this.center ).normalize();
            result.multiplyScalar( this.radius ).add( this.center );

        }

        return result;

    },

    getBoundingBox: function( optionalTarget ) {

        var box = optionalTarget || new THREE.Box3();

        box.set( this.center, this.center );
        box.expandByScalar( this.radius );

        return box;

    },

    applyMatrix4: function( matrix ) {

        this.center.applyMatrix4( matrix );
        this.radius = this.radius * matrix.getMaxScaleOnAxis();

        return this;

    },

    translate: function( offset ) {

        this.center.add( offset );

        return this;

    },

    equals: function( sphere ) {

        return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function( p0, p1, p2, p3, p4, p5 ) {

    this.planes = [

        ( p0 !== undefined ) ? p0 : new THREE.Plane(), ( p1 !== undefined ) ? p1 : new THREE.Plane(), ( p2 !== undefined ) ? p2 : new THREE.Plane(), ( p3 !== undefined ) ? p3 : new THREE.Plane(), ( p4 !== undefined ) ? p4 : new THREE.Plane(), ( p5 !== undefined ) ? p5 : new THREE.Plane()

    ];

};

THREE.Frustum.prototype = {

    constructor: THREE.Frustum,

    set: function( p0, p1, p2, p3, p4, p5 ) {

        var planes = this.planes;

        planes[ 0 ].copy( p0 );
        planes[ 1 ].copy( p1 );
        planes[ 2 ].copy( p2 );
        planes[ 3 ].copy( p3 );
        planes[ 4 ].copy( p4 );
        planes[ 5 ].copy( p5 );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( frustum ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i++ ) {

            planes[ i ].copy( frustum.planes[ i ] );

        }

        return this;

    },

    setFromMatrix: function( m ) {

        var planes = this.planes;
        var me = m.elements;
        var me0 = me[ 0 ],
            me1 = me[ 1 ],
            me2 = me[ 2 ],
            me3 = me[ 3 ];
        var me4 = me[ 4 ],
            me5 = me[ 5 ],
            me6 = me[ 6 ],
            me7 = me[ 7 ];
        var me8 = me[ 8 ],
            me9 = me[ 9 ],
            me10 = me[ 10 ],
            me11 = me[ 11 ];
        var me12 = me[ 12 ],
            me13 = me[ 13 ],
            me14 = me[ 14 ],
            me15 = me[ 15 ];

        planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
        planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
        planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
        planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
        planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
        planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

        return this;

    },

    intersectsObject: function() {

        var sphere = new THREE.Sphere();

        return function( object ) {

            var geometry = object.geometry;

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( object.matrixWorld );

            return this.intersectsSphere( sphere );

        };

    }(),

    intersectsSphere: function( sphere ) {

        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;

        for ( var i = 0; i < 6; i++ ) {

            var distance = planes[ i ].distanceToPoint( center );

            if ( distance < negRadius ) {

                return false;

            }

        }

        return true;

    },

    intersectsBox: function() {

        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();

        return function( box ) {

            var planes = this.planes;

            for ( var i = 0; i < 6; i++ ) {

                var plane = planes[ i ];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint( p1 );
                var d2 = plane.distanceToPoint( p2 );

                // if both outside plane, no intersection

                if ( d1 < 0 && d2 < 0 ) {

                    return false;

                }

            }

            return true;

        };

    }(),


    containsPoint: function( point ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i++ ) {

            if ( planes[ i ].distanceToPoint( point ) < 0 ) {

                return false;

            }

        }

        return true;

    }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function( normal, constant ) {

    this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
    this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

    constructor: THREE.Plane,

    set: function( normal, constant ) {

        this.normal.copy( normal );
        this.constant = constant;

        return this;

    },

    setComponents: function( x, y, z, w ) {

        this.normal.set( x, y, z );
        this.constant = w;

        return this;

    },

    setFromNormalAndCoplanarPoint: function( normal, point ) {

        this.normal.copy( normal );
        this.constant = -point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

        return this;

    },

    setFromCoplanarPoints: function() {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();

        return function( a, b, c ) {

            var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

            this.setFromNormalAndCoplanarPoint( normal, a );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( plane ) {

        this.normal.copy( plane.normal );
        this.constant = plane.constant;

        return this;

    },

    normalize: function() {

        // Note: will lead to a divide by zero if the plane is invalid.

        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar( inverseNormalLength );
        this.constant *= inverseNormalLength;

        return this;

    },

    negate: function() {

        this.constant *= -1;
        this.normal.negate();

        return this;

    },

    distanceToPoint: function( point ) {

        return this.normal.dot( point ) + this.constant;

    },

    distanceToSphere: function( sphere ) {

        return this.distanceToPoint( sphere.center ) - sphere.radius;

    },

    projectPoint: function( point, optionalTarget ) {

        return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    },

    orthoPoint: function( point, optionalTarget ) {

        var perpendicularMagnitude = this.distanceToPoint( point );

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    },

    isIntersectionLine: function( line ) {

        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

        var startSign = this.distanceToPoint( line.start );
        var endSign = this.distanceToPoint( line.end );

        return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    },

    intersectLine: function() {

        var v1 = new THREE.Vector3();

        return function( line, optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            var direction = line.delta( v1 );

            var denominator = this.normal.dot( direction );

            if ( denominator === 0 ) {

                // line is coplanar, return origin
                if ( this.distanceToPoint( line.start ) === 0 ) {

                    return result.copy( line.start );

                }

                // Unsure if this is the correct method to handle this case.
                return undefined;

            }

            var t = -( line.start.dot( this.normal ) + this.constant ) / denominator;

            if ( t < 0 || t > 1 ) {

                return undefined;

            }

            return result.copy( direction ).multiplyScalar( t ).add( line.start );

        };

    }(),


    coplanarPoint: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( -this.constant );

    },

    applyMatrix4: function() {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();

        return function( matrix, optionalNormalMatrix ) {

            // compute new normal based on theory here:
            // http://www.songho.ca/opengl/gl_normaltransform.html
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
            var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

            var newCoplanarPoint = this.coplanarPoint( v2 );
            newCoplanarPoint.applyMatrix4( matrix );

            this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

            return this;

        };

    }(),

    translate: function( offset ) {

        this.constant = this.constant - offset.dot( this.normal );

        return this;

    },

    equals: function( plane ) {

        return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

    generateUUID: function() {

        // http://www.broofa.com/Tools/Math.uuid.htm

        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
        var uuid = new Array( 36 );
        var rnd = 0,
            r;

        return function() {

            for ( var i = 0; i < 36; i++ ) {

                if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

                    uuid[ i ] = '-';

                }
                else if ( i === 14 ) {

                    uuid[ i ] = '4';

                }
                else {

                    if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

                }

            }

            return uuid.join( '' );

        };

    }(),

    // Clamp value to range <a, b>

    clamp: function( x, a, b ) {

        return ( x < a ) ? a : ( ( x > b ) ? b : x );

    },

    // Clamp value to range <a, inf)

    clampBottom: function( x, a ) {

        return x < a ? a : x;

    },

    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation

    euclideanModulo: function( n, m ) {

        return ( ( n % m ) + m ) % m;

    },

    // Linear mapping from range <a1, a2> to range <b1, b2>

    mapLinear: function( x, a1, a2, b1, b2 ) {

        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    },

    // http://en.wikipedia.org/wiki/Smoothstep

    smoothstep: function( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * ( 3 - 2 * x );

    },

    smootherstep: function( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    },

    // Random float from <0, 1> with 16 bits of randomness
    // (standard Math.random() creates repetitive patterns when applied over larger space)

    random16: function() {

        return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

    },

    // Random integer from <low, high> interval

    randInt: function( low, high ) {

        return low + Math.floor( Math.random() * ( high - low + 1 ) );

    },

    // Random float from <low, high> interval

    randFloat: function( low, high ) {

        return low + Math.random() * ( high - low );

    },

    // Random float from <-range/2, range/2> interval

    randFloatSpread: function( range ) {

        return range * ( 0.5 - Math.random() );

    },

    degToRad: function() {

        var degreeToRadiansFactor = Math.PI / 180;

        return function( degrees ) {

            return degrees * degreeToRadiansFactor;

        };

    }(),

    radToDeg: function() {

        var radianToDegreesFactor = 180 / Math.PI;

        return function( radians ) {

            return radians * radianToDegreesFactor;

        };

    }(),

    isPowerOfTwo: function( value ) {

        return ( value & ( value - 1 ) ) === 0 && value !== 0;

    },

    nextPowerOfTwo: function( value ) {

        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;

        return value;

    }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function( points ) {

    this.points = points;

    var c = [],
        v3 = {
            x: 0,
            y: 0,
            z: 0
        },
        point, intPoint, weight, w2, w3,
        pa, pb, pc, pd;

    this.initFromArray = function( a ) {

        this.points = [];

        for ( var i = 0; i < a.length; i++ ) {

            this.points[ i ] = {
                x: a[ i ][ 0 ],
                y: a[ i ][ 1 ],
                z: a[ i ][ 2 ]
            };

        }

    };

    this.getPoint = function( k ) {

        point = ( this.points.length - 1 ) * k;
        intPoint = Math.floor( point );
        weight = point - intPoint;

        c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
        c[ 1 ] = intPoint;
        c[ 2 ] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[ 3 ] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

        pa = this.points[ c[ 0 ] ];
        pb = this.points[ c[ 1 ] ];
        pc = this.points[ c[ 2 ] ];
        pd = this.points[ c[ 3 ] ];

        w2 = weight * weight;
        w3 = weight * w2;

        v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
        v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
        v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

        return v3;

    };

    this.getControlPointsArray = function() {

        var i, p, l = this.points.length,
            coords = [];

        for ( i = 0; i < l; i++ ) {

            p = this.points[ i ];
            coords[ i ] = [ p.x, p.y, p.z ];

        }

        return coords;

    };

    // approximate length by summing linear segments

    this.getLength = function( nSubDivisions ) {

        var i, index, nSamples, position,
            point = 0,
            intPoint = 0,
            oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;

        // first point has 0 length

        chunkLengths[ 0 ] = 0;

        if ( !nSubDivisions ) nSubDivisions = 100;

        nSamples = this.points.length * nSubDivisions;

        oldPosition.copy( this.points[ 0 ] );

        for ( i = 1; i < nSamples; i++ ) {

            index = i / nSamples;

            position = this.getPoint( index );
            tmpVec.copy( position );

            totalLength += tmpVec.distanceTo( oldPosition );

            oldPosition.copy( position );

            point = ( this.points.length - 1 ) * index;
            intPoint = Math.floor( point );

            if ( intPoint !== oldIntPoint ) {

                chunkLengths[ intPoint ] = totalLength;
                oldIntPoint = intPoint;

            }

        }

        // last point ends with total length

        chunkLengths[ chunkLengths.length ] = totalLength;

        return {
            chunks: chunkLengths,
            total: totalLength
        };

    };

    this.reparametrizeByArcLength = function( samplingCoef ) {

        var i, j,
            index, indexCurrent, indexNext,
            realDistance,
            sampling, position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();

        newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

        for ( i = 1; i < this.points.length; i++ ) {

            //tmpVec.copy( this.points[ i - 1 ] );
            //linearDistance = tmpVec.distanceTo( this.points[ i ] );

            realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

            sampling = Math.ceil( samplingCoef * realDistance / sl.total );

            indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
            indexNext = i / ( this.points.length - 1 );

            for ( j = 1; j < sampling - 1; j++ ) {

                index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

                position = this.getPoint( index );
                newpoints.push( tmpVec.copy( position ).clone() );

            }

            newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

        }

        this.points = newpoints;

    };

    // Catmull-Rom

    function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

        var v0 = ( p2 - p0 ) * 0.5,
            v1 = ( p3 - p1 ) * 0.5;

        return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( -3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function( a, b, c ) {

    this.a = ( a !== undefined ) ? a : new THREE.Vector3();
    this.b = ( b !== undefined ) ? b : new THREE.Vector3();
    this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

    var v0 = new THREE.Vector3();

    return function( a, b, c, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        result.subVectors( c, b );
        v0.subVectors( a, b );
        result.cross( v0 );

        var resultLengthSq = result.lengthSq();
        if ( resultLengthSq > 0 ) {

            return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

        }

        return result.set( 0, 0, 0 );

    };

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function( point, a, b, c, optionalTarget ) {

        v0.subVectors( c, a );
        v1.subVectors( b, a );
        v2.subVectors( point, a );

        var dot00 = v0.dot( v0 );
        var dot01 = v0.dot( v1 );
        var dot02 = v0.dot( v2 );
        var dot11 = v1.dot( v1 );
        var dot12 = v1.dot( v2 );

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        var result = optionalTarget || new THREE.Vector3();

        // collinear or singular triangle
        if ( denom === 0 ) {

            // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return result.set( -2, -1, -1 );

        }

        var invDenom = 1 / denom;
        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        // barycentric coordinates must always sum to 1
        return result.set( 1 - u - v, v, u );

    };

}();

THREE.Triangle.containsPoint = function() {

    var v1 = new THREE.Vector3();

    return function( point, a, b, c ) {

        var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

        return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    };

}();

THREE.Triangle.prototype = {

    constructor: THREE.Triangle,

    set: function( a, b, c ) {

        this.a.copy( a );
        this.b.copy( b );
        this.c.copy( c );

        return this;

    },

    setFromPointsAndIndices: function( points, i0, i1, i2 ) {

        this.a.copy( points[ i0 ] );
        this.b.copy( points[ i1 ] );
        this.c.copy( points[ i2 ] );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( triangle ) {

        this.a.copy( triangle.a );
        this.b.copy( triangle.b );
        this.c.copy( triangle.c );

        return this;

    },

    area: function() {

        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();

        return function() {

            v0.subVectors( this.c, this.b );
            v1.subVectors( this.a, this.b );

            return v0.cross( v1 ).length() * 0.5;

        };

    }(),

    midpoint: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    },

    normal: function( optionalTarget ) {

        return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

    },

    plane: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Plane();

        return result.setFromCoplanarPoints( this.a, this.b, this.c );

    },

    barycoordFromPoint: function( point, optionalTarget ) {

        return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    },

    containsPoint: function( point ) {

        return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

    },

    equals: function( triangle ) {

        return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function( autoStart ) {

    this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;

    this.running = false;

};

THREE.Clock.prototype = {

    constructor: THREE.Clock,

    start: function() {

        this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();

        this.oldTime = this.startTime;
        this.running = true;

    },

    stop: function() {

        this.getElapsedTime();
        this.running = false;

    },

    getElapsedTime: function() {

        this.getDelta();
        return this.elapsedTime;

    },

    getDelta: function() {

        var diff = 0;

        if ( this.autoStart && !this.running ) {

            this.start();

        }

        if ( this.running ) {

            var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();

            diff = 0.001 * ( newTime - this.oldTime );
            this.oldTime = newTime;

            this.elapsedTime += diff;

        }

        return diff;

    }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function() {};

THREE.EventDispatcher.prototype = {

    constructor: THREE.EventDispatcher,

    apply: function( object ) {

        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

    },

    addEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) this._listeners = {};

        var listeners = this._listeners;

        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === -1 ) {

            listeners[ type ].push( listener );

        }

    },

    hasEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) return false;

        var listeners = this._listeners;

        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1 ) {

            return true;

        }

        return false;

    },

    removeEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ type ];

        if ( listenerArray !== undefined ) {

            var index = listenerArray.indexOf( listener );

            if ( index !== -1 ) {

                listenerArray.splice( index, 1 );

            }

        }

    },

    dispatchEvent: function( event ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];

        if ( listenerArray !== undefined ) {

            event.target = this;

            var array = [];
            var length = listenerArray.length;

            for ( var i = 0; i < length; i++ ) {

                array[ i ] = listenerArray[ i ];

            }

            for ( var i = 0; i < length; i++ ) {

                array[ i ].call( this, event );

            }

        }

    }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function( THREE ) {

    THREE.Raycaster = function( origin, direction, near, far ) {

        this.ray = new THREE.Ray( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)

        this.near = near || 0;
        this.far = far || Infinity;

        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };

        Object.defineProperties( this.params, {
            PointCloud: {
                get: function() {
                    console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
                    return this.Points;
                }
            }
        } );

    };

    function descSort( a, b ) {

        return a.distance - b.distance;

    }

    var intersectObject = function( object, raycaster, intersects, recursive ) {

        if ( object.visible === false ) return;

        object.raycast( raycaster, intersects );

        if ( recursive === true ) {

            var children = object.children;

            for ( var i = 0, l = children.length; i < l; i++ ) {

                intersectObject( children[ i ], raycaster, intersects, true );

            }

        }

    };

    //

    THREE.Raycaster.prototype = {

        constructor: THREE.Raycaster,

        linePrecision: 1,

        set: function( origin, direction ) {

            // direction is assumed to be normalized (for accurate distance calculations)

            this.ray.set( origin, direction );

        },

        setFromCamera: function( coords, camera ) {

            if ( camera instanceof THREE.PerspectiveCamera ) {

                this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
                this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

            }
            else if ( camera instanceof THREE.OrthographicCamera ) {

                this.ray.origin.set( coords.x, coords.y, -1 ).unproject( camera );
                this.ray.direction.set( 0, 0, -1 ).transformDirection( camera.matrixWorld );

            }
            else {

                console.error( 'THREE.Raycaster: Unsupported camera type.' );

            }

        },

        intersectObject: function( object, recursive ) {

            var intersects = [];

            intersectObject( object, this, intersects, recursive );

            intersects.sort( descSort );

            return intersects;

        },

        intersectObjects: function( objects, recursive ) {

            var intersects = [];

            if ( Array.isArray( objects ) === false ) {

                console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
                return intersects;

            }

            for ( var i = 0, l = objects.length; i < l; i++ ) {

                intersectObject( objects[ i ], this, intersects, recursive );

            }

            intersects.sort( descSort );

            return intersects;

        }

    };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.Object3DIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Object3D';

    this.parent = null;
    this.children = [];

    this.up = THREE.Object3D.DefaultUp.clone();

    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3( 1, 1, 1 );

    var onRotationChange = function() {

        quaternion.setFromEuler( rotation, false );

    };

    var onQuaternionChange = function() {

        rotation.setFromQuaternion( quaternion, undefined, false );

    };

    rotation.onChange( onRotationChange );
    quaternion.onChange( onQuaternionChange );

    Object.defineProperties( this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new THREE.Matrix4()
        },
        normalMatrix: {
            value: new THREE.Matrix3()
        }
    } );

    this.rotationAutoUpdate = true;

    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();

    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;

    this.visible = true;

    this.castShadow = false;
    this.receiveShadow = false;

    this.frustumCulled = true;
    this.renderOrder = 0;

    this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

    constructor: THREE.Object3D,

    get eulerOrder() {

        console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

        return this.rotation.order;

    },

    set eulerOrder( value ) {

        console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

        this.rotation.order = value;

    },

    get useQuaternion() {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set useQuaternion( value ) {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set renderDepth( value ) {

        console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

    },

    applyMatrix: function( matrix ) {

        this.matrix.multiplyMatrices( matrix, this.matrix );

        this.matrix.decompose( this.position, this.quaternion, this.scale );

    },

    setRotationFromAxisAngle: function( axis, angle ) {

        // assumes axis is normalized

        this.quaternion.setFromAxisAngle( axis, angle );

    },

    setRotationFromEuler: function( euler ) {

        this.quaternion.setFromEuler( euler, true );

    },

    setRotationFromMatrix: function( m ) {

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        this.quaternion.setFromRotationMatrix( m );

    },

    setRotationFromQuaternion: function( q ) {

        // assumes q is normalized

        this.quaternion.copy( q );

    },

    rotateOnAxis: function() {

        // rotate object on axis in object space
        // axis is assumed to be normalized

        var q1 = new THREE.Quaternion();

        return function( axis, angle ) {

            q1.setFromAxisAngle( axis, angle );

            this.quaternion.multiply( q1 );

            return this;

        };

    }(),

    rotateX: function() {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateY: function() {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateZ: function() {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    translateOnAxis: function() {

        // translate object by distance along axis in object space
        // axis is assumed to be normalized

        var v1 = new THREE.Vector3();

        return function( axis, distance ) {

            v1.copy( axis ).applyQuaternion( this.quaternion );

            this.position.add( v1.multiplyScalar( distance ) );

            return this;

        };

    }(),

    translate: function( distance, axis ) {

        console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
        return this.translateOnAxis( axis, distance );

    },

    translateX: function() {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateY: function() {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateZ: function() {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    localToWorld: function( vector ) {

        return vector.applyMatrix4( this.matrixWorld );

    },

    worldToLocal: function() {

        var m1 = new THREE.Matrix4();

        return function( vector ) {

            return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

        };

    }(),

    lookAt: function() {

        // This routine does not support objects with rotated and/or translated parent(s)

        var m1 = new THREE.Matrix4();

        return function( vector ) {

            m1.lookAt( vector, this.position, this.up );

            this.quaternion.setFromRotationMatrix( m1 );

        };

    }(),

    add: function( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i++ ) {

                this.add( arguments[ i ] );

            }

            return this;

        }

        if ( object === this ) {

            console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
            return this;

        }

        if ( object instanceof THREE.Object3D ) {

            if ( object.parent !== null ) {

                object.parent.remove( object );

            }

            object.parent = this;
            object.dispatchEvent( {
                type: 'added'
            } );

            this.children.push( object );

        }
        else {

            console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

        }

        return this;

    },

    remove: function( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i++ ) {

                this.remove( arguments[ i ] );

            }

        }

        var index = this.children.indexOf( object );

        if ( index !== -1 ) {

            object.parent = null;

            object.dispatchEvent( {
                type: 'removed'
            } );

            this.children.splice( index, 1 );

        }

    },

    getChildByName: function( name ) {

        console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
        return this.getObjectByName( name );

    },

    getObjectById: function( id ) {

        return this.getObjectByProperty( 'id', id );

    },

    getObjectByName: function( name ) {

        return this.getObjectByProperty( 'name', name );

    },

    getObjectByProperty: function( name, value ) {

        if ( this[ name ] === value ) return this;

        for ( var i = 0, l = this.children.length; i < l; i++ ) {

            var child = this.children[ i ];
            var object = child.getObjectByProperty( name, value );

            if ( object !== undefined ) {

                return object;

            }

        }

        return undefined;

    },

    getWorldPosition: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.updateMatrixWorld( true );

        return result.setFromMatrixPosition( this.matrixWorld );

    },

    getWorldQuaternion: function() {

        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Quaternion();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, result, scale );

            return result;

        };

    }(),

    getWorldRotation: function() {

        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Euler();

            this.getWorldQuaternion( quaternion );

            return result.setFromQuaternion( quaternion, this.rotation.order, false );

        };

    }(),

    getWorldScale: function() {

        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, quaternion, result );

            return result;

        };

    }(),

    getWorldDirection: function() {

        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.getWorldQuaternion( quaternion );

            return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

        };

    }(),

    raycast: function() {},

    traverse: function( callback ) {

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            children[ i ].traverse( callback );

        }

    },

    traverseVisible: function( callback ) {

        if ( this.visible === false ) return;

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            children[ i ].traverseVisible( callback );

        }

    },

    traverseAncestors: function( callback ) {

        var parent = this.parent;

        if ( parent !== null ) {

            callback( parent );

            parent.traverseAncestors( callback );

        }

    },

    updateMatrix: function() {

        this.matrix.compose( this.position, this.quaternion, this.scale );

        this.matrixWorldNeedsUpdate = true;

    },

    updateMatrixWorld: function( force ) {

        if ( this.matrixAutoUpdate === true ) this.updateMatrix();

        if ( this.matrixWorldNeedsUpdate === true || force === true ) {

            if ( this.parent === null ) {

                this.matrixWorld.copy( this.matrix );

            }
            else {

                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

            }

            this.matrixWorldNeedsUpdate = false;

            force = true;

        }

        // update children

        for ( var i = 0, l = this.children.length; i < l; i++ ) {

            this.children[ i ].updateMatrixWorld( force );

        }

    },

    toJSON: function( meta ) {

        var isRootObject = ( meta === undefined );

        var data = {};

        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if ( isRootObject ) {

            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            };

            data.metadata = {
                version: 4.4,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };

        }

        // standard Object3D serialization

        data.uuid = this.uuid;
        data.type = this.type;

        if ( this.name !== '' ) data.name = this.name;
        if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
        if ( this.visible !== true ) data.visible = this.visible;

        data.matrix = this.matrix.toArray();

        if ( this.children.length > 0 ) {

            data.children = [];

            for ( var i = 0; i < this.children.length; i++ ) {

                data.children.push( this.children[ i ].toJSON( meta ).object );

            }

        }

        var output = {};

        if ( isRootObject ) {

            var geometries = extractFromCache( meta.geometries );
            var materials = extractFromCache( meta.materials );
            var textures = extractFromCache( meta.textures );
            var images = extractFromCache( meta.images );

            if ( geometries.length > 0 ) output.geometries = geometries;
            if ( materials.length > 0 ) output.materials = materials;
            if ( textures.length > 0 ) output.textures = textures;
            if ( images.length > 0 ) output.images = images;

        }

        output.object = data;

        return output;

        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache( cache ) {

            var values = [];
            for ( var key in cache ) {

                var data = cache[ key ];
                delete data.metadata;
                values.push( data );

            }
            return values;

        }

    },

    clone: function( recursive ) {

        return new this.constructor().copy( this, recursive );

    },

    copy: function( source, recursive ) {

        if ( recursive === undefined ) recursive = true;

        this.name = source.name;

        this.up.copy( source.up );

        this.position.copy( source.position );
        this.quaternion.copy( source.quaternion );
        this.scale.copy( source.scale );

        this.rotationAutoUpdate = source.rotationAutoUpdate;

        this.matrix.copy( source.matrix );
        this.matrixWorld.copy( source.matrixWorld );

        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

        this.visible = source.visible;

        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;

        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;

        this.userData = JSON.parse( JSON.stringify( source.userData ) );

        if ( recursive === true ) {

            for ( var i = 0; i < source.children.length; i++ ) {

                var child = source.children[ i ];
                this.add( child.clone() );

            }

        }

        return this;

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function( a, b, c, normal, color, materialIndex ) {

    this.a = a;
    this.b = b;
    this.c = c;

    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
    this.vertexNormals = Array.isArray( normal ) ? normal : [];

    this.color = color instanceof THREE.Color ? color : new THREE.Color();
    this.vertexColors = Array.isArray( color ) ? color : [];

    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

    constructor: THREE.Face3,

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.a = source.a;
        this.b = source.b;
        this.c = source.c;

        this.normal.copy( source.normal );
        this.color.copy( source.color );

        this.materialIndex = source.materialIndex;

        for ( var i = 0, il = source.vertexNormals.length; i < il; i++ ) {

            this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

        }

        for ( var i = 0, il = source.vertexColors.length; i < il; i++ ) {

            this.vertexColors[ i ] = source.vertexColors[ i ].clone();

        }

        return this;

    }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function( a, b, c, d, normal, color, materialIndex ) {

    console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function( array, itemSize ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.itemSize = itemSize;

    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };

    this.version = 0;

};

THREE.BufferAttribute.prototype = {

    constructor: THREE.BufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.array.length / this.itemSize;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    setDynamic: function( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function( source ) {

        this.array = new source.array.constructor( source.array );
        this.itemSize = source.itemSize;

        this.dynamic = source.dynamic;

        return this;

    },

    copyAt: function( index1, attribute, index2 ) {

        index1 *= this.itemSize;
        index2 *= attribute.itemSize;

        for ( var i = 0, l = this.itemSize; i < l; i++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    copyArray: function( array ) {

        this.array.set( array );

        return this;

    },

    copyColorsArray: function( colors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = colors.length; i < l; i++ ) {

            var color = colors[ i ];

            if ( color === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
                color = new THREE.Color();

            }

            array[ offset++ ] = color.r;
            array[ offset++ ] = color.g;
            array[ offset++ ] = color.b;

        }

        return this;

    },

    copyIndicesArray: function( indices ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = indices.length; i < l; i++ ) {

            var index = indices[ i ];

            array[ offset++ ] = index.a;
            array[ offset++ ] = index.b;
            array[ offset++ ] = index.c;

        }

        return this;

    },

    copyVector2sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
                vector = new THREE.Vector2();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;

        }

        return this;

    },

    copyVector3sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
                vector = new THREE.Vector3();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;
            array[ offset++ ] = vector.z;

        }

        return this;

    },

    copyVector4sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
                vector = new THREE.Vector4();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;
            array[ offset++ ] = vector.z;
            array[ offset++ ] = vector.w;

        }

        return this;

    },

    set: function( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    getX: function( index ) {

        return this.array[ index * this.itemSize ];

    },

    setX: function( index, x ) {

        this.array[ index * this.itemSize ] = x;

        return this;

    },

    getY: function( index ) {

        return this.array[ index * this.itemSize + 1 ];

    },

    setY: function( index, y ) {

        this.array[ index * this.itemSize + 1 ] = y;

        return this;

    },

    getZ: function( index ) {

        return this.array[ index * this.itemSize + 2 ];

    },

    setZ: function( index, z ) {

        this.array[ index * this.itemSize + 2 ] = z;

        return this;

    },

    getW: function( index ) {

        return this.array[ index * this.itemSize + 3 ];

    },

    setW: function( index, w ) {

        this.array[ index * this.itemSize + 3 ] = w;

        return this;

    },

    setXY: function( index, x, y ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function( index, x, y, z ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function( index, x, y, z, w ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;
        this.array[ index + 3 ] = w;

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    }

};

//

THREE.Int8Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function( array, itemSize ) {

    console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function( array, itemSize, meshPerAttribute ) {

    THREE.BufferAttribute.call( this, array, itemSize );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function( source ) {

    THREE.BufferAttribute.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function( array, stride ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.stride = stride;

    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };

    this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

    constructor: THREE.InterleavedBuffer,

    get length() {

        return this.array.length;

    },

    get count() {

        return this.array.length / this.stride;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    setDynamic: function( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function( source ) {

        this.array = new source.array.constructor( source.array );
        this.stride = source.stride;
        this.dynamic = source.dynamic;

    },

    copyAt: function( index1, attribute, index2 ) {

        index1 *= this.stride;
        index2 *= attribute.stride;

        for ( var i = 0, l = this.stride; i < l; i++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    set: function( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function( array, stride, meshPerAttribute ) {

    THREE.InterleavedBuffer.call( this, array, stride );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function( source ) {

    THREE.InterleavedBuffer.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function( interleavedBuffer, itemSize, offset ) {

    this.uuid = THREE.Math.generateUUID();

    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

    constructor: THREE.InterleavedBufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.data.array.length / this.data.stride;

    },

    setX: function( index, x ) {

        this.data.array[ index * this.data.stride + this.offset ] = x;

        return this;

    },

    setY: function( index, y ) {

        this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

        return this;

    },

    setZ: function( index, z ) {

        this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

        return this;

    },

    setW: function( index, w ) {

        this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

        return this;

    },

    getX: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset ];

    },

    getY: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 1 ];

    },

    getZ: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 2 ];

    },

    getW: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 3 ];

    },

    setXY: function( index, x, y ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function( index, x, y, z ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function( index, x, y, z, w ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;
        this.data.array[ index + 3 ] = w;

        return this;

    }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Geometry';

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];

    this.morphTargets = [];
    this.morphColors = [];
    this.morphNormals = [];

    this.skinWeights = [];
    this.skinIndices = [];

    this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.elementsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

    constructor: THREE.Geometry,

    applyMatrix: function( matrix ) {

        var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        for ( var i = 0, il = this.vertices.length; i < il; i++ ) {

            var vertex = this.vertices[ i ];
            vertex.applyMatrix4( matrix );

        }

        for ( var i = 0, il = this.faces.length; i < il; i++ ) {

            var face = this.faces[ i ];
            face.normal.applyMatrix3( normalMatrix ).normalize();

            for ( var j = 0, jl = face.vertexNormals.length; j < jl; j++ ) {

                face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

            }

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;

    },

    rotateX: function() {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function() {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function() {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function() {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function() {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function() {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    fromBufferGeometry: function( geometry ) {

        var scope = this;

        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;

        var vertices = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

        if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];

        for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

            scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

            if ( normals !== undefined ) {

                tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

            }

            if ( colors !== undefined ) {

                scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

            }

            if ( uvs !== undefined ) {

                tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

            }

            if ( uvs2 !== undefined ) {

                tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

            }

        }

        var addFace = function( a, b, c ) {

            var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
            var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

            var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

            scope.faces.push( face );

            if ( uvs !== undefined ) {

                scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

            }

            if ( uvs2 !== undefined ) {

                scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

            }

        };

        if ( indices !== undefined ) {

            var groups = geometry.groups;

            if ( groups.length > 0 ) {

                for ( var i = 0; i < groups.length; i++ ) {

                    var group = groups[ i ];

                    var start = group.start;
                    var count = group.count;

                    for ( var j = start, jl = start + count; j < jl; j += 3 ) {

                        addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

                    }

                }

            }
            else {

                for ( var i = 0; i < indices.length; i += 3 ) {

                    addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                }

            }

        }
        else {

            for ( var i = 0; i < vertices.length / 3; i += 3 ) {

                addFace( i, i + 1, i + 2 );

            }

        }

        this.computeFaceNormals();

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        return this;

    },

    center: function() {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    normalize: function() {

        this.computeBoundingSphere();

        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;

        var s = radius === 0 ? 1 : 1.0 / radius;

        var matrix = new THREE.Matrix4();
        matrix.set(
            s, 0, 0, -s * center.x,
            0, s, 0, -s * center.y,
            0, 0, s, -s * center.z,
            0, 0, 0, 1
        );

        this.applyMatrix( matrix );

        return this;

    },

    computeFaceNormals: function() {

        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();

        for ( var f = 0, fl = this.faces.length; f < fl; f++ ) {

            var face = this.faces[ f ];

            var vA = this.vertices[ face.a ];
            var vB = this.vertices[ face.b ];
            var vC = this.vertices[ face.c ];

            cb.subVectors( vC, vB );
            ab.subVectors( vA, vB );
            cb.cross( ab );

            cb.normalize();

            face.normal.copy( cb );

        }

    },

    computeVertexNormals: function( areaWeighted ) {

        var v, vl, f, fl, face, vertices;

        vertices = new Array( this.vertices.length );

        for ( v = 0, vl = this.vertices.length; v < vl; v++ ) {

            vertices[ v ] = new THREE.Vector3();

        }

        if ( areaWeighted ) {

            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm

            var vA, vB, vC;
            var cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                vA = this.vertices[ face.a ];
                vB = this.vertices[ face.b ];
                vC = this.vertices[ face.c ];

                cb.subVectors( vC, vB );
                ab.subVectors( vA, vB );
                cb.cross( ab );

                vertices[ face.a ].add( cb );
                vertices[ face.b ].add( cb );
                vertices[ face.c ].add( cb );

            }

        }
        else {

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                vertices[ face.a ].add( face.normal );
                vertices[ face.b ].add( face.normal );
                vertices[ face.c ].add( face.normal );

            }

        }

        for ( v = 0, vl = this.vertices.length; v < vl; v++ ) {

            vertices[ v ].normalize();

        }

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                vertexNormals[ 0 ].copy( vertices[ face.a ] );
                vertexNormals[ 1 ].copy( vertices[ face.b ] );
                vertexNormals[ 2 ].copy( vertices[ face.c ] );

            }
            else {

                vertexNormals[ 0 ] = vertices[ face.a ].clone();
                vertexNormals[ 1 ] = vertices[ face.b ].clone();
                vertexNormals[ 2 ] = vertices[ face.c ].clone();

            }

        }

    },

    computeMorphNormals: function() {

        var i, il, f, fl, face;

        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            if ( !face.__originalFaceNormal ) {

                face.__originalFaceNormal = face.normal.clone();

            }
            else {

                face.__originalFaceNormal.copy( face.normal );

            }

            if ( !face.__originalVertexNormals ) face.__originalVertexNormals = [];

            for ( i = 0, il = face.vertexNormals.length; i < il; i++ ) {

                if ( !face.__originalVertexNormals[ i ] ) {

                    face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

                }
                else {

                    face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

                }

            }

        }

        // use temp geometry to compute face and vertex normals for each morph

        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;

        for ( i = 0, il = this.morphTargets.length; i < il; i++ ) {

            // create on first access

            if ( !this.morphNormals[ i ] ) {

                this.morphNormals[ i ] = {};
                this.morphNormals[ i ].faceNormals = [];
                this.morphNormals[ i ].vertexNormals = [];

                var dstNormalsFace = this.morphNormals[ i ].faceNormals;
                var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

                var faceNormal, vertexNormals;

                for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                    faceNormal = new THREE.Vector3();
                    vertexNormals = {
                        a: new THREE.Vector3(),
                        b: new THREE.Vector3(),
                        c: new THREE.Vector3()
                    };

                    dstNormalsFace.push( faceNormal );
                    dstNormalsVertex.push( vertexNormals );

                }

            }

            var morphNormals = this.morphNormals[ i ];

            // set vertices to morph target

            tmpGeo.vertices = this.morphTargets[ i ].vertices;

            // compute morph normals

            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();

            // store morph normals

            var faceNormal, vertexNormals;

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                faceNormal = morphNormals.faceNormals[ f ];
                vertexNormals = morphNormals.vertexNormals[ f ];

                faceNormal.copy( face.normal );

                vertexNormals.a.copy( face.vertexNormals[ 0 ] );
                vertexNormals.b.copy( face.vertexNormals[ 1 ] );
                vertexNormals.c.copy( face.vertexNormals[ 2 ] );

            }

        }

        // restore original normals

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;

        }

    },

    computeTangents: function() {

        console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    },

    computeLineDistances: function() {

        var d = 0;
        var vertices = this.vertices;

        for ( var i = 0, il = vertices.length; i < il; i++ ) {

            if ( i > 0 ) {

                d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

            }

            this.lineDistances[ i ] = d;

        }

    },

    computeBoundingBox: function() {

        if ( this.boundingBox === null ) {

            this.boundingBox = new THREE.Box3();

        }

        this.boundingBox.setFromPoints( this.vertices );

    },

    computeBoundingSphere: function() {

        if ( this.boundingSphere === null ) {

            this.boundingSphere = new THREE.Sphere();

        }

        this.boundingSphere.setFromPoints( this.vertices );

    },

    merge: function( geometry, matrix, materialIndexOffset ) {

        if ( geometry instanceof THREE.Geometry === false ) {

            console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
            return;

        }

        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[ 0 ],
            uvs2 = geometry.faceVertexUvs[ 0 ];

        if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

        if ( matrix !== undefined ) {

            normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        }

        // vertices

        for ( var i = 0, il = vertices2.length; i < il; i++ ) {

            var vertex = vertices2[ i ];

            var vertexCopy = vertex.clone();

            if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

            vertices1.push( vertexCopy );

        }

        // faces

        for ( i = 0, il = faces2.length; i < il; i++ ) {

            var face = faces2[ i ],
                faceCopy, normal, color,
                faceVertexNormals = face.vertexNormals,
                faceVertexColors = face.vertexColors;

            faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
            faceCopy.normal.copy( face.normal );

            if ( normalMatrix !== undefined ) {

                faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

            }

            for ( var j = 0, jl = faceVertexNormals.length; j < jl; j++ ) {

                normal = faceVertexNormals[ j ].clone();

                if ( normalMatrix !== undefined ) {

                    normal.applyMatrix3( normalMatrix ).normalize();

                }

                faceCopy.vertexNormals.push( normal );

            }

            faceCopy.color.copy( face.color );

            for ( var j = 0, jl = faceVertexColors.length; j < jl; j++ ) {

                color = faceVertexColors[ j ];
                faceCopy.vertexColors.push( color.clone() );

            }

            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

            faces1.push( faceCopy );

        }

        // uvs

        for ( i = 0, il = uvs2.length; i < il; i++ ) {

            var uv = uvs2[ i ],
                uvCopy = [];

            if ( uv === undefined ) {

                continue;

            }

            for ( var j = 0, jl = uv.length; j < jl; j++ ) {

                uvCopy.push( uv[ j ].clone() );

            }

            uvs1.push( uvCopy );

        }

    },

    mergeMesh: function( mesh ) {

        if ( mesh instanceof THREE.Mesh === false ) {

            console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
            return;

        }

        mesh.matrixAutoUpdate && mesh.updateMatrix();

        this.merge( mesh.geometry, mesh.matrix );

    },

    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */

    mergeVertices: function() {

        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [],
            changes = [];

        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow( 10, precisionPoints );
        var i, il, face;
        var indices, j, jl;

        for ( i = 0, il = this.vertices.length; i < il; i++ ) {

            v = this.vertices[ i ];
            key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

            if ( verticesMap[ key ] === undefined ) {

                verticesMap[ key ] = i;
                unique.push( this.vertices[ i ] );
                changes[ i ] = unique.length - 1;

            }
            else {

                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                changes[ i ] = changes[ verticesMap[ key ] ];

            }

        }


        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];

        for ( i = 0, il = this.faces.length; i < il; i++ ) {

            face = this.faces[ i ];

            face.a = changes[ face.a ];
            face.b = changes[ face.b ];
            face.c = changes[ face.c ];

            indices = [ face.a, face.b, face.c ];

            var dupIndex = -1;

            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for ( var n = 0; n < 3; n++ ) {

                if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

                    dupIndex = n;
                    faceIndicesToRemove.push( i );
                    break;

                }

            }

        }

        for ( i = faceIndicesToRemove.length - 1; i >= 0; i-- ) {

            var idx = faceIndicesToRemove[ i ];

            this.faces.splice( idx, 1 );

            for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j++ ) {

                this.faceVertexUvs[ j ].splice( idx, 1 );

            }

        }

        // Use unique set of vertices

        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;

    },

    toJSON: function() {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };

        // standard Geometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        var vertices = [];

        for ( var i = 0; i < this.vertices.length; i++ ) {

            var vertex = this.vertices[ i ];
            vertices.push( vertex.x, vertex.y, vertex.z );

        }

        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};

        for ( var i = 0; i < this.faces.length; i++ ) {

            var face = this.faces[ i ];

            var hasMaterial = false; // face.materialIndex !== undefined;
            var hasFaceUv = false; // deprecated
            var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;

            var faceType = 0;

            faceType = setBit( faceType, 0, 0 );
            faceType = setBit( faceType, 1, hasMaterial );
            faceType = setBit( faceType, 2, hasFaceUv );
            faceType = setBit( faceType, 3, hasFaceVertexUv );
            faceType = setBit( faceType, 4, hasFaceNormal );
            faceType = setBit( faceType, 5, hasFaceVertexNormal );
            faceType = setBit( faceType, 6, hasFaceColor );
            faceType = setBit( faceType, 7, hasFaceVertexColor );

            faces.push( faceType );
            faces.push( face.a, face.b, face.c );

            if ( hasFaceVertexUv ) {

                var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

                faces.push(
                    getUvIndex( faceVertexUvs[ 0 ] ),
                    getUvIndex( faceVertexUvs[ 1 ] ),
                    getUvIndex( faceVertexUvs[ 2 ] )
                );

            }

            if ( hasFaceNormal ) {

                faces.push( getNormalIndex( face.normal ) );

            }

            if ( hasFaceVertexNormal ) {

                var vertexNormals = face.vertexNormals;

                faces.push(
                    getNormalIndex( vertexNormals[ 0 ] ),
                    getNormalIndex( vertexNormals[ 1 ] ),
                    getNormalIndex( vertexNormals[ 2 ] )
                );

            }

            if ( hasFaceColor ) {

                faces.push( getColorIndex( face.color ) );

            }

            if ( hasFaceVertexColor ) {

                var vertexColors = face.vertexColors;

                faces.push(
                    getColorIndex( vertexColors[ 0 ] ),
                    getColorIndex( vertexColors[ 1 ] ),
                    getColorIndex( vertexColors[ 2 ] )
                );

            }

        }

        function setBit( value, position, enabled ) {

            return enabled ? value | ( 1 << position ) : value & ( ~( 1 << position ) );

        }

        function getNormalIndex( normal ) {

            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

            if ( normalsHash[ hash ] !== undefined ) {

                return normalsHash[ hash ];

            }

            normalsHash[ hash ] = normals.length / 3;
            normals.push( normal.x, normal.y, normal.z );

            return normalsHash[ hash ];

        }

        function getColorIndex( color ) {

            var hash = color.r.toString() + color.g.toString() + color.b.toString();

            if ( colorsHash[ hash ] !== undefined ) {

                return colorsHash[ hash ];

            }

            colorsHash[ hash ] = colors.length;
            colors.push( color.getHex() );

            return colorsHash[ hash ];

        }

        function getUvIndex( uv ) {

            var hash = uv.x.toString() + uv.y.toString();

            if ( uvsHash[ hash ] !== undefined ) {

                return uvsHash[ hash ];

            }

            uvsHash[ hash ] = uvs.length / 2;
            uvs.push( uv.x, uv.y );

            return uvsHash[ hash ];

        }

        data.data = {};

        data.data.vertices = vertices;
        data.data.normals = normals;
        if ( colors.length > 0 ) data.data.colors = colors;
        if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
        data.data.faces = faces;

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];

        var vertices = source.vertices;

        for ( var i = 0, il = vertices.length; i < il; i++ ) {

            this.vertices.push( vertices[ i ].clone() );

        }

        var faces = source.faces;

        for ( var i = 0, il = faces.length; i < il; i++ ) {

            this.faces.push( faces[ i ].clone() );

        }

        for ( var i = 0, il = source.faceVertexUvs.length; i < il; i++ ) {

            var faceVertexUvs = source.faceVertexUvs[ i ];

            if ( this.faceVertexUvs[ i ] === undefined ) {

                this.faceVertexUvs[ i ] = [];

            }

            for ( var j = 0, jl = faceVertexUvs.length; j < jl; j++ ) {

                var uvs = faceVertexUvs[ j ],
                    uvsCopy = [];

                for ( var k = 0, kl = uvs.length; k < kl; k++ ) {

                    var uv = uvs[ k ];

                    uvsCopy.push( uv.clone() );

                }

                this.faceVertexUvs[ i ].push( uvsCopy );

            }

        }

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'DirectGeometry';

    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];

    this.groups = [];

    this.morphTargets = {};

    this.skinWeights = [];
    this.skinIndices = [];

    // this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

    constructor: THREE.DirectGeometry,

    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

    computeFaceNormals: function() {

        console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    },

    computeVertexNormals: function() {

        console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    },

    computeGroups: function( geometry ) {

        var group;
        var groups = [];
        var materialIndex;

        var faces = geometry.faces;

        for ( var i = 0; i < faces.length; i++ ) {

            var face = faces[ i ];

            // materials

            if ( face.materialIndex !== materialIndex ) {

                materialIndex = face.materialIndex;

                if ( group !== undefined ) {

                    group.count = ( i * 3 ) - group.start;
                    groups.push( group );

                }

                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };

            }

        }

        if ( group !== undefined ) {

            group.count = ( i * 3 ) - group.start;
            groups.push( group );

        }

        this.groups = groups;

    },

    fromGeometry: function( geometry ) {

        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;

        var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

        // morphs

        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;

        if ( morphTargetsLength > 0 ) {

            var morphTargetsPosition = [];

            for ( var i = 0; i < morphTargetsLength; i++ ) {

                morphTargetsPosition[ i ] = [];

            }

            this.morphTargets.position = morphTargetsPosition;

        }

        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;

        if ( morphNormalsLength > 0 ) {

            var morphTargetsNormal = [];

            for ( var i = 0; i < morphNormalsLength; i++ ) {

                morphTargetsNormal[ i ] = [];

            }

            this.morphTargets.normal = morphTargetsNormal;

        }

        // skins

        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;

        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;

        //

        for ( var i = 0; i < faces.length; i++ ) {

            var face = faces[ i ];

            this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

            }
            else {

                var normal = face.normal;

                this.normals.push( normal, normal, normal );

            }

            var vertexColors = face.vertexColors;

            if ( vertexColors.length === 3 ) {

                this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

            }
            else {

                var color = face.color;

                this.colors.push( color, color, color );

            }

            if ( hasFaceVertexUv === true ) {

                var vertexUvs = faceVertexUvs[ 0 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                }
                else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

                    this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            if ( hasFaceVertexUv2 === true ) {

                var vertexUvs = faceVertexUvs[ 1 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                }
                else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

                    this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            // morphs

            for ( var j = 0; j < morphTargetsLength; j++ ) {

                var morphTarget = morphTargets[ j ].vertices;

                morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

            }

            for ( var j = 0; j < morphNormalsLength; j++ ) {

                var morphNormal = morphNormals[ j ].vertexNormals[ i ];

                morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

            }

            // skins

            if ( hasSkinIndices ) {

                this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

            }

            if ( hasSkinWeights ) {

                this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

            }

        }

        this.computeGroups( geometry );

        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'BufferGeometry';

    this.index = null;
    this.attributes = {};

    this.morphAttributes = {};

    this.groups = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    this.drawRange = {
        start: 0,
        count: Infinity
    };

};

THREE.BufferGeometry.prototype = {

    constructor: THREE.BufferGeometry,

    addIndex: function( index ) {

        console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
        this.setIndex( index );

    },

    getIndex: function() {

        return this.index;

    },

    setIndex: function( index ) {

        this.index = index;

    },

    addAttribute: function( name, attribute ) {

        if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

            console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

            this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

            return;

        }

        if ( name === 'index' ) {

            console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
            this.setIndex( attribute );

        }

        this.attributes[ name ] = attribute;

    },

    getAttribute: function( name ) {

        return this.attributes[ name ];

    },

    removeAttribute: function( name ) {

        delete this.attributes[ name ];

    },

    get drawcalls() {

        console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
        return this.groups;

    },

    get offsets() {

        console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
        return this.groups;

    },

    addDrawCall: function( start, count, indexOffset ) {

        if ( indexOffset !== undefined ) {

            console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

        }

        console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
        this.addGroup( start, count );

    },

    clearDrawCalls: function() {

        console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
        this.clearGroups();

    },

    addGroup: function( start, count, materialIndex ) {

        this.groups.push( {

            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0

        } );

    },

    clearGroups: function() {

        this.groups = [];

    },

    setDrawRange: function( start, count ) {

        this.drawRange.start = start;
        this.drawRange.count = count;

    },

    applyMatrix: function( matrix ) {

        var position = this.attributes.position;

        if ( position !== undefined ) {

            matrix.applyToVector3Array( position.array );
            position.needsUpdate = true;

        }

        var normal = this.attributes.normal;

        if ( normal !== undefined ) {

            var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

            normalMatrix.applyToVector3Array( normal.array );
            normal.needsUpdate = true;

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

    },

    rotateX: function() {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function() {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function() {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function() {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function() {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function() {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    center: function() {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    setFromObject: function( object ) {

        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

        var geometry = object.geometry;

        if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

            var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
            var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

            this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
            this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

            if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

                var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

                this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

            }

            if ( geometry.boundingSphere !== null ) {

                this.boundingSphere = geometry.boundingSphere.clone();

            }

            if ( geometry.boundingBox !== null ) {

                this.boundingBox = geometry.boundingBox.clone();

            }

        }
        else if ( object instanceof THREE.Mesh ) {

            if ( geometry instanceof THREE.Geometry ) {

                this.fromGeometry( geometry );

            }

        }

        return this;

    },

    updateFromObject: function( object ) {

        var geometry = object.geometry;

        if ( object instanceof THREE.Mesh ) {

            var direct = geometry.__directGeometry;

            if ( direct === undefined ) {

                return this.fromGeometry( geometry );

            }

            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;

            geometry = direct;

        }

        if ( geometry.verticesNeedUpdate === true ) {

            var attribute = this.attributes.position;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.vertices );
                attribute.needsUpdate = true;

            }

            geometry.verticesNeedUpdate = false;

        }

        if ( geometry.normalsNeedUpdate === true ) {

            var attribute = this.attributes.normal;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.normals );
                attribute.needsUpdate = true;

            }

            geometry.normalsNeedUpdate = false;

        }

        if ( geometry.colorsNeedUpdate === true ) {

            var attribute = this.attributes.color;

            if ( attribute !== undefined ) {

                attribute.copyColorsArray( geometry.colors );
                attribute.needsUpdate = true;

            }

            geometry.colorsNeedUpdate = false;

        }

        if ( geometry.lineDistancesNeedUpdate ) {

            var attribute = this.attributes.lineDistance;

            if ( attribute !== undefined ) {

                attribute.copyArray( geometry.lineDistances );
                attribute.needsUpdate = true;

            }

            geometry.lineDistancesNeedUpdate = false;

        }

        if ( geometry.groupsNeedUpdate ) {

            geometry.computeGroups( object.geometry );
            this.groups = geometry.groups;

            geometry.groupsNeedUpdate = false;

        }

        return this;

    },

    fromGeometry: function( geometry ) {

        geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

        return this.fromDirectGeometry( geometry.__directGeometry );

    },

    fromDirectGeometry: function( geometry ) {

        var positions = new Float32Array( geometry.vertices.length * 3 );
        this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

        if ( geometry.normals.length > 0 ) {

            var normals = new Float32Array( geometry.normals.length * 3 );
            this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

        }

        if ( geometry.colors.length > 0 ) {

            var colors = new Float32Array( geometry.colors.length * 3 );
            this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

        }

        if ( geometry.uvs.length > 0 ) {

            var uvs = new Float32Array( geometry.uvs.length * 2 );
            this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

        }

        if ( geometry.uvs2.length > 0 ) {

            var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
            this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

        }

        if ( geometry.indices.length > 0 ) {

            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
            var indices = new TypeArray( geometry.indices.length * 3 );
            this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

        }

        // groups

        this.groups = geometry.groups;

        // morphs

        for ( var name in geometry.morphTargets ) {

            var array = [];
            var morphTargets = geometry.morphTargets[ name ];

            for ( var i = 0, l = morphTargets.length; i < l; i++ ) {

                var morphTarget = morphTargets[ i ];

                var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

                array.push( attribute.copyVector3sArray( morphTarget ) );

            }

            this.morphAttributes[ name ] = array;

        }

        // skinning

        if ( geometry.skinIndices.length > 0 ) {

            var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
            this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

        }

        if ( geometry.skinWeights.length > 0 ) {

            var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
            this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

        }

        //

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        return this;

    },

    computeBoundingBox: function() {

        var vector = new THREE.Vector3();

        return function() {

            if ( this.boundingBox === null ) {

                this.boundingBox = new THREE.Box3();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                var bb = this.boundingBox;
                bb.makeEmpty();

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    bb.expandByPoint( vector );

                }

            }

            if ( positions === undefined || positions.length === 0 ) {

                this.boundingBox.min.set( 0, 0, 0 );
                this.boundingBox.max.set( 0, 0, 0 );

            }

            if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

                console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

            }

        };

    }(),

    computeBoundingSphere: function() {

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();

        return function() {

            if ( this.boundingSphere === null ) {

                this.boundingSphere = new THREE.Sphere();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                box.makeEmpty();

                var center = this.boundingSphere.center;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    box.expandByPoint( vector );

                }

                box.center( center );

                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                var maxRadiusSq = 0;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

                }

                this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

                if ( isNaN( this.boundingSphere.radius ) ) {

                    console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

                }

            }

        };

    }(),

    computeFaceNormals: function() {

        // backwards compatibility

    },

    computeVertexNormals: function() {

        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;

        if ( attributes.position ) {

            var positions = attributes.position.array;

            if ( attributes.normal === undefined ) {

                this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

            }
            else {

                // reset existing normals to zero

                var normals = attributes.normal.array;

                for ( var i = 0, il = normals.length; i < il; i++ ) {

                    normals[ i ] = 0;

                }

            }

            var normals = attributes.normal.array;

            var vA, vB, vC,

                pA = new THREE.Vector3(),
                pB = new THREE.Vector3(),
                pC = new THREE.Vector3(),

                cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            // indexed elements

            if ( index ) {

                var indices = index.array;

                if ( groups.length === 0 ) {

                    this.addGroup( 0, indices.length );

                }

                for ( var j = 0, jl = groups.length; j < jl; ++j ) {

                    var group = groups[ j ];

                    var start = group.start;
                    var count = group.count;

                    for ( var i = start, il = start + count; i < il; i += 3 ) {

                        vA = indices[ i + 0 ] * 3;
                        vB = indices[ i + 1 ] * 3;
                        vC = indices[ i + 2 ] * 3;

                        pA.fromArray( positions, vA );
                        pB.fromArray( positions, vB );
                        pC.fromArray( positions, vC );

                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );

                        normals[ vA ] += cb.x;
                        normals[ vA + 1 ] += cb.y;
                        normals[ vA + 2 ] += cb.z;

                        normals[ vB ] += cb.x;
                        normals[ vB + 1 ] += cb.y;
                        normals[ vB + 2 ] += cb.z;

                        normals[ vC ] += cb.x;
                        normals[ vC + 1 ] += cb.y;
                        normals[ vC + 2 ] += cb.z;

                    }

                }

            }
            else {

                // non-indexed elements (unconnected triangle soup)

                for ( var i = 0, il = positions.length; i < il; i += 9 ) {

                    pA.fromArray( positions, i );
                    pB.fromArray( positions, i + 3 );
                    pC.fromArray( positions, i + 6 );

                    cb.subVectors( pC, pB );
                    ab.subVectors( pA, pB );
                    cb.cross( ab );

                    normals[ i ] = cb.x;
                    normals[ i + 1 ] = cb.y;
                    normals[ i + 2 ] = cb.z;

                    normals[ i + 3 ] = cb.x;
                    normals[ i + 4 ] = cb.y;
                    normals[ i + 5 ] = cb.z;

                    normals[ i + 6 ] = cb.x;
                    normals[ i + 7 ] = cb.y;
                    normals[ i + 8 ] = cb.z;

                }

            }

            this.normalizeNormals();

            attributes.normal.needsUpdate = true;

        }

    },

    computeTangents: function() {

        console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

    },

    computeOffsets: function( size ) {

        console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' )

    },

    merge: function( geometry, offset ) {

        if ( geometry instanceof THREE.BufferGeometry === false ) {

            console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
            return;

        }

        if ( offset === undefined ) offset = 0;

        var attributes = this.attributes;

        for ( var key in attributes ) {

            if ( geometry.attributes[ key ] === undefined ) continue;

            var attribute1 = attributes[ key ];
            var attributeArray1 = attribute1.array;

            var attribute2 = geometry.attributes[ key ];
            var attributeArray2 = attribute2.array;

            var attributeSize = attribute2.itemSize;

            for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++ ) {

                attributeArray1[ j ] = attributeArray2[ i ];

            }

        }

        return this;

    },

    normalizeNormals: function() {

        var normals = this.attributes.normal.array;

        var x, y, z, n;

        for ( var i = 0, il = normals.length; i < il; i += 3 ) {

            x = normals[ i ];
            y = normals[ i + 1 ];
            z = normals[ i + 2 ];

            n = 1.0 / Math.sqrt( x * x + y * y + z * z );

            normals[ i ] *= n;
            normals[ i + 1 ] *= n;
            normals[ i + 2 ] *= n;

        }

    },

    toJSON: function() {

        var data = {
            metadata: {
                version: 4.4,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };

        // standard BufferGeometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        data.data = {
            attributes: {}
        };

        var index = this.index;

        if ( index !== null ) {

            var array = Array.prototype.slice.call( index.array );

            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };

        }

        var attributes = this.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];

            var array = Array.prototype.slice.call( attribute.array );

            data.data.attributes[ key ] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array
            };

        }

        var groups = this.groups;

        if ( groups.length > 0 ) {

            data.data.groups = JSON.parse( JSON.stringify( groups ) );

        }

        var boundingSphere = this.boundingSphere;

        if ( boundingSphere !== null ) {

            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };

        }

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        var index = source.index;

        if ( index !== null ) {

            this.setIndex( index.clone() );

        }

        var attributes = source.attributes;

        for ( var name in attributes ) {

            var attribute = attributes[ name ];
            this.addAttribute( name, attribute.clone() );

        }

        var groups = source.groups;

        for ( var i = 0, l = groups.length; i < l; i++ ) {

            var group = groups[ i ];
            this.addGroup( group.start, group.count );

        }

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function() {

    THREE.BufferGeometry.call( this );

    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function( start, count, instances ) {

    this.groups.push( {

        start: start,
        count: count,
        instances: instances

    } );

};

THREE.InstancedBufferGeometry.prototype.copy = function( source ) {

    var index = source.index;

    if ( index !== null ) {

        this.setIndex( index.clone() );

    }

    var attributes = source.attributes;

    for ( var name in attributes ) {

        var attribute = attributes[ name ];
        this.addAttribute( name, attribute.clone() );

    }

    var groups = source.groups;

    for ( var i = 0, l = groups.length; i < l; i++ ) {

        var group = groups[ i ];
        this.addGroup( group.start, group.count, group.instances );

    }

    return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Camera = function() {

    THREE.Object3D.call( this );

    this.type = 'Camera';

    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function() {

    var quaternion = new THREE.Quaternion();

    return function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.getWorldQuaternion( quaternion );

        return result.set( 0, 0, -1 ).applyQuaternion( quaternion );

    };

}();

THREE.Camera.prototype.lookAt = function() {

    // This routine does not support cameras with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function( vector ) {

        m1.lookAt( this.position, vector, this.up );

        this.quaternion.setFromRotationMatrix( m1 );

    };

}();

THREE.Camera.prototype.clone = function() {

    return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.matrixWorldInverse.copy( source.matrixWorldInverse );
    this.projectionMatrix.copy( source.projectionMatrix );

    return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function( near, far, cubeResolution ) {

    THREE.Object3D.call( this );

    this.type = 'CubeCamera';

    var fov = 90,
        aspect = 1;

    var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPX.up.set( 0, -1, 0 );
    cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
    this.add( cameraPX );

    var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNX.up.set( 0, -1, 0 );
    cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
    this.add( cameraNX );

    var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPY.up.set( 0, 0, 1 );
    cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
    this.add( cameraPY );

    var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNY.up.set( 0, 0, -1 );
    cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
    this.add( cameraNY );

    var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPZ.up.set( 0, -1, 0 );
    cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
    this.add( cameraPZ );

    var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNZ.up.set( 0, -1, 0 );
    cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
    this.add( cameraNZ );

    this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    } );

    this.updateCubeMap = function( renderer, scene ) {

        if ( this.parent === null ) this.updateMatrixWorld();

        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.generateMipmaps;

        renderTarget.generateMipmaps = false;

        renderTarget.activeCubeFace = 0;
        renderer.render( scene, cameraPX, renderTarget );

        renderTarget.activeCubeFace = 1;
        renderer.render( scene, cameraNX, renderTarget );

        renderTarget.activeCubeFace = 2;
        renderer.render( scene, cameraPY, renderTarget );

        renderTarget.activeCubeFace = 3;
        renderer.render( scene, cameraNY, renderTarget );

        renderTarget.activeCubeFace = 4;
        renderer.render( scene, cameraPZ, renderTarget );

        renderTarget.generateMipmaps = generateMipmaps;

        renderTarget.activeCubeFace = 5;
        renderer.render( scene, cameraNZ, renderTarget );

        renderer.setRenderTarget( null );

    };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function( left, right, top, bottom, near, far ) {

    THREE.Camera.call( this );

    this.type = 'OrthographicCamera';

    this.zoom = 1;

    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;

    this.near = ( near !== undefined ) ? near : 0.1;
    this.far = ( far !== undefined ) ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {

    var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    var cx = ( this.right + this.left ) / 2;
    var cy = ( this.top + this.bottom ) / 2;

    this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.OrthographicCamera.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function( fov, aspect, near, far ) {

    THREE.Camera.call( this );

    this.type = 'PerspectiveCamera';

    this.zoom = 1;

    this.fov = fov !== undefined ? fov : 50;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function( focalLength, frameHeight ) {

    if ( frameHeight === undefined ) frameHeight = 24;

    this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
    this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function( fullWidth, fullHeight, x, y, width, height ) {

    this.fullWidth = fullWidth;
    this.fullHeight = fullHeight;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {

    var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

    if ( this.fullWidth ) {

        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs( right - left );
        var height = Math.abs( top - bottom );

        this.projectionMatrix.makeFrustum(
            left + this.x * width / this.fullWidth,
            left + ( this.x + this.width ) * width / this.fullWidth,
            top - ( this.y + this.height ) * height / this.fullHeight,
            top - this.y * height / this.fullHeight,
            this.near,
            this.far
        );

    }
    else {

        this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

    }

};

THREE.PerspectiveCamera.prototype.copy = function( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.fov = source.fov;
    this.aspect = source.aspect;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.fov = this.fov;
    data.object.aspect = this.aspect;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function( color ) {

    THREE.Object3D.call( this );

    this.type = 'Light';

    this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.color.copy( source.color );

    return this;

};
// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function( color ) {

    THREE.Light.call( this, color );

    this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();

    return data;

};

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function( color, intensity ) {

    THREE.Light.call( this, color );

    this.type = 'DirectionalLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;

    this.castShadow = false;
    this.onlyShadow = false;

    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5000;

    this.shadowCameraLeft = -500;
    this.shadowCameraRight = 500;
    this.shadowCameraTop = 500;
    this.shadowCameraBottom = -500;

    this.shadowCameraVisible = false;

    this.shadowBias = 0;
    this.shadowDarkness = 0.5;

    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;

    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.target = source.target.clone();

    this.castShadow = source.castShadow;
    this.onlyShadow = source.onlyShadow;

    this.shadowCameraNear = source.shadowCameraNear;
    this.shadowCameraFar = source.shadowCameraFar;

    this.shadowCameraLeft = source.shadowCameraLeft;
    this.shadowCameraRight = source.shadowCameraRight;
    this.shadowCameraTop = source.shadowCameraTop;
    this.shadowCameraBottom = source.shadowCameraBottom;

    this.shadowCameraVisible = source.shadowCameraVisible;

    this.shadowBias = source.shadowBias;
    this.shadowDarkness = source.shadowDarkness;

    this.shadowMapWidth = source.shadowMapWidth;
    this.shadowMapHeight = source.shadowMapHeight;

    return this;

};

THREE.DirectionalLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;

    return data;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function( skyColor, groundColor, intensity ) {

    THREE.Light.call( this, skyColor );

    this.type = 'HemisphereLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.groundColor = new THREE.Color( groundColor );
    this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.groundColor.copy( source.groundColor );
    this.intensity = source.intensity;

    return this;

};

THREE.HemisphereLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.groundColor = this.groundColor.getHex();
    data.object.intensity = this.intensity;

    return data;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function( color, intensity, distance, decay ) {

    THREE.Light.call( this, color );

    this.type = 'PointLight';

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.decay = source.decay;

    return this;

};

THREE.PointLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    data.object.distance = this.distance;
    data.object.decay = this.decay;

    return data;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function( color, intensity, distance, angle, exponent, decay ) {

    THREE.Light.call( this, color );

    this.type = 'SpotLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    this.exponent = ( exponent !== undefined ) ? exponent : 10;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

    this.castShadow = false;
    this.onlyShadow = false;

    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5000;
    this.shadowCameraFov = 50;

    this.shadowCameraVisible = false;

    this.shadowBias = 0;
    this.shadowDarkness = 0.5;

    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;

    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.angle = source.angle;
    this.exponent = source.exponent;
    this.decay = source.decay;

    this.target = source.target.clone();

    this.castShadow = source.castShadow;
    this.onlyShadow = source.onlyShadow;

    this.shadowCameraNear = source.shadowCameraNear;
    this.shadowCameraFar = source.shadowCameraFar;
    this.shadowCameraFov = source.shadowCameraFov;

    this.shadowCameraVisible = source.shadowCameraVisible;

    this.shadowBias = source.shadowBias;
    this.shadowDarkness = source.shadowDarkness;

    this.shadowMapWidth = source.shadowMapWidth;
    this.shadowMapHeight = source.shadowMapHeight;

    return this;
}

THREE.SpotLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    data.object.distance = this.distance;
    data.object.angle = this.angle;
    data.object.exponent = this.exponent;
    data.object.decay = this.decay;

    return data;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

    enabled: false,

    files: {},

    add: function( key, file ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Adding key:', key );

        this.files[ key ] = file;

    },

    get: function( key ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Checking key:', key );

        return this.files[ key ];

    },

    remove: function( key ) {

        delete this.files[ key ];

    },

    clear: function() {

        this.files = {};

    }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function() {

    this.onLoadStart = function() {};
    this.onLoadProgress = function() {};
    this.onLoadComplete = function() {};

};

THREE.Loader.prototype = {

    constructor: THREE.Loader,

    crossOrigin: undefined,

    extractUrlBase: function( url ) {

        var parts = url.split( '/' );

        if ( parts.length === 1 ) return './';

        parts.pop();

        return parts.join( '/' ) + '/';

    },

    initMaterials: function( materials, texturePath, crossOrigin ) {

        var array = [];

        for ( var i = 0; i < materials.length; ++i ) {

            array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

        }

        return array;

    },

    createMaterial: ( function() {

        var imageLoader;

        return function createMaterial( m, texturePath, crossOrigin ) {

            var scope = this;

            if ( crossOrigin === undefined && scope.crossOrigin !== undefined ) crossOrigin = scope.crossOrigin;

            if ( imageLoader === undefined ) imageLoader = new THREE.ImageLoader();

            function nearest_pow2( n ) {

                var l = Math.log( n ) / Math.LN2;
                return Math.pow( 2, Math.round( l ) );

            }

            function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

                var fullPath = texturePath + sourceFile;

                var texture;

                var loader = THREE.Loader.Handlers.get( fullPath );

                if ( loader !== null ) {

                    texture = loader.load( fullPath );

                }
                else {

                    texture = new THREE.Texture();

                    loader = imageLoader;
                    loader.setCrossOrigin( crossOrigin );
                    loader.load( fullPath, function( image ) {

                        if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
                            THREE.Math.isPowerOfTwo( image.height ) === false ) {

                            var width = nearest_pow2( image.width );
                            var height = nearest_pow2( image.height );

                            var canvas = document.createElement( 'canvas' );
                            canvas.width = width;
                            canvas.height = height;

                            var context = canvas.getContext( '2d' );
                            context.drawImage( image, 0, 0, width, height );

                            texture.image = canvas;

                        }
                        else {

                            texture.image = image;

                        }

                        texture.needsUpdate = true;

                    } );

                }

                texture.sourceFile = sourceFile;

                if ( repeat ) {

                    texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

                    if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
                    if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

                }

                if ( offset ) {

                    texture.offset.set( offset[ 0 ], offset[ 1 ] );

                }

                if ( wrap ) {

                    var wrapMap = {
                        'repeat': THREE.RepeatWrapping,
                        'mirror': THREE.MirroredRepeatWrapping
                    };

                    if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
                    if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

                }

                if ( anisotropy ) {

                    texture.anisotropy = anisotropy;

                }

                where[ name ] = texture;

            }

            function rgb2hex( rgb ) {

                return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

            }

            // defaults

            var mtype = 'MeshLambertMaterial';
            var mpars = {};

            // parameters from model file

            if ( m.shading ) {

                var shading = m.shading.toLowerCase();

                if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
                else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

            }

            if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

                mpars.blending = THREE[ m.blending ];

            }

            if ( m.transparent !== undefined ) {

                mpars.transparent = m.transparent;

            }

            if ( m.opacity !== undefined && m.opacity < 1.0 ) {

                mpars.transparent = true;

            }

            if ( m.depthTest !== undefined ) {

                mpars.depthTest = m.depthTest;

            }

            if ( m.depthWrite !== undefined ) {

                mpars.depthWrite = m.depthWrite;

            }

            if ( m.visible !== undefined ) {

                mpars.visible = m.visible;

            }

            if ( m.flipSided !== undefined ) {

                mpars.side = THREE.BackSide;

            }

            if ( m.doubleSided !== undefined ) {

                mpars.side = THREE.DoubleSide;

            }

            if ( m.wireframe !== undefined ) {

                mpars.wireframe = m.wireframe;

            }

            if ( m.vertexColors !== undefined ) {

                if ( m.vertexColors === 'face' ) {

                    mpars.vertexColors = THREE.FaceColors;

                }
                else if ( m.vertexColors ) {

                    mpars.vertexColors = THREE.VertexColors;

                }

            }

            // colors

            if ( m.colorDiffuse ) {

                mpars.color = rgb2hex( m.colorDiffuse );

            }
            else if ( m.DbgColor ) {

                mpars.color = m.DbgColor;

            }

            if ( m.colorEmissive ) {

                mpars.emissive = rgb2hex( m.colorEmissive );

            }

            if ( mtype === 'MeshPhongMaterial' ) {

                if ( m.colorSpecular ) {

                    mpars.specular = rgb2hex( m.colorSpecular );

                }

                if ( m.specularCoef ) {

                    mpars.shininess = m.specularCoef;

                }

            }

            // modifiers

            if ( m.transparency !== undefined ) {

                console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
                m.opacity = m.transparency;

            }

            if ( m.opacity !== undefined ) {

                mpars.opacity = m.opacity;

            }

            // textures

            if ( texturePath ) {

                if ( m.mapDiffuse ) {

                    create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

                }

                if ( m.mapLight ) {

                    create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

                }

                if ( m.mapAO ) {

                    create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

                }

                if ( m.mapBump ) {

                    create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

                }

                if ( m.mapNormal ) {

                    create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

                }

                if ( m.mapSpecular ) {

                    create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

                }

                if ( m.mapAlpha ) {

                    create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

                }

            }

            //

            if ( m.mapBumpScale ) {

                mpars.bumpScale = m.mapBumpScale;

            }

            if ( m.mapNormalFactor ) {

                mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

            }

            var material = new THREE[ mtype ]( mpars );

            if ( m.DbgName !== undefined ) material.name = m.DbgName;

            return material;

        };

    } )()

};

THREE.Loader.Handlers = {

    handlers: [],

    add: function( regex, loader ) {

        this.handlers.push( regex, loader );

    },

    get: function( file ) {

        for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

            var regex = this.handlers[ i ];
            var loader = this.handlers[ i + 1 ];

            if ( regex.test( file ) ) {

                return loader;

            }

        }

        return null;

    }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

    constructor: THREE.XHRLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function() {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var request = new XMLHttpRequest();
        request.open( 'GET', url, true );

        request.addEventListener( 'load', function( event ) {

            THREE.Cache.add( url, this.response );

            if ( onLoad ) onLoad( this.response );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            request.addEventListener( 'progress', function( event ) {

                onProgress( event );

            }, false );

        }

        request.addEventListener( 'error', function( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
        if ( this.responseType !== undefined ) request.responseType = this.responseType;
        if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

        request.send( null );

        scope.manager.itemStart( url );

        return request;

    },

    setResponseType: function( value ) {

        this.responseType = value;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setWithCredentials: function( value ) {

        this.withCredentials = value;

    }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

    constructor: THREE.ImageLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function() {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var image = document.createElement( 'img' );

        image.addEventListener( 'load', function( event ) {

            THREE.Cache.add( url, this );

            if ( onLoad ) onLoad( this );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            image.addEventListener( 'progress', function( event ) {

                onProgress( event );

            }, false );

        }

        image.addEventListener( 'error', function( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

        scope.manager.itemStart( url );

        image.src = url;

        return image;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function( manager ) {

    if ( typeof manager === 'boolean' ) {

        console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
        manager = undefined;

    }

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

    constructor: THREE.JSONLoader,

    // Deprecated

    get statusDomElement() {

        if ( this._statusDomElement === undefined ) {

            this._statusDomElement = document.createElement( 'div' );

        }

        console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
        return this._statusDomElement;

    },

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setWithCredentials( this.withCredentials );
        loader.load( url, function( text ) {

            var json = JSON.parse( text );
            var metadata = json.metadata;

            if ( metadata !== undefined ) {

                if ( metadata.type === 'object' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
                    return;

                }

                if ( metadata.type === 'scene' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
                    return;

                }

            }

            var object = scope.parse( json, texturePath );
            onLoad( object.geometry, object.materials );

        } );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setTexturePath: function( value ) {

        this.texturePath = value;

    },

    parse: function( json, texturePath ) {

        var geometry = new THREE.Geometry(),
            scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

        parseModel( scale );

        parseSkin();
        parseMorphing( scale );

        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();

        function parseModel( scale ) {

            function isBitSet( value, position ) {

                return value & ( 1 << position );

            }

            var i, j, fi,

                offset, zLength,

                colorIndex, normalIndex, uvIndex, materialIndex,

                type,
                isQuad,
                hasMaterial,
                hasFaceVertexUv,
                hasFaceNormal, hasFaceVertexNormal,
                hasFaceColor, hasFaceVertexColor,

                vertex, face, faceA, faceB, hex, normal,

                uvLayer, uv, u, v,

                faces = json.faces,
                vertices = json.vertices,
                normals = json.normals,
                colors = json.colors,

                nUvLayers = 0;

            if ( json.uvs !== undefined ) {

                // disregard empty arrays

                for ( i = 0; i < json.uvs.length; i++ ) {

                    if ( json.uvs[ i ].length ) nUvLayers++;

                }

                for ( i = 0; i < nUvLayers; i++ ) {

                    geometry.faceVertexUvs[ i ] = [];

                }

            }

            offset = 0;
            zLength = vertices.length;

            while ( offset < zLength ) {

                vertex = new THREE.Vector3();

                vertex.x = vertices[ offset++ ] * scale;
                vertex.y = vertices[ offset++ ] * scale;
                vertex.z = vertices[ offset++ ] * scale;

                geometry.vertices.push( vertex );

            }

            offset = 0;
            zLength = faces.length;

            while ( offset < zLength ) {

                type = faces[ offset++ ];


                isQuad = isBitSet( type, 0 );
                hasMaterial = isBitSet( type, 1 );
                hasFaceVertexUv = isBitSet( type, 3 );
                hasFaceNormal = isBitSet( type, 4 );
                hasFaceVertexNormal = isBitSet( type, 5 );
                hasFaceColor = isBitSet( type, 6 );
                hasFaceVertexColor = isBitSet( type, 7 );

                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                if ( isQuad ) {

                    faceA = new THREE.Face3();
                    faceA.a = faces[ offset ];
                    faceA.b = faces[ offset + 1 ];
                    faceA.c = faces[ offset + 3 ];

                    faceB = new THREE.Face3();
                    faceB.a = faces[ offset + 1 ];
                    faceB.b = faces[ offset + 2 ];
                    faceB.c = faces[ offset + 3 ];

                    offset += 4;

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset++ ];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];
                            geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                            for ( j = 0; j < 4; j++ ) {

                                uvIndex = faces[ offset++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset++ ] * 3;

                        faceA.normal.set(
                            normals[ normalIndex++ ],
                            normals[ normalIndex++ ],
                            normals[ normalIndex ]
                        );

                        faceB.normal.copy( faceA.normal );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 4; i++ ) {

                            normalIndex = faces[ offset++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex++ ],
                                normals[ normalIndex++ ],
                                normals[ normalIndex ]
                            );


                            if ( i !== 2 ) faceA.vertexNormals.push( normal );
                            if ( i !== 0 ) faceB.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset++ ];
                        hex = colors[ colorIndex ];

                        faceA.color.setHex( hex );
                        faceB.color.setHex( hex );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 4; i++ ) {

                            colorIndex = faces[ offset++ ];
                            hex = colors[ colorIndex ];

                            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
                            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

                        }

                    }

                    geometry.faces.push( faceA );
                    geometry.faces.push( faceB );

                }
                else {

                    face = new THREE.Face3();
                    face.a = faces[ offset++ ];
                    face.b = faces[ offset++ ];
                    face.c = faces[ offset++ ];

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset++ ];
                        face.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];

                            for ( j = 0; j < 3; j++ ) {

                                uvIndex = faces[ offset++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                geometry.faceVertexUvs[ i ][ fi ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset++ ] * 3;

                        face.normal.set(
                            normals[ normalIndex++ ],
                            normals[ normalIndex++ ],
                            normals[ normalIndex ]
                        );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 3; i++ ) {

                            normalIndex = faces[ offset++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex++ ],
                                normals[ normalIndex++ ],
                                normals[ normalIndex ]
                            );

                            face.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset++ ];
                        face.color.setHex( colors[ colorIndex ] );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 3; i++ ) {

                            colorIndex = faces[ offset++ ];
                            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

                        }

                    }

                    geometry.faces.push( face );

                }

            }

        };

        function parseSkin() {

            var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

            if ( json.skinWeights ) {

                for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

                    var x = json.skinWeights[ i ];
                    var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
                    var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
                    var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

                    geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

                }

            }

            if ( json.skinIndices ) {

                for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

                    var a = json.skinIndices[ i ];
                    var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
                    var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
                    var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

                    geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

                }

            }

            geometry.bones = json.bones;

            if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

                console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                    geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

            }


            // could change this to json.animations[0] or remove completely

            geometry.animation = json.animation;
            geometry.animations = json.animations;

        };

        function parseMorphing( scale ) {

            if ( json.morphTargets !== undefined ) {

                var i, l, v, vl, dstVertices, srcVertices;

                for ( i = 0, l = json.morphTargets.length; i < l; i++ ) {

                    geometry.morphTargets[ i ] = {};
                    geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
                    geometry.morphTargets[ i ].vertices = [];

                    dstVertices = geometry.morphTargets[ i ].vertices;
                    srcVertices = json.morphTargets[ i ].vertices;

                    for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

                        var vertex = new THREE.Vector3();
                        vertex.x = srcVertices[ v ] * scale;
                        vertex.y = srcVertices[ v + 1 ] * scale;
                        vertex.z = srcVertices[ v + 2 ] * scale;

                        dstVertices.push( vertex );

                    }

                }

            }

            if ( json.morphColors !== undefined ) {

                var i, l, c, cl, dstColors, srcColors, color;

                for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

                    geometry.morphColors[ i ] = {};
                    geometry.morphColors[ i ].name = json.morphColors[ i ].name;
                    geometry.morphColors[ i ].colors = [];

                    dstColors = geometry.morphColors[ i ].colors;
                    srcColors = json.morphColors[ i ].colors;

                    for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

                        color = new THREE.Color( 0xffaa00 );
                        color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
                        dstColors.push( color );

                    }

                }

            }

        };

        if ( json.materials === undefined || json.materials.length === 0 ) {

            return {
                geometry: geometry
            };

        }
        else {

            var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

            return {
                geometry: geometry,
                materials: materials
            };

        }

    }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function( onLoad, onProgress, onError ) {

    var scope = this;

    var isLoading = false,
        itemsLoaded = 0,
        itemsTotal = 0;

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function( url ) {

        itemsTotal++;

        if ( isLoading === false ) {

            if ( scope.onStart !== undefined ) {

                scope.onStart( url, itemsLoaded, itemsTotal );

            }

        }

        isLoading = true;

    };

    this.itemEnd = function( url ) {

        itemsLoaded++;

        if ( scope.onProgress !== undefined ) {

            scope.onProgress( url, itemsLoaded, itemsTotal );

        }

        if ( itemsLoaded === itemsTotal ) {

            isLoading = false;

            if ( scope.onLoad !== undefined ) {

                scope.onLoad();

            }

        }

    };

    this.itemError = function( url ) {

        if ( scope.onError !== undefined ) {

            scope.onError( url );

        }

    };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

    constructor: THREE.BufferGeometryLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    parse: function( json ) {

        var geometry = new THREE.BufferGeometry();

        var index = json.data.index;

        if ( index !== undefined ) {

            var typedArray = new self[ index.type ]( index.array );
            geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

        }

        var attributes = json.data.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];
            var typedArray = new self[ attribute.type ]( attribute.array );

            geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

        }

        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

        if ( groups !== undefined ) {

            for ( var i = 0, n = groups.length; i !== n; ++i ) {

                var group = groups[ i ];

                geometry.addGroup( group.start, group.count );

            }

        }

        var boundingSphere = json.data.boundingSphere;

        if ( boundingSphere !== undefined ) {

            var center = new THREE.Vector3();

            if ( boundingSphere.center !== undefined ) {

                center.fromArray( boundingSphere.center );

            }

            geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

        }

        return geometry;

    }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.textures = {};

};

THREE.MaterialLoader.prototype = {

    constructor: THREE.MaterialLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setTextures: function( value ) {

        this.textures = value;

    },

    getTexture: function( name ) {

        var textures = this.textures;

        if ( textures[ name ] === undefined ) {

            console.warn( 'THREE.MaterialLoader: Undefined texture', name );

        }

        return textures[ name ];

    },

    parse: function( json ) {

        var material = new THREE[ json.type ];
        material.uuid = json.uuid;

        if ( json.name !== undefined ) material.name = json.name;
        if ( json.color !== undefined ) material.color.setHex( json.color );
        if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
        if ( json.specular !== undefined ) material.specular.setHex( json.specular );
        if ( json.shininess !== undefined ) material.shininess = json.shininess;
        if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
        if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
        if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
        if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
        if ( json.shading !== undefined ) material.shading = json.shading;
        if ( json.blending !== undefined ) material.blending = json.blending;
        if ( json.side !== undefined ) material.side = json.side;
        if ( json.opacity !== undefined ) material.opacity = json.opacity;
        if ( json.transparent !== undefined ) material.transparent = json.transparent;
        if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
        if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
        if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
        if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
        if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

        // for PointsMaterial
        if ( json.size !== undefined ) material.size = json.size;
        if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

        // maps

        if ( json.map !== undefined ) material.map = this.getTexture( json.map );

        if ( json.alphaMap !== undefined ) {

            material.alphaMap = this.getTexture( json.alphaMap );
            material.transparent = true;

        }

        if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
        if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

        if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
        if ( json.normalScale ) material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

        if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
        if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
        if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

        if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

        if ( json.envMap !== undefined ) {

            material.envMap = this.getTexture( json.envMap );
            material.combine = THREE.MultiplyOperation;

        }

        if ( json.reflectivity ) material.reflectivity = json.reflectivity;

        if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
        if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

        if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
        if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

        // MeshFaceMaterial

        if ( json.materials !== undefined ) {

            for ( var i = 0, l = json.materials.length; i < l; i++ ) {

                material.materials.push( this.parse( json.materials[ i ] ) );

            }

        }

        return material;

    }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

    constructor: THREE.ObjectLoader,

    load: function( url, onLoad, onProgress, onError ) {

        if ( this.texturePath === '' ) {

            this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

        }

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            scope.parse( JSON.parse( text ), onLoad );

        }, onProgress, onError );

    },

    setTexturePath: function( value ) {

        this.texturePath = value;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    parse: function( json, onLoad ) {

        var geometries = this.parseGeometries( json.geometries );

        var images = this.parseImages( json.images, function() {

            if ( onLoad !== undefined ) onLoad( object );

        } );

        var textures = this.parseTextures( json.textures, images );
        var materials = this.parseMaterials( json.materials, textures );
        var object = this.parseObject( json.object, geometries, materials );

        if ( json.images === undefined || json.images.length === 0 ) {

            if ( onLoad !== undefined ) onLoad( object );

        }

        return object;

    },

    parseGeometries: function( json ) {

        var geometries = {};

        if ( json !== undefined ) {

            var geometryLoader = new THREE.JSONLoader();
            var bufferGeometryLoader = new THREE.BufferGeometryLoader();

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var geometry;
                var data = json[ i ];

                switch ( data.type ) {

                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':

                        geometry = new THREE[ data.type ](
                            data.width,
                            data.height,
                            data.widthSegments,
                            data.heightSegments
                        );

                        break;

                    case 'BoxGeometry':
                    case 'CubeGeometry': // backwards compatible

                        geometry = new THREE.BoxGeometry(
                            data.width,
                            data.height,
                            data.depth,
                            data.widthSegments,
                            data.heightSegments,
                            data.depthSegments
                        );

                        break;

                    case 'CircleBufferGeometry':

                        geometry = new THREE.CircleBufferGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CircleGeometry':

                        geometry = new THREE.CircleGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CylinderGeometry':

                        geometry = new THREE.CylinderGeometry(
                            data.radiusTop,
                            data.radiusBottom,
                            data.height,
                            data.radialSegments,
                            data.heightSegments,
                            data.openEnded,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereGeometry':

                        geometry = new THREE.SphereGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereBufferGeometry':

                        geometry = new THREE.SphereBufferGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'DodecahedronGeometry':

                        geometry = new THREE.DodecahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'IcosahedronGeometry':

                        geometry = new THREE.IcosahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'OctahedronGeometry':

                        geometry = new THREE.OctahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'TetrahedronGeometry':

                        geometry = new THREE.TetrahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'RingGeometry':

                        geometry = new THREE.RingGeometry(
                            data.innerRadius,
                            data.outerRadius,
                            data.thetaSegments,
                            data.phiSegments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'TorusGeometry':

                        geometry = new THREE.TorusGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.arc
                        );

                        break;

                    case 'TorusKnotGeometry':

                        geometry = new THREE.TorusKnotGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.p,
                            data.q,
                            data.heightScale
                        );

                        break;

                    case 'TextGeometry':

                        geometry = new THREE.TextGeometry(
                            data.text,
                            data.data
                        );

                        break;

                    case 'BufferGeometry':

                        geometry = bufferGeometryLoader.parse( data );

                        break;

                    case 'Geometry':

                        geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

                        break;

                    default:

                        console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

                        continue;

                }

                geometry.uuid = data.uuid;

                if ( data.name !== undefined ) geometry.name = data.name;

                geometries[ data.uuid ] = geometry;

            }

        }

        return geometries;

    },

    parseMaterials: function( json, textures ) {

        var materials = {};

        if ( json !== undefined ) {

            var loader = new THREE.MaterialLoader();
            loader.setTextures( textures );

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var material = loader.parse( json[ i ] );
                materials[ material.uuid ] = material;

            }

        }

        return materials;

    },

    parseImages: function( json, onLoad ) {

        var scope = this;
        var images = {};

        function loadImage( url ) {

            scope.manager.itemStart( url );

            return loader.load( url, function() {

                scope.manager.itemEnd( url );

            } );

        }

        if ( json !== undefined && json.length > 0 ) {

            var manager = new THREE.LoadingManager( onLoad );

            var loader = new THREE.ImageLoader( manager );
            loader.setCrossOrigin( this.crossOrigin );

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var image = json[ i ];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

                images[ image.uuid ] = loadImage( path );

            }

        }

        return images;

    },

    parseTextures: function( json, images ) {

        function parseConstant( value ) {

            if ( typeof( value ) === 'number' ) return value;

            console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

            return THREE[ value ];

        }

        var textures = {};

        if ( json !== undefined ) {

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var data = json[ i ];

                if ( data.image === undefined ) {

                    console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

                }

                if ( images[ data.image ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

                }

                var texture = new THREE.Texture( images[ data.image ] );
                texture.needsUpdate = true;

                texture.uuid = data.uuid;

                if ( data.name !== undefined ) texture.name = data.name;
                if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
                if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
                if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
                if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
                if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
                if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
                if ( Array.isArray( data.wrap ) ) {

                    texture.wrapS = parseConstant( data.wrap[ 0 ] );
                    texture.wrapT = parseConstant( data.wrap[ 1 ] );

                }

                textures[ data.uuid ] = texture;

            }

        }

        return textures;

    },

    parseObject: function() {

        var matrix = new THREE.Matrix4();

        return function( data, geometries, materials ) {

            var object;

            var getGeometry = function( name ) {

                if ( geometries[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

                }

                return geometries[ name ];

            };

            var getMaterial = function( name ) {

                if ( materials[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined material', name );

                }

                return materials[ name ];

            };

            switch ( data.type ) {

                case 'Scene':

                    object = new THREE.Scene();

                    break;

                case 'PerspectiveCamera':

                    object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

                    break;

                case 'OrthographicCamera':

                    object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

                    break;

                case 'AmbientLight':

                    object = new THREE.AmbientLight( data.color );

                    break;

                case 'DirectionalLight':

                    object = new THREE.DirectionalLight( data.color, data.intensity );

                    break;

                case 'PointLight':

                    object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

                    break;

                case 'SpotLight':

                    object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

                    break;

                case 'HemisphereLight':

                    object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

                    break;

                case 'Mesh':

                    object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'LOD':

                    object = new THREE.LOD();

                    break;

                case 'Line':

                    object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

                    break;

                case 'PointCloud':
                case 'Points':

                    object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'Sprite':

                    object = new THREE.Sprite( getMaterial( data.material ) );

                    break;

                case 'Group':

                    object = new THREE.Group();

                    break;

                default:

                    object = new THREE.Object3D();

            }

            object.uuid = data.uuid;

            if ( data.name !== undefined ) object.name = data.name;
            if ( data.matrix !== undefined ) {

                matrix.fromArray( data.matrix );
                matrix.decompose( object.position, object.quaternion, object.scale );

            }
            else {

                if ( data.position !== undefined ) object.position.fromArray( data.position );
                if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
                if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

            }

            if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
            if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

            if ( data.visible !== undefined ) object.visible = data.visible;
            if ( data.userData !== undefined ) object.userData = data.userData;

            if ( data.children !== undefined ) {

                for ( var child in data.children ) {

                    object.add( this.parseObject( data.children[ child ], geometries, materials ) );

                }

            }

            if ( data.type === 'LOD' ) {

                var levels = data.levels;

                for ( var l = 0; l < levels.length; l++ ) {

                    var level = levels[ l ];
                    var child = object.getObjectByProperty( 'uuid', level.object );

                    if ( child !== undefined ) {

                        object.addLevel( child, level.distance );

                    }

                }

            }

            return object;

        }

    }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

    constructor: THREE.TextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.ImageLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( image ) {

            var texture = new THREE.Texture( image );
            texture.needsUpdate = true;

            if ( onLoad !== undefined ) {

                onLoad( texture );

            }

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

    constructor: THREE.BinaryTextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texture = new THREE.DataTexture();

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        loader.load( url, function( buffer ) {

            var texData = scope._parser( buffer );

            if ( !texData ) return;

            if ( undefined !== texData.image ) {

                texture.image = texData.image;

            }
            else if ( undefined !== texData.data ) {

                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;

            }

            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

            if ( undefined !== texData.format ) {

                texture.format = texData.format;

            }
            if ( undefined !== texData.type ) {

                texture.type = texData.type;

            }

            if ( undefined !== texData.mipmaps ) {

                texture.mipmaps = texData.mipmaps;

            }

            if ( 1 === texData.mipmapCount ) {

                texture.minFilter = THREE.LinearFilter;

            }

            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture, texData );

        }, onProgress, onError );


        return texture;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

    constructor: THREE.CompressedTextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var images = [];

        var texture = new THREE.CompressedTexture();
        texture.image = images;

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        if ( Array.isArray( url ) ) {

            var loaded = 0;

            var loadTexture = function( i ) {

                loader.load( url[ i ], function( buffer ) {

                    var texDatas = scope._parser( buffer, true );

                    images[ i ] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };

                    loaded += 1;

                    if ( loaded === 6 ) {

                        if ( texDatas.mipmapCount === 1 )
                            texture.minFilter = THREE.LinearFilter;

                        texture.format = texDatas.format;
                        texture.needsUpdate = true;

                        if ( onLoad ) onLoad( texture );

                    }

                }, onProgress, onError );

            };

            for ( var i = 0, il = url.length; i < il; ++i ) {

                loadTexture( i );

            }

        }
        else {

            // compressed cubemap texture stored in a single DDS file

            loader.load( url, function( buffer ) {

                var texDatas = scope._parser( buffer, true );

                if ( texDatas.isCubemap ) {

                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                    for ( var f = 0; f < faces; f++ ) {

                        images[ f ] = {
                            mipmaps: []
                        };

                        for ( var i = 0; i < texDatas.mipmapCount; i++ ) {

                            images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
                            images[ f ].format = texDatas.format;
                            images[ f ].width = texDatas.width;
                            images[ f ].height = texDatas.height;

                        }

                    }

                }
                else {

                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;

                }

                if ( texDatas.mipmapCount === 1 ) {

                    texture.minFilter = THREE.LinearFilter;

                }

                texture.format = texDatas.format;
                texture.needsUpdate = true;

                if ( onLoad ) onLoad( texture );

            }, onProgress, onError );

        }

        return texture;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.MaterialIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Material';

    this.side = THREE.FrontSide;

    this.opacity = 1;
    this.transparent = false;

    this.blending = THREE.NormalBlending;

    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;

    this.depthFunc = THREE.LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;

    this.colorWrite = true;

    this.precision = null; // override the renderer's default precision for this material

    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;

    this.alphaTest = 0;

    this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    this.visible = true;

    this._needsUpdate = true;

};

THREE.Material.prototype = {

    constructor: THREE.Material,

    get needsUpdate() {

        return this._needsUpdate;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.update();

        this._needsUpdate = value;

    },

    setValues: function( values ) {

        if ( values === undefined ) return;

        for ( var key in values ) {

            var newValue = values[ key ];

            if ( newValue === undefined ) {

                console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
                continue;

            }

            var currentValue = this[ key ];

            if ( currentValue === undefined ) {

                console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
                continue;

            }

            if ( currentValue instanceof THREE.Color ) {

                currentValue.set( newValue );

            }
            else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

                currentValue.copy( newValue );

            }
            else if ( key === 'overdraw' ) {

                // ensure overdraw is backwards-compatible with legacy boolean type
                this[ key ] = Number( newValue );

            }
            else {

                this[ key ] = newValue;

            }

        }

    },

    toJSON: function( meta ) {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };

        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
        if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
        if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
        if ( this.shininess !== undefined ) data.shininess = this.shininess;

        if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
        if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
        if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
        if ( this.bumpMap instanceof THREE.Texture ) {

            data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
            data.bumpScale = this.bumpScale;

        }
        if ( this.normalMap instanceof THREE.Texture ) {

            data.normalMap = this.normalMap.toJSON( meta ).uuid;
            data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

        }
        if ( this.displacementMap instanceof THREE.Texture ) {

            data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;

        }
        if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
        if ( this.envMap instanceof THREE.Texture ) {

            data.envMap = this.envMap.toJSON( meta ).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap

        }

        if ( this.size !== undefined ) data.size = this.size;
        if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

        if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
        if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
        if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
        if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

        if ( this.opacity < 1 ) data.opacity = this.opacity;
        if ( this.transparent === true ) data.transparent = this.transparent;
        if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
        if ( this.wireframe === true ) data.wireframe = this.wireframe;
        if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.name = source.name;

        this.side = source.side;

        this.opacity = source.opacity;
        this.transparent = source.transparent;

        this.blending = source.blending;

        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;

        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;

        this.precision = source.precision;

        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;

        this.alphaTest = source.alphaTest;

        this.overdraw = source.overdraw;

        this.visible = source.visible;

        return this;

    },

    update: function() {

        this.dispatchEvent( {
            type: 'update'
        } );

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    },

    // Deprecated

    get wrapAround() {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    set wrapAround( boolean ) {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    get wrapRGB() {

        console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
        return new THREE.Color();

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineBasicMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineDashedMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;

    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;

    this.vertexColors = false;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;

    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshBasicMaterial';

    this.color = new THREE.Color( 0xffffff ); // emissive

    this.map = null;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshLambertMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );

    this.map = null;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );

    this.map = source.map;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshPhongMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );
    this.specular = new THREE.Color( 0x111111 );
    this.shininess = 30;

    this.metal = false;

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissiveMap = null;

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new THREE.Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );
    this.specular.copy( source.specular );
    this.shininess = source.shininess;

    this.metal = source.metal;

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissiveMap = source.emissiveMap;

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshDepthMaterial';

    this.morphTargets = false;
    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function( parameters ) {

    THREE.Material.call( this, parameters );

    this.type = 'MeshNormalMaterial';

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function( materials ) {

    this.uuid = THREE.Math.generateUUID();

    this.type = 'MultiMaterial';

    this.materials = materials instanceof Array ? materials : [];

    this.visible = true;

};

THREE.MultiMaterial.prototype = {

    constructor: THREE.MultiMaterial,

    toJSON: function() {

        var output = {
            metadata: {
                version: 4.2,
                type: 'material',
                generator: 'MaterialExporter'
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };

        for ( var i = 0, l = this.materials.length; i < l; i++ ) {

            output.materials.push( this.materials[ i ].toJSON() );

        }

        output.visible = this.visible;

        return output;

    },

    clone: function() {

        var material = new this.constructor();

        for ( var i = 0; i < this.materials.length; i++ ) {

            material.materials.push( this.materials[ i ].clone() );

        }

        material.visible = this.visible;

        return material;

    }

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'PointsMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.map = null;

    this.size = 1;
    this.sizeAttenuation = true;

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function( parameters ) {

    console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function( parameters ) {

    console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function( parameters ) {

    console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'ShaderMaterial';

    this.defines = {};
    this.uniforms = {};

    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    this.shading = THREE.SmoothShading;

    this.linewidth = 1;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false; // set to use scene fog

    this.lights = false; // set to use scene lights

    this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

    this.skinning = false; // set to use skinning attribute streams

    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals

    this.derivatives = false; // set to use derivatives

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [ 1, 1, 1 ],
        'uv': [ 0, 0 ],
        'uv2': [ 0, 0 ]
    };

    this.index0AttributeName = undefined;

    if ( parameters !== undefined ) {

        if ( parameters.attributes !== undefined ) {

            console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

        }

        this.setValues( parameters );

    }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;

    this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

    this.attributes = source.attributes;
    this.defines = source.defines;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    this.fog = source.fog;

    this.lights = source.lights;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;

    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    this.derivatives = source.derivatives;

    return this;

};

THREE.ShaderMaterial.prototype.toJSON = function( meta ) {

    var data = THREE.Material.prototype.toJSON.call( this, meta );

    data.uniforms = this.uniforms;
    data.attributes = this.attributes;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;

    return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function( parameters ) {

    THREE.ShaderMaterial.call( this, parameters );

    this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'SpriteMaterial';

    this.color = new THREE.Color( 0xffffff );
    this.map = null;

    this.rotation = 0;

    this.fog = false;

    // set parameters

    this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.map = source.map;

    this.rotation = source.rotation;

    this.fog = source.fog;

    return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    Object.defineProperty( this, 'id', {
        value: THREE.TextureIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.sourceFile = '';

    this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];

    this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    this.format = format !== undefined ? format : THREE.RGBAFormat;
    this.type = type !== undefined ? type : THREE.UnsignedByteType;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    this.version = 0;
    this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

    constructor: THREE.Texture,

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.image = source.image;
        this.mipmaps = source.mipmaps.slice( 0 );

        this.mapping = source.mapping;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.format = source.format;
        this.type = source.type;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;

        return this;

    },

    toJSON: function( meta ) {

        if ( meta.textures[ this.uuid ] !== undefined ) {

            return meta.textures[ this.uuid ];

        }

        function getDataURL( image ) {

            var canvas;

            if ( image.toDataURL !== undefined ) {

                canvas = image;

            }
            else {

                canvas = document.createElement( 'canvas' );
                canvas.width = image.width;
                canvas.height = image.height;

                canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {

                return canvas.toDataURL( 'image/jpeg', 0.6 );

            }
            else {

                return canvas.toDataURL( 'image/png' );

            }

        }

        var output = {
            metadata: {
                version: 4.4,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },

            uuid: this.uuid,
            name: this.name,

            mapping: this.mapping,

            repeat: [ this.repeat.x, this.repeat.y ],
            offset: [ this.offset.x, this.offset.y ],
            wrap: [ this.wrapS, this.wrapT ],

            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };

        if ( this.image !== undefined ) {

            // TODO: Move to THREE.Image

            var image = this.image;

            if ( image.uuid === undefined ) {

                image.uuid = THREE.Math.generateUUID(); // UGH

            }

            if ( meta.images[ image.uuid ] === undefined ) {

                meta.images[ image.uuid ] = {
                    uuid: image.uuid,
                    url: getDataURL( image )
                };

            }

            output.image = image.uuid;

        }

        meta.textures[ this.uuid ] = output;

        return output;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    },

    transformUv: function( uv ) {

        if ( this.mapping !== THREE.UVMapping ) return;

        uv.multiply( this.repeat );
        uv.add( this.offset );

        if ( uv.x < 0 || uv.x > 1 ) {

            switch ( this.wrapS ) {

                case THREE.RepeatWrapping:

                    uv.x = uv.x - Math.floor( uv.x );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

                        uv.x = Math.ceil( uv.x ) - uv.x;

                    }
                    else {

                        uv.x = uv.x - Math.floor( uv.x );

                    }
                    break;

            }

        }

        if ( uv.y < 0 || uv.y > 1 ) {

            switch ( this.wrapT ) {

                case THREE.RepeatWrapping:

                    uv.y = uv.y - Math.floor( uv.y );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

                        uv.y = Math.ceil( uv.y ) - uv.y;

                    }
                    else {

                        uv.y = uv.y - Math.floor( uv.y );

                    }
                    break;

            }

        }

        if ( this.flipY ) {

            uv.y = 1 - uv.y;

        }

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

    THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.images = images;
    this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function( source ) {

    THREE.Texture.prototype.copy.call( this, source );

    this.images = source.images;

    return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;

    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    this.flipY = false;

    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = {
        data: data,
        width: width,
        height: height
    };

    this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

    this.flipY = false;
    this.generateMipmaps = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.generateMipmaps = false;

    var scope = this;

    var update = function() {

        requestAnimationFrame( update );

        if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

            scope.needsUpdate = true;

        }

    };

    update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function() {

    THREE.Object3D.call( this );

    this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Points';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.PointsMaterial( {
        color: Math.random() * 0xffffff
    } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();

    return function raycast( raycaster, intersects ) {

        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.Points.threshold;

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();

        function testPoint( point, index ) {

            var rayPointDistanceSq = ray.distanceSqToPoint( point );

            if ( rayPointDistanceSq < localThresholdSq ) {

                var intersectPoint = ray.closestPointToPoint( point );
                intersectPoint.applyMatrix4( object.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectPoint );

                if ( distance < raycaster.near || distance > raycaster.far ) return;

                intersects.push( {

                    distance: distance,
                    distanceToRay: Math.sqrt( rayPointDistanceSq ),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object

                } );

            }

        }

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if ( index !== null ) {

                var indices = index.array;

                for ( var i = 0, il = indices.length; i < il; i++ ) {

                    var a = indices[ i ];

                    position.fromArray( positions, a * 3 );

                    testPoint( position, a );

                }

            }
            else {

                for ( var i = 0, l = positions.length / 3; i < l; i++ ) {

                    position.fromArray( positions, i * 3 );

                    testPoint( position, i );

                }

            }

        }
        else {

            var vertices = geometry.vertices;

            for ( var i = 0, l = vertices.length; i < l; i++ ) {

                testPoint( vertices[ i ], i );

            }

        }

    };

}() );

THREE.Points.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Points.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// Backwards compatibility

THREE.PointCloud = function( geometry, material ) {

    console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function( geometry, material ) {

    console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function( geometry, material, mode ) {

    if ( mode === 1 ) {

        console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
        return new THREE.LineSegments( geometry, material );

    }

    THREE.Object3D.call( this );

    this.type = 'Line';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.LineBasicMaterial( {
        color: Math.random() * 0xffffff
    } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    return function raycast( raycaster, intersects ) {

        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;

        var geometry = this.geometry;

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        // Checking boundingSphere distance to ray

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this instanceof THREE.LineSegments ? 2 : 1;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

                    var a = indices[ i ];
                    var b = indices[ i + 1 ];

                    vStart.fromArray( positions, a * 3 );
                    vEnd.fromArray( positions, b * 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }
            else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

                    vStart.fromArray( positions, 3 * i );
                    vEnd.fromArray( positions, 3 * i + 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }

        }
        else if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;
            var nbVertices = vertices.length;

            for ( var i = 0; i < nbVertices - 1; i += step ) {

                var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

                if ( distSq > precisionSq ) continue;

                interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                var distance = raycaster.ray.origin.distanceTo( interRay );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                intersects.push( {

                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Line.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Line.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function( geometry, material ) {

    THREE.Line.call( this, geometry, material );

    this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Mesh';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( {
        color: Math.random() * 0xffffff
    } );

    this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function() {

    if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

        this.morphTargetBase = -1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};

        for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++ ) {

            this.morphTargetInfluences.push( 0 );
            this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

        }

    }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function( name ) {

    if ( this.morphTargetDictionary[ name ] !== undefined ) {

        return this.morphTargetDictionary[ name ];

    }

    console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

    return 0;

};


THREE.Mesh.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var tempA = new THREE.Vector3();
    var tempB = new THREE.Vector3();
    var tempC = new THREE.Vector3();

    var uvA = new THREE.Vector2();
    var uvB = new THREE.Vector2();
    var uvC = new THREE.Vector2();

    var barycoord = new THREE.Vector3();

    var intersectionPoint = new THREE.Vector3();
    var intersectionPointWorld = new THREE.Vector3();

    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

        uv1.multiplyScalar( barycoord.x );
        uv2.multiplyScalar( barycoord.y );
        uv3.multiplyScalar( barycoord.z );

        uv1.add( uv2 ).add( uv3 );

        return uv1.clone();

    }

    return function raycast( raycaster, intersects ) {

        var geometry = this.geometry;
        var material = this.material;

        if ( material === undefined ) return;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        // Check boundingBox before continuing

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var a, b, c;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                    a = indices[ i ];
                    b = indices[ i + 1 ];
                    c = indices[ i + 2 ];

                    vA.fromArray( positions, a * 3 );
                    vB.fromArray( positions, b * 3 );
                    vC.fromArray( positions, c * 3 );

                    if ( material.side === THREE.BackSide ) {

                        if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

                    }
                    else {

                        if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                    }

                    intersectionPointWorld.copy( intersectionPoint );
                    intersectionPointWorld.applyMatrix4( this.matrixWorld );

                    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    var uv;

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;
                        uvA.fromArray( uvs, a * 2 );
                        uvB.fromArray( uvs, b * 2 );
                        uvC.fromArray( uvs, c * 2 );
                        uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

                    }

                    intersects.push( {

                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        uv: uv,
                        face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
                        faceIndex: Math.floor( i / 3 ), // triangle number in indices buffer semantics
                        object: this

                    } );

                }

            }
            else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length; i < l; i += 9 ) {

                    vA.fromArray( positions, i );
                    vB.fromArray( positions, i + 3 );
                    vC.fromArray( positions, i + 6 );

                    if ( material.side === THREE.BackSide ) {

                        if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

                    }
                    else {

                        if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                    }

                    intersectionPointWorld.copy( intersectionPoint );
                    intersectionPointWorld.applyMatrix4( this.matrixWorld );

                    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    var uv;

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;
                        uvA.fromArray( uvs, i );
                        uvB.fromArray( uvs, i + 2 );
                        uvC.fromArray( uvs, i + 4 );
                        uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

                    }

                    a = i / 3;
                    b = a + 1;
                    c = a + 2;

                    intersects.push( {

                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        uv: uv,
                        face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
                        index: a, // triangle number in positions buffer semantics
                        object: this

                    } );

                }

            }

        }
        else if ( geometry instanceof THREE.Geometry ) {

            var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
            var materials = isFaceMaterial === true ? material.materials : null;

            var vertices = geometry.vertices;
            var faces = geometry.faces;

            for ( var f = 0, fl = faces.length; f < fl; f++ ) {

                var face = faces[ f ];
                var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

                if ( faceMaterial === undefined ) continue;

                a = vertices[ face.a ];
                b = vertices[ face.b ];
                c = vertices[ face.c ];

                if ( faceMaterial.morphTargets === true ) {

                    var morphTargets = geometry.morphTargets;
                    var morphInfluences = this.morphTargetInfluences;

                    vA.set( 0, 0, 0 );
                    vB.set( 0, 0, 0 );
                    vC.set( 0, 0, 0 );

                    for ( var t = 0, tl = morphTargets.length; t < tl; t++ ) {

                        var influence = morphInfluences[ t ];

                        if ( influence === 0 ) continue;

                        var targets = morphTargets[ t ].vertices;

                        vA.addScaledVector( tempA.subVectors( targets[ face.a ], a ), influence );
                        vB.addScaledVector( tempB.subVectors( targets[ face.b ], b ), influence );
                        vC.addScaledVector( tempC.subVectors( targets[ face.c ], c ), influence );

                    }

                    vA.add( a );
                    vB.add( b );
                    vC.add( c );

                    a = vA;
                    b = vB;
                    c = vC;

                }

                if ( faceMaterial.side === THREE.BackSide ) {

                    if ( ray.intersectTriangle( c, b, a, true, intersectionPoint ) === null ) continue;

                }
                else {

                    if ( ray.intersectTriangle( a, b, c, faceMaterial.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                }

                intersectionPointWorld.copy( intersectionPoint );
                intersectionPointWorld.applyMatrix4( this.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                var uv;

                if ( geometry.faceVertexUvs[ 0 ].length > 0 ) {

                    var uvs = geometry.faceVertexUvs[ 0 ][ f ];
                    uvA.copy( uvs[ 0 ] );
                    uvB.copy( uvs[ 1 ] );
                    uvC.copy( uvs[ 2 ] );
                    uv = uvIntersection( intersectionPoint, a, b, c, uvA, uvB, uvC );

                }

                intersects.push( {

                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    uv: uv,
                    face: face,
                    faceIndex: f,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Mesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Mesh.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function( skin ) {

    THREE.Object3D.call( this );

    this.type = 'Bone';

    this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.skin = source.skin;

    return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function( bones, boneInverses, useVertexTexture ) {

    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    this.identityMatrix = new THREE.Matrix4();

    // copy the bone array

    bones = bones || [];

    this.bones = bones.slice( 0 );

    // create a bone texture or an array of floats

    if ( this.useVertexTexture ) {

        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


        var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
        size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
        size = Math.max( size, 4 );

        this.boneTextureWidth = size;
        this.boneTextureHeight = size;

        this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
        this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

    }
    else {

        this.boneMatrices = new Float32Array( 16 * this.bones.length );

    }

    // use the supplied bone inverses or calculate the inverses

    if ( boneInverses === undefined ) {

        this.calculateInverses();

    }
    else {

        if ( this.bones.length === boneInverses.length ) {

            this.boneInverses = boneInverses.slice( 0 );

        }
        else {

            console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

            this.boneInverses = [];

            for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

                this.boneInverses.push( new THREE.Matrix4() );

            }

        }

    }

};

THREE.Skeleton.prototype.calculateInverses = function() {

    this.boneInverses = [];

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        var inverse = new THREE.Matrix4();

        if ( this.bones[ b ] ) {

            inverse.getInverse( this.bones[ b ].matrixWorld );

        }

        this.boneInverses.push( inverse );

    }

};

THREE.Skeleton.prototype.pose = function() {

    var bone;

    // recover the bind-time world matrices

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            bone.matrixWorld.getInverse( this.boneInverses[ b ] );

        }

    }

    // compute the local matrices, positions, rotations and scales

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            if ( bone.parent ) {

                bone.matrix.getInverse( bone.parent.matrixWorld );
                bone.matrix.multiply( bone.matrixWorld );

            }
            else {

                bone.matrix.copy( bone.matrixWorld );

            }

            bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

        }

    }

};

THREE.Skeleton.prototype.update = ( function() {

    var offsetMatrix = new THREE.Matrix4();

    return function update() {

        // flatten bone matrices to array

        for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

            // compute the offset between the current and the original transform

            var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

            offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
            offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

        }

        if ( this.useVertexTexture ) {

            this.boneTexture.needsUpdate = true;

        }

    };

} )();

THREE.Skeleton.prototype.clone = function() {

    return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function( geometry, material, useVertexTexture ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'SkinnedMesh';

    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();

    // init bones

    // TODO: remove bone creation as there is no reason (other than
    // convenience) for THREE.SkinnedMesh to do this.

    var bones = [];

    if ( this.geometry && this.geometry.bones !== undefined ) {

        var bone, gbone;

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

            gbone = this.geometry.bones[ b ];

            bone = new THREE.Bone( this );
            bones.push( bone );

            bone.name = gbone.name;
            bone.position.fromArray( gbone.pos );
            bone.quaternion.fromArray( gbone.rotq );
            if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

        }

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

            gbone = this.geometry.bones[ b ];

            if ( gbone.parent !== -1 ) {

                bones[ gbone.parent ].add( bones[ b ] );

            }
            else {

                this.add( bones[ b ] );

            }

        }

    }

    this.normalizeSkinWeights();

    this.updateMatrixWorld( true );
    this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

    this.skeleton = skeleton;

    if ( bindMatrix === undefined ) {

        this.updateMatrixWorld( true );

        this.skeleton.calculateInverses();

        bindMatrix = this.matrixWorld;

    }

    this.bindMatrix.copy( bindMatrix );
    this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function() {

    this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {

    if ( this.geometry instanceof THREE.Geometry ) {

        for ( var i = 0; i < this.geometry.skinIndices.length; i++ ) {

            var sw = this.geometry.skinWeights[ i ];

            var scale = 1.0 / sw.lengthManhattan();

            if ( scale !== Infinity ) {

                sw.multiplyScalar( scale );

            }
            else {

                sw.set( 1 ); // this will be normalized by the shader anyway

            }

        }

    }
    else {

        // skinning weights assumed to be normalized for THREE.BufferGeometry

    }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

    THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

    if ( this.bindMode === "attached" ) {

        this.bindMatrixInverse.getInverse( this.matrixWorld );

    }
    else if ( this.bindMode === "detached" ) {

        this.bindMatrixInverse.getInverse( this.bindMatrix );

    }
    else {

        console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    }

};

THREE.SkinnedMesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'MorphAnimMesh';

    // API

    this.duration = 1000; // milliseconds
    this.mirroredLoop = false;
    this.time = 0;

    // internals

    this.lastKeyframe = 0;
    this.currentKeyframe = 0;

    this.direction = 1;
    this.directionBackwards = false;

    this.setFrameRange( 0, geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function( start, end ) {

    this.startKeyframe = start;
    this.endKeyframe = end;

    this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function() {

    this.direction = 1;
    this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {

    this.direction = -1;
    this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function() {

    var geometry = this.geometry;

    if ( !geometry.animations ) geometry.animations = {};

    var firstAnimation, animations = geometry.animations;

    var pattern = /([a-z]+)_?(\d+)/;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i++ ) {

        var morph = geometry.morphTargets[ i ];
        var parts = morph.name.match( pattern );

        if ( parts && parts.length > 1 ) {

            var label = parts[ 1 ];

            if ( !animations[ label ] ) animations[ label ] = {
                start: Infinity,
                end: -Infinity
            };

            var animation = animations[ label ];

            if ( i < animation.start ) animation.start = i;
            if ( i > animation.end ) animation.end = i;

            if ( !firstAnimation ) firstAnimation = label;

        }

    }

    geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function( label, start, end ) {

    if ( !this.geometry.animations ) this.geometry.animations = {};

    this.geometry.animations[ label ] = {
        start: start,
        end: end
    };

};

THREE.MorphAnimMesh.prototype.playAnimation = function( label, fps ) {

    var animation = this.geometry.animations[ label ];

    if ( animation ) {

        this.setFrameRange( animation.start, animation.end );
        this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
        this.time = 0;

    }
    else {

        console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

    }

};

THREE.MorphAnimMesh.prototype.updateAnimation = function( delta ) {

    var frameTime = this.duration / this.length;

    this.time += this.direction * delta;

    if ( this.mirroredLoop ) {

        if ( this.time > this.duration || this.time < 0 ) {

            this.direction *= -1;

            if ( this.time > this.duration ) {

                this.time = this.duration;
                this.directionBackwards = true;

            }

            if ( this.time < 0 ) {

                this.time = 0;
                this.directionBackwards = false;

            }

        }

    }
    else {

        this.time = this.time % this.duration;

        if ( this.time < 0 ) this.time += this.duration;

    }

    var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

    var influences = this.morphTargetInfluences;

    if ( keyframe !== this.currentKeyframe ) {

        influences[ this.lastKeyframe ] = 0;
        influences[ this.currentKeyframe ] = 1;
        influences[ keyframe ] = 0;

        this.lastKeyframe = this.currentKeyframe;
        this.currentKeyframe = keyframe;

    }

    var mix = ( this.time % frameTime ) / frameTime;

    if ( this.directionBackwards ) {

        mix = 1 - mix;

    }

    influences[ this.currentKeyframe ] = mix;
    influences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function( a, b, t ) {

    var influences = this.morphTargetInfluences;

    for ( var i = 0, l = influences.length; i < l; i++ ) {

        influences[ i ] = 0;

    }

    if ( a > -1 ) influences[ a ] = 1 - t;
    if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.copy = function( source ) {

    THREE.Mesh.prototype.copy.call( this, source );

    this.duration = source.duration;
    this.mirroredLoop = source.mirroredLoop;
    this.time = source.time;

    this.lastKeyframe = source.lastKeyframe;
    this.currentKeyframe = source.currentKeyframe;

    this.direction = source.direction;
    this.directionBackwards = source.directionBackwards;

    return this;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function() {

    THREE.Object3D.call( this );

    this.type = 'LOD';

    Object.defineProperties( this, {
        levels: {
            enumerable: true,
            value: []
        },
        objects: {
            get: function() {

                console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
                return this.levels;

            }
        }
    } );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function( object, distance ) {

    if ( distance === undefined ) distance = 0;

    distance = Math.abs( distance );

    var levels = this.levels;

    for ( var l = 0; l < levels.length; l++ ) {

        if ( distance < levels[ l ].distance ) {

            break;

        }

    }

    levels.splice( l, 0, {
        distance: distance,
        object: object
    } );

    this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function( distance ) {

    var levels = this.levels;

    for ( var i = 1, l = levels.length; i < l; i++ ) {

        if ( distance < levels[ i ].distance ) {

            break;

        }

    }

    return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function() {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( matrixPosition );

        this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    };

}() );

THREE.LOD.prototype.update = function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function update( camera ) {

        var levels = this.levels;

        if ( levels.length > 1 ) {

            v1.setFromMatrixPosition( camera.matrixWorld );
            v2.setFromMatrixPosition( this.matrixWorld );

            var distance = v1.distanceTo( v2 );

            levels[ 0 ].object.visible = true;

            for ( var i = 1, l = levels.length; i < l; i++ ) {

                if ( distance >= levels[ i ].distance ) {

                    levels[ i - 1 ].object.visible = false;
                    levels[ i ].object.visible = true;

                }
                else {

                    break;

                }

            }

            for ( ; i < l; i++ ) {

                levels[ i ].object.visible = false;

            }

        }

    };

}();

THREE.LOD.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source, false );

    var levels = source.levels;

    for ( var i = 0, l = levels.length; i < l; i++ ) {

        var level = levels[ i ];

        this.addLevel( level.object.clone(), level.distance );

    }

    return this;

};

THREE.LOD.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.levels = [];

    var levels = this.levels;

    for ( var i = 0, l = levels.length; i < l; i++ ) {

        var level = levels[ i ];

        data.object.levels.push( {
            object: level.object.uuid,
            distance: level.distance
        } );

    }

    return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function() {

    var indices = new Uint16Array( [ 0, 1, 2, 0, 2, 3 ] );
    var vertices = new Float32Array( [ -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0 ] );
    var uvs = new Float32Array( [ 0, 0, 1, 0, 1, 1, 0, 1 ] );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    return function Sprite( material ) {

        THREE.Object3D.call( this );

        this.type = 'Sprite';

        this.geometry = geometry;
        this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

    };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function() {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
        var guessSizeSq = this.scale.x * this.scale.y;

        if ( distanceSq > guessSizeSq ) {

            return;

        }

        intersects.push( {

            distance: Math.sqrt( distanceSq ),
            point: this.position,
            face: null,
            object: this

        } );

    };

}() );

THREE.Sprite.prototype.clone = function() {

    return new this.constructor( this.material ).copy( this );

};

THREE.Sprite.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.material = this.material.uuid;

    return data;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function( texture, size, distance, blending, color ) {

    THREE.Object3D.call( this );

    this.lensFlares = [];

    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;

    if ( texture !== undefined ) {

        this.add( texture, size, distance, blending, color );

    }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function( texture, size, distance, blending, color, opacity ) {

    if ( size === undefined ) size = -1;
    if ( distance === undefined ) distance = 0;
    if ( opacity === undefined ) opacity = 1;
    if ( color === undefined ) color = new THREE.Color( 0xffffff );
    if ( blending === undefined ) blending = THREE.NormalBlending;

    distance = Math.min( distance, Math.max( 0, distance ) );

    this.lensFlares.push( {
        texture: texture, // THREE.Texture
        size: size, // size in pixels (-1 = use texture.width)
        distance: distance, // distance (0-1) from light source (0=at light source)
        x: 0,
        y: 0,
        z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back
        scale: 1, // scale
        rotation: 0, // rotation
        opacity: opacity, // opacity
        color: color, // color
        blending: blending // blending
    } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function() {

    var f, fl = this.lensFlares.length;
    var flare;
    var vecX = -this.positionScreen.x * 2;
    var vecY = -this.positionScreen.y * 2;

    for ( f = 0; f < fl; f++ ) {

        flare = this.lensFlares[ f ];

        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;

        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    }

};

THREE.LensFlare.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.positionScreen.copy( source.positionScreen );
    this.customUpdateCallback = source.customUpdateCallback;

    for ( var i = 0, l = source.lensFlares.length; i < l; i++ ) {

        this.lensFlares.push( source.lensFlares[ i ] );

    }

    return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function() {

    THREE.Object3D.call( this );

    this.type = 'Scene';

    this.fog = null;
    this.overrideMaterial = null;

    this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    if ( source.fog !== null ) this.fog = source.fog.clone();
    if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;

    return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function( color, near, far ) {

    this.name = '';

    this.color = new THREE.Color( color );

    this.near = ( near !== undefined ) ? near : 1;
    this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function() {

    return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function( color, density ) {

    this.name = '';

    this.color = new THREE.Color( color );
    this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function() {

    return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment' ] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment' ] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment' ] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment' ] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment' ] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex' ] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex' ] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment' ] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment' ] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex' ] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex' ] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common' ] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n	// Original approximation by Christophe Schlick '94\n	//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n	// geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n	// factor of 1/PI in distribution term omitted\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	//float dotNL = saturate( dot( normal, lightDir ) );\n	//float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex' ] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment' ] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment' ] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment' ] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment' ] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment' ] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment' ] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment' ] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex' ] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex' ] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment' ] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n			// specular\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += lightColor;\n\n		// specular (sky term only)\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex' ] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment' ] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment' ] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment' ] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment' ] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment' ] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment' ] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment' ] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex' ] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment' ] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n		#endif\n\n	}\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex' ] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex' ] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex' ] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex' ] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex' ] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment' ] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment' ] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex' ] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

    merge: function( uniforms ) {

        var merged = {};

        for ( var u = 0; u < uniforms.length; u++ ) {

            var tmp = this.clone( uniforms[ u ] );

            for ( var p in tmp ) {

                merged[ p ] = tmp[ p ];

            }

        }

        return merged;

    },

    clone: function( uniforms_src ) {

        var uniforms_dst = {};

        for ( var u in uniforms_src ) {

            uniforms_dst[ u ] = {};

            for ( var p in uniforms_src[ u ] ) {

                var parameter_src = uniforms_src[ u ][ p ];

                if ( parameter_src instanceof THREE.Color ||
                    parameter_src instanceof THREE.Vector2 ||
                    parameter_src instanceof THREE.Vector3 ||
                    parameter_src instanceof THREE.Vector4 ||
                    parameter_src instanceof THREE.Matrix3 ||
                    parameter_src instanceof THREE.Matrix4 ||
                    parameter_src instanceof THREE.Texture ) {

                    uniforms_dst[ u ][ p ] = parameter_src.clone();

                }
                else if ( Array.isArray( parameter_src ) ) {

                    uniforms_dst[ u ][ p ] = parameter_src.slice();

                }
                else {

                    uniforms_dst[ u ][ p ] = parameter_src;

                }

            }

        }

        return uniforms_dst;

    }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

    common: {

        "diffuse": {
            type: "c",
            value: new THREE.Color( 0xeeeeee )
        },
        "opacity": {
            type: "f",
            value: 1.0
        },

        "map": {
            type: "t",
            value: null
        },
        "offsetRepeat": {
            type: "v4",
            value: new THREE.Vector4( 0, 0, 1, 1 )
        },

        "specularMap": {
            type: "t",
            value: null
        },
        "alphaMap": {
            type: "t",
            value: null
        },

        "envMap": {
            type: "t",
            value: null
        },
        "flipEnvMap": {
            type: "f",
            value: -1
        },
        "reflectivity": {
            type: "f",
            value: 1.0
        },
        "refractionRatio": {
            type: "f",
            value: 0.98
        }

    },

    aomap: {

        "aoMap": {
            type: "t",
            value: null
        },
        "aoMapIntensity": {
            type: "f",
            value: 1
        },

    },

    lightmap: {

        "lightMap": {
            type: "t",
            value: null
        },
        "lightMapIntensity": {
            type: "f",
            value: 1
        },

    },

    emissivemap: {

        "emissiveMap": {
            type: "t",
            value: null
        },

    },

    bumpmap: {

        "bumpMap": {
            type: "t",
            value: null
        },
        "bumpScale": {
            type: "f",
            value: 1
        }

    },

    normalmap: {

        "normalMap": {
            type: "t",
            value: null
        },
        "normalScale": {
            type: "v2",
            value: new THREE.Vector2( 1, 1 )
        }

    },

    displacementmap: {

        "displacementMap": {
            type: "t",
            value: null
        },
        "displacementScale": {
            type: "f",
            value: 1
        },
        "displacementBias": {
            type: "f",
            value: 0
        }

    },

    fog: {

        "fogDensity": {
            type: "f",
            value: 0.00025
        },
        "fogNear": {
            type: "f",
            value: 1
        },
        "fogFar": {
            type: "f",
            value: 2000
        },
        "fogColor": {
            type: "c",
            value: new THREE.Color( 0xffffff )
        }

    },

    lights: {

        "ambientLightColor": {
            type: "fv",
            value: []
        },

        "directionalLightDirection": {
            type: "fv",
            value: []
        },
        "directionalLightColor": {
            type: "fv",
            value: []
        },

        "hemisphereLightDirection": {
            type: "fv",
            value: []
        },
        "hemisphereLightSkyColor": {
            type: "fv",
            value: []
        },
        "hemisphereLightGroundColor": {
            type: "fv",
            value: []
        },

        "pointLightColor": {
            type: "fv",
            value: []
        },
        "pointLightPosition": {
            type: "fv",
            value: []
        },
        "pointLightDistance": {
            type: "fv1",
            value: []
        },
        "pointLightDecay": {
            type: "fv1",
            value: []
        },

        "spotLightColor": {
            type: "fv",
            value: []
        },
        "spotLightPosition": {
            type: "fv",
            value: []
        },
        "spotLightDirection": {
            type: "fv",
            value: []
        },
        "spotLightDistance": {
            type: "fv1",
            value: []
        },
        "spotLightAngleCos": {
            type: "fv1",
            value: []
        },
        "spotLightExponent": {
            type: "fv1",
            value: []
        },
        "spotLightDecay": {
            type: "fv1",
            value: []
        }

    },

    points: {

        "psColor": {
            type: "c",
            value: new THREE.Color( 0xeeeeee )
        },
        "opacity": {
            type: "f",
            value: 1.0
        },
        "size": {
            type: "f",
            value: 1.0
        },
        "scale": {
            type: "f",
            value: 1.0
        },
        "map": {
            type: "t",
            value: null
        },
        "offsetRepeat": {
            type: "v4",
            value: new THREE.Vector4( 0, 0, 1, 1 )
        },

        "fogDensity": {
            type: "f",
            value: 0.00025
        },
        "fogNear": {
            type: "f",
            value: 1
        },
        "fogFar": {
            type: "f",
            value: 2000
        },
        "fogColor": {
            type: "c",
            value: new THREE.Color( 0xffffff )
        }

    },

    shadowmap: {

        "shadowMap": {
            type: "tv",
            value: []
        },
        "shadowMapSize": {
            type: "v2v",
            value: []
        },

        "shadowBias": {
            type: "fv1",
            value: []
        },
        "shadowDarkness": {
            type: "fv1",
            value: []
        },

        "shadowMatrix": {
            type: "m4v",
            value: []
        }

    }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

    'basic': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],

            "	#ifdef USE_ENVMAP",

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "	#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],

            "	outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ], // TODO: Shadows on an otherwise unlit surface doesn't make sense.

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'lambert': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive": {
                    type: "c",
                    value: new THREE.Color( 0x000000 )
                }
            }

        ] ),

        vertexShader: [

            "#define LAMBERT",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform float opacity;",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],

            "	#ifdef DOUBLE_SIDED",

            "		if ( gl_FrontFacing )",
            "			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
            "		else",
            "			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

            "	#else",

            "		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

            "	#endif",

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'phong': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "lightmap" ],
            THREE.UniformsLib[ "emissivemap" ],
            THREE.UniformsLib[ "bumpmap" ],
            THREE.UniformsLib[ "normalmap" ],
            THREE.UniformsLib[ "displacementmap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive": {
                    type: "c",
                    value: new THREE.Color( 0x000000 )
                },
                "specular": {
                    type: "c",
                    value: new THREE.Color( 0x111111 )
                },
                "shininess": {
                    type: "f",
                    value: 30
                }
            }

        ] ),

        vertexShader: [

            "#define PHONG",

            "varying vec3 vViewPosition;",

            "#ifndef FLAT_SHADED",

            "	varying vec3 vNormal;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

            "	vNormal = normalize( transformedNormal );",

            "#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "displacementmap_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "	vViewPosition = - mvPosition.xyz;",

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_phong_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "#define PHONG",

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "lightmap_pars_fragment" ],
            THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
            THREE.ShaderChunk[ "normalmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = ambientLightColor;",
            "	vec3 totalEmissiveLight = emissive;",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "lightmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],
            THREE.ShaderChunk[ "emissivemap_fragment" ],

            THREE.ShaderChunk[ "lights_phong_fragment" ],

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'points': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "points" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            "uniform float size;",
            "uniform float scale;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

            "	#ifdef USE_SIZEATTENUATION",
            "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
            "	#else",
            "		gl_PointSize = size;",
            "	#endif",

            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],
            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 psColor;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "map_particle_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( psColor, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_particle_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "shadowmap_fragment" ],
            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'dashed': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],

            {
                "scale": {
                    type: "f",
                    value: 1
                },
                "dashSize": {
                    type: "f",
                    value: 1
                },
                "totalSize": {
                    type: "f",
                    value: 2
                }
            }

        ] ),

        vertexShader: [

            "uniform float scale;",
            "attribute float lineDistance;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vLineDistance = scale * lineDistance;",

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            "uniform float dashSize;",
            "uniform float totalSize;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

            "		discard;",

            "	}",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'depth': {

        uniforms: {

            "mNear": {
                type: "f",
                value: 1.0
            },
            "mFar": {
                type: "f",
                value: 2000.0
            },
            "opacity": {
                type: "f",
                value: 1.0
            }

        },

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float mNear;",
            "uniform float mFar;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

            "	#else",

            "		float depth = gl_FragCoord.z / gl_FragCoord.w;",

            "	#endif",

            "	float color = 1.0 - smoothstep( mNear, mFar, depth );",
            "	gl_FragColor = vec4( vec3( color ), opacity );",

            "}"

        ].join( "\n" )

    },

    'normal': {

        uniforms: {

            "opacity": {
                type: "f",
                value: 1.0
            }

        },

        vertexShader: [

            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vNormal = normalize( normalMatrix * normal );",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float opacity;",
            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

    'cube': {

        uniforms: {
            "tCube": {
                type: "t",
                value: null
            },
            "tFlip": {
                type: "f",
                value: -1
            }
        },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform samplerCube tCube;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

    'equirect': {

        uniforms: {
            "tEquirect": {
                type: "t",
                value: null
            },
            "tFlip": {
                type: "f",
                value: -1
            }
        },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform sampler2D tEquirect;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            // "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            "vec3 direction = normalize( vWorldPosition );",
            "vec2 sampleUV;",
            "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
            "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
            "gl_FragColor = texture2D( tEquirect, sampleUV );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* Depth encoding into RGBA texture
     *
     * based on SpiderGL shadow map example
     * http://spidergl.org/example.php?id=6
     *
     * originally from
     * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
     *
     * see also
     * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
     */

    'depthRGBA': {

        uniforms: {},

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "skinbase_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "vec4 pack_depth( const in float depth ) {",

            "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
            "	res -= res.xxyz * bit_mask;",
            "	return res;",

            "}",

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

            "	#else",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

            "	#endif",

            //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
            //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
            //"gl_FragData[ 0 ] = pack_depth( z );",
            //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

            "}"

        ].join( "\n" )

    }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function( parameters ) {

    console.log( 'THREE.WebGLRenderer', THREE.REVISION );

    parameters = parameters || {};

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
        _context = parameters.context !== undefined ? parameters.context : null,

        _width = _canvas.width,
        _height = _canvas.height,

        pixelRatio = 1,

        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

        _clearColor = new THREE.Color( 0x000000 ),
        _clearAlpha = 0;

    var lights = [];

    var opaqueObjects = [];
    var opaqueObjectsLastIndex = -1;
    var transparentObjects = [];
    var transparentObjectsLastIndex = -1;

    var opaqueImmediateObjects = [];
    var opaqueImmediateObjectsLastIndex = -1;
    var transparentImmediateObjects = [];
    var transparentImmediateObjectsLastIndex = -1;

    var morphInfluences = new Float32Array( 8 );


    var sprites = [];
    var lensFlares = [];

    // public properties

    this.domElement = _canvas;
    this.context = null;

    // clearing

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;

    // scene graph

    this.sortObjects = true;

    // physically based shading

    this.gammaFactor = 2.0; // for backwards compatibility
    this.gammaInput = false;
    this.gammaOutput = false;

    // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;

    // flags

    this.autoScaleCubemaps = true;

    // internal properties

    var _this = this,

        // internal state cache

        _currentProgram = null,
        _currentFramebuffer = null,
        _currentMaterialId = -1,
        _currentGeometryProgram = '',
        _currentCamera = null,

        _usedTextureUnits = 0,

        _viewportX = 0,
        _viewportY = 0,
        _viewportWidth = _canvas.width,
        _viewportHeight = _canvas.height,
        _currentWidth = 0,
        _currentHeight = 0,

        // frustum

        _frustum = new THREE.Frustum(),

        // camera matrices cache

        _projScreenMatrix = new THREE.Matrix4(),

        _vector3 = new THREE.Vector3(),

        // light arrays cache

        _direction = new THREE.Vector3(),

        _lightsNeedUpdate = true,

        _lights = {

            ambient: [ 0, 0, 0 ],
            directional: {
                length: 0,
                colors: [],
                positions: []
            },
            point: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                decays: []
            },
            spot: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                directions: [],
                anglesCos: [],
                exponents: [],
                decays: []
            },
            hemi: {
                length: 0,
                skyColors: [],
                groundColors: [],
                positions: []
            }

        },

        // info

        _infoMemory = {

            geometries: 0,
            textures: 0

        },

        _infoRender = {

            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0

        };

    this.info = {

        render: _infoRender,
        memory: _infoMemory,
        programs: null

    };


    // initialize

    var _gl;

    try {

        var attributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer
        };

        _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

        if ( _gl === null ) {

            if ( _canvas.getContext( 'webgl' ) !== null ) {

                throw 'Error creating WebGL context with your selected attributes.';

            }
            else {

                throw 'Error creating WebGL context.';

            }

        }

        _canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    }
    catch ( error ) {

        console.error( 'THREE.WebGLRenderer: ' + error );

    }

    var extensions = new THREE.WebGLExtensions( _gl );

    extensions.get( 'OES_texture_float' );
    extensions.get( 'OES_texture_float_linear' );
    extensions.get( 'OES_texture_half_float' );
    extensions.get( 'OES_texture_half_float_linear' );
    extensions.get( 'OES_standard_derivatives' );
    extensions.get( 'ANGLE_instanced_arrays' );

    if ( extensions.get( 'OES_element_index_uint' ) ) {

        THREE.BufferGeometry.MaxIndex = 4294967296;

    }

    var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

    var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
    var properties = new THREE.WebGLProperties();
    var objects = new THREE.WebGLObjects( _gl, properties, this.info );
    var programCache = new THREE.WebGLPrograms( this, capabilities );

    this.info.programs = programCache.programs;

    var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
    var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    //

    function glClearColor( r, g, b, a ) {

        if ( _premultipliedAlpha === true ) {

            r *= a;
            g *= a;
            b *= a;

        }

        _gl.clearColor( r, g, b, a );

    }

    function setDefaultGLState() {

        state.init();

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    }

    function resetGLState() {

        _currentProgram = null;
        _currentCamera = null;

        _currentGeometryProgram = '';
        _currentMaterialId = -1;

        _lightsNeedUpdate = true;

        state.reset();

    }

    setDefaultGLState();

    this.context = _gl;
    this.capabilities = capabilities;
    this.extensions = extensions;
    this.state = state;

    // shadow map

    var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

    this.shadowMap = shadowMap;


    // Plugins

    var spritePlugin = new THREE.SpritePlugin( this, sprites );
    var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

    // API

    this.getContext = function() {

        return _gl;

    };

    this.getContextAttributes = function() {

        return _gl.getContextAttributes();

    };

    this.forceContextLoss = function() {

        extensions.get( 'WEBGL_lose_context' ).loseContext();

    };

    this.getMaxAnisotropy = ( function() {

        var value;

        return function getMaxAnisotropy() {

            if ( value !== undefined ) return value;

            var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

            if ( extension !== null ) {

                value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

            }
            else {

                value = 0;

            }

            return value;

        }

    } )();

    this.getPrecision = function() {

        return capabilities.precision;

    };

    this.getPixelRatio = function() {

        return pixelRatio;

    };

    this.setPixelRatio = function( value ) {

        if ( value !== undefined ) pixelRatio = value;

    };

    this.getSize = function() {

        return {
            width: _width,
            height: _height
        };

    };

    this.setSize = function( width, height, updateStyle ) {

        _width = width;
        _height = height;

        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;

        if ( updateStyle !== false ) {

            _canvas.style.width = width + 'px';
            _canvas.style.height = height + 'px';

        }

        this.setViewport( 0, 0, width, height );

    };

    this.setViewport = function( x, y, width, height ) {

        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;

        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    };

    this.setScissor = function( x, y, width, height ) {

        _gl.scissor(
            x * pixelRatio,
            y * pixelRatio,
            width * pixelRatio,
            height * pixelRatio
        );

    };

    this.enableScissorTest = function( boolean ) {

        state.setScissorTest( boolean );

    };

    // Clearing

    this.getClearColor = function() {

        return _clearColor;

    };

    this.setClearColor = function( color, alpha ) {

        _clearColor.set( color );

        _clearAlpha = alpha !== undefined ? alpha : 1;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.getClearAlpha = function() {

        return _clearAlpha;

    };

    this.setClearAlpha = function( alpha ) {

        _clearAlpha = alpha;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.clear = function( color, depth, stencil ) {

        var bits = 0;

        if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
        if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
        if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

        _gl.clear( bits );

    };

    this.clearColor = function() {

        _gl.clear( _gl.COLOR_BUFFER_BIT );

    };

    this.clearDepth = function() {

        _gl.clear( _gl.DEPTH_BUFFER_BIT );

    };

    this.clearStencil = function() {

        _gl.clear( _gl.STENCIL_BUFFER_BIT );

    };

    this.clearTarget = function( renderTarget, color, depth, stencil ) {

        this.setRenderTarget( renderTarget );
        this.clear( color, depth, stencil );

    };

    // Reset

    this.resetGLState = resetGLState;

    this.dispose = function() {

        _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    };

    // Events

    function onContextLost( event ) {

        event.preventDefault();

        resetGLState();
        setDefaultGLState();

        properties.clear();

    };

    function onTextureDispose( event ) {

        var texture = event.target;

        texture.removeEventListener( 'dispose', onTextureDispose );

        deallocateTexture( texture );

        _infoMemory.textures--;


    }

    function onRenderTargetDispose( event ) {

        var renderTarget = event.target;

        renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

        deallocateRenderTarget( renderTarget );

        _infoMemory.textures--;

    }

    function onMaterialDispose( event ) {

        var material = event.target;

        material.removeEventListener( 'dispose', onMaterialDispose );

        deallocateMaterial( material );

    }

    // Buffer deallocation

    function deallocateTexture( texture ) {

        var textureProperties = properties.get( texture );

        if ( texture.image && textureProperties.__image__webglTextureCube ) {

            // cube texture

            _gl.deleteTexture( textureProperties.__image__webglTextureCube );

        }
        else {

            // 2D texture

            if ( textureProperties.__webglInit === undefined ) return;

            _gl.deleteTexture( textureProperties.__webglTexture );

        }

        // remove all webgl properties
        properties.delete( texture );

    }

    function deallocateRenderTarget( renderTarget ) {

        var renderTargetProperties = properties.get( renderTarget );

        if ( !renderTarget || renderTargetProperties.__webglTexture === undefined ) return;

        _gl.deleteTexture( renderTargetProperties.__webglTexture );

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            for ( var i = 0; i < 6; i++ ) {

                _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
                _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

            }

        }
        else {

            _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
            _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

        }

        properties.delete( renderTarget );

    }

    function deallocateMaterial( material ) {

        releaseMaterialProgramReference( material );

        properties.delete( material );

    }


    function releaseMaterialProgramReference( material ) {

        var programInfo = properties.get( material ).program;

        material.program = undefined;

        if ( programInfo !== undefined ) {

            programCache.releaseProgram( programInfo );
        }

    }

    // Buffer rendering

    this.renderBufferImmediate = function( object, program, material ) {

        state.initAttributes();

        var buffers = properties.get( object );

        if ( object.hasPositions && !buffers.position ) buffers.position = _gl.createBuffer();
        if ( object.hasNormals && !buffers.normal ) buffers.normal = _gl.createBuffer();
        if ( object.hasUvs && !buffers.uv ) buffers.uv = _gl.createBuffer();
        if ( object.hasColors && !buffers.color ) buffers.color = _gl.createBuffer();

        var attributes = program.getAttributes();

        if ( object.hasPositions ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.position );
            _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasNormals ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

            if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

                for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

                    var array = object.normalArray;

                    var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
                    var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
                    var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

                    array[ i + 0 ] = nx;
                    array[ i + 1 ] = ny;
                    array[ i + 2 ] = nz;

                    array[ i + 3 ] = nx;
                    array[ i + 4 ] = ny;
                    array[ i + 5 ] = nz;

                    array[ i + 6 ] = nx;
                    array[ i + 7 ] = ny;
                    array[ i + 8 ] = nz;

                }

            }

            _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.normal );

            _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasUvs && material.map ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.uv );

            _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.color );

            _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

        }

        state.disableUnusedAttributes();

        _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

        object.count = 0;

    };

    this.renderBufferDirect = function( camera, lights, fog, geometry, material, object, group ) {

        setMaterial( material );

        var program = setProgram( camera, lights, fog, material, object );

        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

        if ( geometryProgram !== _currentGeometryProgram ) {

            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;

        }

        // morph targets

        var morphTargetInfluences = object.morphTargetInfluences;

        if ( morphTargetInfluences !== undefined ) {

            var activeInfluences = [];

            for ( var i = 0, l = morphTargetInfluences.length; i < l; i++ ) {

                var influence = morphTargetInfluences[ i ];
                activeInfluences.push( [ influence, i ] );

            }

            activeInfluences.sort( numericalSort );

            if ( activeInfluences.length > 8 ) {

                activeInfluences.length = 8;

            }

            var morphAttributes = geometry.morphAttributes;

            for ( var i = 0, l = activeInfluences.length; i < l; i++ ) {

                var influence = activeInfluences[ i ];
                morphInfluences[ i ] = influence[ 0 ];

                if ( influence[ 0 ] !== 0 ) {

                    var index = influence[ 1 ];

                    if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
                    if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

                }
                else {

                    if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
                    if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

                }

            }

            var uniforms = program.getUniforms();

            if ( uniforms.morphTargetInfluences !== null ) {

                _gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

            }

            updateBuffers = true;

        }

        //

        var index = geometry.index;
        var position = geometry.attributes.position;

        if ( material.wireframe === true ) {

            index = objects.getWireframeAttribute( geometry );

        }

        var renderer;

        if ( index !== null ) {

            renderer = indexedBufferRenderer;
            renderer.setIndex( index );

        }
        else {

            renderer = bufferRenderer;

        }

        if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry );

            if ( index !== null ) {

                _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

            }

        }

        if ( group === undefined ) {

            var count;

            if ( index !== null ) {
                count = index.count;

            }
            else if ( position instanceof THREE.InterleavedBufferAttribute ) {

                count = position.data.array.length / 3;

            }
            else {
                count = position.count;

            }

            var drawRange = geometry.drawRange;

            group = {
                start: drawRange.start,
                count: Math.min( drawRange.count, count )
            };

        }

        if ( object instanceof THREE.Mesh ) {

            if ( material.wireframe === true ) {

                state.setLineWidth( material.wireframeLinewidth * pixelRatio );
                renderer.setMode( _gl.LINES );

            }
            else {

                renderer.setMode( _gl.TRIANGLES );

            }

            if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

                renderer.renderInstances( geometry );

            }
            else {

                renderer.render( group.start, group.count );

            }

        }
        else if ( object instanceof THREE.Line ) {

            var lineWidth = material.linewidth;

            if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

            state.setLineWidth( lineWidth * pixelRatio );

            if ( object instanceof THREE.LineSegments ) {

                renderer.setMode( _gl.LINES );

            }
            else {

                renderer.setMode( _gl.LINE_STRIP );

            }

            renderer.render( group.start, group.count );

        }
        else if ( object instanceof THREE.Points ) {
            renderer.setMode( _gl.POINTS );
            renderer.render( group.start, group.count );

        }

    };

    function setupVertexAttributes( material, program, geometry, startIndex ) {

        var extension;

        if ( geometry instanceof THREE.InstancedBufferGeometry ) {

            extension = extensions.get( 'ANGLE_instanced_arrays' );

            if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

            }

        }

        if ( startIndex === undefined ) startIndex = 0;

        state.initAttributes();

        var geometryAttributes = geometry.attributes;

        var programAttributes = program.getAttributes();

        var materialDefaultAttributeValues = material.defaultAttributeValues;

        for ( var name in programAttributes ) {

            var programAttribute = programAttributes[ name ];

            if ( programAttribute >= 0 ) {

                var geometryAttribute = geometryAttributes[ name ];

                if ( geometryAttribute !== undefined ) {

                    state.enableAttribute( programAttribute );

                    var size = geometryAttribute.itemSize;
                    var buffer = objects.getAttributeBuffer( geometryAttribute );

                    if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

                        if ( data instanceof THREE.InstancedInterleavedBuffer ) {

                            if ( extension === null ) {

                                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                                return;

                            }

                            extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;

                            }

                        }

                    }
                    else {

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

                        if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

                            if ( extension === null ) {

                                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                                return;

                            }

                            extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                            }

                        }

                    }

                }
                else if ( materialDefaultAttributeValues !== undefined ) {

                    var value = materialDefaultAttributeValues[ name ];

                    if ( value !== undefined ) {

                        switch ( value.length ) {

                            case 2:
                                _gl.vertexAttrib2fv( programAttribute, value );
                                break;

                            case 3:
                                _gl.vertexAttrib3fv( programAttribute, value );
                                break;

                            case 4:
                                _gl.vertexAttrib4fv( programAttribute, value );
                                break;

                            default:
                                _gl.vertexAttrib1fv( programAttribute, value );

                        }

                    }

                }

            }

        }

        state.disableUnusedAttributes();

    }

    // Sorting

    function numericalSort( a, b ) {

        return b[ 0 ] - a[ 0 ];

    }

    function painterSortStable( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        }
        else if ( a.material.id !== b.material.id ) {

            return a.material.id - b.material.id;

        }
        else if ( a.z !== b.z ) {

            return a.z - b.z;

        }
        else {

            return a.id - b.id;

        }

    }

    function reversePainterSortStable( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        }
        if ( a.z !== b.z ) {

            return b.z - a.z;

        }
        else {

            return a.id - b.id;

        }

    }

    // Rendering

    this.render = function( scene, camera, renderTarget, forceClear ) {

        if ( camera instanceof THREE.Camera === false ) {

            console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
            return;

        }

        var fog = scene.fog;

        // reset caching for this frame

        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;

        // update scene graph

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

        // update camera matrices and frustum

        if ( camera.parent === null ) camera.updateMatrixWorld();

        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        _frustum.setFromMatrix( _projScreenMatrix );

        lights.length = 0;

        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;

        opaqueImmediateObjectsLastIndex = -1;
        transparentImmediateObjectsLastIndex = -1;

        sprites.length = 0;
        lensFlares.length = 0;

        projectObject( scene );

        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;

        opaqueImmediateObjects.length = opaqueImmediateObjectsLastIndex + 1;
        transparentImmediateObjects.length = transparentImmediateObjectsLastIndex + 1;

        if ( _this.sortObjects === true ) {

            opaqueObjects.sort( painterSortStable );
            transparentObjects.sort( reversePainterSortStable );

        }

        //

        shadowMap.render( scene, camera );

        //

        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;

        this.setRenderTarget( renderTarget );

        if ( this.autoClear || forceClear ) {

            this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

        }

        //

        if ( scene.overrideMaterial ) {

            var overrideMaterial = scene.overrideMaterial;

            renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
            renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

            renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog, overrideMaterial );
            renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog, overrideMaterial );

        }
        else {

            // opaque pass (front-to-back order)

            state.setBlending( THREE.NoBlending );

            renderObjects( opaqueObjects, camera, lights, fog );
            renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog );

            // transparent pass (back-to-front order)

            renderObjects( transparentObjects, camera, lights, fog );
            renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog );

        }

        // custom render plugins (post pass)

        spritePlugin.render( scene, camera );
        lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

        // Generate mipmap if we're using any kind of mipmap filtering

        if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

            updateRenderTargetMipmap( renderTarget );

        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render

        state.setDepthTest( true );
        state.setDepthWrite( true );
        state.setColorWrite( true );

        // _gl.finish();

    };

    function pushImmediateRenderItem( object ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( object.material.transparent ) {

            array = transparentImmediateObjects;
            index = ++transparentImmediateObjectsLastIndex;

        }
        else {

            array = opaqueImmediateObjects;
            index = ++opaqueImmediateObjectsLastIndex;

        }

        // recycle existing position or grow the array

        if ( index < array.length ) {

            array[ index ] = object;

        }
        else {

            // assert( index === array.length );
            array.push( object );

        }


    }

    function pushRenderItem( object, geometry, material, z, group ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( material.transparent ) {

            array = transparentObjects;
            index = ++transparentObjectsLastIndex;

        }
        else {

            array = opaqueObjects;
            index = ++opaqueObjectsLastIndex;

        }

        // recycle existing render item or grow the array

        var renderItem = array[ index ];

        if ( renderItem !== undefined ) {

            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = _vector3.z;
            renderItem.group = group;

        }
        else {

            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: _vector3.z,
                group: group
            };

            // assert( index === array.length );
            array.push( renderItem );

        }

    }

    function projectObject( object ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Light ) {

            lights.push( object );

        }
        else if ( object instanceof THREE.Sprite ) {

            sprites.push( object );

        }
        else if ( object instanceof THREE.LensFlare ) {

            lensFlares.push( object );

        }
        else if ( object instanceof THREE.ImmediateRenderObject ) {

            pushImmediateRenderItem( object );

        }
        else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object instanceof THREE.SkinnedMesh ) {

                object.skeleton.update();

            }

            if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                var material = object.material;

                if ( material.visible === true ) {

                    if ( _this.sortObjects === true ) {

                        _vector3.setFromMatrixPosition( object.matrixWorld );
                        _vector3.applyProjection( _projScreenMatrix );

                    }

                    var geometry = objects.update( object );

                    if ( material instanceof THREE.MeshFaceMaterial ) {

                        var groups = geometry.groups;
                        var materials = material.materials;

                        for ( var i = 0, l = groups.length; i < l; i++ ) {

                            var group = groups[ i ];
                            var groupMaterial = materials[ group.materialIndex ];

                            if ( groupMaterial.visible === true ) {

                                pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

                            }

                        }

                    }
                    else {

                        pushRenderItem( object, geometry, material, _vector3.z );

                    }

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            projectObject( children[ i ] );

        }

    }

    function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

        for ( var i = 0, l = renderList.length; i < l; i++ ) {

            var renderItem = renderList[ i ];

            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            _this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

        }

    }

    function renderObjectsImmediate( renderList, camera, lights, fog, overrideMaterial ) {

        var material = overrideMaterial;

        for ( var i = 0, l = renderList.length; i < l; i++ ) {

            var object = renderList[ i ];

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            if ( overrideMaterial === undefined ) material = object.material;

            setMaterial( material );

            var program = setProgram( camera, lights, fog, material, object );

            _currentGeometryProgram = '';

            object.render( function( object ) {

                _this.renderBufferImmediate( object, program, material );

            } );

        }

    }

    function initMaterial( material, lights, fog, object ) {

        var materialProperties = properties.get( material );

        var parameters = programCache.getParameters( material, lights, fog, object );
        var code = programCache.getProgramCode( material, parameters );

        var program = materialProperties.program;
        var programChange = true;

        if ( program === undefined ) {

            // new material
            material.addEventListener( 'dispose', onMaterialDispose );

        }
        else if ( program.code !== code ) {

            // changed glsl or parameters
            releaseMaterialProgramReference( material );

        }
        else if ( parameters.shaderID !== undefined ) {

            // same glsl and uniform list
            return;

        }
        else {

            // only rebuild uniform list
            programChange = false;

        }

        if ( programChange ) {

            if ( parameters.shaderID ) {

                var shader = THREE.ShaderLib[ parameters.shaderID ];

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };

            }
            else {

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };

            }

            material.__webglShader = materialProperties.__webglShader;

            program = programCache.acquireProgram( material, parameters, code );

            materialProperties.program = program;
            material.program = program;

        }

        var attributes = program.getAttributes();

        if ( material.morphTargets ) {

            material.numSupportedMorphTargets = 0;

            for ( var i = 0; i < _this.maxMorphTargets; i++ ) {

                if ( attributes[ 'morphTarget' + i ] >= 0 ) {

                    material.numSupportedMorphTargets++;

                }

            }

        }

        if ( material.morphNormals ) {

            material.numSupportedMorphNormals = 0;

            for ( i = 0; i < _this.maxMorphNormals; i++ ) {

                if ( attributes[ 'morphNormal' + i ] >= 0 ) {

                    material.numSupportedMorphNormals++;

                }

            }

        }

        materialProperties.uniformsList = [];

        var uniformLocations = materialProperties.program.getUniforms();

        for ( var u in materialProperties.__webglShader.uniforms ) {

            var location = uniformLocations[ u ];

            if ( location ) {

                materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

            }

        }

    }

    function setMaterial( material ) {

        setMaterialFaces( material );

        if ( material.transparent === true ) {

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

        }
        else {

            state.setBlending( THREE.NoBlending );

        }

        state.setDepthFunc( material.depthFunc );
        state.setDepthTest( material.depthTest );
        state.setDepthWrite( material.depthWrite );
        state.setColorWrite( material.colorWrite );
        state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    }

    function setMaterialFaces( material ) {

        material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
        state.setFlipSided( material.side === THREE.BackSide );

    }

    function setProgram( camera, lights, fog, material, object ) {

        _usedTextureUnits = 0;

        var materialProperties = properties.get( material );

        if ( material.needsUpdate || !materialProperties.program ) {

            initMaterial( material, lights, fog, object );
            material.needsUpdate = false;

        }

        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;

        var program = materialProperties.program,
            p_uniforms = program.getUniforms(),
            m_uniforms = materialProperties.__webglShader.uniforms;

        if ( program.id !== _currentProgram ) {

            _gl.useProgram( program.program );
            _currentProgram = program.id;

            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;

        }

        if ( material.id !== _currentMaterialId ) {

            if ( _currentMaterialId === -1 ) refreshLights = true;
            _currentMaterialId = material.id;

            refreshMaterial = true;

        }

        if ( refreshProgram || camera !== _currentCamera ) {

            _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

            if ( capabilities.logarithmicDepthBuffer ) {

                _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

            }


            if ( camera !== _currentCamera ) _currentCamera = camera;

            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)

            if ( material instanceof THREE.ShaderMaterial ||
                material instanceof THREE.MeshPhongMaterial ||
                material.envMap ) {

                if ( p_uniforms.cameraPosition !== undefined ) {

                    _vector3.setFromMatrixPosition( camera.matrixWorld );
                    _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

                }

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.ShaderMaterial ||
                material.skinning ) {

                if ( p_uniforms.viewMatrix !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

                }

            }

        }

        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // not sure why, but otherwise weird things happen

        if ( material.skinning ) {

            if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

            }

            if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

            }

            if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

                if ( p_uniforms.boneTexture !== undefined ) {

                    var textureUnit = getTextureUnit();

                    _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
                    _this.setTexture( object.skeleton.boneTexture, textureUnit );

                }

                if ( p_uniforms.boneTextureWidth !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

                }

                if ( p_uniforms.boneTextureHeight !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

                }

            }
            else if ( object.skeleton && object.skeleton.boneMatrices ) {

                if ( p_uniforms.boneGlobalMatrices !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

                }

            }

        }

        if ( refreshMaterial ) {

            // refresh uniforms common to several materials

            if ( fog && material.fog ) {

                refreshUniformsFog( m_uniforms, fog );

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material.lights ) {

                if ( _lightsNeedUpdate ) {

                    refreshLights = true;
                    setupLights( lights, camera );
                    _lightsNeedUpdate = false;

                }

                if ( refreshLights ) {

                    refreshUniformsLights( m_uniforms, _lights );
                    markUniformsLightsNeedsUpdate( m_uniforms, true );

                }
                else {

                    markUniformsLightsNeedsUpdate( m_uniforms, false );

                }

            }

            if ( material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsCommon( m_uniforms, material );

            }

            // refresh single material specific uniforms

            if ( material instanceof THREE.LineBasicMaterial ) {

                refreshUniformsLine( m_uniforms, material );

            }
            else if ( material instanceof THREE.LineDashedMaterial ) {

                refreshUniformsLine( m_uniforms, material );
                refreshUniformsDash( m_uniforms, material );

            }
            else if ( material instanceof THREE.PointsMaterial ) {

                refreshUniformsParticle( m_uniforms, material );

            }
            else if ( material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsPhong( m_uniforms, material );

            }
            else if ( material instanceof THREE.MeshDepthMaterial ) {

                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;

            }
            else if ( material instanceof THREE.MeshNormalMaterial ) {

                m_uniforms.opacity.value = material.opacity;

            }

            if ( object.receiveShadow && !material._shadowPass ) {

                refreshUniformsShadow( m_uniforms, lights );

            }

            // load common uniforms

            loadUniformsGeneric( materialProperties.uniformsList );

        }

        loadUniformsMatrices( p_uniforms, object );

        if ( p_uniforms.modelMatrix !== undefined ) {

            _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

        }

        return program;

    }

    // Uniforms (refresh uniforms objects)

    function refreshUniformsCommon( uniforms, material ) {

        uniforms.opacity.value = material.opacity;

        uniforms.diffuse.value = material.color;

        if ( material.emissive ) {

            uniforms.emissive.value = material.emissive;

        }

        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

        if ( material.aoMap ) {

            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;

        }

        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if ( material.map ) {

            uvScaleMap = material.map;

        }
        else if ( material.specularMap ) {

            uvScaleMap = material.specularMap;

        }
        else if ( material.displacementMap ) {

            uvScaleMap = material.displacementMap;

        }
        else if ( material.normalMap ) {

            uvScaleMap = material.normalMap;

        }
        else if ( material.bumpMap ) {

            uvScaleMap = material.bumpMap;

        }
        else if ( material.alphaMap ) {

            uvScaleMap = material.alphaMap;

        }
        else if ( material.emissiveMap ) {

            uvScaleMap = material.emissiveMap;

        }

        if ( uvScaleMap !== undefined ) {

            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;

    }

    function refreshUniformsLine( uniforms, material ) {

        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;

    }

    function refreshUniformsDash( uniforms, material ) {

        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;

    }

    function refreshUniformsParticle( uniforms, material ) {

        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

        uniforms.map.value = material.map;

        if ( material.map !== null ) {

            var offset = material.map.offset;
            var repeat = material.map.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

    }

    function refreshUniformsFog( uniforms, fog ) {

        uniforms.fogColor.value = fog.color;

        if ( fog instanceof THREE.Fog ) {

            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;

        }
        else if ( fog instanceof THREE.FogExp2 ) {

            uniforms.fogDensity.value = fog.density;

        }

    }

    function refreshUniformsPhong( uniforms, material ) {

        uniforms.specular.value = material.specular;
        uniforms.shininess.value = material.shininess;

        if ( material.lightMap ) {

            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;

        }

        if ( material.emissiveMap ) {

            uniforms.emissiveMap.value = material.emissiveMap;

        }

        if ( material.bumpMap ) {

            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;

        }

        if ( material.normalMap ) {

            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy( material.normalScale );

        }

        if ( material.displacementMap ) {

            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;

        }

    }

    function refreshUniformsLights( uniforms, lights ) {

        uniforms.ambientLightColor.value = lights.ambient;

        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;

        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;

        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;

        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;

    }

    // If uniforms are marked as clean, they don't need to be loaded to the GPU.

    function markUniformsLightsNeedsUpdate( uniforms, value ) {

        uniforms.ambientLightColor.needsUpdate = value;

        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;

        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;

        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;

        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;

    }

    function refreshUniformsShadow( uniforms, lights ) {

        if ( uniforms.shadowMatrix ) {

            var j = 0;

            for ( var i = 0, il = lights.length; i < il; i++ ) {

                var light = lights[ i ];

                if ( !light.castShadow ) continue;

                if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight ) ) {

                    uniforms.shadowMap.value[ j ] = light.shadowMap;
                    uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

                    uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

                    uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
                    uniforms.shadowBias.value[ j ] = light.shadowBias;

                    j++;

                }

            }

        }

    }

    // Uniforms (load to GPU)

    function loadUniformsMatrices( uniforms, object ) {

        _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

        if ( uniforms.normalMatrix ) {

            _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

        }

    }

    function getTextureUnit() {

        var textureUnit = _usedTextureUnits;

        if ( textureUnit >= capabilities.maxTextures ) {

            console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

        }

        _usedTextureUnits += 1;

        return textureUnit;

    }

    function loadUniformsGeneric( uniforms ) {

        var texture, textureUnit;

        for ( var j = 0, jl = uniforms.length; j < jl; j++ ) {

            var uniform = uniforms[ j ][ 0 ];

            // needsUpdate property is not added to all uniforms.
            if ( uniform.needsUpdate === false ) continue;

            var type = uniform.type;
            var value = uniform.value;
            var location = uniforms[ j ][ 1 ];

            switch ( type ) {

                case '1i':
                    _gl.uniform1i( location, value );
                    break;

                case '1f':
                    _gl.uniform1f( location, value );
                    break;

                case '2f':
                    _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
                    break;

                case '3f':
                    _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
                    break;

                case '4f':
                    _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
                    break;

                case '1iv':
                    _gl.uniform1iv( location, value );
                    break;

                case '3iv':
                    _gl.uniform3iv( location, value );
                    break;

                case '1fv':
                    _gl.uniform1fv( location, value );
                    break;

                case '2fv':
                    _gl.uniform2fv( location, value );
                    break;

                case '3fv':
                    _gl.uniform3fv( location, value );
                    break;

                case '4fv':
                    _gl.uniform4fv( location, value );
                    break;

                case 'Matrix3fv':
                    _gl.uniformMatrix3fv( location, false, value );
                    break;

                case 'Matrix4fv':
                    _gl.uniformMatrix4fv( location, false, value );
                    break;

                    //

                case 'i':

                    // single integer
                    _gl.uniform1i( location, value );

                    break;

                case 'f':

                    // single float
                    _gl.uniform1f( location, value );

                    break;

                case 'v2':

                    // single THREE.Vector2
                    _gl.uniform2f( location, value.x, value.y );

                    break;

                case 'v3':

                    // single THREE.Vector3
                    _gl.uniform3f( location, value.x, value.y, value.z );

                    break;

                case 'v4':

                    // single THREE.Vector4
                    _gl.uniform4f( location, value.x, value.y, value.z, value.w );

                    break;

                case 'c':

                    // single THREE.Color
                    _gl.uniform3f( location, value.r, value.g, value.b );

                    break;

                case 'iv1':

                    // flat array of integers (JS or typed array)
                    _gl.uniform1iv( location, value );

                    break;

                case 'iv':

                    // flat array of integers with 3 x N size (JS or typed array)
                    _gl.uniform3iv( location, value );

                    break;

                case 'fv1':

                    // flat array of floats (JS or typed array)
                    _gl.uniform1fv( location, value );

                    break;

                case 'fv':

                    // flat array of floats with 3 x N size (JS or typed array)
                    _gl.uniform3fv( location, value );

                    break;

                case 'v2v':

                    // array of THREE.Vector2

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 2 * value.length );

                    }

                    for ( var i = 0, i2 = 0, il = value.length; i < il; i++, i2 += 2 ) {

                        uniform._array[ i2 + 0 ] = value[ i ].x;
                        uniform._array[ i2 + 1 ] = value[ i ].y;

                    }

                    _gl.uniform2fv( location, uniform._array );

                    break;

                case 'v3v':

                    // array of THREE.Vector3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 3 * value.length );

                    }

                    for ( var i = 0, i3 = 0, il = value.length; i < il; i++, i3 += 3 ) {

                        uniform._array[ i3 + 0 ] = value[ i ].x;
                        uniform._array[ i3 + 1 ] = value[ i ].y;
                        uniform._array[ i3 + 2 ] = value[ i ].z;

                    }

                    _gl.uniform3fv( location, uniform._array );

                    break;

                case 'v4v':

                    // array of THREE.Vector4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 4 * value.length );

                    }

                    for ( var i = 0, i4 = 0, il = value.length; i < il; i++, i4 += 4 ) {

                        uniform._array[ i4 + 0 ] = value[ i ].x;
                        uniform._array[ i4 + 1 ] = value[ i ].y;
                        uniform._array[ i4 + 2 ] = value[ i ].z;
                        uniform._array[ i4 + 3 ] = value[ i ].w;

                    }

                    _gl.uniform4fv( location, uniform._array );

                    break;

                case 'm3':

                    // single THREE.Matrix3
                    _gl.uniformMatrix3fv( location, false, value.elements );

                    break;

                case 'm3v':

                    // array of THREE.Matrix3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 9 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

                    }

                    _gl.uniformMatrix3fv( location, false, uniform._array );

                    break;

                case 'm4':

                    // single THREE.Matrix4
                    _gl.uniformMatrix4fv( location, false, value.elements );

                    break;

                case 'm4v':

                    // array of THREE.Matrix4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 16 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

                    }

                    _gl.uniformMatrix4fv( location, false, uniform._array );

                    break;

                case 't':

                    // single THREE.Texture (2d or cube)

                    texture = value;
                    textureUnit = getTextureUnit();

                    _gl.uniform1i( location, textureUnit );

                    if ( !texture ) continue;

                    if ( texture instanceof THREE.CubeTexture ||
                        ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

                        // CompressedTexture can have Array in image :/

                        setCubeTexture( texture, textureUnit );

                    }
                    else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

                        setCubeTextureDynamic( texture, textureUnit );

                    }
                    else {

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                case 'tv':

                    // array of THREE.Texture (2d)

                    if ( uniform._array === undefined ) {

                        uniform._array = [];

                    }

                    for ( var i = 0, il = uniform.value.length; i < il; i++ ) {

                        uniform._array[ i ] = getTextureUnit();

                    }

                    _gl.uniform1iv( location, uniform._array );

                    for ( var i = 0, il = uniform.value.length; i < il; i++ ) {

                        texture = uniform.value[ i ];
                        textureUnit = uniform._array[ i ];

                        if ( !texture ) continue;

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                default:

                    console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

            }

        }

    }

    function setColorLinear( array, offset, color, intensity ) {

        array[ offset + 0 ] = color.r * intensity;
        array[ offset + 1 ] = color.g * intensity;
        array[ offset + 2 ] = color.b * intensity;

    }

    function setupLights( lights, camera ) {

        var l, ll, light,
            r = 0,
            g = 0,
            b = 0,
            color, skyColor, groundColor,
            intensity,
            distance,

            zlights = _lights,

            viewMatrix = camera.matrixWorldInverse,

            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,

            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,

            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,

            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,

            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,

            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,

            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;

        for ( l = 0, ll = lights.length; l < ll; l++ ) {

            light = lights[ l ];

            if ( light.onlyShadow ) continue;

            color = light.color;
            intensity = light.intensity;
            distance = light.distance;

            if ( light instanceof THREE.AmbientLight ) {

                if ( !light.visible ) continue;

                r += color.r;
                g += color.g;
                b += color.b;

            }
            else if ( light instanceof THREE.DirectionalLight ) {

                dirCount += 1;

                if ( !light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                dirOffset = dirLength * 3;

                dirPositions[ dirOffset + 0 ] = _direction.x;
                dirPositions[ dirOffset + 1 ] = _direction.y;
                dirPositions[ dirOffset + 2 ] = _direction.z;

                setColorLinear( dirColors, dirOffset, color, intensity );

                dirLength += 1;

            }
            else if ( light instanceof THREE.PointLight ) {

                pointCount += 1;

                if ( !light.visible ) continue;

                pointOffset = pointLength * 3;

                setColorLinear( pointColors, pointOffset, color, intensity );

                _vector3.setFromMatrixPosition( light.matrixWorld );
                _vector3.applyMatrix4( viewMatrix );

                pointPositions[ pointOffset + 0 ] = _vector3.x;
                pointPositions[ pointOffset + 1 ] = _vector3.y;
                pointPositions[ pointOffset + 2 ] = _vector3.z;

                // distance is 0 if decay is 0, because there is no attenuation at all.
                pointDistances[ pointLength ] = distance;
                pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                pointLength += 1;

            }
            else if ( light instanceof THREE.SpotLight ) {

                spotCount += 1;

                if ( !light.visible ) continue;

                spotOffset = spotLength * 3;

                setColorLinear( spotColors, spotOffset, color, intensity );

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.copy( _direction ).applyMatrix4( viewMatrix );

                spotPositions[ spotOffset + 0 ] = _vector3.x;
                spotPositions[ spotOffset + 1 ] = _vector3.y;
                spotPositions[ spotOffset + 2 ] = _vector3.z;

                spotDistances[ spotLength ] = distance;

                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                spotDirections[ spotOffset + 0 ] = _direction.x;
                spotDirections[ spotOffset + 1 ] = _direction.y;
                spotDirections[ spotOffset + 2 ] = _direction.z;

                spotAnglesCos[ spotLength ] = Math.cos( light.angle );
                spotExponents[ spotLength ] = light.exponent;
                spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                spotLength += 1;

            }
            else if ( light instanceof THREE.HemisphereLight ) {

                hemiCount += 1;

                if ( !light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _direction.transformDirection( viewMatrix );

                hemiOffset = hemiLength * 3;

                hemiPositions[ hemiOffset + 0 ] = _direction.x;
                hemiPositions[ hemiOffset + 1 ] = _direction.y;
                hemiPositions[ hemiOffset + 2 ] = _direction.z;

                skyColor = light.color;
                groundColor = light.groundColor;

                setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
                setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

                hemiLength += 1;

            }

        }

        // null eventual remains from removed lights
        // (this is to avoid if in shader)

        for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l++ ) dirColors[ l ] = 0.0;
        for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l++ ) pointColors[ l ] = 0.0;
        for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l++ ) spotColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l++ ) hemiSkyColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l++ ) hemiGroundColors[ l ] = 0.0;

        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;

        zlights.ambient[ 0 ] = r;
        zlights.ambient[ 1 ] = g;
        zlights.ambient[ 2 ] = b;

    }

    // GL state setting

    this.setFaceCulling = function( cullFace, frontFaceDirection ) {

        if ( cullFace === THREE.CullFaceNone ) {

            state.disable( _gl.CULL_FACE );

        }
        else {

            if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

                _gl.frontFace( _gl.CW );

            }
            else {

                _gl.frontFace( _gl.CCW );

            }

            if ( cullFace === THREE.CullFaceBack ) {

                _gl.cullFace( _gl.BACK );

            }
            else if ( cullFace === THREE.CullFaceFront ) {

                _gl.cullFace( _gl.FRONT );

            }
            else {

                _gl.cullFace( _gl.FRONT_AND_BACK );

            }

            state.enable( _gl.CULL_FACE );

        }

    };

    // Textures

    function setTextureParameters( textureType, texture, isImagePowerOfTwo ) {

        var extension;

        if ( isImagePowerOfTwo ) {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

        }
        else {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

            if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

            }

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

            if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

            }

        }

        extension = extensions.get( 'EXT_texture_filter_anisotropic' );

        if ( extension ) {

            if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
            if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

            if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

                _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
                properties.get( texture ).__currentAnisotropy = texture.anisotropy;

            }

        }

    }

    function uploadTexture( textureProperties, texture, slot ) {

        if ( textureProperties.__webglInit === undefined ) {

            textureProperties.__webglInit = true;

            texture.__webglInit = true;

            texture.addEventListener( 'dispose', onTextureDispose );

            textureProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
        _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
        _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

        texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

        var image = texture.image,
            isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
            glFormat = paramThreeToGL( texture.format ),
            glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

        var mipmap, mipmaps = texture.mipmaps;

        if ( texture instanceof THREE.DataTexture ) {

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

                texture.generateMipmaps = false;

            }
            else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

            }

        }
        else if ( texture instanceof THREE.CompressedTexture ) {

            for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                mipmap = mipmaps[ i ];

                if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                    if ( state.getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                        state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                    }
                    else {

                        console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

                    }

                }
                else {

                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

            }

        }
        else {

            // regular Texture (image, video, canvas)

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

                }

                texture.generateMipmaps = false;

            }
            else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

            }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

        textureProperties.__version = texture.version;

        if ( texture.onUpdate ) texture.onUpdate( texture );

    }

    this.setTexture = function( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

            var image = texture.image;

            if ( image === undefined ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
                return;

            }

            if ( image.complete === false ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
                return;

            }

            uploadTexture( textureProperties, texture, slot );
            return;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    };

    function clampToMaxSize( image, maxSize ) {

        if ( image.width > maxSize || image.height > maxSize ) {

            // Warning: Scaling through the canvas will only work with images that use
            // premultiplied alpha.

            var scale = maxSize / Math.max( image.width, image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = Math.floor( image.width * scale );
            canvas.height = Math.floor( image.height * scale );

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

            console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

            return canvas;

        }

        return image;

    }

    function setCubeTexture( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.image.length === 6 ) {

            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

                if ( !textureProperties.__image__webglTextureCube ) {

                    texture.addEventListener( 'dispose', onTextureDispose );

                    textureProperties.__image__webglTextureCube = _gl.createTexture();

                    _infoMemory.textures++;

                }

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

                _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

                var isCompressed = texture instanceof THREE.CompressedTexture;
                var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

                var cubeImage = [];

                for ( var i = 0; i < 6; i++ ) {

                    if ( _this.autoScaleCubemaps && !isCompressed && !isDataTexture ) {

                        cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

                    }
                    else {

                        cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

                    }

                }

                var image = cubeImage[ 0 ],
                    isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
                    glFormat = paramThreeToGL( texture.format ),
                    glType = paramThreeToGL( texture.type );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

                for ( var i = 0; i < 6; i++ ) {

                    if ( !isCompressed ) {

                        if ( isDataTexture ) {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

                        }
                        else {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

                        }

                    }
                    else {

                        var mipmap, mipmaps = cubeImage[ i ].mipmaps;

                        for ( var j = 0, jl = mipmaps.length; j < jl; j++ ) {

                            mipmap = mipmaps[ j ];

                            if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                                if ( state.getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                                    state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                                }
                                else {

                                    console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                                }

                            }
                            else {

                                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                            }

                        }

                    }

                }

                if ( texture.generateMipmaps && isImagePowerOfTwo ) {

                    _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

                }

                textureProperties.__version = texture.version;

                if ( texture.onUpdate ) texture.onUpdate( texture );

            }
            else {

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

            }

        }

    }

    function setCubeTextureDynamic( texture, slot ) {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    }

    // Render targets

    function setupFrameBuffer( framebuffer, renderTarget, textureTarget ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget ).__webglTexture, 0 );

    }

    function setupRenderBuffer( renderbuffer, renderTarget ) {

        _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

        if ( renderTarget.depthBuffer && !renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            /* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/

        }
        else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

        }
        else {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

        }

    }

    this.setRenderTarget = function( renderTarget ) {

        var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

        if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
            if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

            renderTargetProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures++;

            // Setup texture, create render and frame buffers

            var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
                glFormat = paramThreeToGL( renderTarget.format ),
                glType = paramThreeToGL( renderTarget.type );

            if ( isCube ) {

                renderTargetProperties.__webglFramebuffer = [];
                renderTargetProperties.__webglRenderbuffer = [];

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

                for ( var i = 0; i < 6; i++ ) {

                    renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
                    renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

                    state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                    setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

                }

                if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

            }
            else {

                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

                if ( renderTarget.shareDepthFrom ) {

                    renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

                }
                else {

                    renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

                }

                state.bindTexture( _gl.TEXTURE_2D, renderTargetProperties.__webglTexture );
                setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

                if ( renderTarget.shareDepthFrom ) {

                    if ( renderTarget.depthBuffer && !renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }
                    else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }

                }
                else {

                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

                }

                if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

            }

            // Release everything

            if ( isCube ) {

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

            }
            else {

                state.bindTexture( _gl.TEXTURE_2D, null );

            }

            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( isCube ) {

                framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

            }
            else {

                framebuffer = renderTargetProperties.__webglFramebuffer;

            }

            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        }
        else {

            framebuffer = null;

            width = _viewportWidth;
            height = _viewportHeight;

            vx = _viewportX;
            vy = _viewportY;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        _currentWidth = width;
        _currentHeight = height;

    };

    this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

        if ( !( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
            return;

        }

        if ( properties.get( renderTarget ).__webglFramebuffer ) {

            if ( renderTarget.format !== THREE.RGBAFormat ) {

                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
                return;

            }

            var restore = false;

            if ( properties.get( renderTarget ).__webglFramebuffer !== _currentFramebuffer ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, properties.get( renderTarget ).__webglFramebuffer );

                restore = true;

            }

            if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

                _gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

            }
            else {

                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

            }

            if ( restore ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

            }

        }

    };

    function updateRenderTargetMipmap( renderTarget ) {

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( renderTarget ).__webglTexture );
            _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
            state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

        }
        else {

            state.bindTexture( _gl.TEXTURE_2D, properties.get( renderTarget ).__webglTexture );
            _gl.generateMipmap( _gl.TEXTURE_2D );
            state.bindTexture( _gl.TEXTURE_2D, null );

        }

    }

    // Fallback filters for non-power-of-2 textures

    function filterFallback( f ) {

        if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

            return _gl.NEAREST;

        }

        return _gl.LINEAR;

    }

    // Map three.js constants to WebGL constants

    function paramThreeToGL( p ) {

        var extension;

        if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
        if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
        if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

        if ( p === THREE.NearestFilter ) return _gl.NEAREST;
        if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
        if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

        if ( p === THREE.LinearFilter ) return _gl.LINEAR;
        if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
        if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

        if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
        if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
        if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
        if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

        if ( p === THREE.ByteType ) return _gl.BYTE;
        if ( p === THREE.ShortType ) return _gl.SHORT;
        if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
        if ( p === THREE.IntType ) return _gl.INT;
        if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
        if ( p === THREE.FloatType ) return _gl.FLOAT;

        extension = extensions.get( 'OES_texture_half_float' );

        if ( extension !== null ) {

            if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

        }

        if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
        if ( p === THREE.RGBFormat ) return _gl.RGB;
        if ( p === THREE.RGBAFormat ) return _gl.RGBA;
        if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
        if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

        if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
        if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
        if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

        if ( p === THREE.ZeroFactor ) return _gl.ZERO;
        if ( p === THREE.OneFactor ) return _gl.ONE;
        if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
        if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
        if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
        if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
        if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
        if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

        if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
        if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
        if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

        extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

        }

        extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

        }

        extension = extensions.get( 'EXT_blend_minmax' );

        if ( extension !== null ) {

            if ( p === THREE.MinEquation ) return extension.MIN_EXT;
            if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

        }

        return 0;

    }

    // DEPRECATED

    this.supportsFloatTextures = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
        return extensions.get( 'OES_texture_float' );

    };

    this.supportsHalfFloatTextures = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
        return extensions.get( 'OES_texture_half_float' );

    };

    this.supportsStandardDerivatives = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
        return extensions.get( 'OES_standard_derivatives' );

    };

    this.supportsCompressedTextureS3TC = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_s3tc' );

    };

    this.supportsCompressedTexturePVRTC = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    };

    this.supportsBlendMinMax = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
        return extensions.get( 'EXT_blend_minmax' );

    };

    this.supportsVertexTextures = function() {

        return capabilities.vertexTextures;

    };

    this.supportsInstancedArrays = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
        return extensions.get( 'ANGLE_instanced_arrays' );

    };

    //

    this.initMaterial = function() {

        console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

    };

    this.addPrePlugin = function() {

        console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

    };

    this.addPostPlugin = function() {

        console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

    };

    this.updateShadowMap = function() {

        console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

    };

    Object.defineProperties( this, {
        shadowMapEnabled: {
            get: function() {

                return shadowMap.enabled;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
                shadowMap.enabled = value;

            }
        },
        shadowMapType: {
            get: function() {

                return shadowMap.type;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
                shadowMap.type = value;

            }
        },
        shadowMapCullFace: {
            get: function() {

                return shadowMap.cullFace;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
                shadowMap.cullFace = value;

            }
        },
        shadowMapDebug: {
            get: function() {

                return shadowMap.debug;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
                shadowMap.debug = value;

            }
        }
    } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function( width, height, options ) {

    this.uuid = THREE.Math.generateUUID();

    this.width = width;
    this.height = height;

    options = options || {};

    this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
    this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
    this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

    this.generateMipmaps = true;

    this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

    constructor: THREE.WebGLRenderTarget,

    setSize: function( width, height ) {

        if ( this.width !== width || this.height !== height ) {

            this.width = width;
            this.height = height;

            this.dispose();

        }

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.width = source.width;
        this.height = source.height;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.format = source.format;
        this.type = source.type;

        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;

        this.generateMipmaps = source.generateMipmaps;

        this.shareDepthFrom = source.shareDepthFrom;

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function( width, height, options ) {

    THREE.WebGLRenderTarget.call( this, width, height, options );

    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLBufferRenderer = function( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var traceCount = 0;

    function render( start, count ) {
        if ( traceCount === 0 ) {
            traceCount = 1;
        }

        _gl.drawArrays( mode, start, count );

        _infoRender.calls++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var position = geometry.attributes.position;

        if ( position instanceof THREE.InterleavedBufferAttribute ) {

            extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

        }
        else {

            extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

        }

    }

    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLIndexedBufferRenderer = function( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var type, size;

    function setIndex( index ) {

        if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

            type = _gl.UNSIGNED_INT;
            size = 4;

        }
        else {

            type = _gl.UNSIGNED_SHORT;
            size = 2;

        }

    }

    function render( start, count ) {

        _gl.drawElements( mode, count, type, start * size );

        _infoRender.calls++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var index = geometry.index;

        extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

    }

    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLExtensions = function( gl ) {

    var extensions = {};

    this.get = function( name ) {

        if ( extensions[ name ] !== undefined ) {

            return extensions[ name ];

        }

        var extension;

        switch ( name ) {

            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
                break;

            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
                break;

            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
                break;

            default:
                extension = gl.getExtension( name );

        }

        if ( extension === null ) {

            console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

        }

        extensions[ name ] = extension;

        return extension;

    };

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function( gl, extensions, parameters ) {

    function getMaxPrecision( precision ) {

        if ( precision === 'highp' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

                return 'highp';

            }

            precision = 'mediump';

        }

        if ( precision === 'mediump' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

                return 'mediump';

            }

        }

        return 'lowp';

    }

    this.getMaxPrecision = getMaxPrecision;

    this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
    this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

    this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    this.vertexTextures = this.maxVertexTextures > 0;
    this.floatFragmentTextures = !!extensions.get( 'OES_texture_float' );
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

    var _maxPrecision = getMaxPrecision( this.precision );

    if ( _maxPrecision !== this.precision ) {

        console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
        this.precision = _maxPrecision;

    }

    if ( this.logarithmicDepthBuffer ) {

        this.logarithmicDepthBuffer = !!extensions.get( 'EXT_frag_depth' );

    }

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLGeometries = function( gl, properties, info ) {

    var geometries = {};

    function get( object ) {

        var geometry = object.geometry;

        if ( geometries[ geometry.id ] !== undefined ) {

            return geometries[ geometry.id ];

        }

        geometry.addEventListener( 'dispose', onGeometryDispose );

        var buffergeometry;

        if ( geometry instanceof THREE.BufferGeometry ) {

            buffergeometry = geometry;

        }
        else if ( geometry instanceof THREE.Geometry ) {

            if ( geometry._bufferGeometry === undefined ) {

                geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

            }

            buffergeometry = geometry._bufferGeometry;

        }

        geometries[ geometry.id ] = buffergeometry;

        info.memory.geometries++;

        return buffergeometry;

    }

    function onGeometryDispose( event ) {

        var geometry = event.target;
        var buffergeometry = geometries[ geometry.id ];

        deleteAttributes( buffergeometry.attributes );

        geometry.removeEventListener( 'dispose', onGeometryDispose );

        delete geometries[ geometry.id ];

        var property = properties.get( geometry );
        if ( property.wireframe ) deleteAttribute( property.wireframe );

        info.memory.geometries--;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function deleteAttribute( attribute ) {

        var buffer = getAttributeBuffer( attribute );

        if ( buffer !== undefined ) {

            gl.deleteBuffer( buffer );
            removeAttributeBuffer( attribute );

        }

    }

    function deleteAttributes( attributes ) {

        for ( var name in attributes ) {

            deleteAttribute( attributes[ name ] );

        }

    }

    function removeAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            properties.delete( attribute.data );

        }
        else {

            properties.delete( attribute );

        }

    }

    this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLObjects = function( gl, properties, info ) {

    var geometries = new THREE.WebGLGeometries( gl, properties, info );

    //

    function update( object ) {

        // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

        var geometry = geometries.get( object );

        if ( object.geometry instanceof THREE.Geometry ) {

            geometry.updateFromObject( object );

        }

        var index = geometry.index;
        var attributes = geometry.attributes;

        if ( index !== null ) {

            updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

        }

        for ( var name in attributes ) {

            updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

        }

        // morph targets

        var morphAttributes = geometry.morphAttributes;

        for ( var name in morphAttributes ) {

            var array = morphAttributes[ name ];

            for ( var i = 0, l = array.length; i < l; i++ ) {

                updateAttribute( array[ i ], gl.ARRAY_BUFFER );

            }

        }

        return geometry;

    }

    function updateAttribute( attribute, bufferType ) {

        var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

        var attributeProperties = properties.get( data );

        if ( attributeProperties.__webglBuffer === undefined ) {
            createBuffer( attributeProperties, data, bufferType );

        }
        else if ( attributeProperties.version !== data.version ) {

            updateBuffer( attributeProperties, data, bufferType );

        }

    }

    function createBuffer( attributeProperties, data, bufferType ) {

        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        gl.bufferData( bufferType, data.array, usage );

        attributeProperties.version = data.version;

    }

    function updateBuffer( attributeProperties, data, bufferType ) {

        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        if ( data.dynamic === false || data.updateRange.count === -1 ) {

            // Not using update ranges
            gl.bufferSubData( bufferType, 0, data.array );

        }
        else if ( data.updateRange.count === 0 ) {

            console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

        }
        else {
            gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

            data.updateRange.count = 0; // reset range

        }

        attributeProperties.version = data.version;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function getWireframeAttribute( geometry ) {

        var property = properties.get( geometry );

        if ( property.wireframe !== undefined ) {

            return property.wireframe;

        }

        var indices = [];

        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;

        // console.time( 'wireframe' );

        if ( index !== null ) {

            var edges = {};
            var array = index.array;

            for ( var i = 0, l = array.length; i < l; i += 3 ) {

                var a = array[ i + 0 ];
                var b = array[ i + 1 ];
                var c = array[ i + 2 ];

                if ( checkEdge( edges, a, b ) ) indices.push( a, b );
                if ( checkEdge( edges, b, c ) ) indices.push( b, c );
                if ( checkEdge( edges, c, a ) ) indices.push( c, a );

            }

        }
        else {

            var array = attributes.position.array;

            for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

                var a = i + 0;
                var b = i + 1;
                var c = i + 2;

                indices.push( a, b, b, c, c, a );

            }

        }

        // console.timeEnd( 'wireframe' );

        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

        updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

        property.wireframe = attribute;

        return attribute;

    }

    function checkEdge( edges, a, b ) {

        if ( a > b ) {

            var tmp = a;
            a = b;
            b = tmp;

        }

        var list = edges[ a ];

        if ( list === undefined ) {

            edges[ a ] = [ b ];
            return true;

        }
        else if ( list.indexOf( b ) === -1 ) {

            list.push( b );
            return true;

        }

        return false;

    }

    this.getAttributeBuffer = getAttributeBuffer;
    this.getWireframeAttribute = getWireframeAttribute;

    this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function() {

    var programIdCount = 0;

    function generateDefines( defines ) {

        var chunks = [];

        for ( var name in defines ) {

            var value = defines[ name ];

            if ( value === false ) continue;

            chunks.push( '#define ' + name + ' ' + value );

        }

        return chunks.join( '\n' );

    }

    function fetchUniformLocations( gl, program, identifiers ) {

        var uniforms = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

        for ( var i = 0; i < n; i++ ) {

            var info = gl.getActiveUniform( program, i );
            var name = info.name;
            var location = gl.getUniformLocation( program, name );

            // console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

            var suffixPos = name.lastIndexOf( '[0]' );
            if ( suffixPos !== -1 && suffixPos === name.length - 3 ) {

                uniforms[ name.substr( 0, suffixPos ) ] = location;

            }

            uniforms[ name ] = location;

        }

        return uniforms;

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

        var attributes = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

        for ( var i = 0; i < n; i++ ) {

            var info = gl.getActiveAttrib( program, i );
            var name = info.name;

            // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

            attributes[ name ] = gl.getAttribLocation( program, name );

        }

        return attributes;

    }

    function filterEmptyLine( string ) {

        return string !== '';

    }

    return function WebGLProgram( renderer, code, material, parameters ) {

        var gl = renderer.context;

        var defines = material.defines;

        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;

        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

        if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

        }
        else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

        }

        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

        if ( parameters.envMap ) {

            switch ( material.envMap.mapping ) {

                case THREE.CubeReflectionMapping:
                case THREE.CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;

                case THREE.EquirectangularReflectionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;

                case THREE.SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;

            }

            switch ( material.envMap.mapping ) {

                case THREE.CubeRefractionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;

            }

            switch ( material.combine ) {

                case THREE.MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;

                case THREE.MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;

                case THREE.AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;

            }

        }

        var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

        // console.log( 'building new program ' );

        //

        var customDefines = generateDefines( defines );

        //

        var program = gl.createProgram();

        var prefixVertex, prefixFragment;

        if ( material instanceof THREE.RawShaderMaterial ) {

            prefixVertex = '';
            prefixFragment = '';

        }
        else {

            prefixVertex = [

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                '#define MAX_BONES ' + parameters.maxBones,

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',

                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',

                '#ifdef USE_COLOR',

                '	attribute vec3 color;',

                '#endif',

                '#ifdef USE_MORPHTARGETS',

                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',

                '	#ifdef USE_MORPHNORMALS',

                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',

                '	#else',

                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',

                '	#endif',

                '#endif',

                '#ifdef USE_SKINNING',

                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',

                '#endif',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

            prefixFragment = [

                parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '', ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.metal ? '#define METAL' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

        }

        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;

        var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
        var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

        gl.attachShader( program, glVertexShader );
        gl.attachShader( program, glFragmentShader );

        // Force a particular attribute to index 0.

        if ( material.index0AttributeName !== undefined ) {

            gl.bindAttribLocation( program, 0, material.index0AttributeName );

        }
        else if ( parameters.morphTargets === true ) {

            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation( program, 0, 'position' );

        }

        gl.linkProgram( program );

        var programLog = gl.getProgramInfoLog( program );
        var vertexLog = gl.getShaderInfoLog( glVertexShader );
        var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

        var runnable = true;
        var haveDiagnostics = true;

        if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

            runnable = false;

            console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

        }
        else if ( programLog !== '' ) {

            console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

        }
        else if ( vertexLog === '' || fragmentLog === '' ) {

            haveDiagnostics = false;

        }

        if ( haveDiagnostics ) {

            this.diagnostics = {

                runnable: runnable,
                material: material,

                programLog: programLog,

                vertexShader: {

                    log: vertexLog,
                    prefix: prefixVertex

                },

                fragmentShader: {

                    log: fragmentLog,
                    prefix: prefixFragment

                }

            };

        }

        // clean up

        gl.deleteShader( glVertexShader );
        gl.deleteShader( glFragmentShader );

        // set up caching for uniform locations

        var cachedUniforms;

        this.getUniforms = function() {

            if ( cachedUniforms === undefined ) {

                cachedUniforms = fetchUniformLocations( gl, program );

            }

            return cachedUniforms;

        };

        // set up caching for attribute locations

        var cachedAttributes;

        this.getAttributes = function() {

            if ( cachedAttributes === undefined ) {

                cachedAttributes = fetchAttributeLocations( gl, program );

            }

            return cachedAttributes;

        };

        // free resource

        this.destroy = function() {

            gl.deleteProgram( program );
            this.program = undefined;

        };

        // DEPRECATED

        Object.defineProperties( this, {

            uniforms: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
                    return this.getUniforms();

                }
            },

            attributes: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
                    return this.getAttributes();

                }
            }

        } );


        //

        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;

        return this;

    };

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function( renderer, capabilities ) {

    var programs = [];

    var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
    };

    var parameterNames = [
        "precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
        "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "specularMap",
        "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
        "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
        "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
        "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
        "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled",
        "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
        "flipSided"
    ];


    function allocateBones( object ) {

        if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

            return 1024;

        }
        else {

            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)

            var nVertexUniforms = capabilities.maxVertexUniforms;
            var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

            var maxBones = nVertexMatrices;

            if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

                maxBones = Math.min( object.skeleton.bones.length, maxBones );

                if ( maxBones < object.skeleton.bones.length ) {

                    console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

                }

            }

            return maxBones;

        }

    }

    function allocateLights( lights ) {

        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;

        for ( var l = 0, ll = lights.length; l < ll; l++ ) {

            var light = lights[ l ];

            if ( light.onlyShadow || light.visible === false ) continue;

            if ( light instanceof THREE.DirectionalLight ) dirLights++;
            if ( light instanceof THREE.PointLight ) pointLights++;
            if ( light instanceof THREE.SpotLight ) spotLights++;
            if ( light instanceof THREE.HemisphereLight ) hemiLights++;

        }

        return {
            'directional': dirLights,
            'point': pointLights,
            'spot': spotLights,
            'hemi': hemiLights
        };

    }

    function allocateShadows( lights ) {

        var maxShadows = 0;

        for ( var l = 0, ll = lights.length; l < ll; l++ ) {

            var light = lights[ l ];

            if ( !light.castShadow ) continue;

            if ( light instanceof THREE.SpotLight ) maxShadows++;
            if ( light instanceof THREE.DirectionalLight ) maxShadows++;

        }

        return maxShadows;

    }

    this.getParameters = function( material, lights, fog, object ) {

        var shaderID = shaderIDs[ material.type ];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)

        var maxLightCount = allocateLights( lights );
        var maxShadows = allocateShadows( lights );
        var maxBones = allocateBones( object );
        var precision = renderer.getPrecision();

        if ( material.precision !== null ) {

            precision = capabilities.getMaxPrecision( material.precision );

            if ( precision !== material.precision ) {

                console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

            }

        }

        var parameters = {

            shaderID: shaderID,

            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,

            map: !!material.map,
            envMap: !!material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            displacementMap: !!material.displacementMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,

            combine: material.combine,

            vertexColors: material.vertexColors,

            fog: fog,
            useFog: material.fog,
            fogExp: fog instanceof THREE.FogExp2,

            flatShading: material.shading === THREE.FlatShading,

            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: renderer.logarithmicDepthBuffer,

            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,

            maxDirLights: maxLightCount.directional,
            maxPointLights: maxLightCount.point,
            maxSpotLights: maxLightCount.spot,
            maxHemiLights: maxLightCount.hemi,

            maxShadows: maxShadows,
            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && maxShadows > 0,
            shadowMapType: renderer.shadowMap.type,
            shadowMapDebug: renderer.shadowMap.debug,

            alphaTest: material.alphaTest,
            metal: material.metal,
            doubleSided: material.side === THREE.DoubleSide,
            flipSided: material.side === THREE.BackSide

        };

        return parameters;

    };

    this.getProgramCode = function( material, parameters ) {

        var chunks = [];

        if ( parameters.shaderID ) {

            chunks.push( parameters.shaderID );

        }
        else {

            chunks.push( material.fragmentShader );
            chunks.push( material.vertexShader );

        }

        if ( material.defines !== undefined ) {

            for ( var name in material.defines ) {

                chunks.push( name );
                chunks.push( material.defines[ name ] );

            }

        }

        for ( var i = 0; i < parameterNames.length; i++ ) {

            var parameterName = parameterNames[ i ];
            chunks.push( parameterName );
            chunks.push( parameters[ parameterName ] );

        }

        return chunks.join();

    };

    this.acquireProgram = function( material, parameters, code ) {

        var program;

        // Check if code has been already compiled
        for ( var p = 0, pl = programs.length; p < pl; p++ ) {

            var programInfo = programs[ p ];

            if ( programInfo.code === code ) {

                program = programInfo;
                ++program.usedTimes;

                break;

            }

        }

        if ( program === undefined ) {

            program = new THREE.WebGLProgram( renderer, code, material, parameters );
            programs.push( program );

        }

        return program;

    };

    this.releaseProgram = function( program ) {

        if ( --program.usedTimes === 0 ) {

            // Remove from unordered set
            var i = programs.indexOf( program );
            programs[ i ] = programs[ programs.length - 1 ];
            programs.pop();

            // Free WebGL resources
            program.destroy();

        }

    };

    // Exposed for resource monitoring & error feedback via renderer.info:
    this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
 * @author fordacious / fordacious.github.io
 */

THREE.WebGLProperties = function() {

    var properties = {};

    this.get = function( object ) {

        var uuid = object.uuid;
        var map = properties[ uuid ];

        if ( map === undefined ) {

            map = {};
            properties[ uuid ] = map;

        }

        return map;

    };

    this.delete = function( object ) {

        delete properties[ object.uuid ];

    };

    this.clear = function() {

        properties = {};

    };

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function() {

    var addLineNumbers = function( string ) {

        var lines = string.split( '\n' );

        for ( var i = 0; i < lines.length; i++ ) {

            lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

        }

        return lines.join( '\n' );

    };

    return function WebGLShader( gl, type, string ) {

        var shader = gl.createShader( type );

        gl.shaderSource( shader, string );
        gl.compileShader( shader );

        if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

            console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

        }

        if ( gl.getShaderInfoLog( shader ) !== '' ) {

            console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

        }

        // --enable-privileged-webgl-extension
        // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

        return shader;

    };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function( _renderer, _lights, _objects ) {

    var _gl = _renderer.context,
        _state = _renderer.state,
        _frustum = new THREE.Frustum(),
        _projScreenMatrix = new THREE.Matrix4(),

        _min = new THREE.Vector3(),
        _max = new THREE.Vector3(),

        _matrixPosition = new THREE.Vector3(),

        _renderList = [];

    // init

    var depthShader = THREE.ShaderLib[ "depthRGBA" ];
    var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

    var _depthMaterial = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader
    } );

    var _depthMaterialMorph = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true
    } );

    var _depthMaterialSkin = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        skinning: true
    } );

    var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true,
        skinning: true
    } );

    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;

    //

    var scope = this;

    this.enabled = false;

    this.autoUpdate = true;
    this.needsUpdate = false;

    this.type = THREE.PCFShadowMap;
    this.cullFace = THREE.CullFaceFront;

    this.render = function( scene, camera ) {

        if ( scope.enabled === false ) return;
        if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

        // set GL state for depth map

        _gl.clearColor( 1, 1, 1, 1 );
        _state.disable( _gl.BLEND );

        _state.enable( _gl.CULL_FACE );
        _gl.frontFace( _gl.CCW );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.FRONT );

        }
        else {

            _gl.cullFace( _gl.BACK );

        }

        _state.setDepthTest( true );

        // render depth map

        for ( var i = 0, il = _lights.length; i < il; i++ ) {

            var light = _lights[ i ];

            if ( !light.castShadow ) continue;

            if ( !light.shadowMap ) {

                var shadowFilter = THREE.LinearFilter;

                if ( scope.type === THREE.PCFSoftShadowMap ) {

                    shadowFilter = THREE.NearestFilter;

                }

                var pars = {
                    minFilter: shadowFilter,
                    magFilter: shadowFilter,
                    format: THREE.RGBAFormat
                };

                light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
                light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

                light.shadowMatrix = new THREE.Matrix4();

            }

            if ( !light.shadowCamera ) {

                if ( light instanceof THREE.SpotLight ) {

                    light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

                }
                else if ( light instanceof THREE.DirectionalLight ) {

                    light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

                }
                else {

                    console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
                    continue;

                }

                scene.add( light.shadowCamera );

                if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

            }

            if ( light.shadowCameraVisible && !light.cameraHelper ) {

                light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
                scene.add( light.cameraHelper );

            }

            var shadowMap = light.shadowMap;
            var shadowMatrix = light.shadowMatrix;
            var shadowCamera = light.shadowCamera;

            //

            shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
            _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
            shadowCamera.lookAt( _matrixPosition );
            shadowCamera.updateMatrixWorld();

            shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

            //

            if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
            if ( light.shadowCameraVisible ) light.cameraHelper.update();

            // compute shadow matrix

            shadowMatrix.set(
                0.5, 0.0, 0.0, 0.5,
                0.0, 0.5, 0.0, 0.5,
                0.0, 0.0, 0.5, 0.5,
                0.0, 0.0, 0.0, 1.0
            );

            shadowMatrix.multiply( shadowCamera.projectionMatrix );
            shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

            // update camera matrices and frustum

            _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
            _frustum.setFromMatrix( _projScreenMatrix );

            // render shadow map

            _renderer.setRenderTarget( shadowMap );
            _renderer.clear();

            // set object matrices & frustum culling

            _renderList.length = 0;

            projectObject( scene, shadowCamera );


            // render regular objects

            for ( var j = 0, jl = _renderList.length; j < jl; j++ ) {

                var object = _renderList[ j ];
                var geometry = _objects.update( object );
                var material = object.material;

                if ( material instanceof THREE.MeshFaceMaterial ) {

                    var groups = geometry.groups;
                    var materials = material.materials;

                    for ( var k = 0, kl = groups.length; k < kl; k++ ) {

                        var group = groups[ k ];
                        var groupMaterial = materials[ group.materialIndex ];

                        if ( groupMaterial.visible === true ) {

                            _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, groupMaterial ), object, group );

                        }

                    }

                }
                else {

                    _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, material ), object );

                }

            }

        }

        // restore GL state

        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();

        _renderer.setClearColor( clearColor, clearAlpha );
        _state.enable( _gl.BLEND );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.BACK );

        }

        _renderer.resetGLState();

        scope.needsUpdate = false;

    };

    function getDepthMaterial( object, material ) {

        var geometry = object.geometry;

        var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
        var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

        var depthMaterial;

        if ( object.customDepthMaterial ) {

            depthMaterial = object.customDepthMaterial;

        }
        else if ( useSkinning ) {

            depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

        }
        else if ( useMorphing ) {

            depthMaterial = _depthMaterialMorph;

        }
        else {

            depthMaterial = _depthMaterial;

        }

        depthMaterial.visible = material.visible;
        depthMaterial.wireframe = material.wireframe;
        depthMaterial.wireframeLinewidth = material.wireframeLinewidth;

        return depthMaterial;

    }

    function projectObject( object, camera ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

                var material = object.material;

                if ( material.visible === true ) {

                    object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
                    _renderList.push( object );

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            projectObject( children[ i ], camera );

        }

    }

};

// File:src/renderers/webgl/WebGLState.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLState = function( gl, extensions, paramThreeToGL ) {

    var _this = this;

    var newAttributes = new Uint8Array( 16 );
    var enabledAttributes = new Uint8Array( 16 );

    var capabilities = {};

    var compressedTextureFormats = null;

    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;

    var currentDepthFunc = null;
    var currentDepthWrite = null;

    var currentColorWrite = null;

    var currentFlipSided = null;

    var currentLineWidth = null;

    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;

    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    var currentTextureSlot = undefined;
    var currentBoundTextures = {};

    this.init = function() {

        gl.clearColor( 0, 0, 0, 1 );
        gl.clearDepth( 1 );
        gl.clearStencil( 0 );

        this.enable( gl.DEPTH_TEST );
        gl.depthFunc( gl.LEQUAL );

        gl.frontFace( gl.CCW );
        gl.cullFace( gl.BACK );
        this.enable( gl.CULL_FACE );

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

    };

    this.initAttributes = function() {

        for ( var i = 0, l = newAttributes.length; i < l; i++ ) {

            newAttributes[ i ] = 0;

        }

    };

    this.enableAttribute = function( attribute ) {

        newAttributes[ attribute ] = 1;

        if ( enabledAttributes[ attribute ] === 0 ) {

            gl.enableVertexAttribArray( attribute );
            enabledAttributes[ attribute ] = 1;

        }

    };

    this.disableUnusedAttributes = function() {

        for ( var i = 0, l = enabledAttributes.length; i < l; i++ ) {

            if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

    };

    this.enable = function( id ) {

        if ( capabilities[ id ] !== true ) {

            gl.enable( id );
            capabilities[ id ] = true;

        }

    };

    this.disable = function( id ) {

        if ( capabilities[ id ] !== false ) {

            gl.disable( id );
            capabilities[ id ] = false;

        }

    };

    this.getCompressedTextureFormats = function() {

        if ( compressedTextureFormats === null ) {

            compressedTextureFormats = [];

            if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
                extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

                var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

                for ( var i = 0; i < formats.length; i++ ) {

                    compressedTextureFormats.push( formats[ i ] );

                }

            }

        }

        return compressedTextureFormats;

    };

    this.setBlending = function( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

        if ( blending !== currentBlending ) {

            if ( blending === THREE.NoBlending ) {

                this.disable( gl.BLEND );

            }
            else if ( blending === THREE.AdditiveBlending ) {

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

            }
            else if ( blending === THREE.SubtractiveBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

            }
            else if ( blending === THREE.MultiplyBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

            }
            else if ( blending === THREE.CustomBlending ) {

                this.enable( gl.BLEND );

            }
            else {

                this.enable( gl.BLEND );
                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

            }

            currentBlending = blending;

        }

        if ( blending === THREE.CustomBlending ) {

            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;

            if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

                gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;

            }

            if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

                gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;

            }

        }
        else {

            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;

        }

    };

    this.setDepthFunc = function( depthFunc ) {

        if ( currentDepthFunc !== depthFunc ) {

            if ( depthFunc ) {

                switch ( depthFunc ) {

                    case THREE.NeverDepth:

                        gl.depthFunc( gl.NEVER );
                        break;

                    case THREE.AlwaysDepth:

                        gl.depthFunc( gl.ALWAYS );
                        break;

                    case THREE.LessDepth:

                        gl.depthFunc( gl.LESS );
                        break;

                    case THREE.LessEqualDepth:

                        gl.depthFunc( gl.LEQUAL );
                        break;

                    case THREE.EqualDepth:

                        gl.depthFunc( gl.EQUAL );
                        break;

                    case THREE.GreaterEqualDepth:

                        gl.depthFunc( gl.GEQUAL );
                        break;

                    case THREE.GreaterDepth:

                        gl.depthFunc( gl.GREATER );
                        break;

                    case THREE.NotEqualDepth:

                        gl.depthFunc( gl.NOTEQUAL );
                        break;

                    default:

                        gl.depthFunc( gl.LEQUAL );

                }

            }
            else {

                gl.depthFunc( gl.LEQUAL );

            }

            currentDepthFunc = depthFunc;

        }

    };

    this.setDepthTest = function( depthTest ) {

        if ( depthTest ) {

            this.enable( gl.DEPTH_TEST );

        }
        else {

            this.disable( gl.DEPTH_TEST );

        }

    };

    this.setDepthWrite = function( depthWrite ) {

        if ( currentDepthWrite !== depthWrite ) {

            gl.depthMask( depthWrite );
            currentDepthWrite = depthWrite;

        }

    };

    this.setColorWrite = function( colorWrite ) {

        if ( currentColorWrite !== colorWrite ) {

            gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
            currentColorWrite = colorWrite;

        }

    };

    this.setFlipSided = function( flipSided ) {

        if ( currentFlipSided !== flipSided ) {

            if ( flipSided ) {

                gl.frontFace( gl.CW );

            }
            else {

                gl.frontFace( gl.CCW );

            }

            currentFlipSided = flipSided;

        }

    };

    this.setLineWidth = function( width ) {

        if ( width !== currentLineWidth ) {

            gl.lineWidth( width );

            currentLineWidth = width;

        }

    };

    this.setPolygonOffset = function( polygonOffset, factor, units ) {

        if ( polygonOffset ) {

            this.enable( gl.POLYGON_OFFSET_FILL );

        }
        else {

            this.disable( gl.POLYGON_OFFSET_FILL );

        }

        if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

            gl.polygonOffset( factor, units );

            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;

        }

    };

    this.setScissorTest = function( scissorTest ) {

        if ( scissorTest ) {

            this.enable( gl.SCISSOR_TEST );

        }
        else {

            this.disable( gl.SCISSOR_TEST );

        }

    };

    // texture

    this.activeTexture = function( webglSlot ) {

        if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

        if ( currentTextureSlot !== webglSlot ) {

            gl.activeTexture( webglSlot );
            currentTextureSlot = webglSlot;

        }

    }

    this.bindTexture = function( webglType, webglTexture ) {

        if ( currentTextureSlot === undefined ) {

            _this.activeTexture();

        }

        var boundTexture = currentBoundTextures[ currentTextureSlot ];

        if ( boundTexture === undefined ) {

            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[ currentTextureSlot ] = boundTexture;

        }

        if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

            gl.bindTexture( webglType, webglTexture );

            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;

        }

    };

    this.compressedTexImage2D = function() {

        try {

            gl.compressedTexImage2D.apply( gl, arguments );

        }
        catch ( error ) {

            console.error( error );

        }

    };

    this.texImage2D = function() {

        try {

            gl.texImage2D.apply( gl, arguments );

        }
        catch ( error ) {

            console.error( error );

        }

    };

    //

    this.reset = function() {

        for ( var i = 0; i < enabledAttributes.length; i++ ) {

            if ( enabledAttributes[ i ] === 1 ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

        capabilities = {};

        compressedTextureFormats = null;

        currentBlending = null;

        currentDepthWrite = null;
        currentColorWrite = null;

        currentFlipSided = null;

    };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function( renderer, flares ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var hasVertexTexture;

    var tempTexture, occlusionTexture;

    var init = function() {

        var vertices = new Float32Array( [ -1, -1, 0, 0,
            1, -1, 1, 0,
            1, 1, 1, 1, -1, 1, 0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        // buffers

        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        // textures

        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();

        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

        var shader;

        if ( hasVertexTexture ) {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "uniform sampler2D occlusionMap;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if( renderType == 2 ) {",

                    "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

                    "vVisibility =        visibility.r / 9.0;",
                    "vVisibility *= 1.0 - visibility.g / 9.0;",
                    "vVisibility *=       visibility.b / 9.0;",
                    "vVisibility *= 1.0 - visibility.a / 9.0;",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    // pink square

                    "if( renderType == 0 ) {",

                    "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

                    // restore

                    "} else if( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * vVisibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }
        else {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if( renderType == 2 ) {",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "precision mediump float;",

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform sampler2D occlusionMap;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",

                    "void main() {",

                    // pink square

                    "if( renderType == 0 ) {",

                    "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

                    // restore

                    "} else if( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
                    "visibility = ( 1.0 - visibility / 4.0 );",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * visibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }

        program = createProgram( shader );

        attributes = {
            vertex: gl.getAttribLocation( program, "position" ),
            uv: gl.getAttribLocation( program, "uv" )
        };

        uniforms = {
            renderType: gl.getUniformLocation( program, "renderType" ),
            map: gl.getUniformLocation( program, "map" ),
            occlusionMap: gl.getUniformLocation( program, "occlusionMap" ),
            opacity: gl.getUniformLocation( program, "opacity" ),
            color: gl.getUniformLocation( program, "color" ),
            scale: gl.getUniformLocation( program, "scale" ),
            rotation: gl.getUniformLocation( program, "rotation" ),
            screenPosition: gl.getUniformLocation( program, "screenPosition" )
        };

    };

    /*
     * Render lens flares
     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
     *         reads these back and calculates occlusion.
     */

    this.render = function( scene, camera, viewportWidth, viewportHeight ) {

        if ( flares.length === 0 ) return;

        var tempPosition = new THREE.Vector3();

        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;

        var size = 16 / viewportHeight,
            scale = new THREE.Vector2( size * invAspect, size );

        var screenPosition = new THREE.Vector3( 1, 1, 0 ),
            screenPositionPixels = new THREE.Vector2( 1, 1 );

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.vertex );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        // loop through all lens flares to update their occlusion and positions
        // setup gl and common used attribs/uniforms

        gl.uniform1i( uniforms.occlusionMap, 0 );
        gl.uniform1i( uniforms.map, 1 );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        state.disable( gl.CULL_FACE );
        gl.depthMask( false );

        for ( var i = 0, l = flares.length; i < l; i++ ) {

            size = 16 / viewportHeight;
            scale.set( size * invAspect, size );

            // calc object screen position

            var flare = flares[ i ];

            tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

            tempPosition.applyMatrix4( camera.matrixWorldInverse );
            tempPosition.applyProjection( camera.projectionMatrix );

            // setup arrays for gl programs

            screenPosition.copy( tempPosition );

            screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
            screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

            // screen cull

            if ( hasVertexTexture || (
                screenPositionPixels.x > 0 &&
                screenPositionPixels.x < viewportWidth &&
                screenPositionPixels.y > 0 &&
                screenPositionPixels.y < viewportHeight ) ) {

                // save current RGB to temp texture

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, null );
                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // render pink quad

                gl.uniform1i( uniforms.renderType, 0 );
                gl.uniform2f( uniforms.scale, scale.x, scale.y );
                gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

                state.disable( gl.BLEND );
                state.enable( gl.DEPTH_TEST );

                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // copy result to occlusionMap

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // restore graphics

                gl.uniform1i( uniforms.renderType, 1 );
                state.disable( gl.DEPTH_TEST );

                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // update object positions

                flare.positionScreen.copy( screenPosition );

                if ( flare.customUpdateCallback ) {

                    flare.customUpdateCallback( flare );

                }
                else {

                    flare.updateLensFlares();

                }

                // render flares

                gl.uniform1i( uniforms.renderType, 2 );
                state.enable( gl.BLEND );

                for ( var j = 0, jl = flare.lensFlares.length; j < jl; j++ ) {

                    var sprite = flare.lensFlares[ j ];

                    if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;

                        size = sprite.size * sprite.scale / viewportHeight;

                        scale.x = size * invAspect;
                        scale.y = size;

                        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
                        gl.uniform2f( uniforms.scale, scale.x, scale.y );
                        gl.uniform1f( uniforms.rotation, sprite.rotation );

                        gl.uniform1f( uniforms.opacity, sprite.opacity );
                        gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

                        state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
                        renderer.setTexture( sprite.texture, 1 );

                        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

                    }

                }

            }

        }

        // restore gl

        state.enable( gl.CULL_FACE );
        state.enable( gl.DEPTH_TEST );
        gl.depthMask( true );

        renderer.resetGLState();

    };

    function createProgram( shader ) {

        var program = gl.createProgram();

        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
        var vertexShader = gl.createShader( gl.VERTEX_SHADER );

        var prefix = "precision " + renderer.getPrecision() + " float;\n";

        gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
        gl.shaderSource( vertexShader, prefix + shader.vertexShader );

        gl.compileShader( fragmentShader );
        gl.compileShader( vertexShader );

        gl.attachShader( program, fragmentShader );
        gl.attachShader( program, vertexShader );

        gl.linkProgram( program );

        return program;

    }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function( renderer, sprites ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;

    var texture;

    // decompose matrixWorld

    var spritePosition = new THREE.Vector3();
    var spriteRotation = new THREE.Quaternion();
    var spriteScale = new THREE.Vector3();

    var init = function() {

        var vertices = new Float32Array( [ -0.5, -0.5, 0, 0,
            0.5, -0.5, 1, 0,
            0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        program = createProgram();

        attributes = {
            position: gl.getAttribLocation( program, 'position' ),
            uv: gl.getAttribLocation( program, 'uv' )
        };

        uniforms = {
            uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
            uvScale: gl.getUniformLocation( program, 'uvScale' ),

            rotation: gl.getUniformLocation( program, 'rotation' ),
            scale: gl.getUniformLocation( program, 'scale' ),

            color: gl.getUniformLocation( program, 'color' ),
            map: gl.getUniformLocation( program, 'map' ),
            opacity: gl.getUniformLocation( program, 'opacity' ),

            modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
            projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

            fogType: gl.getUniformLocation( program, 'fogType' ),
            fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
            fogNear: gl.getUniformLocation( program, 'fogNear' ),
            fogFar: gl.getUniformLocation( program, 'fogFar' ),
            fogColor: gl.getUniformLocation( program, 'fogColor' ),

            alphaTest: gl.getUniformLocation( program, 'alphaTest' )
        };

        var canvas = document.createElement( 'canvas' );
        canvas.width = 8;
        canvas.height = 8;

        var context = canvas.getContext( '2d' );
        context.fillStyle = 'white';
        context.fillRect( 0, 0, 8, 8 );

        texture = new THREE.Texture( canvas );
        texture.needsUpdate = true;

    };

    this.render = function( scene, camera ) {

        if ( sprites.length === 0 ) return;

        // setup gl

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.position );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        state.disable( gl.CULL_FACE );
        state.enable( gl.BLEND );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

        state.activeTexture( gl.TEXTURE0 );
        gl.uniform1i( uniforms.map, 0 );

        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;

        if ( fog ) {

            gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

            if ( fog instanceof THREE.Fog ) {

                gl.uniform1f( uniforms.fogNear, fog.near );
                gl.uniform1f( uniforms.fogFar, fog.far );

                gl.uniform1i( uniforms.fogType, 1 );
                oldFogType = 1;
                sceneFogType = 1;

            }
            else if ( fog instanceof THREE.FogExp2 ) {

                gl.uniform1f( uniforms.fogDensity, fog.density );

                gl.uniform1i( uniforms.fogType, 2 );
                oldFogType = 2;
                sceneFogType = 2;

            }

        }
        else {

            gl.uniform1i( uniforms.fogType, 0 );
            oldFogType = 0;
            sceneFogType = 0;

        }


        // update positions and sort

        for ( var i = 0, l = sprites.length; i < l; i++ ) {

            var sprite = sprites[ i ];

            sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
            sprite.z = -sprite.modelViewMatrix.elements[ 14 ];

        }

        sprites.sort( painterSortStable );

        // render all sprites

        var scale = [];

        for ( var i = 0, l = sprites.length; i < l; i++ ) {

            var sprite = sprites[ i ];
            var material = sprite.material;

            gl.uniform1f( uniforms.alphaTest, material.alphaTest );
            gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

            sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

            scale[ 0 ] = spriteScale.x;
            scale[ 1 ] = spriteScale.y;

            var fogType = 0;

            if ( scene.fog && material.fog ) {

                fogType = sceneFogType;

            }

            if ( oldFogType !== fogType ) {

                gl.uniform1i( uniforms.fogType, fogType );
                oldFogType = fogType;

            }

            if ( material.map !== null ) {

                gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
                gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

            }
            else {

                gl.uniform2f( uniforms.uvOffset, 0, 0 );
                gl.uniform2f( uniforms.uvScale, 1, 1 );

            }

            gl.uniform1f( uniforms.opacity, material.opacity );
            gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

            gl.uniform1f( uniforms.rotation, material.rotation );
            gl.uniform2fv( uniforms.scale, scale );

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
            state.setDepthTest( material.depthTest );
            state.setDepthWrite( material.depthWrite );

            if ( material.map && material.map.image && material.map.image.width ) {

                renderer.setTexture( material.map, 0 );

            }
            else {

                renderer.setTexture( texture, 0 );

            }

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

        }

        // restore gl

        state.enable( gl.CULL_FACE );

        renderer.resetGLState();

    };

    function createProgram() {

        var program = gl.createProgram();

        var vertexShader = gl.createShader( gl.VERTEX_SHADER );
        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

        gl.shaderSource( vertexShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform float rotation;',
            'uniform vec2 scale;',
            'uniform vec2 uvOffset;',
            'uniform vec2 uvScale;',

            'attribute vec2 position;',
            'attribute vec2 uv;',

            'varying vec2 vUV;',

            'void main() {',

            'vUV = uvOffset + uv * uvScale;',

            'vec2 alignedPosition = position * scale;',

            'vec2 rotatedPosition;',
            'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
            'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

            'vec4 finalPosition;',

            'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
            'finalPosition.xy += rotatedPosition;',
            'finalPosition = projectionMatrix * finalPosition;',

            'gl_Position = finalPosition;',

            '}'

        ].join( '\n' ) );

        gl.shaderSource( fragmentShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform vec3 color;',
            'uniform sampler2D map;',
            'uniform float opacity;',

            'uniform int fogType;',
            'uniform vec3 fogColor;',
            'uniform float fogDensity;',
            'uniform float fogNear;',
            'uniform float fogFar;',
            'uniform float alphaTest;',

            'varying vec2 vUV;',

            'void main() {',

            'vec4 texture = texture2D( map, vUV );',

            'if ( texture.a < alphaTest ) discard;',

            'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

            'if ( fogType > 0 ) {',

            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
            'float fogFactor = 0.0;',

            'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

            '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

            '}',

            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

            '}',

            '}'

        ].join( '\n' ) );

        gl.compileShader( vertexShader );
        gl.compileShader( fragmentShader );

        gl.attachShader( program, vertexShader );
        gl.attachShader( program, fragmentShader );

        gl.linkProgram( program );

        return program;

    }

    function painterSortStable( a, b ) {

        if ( a.z !== b.z ) {

            return b.z - a.z;

        }
        else {

            return b.id - a.id;

        }

    }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

    merge: function( geometry1, geometry2, materialIndexOffset ) {

        console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

        var matrix;

        if ( geometry2 instanceof THREE.Mesh ) {

            geometry2.matrixAutoUpdate && geometry2.updateMatrix();

            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;

        }

        geometry1.merge( geometry2, matrix, materialIndexOffset );

    },

    center: function( geometry ) {

        console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
        return geometry.center();

    }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

    crossOrigin: undefined,

    loadTexture: function( url, mapping, onLoad, onError ) {

        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;

        var texture = new THREE.Texture( undefined, mapping );

        loader.load( url, function( image ) {

            texture.image = image;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

        }, undefined, function( event ) {

            if ( onError ) onError( event );

        } );

        texture.sourceFile = url;

        return texture;

    },

    loadTextureCube: function( array, mapping, onLoad, onError ) {

        var images = [];

        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;

        var texture = new THREE.CubeTexture( images, mapping );

        var loaded = 0;

        var loadTexture = function( i ) {

            loader.load( array[ i ], function( image ) {

                texture.images[ i ] = image;

                loaded += 1;

                if ( loaded === 6 ) {

                    texture.needsUpdate = true;

                    if ( onLoad ) onLoad( texture );

                }

            }, undefined, onError );

        };

        for ( var i = 0, il = array.length; i < il; ++i ) {

            loadTexture( i );

        }

        return texture;

    },

    loadCompressedTexture: function() {

        console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

    },

    loadCompressedTextureCube: function() {

        console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

    },

    getNormalMap: function( image, depth ) {

        // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

        var cross = function( a, b ) {

            return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

        };

        var subtract = function( a, b ) {

            return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

        };

        var normalize = function( a ) {

            var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
            return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

        };

        depth = depth | 1;

        var width = image.width;
        var height = image.height;

        var canvas = document.createElement( 'canvas' );
        canvas.width = width;
        canvas.height = height;

        var context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0 );

        var data = context.getImageData( 0, 0, width, height ).data;
        var imageData = context.createImageData( width, height );
        var output = imageData.data;

        for ( var x = 0; x < width; x++ ) {

            for ( var y = 0; y < height; y++ ) {

                var ly = y - 1 < 0 ? 0 : y - 1;
                var uy = y + 1 > height - 1 ? height - 1 : y + 1;
                var lx = x - 1 < 0 ? 0 : x - 1;
                var ux = x + 1 > width - 1 ? width - 1 : x + 1;

                var points = [];
                var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
                points.push( [ -1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
                points.push( [ -1, -1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
                points.push( [ 0, -1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
                points.push( [ 1, -1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
                points.push( [ -1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

                var normals = [];
                var num_points = points.length;

                for ( var i = 0; i < num_points; i++ ) {

                    var v1 = points[ i ];
                    var v2 = points[ ( i + 1 ) % num_points ];
                    v1 = subtract( v1, origin );
                    v2 = subtract( v2, origin );
                    normals.push( normalize( cross( v1, v2 ) ) );

                }

                var normal = [ 0, 0, 0 ];

                for ( var i = 0; i < normals.length; i++ ) {

                    normal[ 0 ] += normals[ i ][ 0 ];
                    normal[ 1 ] += normals[ i ][ 1 ];
                    normal[ 2 ] += normals[ i ][ 2 ];

                }

                normal[ 0 ] /= normals.length;
                normal[ 1 ] /= normals.length;
                normal[ 2 ] /= normals.length;

                var idx = ( y * width + x ) * 4;

                output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
                output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
                output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
                output[ idx + 3 ] = 255;

            }

        }

        context.putImageData( imageData, 0, 0 );

        return canvas;

    },

    generateDataTexture: function( width, height, color ) {

        var size = width * height;
        var data = new Uint8Array( 3 * size );

        var r = Math.floor( color.r * 255 );
        var g = Math.floor( color.g * 255 );
        var b = Math.floor( color.b * 255 );

        for ( var i = 0; i < size; i++ ) {

            data[ i * 3 ] = r;
            data[ i * 3 + 1 ] = g;
            data[ i * 3 + 2 ] = b;

        }

        var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
        texture.needsUpdate = true;

        return texture;

    }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

    createMultiMaterialObject: function( geometry, materials ) {

        var group = new THREE.Group();

        for ( var i = 0, l = materials.length; i < l; i++ ) {

            group.add( new THREE.Mesh( geometry, materials[ i ] ) );

        }

        return group;

    },

    detach: function( child, parent, scene ) {

        child.applyMatrix( parent.matrixWorld );
        parent.remove( child );
        scene.add( child );

    },

    attach: function( child, scene, parent ) {

        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse( parent.matrixWorld );
        child.applyMatrix( matrixWorldInverse );

        scene.remove( child );
        parent.add( child );

    }

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

    faces: {},

    // Just for now. face[weight][style]

    face: 'helvetiker',
    weight: 'normal',
    style: 'normal',
    size: 150,
    divisions: 10,

    getFace: function() {

        try {

            return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

        }
        catch ( e ) {

            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

        }

    },

    loadFace: function( data ) {

        var family = data.familyName.toLowerCase();

        var ThreeFont = this;

        ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

        ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        return data;

    },

    drawText: function( text ) {

        // RenderText

        var i,
            face = this.getFace(),
            scale = this.size / face.resolution,
            offset = 0,
            chars = String( text ).split( '' ),
            length = chars.length;

        var fontPaths = [];

        for ( i = 0; i < length; i++ ) {

            var path = new THREE.Path();

            var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
            offset += ret.offset;

            fontPaths.push( ret.path );

        }

        // get the width

        var width = offset / 2;
        //
        // for ( p = 0; p < allPts.length; p++ ) {
        //
        // 	allPts[ p ].x -= width;
        //
        // }

        //var extract = this.extractPoints( allPts, characterPts );
        //extract.contour = allPts;

        //extract.paths = fontPaths;
        //extract.offset = width;

        return {
            paths: fontPaths,
            offset: width
        };

    },




    extractGlyphPoints: function( c, face, scale, offset, path ) {

        var pts = [];

        var i, i2, divisions,
            outline, action, length,
            scaleX, scaleY,
            x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
            laste,
            glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

        if ( !glyph ) return;

        if ( glyph.o ) {

            outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
            length = outline.length;

            scaleX = scale;
            scaleY = scale;

            for ( i = 0; i < length; ) {

                action = outline[ i++ ];

                //console.log( action );

                switch ( action ) {

                    case 'm':

                        // Move To

                        x = outline[ i++ ] * scaleX + offset;
                        y = outline[ i++ ] * scaleY;

                        path.moveTo( x, y );
                        break;

                    case 'l':

                        // Line To

                        x = outline[ i++ ] * scaleX + offset;
                        y = outline[ i++ ] * scaleY;
                        path.lineTo( x, y );
                        break;

                    case 'q':

                        // QuadraticCurveTo

                        cpx = outline[ i++ ] * scaleX + offset;
                        cpy = outline[ i++ ] * scaleY;
                        cpx1 = outline[ i++ ] * scaleX + offset;
                        cpy1 = outline[ i++ ] * scaleY;

                        path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2++ ) {

                                var t = i2 / divisions;
                                THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
                                THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

                            }

                        }

                        break;

                    case 'b':

                        // Cubic Bezier Curve

                        cpx = outline[ i++ ] * scaleX + offset;
                        cpy = outline[ i++ ] * scaleY;
                        cpx1 = outline[ i++ ] * scaleX + offset;
                        cpy1 = outline[ i++ ] * scaleY;
                        cpx2 = outline[ i++ ] * scaleX + offset;
                        cpy2 = outline[ i++ ] * scaleY;

                        path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2++ ) {

                                var t = i2 / divisions;
                                THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
                                THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

                            }

                        }

                        break;

                }

            }

        }



        return {
            offset: glyph.ha * scale,
            path: path
        };

    }

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

    // Parameters

    parameters = parameters || {};

    var size = parameters.size !== undefined ? parameters.size : 100;
    var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

    var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
    var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
    var style = parameters.style !== undefined ? parameters.style : 'normal';

    THREE.FontUtils.size = size;
    THREE.FontUtils.divisions = curveSegments;

    THREE.FontUtils.face = font;
    THREE.FontUtils.weight = weight;
    THREE.FontUtils.style = style;

    // Get a Font data json object

    var data = THREE.FontUtils.drawText( text );

    var paths = data.paths;
    var shapes = [];

    for ( var p = 0, pl = paths.length; p < pl; p++ ) {

        Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    }

    return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

    var EPSILON = 0.0000000001;

    // takes in an contour array and returns

    var process = function( contour, indices ) {

        var n = contour.length;

        if ( n < 3 ) return null;

        var result = [],
            verts = [],
            vertIndices = [];

        /* we want a counter-clockwise polygon in verts */

        var u, v, w;

        if ( area( contour ) > 0.0 ) {

            for ( v = 0; v < n; v++ ) verts[ v ] = v;

        }
        else {

            for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

        }

        var nv = n;

        /*  remove nv - 2 vertices, creating 1 triangle every time */

        var count = 2 * nv; /* error detection */

        for ( v = nv - 1; nv > 2; ) {

            /* if we loop, it is probably a non-simple polygon */

            if ( ( count-- ) <= 0 ) {

                //** Triangulate: ERROR - probable bad polygon!

                //throw ( "Warning, unable to triangulate polygon!" );
                //return null;
                // Sometimes warning is fine, especially polygons are triangulated in reverse.
                console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

                if ( indices ) return vertIndices;
                return result;

            }

            /* three consecutive vertices in current polygon, <u,v,w> */

            u = v;
            if ( nv <= u ) u = 0; /* previous */
            v = u + 1;
            if ( nv <= v ) v = 0; /* new v    */
            w = v + 1;
            if ( nv <= w ) w = 0; /* next     */

            if ( snip( contour, u, v, w, nv, verts ) ) {

                var a, b, c, s, t;

                /* true names of the vertices */

                a = verts[ u ];
                b = verts[ v ];
                c = verts[ w ];

                /* output Triangle */

                result.push( [ contour[ a ],
                    contour[ b ],
                    contour[ c ]
                ] );


                vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

                /* remove v from the remaining polygon */

                for ( s = v, t = v + 1; t < nv; s++, t++ ) {

                    verts[ s ] = verts[ t ];

                }

                nv--;

                /* reset error detection counter */

                count = 2 * nv;

            }

        }

        if ( indices ) return vertIndices;
        return result;

    };

    // calculate area of the contour polygon

    var area = function( contour ) {

        var n = contour.length;
        var a = 0.0;

        for ( var p = n - 1, q = 0; q < n; p = q++ ) {

            a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

        }

        return a * 0.5;

    };

    var snip = function( contour, u, v, w, n, verts ) {

        var p;
        var ax, ay, bx, by;
        var cx, cy, px, py;

        ax = contour[ verts[ u ] ].x;
        ay = contour[ verts[ u ] ].y;

        bx = contour[ verts[ v ] ].x;
        by = contour[ verts[ v ] ].y;

        cx = contour[ verts[ w ] ].x;
        cy = contour[ verts[ w ] ].y;

        if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

        var aX, aY, bX, bY, cX, cY;
        var apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;

        aX = cx - bx;
        aY = cy - by;
        bX = ax - cx;
        bY = ay - cy;
        cX = bx - ax;
        cY = by - ay;

        for ( p = 0; p < n; p++ ) {

            px = contour[ verts[ p ] ].x;
            py = contour[ verts[ p ] ].y;

            if ( ( ( px === ax ) && ( py === ay ) ) ||
                ( ( px === bx ) && ( py === by ) ) ||
                ( ( px === cx ) && ( py === cy ) ) ) continue;

            apx = px - ax;
            apy = py - ay;
            bpx = px - bx;
            bpy = py - by;
            cpx = px - cx;
            cpy = py - cy;

            // see if p is inside triangle abc

            aCROSSbp = aX * bpy - aY * bpx;
            cCROSSap = cX * apy - cY * apx;
            bCROSScp = bX * cpy - bY * cpx;

            if ( ( aCROSSbp >= -EPSILON ) && ( bCROSScp >= -EPSILON ) && ( cCROSSap >= -EPSILON ) ) return false;

        }

        return true;

    };


    namespace.Triangulate = process;
    namespace.Triangulate.area = area;

    return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API

THREE.typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
};
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function( listener ) {

    THREE.Object3D.call( this );

    this.type = 'Audio';

    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind( this );

    this.gain = this.context.createGain();
    this.gain.connect( this.context.destination );

    this.panner = this.context.createPanner();
    this.panner.connect( this.gain );

    this.autoplay = false;

    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function( file ) {

    var scope = this;

    var request = new XMLHttpRequest();
    request.open( 'GET', file, true );
    request.responseType = 'arraybuffer';
    request.onload = function( e ) {

        scope.context.decodeAudioData( this.response, function( buffer ) {

            scope.source.buffer = buffer;

            if ( scope.autoplay ) scope.play();

        } );

    };
    request.send();

    return this;

};

THREE.Audio.prototype.play = function() {

    if ( this.isPlaying === true ) {

        console.warn( 'THREE.Audio: Audio is already playing.' );
        return;

    }

    var source = this.context.createBufferSource();

    source.buffer = this.source.buffer;
    source.loop = this.source.loop;
    source.onended = this.source.onended;
    source.start( 0, this.startTime );
    source.playbackRate.value = this.playbackRate;

    this.isPlaying = true;

    this.source = source;

    this.connect();

};

THREE.Audio.prototype.pause = function() {

    this.source.stop();
    this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function() {

    this.source.stop();
    this.startTime = 0;

};

THREE.Audio.prototype.connect = function() {

    if ( this.filter !== undefined ) {

        this.source.connect( this.filter );
        this.filter.connect( this.panner );

    }
    else {

        this.source.connect( this.panner );

    }

};

THREE.Audio.prototype.disconnect = function() {

    if ( this.filter !== undefined ) {

        this.source.disconnect( this.filter );
        this.filter.disconnect( this.panner );

    }
    else {

        this.source.disconnect( this.panner );

    }

};

THREE.Audio.prototype.setFilter = function( value ) {

    if ( this.isPlaying === true ) {

        this.disconnect();
        this.filter = value;
        this.connect();

    }
    else {

        this.filter = value;

    }

};

THREE.Audio.prototype.getFilter = function() {

    return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function( value ) {

    this.playbackRate = value;

    if ( this.isPlaying === true ) {

        this.source.playbackRate.value = this.playbackRate;

    }

};

THREE.Audio.prototype.getPlaybackRate = function() {

    return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

    this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function( value ) {

    this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function() {

    return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function( value ) {

    this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function() {

    return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function( value ) {

    this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function() {

    return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function( value ) {

    this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function() {

    return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function() {

    var position = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        position.setFromMatrixPosition( this.matrixWorld );

        this.panner.setPosition( position.x, position.y, position.z );

    };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function() {

    THREE.Object3D.call( this );

    this.type = 'AudioListener';

    this.context = new( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function() {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();

    var orientation = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        var listener = this.context.listener;
        var up = this.up;

        this.matrixWorld.decompose( position, quaternion, scale );

        orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );

        listener.setPosition( position.x, position.y, position.z );
        listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function() {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function( t ) {

    console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function( u ) {

    var t = this.getUtoTmapping( u );
    return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function( divisions ) {

    if ( !divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d++ ) {

        pts.push( this.getPoint( d / divisions ) );

    }

    return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function( divisions ) {

    if ( !divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d++ ) {

        pts.push( this.getPointAt( d / divisions ) );

    }

    return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function() {

    var lengths = this.getLengths();
    return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function( divisions ) {

    if ( !divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    if ( this.cacheArcLengths && ( this.cacheArcLengths.length === divisions + 1 ) && !this.needsUpdate ) {

        //console.log( "cached", this.cacheArcLengths );
        return this.cacheArcLengths;

    }

    this.needsUpdate = false;

    var cache = [];
    var current, last = this.getPoint( 0 );
    var p, sum = 0;

    cache.push( 0 );

    for ( p = 1; p <= divisions; p++ ) {

        current = this.getPoint( p / divisions );
        sum += current.distanceTo( last );
        cache.push( sum );
        last = current;

    }

    this.cacheArcLengths = cache;

    return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {

    this.needsUpdate = true;
    this.getLengths();

};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

THREE.Curve.prototype.getUtoTmapping = function( u, distance ) {

    var arcLengths = this.getLengths();

    var i = 0,
        il = arcLengths.length;

    var targetArcLength; // The targeted u distance value to get

    if ( distance ) {

        targetArcLength = distance;

    }
    else {

        targetArcLength = u * arcLengths[ il - 1 ];

    }

    //var time = Date.now();

    // binary search for the index with largest value smaller than target u distance

    var low = 0,
        high = il - 1,
        comparison;

    while ( low <= high ) {

        i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

        comparison = arcLengths[ i ] - targetArcLength;

        if ( comparison < 0 ) {

            low = i + 1;

        }
        else if ( comparison > 0 ) {

            high = i - 1;

        }
        else {

            high = i;
            break;

            // DONE

        }

    }

    i = high;

    //console.log('b' , i, low, high, Date.now()- time);

    if ( arcLengths[ i ] === targetArcLength ) {

        var t = i / ( il - 1 );
        return t;

    }

    // we could get finer grain at lengths, or use simple interpolation between two points

    var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il - 1 );

    return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

    var delta = 0.0001;
    var t1 = t - delta;
    var t2 = t + delta;

    // Capping in case of danger

    if ( t1 < 0 ) t1 = 0;
    if ( t2 > 1 ) t2 = 1;

    var pt1 = this.getPoint( t1 );
    var pt2 = this.getPoint( t2 );

    var vec = pt2.clone().sub( pt1 );
    return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function( u ) {

    var t = this.getUtoTmapping( u );
    return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

    tangentQuadraticBezier: function( t, p0, p1, p2 ) {

        return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    },

    // Puay Bing, thanks for helping with this derivative!

    tangentCubicBezier: function( t, p0, p1, p2, p3 ) {

        return -3 * p0 * ( 1 - t ) * ( 1 - t ) +
            3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
            6 * t * p2 * ( 1 - t ) - 3 * t * t * p2 +
            3 * t * t * p3;

    },

    tangentSpline: function( t, p0, p1, p2, p3 ) {

        // To check if my formulas are correct

        var h00 = 6 * t * t - 6 * t; // derived from 2t^3 − 3t^2 + 1
        var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
        var h01 = -6 * t * t + 6 * t; // − 2t3 + 3t2
        var h11 = 3 * t * t - 2 * t; // t3 − t2

        return h00 + h10 + h01 + h11;

    },

    // Catmull-Rom

    interpolate: function( p0, p1, p2, p3, t ) {

        var v0 = ( p2 - p0 ) * 0.5;
        var v1 = ( p3 - p1 ) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function( constructor, getPointFunc ) {

    constructor.prototype = Object.create( THREE.Curve.prototype );
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;

    return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function() {

    this.curves = [];
    this.bends = [];

    this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function( curve ) {

    this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
    // TODO
    // If the ending of curve is not connected to the starting
    // or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {

    // TODO Test
    // and verify for vector3 (needs to implement equals)
    // Add a line curve if start and end of lines are not connected
    var startPoint = this.curves[ 0 ].getPoint( 0 );
    var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    if ( !startPoint.equals( endPoint ) ) {

        this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

    }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0,
        diff, curve;

    // To think about boundaries points.

    while ( i < curveLengths.length ) {

        if ( curveLengths[ i ] >= d ) {

            diff = curveLengths[ i ] - d;
            curve = this.curves[ i ];

            var u = 1 - diff / curve.getLength();

            return curve.getPointAt( u );

        }

        i++;

    }

    return null;

    // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

    var lens = this.getCurveLengths();
    return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

    // We use cache values if curves and cache array are same length

    if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

        return this.cacheLengths;

    }

    // Get length of sub-curve
    // Push sums into cached array

    var lengths = [],
        sums = 0;
    var i, il = this.curves.length;

    for ( i = 0; i < il; i++ ) {

        sums += this.curves[ i ].getLength();
        lengths.push( sums );

    }

    this.cacheLengths = lengths;

    return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function() {

    var points = this.getPoints();

    var maxX, maxY, maxZ;
    var minX, minY, minZ;

    maxX = maxY = Number.NEGATIVE_INFINITY;
    minX = minY = Number.POSITIVE_INFINITY;

    var p, i, il, sum;

    var v3 = points[ 0 ] instanceof THREE.Vector3;

    sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

    for ( i = 0, il = points.length; i < il; i++ ) {

        p = points[ i ];

        if ( p.x > maxX ) maxX = p.x;
        else if ( p.x < minX ) minX = p.x;

        if ( p.y > maxY ) maxY = p.y;
        else if ( p.y < minY ) minY = p.y;

        if ( v3 ) {

            if ( p.z > maxZ ) maxZ = p.z;
            else if ( p.z < minZ ) minZ = p.z;

        }

        sum.add( p );

    }

    var ret = {

        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY

    };

    if ( v3 ) {

        ret.maxZ = maxZ;
        ret.minZ = minZ;

    }

    return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

    var pts = this.getPoints( divisions, true );
    return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

    var pts = this.getSpacedPoints( divisions, true );
    return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < points.length; i++ ) {

        geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0 ) );

    }

    return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function( bendpath ) {

    this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

    var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
    var i, il;

    if ( !bends ) {

        bends = this.bends;

    }

    for ( i = 0, il = bends.length; i < il; i++ ) {

        oldPts = this.getWrapPoints( oldPts, bends[ i ] );

    }

    return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

    var oldPts = this.getSpacedPoints( segments );

    var i, il;

    if ( !bends ) {

        bends = this.bends;

    }

    for ( i = 0, il = bends.length; i < il; i++ ) {

        oldPts = this.getWrapPoints( oldPts, bends[ i ] );

    }

    return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function( oldPts, path ) {

    var bounds = this.getBoundingBox();

    var i, il, p, oldX, oldY, xNorm;

    for ( i = 0, il = oldPts.length; i < il; i++ ) {

        p = oldPts[ i ];

        oldX = p.x;
        oldY = p.y;

        xNorm = oldX / bounds.maxX;

        // If using actual distance, for length > path, requires line extrusions
        //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

        xNorm = path.getUtoTmapping( xNorm, oldX );

        // check for out of bounds?

        var pathPt = path.getPoint( xNorm );
        var normal = path.getTangent( xNorm );
        normal.set( -normal.y, normal.x ).multiplyScalar( oldY );

        p.x = pathPt.x + normal.x;
        p.y = pathPt.y + normal.y;

    }

    return oldPts;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function( points ) {

    THREE.CurvePath.call( this );

    this.actions = [];

    if ( points ) {

        this.fromPoints( points );

    }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {

    MOVE_TO: 'moveTo',
    LINE_TO: 'lineTo',
    QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
    BEZIER_CURVE_TO: 'bezierCurveTo', // Bezier cubic curve
    CSPLINE_THRU: 'splineThru', // Catmull-Rom spline
    ARC: 'arc', // Circle
    ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function( vectors ) {

    this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    for ( var v = 1, vlen = vectors.length; v < vlen; v++ ) {

        this.lineTo( vectors[ v ].x, vectors[ v ].y );

    }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function( x, y ) {

    var args = Array.prototype.slice.call( arguments );
    this.actions.push( {
        action: THREE.PathActions.MOVE_TO,
        args: args
    } );

};

THREE.Path.prototype.lineTo = function( x, y ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.LINE_TO,
        args: args
    } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCPx, aCPy ),
        new THREE.Vector2( aX, aY ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: args
    } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
    aCP2x, aCP2y,
    aX, aY ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCP1x, aCP1y ),
        new THREE.Vector2( aCP2x, aCP2y ),
        new THREE.Vector2( aX, aY ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: args
    } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

    var args = Array.prototype.slice.call( arguments );
    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];
    //---
    var npts = [ new THREE.Vector2( x0, y0 ) ];
    Array.prototype.push.apply( npts, pts );

    var curve = new THREE.SplineCurve( npts );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.CSPLINE_THRU,
        args: args
    } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function( aX, aY, aRadius,
    aStartAngle, aEndAngle, aClockwise ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absarc( aX + x0, aY + y0, aRadius,
        aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.absarc = function( aX, aY, aRadius,
    aStartAngle, aEndAngle, aClockwise ) {

    this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.ellipse = function( aX, aY, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absellipse( aX + x0, aY + y0, xRadius, yRadius,
        aStartAngle, aEndAngle, aClockwise, aRotation );

};


THREE.Path.prototype.absellipse = function( aX, aY, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var args = [
        aX, aY,
        xRadius, yRadius,
        aStartAngle, aEndAngle,
        aClockwise,
        aRotation || 0 // aRotation is optional.
    ];
    var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
        aStartAngle, aEndAngle, aClockwise, aRotation );
    this.curves.push( curve );

    var lastPoint = curve.getPoint( 1 );
    args.push( lastPoint.x );
    args.push( lastPoint.y );

    this.actions.push( {
        action: THREE.PathActions.ELLIPSE,
        args: args
    } );

};

THREE.Path.prototype.getSpacedPoints = function( divisions, closedPath ) {

    if ( !divisions ) divisions = 40;

    var points = [];

    for ( var i = 0; i < divisions; i++ ) {

        points.push( this.getPoint( i / divisions ) );

        //if( !this.getPoint( i / divisions ) ) throw "DIE";

    }

    // if ( closedPath ) {
    //
    // 	points.push( points[ 0 ] );
    //
    // }

    return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

    if ( this.useSpacedPoints ) {

        return this.getSpacedPoints( divisions, closedPath );

    }

    divisions = divisions || 12;

    var points = [];

    var i, il, item, action, args;
    var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
        laste, j,
        t, tx, ty;

    for ( i = 0, il = this.actions.length; i < il; i++ ) {

        item = this.actions[ i ];

        action = item.action;
        args = item.args;

        switch ( action ) {

            case THREE.PathActions.MOVE_TO:

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case THREE.PathActions.LINE_TO:

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case THREE.PathActions.QUADRATIC_CURVE_TO:

                cpx = args[ 2 ];
                cpy = args[ 3 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                }
                else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }

                for ( j = 1; j <= divisions; j++ ) {

                    t = j / divisions;

                    tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
                    ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case THREE.PathActions.BEZIER_CURVE_TO:

                cpx = args[ 4 ];
                cpy = args[ 5 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                cpx2 = args[ 2 ];
                cpy2 = args[ 3 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                }
                else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }


                for ( j = 1; j <= divisions; j++ ) {

                    t = j / divisions;

                    tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
                    ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case THREE.PathActions.CSPLINE_THRU:

                laste = this.actions[ i - 1 ].args;

                var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
                var spts = [ last ];

                var n = divisions * args[ 0 ].length;

                spts = spts.concat( args[ 0 ] );

                var spline = new THREE.SplineCurve( spts );

                for ( j = 1; j <= n; j++ ) {

                    points.push( spline.getPointAt( j / n ) );

                }

                break;

            case THREE.PathActions.ARC:

                var aX = args[ 0 ],
                    aY = args[ 1 ],
                    aRadius = args[ 2 ],
                    aStartAngle = args[ 3 ],
                    aEndAngle = args[ 4 ],
                    aClockwise = !!args[ 5 ];

                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                for ( j = 1; j <= tdivisions; j++ ) {

                    t = j / tdivisions;

                    if ( !aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + aRadius * Math.cos( angle );
                    ty = aY + aRadius * Math.sin( angle );

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

            case THREE.PathActions.ELLIPSE:

                var aX = args[ 0 ],
                    aY = args[ 1 ],
                    xRadius = args[ 2 ],
                    yRadius = args[ 3 ],
                    aStartAngle = args[ 4 ],
                    aEndAngle = args[ 5 ],
                    aClockwise = !!args[ 6 ],
                    aRotation = args[ 7 ];


                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                var cos, sin;
                if ( aRotation !== 0 ) {

                    cos = Math.cos( aRotation );
                    sin = Math.sin( aRotation );

                }

                for ( j = 1; j <= tdivisions; j++ ) {

                    t = j / tdivisions;

                    if ( !aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + xRadius * Math.cos( angle );
                    ty = aY + yRadius * Math.sin( angle );

                    if ( aRotation !== 0 ) {

                        var x = tx,
                            y = ty;

                        // Rotate the point about the center of the ellipse.
                        tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
                        ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

                    }

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

        } // end switch

    }



    // Normalize to remove the closing point by default.
    var lastPoint = points[ points.length - 1 ];
    var EPSILON = 0.0000000001;
    if ( Math.abs( lastPoint.x - points[ 0 ].x ) < EPSILON &&
        Math.abs( lastPoint.y - points[ 0 ].y ) < EPSILON )
        points.splice( points.length - 1, 1 );
    if ( closedPath ) {

        points.push( points[ 0 ] );

    }

    return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

    function extractSubpaths( inActions ) {

        var i, il, item, action, args;

        var subPaths = [],
            lastPath = new THREE.Path();

        for ( i = 0, il = inActions.length; i < il; i++ ) {

            item = inActions[ i ];

            args = item.args;
            action = item.action;

            if ( action === THREE.PathActions.MOVE_TO ) {

                if ( lastPath.actions.length !== 0 ) {

                    subPaths.push( lastPath );
                    lastPath = new THREE.Path();

                }

            }

            lastPath[ action ].apply( lastPath, args );

        }

        if ( lastPath.actions.length !== 0 ) {

            subPaths.push( lastPath );

        }

        // console.log(subPaths);

        return subPaths;

    }

    function toShapesNoHoles( inSubpaths ) {

        var shapes = [];

        for ( var i = 0, il = inSubpaths.length; i < il; i++ ) {

            var tmpPath = inSubpaths[ i ];

            var tmpShape = new THREE.Shape();
            tmpShape.actions = tmpPath.actions;
            tmpShape.curves = tmpPath.curves;

            shapes.push( tmpShape );

        }

        //console.log("shape", shapes);

        return shapes;

    }

    function isPointInsidePolygon( inPt, inPolygon ) {

        var EPSILON = 0.0000000001;

        var polyLen = inPolygon.length;

        // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line
        var inside = false;
        for ( var p = polyLen - 1, q = 0; q < polyLen; p = q++ ) {

            var edgeLowPt = inPolygon[ p ];
            var edgeHighPt = inPolygon[ q ];

            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;

            if ( Math.abs( edgeDy ) > EPSILON ) {

                // not parallel
                if ( edgeDy < 0 ) {

                    edgeLowPt = inPolygon[ q ];
                    edgeDx = -edgeDx;
                    edgeHighPt = inPolygon[ p ];
                    edgeDy = -edgeDy;

                }
                if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) continue;

                if ( inPt.y === edgeLowPt.y ) {

                    if ( inPt.x === edgeLowPt.x ) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!

                }
                else {

                    var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
                    if ( perpEdge === 0 ) return true; // inPt is on contour ?
                    if ( perpEdge < 0 ) continue;
                    inside = !inside; // true intersection left of inPt

                }

            }
            else {

                // parallel or collinear
                if ( inPt.y !== edgeLowPt.y ) continue; // parallel
                // edge lies on the same horizontal line as inPt
                if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
                    ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) ) return true; // inPt: Point on contour !
                // continue;

            }

        }

        return inside;

    }


    var subPaths = extractSubpaths( this.actions );
    if ( subPaths.length === 0 ) return [];

    if ( noHoles === true ) return toShapesNoHoles( subPaths );


    var solid, tmpPath, tmpShape, shapes = [];

    if ( subPaths.length === 1 ) {

        tmpPath = subPaths[ 0 ];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push( tmpShape );
        return shapes;

    }

    var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
    holesFirst = isCCW ? !holesFirst : holesFirst;

    // console.log("Holes first", holesFirst);

    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;

    newShapes[ mainIdx ] = undefined;
    newShapeHoles[ mainIdx ] = [];

    var i, il;

    for ( i = 0, il = subPaths.length; i < il; i++ ) {

        tmpPath = subPaths[ i ];
        tmpPoints = tmpPath.getPoints();
        solid = THREE.Shape.Utils.isClockWise( tmpPoints );
        solid = isCCW ? !solid : solid;

        if ( solid ) {

            if ( ( !holesFirst ) && ( newShapes[ mainIdx ] ) ) mainIdx++;

            newShapes[ mainIdx ] = {
                s: new THREE.Shape(),
                p: tmpPoints
            };
            newShapes[ mainIdx ].s.actions = tmpPath.actions;
            newShapes[ mainIdx ].s.curves = tmpPath.curves;

            if ( holesFirst ) mainIdx++;
            newShapeHoles[ mainIdx ] = [];

            //console.log('cw', i);

        }
        else {

            newShapeHoles[ mainIdx ].push( {
                h: tmpPath,
                p: tmpPoints[ 0 ]
            } );

            //console.log('ccw', i);

        }

    }

    // only Holes? -> probably all Shapes with wrong orientation
    if ( !newShapes[ 0 ] ) return toShapesNoHoles( subPaths );


    if ( newShapes.length > 1 ) {

        var ambiguous = false;
        var toChange = [];

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {

            betterShapeHoles[ sIdx ] = [];

        }
        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {

            var sho = newShapeHoles[ sIdx ];
            for ( var hIdx = 0; hIdx < sho.length; hIdx++ ) {

                var ho = sho[ hIdx ];
                var hole_unassigned = true;
                for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx++ ) {

                    if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

                        if ( sIdx !== s2Idx ) toChange.push( {
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        } );
                        if ( hole_unassigned ) {

                            hole_unassigned = false;
                            betterShapeHoles[ s2Idx ].push( ho );

                        }
                        else {

                            ambiguous = true;

                        }

                    }

                }
                if ( hole_unassigned ) {

                    betterShapeHoles[ sIdx ].push( ho );

                }

            }

        }
        // console.log("ambiguous: ", ambiguous);
        if ( toChange.length > 0 ) {

            // console.log("to change: ", toChange);
            if ( !ambiguous ) newShapeHoles = betterShapeHoles;

        }

    }

    var tmpHoles, j, jl;
    for ( i = 0, il = newShapes.length; i < il; i++ ) {

        tmpShape = newShapes[ i ].s;
        shapes.push( tmpShape );
        tmpHoles = newShapeHoles[ i ];
        for ( j = 0, jl = tmpHoles.length; j < jl; j++ ) {

            tmpShape.holes.push( tmpHoles[ j ].h );

        }

    }

    //console.log("shape", shapes);

    return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function() {

    THREE.Path.apply( this, arguments );
    this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function( options ) {

    var extruded = new THREE.ExtrudeGeometry( this, options );
    return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function( options ) {

    var geometry = new THREE.ShapeGeometry( this, options );
    return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function( divisions ) {

    var i, il = this.holes.length,
        holesPts = [];

    for ( i = 0; i < il; i++ ) {

        holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

    }

    return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function( divisions ) {

    var i, il = this.holes.length,
        holesPts = [];

    for ( i = 0; i < il; i++ ) {

        holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

    }

    return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function( divisions ) {

    return {

        shape: this.getTransformedPoints( divisions ),
        holes: this.getPointsHoles( divisions )

    };

};

THREE.Shape.prototype.extractPoints = function( divisions ) {

    if ( this.useSpacedPoints ) {

        return this.extractAllSpacedPoints( divisions );

    }

    return this.extractAllPoints( divisions );

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function( divisions ) {

    return {

        shape: this.getTransformedSpacedPoints( divisions ),
        holes: this.getSpacedPointsHoles( divisions )

    };

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

    triangulateShape: function( contour, holes ) {

        function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

            // inOtherPt needs to be collinear to the inSegment
            if ( inSegPt1.x !== inSegPt2.x ) {

                if ( inSegPt1.x < inSegPt2.x ) {

                    return ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

                }
                else {

                    return ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

                }

            }
            else {

                if ( inSegPt1.y < inSegPt2.y ) {

                    return ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

                }
                else {

                    return ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

                }

            }

        }

        function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

            var EPSILON = 0.0000000001;

            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
                seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
                seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

            var limit = seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

            if ( Math.abs( limit ) > EPSILON ) {

                // not parallel

                var perpSeg2;
                if ( limit > 0 ) {

                    if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) return [];

                }
                else {

                    if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) return [];

                }

                // i.e. to reduce rounding errors
                // intersection at endpoint of segment#1?
                if ( perpSeg2 === 0 ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) ) return [];
                    return [ inSeg1Pt1 ];

                }
                if ( perpSeg2 === limit ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) ) return [];
                    return [ inSeg1Pt2 ];

                }
                // intersection at endpoint of segment#2?
                if ( perpSeg1 === 0 ) return [ inSeg2Pt1 ];
                if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

                // return real intersection point
                var factorSeg1 = perpSeg2 / limit;
                return [ {
                    x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                    y: inSeg1Pt1.y + factorSeg1 * seg1dy
                } ];

            }
            else {

                // parallel or collinear
                if ( ( perpSeg1 !== 0 ) ||
                    ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) return [];

                // they are collinear or degenerate
                var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) ); // segment1 is just a point?
                var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) ); // segment2 is just a point?
                // both segments are points
                if ( seg1Pt && seg2Pt ) {

                    if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
                        ( inSeg1Pt1.y !== inSeg2Pt1.y ) ) return []; // they are distinct  points
                    return [ inSeg1Pt1 ]; // they are the same point

                }
                // segment#1  is a single point
                if ( seg1Pt ) {

                    if ( !point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) ) return []; // but not in segment#2
                    return [ inSeg1Pt1 ];

                }
                // segment#2  is a single point
                if ( seg2Pt ) {

                    if ( !point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) ) return []; // but not in segment#1
                    return [ inSeg2Pt1 ];

                }

                // they are collinear segments, which might overlap
                var seg1min, seg1max, seg1minVal, seg1maxVal;
                var seg2min, seg2max, seg2minVal, seg2maxVal;
                if ( seg1dx !== 0 ) {

                    // the segments are NOT on a vertical line
                    if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.x;

                    }
                    else {

                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.x;

                    }
                    if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.x;

                    }
                    else {

                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.x;

                    }

                }
                else {

                    // the segments are on a vertical line
                    if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.y;

                    }
                    else {

                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.y;

                    }
                    if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.y;

                    }
                    else {

                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.y;

                    }

                }
                if ( seg1minVal <= seg2minVal ) {

                    if ( seg1maxVal < seg2minVal ) return [];
                    if ( seg1maxVal === seg2minVal ) {

                        if ( inExcludeAdjacentSegs ) return [];
                        return [ seg2min ];

                    }
                    if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
                    return [ seg2min, seg2max ];

                }
                else {

                    if ( seg1minVal > seg2maxVal ) return [];
                    if ( seg1minVal === seg2maxVal ) {

                        if ( inExcludeAdjacentSegs ) return [];
                        return [ seg1min ];

                    }
                    if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
                    return [ seg1min, seg2max ];

                }

            }

        }

        function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

            // The order of legs is important

            var EPSILON = 0.0000000001;

            // translation of all points, so that Vertex is at (0,0)
            var legFromPtX = inLegFromPt.x - inVertex.x,
                legFromPtY = inLegFromPt.y - inVertex.y;
            var legToPtX = inLegToPt.x - inVertex.x,
                legToPtY = inLegToPt.y - inVertex.y;
            var otherPtX = inOtherPt.x - inVertex.x,
                otherPtY = inOtherPt.y - inVertex.y;

            // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
            var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

            if ( Math.abs( from2toAngle ) > EPSILON ) {

                // angle != 180 deg.

                var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

                if ( from2toAngle > 0 ) {

                    // main angle < 180 deg.
                    return ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

                }
                else {

                    // main angle > 180 deg.
                    return ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

                }

            }
            else {

                // angle == 180 deg.
                // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                return ( from2otherAngle > 0 );

            }

        }


        function removeHoles( contour, holes ) {

            var shape = contour.concat(); // work on this shape
            var hole;

            function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

                // Check if hole point lies within angle around shape point
                var lastShapeIdx = shape.length - 1;

                var prevShapeIdx = inShapeIdx - 1;
                if ( prevShapeIdx < 0 ) prevShapeIdx = lastShapeIdx;

                var nextShapeIdx = inShapeIdx + 1;
                if ( nextShapeIdx > lastShapeIdx ) nextShapeIdx = 0;

                var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
                if ( !insideAngle ) {

                    // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                    return false;

                }

                // Check if shape point lies within angle around hole point
                var lastHoleIdx = hole.length - 1;

                var prevHoleIdx = inHoleIdx - 1;
                if ( prevHoleIdx < 0 ) prevHoleIdx = lastHoleIdx;

                var nextHoleIdx = inHoleIdx + 1;
                if ( nextHoleIdx > lastHoleIdx ) nextHoleIdx = 0;

                insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
                if ( !insideAngle ) {

                    // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
                    return false;

                }

                return true;

            }

            function intersectsShapeEdge( inShapePt, inHolePt ) {

                // checks for intersections with shape edges
                var sIdx, nextIdx, intersection;
                for ( sIdx = 0; sIdx < shape.length; sIdx++ ) {

                    nextIdx = sIdx + 1;
                    nextIdx %= shape.length;
                    intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
                    if ( intersection.length > 0 ) return true;

                }

                return false;

            }

            var indepHoles = [];

            function intersectsHoleEdge( inShapePt, inHolePt ) {

                // checks for intersections with hole edges
                var ihIdx, chkHole,
                    hIdx, nextIdx, intersection;
                for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx++ ) {

                    chkHole = holes[ indepHoles[ ihIdx ] ];
                    for ( hIdx = 0; hIdx < chkHole.length; hIdx++ ) {

                        nextIdx = hIdx + 1;
                        nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
                        if ( intersection.length > 0 ) return true;

                    }

                }
                return false;

            }

            var holeIndex, shapeIndex,
                shapePt, holePt,
                holeIdx, cutKey, failedCuts = [],
                tmpShape1, tmpShape2,
                tmpHole1, tmpHole2;

            for ( var h = 0, hl = holes.length; h < hl; h++ ) {

                indepHoles.push( h );

            }

            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while ( indepHoles.length > 0 ) {

                counter--;
                if ( counter < 0 ) {

                    console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
                    break;

                }

                // search for shape-vertex and hole-vertex,
                // which can be connected without intersections
                for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++ ) {

                    shapePt = shape[ shapeIndex ];
                    holeIndex = -1;

                    // search for hole which can be reached without intersections
                    for ( var h = 0; h < indepHoles.length; h++ ) {

                        holeIdx = indepHoles[ h ];

                        // prevent multiple checks
                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                        if ( failedCuts[ cutKey ] !== undefined ) continue;

                        hole = holes[ holeIdx ];
                        for ( var h2 = 0; h2 < hole.length; h2++ ) {

                            holePt = hole[ h2 ];
                            if ( !isCutLineInsideAngles( shapeIndex, h2 ) ) continue;
                            if ( intersectsShapeEdge( shapePt, holePt ) ) continue;
                            if ( intersectsHoleEdge( shapePt, holePt ) ) continue;

                            holeIndex = h2;
                            indepHoles.splice( h, 1 );

                            tmpShape1 = shape.slice( 0, shapeIndex + 1 );
                            tmpShape2 = shape.slice( shapeIndex );
                            tmpHole1 = hole.slice( holeIndex );
                            tmpHole2 = hole.slice( 0, holeIndex + 1 );

                            shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

                            minShapeIndex = shapeIndex;

                            // Debug only, to show the selected cuts
                            // glob_CutLines.push( [ shapePt, holePt ] );

                            break;

                        }
                        if ( holeIndex >= 0 ) break; // hole-vertex found

                        failedCuts[ cutKey ] = true; // remember failure

                    }
                    if ( holeIndex >= 0 ) break; // hole-vertex found

                }

            }

            return shape; /* shape with no holes */

        }


        var i, il, f, face,
            key, index,
            allPointsMap = {};

        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

        var allpoints = contour.concat();

        for ( var h = 0, hl = holes.length; h < hl; h++ ) {

            Array.prototype.push.apply( allpoints, holes[ h ] );

        }

        //console.log( "allpoints",allpoints, allpoints.length );

        // prepare all points map

        for ( i = 0, il = allpoints.length; i < il; i++ ) {

            key = allpoints[ i ].x + ":" + allpoints[ i ].y;

            if ( allPointsMap[ key ] !== undefined ) {

                console.warn( "THREE.Shape: Duplicate point", key );

            }

            allPointsMap[ key ] = i;

        }

        // remove holes by cutting paths to holes and adding them to the shape
        var shapeWithoutHoles = removeHoles( contour, holes );

        var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
        //console.log( "triangles",triangles, triangles.length );

        // check all face vertices against all points map

        for ( i = 0, il = triangles.length; i < il; i++ ) {

            face = triangles[ i ];

            for ( f = 0; f < 3; f++ ) {

                key = face[ f ].x + ":" + face[ f ].y;

                index = allPointsMap[ key ];

                if ( index !== undefined ) {

                    face[ f ] = index;

                }

            }

        }

        return triangles.concat();

    },

    isClockWise: function( pts ) {

        return THREE.FontUtils.Triangulate.area( pts ) < 0;

    },

    // Bezier Curves formulas obtained from
    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    // Quad Bezier Functions

    b2p0: function( t, p ) {

        var k = 1 - t;
        return k * k * p;

    },

    b2p1: function( t, p ) {

        return 2 * ( 1 - t ) * t * p;

    },

    b2p2: function( t, p ) {

        return t * t * p;

    },

    b2: function( t, p0, p1, p2 ) {

        return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

    },

    // Cubic Bezier Functions

    b3p0: function( t, p ) {

        var k = 1 - t;
        return k * k * k * p;

    },

    b3p1: function( t, p ) {

        var k = 1 - t;
        return 3 * k * k * t * p;

    },

    b3p2: function( t, p ) {

        var k = 1 - t;
        return 3 * k * t * t * p;

    },

    b3p3: function( t, p ) {

        return t * t * t * p;

    },

    b3: function( t, p0, p1, p2, p3 ) {

        return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) + this.b3p3( t, p3 );

    }

};

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function( t ) {

    var point = this.v2.clone().sub( this.v1 );
    point.multiplyScalar( t ).add( this.v1 );

    return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function( u ) {

    return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

    var tangent = this.v2.clone().sub( this.v1 );

    return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function( t ) {

    var vector = new THREE.Vector2();

    vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

    return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

    var vector = new THREE.Vector2();

    vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

    // returns unit vector

    return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function( t ) {

    var tx, ty;

    tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

    return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

    var tx, ty;

    tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

    var tangent = new THREE.Vector2( tx, ty );
    tangent.normalize();

    return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function( points /* array of Vector2 */ ) {

    this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var vector = new THREE.Vector2();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

    return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    this.aX = aX;
    this.aY = aY;

    this.xRadius = xRadius;
    this.yRadius = yRadius;

    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;

    this.aClockwise = aClockwise;

    this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function( t ) {

    var deltaAngle = this.aEndAngle - this.aStartAngle;

    if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
    if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

    var angle;

    if ( this.aClockwise === true ) {

        angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

    }
    else {

        angle = this.aStartAngle + t * deltaAngle;

    }

    var x = this.aX + this.xRadius * Math.cos( angle );
    var y = this.aY + this.yRadius * Math.sin( angle );

    if ( this.aRotation !== 0 ) {

        var cos = Math.cos( this.aRotation );
        var sin = Math.sin( this.aRotation );

        var tx = x,
            ty = y;

        // Rotate the point about the center of the ellipse.
        x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
        y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

    }

    return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

    function( v1, v2 ) {

        this.v1 = v1;
        this.v2 = v2;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.subVectors( this.v2, this.v1 ); // diff
        vector.multiplyScalar( t );
        vector.add( this.v1 );

        return vector;

    }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

    function( v0, v1, v2 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
        vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
        vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

        return vector;

    }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

    function( v0, v1, v2, v3 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
        vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
        vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

        return vector;

    }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

    function( points /* array of Vector3 */ ) {

        console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
        this.points = ( points == undefined ) ? [] : points;

    },

    function( t ) {

        var points = this.points;
        var point = ( points.length - 1 ) * t;

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
        var point1 = points[ intPoint ];
        var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
        var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

        var vector = new THREE.Vector3();

        vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
        vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
        vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

        return vector;

    }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

    var
        tmp = new THREE.Vector3(),
        px = new CubicPoly(),
        py = new CubicPoly(),
        pz = new CubicPoly();

    /*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

    function CubicPoly() {

    }

    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

        this.c0 = x0;
        this.c1 = t0;
        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    };

    CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

        // compute tangents when parameterized in [t1,t2]
        var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
        var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;

        // initCubicPoly
        this.init( x1, x2, t1, t2 );

    };

    // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

        this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    };

    CubicPoly.prototype.calc = function( t ) {

        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    };

    // Subclass Three.js curve
    return THREE.Curve.create(

        function( p /* array of Vector3 */ ) {

            this.points = p || [];

        },

        function( t ) {

            var points = this.points,
                point, intPoint, weight, l;

            l = points.length;

            if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

            point = ( l - 1 ) * t;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            if ( weight === 0 && intPoint === l - 1 ) {

                intPoint = l - 2;
                weight = 1;

            }

            var p0, p1, p2, p3;

            if ( intPoint === 0 ) {

                // extrapolate first point
                tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
                p0 = tmp;

            }
            else {

                p0 = points[ intPoint - 1 ];

            }

            p1 = points[ intPoint ];
            p2 = points[ intPoint + 1 ];

            if ( intPoint + 2 < l ) {

                p3 = points[ intPoint + 2 ]

            }
            else {

                // extrapolate last point
                tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
                p3 = tmp;

            }

            if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

                // init Centripetal / Chordal Catmull-Rom
                var pow = this.type === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
                var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
                var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

                // safety check for repeated points
                if ( dt1 < 1e-4 ) dt1 = 1.0;
                if ( dt0 < 1e-4 ) dt0 = dt1;
                if ( dt2 < 1e-4 ) dt2 = dt1;

                px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
                py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
                pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

            }
            else if ( this.type === 'catmullrom' ) {

                var tension = this.tension !== undefined ? this.tension : 0.5;
                px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
                py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
                pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

            }

            var v = new THREE.Vector3(
                px.calc( weight ),
                py.calc( weight ),
                pz.calc( weight )
            );

            return v;

        }

    );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

    function( points /* array of Vector3 */ ) {

        this.points = ( points == undefined ) ? [] : points;

    },

    function( t ) {

        var points = this.points;
        var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

        var point0 = points[ ( intPoint - 1 ) % points.length ];
        var point1 = points[ ( intPoint ) % points.length ];
        var point2 = points[ ( intPoint + 1 ) % points.length ];
        var point3 = points[ ( intPoint + 2 ) % points.length ];

        var vector = new THREE.Vector3();

        vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
        vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
        vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

        return vector;

    }

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2,

    //

    add: function() {

        console.warn( 'THREE.AnimationHandler.add() has been deprecated.' );

    },
    get: function() {

        console.warn( 'THREE.AnimationHandler.get() has been deprecated.' );

    },
    remove: function() {

        console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );

    },

    //

    animations: [],

    init: function( data ) {

        if ( data.initialized === true ) return data;

        // loop through all keys

        for ( var h = 0; h < data.hierarchy.length; h++ ) {

            for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                // remove minus times

                if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

                    data.hierarchy[ h ].keys[ k ].time = 0;

                }

                // create quaternions

                if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
                    !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

                    var quat = data.hierarchy[ h ].keys[ k ].rot;
                    data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

                }

            }

            // prepare morph target keys

            if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

                // get all used

                var usedMorphTargets = {};

                for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                    for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m++ ) {

                        var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
                        usedMorphTargets[ morphTargetName ] = -1;

                    }

                }

                data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


                // set all used on all frames

                for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                    var influences = {};

                    for ( var morphTargetName in usedMorphTargets ) {

                        for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m++ ) {

                            if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

                                influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
                                break;

                            }

                        }

                        if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

                            influences[ morphTargetName ] = 0;

                        }

                    }

                    data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

                }

            }


            // remove all keys that are on the same time

            for ( var k = 1; k < data.hierarchy[ h ].keys.length; k++ ) {

                if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

                    data.hierarchy[ h ].keys.splice( k, 1 );
                    k--;

                }

            }


            // set index

            for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                data.hierarchy[ h ].keys[ k ].index = k;

            }

        }

        data.initialized = true;

        return data;

    },

    parse: function( root ) {

        var parseRecurseHierarchy = function( root, hierarchy ) {

            hierarchy.push( root );

            for ( var c = 0; c < root.children.length; c++ )
                parseRecurseHierarchy( root.children[ c ], hierarchy );

        };

        // setup hierarchy

        var hierarchy = [];

        if ( root instanceof THREE.SkinnedMesh ) {

            for ( var b = 0; b < root.skeleton.bones.length; b++ ) {

                hierarchy.push( root.skeleton.bones[ b ] );

            }

        }
        else {

            parseRecurseHierarchy( root, hierarchy );

        }

        return hierarchy;

    },

    play: function( animation ) {

        if ( this.animations.indexOf( animation ) === -1 ) {

            this.animations.push( animation );

        }

    },

    stop: function( animation ) {

        var index = this.animations.indexOf( animation );

        if ( index !== -1 ) {

            this.animations.splice( index, 1 );

        }

    },

    update: function( deltaTimeMS ) {

        for ( var i = 0; i < this.animations.length; i++ ) {

            this.animations[ i ].resetBlendWeights();

        }

        for ( var i = 0; i < this.animations.length; i++ ) {

            this.animations[ i ].update( deltaTimeMS );

        }

    }

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function( root, data ) {

    this.root = root;
    this.data = THREE.AnimationHandler.init( data );
    this.hierarchy = THREE.AnimationHandler.parse( root );

    this.currentTime = 0;
    this.timeScale = 1;

    this.isPlaying = false;
    this.loop = true;
    this.weight = 0;

    this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype = {

    constructor: THREE.Animation,

    keyTypes: [ "pos", "rot", "scl" ],

    play: function( startTime, weight ) {

        this.currentTime = startTime !== undefined ? startTime : 0;
        this.weight = weight !== undefined ? weight : 1;

        this.isPlaying = true;

        this.reset();

        THREE.AnimationHandler.play( this );

    },

    stop: function() {

        this.isPlaying = false;

        THREE.AnimationHandler.stop( this );

    },

    reset: function() {

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];

            if ( object.animationCache === undefined ) {

                object.animationCache = {
                    animations: {},
                    blending: {
                        positionWeight: 0.0,
                        quaternionWeight: 0.0,
                        scaleWeight: 0.0
                    }
                };

            }

            var name = this.data.name;
            var animations = object.animationCache.animations;
            var animationCache = animations[ name ];

            if ( animationCache === undefined ) {

                animationCache = {
                    prevKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    nextKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    originalMatrix: object.matrix
                };

                animations[ name ] = animationCache;

            }

            // Get keys to match our current time

            for ( var t = 0; t < 3; t++ ) {

                var type = this.keyTypes[ t ];

                var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
                var nextKey = this.getNextKeyWith( type, h, 1 );

                while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                    prevKey = nextKey;
                    nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

                }

                animationCache.prevKey[ type ] = prevKey;
                animationCache.nextKey[ type ] = nextKey;

            }

        }

    },

    resetBlendWeights: function() {

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];
            var animationCache = object.animationCache;

            if ( animationCache !== undefined ) {

                var blending = animationCache.blending;

                blending.positionWeight = 0.0;
                blending.quaternionWeight = 0.0;
                blending.scaleWeight = 0.0;

            }

        }

    },

    update: ( function() {

        var points = [];
        var target = new THREE.Vector3();
        var newVector = new THREE.Vector3();
        var newQuat = new THREE.Quaternion();

        // Catmull-Rom spline

        var interpolateCatmullRom = function( points, scale ) {

            var c = [],
                v3 = [],
                point, intPoint, weight, w2, w3,
                pa, pb, pc, pd;

            point = ( points.length - 1 ) * scale;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
            c[ 1 ] = intPoint;
            c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
            c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

            pa = points[ c[ 0 ] ];
            pb = points[ c[ 1 ] ];
            pc = points[ c[ 2 ] ];
            pd = points[ c[ 3 ] ];

            w2 = weight * weight;
            w3 = weight * w2;

            v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
            v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
            v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

            return v3;

        };

        var interpolate = function( p0, p1, p2, p3, t, t2, t3 ) {

            var v0 = ( p2 - p0 ) * 0.5,
                v1 = ( p3 - p1 ) * 0.5;

            return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( -3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

        };

        return function( delta ) {

            if ( this.isPlaying === false ) return;

            this.currentTime += delta * this.timeScale;

            if ( this.weight === 0 )
                return;

            //

            var duration = this.data.length;

            if ( this.currentTime > duration || this.currentTime < 0 ) {

                if ( this.loop ) {

                    this.currentTime %= duration;

                    if ( this.currentTime < 0 )
                        this.currentTime += duration;

                    this.reset();

                }
                else {

                    this.stop();

                }

            }

            for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

                var object = this.hierarchy[ h ];
                var animationCache = object.animationCache.animations[ this.data.name ];
                var blending = object.animationCache.blending;

                // loop through pos/rot/scl

                for ( var t = 0; t < 3; t++ ) {

                    // get keys

                    var type = this.keyTypes[ t ];
                    var prevKey = animationCache.prevKey[ type ];
                    var nextKey = animationCache.nextKey[ type ];

                    if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
                        ( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

                        prevKey = this.data.hierarchy[ h ].keys[ 0 ];
                        nextKey = this.getNextKeyWith( type, h, 1 );

                        while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                            prevKey = nextKey;
                            nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

                        }

                        animationCache.prevKey[ type ] = prevKey;
                        animationCache.nextKey[ type ] = nextKey;

                    }

                    var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

                    var prevXYZ = prevKey[ type ];
                    var nextXYZ = nextKey[ type ];

                    if ( scale < 0 ) scale = 0;
                    if ( scale > 1 ) scale = 1;

                    // interpolate

                    if ( type === "pos" ) {

                        if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

                            newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
                            newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
                            newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

                            // blend
                            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
                            object.position.lerp( newVector, proportionalWeight );
                            blending.positionWeight += this.weight;

                        }
                        else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
                            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                            points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
                            points[ 1 ] = prevXYZ;
                            points[ 2 ] = nextXYZ;
                            points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

                            scale = scale * 0.33 + 0.33;

                            var currentPoint = interpolateCatmullRom( points, scale );
                            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
                            blending.positionWeight += this.weight;

                            // blend

                            var vector = object.position;

                            vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
                            vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
                            vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

                            if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                                var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

                                target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
                                target.sub( vector );
                                target.y = 0;
                                target.normalize();

                                var angle = Math.atan2( target.x, target.z );
                                object.rotation.set( 0, angle, 0 );

                            }

                        }

                    }
                    else if ( type === "rot" ) {

                        THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

                        // Avoid paying the cost of an additional slerp if we don't have to
                        if ( blending.quaternionWeight === 0 ) {

                            object.quaternion.copy( newQuat );
                            blending.quaternionWeight = this.weight;

                        }
                        else {

                            var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
                            THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
                            blending.quaternionWeight += this.weight;

                        }

                    }
                    else if ( type === "scl" ) {

                        newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
                        newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
                        newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

                        var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
                        object.scale.lerp( newVector, proportionalWeight );
                        blending.scaleWeight += this.weight;

                    }

                }

            }

            return true;

        };

    } )(),

    getNextKeyWith: function( type, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;

        if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

            key = key < keys.length - 1 ? key : keys.length - 1;

        }
        else {

            key = key % keys.length;

        }

        for ( ; key < keys.length; key++ ) {

            if ( keys[ key ][ type ] !== undefined ) {

                return keys[ key ];

            }

        }

        return this.data.hierarchy[ h ].keys[ 0 ];

    },

    getPrevKeyWith: function( type, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;

        if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

            key = key > 0 ? key : 0;

        }
        else {

            key = key >= 0 ? key : key + keys.length;

        }


        for ( ; key >= 0; key-- ) {

            if ( keys[ key ][ type ] !== undefined ) {

                return keys[ key ];

            }

        }

        return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

    }

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function( data ) {

    this.root = data.node;
    this.data = THREE.AnimationHandler.init( data );
    this.hierarchy = THREE.AnimationHandler.parse( this.root );
    this.currentTime = 0;
    this.timeScale = 0.001;
    this.isPlaying = false;
    this.isPaused = true;
    this.loop = true;

    // initialize to first keyframes

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

        var keys = this.data.hierarchy[ h ].keys,
            sids = this.data.hierarchy[ h ].sids,
            obj = this.hierarchy[ h ];

        if ( keys.length && sids ) {

            for ( var s = 0; s < sids.length; s++ ) {

                var sid = sids[ s ],
                    next = this.getNextKeyWith( sid, h, 0 );

                if ( next ) {

                    next.apply( sid );

                }

            }

            obj.matrixAutoUpdate = false;
            this.data.hierarchy[ h ].node.updateMatrix();
            obj.matrixWorldNeedsUpdate = true;

        }

    }

};

THREE.KeyFrameAnimation.prototype = {

    constructor: THREE.KeyFrameAnimation,

    play: function( startTime ) {

        this.currentTime = startTime !== undefined ? startTime : 0;

        if ( this.isPlaying === false ) {

            this.isPlaying = true;

            // reset key cache

            var h, hl = this.hierarchy.length,
                object,
                node;

            for ( h = 0; h < hl; h++ ) {

                object = this.hierarchy[ h ];
                node = this.data.hierarchy[ h ];

                if ( node.animationCache === undefined ) {

                    node.animationCache = {};
                    node.animationCache.prevKey = null;
                    node.animationCache.nextKey = null;
                    node.animationCache.originalMatrix = object.matrix;

                }

                var keys = this.data.hierarchy[ h ].keys;

                if ( keys.length ) {

                    node.animationCache.prevKey = keys[ 0 ];
                    node.animationCache.nextKey = keys[ 1 ];

                    this.startTime = Math.min( keys[ 0 ].time, this.startTime );
                    this.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );

                }

            }

            this.update( 0 );

        }

        this.isPaused = false;

        THREE.AnimationHandler.play( this );

    },

    stop: function() {

        this.isPlaying = false;
        this.isPaused = false;

        THREE.AnimationHandler.stop( this );

        // reset JIT matrix and remove cache

        for ( var h = 0; h < this.data.hierarchy.length; h++ ) {

            var obj = this.hierarchy[ h ];
            var node = this.data.hierarchy[ h ];

            if ( node.animationCache !== undefined ) {

                var original = node.animationCache.originalMatrix;

                original.copy( obj.matrix );
                obj.matrix = original;

                delete node.animationCache;

            }

        }

    },

    update: function( delta ) {

        if ( this.isPlaying === false ) return;

        this.currentTime += delta * this.timeScale;

        //

        var duration = this.data.length;

        if ( this.loop === true && this.currentTime > duration ) {

            this.currentTime %= duration;

        }

        this.currentTime = Math.min( this.currentTime, duration );

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];
            var node = this.data.hierarchy[ h ];

            var keys = node.keys,
                animationCache = node.animationCache;


            if ( keys.length ) {

                var prevKey = animationCache.prevKey;
                var nextKey = animationCache.nextKey;

                if ( nextKey.time <= this.currentTime ) {

                    while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                        prevKey = nextKey;
                        nextKey = keys[ prevKey.index + 1 ];

                    }

                    animationCache.prevKey = prevKey;
                    animationCache.nextKey = nextKey;

                }

                if ( nextKey.time >= this.currentTime ) {

                    prevKey.interpolate( nextKey, this.currentTime );

                }
                else {

                    prevKey.interpolate( nextKey, nextKey.time );

                }

                this.data.hierarchy[ h ].node.updateMatrix();
                object.matrixWorldNeedsUpdate = true;

            }

        }

    },

    getNextKeyWith: function( sid, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;
        key = key % keys.length;

        for ( ; key < keys.length; key++ ) {

            if ( keys[ key ].hasTarget( sid ) ) {

                return keys[ key ];

            }

        }

        return keys[ 0 ];

    },

    getPrevKeyWith: function( sid, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;
        key = key >= 0 ? key : key + keys.length;

        for ( ; key >= 0; key-- ) {

            if ( keys[ key ].hasTarget( sid ) ) {

                return keys[ key ];

            }

        }

        return keys[ keys.length - 1 ];

    }

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author willy-vvu / http://willy-vvu.github.io
 */

THREE.MorphAnimation = function( mesh ) {

    this.mesh = mesh;
    this.frames = mesh.morphTargetInfluences.length;
    this.currentTime = 0;
    this.duration = 1000;
    this.loop = true;
    this.lastFrame = 0;
    this.currentFrame = 0;

    this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

    constructor: THREE.MorphAnimation,

    play: function() {

        this.isPlaying = true;

    },

    pause: function() {

        this.isPlaying = false;

    },

    update: function( delta ) {

        if ( this.isPlaying === false ) return;

        this.currentTime += delta;

        if ( this.loop === true && this.currentTime > this.duration ) {

            this.currentTime %= this.duration;

        }

        this.currentTime = Math.min( this.currentTime, this.duration );

        var frameTime = this.duration / this.frames;
        var frame = Math.floor( this.currentTime / frameTime );

        var influences = this.mesh.morphTargetInfluences;

        if ( frame !== this.currentFrame ) {

            influences[ this.lastFrame ] = 0;
            influences[ this.currentFrame ] = 1;
            influences[ frame ] = 0;

            this.lastFrame = this.currentFrame;
            this.currentFrame = frame;

        }

        var mix = ( this.currentTime % frameTime ) / frameTime;

        influences[ frame ] = mix;
        influences[ this.lastFrame ] = 1 - mix;

    }

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    THREE.Geometry.call( this );

    this.type = 'BoxGeometry';

    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };

    this.widthSegments = widthSegments || 1;
    this.heightSegments = heightSegments || 1;
    this.depthSegments = depthSegments || 1;

    var scope = this;

    var width_half = width / 2;
    var height_half = height / 2;
    var depth_half = depth / 2;

    buildPlane( 'z', 'y', -1, -1, depth, height, width_half, 0 ); // px
    buildPlane( 'z', 'y', 1, -1, depth, height, -width_half, 1 ); // nx
    buildPlane( 'x', 'z', 1, 1, width, depth, height_half, 2 ); // py
    buildPlane( 'x', 'z', 1, -1, width, depth, -height_half, 3 ); // ny
    buildPlane( 'x', 'y', 1, -1, width, height, depth_half, 4 ); // pz
    buildPlane( 'x', 'y', -1, -1, width, height, -depth_half, 5 ); // nz

    function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

        var w, ix, iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;

        if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

            w = 'z';

        }
        else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

            w = 'y';
            gridY = scope.depthSegments;

        }
        else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

            w = 'x';
            gridX = scope.depthSegments;

        }

        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();

        normal[ w ] = depth > 0 ? 1 : -1;

        for ( iy = 0; iy < gridY1; iy++ ) {

            for ( ix = 0; ix < gridX1; ix++ ) {

                var vector = new THREE.Vector3();
                vector[ u ] = ( ix * segment_width - width_half ) * udir;
                vector[ v ] = ( iy * segment_height - height_half ) * vdir;
                vector[ w ] = depth;

                scope.vertices.push( vector );

            }

        }

        for ( iy = 0; iy < gridY; iy++ ) {

            for ( ix = 0; ix < gridX; ix++ ) {

                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * ( iy + 1 );
                var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
                var d = ( ix + 1 ) + gridX1 * iy;

                var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
                var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
                var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
                var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

                var face = new THREE.Face3( a + offset, b + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

                face = new THREE.Face3( b + offset, c + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

            }

        }

    }

    this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function() {

    var geometry = new THREE.BoxGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.depth,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.depthSegments
    );

    return geometry;

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function( radius, segments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CircleGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var i, uvs = [],
        center = new THREE.Vector3(),
        centerUV = new THREE.Vector2( 0.5, 0.5 );

    this.vertices.push( center );
    uvs.push( centerUV );

    for ( i = 0; i <= segments; i++ ) {

        var vertex = new THREE.Vector3();
        var segment = thetaStart + i / segments * thetaLength;

        vertex.x = radius * Math.cos( segment );
        vertex.y = radius * Math.sin( segment );

        this.vertices.push( vertex );
        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 1; i <= segments; i++ ) {

        this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
        this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function() {

    var geometry = new THREE.CircleGeometry(
        this.parameters.radius,
        this.parameters.segments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function( radius, segments, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'CircleBufferGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var vertices = segments + 2;

    var positions = new Float32Array( vertices * 3 );
    var normals = new Float32Array( vertices * 3 );
    var uvs = new Float32Array( vertices * 2 );

    // center data is already zero, but need to set a few extras
    normals[ 3 ] = 1.0;
    uvs[ 0 ] = 0.5;
    uvs[ 1 ] = 0.5;

    for ( var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2 ) {

        var segment = thetaStart + s / segments * thetaLength;

        positions[ i ] = radius * Math.cos( segment );
        positions[ i + 1 ] = radius * Math.sin( segment );

        normals[ i + 2 ] = 1; // normal z

        uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
        uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    }

    var indices = [];

    for ( var i = 1; i <= segments; i++ ) {

        indices.push( i );
        indices.push( i + 1 );
        indices.push( 0 );

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.CircleBufferGeometry(
        this.parameters.radius,
        this.parameters.segments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CylinderGeometry';

    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;

    radialSegments = radialSegments || 8;
    heightSegments = heightSegments || 1;

    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

    var heightHalf = height / 2;

    var x, y, vertices = [],
        uvs = [];

    for ( y = 0; y <= heightSegments; y++ ) {

        var verticesRow = [];
        var uvsRow = [];

        var v = y / heightSegments;
        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

        for ( x = 0; x <= radialSegments; x++ ) {

            var u = x / radialSegments;

            var vertex = new THREE.Vector3();
            vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
            vertex.y = -v * height + heightHalf;
            vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

            this.vertices.push( vertex );

            verticesRow.push( this.vertices.length - 1 );
            uvsRow.push( new THREE.Vector2( u, 1 - v ) );

        }

        vertices.push( verticesRow );
        uvs.push( uvsRow );

    }

    var tanTheta = ( radiusBottom - radiusTop ) / height;
    var na, nb;

    for ( x = 0; x < radialSegments; x++ ) {

        if ( radiusTop !== 0 ) {

            na = this.vertices[ vertices[ 0 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

        }
        else {

            na = this.vertices[ vertices[ 1 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

        }

        na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
        nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

        for ( y = 0; y < heightSegments; y++ ) {

            var v1 = vertices[ y ][ x ];
            var v2 = vertices[ y + 1 ][ x ];
            var v3 = vertices[ y + 1 ][ x + 1 ];
            var v4 = vertices[ y ][ x + 1 ];

            var n1 = na.clone();
            var n2 = na.clone();
            var n3 = nb.clone();
            var n4 = nb.clone();

            var uv1 = uvs[ y ][ x ].clone();
            var uv2 = uvs[ y + 1 ][ x ].clone();
            var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
            var uv4 = uvs[ y ][ x + 1 ].clone();

            this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

            this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

        }

    }

    // top cap

    if ( openEnded === false && radiusTop > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x++ ) {

            var v1 = vertices[ 0 ][ x ];
            var v2 = vertices[ 0 ][ x + 1 ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, 1, 0 );
            var n2 = new THREE.Vector3( 0, 1, 0 );
            var n3 = new THREE.Vector3( 0, 1, 0 );

            var uv1 = uvs[ 0 ][ x ].clone();
            var uv2 = uvs[ 0 ][ x + 1 ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 0 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    // bottom cap

    if ( openEnded === false && radiusBottom > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, -heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x++ ) {

            var v1 = vertices[ heightSegments ][ x + 1 ];
            var v2 = vertices[ heightSegments ][ x ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, -1, 0 );
            var n2 = new THREE.Vector3( 0, -1, 0 );
            var n3 = new THREE.Vector3( 0, -1, 0 );

            var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
            var uv2 = uvs[ heightSegments ][ x ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 1 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function() {

    var geometry = new THREE.CylinderGeometry(
        this.parameters.radiusTop,
        this.parameters.radiusBottom,
        this.parameters.height,
        this.parameters.radialSegments,
        this.parameters.heightSegments,
        this.parameters.openEnded,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function( geometry, thresholdAngle ) {

    THREE.BufferGeometry.call( this );

    thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

    var edge = [ 0, 0 ],
        hash = {};
    var sortFunction = function( a, b ) {

        return a - b;

    };

    var keys = [ 'a', 'b', 'c' ];

    var geometry2;

    if ( geometry instanceof THREE.BufferGeometry ) {

        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry( geometry );

    }
    else {

        geometry2 = geometry.clone();

    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();

    var vertices = geometry2.vertices;
    var faces = geometry2.faces;

    for ( var i = 0, l = faces.length; i < l; i++ ) {

        var face = faces[ i ];

        for ( var j = 0; j < 3; j++ ) {

            edge[ 0 ] = face[ keys[ j ] ];
            edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

                hash[ key ] = {
                    vert1: edge[ 0 ],
                    vert2: edge[ 1 ],
                    face1: i,
                    face2: undefined
                };

            }
            else {

                hash[ key ].face2 = i;

            }

        }

    }

    var coords = [];

    for ( var key in hash ) {

        var h = hash[ key ];

        if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

            var vertex = vertices[ h.vert1 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

            vertex = vertices[ h.vert2 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

        }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function( shapes, options ) {

    if ( typeof( shapes ) === "undefined" ) {

        shapes = [];
        return;

    }

    THREE.Geometry.call( this );

    this.type = 'ExtrudeGeometry';

    shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

    // can't really use automatic vertex normals
    // as then front and back sides get smoothed too
    // should do separate smoothing just for sides

    //this.computeVertexNormals();

    //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function( shapes, options ) {

    var sl = shapes.length;

    for ( var s = 0; s < sl; s++ ) {

        var shape = shapes[ s ];
        this.addShape( shape, options );

    }

};

THREE.ExtrudeGeometry.prototype.addShape = function( shape, options ) {

    var amount = options.amount !== undefined ? options.amount : 100;

    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var steps = options.steps !== undefined ? options.steps : 1;

    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;

    // Use default WorldUVGenerator if no UV generators are specified.
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

    var splineTube, binormal, normal, position2;
    if ( extrudePath ) {

        extrudePts = extrudePath.getSpacedPoints( steps );

        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion

        // SETUP TNB variables

        // Reuse TNB from TubeGeomtry for now.
        // TODO1 - have a .isClosed in spline?

        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();

    }

    // Safeguards if bevels are not enabled

    if ( !bevelEnabled ) {

        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;

    }

    // Variables initialization

    var ahole, h, hl; // looping of holes
    var scope = this;

    var shapesOffset = this.vertices.length;

    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = !THREE.Shape.Utils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];

            if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

                holes[ h ] = ahole.reverse();

            }

        }

        reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    }


    var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for ( h = 0, hl = holes.length; h < hl; h++ ) {

        ahole = holes[ h ];

        vertices = vertices.concat( ahole );

    }


    function scalePt2( pt, vec, size ) {

        if ( !vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

        return vec.clone().multiplyScalar( size ).add( pt );

    }

    var b, bs, t, z,
        vert, vlen = vertices.length,
        face, flen = faces.length;


    // Find directions for point movement


    function getBevelVec( inPt, inPrev, inNext ) {

        var EPSILON = 0.0000000001;

        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.

        var v_trans_x, v_trans_y, shrink_by = 1; // resulting translation vector for inPt

        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;

        var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

        // check for collinear edges
        var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

        if ( Math.abs( collinear0 ) > EPSILON ) {

            // not collinear

            // length of vectors for normalizing

            var v_prev_len = Math.sqrt( v_prev_lensq );
            var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

            // shift adjacent points by unit vectors to the left

            var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
            var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

            var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
            var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

            // scaling factor for v_prev to intersection point

            var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
                    ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
                ( v_prev_x * v_next_y - v_prev_y * v_next_x );

            // vector from inPt to intersection point

            v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
            v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

            // Don't normalize!, otherwise sharp corners become ugly
            //  but prevent crazy spikes
            var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
            if ( v_trans_lensq <= 2 ) {

                return new THREE.Vector2( v_trans_x, v_trans_y );

            }
            else {

                shrink_by = Math.sqrt( v_trans_lensq / 2 );

            }

        }
        else {

            // handle special case of collinear edges

            var direction_eq = false; // assumes: opposite
            if ( v_prev_x > EPSILON ) {

                if ( v_next_x > EPSILON ) {

                    direction_eq = true;

                }

            }
            else {

                if ( v_prev_x < -EPSILON ) {

                    if ( v_next_x < -EPSILON ) {

                        direction_eq = true;

                    }

                }
                else {

                    if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

                        direction_eq = true;

                    }

                }

            }

            if ( direction_eq ) {

                // console.log("Warning: lines are a straight sequence");
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt( v_prev_lensq );

            }
            else {

                // console.log("Warning: lines are a straight spike");
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt( v_prev_lensq / 2 );

            }

        }

        return new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    }


    var contourMovements = [];

    for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++ ) {

        if ( j === il ) j = 0;
        if ( k === il ) k = 0;

        //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    }

    var holesMovements = [],
        oneHoleMovements, verticesMovements = contourMovements.concat();

    for ( h = 0, hl = holes.length; h < hl; h++ ) {

        ahole = holes[ h ];

        oneHoleMovements = [];

        for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++ ) {

            if ( j === il ) j = 0;
            if ( k === il ) k = 0;

            //  (j)---(i)---(k)
            oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

        }

        holesMovements.push( oneHoleMovements );
        verticesMovements = verticesMovements.concat( oneHoleMovements );

    }


    // Loop bevelSegments, 1 for the front, 1 for the back

    for ( b = 0; b < bevelSegments; b++ ) {

        //for ( b = bevelSegments; b > 0; b -- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );

        //z = bevelThickness * t;
        bs = bevelSize * ( Math.sin( t * Math.PI / 2 ) ); // curved
        //bs = bevelSize * t; // linear

        // contract shape

        for ( i = 0, il = contour.length; i < il; i++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

            v( vert.x, vert.y, -z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                v( vert.x, vert.y, -z );

            }

        }

    }

    bs = bevelSize;

    // Back facing vertices

    for ( i = 0; i < vlen; i++ ) {

        vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

        if ( !extrudeByPath ) {

            v( vert.x, vert.y, 0 );

        }
        else {

            // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

            normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
            binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

            position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

            v( position2.x, position2.y, position2.z );

        }

    }

    // Add stepped vertices...
    // Including front facing vertices

    var s;

    for ( s = 1; s <= steps; s++ ) {

        for ( i = 0; i < vlen; i++ ) {

            vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

            if ( !extrudeByPath ) {

                v( vert.x, vert.y, amount / steps * s );

            }
            else {

                // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
                binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

                position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

                v( position2.x, position2.y, position2.z );

            }

        }

    }


    // Add bevel segments planes

    //for ( b = 1; b <= bevelSegments; b ++ ) {
    for ( b = bevelSegments - 1; b >= 0; b-- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );
        //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
        bs = bevelSize * Math.sin( t * Math.PI / 2 );

        // contract shape

        for ( i = 0, il = contour.length; i < il; i++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
            v( vert.x, vert.y, amount + z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                if ( !extrudeByPath ) {

                    v( vert.x, vert.y, amount + z );

                }
                else {

                    v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

                }

            }

        }

    }

    /* Faces */

    // Top and bottom faces

    buildLidFaces();

    // Sides faces

    buildSideFaces();


    /////  Internal functions

    function buildLidFaces() {

        if ( bevelEnabled ) {

            var layer = 0; // steps + 1
            var offset = vlen * layer;

            // Bottom faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

            }

            layer = steps + bevelSegments * 2;
            offset = vlen * layer;

            // Top faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

            }

        }
        else {

            // Bottom faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 2 ], face[ 1 ], face[ 0 ] );

            }

            // Top faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

            }

        }

    }

    // Create faces for the z-sides of the shape

    function buildSideFaces() {

        var layeroffset = 0;
        sidewalls( contour, layeroffset );
        layeroffset += contour.length;

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            sidewalls( ahole, layeroffset );

            //, true
            layeroffset += ahole.length;

        }

    }

    function sidewalls( contour, layeroffset ) {

        var j, k;
        i = contour.length;

        while ( --i >= 0 ) {

            j = i;
            k = i - 1;
            if ( k < 0 ) k = contour.length - 1;

            //console.log('b', i,j, i-1, k,vertices.length);

            var s = 0,
                sl = steps + bevelSegments * 2;

            for ( s = 0; s < sl; s++ ) {

                var slen1 = vlen * s;
                var slen2 = vlen * ( s + 1 );

                var a = layeroffset + j + slen1,
                    b = layeroffset + k + slen1,
                    c = layeroffset + k + slen2,
                    d = layeroffset + j + slen2;

                f4( a, b, c, d, contour, s, sl, j, k );

            }

        }

    }


    function v( x, y, z ) {

        scope.vertices.push( new THREE.Vector3( x, y, z ) );

    }

    function f3( a, b, c ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, c ) );

        var uvs = uvgen.generateTopUV( scope, a, b, c );

        scope.faceVertexUvs[ 0 ].push( uvs );

    }

    function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, d ) );
        scope.faces.push( new THREE.Face3( b, c, d ) );

        var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

        scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
        scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

    generateTopUV: function( geometry, indexA, indexB, indexC ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];

        return [
            new THREE.Vector2( a.x, a.y ),
            new THREE.Vector2( b.x, b.y ),
            new THREE.Vector2( c.x, c.y )
        ];

    },

    generateSideWallUV: function( geometry, indexA, indexB, indexC, indexD ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];
        var d = vertices[ indexD ];

        if ( Math.abs( a.y - b.y ) < 0.01 ) {

            return [
                new THREE.Vector2( a.x, 1 - a.z ),
                new THREE.Vector2( b.x, 1 - b.z ),
                new THREE.Vector2( c.x, 1 - c.z ),
                new THREE.Vector2( d.x, 1 - d.z )
            ];

        }
        else {

            return [
                new THREE.Vector2( a.y, 1 - a.z ),
                new THREE.Vector2( b.y, 1 - b.z ),
                new THREE.Vector2( c.y, 1 - c.z ),
                new THREE.Vector2( d.y, 1 - d.z )
            ];

        }

    }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function( shapes, options ) {

    THREE.Geometry.call( this );

    this.type = 'ShapeGeometry';

    if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function( shapes, options ) {

    for ( var i = 0, l = shapes.length; i < l; i++ ) {

        this.addShape( shapes[ i ], options );

    }

    return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function( shape, options ) {

    if ( options === undefined ) options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    //

    var i, l, hole;

    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = !THREE.Shape.Utils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe...

        for ( i = 0, l = holes.length; i < l; i++ ) {

            hole = holes[ i ];

            if ( THREE.Shape.Utils.isClockWise( hole ) ) {

                holes[ i ] = hole.reverse();

            }

        }

        reverse = false;

    }

    var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

    // Vertices

    for ( i = 0, l = holes.length; i < l; i++ ) {

        hole = holes[ i ];
        vertices = vertices.concat( hole );

    }

    //

    var vert, vlen = vertices.length;
    var face, flen = faces.length;

    for ( i = 0; i < vlen; i++ ) {

        vert = vertices[ i ];

        this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

    }

    for ( i = 0; i < flen; i++ ) {

        face = faces[ i ];

        var a = face[ 0 ] + shapesOffset;
        var b = face[ 1 ] + shapesOffset;
        var c = face[ 2 ] + shapesOffset;

        this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
        this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function( points, segments, phiStart, phiLength ) {

    THREE.Geometry.call( this );

    this.type = 'LatheGeometry';

    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };

    segments = segments || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || 2 * Math.PI;

    var inversePointLength = 1.0 / ( points.length - 1 );
    var inverseSegments = 1.0 / segments;

    for ( var i = 0, il = segments; i <= il; i++ ) {

        var phi = phiStart + i * inverseSegments * phiLength;

        var c = Math.cos( phi ),
            s = Math.sin( phi );

        for ( var j = 0, jl = points.length; j < jl; j++ ) {

            var pt = points[ j ];

            var vertex = new THREE.Vector3();

            vertex.x = c * pt.x - s * pt.y;
            vertex.y = s * pt.x + c * pt.y;
            vertex.z = pt.z;

            this.vertices.push( vertex );

        }

    }

    var np = points.length;

    for ( var i = 0, il = segments; i < il; i++ ) {

        for ( var j = 0, jl = points.length - 1; j < jl; j++ ) {

            var base = j + np * i;
            var a = base;
            var b = base + np;
            var c = base + 1 + np;
            var d = base + 1;

            var u0 = i * inverseSegments;
            var v0 = j * inversePointLength;
            var u1 = u0 + inverseSegments;
            var v1 = v0 + inversePointLength;

            this.faces.push( new THREE.Face3( a, b, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u0, v0 ),
                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u0, v1 )

            ] );

            this.faces.push( new THREE.Face3( b, c, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u1, v1 ),
                new THREE.Vector2( u0, v1 )

            ] );


        }

    }

    this.mergeVertices();
    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function( width, height, widthSegments, heightSegments ) {

    THREE.Geometry.call( this );

    this.type = 'PlaneGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function() {

    var geometry = new THREE.PlaneGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.widthSegments,
        this.parameters.heightSegments
    );

    return geometry;

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function( width, height, widthSegments, heightSegments ) {

    THREE.BufferGeometry.call( this );

    this.type = 'PlaneBufferGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    var width_half = width / 2;
    var height_half = height / 2;

    var gridX = Math.floor( widthSegments ) || 1;
    var gridY = Math.floor( heightSegments ) || 1;

    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;

    var segment_width = width / gridX;
    var segment_height = height / gridY;

    var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    var normals = new Float32Array( gridX1 * gridY1 * 3 );
    var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    var offset = 0;
    var offset2 = 0;

    for ( var iy = 0; iy < gridY1; iy++ ) {

        var y = iy * segment_height - height_half;

        for ( var ix = 0; ix < gridX1; ix++ ) {

            var x = ix * segment_width - width_half;

            vertices[ offset ] = x;
            vertices[ offset + 1 ] = -y;

            normals[ offset + 2 ] = 1;

            uvs[ offset2 ] = ix / gridX;
            uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

            offset += 3;
            offset2 += 2;

        }

    }

    offset = 0;

    var indices = new( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    for ( var iy = 0; iy < gridY; iy++ ) {

        for ( var ix = 0; ix < gridX; ix++ ) {

            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * ( iy + 1 );
            var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
            var d = ( ix + 1 ) + gridX1 * iy;

            indices[ offset ] = a;
            indices[ offset + 1 ] = b;
            indices[ offset + 2 ] = d;

            indices[ offset + 3 ] = b;
            indices[ offset + 4 ] = c;
            indices[ offset + 5 ] = d;

            offset += 6;

        }

    }

    this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.PlaneBufferGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.widthSegments,
        this.parameters.heightSegments
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'RingGeometry';

    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    innerRadius = innerRadius || 0;
    outerRadius = outerRadius || 50;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

    var i, o, uvs = [],
        radius = innerRadius,
        radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

    for ( i = 0; i < phiSegments + 1; i++ ) {

        // concentric circles inside ring

        for ( o = 0; o < thetaSegments + 1; o++ ) {

            // number of segments per circle

            var vertex = new THREE.Vector3();
            var segment = thetaStart + o / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos( segment );
            vertex.y = radius * Math.sin( segment );

            this.vertices.push( vertex );
            uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

        }

        radius += radiusStep;

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 0; i < phiSegments; i++ ) {

        // concentric circles inside ring

        var thetaSegment = i * ( thetaSegments + 1 );

        for ( o = 0; o < thetaSegments; o++ ) {

            // number of segments per circle

            var segment = o + thetaSegment;

            var v1 = segment;
            var v2 = segment + thetaSegments + 1;
            var v3 = segment + thetaSegments + 2;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

            v1 = segment;
            v2 = segment + thetaSegments + 2;
            v3 = segment + 1;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

        }

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function() {

    var geometry = new THREE.RingGeometry(
        this.parameters.innerRadius,
        this.parameters.outerRadius,
        this.parameters.thetaSegments,
        this.parameters.phiSegments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'SphereGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function() {

    var geometry = new THREE.SphereGeometry(
        this.parameters.radius,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.phiStart,
        this.parameters.phiLength,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'SphereBufferGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;

    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    var thetaEnd = thetaStart + thetaLength;

    var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    var index = 0,
        vertices = [],
        normal = new THREE.Vector3();

    for ( var y = 0; y <= heightSegments; y++ ) {

        var verticesRow = [];

        var v = y / heightSegments;

        for ( var x = 0; x <= widthSegments; x++ ) {

            var u = x / widthSegments;

            var px = -radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
            var py = radius * Math.cos( thetaStart + v * thetaLength );
            var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

            normal.set( px, py, pz ).normalize();

            positions.setXYZ( index, px, py, pz );
            normals.setXYZ( index, normal.x, normal.y, normal.z );
            uvs.setXY( index, u, 1 - v );

            verticesRow.push( index );

            index++;

        }

        vertices.push( verticesRow );

    }

    var indices = [];

    for ( var y = 0; y < heightSegments; y++ ) {

        for ( var x = 0; x < widthSegments; x++ ) {

            var v1 = vertices[ y ][ x + 1 ];
            var v2 = vertices[ y ][ x ];
            var v3 = vertices[ y + 1 ][ x ];
            var v4 = vertices[ y + 1 ][ x + 1 ];

            if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
            if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

        }

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', positions );
    this.addAttribute( 'normal', normals );
    this.addAttribute( 'uv', uvs );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.SphereBufferGeometry(
        this.parameters.radius,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.phiStart,
        this.parameters.phiLength,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function( text, parameters ) {

    parameters = parameters || {};

    var textShapes = THREE.FontUtils.generateShapes( text, parameters );

    // translate parameters to ExtrudeGeometry API

    parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    // defaults

    if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    THREE.ExtrudeGeometry.call( this, textShapes, parameters );

    this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function( radius, tube, radialSegments, tubularSegments, arc ) {

    THREE.Geometry.call( this );

    this.type = 'TorusGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var center = new THREE.Vector3(),
        uvs = [],
        normals = [];

    for ( var j = 0; j <= radialSegments; j++ ) {

        for ( var i = 0; i <= tubularSegments; i++ ) {

            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            center.x = radius * Math.cos( u );
            center.y = radius * Math.sin( u );

            var vertex = new THREE.Vector3();
            vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            vertex.z = tube * Math.sin( v );

            this.vertices.push( vertex );

            uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
            normals.push( vertex.clone().sub( center ).normalize() );

        }

    }

    for ( var j = 1; j <= radialSegments; j++ ) {

        for ( var i = 1; i <= tubularSegments; i++ ) {

            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

            face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

        }

    }

    this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function() {

    var geometry = new THREE.TorusGeometry(
        this.parameters.radius,
        this.parameters.tube,
        this.parameters.radialSegments,
        this.parameters.tubularSegments,
        this.parameters.arc
    );

    return geometry;

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

    THREE.Geometry.call( this );

    this.type = 'TorusKnotGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 64;
    tubularSegments = tubularSegments || 8;
    p = p || 2;
    q = q || 3;
    heightScale = heightScale || 1;

    var grid = new Array( radialSegments );
    var tang = new THREE.Vector3();
    var n = new THREE.Vector3();
    var bitan = new THREE.Vector3();

    for ( var i = 0; i < radialSegments; ++i ) {

        grid[ i ] = new Array( tubularSegments );
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos( u, q, p, radius, heightScale );
        var p2 = getPos( u + 0.01, q, p, radius, heightScale );
        tang.subVectors( p2, p1 );
        n.addVectors( p2, p1 );

        bitan.crossVectors( tang, n );
        n.crossVectors( bitan, tang );
        bitan.normalize();
        n.normalize();

        for ( var j = 0; j < tubularSegments; ++j ) {

            var v = j / tubularSegments * 2 * Math.PI;
            var cx = -tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            var cy = tube * Math.sin( v );

            var pos = new THREE.Vector3();
            pos.x = p1.x + cx * n.x + cy * bitan.x;
            pos.y = p1.y + cx * n.y + cy * bitan.y;
            pos.z = p1.z + cx * n.z + cy * bitan.z;

            grid[ i ][ j ] = this.vertices.push( pos ) - 1;

        }

    }

    for ( var i = 0; i < radialSegments; ++i ) {

        for ( var j = 0; j < tubularSegments; ++j ) {

            var ip = ( i + 1 ) % radialSegments;
            var jp = ( j + 1 ) % tubularSegments;

            var a = grid[ i ][ j ];
            var b = grid[ ip ][ j ];
            var c = grid[ ip ][ jp ];
            var d = grid[ i ][ jp ];

            var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
            var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
            var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
            var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

    function getPos( u, in_q, in_p, radius, heightScale ) {

        var cu = Math.cos( u );
        var su = Math.sin( u );
        var quOverP = in_q / in_p * u;
        var cs = Math.cos( quOverP );

        var tx = radius * ( 2 + cs ) * 0.5 * cu;
        var ty = radius * ( 2 + cs ) * su * 0.5;
        var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

        return new THREE.Vector3( tx, ty, tz );

    }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function() {

    var geometry = new THREE.TorusKnotGeometry(
        this.parameters.radius,
        this.parameters.tube,
        this.parameters.radialSegments,
        this.parameters.tubularSegments,
        this.parameters.p,
        this.parameters.q,
        this.parameters.heightScale
    );

    return geometry;

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed, taper ) {

    THREE.Geometry.call( this );

    this.type = 'TubeGeometry';

    this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };

    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || THREE.TubeGeometry.NoTaper;

    var grid = [];

    var scope = this,

        tangent,
        normal,
        binormal,

        numpoints = segments + 1,

        u, v, r,

        cx, cy,
        pos, pos2 = new THREE.Vector3(),
        i, j,
        ip, jp,
        a, b, c, d,
        uva, uvb, uvc, uvd;

    var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
        tangents = frames.tangents,
        normals = frames.normals,
        binormals = frames.binormals;

    // proxy internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    function vert( x, y, z ) {

        return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

    }

    // construct the grid

    for ( i = 0; i < numpoints; i++ ) {

        grid[ i ] = [];

        u = i / ( numpoints - 1 );

        pos = path.getPointAt( u );

        tangent = tangents[ i ];
        normal = normals[ i ];
        binormal = binormals[ i ];

        r = radius * taper( u );

        for ( j = 0; j < radialSegments; j++ ) {

            v = j / radialSegments * 2 * Math.PI;

            cx = -r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            cy = r * Math.sin( v );

            pos2.copy( pos );
            pos2.x += cx * normal.x + cy * binormal.x;
            pos2.y += cx * normal.y + cy * binormal.y;
            pos2.z += cx * normal.z + cy * binormal.z;

            grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

        }

    }


    // construct the mesh

    for ( i = 0; i < segments; i++ ) {

        for ( j = 0; j < radialSegments; j++ ) {

            ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
            jp = ( j + 1 ) % radialSegments;

            a = grid[ i ][ j ]; // *** NOT NECESSARILY PLANAR ! ***
            b = grid[ ip ][ j ];
            c = grid[ ip ][ jp ];
            d = grid[ i ][ jp ];

            uva = new THREE.Vector2( i / segments, j / radialSegments );
            uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
            uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
            uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function( u ) {

    return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function( u ) {

    return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function( path, segments, closed ) {

    var normal = new THREE.Vector3(),

        tangents = [],
        normals = [],
        binormals = [],

        vec = new THREE.Vector3(),
        mat = new THREE.Matrix4(),

        numpoints = segments + 1,
        theta,
        epsilon = 0.0001,
        smallest,

        tx, ty, tz,
        i, u;


    // expose internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    // compute the tangent vectors for each segment on the path

    for ( i = 0; i < numpoints; i++ ) {

        u = i / ( numpoints - 1 );

        tangents[ i ] = path.getTangentAt( u );
        tangents[ i ].normalize();

    }

    initialNormal3();

    /*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

    function initialNormal3() {

        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the smallest tangent xyz component

        normals[ 0 ] = new THREE.Vector3();
        binormals[ 0 ] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs( tangents[ 0 ].x );
        ty = Math.abs( tangents[ 0 ].y );
        tz = Math.abs( tangents[ 0 ].z );

        if ( tx <= smallest ) {

            smallest = tx;
            normal.set( 1, 0, 0 );

        }

        if ( ty <= smallest ) {

            smallest = ty;
            normal.set( 0, 1, 0 );

        }

        if ( tz <= smallest ) {

            normal.set( 0, 0, 1 );

        }

        vec.crossVectors( tangents[ 0 ], normal ).normalize();

        normals[ 0 ].crossVectors( tangents[ 0 ], vec );
        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    }


    // compute the slowly-varying normal and binormal vectors for each segment on the path

    for ( i = 1; i < numpoints; i++ ) {

        normals[ i ] = normals[ i - 1 ].clone();

        binormals[ i ] = binormals[ i - 1 ].clone();

        vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

        if ( vec.length() > epsilon ) {

            vec.normalize();

            theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

            normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

        }

        binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }


    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    if ( closed ) {

        theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), -1, 1 ) );
        theta /= ( numpoints - 1 );

        if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

            theta = -theta;

        }

        for ( i = 1; i < numpoints; i++ ) {

            // twist a little...
            normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

        }

    }

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.PolyhedronGeometry = function( vertices, indices, radius, detail ) {

    THREE.Geometry.call( this );

    this.type = 'PolyhedronGeometry';

    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };

    radius = radius || 1;
    detail = detail || 0;

    var that = this;

    for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

        prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    }

    var p = this.vertices;

    var faces = [];

    for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j++ ) {

        var v1 = p[ indices[ i ] ];
        var v2 = p[ indices[ i + 1 ] ];
        var v3 = p[ indices[ i + 2 ] ];

        faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

    }

    var centroid = new THREE.Vector3();

    for ( var i = 0, l = faces.length; i < l; i++ ) {

        subdivide( faces[ i ], detail );

    }


    // Handle case when face straddles the seam

    for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i++ ) {

        var uvs = this.faceVertexUvs[ 0 ][ i ];

        var x0 = uvs[ 0 ].x;
        var x1 = uvs[ 1 ].x;
        var x2 = uvs[ 2 ].x;

        var max = Math.max( x0, Math.max( x1, x2 ) );
        var min = Math.min( x0, Math.min( x1, x2 ) );

        if ( max > 0.9 && min < 0.1 ) {

            // 0.9 is somewhat arbitrary

            if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
            if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
            if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

        }

    }


    // Apply radius

    for ( var i = 0, l = this.vertices.length; i < l; i++ ) {

        this.vertices[ i ].multiplyScalar( radius );

    }


    // Merge vertices

    this.mergeVertices();

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


    // Project vector onto sphere's surface

    function prepare( vector ) {

        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push( vertex ) - 1;

        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

        var u = azimuth( vector ) / 2 / Math.PI + 0.5;
        var v = inclination( vector ) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2( u, 1 - v );

        return vertex;

    }


    // Approximate a curved face with recursively sub-divided triangles.

    function make( v1, v2, v3, materialIndex ) {

        var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
        that.faces.push( face );

        centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

        var azi = azimuth( centroid );

        that.faceVertexUvs[ 0 ].push( [
            correctUV( v1.uv, v1, azi ),
            correctUV( v2.uv, v2, azi ),
            correctUV( v3.uv, v3, azi )
        ] );

    }


    // Analytically subdivide a face to the required detail level.

    function subdivide( face, detail ) {

        var cols = Math.pow( 2, detail );
        var a = prepare( that.vertices[ face.a ] );
        var b = prepare( that.vertices[ face.b ] );
        var c = prepare( that.vertices[ face.c ] );
        var v = [];

        var materialIndex = face.materialIndex;

        // Construct all of the vertices for this subdivision.

        for ( var i = 0; i <= cols; i++ ) {

            v[ i ] = [];

            var aj = prepare( a.clone().lerp( c, i / cols ) );
            var bj = prepare( b.clone().lerp( c, i / cols ) );
            var rows = cols - i;

            for ( var j = 0; j <= rows; j++ ) {

                if ( j === 0 && i === cols ) {

                    v[ i ][ j ] = aj;

                }
                else {

                    v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

                }

            }

        }

        // Construct all of the faces.

        for ( var i = 0; i < cols; i++ ) {

            for ( var j = 0; j < 2 * ( cols - i ) - 1; j++ ) {

                var k = Math.floor( j / 2 );

                if ( j % 2 === 0 ) {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        v[ i ][ k ],
                        materialIndex
                    );

                }
                else {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        materialIndex
                    );

                }

            }

        }

    }


    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth( vector ) {

        return Math.atan2( vector.z, -vector.x );

    }


    // Angle above the XZ plane.

    function inclination( vector ) {

        return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    }


    // Texture fixing helper. Spheres have some odd behaviours.

    function correctUV( uv, vector, azimuth ) {

        if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
        if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
        return uv.clone();

    }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function() {

    var geometry = new THREE.PolyhedronGeometry(
        this.parameters.vertices,
        this.parameters.indices,
        this.parameters.radius,
        this.parameters.detail
    );

    return geometry.copy( this );

};

THREE.PolyhedronGeometry.prototype.copy = function( source ) {

    THREE.Geometry.prototype.copy.call( this, source );
    return this;

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    var r = 1 / t;

    var vertices = [

        // (±1, ±1, ±1)
        -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1,
        1, -1, -1, 1, -1, 1,
        1, 1, -1, 1, 1, 1,

        // (0, ±1/φ, ±φ)
        0, -r, -t, 0, -r, t,
        0, r, -t, 0, r, t,

        // (±1/φ, ±φ, 0)
        -r, -t, 0, -r, t, 0,
        r, -t, 0, r, t, 0,

        // (±φ, 0, ±1/φ)
        -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r
    ];

    var indices = [
        3, 11, 7, 3, 7, 15, 3, 15, 13,
        7, 19, 17, 7, 17, 6, 7, 6, 15,
        17, 4, 8, 17, 8, 10, 17, 10, 6,
        8, 0, 16, 8, 16, 2, 8, 2, 10,
        0, 12, 1, 0, 1, 18, 0, 18, 16,
        6, 10, 2, 6, 2, 13, 6, 13, 15,
        2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3,
        4, 14, 12, 4, 12, 0, 4, 0, 8,
        11, 9, 5, 11, 5, 19, 11, 19, 7,
        19, 5, 14, 19, 14, 4, 19, 4, 17,
        1, 12, 14, 1, 14, 5, 1, 5, 9
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'DodecahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.DodecahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
        0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
        t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
    ];

    var indices = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
        1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
        3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'IcosahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.IcosahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function( radius, detail ) {

    var vertices = [
        1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1
    ];

    var indices = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'OctahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.OctahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function( radius, detail ) {

    var vertices = [
        1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
    ];

    var indices = [
        2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'TetrahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.TetrahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function( func, slices, stacks ) {

    THREE.Geometry.call( this );

    this.type = 'ParametricGeometry';

    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };

    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[ 0 ];

    var i, j, p;
    var u, v;

    var sliceCount = slices + 1;

    for ( i = 0; i <= stacks; i++ ) {

        v = i / stacks;

        for ( j = 0; j <= slices; j++ ) {

            u = j / slices;

            p = func( u, v );
            verts.push( p );

        }

    }

    var a, b, c, d;
    var uva, uvb, uvc, uvd;

    for ( i = 0; i < stacks; i++ ) {

        for ( j = 0; j < slices; j++ ) {

            a = i * sliceCount + j;
            b = i * sliceCount + j + 1;
            c = ( i + 1 ) * sliceCount + j + 1;
            d = ( i + 1 ) * sliceCount + j;

            uva = new THREE.Vector2( j / slices, i / stacks );
            uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
            uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
            uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

            faces.push( new THREE.Face3( a, b, d ) );
            uvs.push( [ uva, uvb, uvd ] );

            faces.push( new THREE.Face3( b, c, d ) );
            uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    // console.log(this);

    // magic bullet
    // var diff = this.mergeVertices();
    // console.log('removed ', diff, ' vertices by merging');

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function( geometry ) {

    THREE.BufferGeometry.call( this );

    var edge = [ 0, 0 ],
        hash = {};
    var sortFunction = function( a, b ) {

        return a - b;

    };

    var keys = [ 'a', 'b', 'c' ];

    if ( geometry instanceof THREE.Geometry ) {

        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;

        // allocate maximal size
        var edges = new Uint32Array( 6 * faces.length );

        for ( var i = 0, l = faces.length; i < l; i++ ) {

            var face = faces[ i ];

            for ( var j = 0; j < 3; j++ ) {

                edge[ 0 ] = face[ keys[ j ] ];
                edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
                edge.sort( sortFunction );

                var key = edge.toString();

                if ( hash[ key ] === undefined ) {

                    edges[ 2 * numEdges ] = edge[ 0 ];
                    edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                    hash[ key ] = true;
                    numEdges++;

                }

            }

        }

        var coords = new Float32Array( numEdges * 2 * 3 );

        for ( var i = 0, l = numEdges; i < l; i++ ) {

            for ( var j = 0; j < 2; j++ ) {

                var vertex = vertices[ edges[ 2 * i + j ] ];

                var index = 6 * i + 3 * j;
                coords[ index + 0 ] = vertex.x;
                coords[ index + 1 ] = vertex.y;
                coords[ index + 2 ] = vertex.z;

            }

        }

        this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }
    else if ( geometry instanceof THREE.BufferGeometry ) {

        if ( geometry.index !== null ) {

            // Indexed BufferGeometry

            var indices = geometry.index.array;
            var vertices = geometry.attributes.position;
            var drawcalls = geometry.drawcalls;
            var numEdges = 0;

            if ( drawcalls.length === 0 ) {

                geometry.addDrawCall( 0, indices.length );

            }

            // allocate maximal size
            var edges = new Uint32Array( 2 * indices.length );

            for ( var o = 0, ol = drawcalls.length; o < ol; ++o ) {

                var drawcall = drawcalls[ o ];

                var start = drawcall.start;
                var count = drawcall.count;

                for ( var i = start, il = start + count; i < il; i += 3 ) {

                    for ( var j = 0; j < 3; j++ ) {

                        edge[ 0 ] = indices[ i + j ];
                        edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
                        edge.sort( sortFunction );

                        var key = edge.toString();

                        if ( hash[ key ] === undefined ) {

                            edges[ 2 * numEdges ] = edge[ 0 ];
                            edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                            hash[ key ] = true;
                            numEdges++;

                        }

                    }

                }

            }

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numEdges; i < l; i++ ) {

                for ( var j = 0; j < 2; j++ ) {

                    var index = 6 * i + 3 * j;
                    var index2 = edges[ 2 * i + j ];

                    coords[ index + 0 ] = vertices.getX( index2 );
                    coords[ index + 1 ] = vertices.getY( index2 );
                    coords[ index + 2 ] = vertices.getZ( index2 );

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }
        else {

            // non-indexed BufferGeometry

            var vertices = geometry.attributes.position.array;
            var numEdges = vertices.length / 3;
            var numTris = numEdges / 3;

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numTris; i < l; i++ ) {

                for ( var j = 0; j < 3; j++ ) {

                    var index = 18 * i + 6 * j;

                    var index1 = 9 * i + 3 * j;
                    coords[ index + 0 ] = vertices[ index1 ];
                    coords[ index + 1 ] = vertices[ index1 + 1 ];
                    coords[ index + 2 ] = vertices[ index1 + 2 ];

                    var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
                    coords[ index + 3 ] = vertices[ index2 ];
                    coords[ index + 4 ] = vertices[ index2 + 1 ];
                    coords[ index + 5 ] = vertices[ index2 + 2 ];

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }

    }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function( size ) {

    size = size || 1;

    var vertices = new Float32Array( [
        0, 0, 0, size, 0, 0,
        0, 0, 0, 0, size, 0,
        0, 0, 0, 0, 0, size
    ] );

    var colors = new Float32Array( [
        1, 0, 0, 1, 0.6, 0,
        0, 1, 0, 0.6, 1, 0,
        0, 0, 1, 0, 0.6, 1
    ] );

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors
    } );

    THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function() {

    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

    var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, -0.5, 0 );

    return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

        // dir is assumed to be normalized

        THREE.Object3D.call( this );

        if ( color === undefined ) color = 0xffff00;
        if ( length === undefined ) length = 1;
        if ( headLength === undefined ) headLength = 0.2 * length;
        if ( headWidth === undefined ) headWidth = 0.2 * headLength;

        this.position.copy( origin );

        if ( headLength < length ) {
            this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( {
                color: color
            } ) );
            this.line.matrixAutoUpdate = false;
            this.add( this.line );
        }

        this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( {
            color: color
        } ) );
        this.cone.matrixAutoUpdate = false;
        this.add( this.cone );

        this.setDirection( dir );
        this.setLength( length, headLength, headWidth );

    }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function() {

    var axis = new THREE.Vector3();
    var radians;

    return function setDirection( dir ) {

        // dir is assumed to be normalized

        if ( dir.y > 0.99999 ) {

            this.quaternion.set( 0, 0, 0, 1 );

        }
        else if ( dir.y < -0.99999 ) {

            this.quaternion.set( 1, 0, 0, 0 );

        }
        else {

            axis.set( dir.z, 0, -dir.x ).normalize();

            radians = Math.acos( dir.y );

            this.quaternion.setFromAxisAngle( axis, radians );

        }

    };

}() );

THREE.ArrowHelper.prototype.setLength = function( length, headLength, headWidth ) {

    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    if ( headLength < length ) {
        this.line.scale.set( 1, length - headLength, 1 );
        this.line.updateMatrix();
    }

    this.cone.scale.set( headWidth, headLength, headWidth );
    this.cone.position.y = length;
    this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function( color ) {

    if ( this.line !== undefined ) this.line.material.color.set( color );
    this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function( object ) {

    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    var positions = new Float32Array( 8 * 3 );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: 0xffff00
    } ) );

    if ( object !== undefined ) {

        this.update( object );

    }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function() {

    var box = new THREE.Box3();

    return function( object ) {

        box.setFromObject( object );

        if ( box.empty() ) return;

        var min = box.min;
        var max = box.max;

        /*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

        var position = this.geometry.attributes.position;
        var array = position.array;

        array[ 0 ] = max.x;
        array[ 1 ] = max.y;
        array[ 2 ] = max.z;
        array[ 3 ] = min.x;
        array[ 4 ] = max.y;
        array[ 5 ] = max.z;
        array[ 6 ] = min.x;
        array[ 7 ] = min.y;
        array[ 8 ] = max.z;
        array[ 9 ] = max.x;
        array[ 10 ] = min.y;
        array[ 11 ] = max.z;
        array[ 12 ] = max.x;
        array[ 13 ] = max.y;
        array[ 14 ] = min.z;
        array[ 15 ] = min.x;
        array[ 16 ] = max.y;
        array[ 17 ] = min.z;
        array[ 18 ] = min.x;
        array[ 19 ] = min.y;
        array[ 20 ] = min.z;
        array[ 21 ] = max.x;
        array[ 22 ] = min.y;
        array[ 23 ] = min.z;

        position.needsUpdate = true;

        this.geometry.computeBoundingSphere();

    }

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0x888888;

    this.object = object;

    this.box = new THREE.Box3();

    THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( {
        color: color,
        wireframe: true
    } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function() {

    this.box.setFromObject( this.object );

    this.box.size( this.scale );

    this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function( camera ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( {
        color: 0xffffff,
        vertexColors: THREE.FaceColors
    } );

    var pointMap = {};

    // colors

    var hexFrustum = 0xffaa00;
    var hexCone = 0xff0000;
    var hexUp = 0x00aaff;
    var hexTarget = 0xffffff;
    var hexCross = 0x333333;

    // near

    addLine( "n1", "n2", hexFrustum );
    addLine( "n2", "n4", hexFrustum );
    addLine( "n4", "n3", hexFrustum );
    addLine( "n3", "n1", hexFrustum );

    // far

    addLine( "f1", "f2", hexFrustum );
    addLine( "f2", "f4", hexFrustum );
    addLine( "f4", "f3", hexFrustum );
    addLine( "f3", "f1", hexFrustum );

    // sides

    addLine( "n1", "f1", hexFrustum );
    addLine( "n2", "f2", hexFrustum );
    addLine( "n3", "f3", hexFrustum );
    addLine( "n4", "f4", hexFrustum );

    // cone

    addLine( "p", "n1", hexCone );
    addLine( "p", "n2", hexCone );
    addLine( "p", "n3", hexCone );
    addLine( "p", "n4", hexCone );

    // up

    addLine( "u1", "u2", hexUp );
    addLine( "u2", "u3", hexUp );
    addLine( "u3", "u1", hexUp );

    // target

    addLine( "c", "t", hexTarget );
    addLine( "p", "c", hexCross );

    // cross

    addLine( "cn1", "cn2", hexCross );
    addLine( "cn3", "cn4", hexCross );

    addLine( "cf1", "cf2", hexCross );
    addLine( "cf3", "cf4", hexCross );

    function addLine( a, b, hex ) {

        addPoint( a, hex );
        addPoint( b, hex );

    }

    function addPoint( id, hex ) {

        geometry.vertices.push( new THREE.Vector3() );
        geometry.colors.push( new THREE.Color( hex ) );

        if ( pointMap[ id ] === undefined ) {

            pointMap[ id ] = [];

        }

        pointMap[ id ].push( geometry.vertices.length - 1 );

    }

    THREE.LineSegments.call( this, geometry, material );

    this.camera = camera;
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;

    this.pointMap = pointMap;

    this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function() {

    var geometry, pointMap;

    var vector = new THREE.Vector3();
    var camera = new THREE.Camera();

    var setPoint = function( point, x, y, z ) {

        vector.set( x, y, z ).unproject( camera );

        var points = pointMap[ point ];

        if ( points !== undefined ) {

            for ( var i = 0, il = points.length; i < il; i++ ) {

                geometry.vertices[ points[ i ] ].copy( vector );

            }

        }

    };

    return function() {

        geometry = this.geometry;
        pointMap = this.pointMap;

        var w = 1,
            h = 1;

        // we need just camera projection matrix
        // world matrix must be identity

        camera.projectionMatrix.copy( this.camera.projectionMatrix );

        // center / target

        setPoint( "c", 0, 0, -1 );
        setPoint( "t", 0, 0, 1 );

        // near

        setPoint( "n1", -w, -h, -1 );
        setPoint( "n2", w, -h, -1 );
        setPoint( "n3", -w, h, -1 );
        setPoint( "n4", w, h, -1 );

        // far

        setPoint( "f1", -w, -h, 1 );
        setPoint( "f2", w, -h, 1 );
        setPoint( "f3", -w, h, 1 );
        setPoint( "f4", w, h, 1 );

        // up

        setPoint( "u1", w * 0.7, h * 1.1, -1 );
        setPoint( "u2", -w * 0.7, h * 1.1, -1 );
        setPoint( "u3", 0, h * 2, -1 );

        // cross

        setPoint( "cf1", -w, 0, 1 );
        setPoint( "cf2", w, 0, 1 );
        setPoint( "cf3", 0, -h, 1 );
        setPoint( "cf4", 0, h, 1 );

        setPoint( "cn1", -w, 0, -1 );
        setPoint( "cn2", w, 0, -1 );
        setPoint( "cn3", 0, -h, -1 );
        setPoint( "cn4", 0, h, -1 );

        geometry.verticesNeedUpdate = true;

    };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function( light, size ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    size = size || 1;

    var geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3( -size, size, 0 ),
        new THREE.Vector3( size, size, 0 ),
        new THREE.Vector3( size, -size, 0 ),
        new THREE.Vector3( -size, -size, 0 ),
        new THREE.Vector3( -size, size, 0 )
    );

    var material = new THREE.LineBasicMaterial( {
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.lightPlane = new THREE.Line( geometry, material );
    this.add( this.lightPlane );

    geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3(),
        new THREE.Vector3()
    );

    material = new THREE.LineBasicMaterial( {
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine = new THREE.Line( geometry, material );
    this.add( this.targetLine );

    this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function() {

    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v3 = new THREE.Vector3();

    return function() {

        v1.setFromMatrixPosition( this.light.matrixWorld );
        v2.setFromMatrixPosition( this.light.target.matrixWorld );
        v3.subVectors( v2, v1 );

        this.lightPlane.lookAt( v3 );
        this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

        this.targetLine.geometry.vertices[ 1 ].copy( v3 );
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy( this.lightPlane.material.color );

    };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function( object, hex, thresholdAngle ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( {
        color: color
    } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.FaceNormalsHelper = function( object, size, hex, linewidth ) {

    // FaceNormalsHelper only supports THREE.Geometry

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length;

    }
    else {

        console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: color,
        linewidth: width
    } ) );

    //

    this.matrixAutoUpdate = false;
    this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        var vertices = objGeometry.vertices;

        var faces = objGeometry.faces;

        var idx = 0;

        for ( var i = 0, l = faces.length; i < l; i++ ) {

            var face = faces[ i ];

            var normal = face.normal;

            v1.copy( vertices[ face.a ] )
                .add( vertices[ face.b ] )
                .add( vertices[ face.c ] )
                .divideScalar( 3 )
                .applyMatrix4( matrixWorld );

            v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

            position.setXYZ( idx, v1.x, v1.y, v1.z );

            idx = idx + 1;

            position.setXYZ( idx, v2.x, v2.y, v2.z );

            idx = idx + 1;

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function( size, step ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors
    } );

    this.color1 = new THREE.Color( 0x444444 );
    this.color2 = new THREE.Color( 0x888888 );

    for ( var i = -size; i <= size; i += step ) {

        geometry.vertices.push(
            new THREE.Vector3( -size, 0, i ), new THREE.Vector3( size, 0, i ),
            new THREE.Vector3( i, 0, -size ), new THREE.Vector3( i, 0, size )
        );

        var color = i === 0 ? this.color1 : this.color2;

        geometry.colors.push( color, color, color, color );

    }

    THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

    this.color1.set( colorCenterLine );
    this.color2.set( colorGrid );

    this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function( light, sphereSize ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.colors = [ new THREE.Color(), new THREE.Color() ];

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    geometry.rotateX( -Math.PI / 2 );

    for ( var i = 0, il = 8; i < il; i++ ) {

        geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    }

    var material = new THREE.MeshBasicMaterial( {
        vertexColors: THREE.FaceColors,
        wireframe: true
    } );

    this.lightSphere = new THREE.Mesh( geometry, material );
    this.add( this.lightSphere );

    this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function() {

    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function() {

    var vector = new THREE.Vector3();

    return function() {

        this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
        this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

        this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
        this.lightSphere.geometry.colorsNeedUpdate = true;

    }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function( light, sphereSize ) {

    this.light = light;
    this.light.updateMatrixWorld();

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    var material = new THREE.MeshBasicMaterial( {
        wireframe: true,
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    THREE.Mesh.call( this, geometry, material );

    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;

    /*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function() {

    this.geometry.dispose();
    this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function() {

    this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    /*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function( object ) {

    this.bones = this.getBoneList( object );

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < this.bones.length; i++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            geometry.vertices.push( new THREE.Vector3() );
            geometry.vertices.push( new THREE.Vector3() );
            geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
            geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

        }

    }

    geometry.dynamic = true;

    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
    } );

    THREE.LineSegments.call( this, geometry, material );

    this.root = object;

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

    this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

    var boneList = [];

    if ( object instanceof THREE.Bone ) {

        boneList.push( object );

    }

    for ( var i = 0; i < object.children.length; i++ ) {

        boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    }

    return boneList;

};

THREE.SkeletonHelper.prototype.update = function() {

    var geometry = this.geometry;

    var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

    var boneMatrix = new THREE.Matrix4();

    var j = 0;

    for ( var i = 0; i < this.bones.length; i++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
            geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
            geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

            j += 2;

        }

    }

    geometry.verticesNeedUpdate = true;

    geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.SpotLightHelper = function( light ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

    geometry.translate( 0, -0.5, 0 );
    geometry.rotateX( -Math.PI / 2 );

    var material = new THREE.MeshBasicMaterial( {
        wireframe: true,
        fog: false
    } );

    this.cone = new THREE.Mesh( geometry, material );
    this.add( this.cone );

    this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function() {

    this.cone.geometry.dispose();
    this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function() {

    var vector = new THREE.Vector3();
    var vector2 = new THREE.Vector3();

    return function() {

        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan( this.light.angle );

        this.cone.scale.set( coneWidth, coneWidth, coneLength );

        vector.setFromMatrixPosition( this.light.matrixWorld );
        vector2.setFromMatrixPosition( this.light.target.matrixWorld );

        this.cone.lookAt( vector2.sub( vector ) );

        this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.VertexNormalsHelper = function( object, size, hex, linewidth ) {

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xff0000;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length * 3;

    }
    else if ( objGeometry instanceof THREE.BufferGeometry ) {

        nNormals = objGeometry.attributes.normal.count

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: color,
        linewidth: width
    } ) );

    //

    this.matrixAutoUpdate = false;

    this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        var keys = [ 'a', 'b', 'c' ];

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        if ( objGeometry instanceof THREE.Geometry ) {

            var vertices = objGeometry.vertices;

            var faces = objGeometry.faces;

            var idx = 0;

            for ( var i = 0, l = faces.length; i < l; i++ ) {

                var face = faces[ i ];

                for ( var j = 0, jl = face.vertexNormals.length; j < jl; j++ ) {

                    var vertex = vertices[ face[ keys[ j ] ] ];

                    var normal = face.vertexNormals[ j ];

                    v1.copy( vertex ).applyMatrix4( matrixWorld );

                    v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                    position.setXYZ( idx, v1.x, v1.y, v1.z );

                    idx = idx + 1;

                    position.setXYZ( idx, v2.x, v2.y, v2.z );

                    idx = idx + 1;

                }

            }

        }
        else if ( objGeometry instanceof THREE.BufferGeometry ) {

            var objPos = objGeometry.attributes.position;

            var objNorm = objGeometry.attributes.normal;

            var idx = 0;

            // for simplicity, ignore index and drawcalls, and render every normal

            for ( var j = 0, jl = objPos.count; j < jl; j++ ) {

                v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

                v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

                v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                position.setXYZ( idx, v1.x, v1.y, v1.z );

                idx = idx + 1;

                position.setXYZ( idx, v2.x, v2.y, v2.z );

                idx = idx + 1;

            }

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( {
        color: color
    } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function() {

    THREE.Object3D.call( this );

    this.render = function( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.animationsMap = {};
    this.animationsList = [];

    // prepare default animation
    // (all frames played together in 1 second)

    var numFrames = this.geometry.morphTargets.length;

    var name = "__default";

    var startFrame = 0;
    var endFrame = numFrames - 1;

    var fps = numFrames / 1;

    this.createAnimation( name, startFrame, endFrame, fps );
    this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function( name, start, end, fps ) {

    var animation = {

        start: start,
        end: end,

        length: end - start + 1,

        fps: fps,
        duration: ( end - start ) / fps,

        lastFrame: 0,
        currentFrame: 0,

        active: false,

        time: 0,
        direction: 1,
        weight: 1,

        directionBackwards: false,
        mirroredLoop: false

    };

    this.animationsMap[ name ] = animation;
    this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function( fps ) {

    var pattern = /([a-z]+)_?(\d+)/;

    var firstAnimation, frameRanges = {};

    var geometry = this.geometry;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i++ ) {

        var morph = geometry.morphTargets[ i ];
        var chunks = morph.name.match( pattern );

        if ( chunks && chunks.length > 1 ) {

            var name = chunks[ 1 ];

            if ( !frameRanges[ name ] ) frameRanges[ name ] = {
                start: Infinity,
                end: -Infinity
            };

            var range = frameRanges[ name ];

            if ( i < range.start ) range.start = i;
            if ( i > range.end ) range.end = i;

            if ( !firstAnimation ) firstAnimation = name;

        }

    }

    for ( var name in frameRanges ) {

        var range = frameRanges[ name ];
        this.createAnimation( name, range.start, range.end, fps );

    }

    this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = 1;
        animation.directionBackwards = false;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = -1;
        animation.directionBackwards = true;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function( name, fps ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.fps = fps;
        animation.duration = ( animation.end - animation.start ) / animation.fps;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function( name, duration ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.duration = duration;
        animation.fps = ( animation.end - animation.start ) / animation.duration;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function( name, weight ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.weight = weight;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function( name, time ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = time;

    }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function( name ) {

    var time = 0;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        time = animation.time;

    }

    return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function( name ) {

    var duration = -1;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        duration = animation.duration;

    }

    return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = 0;
        animation.active = true;

    }
    else {

        console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.active = false;

    }

};

THREE.MorphBlendMesh.prototype.update = function( delta ) {

    for ( var i = 0, il = this.animationsList.length; i < il; i++ ) {

        var animation = this.animationsList[ i ];

        if ( !animation.active ) continue;

        var frameTime = animation.duration / animation.length;

        animation.time += animation.direction * delta;

        if ( animation.mirroredLoop ) {

            if ( animation.time > animation.duration || animation.time < 0 ) {

                animation.direction *= -1;

                if ( animation.time > animation.duration ) {

                    animation.time = animation.duration;
                    animation.directionBackwards = true;

                }

                if ( animation.time < 0 ) {

                    animation.time = 0;
                    animation.directionBackwards = false;

                }

            }

        }
        else {

            animation.time = animation.time % animation.duration;

            if ( animation.time < 0 ) animation.time += animation.duration;

        }

        var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
        var weight = animation.weight;

        if ( keyframe !== animation.currentFrame ) {

            this.morphTargetInfluences[ animation.lastFrame ] = 0;
            this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

            this.morphTargetInfluences[ keyframe ] = 0;

            animation.lastFrame = animation.currentFrame;
            animation.currentFrame = keyframe;

        }

        var mix = ( animation.time % frameTime ) / frameTime;

        if ( animation.directionBackwards ) mix = 1 - mix;

        if ( animation.currentFrame !== animation.lastFrame ) {

            this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
            this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

        }
        else {

            this.morphTargetInfluences[ animation.currentFrame ] = weight;

        }

    }

};
},{}],"TextLayer":[function(require,module,exports){
var TextLayer, convertTextLayers, convertToTextLayer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

TextLayer = (function(superClass) {
  extend(TextLayer, superClass);

  function TextLayer(options) {
    if (options == null) {
      options = {};
    }
    this.doAutoSize = false;
    this.doAutoSizeHeight = false;
    if (options.backgroundColor == null) {
      options.backgroundColor = options.setup ? "hsla(60, 90%, 47%, .4)" : "transparent";
    }
    if (options.color == null) {
      options.color = "red";
    }
    if (options.lineHeight == null) {
      options.lineHeight = 1.25;
    }
    if (options.fontFamily == null) {
      options.fontFamily = "Helvetica";
    }
    if (options.fontSize == null) {
      options.fontSize = 20;
    }
    if (options.text == null) {
      options.text = "Use layer.text to add text";
    }
    TextLayer.__super__.constructor.call(this, options);
    this.style.whiteSpace = "pre-line";
    this.style.outline = "none";
  }

  TextLayer.prototype.setStyle = function(property, value, pxSuffix) {
    if (pxSuffix == null) {
      pxSuffix = false;
    }
    this.style[property] = pxSuffix ? value + "px" : value;
    this.emit("change:" + property, value);
    if (this.doAutoSize) {
      return this.calcSize();
    }
  };

  TextLayer.prototype.calcSize = function() {
    var constraints, size, sizeAffectingStyles;
    sizeAffectingStyles = {
      lineHeight: this.style["line-height"],
      fontSize: this.style["font-size"],
      fontWeight: this.style["font-weight"],
      paddingTop: this.style["padding-top"],
      paddingRight: this.style["padding-right"],
      paddingBottom: this.style["padding-bottom"],
      paddingLeft: this.style["padding-left"],
      textTransform: this.style["text-transform"],
      borderWidth: this.style["border-width"],
      letterSpacing: this.style["letter-spacing"],
      fontFamily: this.style["font-family"],
      fontStyle: this.style["font-style"],
      fontVariant: this.style["font-variant"]
    };
    constraints = {};
    if (this.doAutoSizeHeight) {
      constraints.width = this.width;
    }
    size = Utils.textSize(this.text, sizeAffectingStyles, constraints);
    if (this.style.textAlign === "right") {
      this.width = size.width;
      this.x = this.x - this.width;
    } else {
      this.width = size.width;
    }
    return this.height = size.height;
  };

  TextLayer.define("autoSize", {
    get: function() {
      return this.doAutoSize;
    },
    set: function(value) {
      this.doAutoSize = value;
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("autoSizeHeight", {
    set: function(value) {
      this.doAutoSize = value;
      this.doAutoSizeHeight = value;
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("contentEditable", {
    set: function(boolean) {
      this._element.contentEditable = boolean;
      this.ignoreEvents = !boolean;
      return this.on("input", function() {
        if (this.doAutoSize) {
          return this.calcSize();
        }
      });
    }
  });

  TextLayer.define("text", {
    get: function() {
      return this._element.textContent;
    },
    set: function(value) {
      this._element.textContent = value;
      this.emit("change:text", value);
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("fontFamily", {
    get: function() {
      return this.style.fontFamily;
    },
    set: function(value) {
      return this.setStyle("fontFamily", value);
    }
  });

  TextLayer.define("fontSize", {
    get: function() {
      return this.style.fontSize.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("fontSize", value, true);
    }
  });

  TextLayer.define("lineHeight", {
    get: function() {
      return this.style.lineHeight;
    },
    set: function(value) {
      return this.setStyle("lineHeight", value);
    }
  });

  TextLayer.define("fontWeight", {
    get: function() {
      return this.style.fontWeight;
    },
    set: function(value) {
      return this.setStyle("fontWeight", value);
    }
  });

  TextLayer.define("fontStyle", {
    get: function() {
      return this.style.fontStyle;
    },
    set: function(value) {
      return this.setStyle("fontStyle", value);
    }
  });

  TextLayer.define("fontVariant", {
    get: function() {
      return this.style.fontVariant;
    },
    set: function(value) {
      return this.setStyle("fontVariant", value);
    }
  });

  TextLayer.define("padding", {
    set: function(value) {
      this.setStyle("paddingTop", value, true);
      this.setStyle("paddingRight", value, true);
      this.setStyle("paddingBottom", value, true);
      return this.setStyle("paddingLeft", value, true);
    }
  });

  TextLayer.define("paddingTop", {
    get: function() {
      return this.style.paddingTop.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingTop", value, true);
    }
  });

  TextLayer.define("paddingRight", {
    get: function() {
      return this.style.paddingRight.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingRight", value, true);
    }
  });

  TextLayer.define("paddingBottom", {
    get: function() {
      return this.style.paddingBottom.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingBottom", value, true);
    }
  });

  TextLayer.define("paddingLeft", {
    get: function() {
      return this.style.paddingLeft.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingLeft", value, true);
    }
  });

  TextLayer.define("textAlign", {
    set: function(value) {
      return this.setStyle("textAlign", value);
    }
  });

  TextLayer.define("textTransform", {
    get: function() {
      return this.style.textTransform;
    },
    set: function(value) {
      return this.setStyle("textTransform", value);
    }
  });

  TextLayer.define("letterSpacing", {
    get: function() {
      return this.style.letterSpacing.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("letterSpacing", value, true);
    }
  });

  TextLayer.define("length", {
    get: function() {
      return this.text.length;
    }
  });

  return TextLayer;

})(Layer);

convertToTextLayer = function(layer, debug) {
  var css, key, styleObj, t, val;
  t = new TextLayer({
    name: layer.name,
    frame: layer.frame,
    parent: layer.parent,
    text: layer._info.metadata.string
  });
  styleObj = {};
  css = layer._info.metadata.css;
  css.forEach(function(rule) {
    var arr, prop, value;
    if (_.includes(rule, '/*')) {
      return;
    }
    arr = rule.split(': ');
    prop = _.camelCase(arr[0]);
    value = arr[1].replace(';', '');
    if (["fontSize", "letterSpacing", "lineHeight"].indexOf(prop) > -1) {
      value = parseInt(value);
    }
    return styleObj[prop] = value;
  });
  if (styleObj.hasOwnProperty("lineHeight")) {
    styleObj["lineHeight"] = styleObj.lineHeight / styleObj.fontSize;
  } else {
    styleObj["lineHeight"] = 1.3;
  }
  for (key in styleObj) {
    val = styleObj[key];
    t[key] = val;
  }
  t.y -= (t.fontSize / t.lineHeight) / (4 - t.lineHeight);
  t.x -= t.fontSize * 0.07;
  t.width += t.fontSize * 0.5;
  if (debug) {
    layer.opacity = .5;
  } else {
    layer.destroy();
  }
  return t;
};

Layer.prototype.convertToTextLayer = function(debug) {
  return convertToTextLayer(this, debug);
};

convertTextLayers = function(obj, debug) {
  var layer, prop, results;
  results = [];
  for (prop in obj) {
    layer = obj[prop];
    if (layer._info.kind === "text") {
      results.push(obj[prop] = convertToTextLayer(layer, debug));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

Layer.prototype.frameAsTextLayer = function(properties) {
  var t;
  t = new TextLayer;
  t.frame = this.frame;
  t.superLayer = this.superLayer;
  _.extend(t, properties);
  this.destroy();
  return t;
};

exports.TextLayer = TextLayer;

exports.convertTextLayers = convertTextLayers;


},{}],"d3-min":[function(require,module,exports){
// https://d3js.org Version 4.12.2. Copyright 2017 Mike Bostock.
(function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.d3=t.d3||{})})(this,function(t){"use strict";function n(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function e(t){return 1===t.length&&(t=function(t){return function(e,r){return n(t(e),r)}}(t)),{left:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)<0?r=o+1:i=o}return r},right:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)>0?i=o:r=o+1}return r}}}function r(t,n){return[t,n]}function i(t){return null===t?NaN:+t}function o(t,n){var e,r,o=t.length,u=0,a=-1,c=0,s=0;if(null==n)for(;++a<o;)isNaN(e=i(t[a]))||(s+=(r=e-c)*(e-(c+=r/++u)));else for(;++a<o;)isNaN(e=i(n(t[a],a,t)))||(s+=(r=e-c)*(e-(c+=r/++u)));if(u>1)return s/(u-1)}function u(t,n){var e=o(t,n);return e?Math.sqrt(e):e}function a(t,n){var e,r,i,o=t.length,u=-1;if(null==n){for(;++u<o;)if(null!=(e=t[u])&&e>=e)for(r=i=e;++u<o;)null!=(e=t[u])&&(r>e&&(r=e),i<e&&(i=e))}else for(;++u<o;)if(null!=(e=n(t[u],u,t))&&e>=e)for(r=i=e;++u<o;)null!=(e=n(t[u],u,t))&&(r>e&&(r=e),i<e&&(i=e));return[r,i]}function c(t){return function(){return t}}function s(t){return t}function f(t,n,e){t=+t,n=+n,e=(i=arguments.length)<2?(n=t,t=0,1):i<3?1:+e;for(var r=-1,i=0|Math.max(0,Math.ceil((n-t)/e)),o=new Array(i);++r<i;)o[r]=t+r*e;return o}function l(t,n,e){var r,i,o,u,a=-1;if(n=+n,t=+t,e=+e,t===n&&e>0)return[t];if((r=n<t)&&(i=t,t=n,n=i),0===(u=h(t,n,e))||!isFinite(u))return[];if(u>0)for(t=Math.ceil(t/u),n=Math.floor(n/u),o=new Array(i=Math.ceil(n-t+1));++a<i;)o[a]=(t+a)*u;else for(t=Math.floor(t*u),n=Math.ceil(n*u),o=new Array(i=Math.ceil(t-n+1));++a<i;)o[a]=(t-a)/u;return r&&o.reverse(),o}function h(t,n,e){var r=(n-t)/Math.max(0,e),i=Math.floor(Math.log(r)/Math.LN10),o=r/Math.pow(10,i);return i>=0?(o>=Ys?10:o>=Bs?5:o>=Hs?2:1)*Math.pow(10,i):-Math.pow(10,-i)/(o>=Ys?10:o>=Bs?5:o>=Hs?2:1)}function p(t,n,e){var r=Math.abs(n-t)/Math.max(0,e),i=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),o=r/i;return o>=Ys?i*=10:o>=Bs?i*=5:o>=Hs&&(i*=2),n<t?-i:i}function d(t){return Math.ceil(Math.log(t.length)/Math.LN2)+1}function v(t,n,e){if(null==e&&(e=i),r=t.length){if((n=+n)<=0||r<2)return+e(t[0],0,t);if(n>=1)return+e(t[r-1],r-1,t);var r,o=(r-1)*n,u=Math.floor(o),a=+e(t[u],u,t);return a+(+e(t[u+1],u+1,t)-a)*(o-u)}}function g(t){for(var n,e,r,i=t.length,o=-1,u=0;++o<i;)u+=t[o].length;for(e=new Array(u);--i>=0;)for(n=(r=t[i]).length;--n>=0;)e[--u]=r[n];return e}function _(t,n){var e,r,i=t.length,o=-1;if(null==n){for(;++o<i;)if(null!=(e=t[o])&&e>=e)for(r=e;++o<i;)null!=(e=t[o])&&r>e&&(r=e)}else for(;++o<i;)if(null!=(e=n(t[o],o,t))&&e>=e)for(r=e;++o<i;)null!=(e=n(t[o],o,t))&&r>e&&(r=e);return r}function y(t){if(!(i=t.length))return[];for(var n=-1,e=_(t,m),r=new Array(e);++n<e;)for(var i,o=-1,u=r[n]=new Array(i);++o<i;)u[o]=t[o][n];return r}function m(t){return t.length}function x(t){return t}function b(t){return"translate("+(t+.5)+",0)"}function w(t){return"translate(0,"+(t+.5)+")"}function M(){return!this.__axis}function T(t,n){function e(e){var h=null==i?n.ticks?n.ticks.apply(n,r):n.domain():i,p=null==o?n.tickFormat?n.tickFormat.apply(n,r):x:o,d=Math.max(u,0)+c,v=n.range(),g=+v[0]+.5,_=+v[v.length-1]+.5,y=(n.bandwidth?function(t){var n=Math.max(0,t.bandwidth()-1)/2;return t.round()&&(n=Math.round(n)),function(e){return+t(e)+n}}:function(t){return function(n){return+t(n)}})(n.copy()),m=e.selection?e.selection():e,b=m.selectAll(".domain").data([null]),w=m.selectAll(".tick").data(h,n).order(),T=w.exit(),N=w.enter().append("g").attr("class","tick"),k=w.select("line"),S=w.select("text");b=b.merge(b.enter().insert("path",".tick").attr("class","domain").attr("stroke","#000")),w=w.merge(N),k=k.merge(N.append("line").attr("stroke","#000").attr(f+"2",s*u)),S=S.merge(N.append("text").attr("fill","#000").attr(f,s*d).attr("dy",t===Xs?"0em":t===$s?"0.71em":"0.32em")),e!==m&&(b=b.transition(e),w=w.transition(e),k=k.transition(e),S=S.transition(e),T=T.transition(e).attr("opacity",Zs).attr("transform",function(t){return isFinite(t=y(t))?l(t):this.getAttribute("transform")}),N.attr("opacity",Zs).attr("transform",function(t){var n=this.parentNode.__axis;return l(n&&isFinite(n=n(t))?n:y(t))})),T.remove(),b.attr("d",t===Ws||t==Vs?"M"+s*a+","+g+"H0.5V"+_+"H"+s*a:"M"+g+","+s*a+"V0.5H"+_+"V"+s*a),w.attr("opacity",1).attr("transform",function(t){return l(y(t))}),k.attr(f+"2",s*u),S.attr(f,s*d).text(p),m.filter(M).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",t===Vs?"start":t===Ws?"end":"middle"),m.each(function(){this.__axis=y})}var r=[],i=null,o=null,u=6,a=6,c=3,s=t===Xs||t===Ws?-1:1,f=t===Ws||t===Vs?"x":"y",l=t===Xs||t===$s?b:w;return e.scale=function(t){return arguments.length?(n=t,e):n},e.ticks=function(){return r=js.call(arguments),e},e.tickArguments=function(t){return arguments.length?(r=null==t?[]:js.call(t),e):r.slice()},e.tickValues=function(t){return arguments.length?(i=null==t?null:js.call(t),e):i&&i.slice()},e.tickFormat=function(t){return arguments.length?(o=t,e):o},e.tickSize=function(t){return arguments.length?(u=a=+t,e):u},e.tickSizeInner=function(t){return arguments.length?(u=+t,e):u},e.tickSizeOuter=function(t){return arguments.length?(a=+t,e):a},e.tickPadding=function(t){return arguments.length?(c=+t,e):c},e}function N(){for(var t,n=0,e=arguments.length,r={};n<e;++n){if(!(t=arguments[n]+"")||t in r)throw new Error("illegal type: "+t);r[t]=[]}return new k(r)}function k(t){this._=t}function S(t,n,e){for(var r=0,i=t.length;r<i;++r)if(t[r].name===n){t[r]=Gs,t=t.slice(0,r).concat(t.slice(r+1));break}return null!=e&&t.push({name:n,value:e}),t}function E(t){var n=t+="",e=n.indexOf(":");return e>=0&&"xmlns"!==(n=t.slice(0,e))&&(t=t.slice(e+1)),Js.hasOwnProperty(n)?{space:Js[n],local:t}:t}function A(t){var n=E(t);return(n.local?function(t){return function(){return this.ownerDocument.createElementNS(t.space,t.local)}}:function(t){return function(){var n=this.ownerDocument,e=this.namespaceURI;return e===Qs&&n.documentElement.namespaceURI===Qs?n.createElement(t):n.createElementNS(e,t)}})(n)}function C(){return new z}function z(){this._="@"+(++Ks).toString(36)}function P(t,n,e){return t=R(t,n,e),function(n){var e=n.relatedTarget;e&&(e===this||8&e.compareDocumentPosition(this))||t.call(this,n)}}function R(n,e,r){return function(i){var o=t.event;t.event=i;try{n.call(this,this.__data__,e,r)}finally{t.event=o}}}function L(t){return function(){var n=this.__on;if(n){for(var e,r=0,i=-1,o=n.length;r<o;++r)e=n[r],t.type&&e.type!==t.type||e.name!==t.name?n[++i]=e:this.removeEventListener(e.type,e.listener,e.capture);++i?n.length=i:delete this.__on}}}function q(t,n,e){var r=of.hasOwnProperty(t.type)?P:R;return function(i,o,u){var a,c=this.__on,s=r(n,o,u);if(c)for(var f=0,l=c.length;f<l;++f)if((a=c[f]).type===t.type&&a.name===t.name)return this.removeEventListener(a.type,a.listener,a.capture),this.addEventListener(a.type,a.listener=s,a.capture=e),void(a.value=n);this.addEventListener(t.type,s,e),a={type:t.type,name:t.name,value:n,listener:s,capture:e},c?c.push(a):this.__on=[a]}}function D(n,e,r,i){var o=t.event;n.sourceEvent=t.event,t.event=n;try{return e.apply(r,i)}finally{t.event=o}}function U(){for(var n,e=t.event;n=e.sourceEvent;)e=n;return e}function O(t,n){var e=t.ownerSVGElement||t;if(e.createSVGPoint){var r=e.createSVGPoint();return r.x=n.clientX,r.y=n.clientY,r=r.matrixTransform(t.getScreenCTM().inverse()),[r.x,r.y]}var i=t.getBoundingClientRect();return[n.clientX-i.left-t.clientLeft,n.clientY-i.top-t.clientTop]}function F(t){var n=U();return n.changedTouches&&(n=n.changedTouches[0]),O(t,n)}function I(){}function Y(t){return null==t?I:function(){return this.querySelector(t)}}function B(){return[]}function H(t){return null==t?B:function(){return this.querySelectorAll(t)}}function j(t){return new Array(t.length)}function X(t,n){this.ownerDocument=t.ownerDocument,this.namespaceURI=t.namespaceURI,this._next=null,this._parent=t,this.__data__=n}function V(t,n,e,r,i,o){for(var u,a=0,c=n.length,s=o.length;a<s;++a)(u=n[a])?(u.__data__=o[a],r[a]=u):e[a]=new X(t,o[a]);for(;a<c;++a)(u=n[a])&&(i[a]=u)}function $(t,n,e,r,i,o,u){var a,c,s,f={},l=n.length,h=o.length,p=new Array(l);for(a=0;a<l;++a)(c=n[a])&&(p[a]=s=uf+u.call(c,c.__data__,a,n),s in f?i[a]=c:f[s]=c);for(a=0;a<h;++a)(c=f[s=uf+u.call(t,o[a],a,o)])?(r[a]=c,c.__data__=o[a],f[s]=null):e[a]=new X(t,o[a]);for(a=0;a<l;++a)(c=n[a])&&f[p[a]]===c&&(i[a]=c)}function W(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function Z(t){return t.ownerDocument&&t.ownerDocument.defaultView||t.document&&t||t.defaultView}function G(t,n){return t.style.getPropertyValue(n)||Z(t).getComputedStyle(t,null).getPropertyValue(n)}function Q(t){return t.trim().split(/^|\s+/)}function J(t){return t.classList||new K(t)}function K(t){this._node=t,this._names=Q(t.getAttribute("class")||"")}function tt(t,n){for(var e=J(t),r=-1,i=n.length;++r<i;)e.add(n[r])}function nt(t,n){for(var e=J(t),r=-1,i=n.length;++r<i;)e.remove(n[r])}function et(){this.textContent=""}function rt(){this.innerHTML=""}function it(){this.nextSibling&&this.parentNode.appendChild(this)}function ot(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function ut(){return null}function at(){var t=this.parentNode;t&&t.removeChild(this)}function ct(t,n,e){var r=Z(t),i=r.CustomEvent;"function"==typeof i?i=new i(n,e):(i=r.document.createEvent("Event"),e?(i.initEvent(n,e.bubbles,e.cancelable),i.detail=e.detail):i.initEvent(n,!1,!1)),t.dispatchEvent(i)}function st(t,n){this._groups=t,this._parents=n}function ft(){return new st([[document.documentElement]],af)}function lt(t){return"string"==typeof t?new st([[document.querySelector(t)]],[document.documentElement]):new st([[t]],af)}function ht(t,n,e){arguments.length<3&&(e=n,n=U().changedTouches);for(var r,i=0,o=n?n.length:0;i<o;++i)if((r=n[i]).identifier===e)return O(t,r);return null}function pt(){t.event.stopImmediatePropagation()}function dt(){t.event.preventDefault(),t.event.stopImmediatePropagation()}function vt(t){var n=t.document.documentElement,e=lt(t).on("dragstart.drag",dt,!0);"onselectstart"in n?e.on("selectstart.drag",dt,!0):(n.__noselect=n.style.MozUserSelect,n.style.MozUserSelect="none")}function gt(t,n){var e=t.document.documentElement,r=lt(t).on("dragstart.drag",null);n&&(r.on("click.drag",dt,!0),setTimeout(function(){r.on("click.drag",null)},0)),"onselectstart"in e?r.on("selectstart.drag",null):(e.style.MozUserSelect=e.__noselect,delete e.__noselect)}function _t(t){return function(){return t}}function yt(t,n,e,r,i,o,u,a,c,s){this.target=t,this.type=n,this.subject=e,this.identifier=r,this.active=i,this.x=o,this.y=u,this.dx=a,this.dy=c,this._=s}function mt(){return!t.event.button}function xt(){return this.parentNode}function bt(n){return null==n?{x:t.event.x,y:t.event.y}:n}function wt(){return"ontouchstart"in this}function Mt(t,n,e){t.prototype=n.prototype=e,e.constructor=t}function Tt(t,n){var e=Object.create(t.prototype);for(var r in n)e[r]=n[r];return e}function Nt(){}function kt(t){var n;return t=(t+"").trim().toLowerCase(),(n=lf.exec(t))?(n=parseInt(n[1],16),new zt(n>>8&15|n>>4&240,n>>4&15|240&n,(15&n)<<4|15&n,1)):(n=hf.exec(t))?St(parseInt(n[1],16)):(n=pf.exec(t))?new zt(n[1],n[2],n[3],1):(n=df.exec(t))?new zt(255*n[1]/100,255*n[2]/100,255*n[3]/100,1):(n=vf.exec(t))?Et(n[1],n[2],n[3],n[4]):(n=gf.exec(t))?Et(255*n[1]/100,255*n[2]/100,255*n[3]/100,n[4]):(n=_f.exec(t))?Pt(n[1],n[2]/100,n[3]/100,1):(n=yf.exec(t))?Pt(n[1],n[2]/100,n[3]/100,n[4]):mf.hasOwnProperty(t)?St(mf[t]):"transparent"===t?new zt(NaN,NaN,NaN,0):null}function St(t){return new zt(t>>16&255,t>>8&255,255&t,1)}function Et(t,n,e,r){return r<=0&&(t=n=e=NaN),new zt(t,n,e,r)}function At(t){return t instanceof Nt||(t=kt(t)),t?(t=t.rgb(),new zt(t.r,t.g,t.b,t.opacity)):new zt}function Ct(t,n,e,r){return 1===arguments.length?At(t):new zt(t,n,e,null==r?1:r)}function zt(t,n,e,r){this.r=+t,this.g=+n,this.b=+e,this.opacity=+r}function Pt(t,n,e,r){return r<=0?t=n=e=NaN:e<=0||e>=1?t=n=NaN:n<=0&&(t=NaN),new Lt(t,n,e,r)}function Rt(t,n,e,r){return 1===arguments.length?function(t){if(t instanceof Lt)return new Lt(t.h,t.s,t.l,t.opacity);if(t instanceof Nt||(t=kt(t)),!t)return new Lt;if(t instanceof Lt)return t;var n=(t=t.rgb()).r/255,e=t.g/255,r=t.b/255,i=Math.min(n,e,r),o=Math.max(n,e,r),u=NaN,a=o-i,c=(o+i)/2;return a?(u=n===o?(e-r)/a+6*(e<r):e===o?(r-n)/a+2:(n-e)/a+4,a/=c<.5?o+i:2-o-i,u*=60):a=c>0&&c<1?0:u,new Lt(u,a,c,t.opacity)}(t):new Lt(t,n,e,null==r?1:r)}function Lt(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function qt(t,n,e){return 255*(t<60?n+(e-n)*t/60:t<180?e:t<240?n+(e-n)*(240-t)/60:n)}function Dt(t){if(t instanceof Ot)return new Ot(t.l,t.a,t.b,t.opacity);if(t instanceof jt){var n=t.h*xf;return new Ot(t.l,Math.cos(n)*t.c,Math.sin(n)*t.c,t.opacity)}t instanceof zt||(t=At(t));var e=Bt(t.r),r=Bt(t.g),i=Bt(t.b),o=Ft((.4124564*e+.3575761*r+.1804375*i)/wf),u=Ft((.2126729*e+.7151522*r+.072175*i)/Mf);return new Ot(116*u-16,500*(o-u),200*(u-Ft((.0193339*e+.119192*r+.9503041*i)/Tf)),t.opacity)}function Ut(t,n,e,r){return 1===arguments.length?Dt(t):new Ot(t,n,e,null==r?1:r)}function Ot(t,n,e,r){this.l=+t,this.a=+n,this.b=+e,this.opacity=+r}function Ft(t){return t>Ef?Math.pow(t,1/3):t/Sf+Nf}function It(t){return t>kf?t*t*t:Sf*(t-Nf)}function Yt(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function Bt(t){return(t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function Ht(t,n,e,r){return 1===arguments.length?function(t){if(t instanceof jt)return new jt(t.h,t.c,t.l,t.opacity);t instanceof Ot||(t=Dt(t));var n=Math.atan2(t.b,t.a)*bf;return new jt(n<0?n+360:n,Math.sqrt(t.a*t.a+t.b*t.b),t.l,t.opacity)}(t):new jt(t,n,e,null==r?1:r)}function jt(t,n,e,r){this.h=+t,this.c=+n,this.l=+e,this.opacity=+r}function Xt(t,n,e,r){return 1===arguments.length?function(t){if(t instanceof Vt)return new Vt(t.h,t.s,t.l,t.opacity);t instanceof zt||(t=At(t));var n=t.r/255,e=t.g/255,r=t.b/255,i=(Lf*r+Pf*n-Rf*e)/(Lf+Pf-Rf),o=r-i,u=(zf*(e-i)-Af*o)/Cf,a=Math.sqrt(u*u+o*o)/(zf*i*(1-i)),c=a?Math.atan2(u,o)*bf-120:NaN;return new Vt(c<0?c+360:c,a,i,t.opacity)}(t):new Vt(t,n,e,null==r?1:r)}function Vt(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function $t(t,n,e,r,i){var o=t*t,u=o*t;return((1-3*t+3*o-u)*n+(4-6*o+3*u)*e+(1+3*t+3*o-3*u)*r+u*i)/6}function Wt(t){var n=t.length-1;return function(e){var r=e<=0?e=0:e>=1?(e=1,n-1):Math.floor(e*n),i=t[r],o=t[r+1],u=r>0?t[r-1]:2*i-o,a=r<n-1?t[r+2]:2*o-i;return $t((e-r/n)*n,u,i,o,a)}}function Zt(t){var n=t.length;return function(e){var r=Math.floor(((e%=1)<0?++e:e)*n),i=t[(r+n-1)%n],o=t[r%n],u=t[(r+1)%n],a=t[(r+2)%n];return $t((e-r/n)*n,i,o,u,a)}}function Gt(t){return function(){return t}}function Qt(t,n){return function(e){return t+e*n}}function Jt(t,n){var e=n-t;return e?Qt(t,e>180||e<-180?e-360*Math.round(e/360):e):Gt(isNaN(t)?n:t)}function Kt(t){return 1==(t=+t)?tn:function(n,e){return e-n?function(t,n,e){return t=Math.pow(t,e),n=Math.pow(n,e)-t,e=1/e,function(r){return Math.pow(t+r*n,e)}}(n,e,t):Gt(isNaN(n)?e:n)}}function tn(t,n){var e=n-t;return e?Qt(t,e):Gt(isNaN(t)?n:t)}function nn(t){return function(n){var e,r,i=n.length,o=new Array(i),u=new Array(i),a=new Array(i);for(e=0;e<i;++e)r=Ct(n[e]),o[e]=r.r||0,u[e]=r.g||0,a[e]=r.b||0;return o=t(o),u=t(u),a=t(a),r.opacity=1,function(t){return r.r=o(t),r.g=u(t),r.b=a(t),r+""}}}function en(t,n){var e,r=n?n.length:0,i=t?Math.min(r,t.length):0,o=new Array(i),u=new Array(r);for(e=0;e<i;++e)o[e]=cn(t[e],n[e]);for(;e<r;++e)u[e]=n[e];return function(t){for(e=0;e<i;++e)u[e]=o[e](t);return u}}function rn(t,n){var e=new Date;return t=+t,n-=t,function(r){return e.setTime(t+n*r),e}}function on(t,n){return t=+t,n-=t,function(e){return t+n*e}}function un(t,n){var e,r={},i={};null!==t&&"object"==typeof t||(t={}),null!==n&&"object"==typeof n||(n={});for(e in n)e in t?r[e]=cn(t[e],n[e]):i[e]=n[e];return function(t){for(e in r)i[e]=r[e](t);return i}}function an(t,n){var e,r,i,o=jf.lastIndex=Xf.lastIndex=0,u=-1,a=[],c=[];for(t+="",n+="";(e=jf.exec(t))&&(r=Xf.exec(n));)(i=r.index)>o&&(i=n.slice(o,i),a[u]?a[u]+=i:a[++u]=i),(e=e[0])===(r=r[0])?a[u]?a[u]+=r:a[++u]=r:(a[++u]=null,c.push({i:u,x:on(e,r)})),o=Xf.lastIndex;return o<n.length&&(i=n.slice(o),a[u]?a[u]+=i:a[++u]=i),a.length<2?c[0]?function(t){return function(n){return t(n)+""}}(c[0].x):function(t){return function(){return t}}(n):(n=c.length,function(t){for(var e,r=0;r<n;++r)a[(e=c[r]).i]=e.x(t);return a.join("")})}function cn(t,n){var e,r=typeof n;return null==n||"boolean"===r?Gt(n):("number"===r?on:"string"===r?(e=kt(n))?(n=e,Yf):an:n instanceof kt?Yf:n instanceof Date?rn:Array.isArray(n)?en:"function"!=typeof n.valueOf&&"function"!=typeof n.toString||isNaN(n)?un:on)(t,n)}function sn(t,n){return t=+t,n-=t,function(e){return Math.round(t+n*e)}}function fn(t,n,e,r,i,o){var u,a,c;return(u=Math.sqrt(t*t+n*n))&&(t/=u,n/=u),(c=t*e+n*r)&&(e-=t*c,r-=n*c),(a=Math.sqrt(e*e+r*r))&&(e/=a,r/=a,c/=a),t*r<n*e&&(t=-t,n=-n,c=-c,u=-u),{translateX:i,translateY:o,rotate:Math.atan2(n,t)*Vf,skewX:Math.atan(c)*Vf,scaleX:u,scaleY:a}}function ln(t,n,e,r){function i(t){return t.length?t.pop()+" ":""}return function(o,u){var a=[],c=[];return o=t(o),u=t(u),function(t,r,i,o,u,a){if(t!==i||r!==o){var c=u.push("translate(",null,n,null,e);a.push({i:c-4,x:on(t,i)},{i:c-2,x:on(r,o)})}else(i||o)&&u.push("translate("+i+n+o+e)}(o.translateX,o.translateY,u.translateX,u.translateY,a,c),function(t,n,e,o){t!==n?(t-n>180?n+=360:n-t>180&&(t+=360),o.push({i:e.push(i(e)+"rotate(",null,r)-2,x:on(t,n)})):n&&e.push(i(e)+"rotate("+n+r)}(o.rotate,u.rotate,a,c),function(t,n,e,o){t!==n?o.push({i:e.push(i(e)+"skewX(",null,r)-2,x:on(t,n)}):n&&e.push(i(e)+"skewX("+n+r)}(o.skewX,u.skewX,a,c),function(t,n,e,r,o,u){if(t!==e||n!==r){var a=o.push(i(o)+"scale(",null,",",null,")");u.push({i:a-4,x:on(t,e)},{i:a-2,x:on(n,r)})}else 1===e&&1===r||o.push(i(o)+"scale("+e+","+r+")")}(o.scaleX,o.scaleY,u.scaleX,u.scaleY,a,c),o=u=null,function(t){for(var n,e=-1,r=c.length;++e<r;)a[(n=c[e]).i]=n.x(t);return a.join("")}}}function hn(t){return((t=Math.exp(t))+1/t)/2}function pn(t,n){var e,r,i=t[0],o=t[1],u=t[2],a=n[0],c=n[1],s=n[2],f=a-i,l=c-o,h=f*f+l*l;if(h<Kf)r=Math.log(s/u)/Gf,e=function(t){return[i+t*f,o+t*l,u*Math.exp(Gf*t*r)]};else{var p=Math.sqrt(h),d=(s*s-u*u+Jf*h)/(2*u*Qf*p),v=(s*s-u*u-Jf*h)/(2*s*Qf*p),g=Math.log(Math.sqrt(d*d+1)-d),_=Math.log(Math.sqrt(v*v+1)-v);r=(_-g)/Gf,e=function(t){var n=t*r,e=hn(g),a=u/(Qf*p)*(e*function(t){return((t=Math.exp(2*t))-1)/(t+1)}(Gf*n+g)-function(t){return((t=Math.exp(t))-1/t)/2}(g));return[i+a*f,o+a*l,u*e/hn(Gf*n+g)]}}return e.duration=1e3*r,e}function dn(t){return function(n,e){var r=t((n=Rt(n)).h,(e=Rt(e)).h),i=tn(n.s,e.s),o=tn(n.l,e.l),u=tn(n.opacity,e.opacity);return function(t){return n.h=r(t),n.s=i(t),n.l=o(t),n.opacity=u(t),n+""}}}function vn(t){return function(n,e){var r=t((n=Ht(n)).h,(e=Ht(e)).h),i=tn(n.c,e.c),o=tn(n.l,e.l),u=tn(n.opacity,e.opacity);return function(t){return n.h=r(t),n.c=i(t),n.l=o(t),n.opacity=u(t),n+""}}}function gn(t){return function n(e){function r(n,r){var i=t((n=Xt(n)).h,(r=Xt(r)).h),o=tn(n.s,r.s),u=tn(n.l,r.l),a=tn(n.opacity,r.opacity);return function(t){return n.h=i(t),n.s=o(t),n.l=u(Math.pow(t,e)),n.opacity=a(t),n+""}}return e=+e,r.gamma=n,r}(1)}function _n(){return ll||(dl(yn),ll=pl.now()+hl)}function yn(){ll=0}function mn(){this._call=this._time=this._next=null}function xn(t,n,e){var r=new mn;return r.restart(t,n,e),r}function bn(){_n(),++ul;for(var t,n=Ff;n;)(t=ll-n._time)>=0&&n._call.call(null,t),n=n._next;--ul}function wn(){ll=(fl=pl.now())+hl,ul=al=0;try{bn()}finally{ul=0,function(){var t,n,e=Ff,r=1/0;for(;e;)e._call?(r>e._time&&(r=e._time),t=e,e=e._next):(n=e._next,e._next=null,e=t?t._next=n:Ff=n);If=t,Tn(r)}(),ll=0}}function Mn(){var t=pl.now(),n=t-fl;n>sl&&(hl-=n,fl=t)}function Tn(t){if(!ul){al&&(al=clearTimeout(al));t-ll>24?(t<1/0&&(al=setTimeout(wn,t-pl.now()-hl)),cl&&(cl=clearInterval(cl))):(cl||(fl=pl.now(),cl=setInterval(Mn,sl)),ul=1,dl(wn))}}function Nn(t,n,e){var r=new mn;return n=null==n?0:+n,r.restart(function(e){r.stop(),t(e+n)},n,e),r}function kn(t,n,e,r,i,o){var u=t.__transition;if(u){if(e in u)return}else t.__transition={};(function(t,n,e){function r(c){var s,f,l,h;if(e.state!==yl)return o();for(s in a)if((h=a[s]).name===e.name){if(h.state===xl)return Nn(r);h.state===bl?(h.state=Ml,h.timer.stop(),h.on.call("interrupt",t,t.__data__,h.index,h.group),delete a[s]):+s<n&&(h.state=Ml,h.timer.stop(),delete a[s])}if(Nn(function(){e.state===xl&&(e.state=bl,e.timer.restart(i,e.delay,e.time),i(c))}),e.state=ml,e.on.call("start",t,t.__data__,e.index,e.group),e.state===ml){for(e.state=xl,u=new Array(l=e.tween.length),s=0,f=-1;s<l;++s)(h=e.tween[s].value.call(t,t.__data__,e.index,e.group))&&(u[++f]=h);u.length=f+1}}function i(n){for(var r=n<e.duration?e.ease.call(null,n/e.duration):(e.timer.restart(o),e.state=wl,1),i=-1,a=u.length;++i<a;)u[i].call(null,r);e.state===wl&&(e.on.call("end",t,t.__data__,e.index,e.group),o())}function o(){e.state=Ml,e.timer.stop(),delete a[n];for(var r in a)return;delete t.__transition}var u,a=t.__transition;a[n]=e,e.timer=xn(function(t){e.state=yl,e.timer.restart(r,e.delay,e.time),e.delay<=t&&r(t-e.delay)},0,e.time)})(t,e,{name:n,index:r,group:i,on:vl,tween:gl,time:o.time,delay:o.delay,duration:o.duration,ease:o.ease,timer:null,state:_l})}function Sn(t,n){var e=An(t,n);if(e.state>_l)throw new Error("too late; already scheduled");return e}function En(t,n){var e=An(t,n);if(e.state>ml)throw new Error("too late; already started");return e}function An(t,n){var e=t.__transition;if(!e||!(e=e[n]))throw new Error("transition not found");return e}function Cn(t,n){var e,r,i,o=t.__transition,u=!0;if(o){n=null==n?null:n+"";for(i in o)(e=o[i]).name===n?(r=e.state>ml&&e.state<wl,e.state=Ml,e.timer.stop(),r&&e.on.call("interrupt",t,t.__data__,e.index,e.group),delete o[i]):u=!1;u&&delete t.__transition}}function zn(t,n,e){var r=t._id;return t.each(function(){var t=En(this,r);(t.value||(t.value={}))[n]=e.apply(this,arguments)}),function(t){return An(t,r).value[n]}}function Pn(t,n){var e;return("number"==typeof n?on:n instanceof kt?Yf:(e=kt(n))?(n=e,Yf):an)(t,n)}function Rn(t,n,e,r){this._groups=t,this._parents=n,this._name=e,this._id=r}function Ln(t){return ft().transition(t)}function qn(){return++Nl}function Dn(t){return((t*=2)<=1?t*t:--t*(2-t)+1)/2}function Un(t){return((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2}function On(t){return(1-Math.cos(Cl*t))/2}function Fn(t){return((t*=2)<=1?Math.pow(2,10*t-10):2-Math.pow(2,10-10*t))/2}function In(t){return((t*=2)<=1?1-Math.sqrt(1-t*t):Math.sqrt(1-(t-=2)*t)+1)/2}function Yn(t){return(t=+t)<Pl?Yl*t*t:t<Ll?Yl*(t-=Rl)*t+ql:t<Ul?Yl*(t-=Dl)*t+Ol:Yl*(t-=Fl)*t+Il}function Bn(t,n){for(var e;!(e=t.__transition)||!(e=e[n]);)if(!(t=t.parentNode))return Zl.time=_n(),Zl;return e}function Hn(t){return function(){return t}}function jn(){t.event.stopImmediatePropagation()}function Xn(){t.event.preventDefault(),t.event.stopImmediatePropagation()}function Vn(t){return{type:t}}function $n(){return!t.event.button}function Wn(){var t=this.ownerSVGElement||this;return[[0,0],[t.width.baseVal.value,t.height.baseVal.value]]}function Zn(t){for(;!t.__brush;)if(!(t=t.parentNode))return;return t.__brush}function Gn(t){return t[0][0]===t[1][0]||t[0][1]===t[1][1]}function Qn(n){function e(t){var e=t.property("__brush",a).selectAll(".overlay").data([Vn("overlay")]);e.enter().append("rect").attr("class","overlay").attr("pointer-events","all").attr("cursor",ih.overlay).merge(e).each(function(){var t=Zn(this).extent;lt(this).attr("x",t[0][0]).attr("y",t[0][1]).attr("width",t[1][0]-t[0][0]).attr("height",t[1][1]-t[0][1])}),t.selectAll(".selection").data([Vn("selection")]).enter().append("rect").attr("class","selection").attr("cursor",ih.selection).attr("fill","#777").attr("fill-opacity",.3).attr("stroke","#fff").attr("shape-rendering","crispEdges");var i=t.selectAll(".handle").data(n.handles,function(t){return t.type});i.exit().remove(),i.enter().append("rect").attr("class",function(t){return"handle handle--"+t.type}).attr("cursor",function(t){return ih[t.type]}),t.each(r).attr("fill","none").attr("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush touchstart.brush",u)}function r(){var t=lt(this),n=Zn(this).selection;n?(t.selectAll(".selection").style("display",null).attr("x",n[0][0]).attr("y",n[0][1]).attr("width",n[1][0]-n[0][0]).attr("height",n[1][1]-n[0][1]),t.selectAll(".handle").style("display",null).attr("x",function(t){return"e"===t.type[t.type.length-1]?n[1][0]-h/2:n[0][0]-h/2}).attr("y",function(t){return"s"===t.type[0]?n[1][1]-h/2:n[0][1]-h/2}).attr("width",function(t){return"n"===t.type||"s"===t.type?n[1][0]-n[0][0]+h:h}).attr("height",function(t){return"e"===t.type||"w"===t.type?n[1][1]-n[0][1]+h:h})):t.selectAll(".selection,.handle").style("display","none").attr("x",null).attr("y",null).attr("width",null).attr("height",null)}function i(t,n){return t.__brush.emitter||new o(t,n)}function o(t,n){this.that=t,this.args=n,this.state=t.__brush,this.active=0}function u(){function e(){var t=F(w);!L||x||b||(Math.abs(t[0]-D[0])>Math.abs(t[1]-D[1])?b=!0:x=!0),D=t,m=!0,Xn(),o()}function o(){var t;switch(_=D[0]-q[0],y=D[1]-q[1],T){case Jl:case Ql:N&&(_=Math.max(C-a,Math.min(P-p,_)),s=a+_,d=p+_),k&&(y=Math.max(z-l,Math.min(R-v,y)),h=l+y,g=v+y);break;case Kl:N<0?(_=Math.max(C-a,Math.min(P-a,_)),s=a+_,d=p):N>0&&(_=Math.max(C-p,Math.min(P-p,_)),s=a,d=p+_),k<0?(y=Math.max(z-l,Math.min(R-l,y)),h=l+y,g=v):k>0&&(y=Math.max(z-v,Math.min(R-v,y)),h=l,g=v+y);break;case th:N&&(s=Math.max(C,Math.min(P,a-_*N)),d=Math.max(C,Math.min(P,p+_*N))),k&&(h=Math.max(z,Math.min(R,l-y*k)),g=Math.max(z,Math.min(R,v+y*k)))}d<s&&(N*=-1,t=a,a=p,p=t,t=s,s=d,d=t,M in oh&&I.attr("cursor",ih[M=oh[M]])),g<h&&(k*=-1,t=l,l=v,v=t,t=h,h=g,g=t,M in uh&&I.attr("cursor",ih[M=uh[M]])),S.selection&&(A=S.selection),x&&(s=A[0][0],d=A[1][0]),b&&(h=A[0][1],g=A[1][1]),A[0][0]===s&&A[0][1]===h&&A[1][0]===d&&A[1][1]===g||(S.selection=[[s,h],[d,g]],r.call(w),U.brush())}function u(){if(jn(),t.event.touches){if(t.event.touches.length)return;c&&clearTimeout(c),c=setTimeout(function(){c=null},500),O.on("touchmove.brush touchend.brush touchcancel.brush",null)}else gt(t.event.view,m),Y.on("keydown.brush keyup.brush mousemove.brush mouseup.brush",null);O.attr("pointer-events","all"),I.attr("cursor",ih.overlay),S.selection&&(A=S.selection),Gn(A)&&(S.selection=null,r.call(w)),U.end()}if(t.event.touches){if(t.event.changedTouches.length<t.event.touches.length)return Xn()}else if(c)return;if(f.apply(this,arguments)){var a,s,l,h,p,d,v,g,_,y,m,x,b,w=this,M=t.event.target.__data__.type,T="selection"===(t.event.metaKey?M="overlay":M)?Ql:t.event.altKey?th:Kl,N=n===eh?null:ah[M],k=n===nh?null:ch[M],S=Zn(w),E=S.extent,A=S.selection,C=E[0][0],z=E[0][1],P=E[1][0],R=E[1][1],L=N&&k&&t.event.shiftKey,q=F(w),D=q,U=i(w,arguments).beforestart();"overlay"===M?S.selection=A=[[a=n===eh?C:q[0],l=n===nh?z:q[1]],[p=n===eh?P:a,v=n===nh?R:l]]:(a=A[0][0],l=A[0][1],p=A[1][0],v=A[1][1]),s=a,h=l,d=p,g=v;var O=lt(w).attr("pointer-events","none"),I=O.selectAll(".overlay").attr("cursor",ih[M]);if(t.event.touches)O.on("touchmove.brush",e,!0).on("touchend.brush touchcancel.brush",u,!0);else{var Y=lt(t.event.view).on("keydown.brush",function(){switch(t.event.keyCode){case 16:L=N&&k;break;case 18:T===Kl&&(N&&(p=d-_*N,a=s+_*N),k&&(v=g-y*k,l=h+y*k),T=th,o());break;case 32:T!==Kl&&T!==th||(N<0?p=d-_:N>0&&(a=s-_),k<0?v=g-y:k>0&&(l=h-y),T=Jl,I.attr("cursor",ih.selection),o());break;default:return}Xn()},!0).on("keyup.brush",function(){switch(t.event.keyCode){case 16:L&&(x=b=L=!1,o());break;case 18:T===th&&(N<0?p=d:N>0&&(a=s),k<0?v=g:k>0&&(l=h),T=Kl,o());break;case 32:T===Jl&&(t.event.altKey?(N&&(p=d-_*N,a=s+_*N),k&&(v=g-y*k,l=h+y*k),T=th):(N<0?p=d:N>0&&(a=s),k<0?v=g:k>0&&(l=h),T=Kl),I.attr("cursor",ih[M]),o());break;default:return}Xn()},!0).on("mousemove.brush",e,!0).on("mouseup.brush",u,!0);vt(t.event.view)}jn(),Cn(w),r.call(w),U.start()}}function a(){var t=this.__brush||{selection:null};return t.extent=s.apply(this,arguments),t.dim=n,t}var c,s=Wn,f=$n,l=N(e,"start","brush","end"),h=6;return e.move=function(t,e){t.selection?t.on("start.brush",function(){i(this,arguments).beforestart().start()}).on("interrupt.brush end.brush",function(){i(this,arguments).end()}).tween("brush",function(){function t(t){u.selection=1===t&&Gn(s)?null:f(t),r.call(o),a.brush()}var o=this,u=o.__brush,a=i(o,arguments),c=u.selection,s=n.input("function"==typeof e?e.apply(this,arguments):e,u.extent),f=cn(c,s);return c&&s?t:t(1)}):t.each(function(){var t=arguments,o=this.__brush,u=n.input("function"==typeof e?e.apply(this,t):e,o.extent),a=i(this,t).beforestart();Cn(this),o.selection=null==u||Gn(u)?null:u,r.call(this),a.start().brush().end()})},o.prototype={beforestart:function(){return 1==++this.active&&(this.state.emitter=this,this.starting=!0),this},start:function(){return this.starting&&(this.starting=!1,this.emit("start")),this},brush:function(){return this.emit("brush"),this},end:function(){return 0==--this.active&&(delete this.state.emitter,this.emit("end")),this},emit:function(t){D(new function(t,n,e){this.target=t,this.type=n,this.selection=e}(e,t,n.output(this.state.selection)),l.apply,l,[t,this.that,this.args])}},e.extent=function(t){return arguments.length?(s="function"==typeof t?t:Hn([[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]]),e):s},e.filter=function(t){return arguments.length?(f="function"==typeof t?t:Hn(!!t),e):f},e.handleSize=function(t){return arguments.length?(h=+t,e):h},e.on=function(){var t=l.on.apply(l,arguments);return t===l?e:t},e}function Jn(t){return function(){return t}}function Kn(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function te(){return new Kn}function ne(t){return t.source}function ee(t){return t.target}function re(t){return t.radius}function ie(t){return t.startAngle}function oe(t){return t.endAngle}function ue(){}function ae(t,n){var e=new ue;if(t instanceof ue)t.each(function(t,n){e.set(n,t)});else if(Array.isArray(t)){var r,i=-1,o=t.length;if(null==n)for(;++i<o;)e.set(i,t[i]);else for(;++i<o;)e.set(n(r=t[i],i,t),r)}else if(t)for(var u in t)e.set(u,t[u]);return e}function ce(){return{}}function se(t,n,e){t[n]=e}function fe(){return ae()}function le(t,n,e){t.set(n,e)}function he(){}function pe(t,n){var e=new he;if(t instanceof he)t.each(function(t){e.add(t)});else if(t){var r=-1,i=t.length;if(null==n)for(;++r<i;)e.add(t[r]);else for(;++r<i;)e.add(n(t[r],r,t))}return e}function de(t){return new Function("d","return {"+t.map(function(t,n){return JSON.stringify(t)+": d["+n+"]"}).join(",")+"}")}function ve(t){function n(t,n){function e(){if(s)return bh;if(f)return f=!1,xh;var n,e,r=a;if(t.charCodeAt(r)===wh){for(;a++<u&&t.charCodeAt(a)!==wh||t.charCodeAt(++a)===wh;);return(n=a)>=u?s=!0:(e=t.charCodeAt(a++))===Mh?f=!0:e===Th&&(f=!0,t.charCodeAt(a)===Mh&&++a),t.slice(r+1,n-1).replace(/""/g,'"')}for(;a<u;){if((e=t.charCodeAt(n=a++))===Mh)f=!0;else if(e===Th)f=!0,t.charCodeAt(a)===Mh&&++a;else if(e!==o)continue;return t.slice(r,n)}return s=!0,t.slice(r,u)}var r,i=[],u=t.length,a=0,c=0,s=u<=0,f=!1;for(t.charCodeAt(u-1)===Mh&&--u,t.charCodeAt(u-1)===Th&&--u;(r=e())!==bh;){for(var l=[];r!==xh&&r!==bh;)l.push(r),r=e();n&&null==(l=n(l,c++))||i.push(l)}return i}function e(n){return n.map(r).join(t)}function r(t){return null==t?"":i.test(t+="")?'"'+t.replace(/"/g,'""')+'"':t}var i=new RegExp('["'+t+"\n\r]"),o=t.charCodeAt(0);return{parse:function(t,e){var r,i,o=n(t,function(t,n){if(r)return r(t,n-1);i=t,r=e?function(t,n){var e=de(t);return function(r,i){return n(e(r),i,t)}}(t,e):de(t)});return o.columns=i||[],o},parseRows:n,format:function(n,e){return null==e&&(e=function(t){var n=Object.create(null),e=[];return t.forEach(function(t){for(var r in t)r in n||e.push(n[r]=r)}),e}(n)),[e.map(r).join(t)].concat(n.map(function(n){return e.map(function(t){return r(n[t])}).join(t)})).join("\n")},formatRows:function(t){return t.map(e).join("\n")}}}function ge(t){return function(){return t}}function _e(){return 1e-6*(Math.random()-.5)}function ye(t,n,e,r){if(isNaN(n)||isNaN(e))return t;var i,o,u,a,c,s,f,l,h,p=t._root,d={data:r},v=t._x0,g=t._y0,_=t._x1,y=t._y1;if(!p)return t._root=d,t;for(;p.length;)if((s=n>=(o=(v+_)/2))?v=o:_=o,(f=e>=(u=(g+y)/2))?g=u:y=u,i=p,!(p=p[l=f<<1|s]))return i[l]=d,t;if(a=+t._x.call(null,p.data),c=+t._y.call(null,p.data),n===a&&e===c)return d.next=p,i?i[l]=d:t._root=d,t;do{i=i?i[l]=new Array(4):t._root=new Array(4),(s=n>=(o=(v+_)/2))?v=o:_=o,(f=e>=(u=(g+y)/2))?g=u:y=u}while((l=f<<1|s)==(h=(c>=u)<<1|a>=o));return i[h]=p,i[l]=d,t}function me(t,n,e,r,i){this.node=t,this.x0=n,this.y0=e,this.x1=r,this.y1=i}function xe(t){return t[0]}function be(t){return t[1]}function we(t,n,e){var r=new Me(null==n?xe:n,null==e?be:e,NaN,NaN,NaN,NaN);return null==t?r:r.addAll(t)}function Me(t,n,e,r,i,o){this._x=t,this._y=n,this._x0=e,this._y0=r,this._x1=i,this._y1=o,this._root=void 0}function Te(t){for(var n={data:t.data},e=n;t=t.next;)e=e.next={data:t.data};return n}function Ne(t){return t.x+t.vx}function ke(t){return t.y+t.vy}function Se(t){return t.index}function Ee(t,n){var e=t.get(n);if(!e)throw new Error("missing: "+n);return e}function Ae(t){return t.x}function Ce(t){return t.y}function ze(t,n){if((e=(t=n?t.toExponential(n-1):t.toExponential()).indexOf("e"))<0)return null;var e,r=t.slice(0,e);return[r.length>1?r[0]+r.slice(2):r,+t.slice(e+1)]}function Pe(t){return(t=ze(Math.abs(t)))?t[1]:NaN}function Re(t,n){var e=ze(t,n);if(!e)return t+"";var r=e[0],i=e[1];return i<0?"0."+new Array(-i).join("0")+r:r.length>i+1?r.slice(0,i+1)+"."+r.slice(i+1):r+new Array(i-r.length+2).join("0")}function Le(t){return new qe(t)}function qe(t){if(!(n=Ih.exec(t)))throw new Error("invalid format: "+t);var n,e=n[1]||" ",r=n[2]||">",i=n[3]||"-",o=n[4]||"",u=!!n[5],a=n[6]&&+n[6],c=!!n[7],s=n[8]&&+n[8].slice(1),f=n[9]||"";"n"===f?(c=!0,f="g"):Fh[f]||(f=""),(u||"0"===e&&"="===r)&&(u=!0,e="0",r="="),this.fill=e,this.align=r,this.sign=i,this.symbol=o,this.zero=u,this.width=a,this.comma=c,this.precision=s,this.type=f}function De(t){return t}function Ue(t){function n(t){function n(t){var n,r,u,f=g,x=_;if("c"===v)x=y(t)+x,t="";else{var b=(t=+t)<0;if(t=y(Math.abs(t),d),b&&0==+t&&(b=!1),f=(b?"("===s?s:"-":"-"===s||"("===s?"":s)+f,x=x+("s"===v?Bh[8+Dh/3]:"")+(b&&"("===s?")":""),m)for(n=-1,r=t.length;++n<r;)if(48>(u=t.charCodeAt(n))||u>57){x=(46===u?i+t.slice(n+1):t.slice(n))+x,t=t.slice(0,n);break}}p&&!l&&(t=e(t,1/0));var w=f.length+t.length+x.length,M=w<h?new Array(h-w+1).join(a):"";switch(p&&l&&(t=e(M+t,M.length?h-x.length:1/0),M=""),c){case"<":t=f+t+x+M;break;case"=":t=f+M+t+x;break;case"^":t=M.slice(0,w=M.length>>1)+f+t+x+M.slice(w);break;default:t=M+f+t+x}return o(t)}var a=(t=Le(t)).fill,c=t.align,s=t.sign,f=t.symbol,l=t.zero,h=t.width,p=t.comma,d=t.precision,v=t.type,g="$"===f?r[0]:"#"===f&&/[boxX]/.test(v)?"0"+v.toLowerCase():"",_="$"===f?r[1]:/[%p]/.test(v)?u:"",y=Fh[v],m=!v||/[defgprs%]/.test(v);return d=null==d?v?6:12:/[gprs]/.test(v)?Math.max(1,Math.min(21,d)):Math.max(0,Math.min(20,d)),n.toString=function(){return t+""},n}var e=t.grouping&&t.thousands?function(t,n){return function(e,r){for(var i=e.length,o=[],u=0,a=t[0],c=0;i>0&&a>0&&(c+a+1>r&&(a=Math.max(1,r-c)),o.push(e.substring(i-=a,i+a)),!((c+=a+1)>r));)a=t[u=(u+1)%t.length];return o.reverse().join(n)}}(t.grouping,t.thousands):De,r=t.currency,i=t.decimal,o=t.numerals?function(t){return function(n){return n.replace(/[0-9]/g,function(n){return t[+n]})}}(t.numerals):De,u=t.percent||"%";return{format:n,formatPrefix:function(t,e){var r=n((t=Le(t),t.type="f",t)),i=3*Math.max(-8,Math.min(8,Math.floor(Pe(e)/3))),o=Math.pow(10,-i),u=Bh[8+i/3];return function(t){return r(o*t)+u}}}}function Oe(n){return Yh=Ue(n),t.format=Yh.format,t.formatPrefix=Yh.formatPrefix,Yh}function Fe(t){return Math.max(0,-Pe(Math.abs(t)))}function Ie(t,n){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(Pe(n)/3)))-Pe(Math.abs(t)))}function Ye(t,n){return t=Math.abs(t),n=Math.abs(n)-t,Math.max(0,Pe(n)-Pe(t))+1}function Be(){return new He}function He(){this.reset()}function je(t,n,e){var r=t.s=n+e,i=r-n,o=r-i;t.t=n-o+(e-i)}function Xe(t){return t>1?0:t<-1?Mp:Math.acos(t)}function Ve(t){return t>1?Tp:t<-1?-Tp:Math.asin(t)}function $e(t){return(t=Up(t/2))*t}function We(){}function Ze(t,n){t&&Bp.hasOwnProperty(t.type)&&Bp[t.type](t,n)}function Ge(t,n,e){var r,i=-1,o=t.length-e;for(n.lineStart();++i<o;)r=t[i],n.point(r[0],r[1],r[2]);n.lineEnd()}function Qe(t,n){var e=-1,r=t.length;for(n.polygonStart();++e<r;)Ge(t[e],n,1);n.polygonEnd()}function Je(t,n){t&&Yp.hasOwnProperty(t.type)?Yp[t.type](t,n):Ze(t,n)}function Ke(){Xp.point=nr}function tr(){er(Hh,jh)}function nr(t,n){Xp.point=er,Hh=t,jh=n,Xh=t*=Ep,Vh=Pp(n=(n*=Ep)/2+Np),$h=Up(n)}function er(t,n){n=(n*=Ep)/2+Np;var e=(t*=Ep)-Xh,r=e>=0?1:-1,i=r*e,o=Pp(n),u=Up(n),a=$h*u,c=Vh*o+a*Pp(i),s=a*r*Up(i);Hp.add(zp(s,c)),Xh=t,Vh=o,$h=u}function rr(t){return[zp(t[1],t[0]),Ve(t[2])]}function ir(t){var n=t[0],e=t[1],r=Pp(e);return[r*Pp(n),r*Up(n),Up(e)]}function or(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function ur(t,n){return[t[1]*n[2]-t[2]*n[1],t[2]*n[0]-t[0]*n[2],t[0]*n[1]-t[1]*n[0]]}function ar(t,n){t[0]+=n[0],t[1]+=n[1],t[2]+=n[2]}function cr(t,n){return[t[0]*n,t[1]*n,t[2]*n]}function sr(t){var n=Fp(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=n,t[1]/=n,t[2]/=n}function fr(t,n){ep.push(rp=[Wh=t,Gh=t]),n<Zh&&(Zh=n),n>Qh&&(Qh=n)}function lr(t,n){var e=ir([t*Ep,n*Ep]);if(np){var r=ur(np,e),i=ur([r[1],-r[0],0],r);sr(i),i=rr(i);var o,u=t-Jh,a=u>0?1:-1,c=i[0]*Sp*a,s=Ap(u)>180;s^(a*Jh<c&&c<a*t)?(o=i[1]*Sp)>Qh&&(Qh=o):(c=(c+360)%360-180,s^(a*Jh<c&&c<a*t)?(o=-i[1]*Sp)<Zh&&(Zh=o):(n<Zh&&(Zh=n),n>Qh&&(Qh=n))),s?t<Jh?_r(Wh,t)>_r(Wh,Gh)&&(Gh=t):_r(t,Gh)>_r(Wh,Gh)&&(Wh=t):Gh>=Wh?(t<Wh&&(Wh=t),t>Gh&&(Gh=t)):t>Jh?_r(Wh,t)>_r(Wh,Gh)&&(Gh=t):_r(t,Gh)>_r(Wh,Gh)&&(Wh=t)}else ep.push(rp=[Wh=t,Gh=t]);n<Zh&&(Zh=n),n>Qh&&(Qh=n),np=e,Jh=t}function hr(){$p.point=lr}function pr(){rp[0]=Wh,rp[1]=Gh,$p.point=fr,np=null}function dr(t,n){if(np){var e=t-Jh;Vp.add(Ap(e)>180?e+(e>0?360:-360):e)}else Kh=t,tp=n;Xp.point(t,n),lr(t,n)}function vr(){Xp.lineStart()}function gr(){dr(Kh,tp),Xp.lineEnd(),Ap(Vp)>bp&&(Wh=-(Gh=180)),rp[0]=Wh,rp[1]=Gh,np=null}function _r(t,n){return(n-=t)<0?n+360:n}function yr(t,n){return t[0]-n[0]}function mr(t,n){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}function xr(t,n){t*=Ep;var e=Pp(n*=Ep);br(e*Pp(t),e*Up(t),Up(n))}function br(t,n,e){up+=(t-up)/++ip,ap+=(n-ap)/ip,cp+=(e-cp)/ip}function wr(){Wp.point=Mr}function Mr(t,n){t*=Ep;var e=Pp(n*=Ep);_p=e*Pp(t),yp=e*Up(t),mp=Up(n),Wp.point=Tr,br(_p,yp,mp)}function Tr(t,n){t*=Ep;var e=Pp(n*=Ep),r=e*Pp(t),i=e*Up(t),o=Up(n),u=zp(Fp((u=yp*o-mp*i)*u+(u=mp*r-_p*o)*u+(u=_p*i-yp*r)*u),_p*r+yp*i+mp*o);op+=u,sp+=u*(_p+(_p=r)),fp+=u*(yp+(yp=i)),lp+=u*(mp+(mp=o)),br(_p,yp,mp)}function Nr(){Wp.point=xr}function kr(){Wp.point=Er}function Sr(){Ar(vp,gp),Wp.point=xr}function Er(t,n){vp=t,gp=n,t*=Ep,n*=Ep,Wp.point=Ar;var e=Pp(n);_p=e*Pp(t),yp=e*Up(t),mp=Up(n),br(_p,yp,mp)}function Ar(t,n){t*=Ep;var e=Pp(n*=Ep),r=e*Pp(t),i=e*Up(t),o=Up(n),u=yp*o-mp*i,a=mp*r-_p*o,c=_p*i-yp*r,s=Fp(u*u+a*a+c*c),f=Ve(s),l=s&&-f/s;hp+=l*u,pp+=l*a,dp+=l*c,op+=f,sp+=f*(_p+(_p=r)),fp+=f*(yp+(yp=i)),lp+=f*(mp+(mp=o)),br(_p,yp,mp)}function Cr(t){return function(){return t}}function zr(t,n){function e(e,r){return e=t(e,r),n(e[0],e[1])}return t.invert&&n.invert&&(e.invert=function(e,r){return(e=n.invert(e,r))&&t.invert(e[0],e[1])}),e}function Pr(t,n){return[t>Mp?t-kp:t<-Mp?t+kp:t,n]}function Rr(t,n,e){return(t%=kp)?n||e?zr(qr(t),Dr(n,e)):qr(t):n||e?Dr(n,e):Pr}function Lr(t){return function(n,e){return n+=t,[n>Mp?n-kp:n<-Mp?n+kp:n,e]}}function qr(t){var n=Lr(t);return n.invert=Lr(-t),n}function Dr(t,n){function e(t,n){var e=Pp(n),a=Pp(t)*e,c=Up(t)*e,s=Up(n),f=s*r+a*i;return[zp(c*o-f*u,a*r-s*i),Ve(f*o+c*u)]}var r=Pp(t),i=Up(t),o=Pp(n),u=Up(n);return e.invert=function(t,n){var e=Pp(n),a=Pp(t)*e,c=Up(t)*e,s=Up(n),f=s*o-c*u;return[zp(c*o+s*u,a*r+f*i),Ve(f*r-a*i)]},e}function Ur(t){function n(n){return n=t(n[0]*Ep,n[1]*Ep),n[0]*=Sp,n[1]*=Sp,n}return t=Rr(t[0]*Ep,t[1]*Ep,t.length>2?t[2]*Ep:0),n.invert=function(n){return n=t.invert(n[0]*Ep,n[1]*Ep),n[0]*=Sp,n[1]*=Sp,n},n}function Or(t,n,e,r,i,o){if(e){var u=Pp(n),a=Up(n),c=r*e;null==i?(i=n+r*kp,o=n-c/2):(i=Fr(u,i),o=Fr(u,o),(r>0?i<o:i>o)&&(i+=r*kp));for(var s,f=i;r>0?f>o:f<o;f-=c)s=rr([u,-a*Pp(f),-a*Up(f)]),t.point(s[0],s[1])}}function Fr(t,n){(n=ir(n))[0]-=t,sr(n);var e=Xe(-n[1]);return((-n[2]<0?-e:e)+kp-bp)%kp}function Ir(){var t,n=[];return{point:function(n,e){t.push([n,e])},lineStart:function(){n.push(t=[])},lineEnd:We,rejoin:function(){n.length>1&&n.push(n.pop().concat(n.shift()))},result:function(){var e=n;return n=[],t=null,e}}}function Yr(t,n){return Ap(t[0]-n[0])<bp&&Ap(t[1]-n[1])<bp}function Br(t,n,e,r){this.x=t,this.z=n,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Hr(t,n,e,r,i){var o,u,a=[],c=[];if(t.forEach(function(t){if(!((n=t.length-1)<=0)){var n,e,r=t[0],u=t[n];if(Yr(r,u)){for(i.lineStart(),o=0;o<n;++o)i.point((r=t[o])[0],r[1]);i.lineEnd()}else a.push(e=new Br(r,t,null,!0)),c.push(e.o=new Br(r,null,e,!1)),a.push(e=new Br(u,t,null,!1)),c.push(e.o=new Br(u,null,e,!0))}}),a.length){for(c.sort(n),jr(a),jr(c),o=0,u=c.length;o<u;++o)c[o].e=e=!e;for(var s,f,l=a[0];;){for(var h=l,p=!0;h.v;)if((h=h.n)===l)return;s=h.z,i.lineStart();do{if(h.v=h.o.v=!0,h.e){if(p)for(o=0,u=s.length;o<u;++o)i.point((f=s[o])[0],f[1]);else r(h.x,h.n.x,1,i);h=h.n}else{if(p)for(s=h.p.z,o=s.length-1;o>=0;--o)i.point((f=s[o])[0],f[1]);else r(h.x,h.p.x,-1,i);h=h.p}s=(h=h.o).z,p=!p}while(!h.v);i.lineEnd()}}}function jr(t){if(n=t.length){for(var n,e,r=0,i=t[0];++r<n;)i.n=e=t[r],e.p=i,i=e;i.n=e=t[0],e.p=i}}function Xr(t,n){var e=n[0],r=n[1],i=[Up(e),-Pp(e),0],o=0,u=0;ud.reset();for(var a=0,c=t.length;a<c;++a)if(f=(s=t[a]).length)for(var s,f,l=s[f-1],h=l[0],p=l[1]/2+Np,d=Up(p),v=Pp(p),g=0;g<f;++g,h=y,d=x,v=b,l=_){var _=s[g],y=_[0],m=_[1]/2+Np,x=Up(m),b=Pp(m),w=y-h,M=w>=0?1:-1,T=M*w,N=T>Mp,k=d*x;if(ud.add(zp(k*M*Up(T),v*b+k*Pp(T))),o+=N?w+M*kp:w,N^h>=e^y>=e){var S=ur(ir(l),ir(_));sr(S);var E=ur(i,S);sr(E);var A=(N^w>=0?-1:1)*Ve(E[2]);(r>A||r===A&&(S[0]||S[1]))&&(u+=N^w>=0?1:-1)}}return(o<-bp||o<bp&&ud<-bp)^1&u}function Vr(t,n,e,r){return function(i){function o(n,e){t(n,e)&&i.point(n,e)}function u(t,n){v.point(t,n)}function a(){x.point=u,v.lineStart()}function c(){x.point=o,v.lineEnd()}function s(t,n){d.push([t,n]),y.point(t,n)}function f(){y.lineStart(),d=[]}function l(){s(d[0][0],d[0][1]),y.lineEnd();var t,n,e,r,o=y.clean(),u=_.result(),a=u.length;if(d.pop(),h.push(d),d=null,a)if(1&o){if(e=u[0],(n=e.length-1)>0){for(m||(i.polygonStart(),m=!0),i.lineStart(),t=0;t<n;++t)i.point((r=e[t])[0],r[1]);i.lineEnd()}}else a>1&&2&o&&u.push(u.pop().concat(u.shift())),p.push(u.filter($r))}var h,p,d,v=n(i),_=Ir(),y=n(_),m=!1,x={point:o,lineStart:a,lineEnd:c,polygonStart:function(){x.point=s,x.lineStart=f,x.lineEnd=l,p=[],h=[]},polygonEnd:function(){x.point=o,x.lineStart=a,x.lineEnd=c,p=g(p);var t=Xr(h,r);p.length?(m||(i.polygonStart(),m=!0),Hr(p,Wr,t,e,i)):t&&(m||(i.polygonStart(),m=!0),i.lineStart(),e(null,null,1,i),i.lineEnd()),m&&(i.polygonEnd(),m=!1),p=h=null},sphere:function(){i.polygonStart(),i.lineStart(),e(null,null,1,i),i.lineEnd(),i.polygonEnd()}};return x}}function $r(t){return t.length>1}function Wr(t,n){return((t=t.x)[0]<0?t[1]-Tp-bp:Tp-t[1])-((n=n.x)[0]<0?n[1]-Tp-bp:Tp-n[1])}function Zr(t){function n(t,n){return Pp(t)*Pp(n)>i}function e(t,n,e){var r=[1,0,0],o=ur(ir(t),ir(n)),u=or(o,o),a=o[0],c=u-a*a;if(!c)return!e&&t;var s=i*u/c,f=-i*a/c,l=ur(r,o),h=cr(r,s);ar(h,cr(o,f));var p=l,d=or(h,p),v=or(p,p),g=d*d-v*(or(h,h)-1);if(!(g<0)){var _=Fp(g),y=cr(p,(-d-_)/v);if(ar(y,h),y=rr(y),!e)return y;var m,x=t[0],b=n[0],w=t[1],M=n[1];b<x&&(m=x,x=b,b=m);var T=b-x,N=Ap(T-Mp)<bp;if(!N&&M<w&&(m=w,w=M,M=m),N||T<bp?N?w+M>0^y[1]<(Ap(y[0]-x)<bp?w:M):w<=y[1]&&y[1]<=M:T>Mp^(x<=y[0]&&y[0]<=b)){var k=cr(p,(-d+_)/v);return ar(k,h),[y,rr(k)]}}}function r(n,e){var r=u?t:Mp-t,i=0;return n<-r?i|=1:n>r&&(i|=2),e<-r?i|=4:e>r&&(i|=8),i}var i=Pp(t),o=6*Ep,u=i>0,a=Ap(i)>bp;return Vr(n,function(t){var i,o,c,s,f;return{lineStart:function(){s=c=!1,f=1},point:function(l,h){var p,d=[l,h],v=n(l,h),g=u?v?0:r(l,h):v?r(l+(l<0?Mp:-Mp),h):0;if(!i&&(s=c=v)&&t.lineStart(),v!==c&&(!(p=e(i,d))||Yr(i,p)||Yr(d,p))&&(d[0]+=bp,d[1]+=bp,v=n(d[0],d[1])),v!==c)f=0,v?(t.lineStart(),p=e(d,i),t.point(p[0],p[1])):(p=e(i,d),t.point(p[0],p[1]),t.lineEnd()),i=p;else if(a&&i&&u^v){var _;g&o||!(_=e(d,i,!0))||(f=0,u?(t.lineStart(),t.point(_[0][0],_[0][1]),t.point(_[1][0],_[1][1]),t.lineEnd()):(t.point(_[1][0],_[1][1]),t.lineEnd(),t.lineStart(),t.point(_[0][0],_[0][1])))}!v||i&&Yr(i,d)||t.point(d[0],d[1]),i=d,c=v,o=g},lineEnd:function(){c&&t.lineEnd(),i=null},clean:function(){return f|(s&&c)<<1}}},function(n,e,r,i){Or(i,t,o,r,n,e)},u?[0,-t]:[-Mp,t-Mp])}function Gr(t,n,e,r){function i(i,o){return t<=i&&i<=e&&n<=o&&o<=r}function o(i,o,a,s){var f=0,l=0;if(null==i||(f=u(i,a))!==(l=u(o,a))||c(i,o)<0^a>0)do{s.point(0===f||3===f?t:e,f>1?r:n)}while((f=(f+a+4)%4)!==l);else s.point(o[0],o[1])}function u(r,i){return Ap(r[0]-t)<bp?i>0?0:3:Ap(r[0]-e)<bp?i>0?2:1:Ap(r[1]-n)<bp?i>0?1:0:i>0?3:2}function a(t,n){return c(t.x,n.x)}function c(t,n){var e=u(t,1),r=u(n,1);return e!==r?e-r:0===e?n[1]-t[1]:1===e?t[0]-n[0]:2===e?t[1]-n[1]:n[0]-t[0]}return function(u){function c(t,n){i(t,n)&&w.point(t,n)}function s(o,u){var a=i(o,u);if(l&&h.push([o,u]),x)p=o,d=u,v=a,x=!1,a&&(w.lineStart(),w.point(o,u));else if(a&&m)w.point(o,u);else{var c=[_=Math.max(sd,Math.min(cd,_)),y=Math.max(sd,Math.min(cd,y))],s=[o=Math.max(sd,Math.min(cd,o)),u=Math.max(sd,Math.min(cd,u))];!function(t,n,e,r,i,o){var u,a=t[0],c=t[1],s=0,f=1,l=n[0]-a,h=n[1]-c;if(u=e-a,l||!(u>0)){if(u/=l,l<0){if(u<s)return;u<f&&(f=u)}else if(l>0){if(u>f)return;u>s&&(s=u)}if(u=i-a,l||!(u<0)){if(u/=l,l<0){if(u>f)return;u>s&&(s=u)}else if(l>0){if(u<s)return;u<f&&(f=u)}if(u=r-c,h||!(u>0)){if(u/=h,h<0){if(u<s)return;u<f&&(f=u)}else if(h>0){if(u>f)return;u>s&&(s=u)}if(u=o-c,h||!(u<0)){if(u/=h,h<0){if(u>f)return;u>s&&(s=u)}else if(h>0){if(u<s)return;u<f&&(f=u)}return s>0&&(t[0]=a+s*l,t[1]=c+s*h),f<1&&(n[0]=a+f*l,n[1]=c+f*h),!0}}}}}(c,s,t,n,e,r)?a&&(w.lineStart(),w.point(o,u),b=!1):(m||(w.lineStart(),w.point(c[0],c[1])),w.point(s[0],s[1]),a||w.lineEnd(),b=!1)}_=o,y=u,m=a}var f,l,h,p,d,v,_,y,m,x,b,w=u,M=Ir(),T={point:c,lineStart:function(){T.point=s,l&&l.push(h=[]),x=!0,m=!1,_=y=NaN},lineEnd:function(){f&&(s(p,d),v&&m&&M.rejoin(),f.push(M.result())),T.point=c,m&&w.lineEnd()},polygonStart:function(){w=M,f=[],l=[],b=!0},polygonEnd:function(){var n=function(){for(var n=0,e=0,i=l.length;e<i;++e)for(var o,u,a=l[e],c=1,s=a.length,f=a[0],h=f[0],p=f[1];c<s;++c)o=h,u=p,h=(f=a[c])[0],p=f[1],u<=r?p>r&&(h-o)*(r-u)>(p-u)*(t-o)&&++n:p<=r&&(h-o)*(r-u)<(p-u)*(t-o)&&--n;return n}(),e=b&&n,i=(f=g(f)).length;(e||i)&&(u.polygonStart(),e&&(u.lineStart(),o(null,null,1,u),u.lineEnd()),i&&Hr(f,a,n,o,u),u.polygonEnd()),w=u,f=l=h=null}};return T}}function Qr(){ld.point=ld.lineEnd=We}function Jr(t,n){Zp=t*=Ep,Gp=Up(n*=Ep),Qp=Pp(n),ld.point=Kr}function Kr(t,n){t*=Ep;var e=Up(n*=Ep),r=Pp(n),i=Ap(t-Zp),o=Pp(i),u=r*Up(i),a=Qp*e-Gp*r*o,c=Gp*e+Qp*r*o;fd.add(zp(Fp(u*u+a*a),c)),Zp=t,Gp=e,Qp=r}function ti(t){return fd.reset(),Je(t,ld),+fd}function ni(t,n){return hd[0]=t,hd[1]=n,ti(pd)}function ei(t,n){return!(!t||!vd.hasOwnProperty(t.type))&&vd[t.type](t,n)}function ri(t,n){return 0===ni(t,n)}function ii(t,n){var e=ni(t[0],t[1]);return ni(t[0],n)+ni(n,t[1])<=e+bp}function oi(t,n){return!!Xr(t.map(ui),ai(n))}function ui(t){return(t=t.map(ai)).pop(),t}function ai(t){return[t[0]*Ep,t[1]*Ep]}function ci(t,n,e){var r=f(t,n-bp,e).concat(n);return function(t){return r.map(function(n){return[t,n]})}}function si(t,n,e){var r=f(t,n-bp,e).concat(n);return function(t){return r.map(function(n){return[n,t]})}}function fi(){function t(){return{type:"MultiLineString",coordinates:n()}}function n(){return f(Rp(o/_)*_,i,_).map(p).concat(f(Rp(s/y)*y,c,y).map(d)).concat(f(Rp(r/v)*v,e,v).filter(function(t){return Ap(t%_)>bp}).map(l)).concat(f(Rp(a/g)*g,u,g).filter(function(t){return Ap(t%y)>bp}).map(h))}var e,r,i,o,u,a,c,s,l,h,p,d,v=10,g=v,_=90,y=360,m=2.5;return t.lines=function(){return n().map(function(t){return{type:"LineString",coordinates:t}})},t.outline=function(){return{type:"Polygon",coordinates:[p(o).concat(d(c).slice(1),p(i).reverse().slice(1),d(s).reverse().slice(1))]}},t.extent=function(n){return arguments.length?t.extentMajor(n).extentMinor(n):t.extentMinor()},t.extentMajor=function(n){return arguments.length?(o=+n[0][0],i=+n[1][0],s=+n[0][1],c=+n[1][1],o>i&&(n=o,o=i,i=n),s>c&&(n=s,s=c,c=n),t.precision(m)):[[o,s],[i,c]]},t.extentMinor=function(n){return arguments.length?(r=+n[0][0],e=+n[1][0],a=+n[0][1],u=+n[1][1],r>e&&(n=r,r=e,e=n),a>u&&(n=a,a=u,u=n),t.precision(m)):[[r,a],[e,u]]},t.step=function(n){return arguments.length?t.stepMajor(n).stepMinor(n):t.stepMinor()},t.stepMajor=function(n){return arguments.length?(_=+n[0],y=+n[1],t):[_,y]},t.stepMinor=function(n){return arguments.length?(v=+n[0],g=+n[1],t):[v,g]},t.precision=function(n){return arguments.length?(m=+n,l=ci(a,u,90),h=si(r,e,m),p=ci(s,c,90),d=si(o,i,m),t):m},t.extentMajor([[-180,-90+bp],[180,90-bp]]).extentMinor([[-180,-80-bp],[180,80+bp]])}function li(t){return t}function hi(){yd.point=pi}function pi(t,n){yd.point=di,Jp=td=t,Kp=nd=n}function di(t,n){_d.add(nd*t-td*n),td=t,nd=n}function vi(){di(Jp,Kp)}function gi(t,n){Td+=t,Nd+=n,++kd}function _i(){Rd.point=yi}function yi(t,n){Rd.point=mi,gi(id=t,od=n)}function mi(t,n){var e=t-id,r=n-od,i=Fp(e*e+r*r);Sd+=i*(id+t)/2,Ed+=i*(od+n)/2,Ad+=i,gi(id=t,od=n)}function xi(){Rd.point=gi}function bi(){Rd.point=Mi}function wi(){Ti(ed,rd)}function Mi(t,n){Rd.point=Ti,gi(ed=id=t,rd=od=n)}function Ti(t,n){var e=t-id,r=n-od,i=Fp(e*e+r*r);Sd+=i*(id+t)/2,Ed+=i*(od+n)/2,Ad+=i,Cd+=(i=od*t-id*n)*(id+t),zd+=i*(od+n),Pd+=3*i,gi(id=t,od=n)}function Ni(t){this._context=t}function ki(t,n){Id.point=Si,qd=Ud=t,Dd=Od=n}function Si(t,n){Ud-=t,Od-=n,Fd.add(Fp(Ud*Ud+Od*Od)),Ud=t,Od=n}function Ei(){this._string=[]}function Ai(t){return"m0,"+t+"a"+t+","+t+" 0 1,1 0,"+-2*t+"a"+t+","+t+" 0 1,1 0,"+2*t+"z"}function Ci(t){return function(n){var e=new zi;for(var r in t)e[r]=t[r];return e.stream=n,e}}function zi(){}function Pi(t,n,e){var r=t.clipExtent&&t.clipExtent();return t.scale(150).translate([0,0]),null!=r&&t.clipExtent(null),Je(e,t.stream(Md)),n(Md.result()),null!=r&&t.clipExtent(r),t}function Ri(t,n,e){return Pi(t,function(e){var r=n[1][0]-n[0][0],i=n[1][1]-n[0][1],o=Math.min(r/(e[1][0]-e[0][0]),i/(e[1][1]-e[0][1])),u=+n[0][0]+(r-o*(e[1][0]+e[0][0]))/2,a=+n[0][1]+(i-o*(e[1][1]+e[0][1]))/2;t.scale(150*o).translate([u,a])},e)}function Li(t,n,e){return Ri(t,[[0,0],n],e)}function qi(t,n,e){return Pi(t,function(e){var r=+n,i=r/(e[1][0]-e[0][0]),o=(r-i*(e[1][0]+e[0][0]))/2,u=-i*e[0][1];t.scale(150*i).translate([o,u])},e)}function Di(t,n,e){return Pi(t,function(e){var r=+n,i=r/(e[1][1]-e[0][1]),o=-i*e[0][0],u=(r-i*(e[1][1]+e[0][1]))/2;t.scale(150*i).translate([o,u])},e)}function Ui(t,n){return+n?function(t,n){function e(r,i,o,u,a,c,s,f,l,h,p,d,v,g){var _=s-r,y=f-i,m=_*_+y*y;if(m>4*n&&v--){var x=u+h,b=a+p,w=c+d,M=Fp(x*x+b*b+w*w),T=Ve(w/=M),N=Ap(Ap(w)-1)<bp||Ap(o-l)<bp?(o+l)/2:zp(b,x),k=t(N,T),S=k[0],E=k[1],A=S-r,C=E-i,z=y*A-_*C;(z*z/m>n||Ap((_*A+y*C)/m-.5)>.3||u*h+a*p+c*d<Bd)&&(e(r,i,o,u,a,c,S,E,N,x/=M,b/=M,w,v,g),g.point(S,E),e(S,E,N,x,b,w,s,f,l,h,p,d,v,g))}}return function(n){function r(e,r){e=t(e,r),n.point(e[0],e[1])}function i(){_=NaN,w.point=o,n.lineStart()}function o(r,i){var o=ir([r,i]),u=t(r,i);e(_,y,g,m,x,b,_=u[0],y=u[1],g=r,m=o[0],x=o[1],b=o[2],Yd,n),n.point(_,y)}function u(){w.point=r,n.lineEnd()}function a(){i(),w.point=c,w.lineEnd=s}function c(t,n){o(f=t,n),l=_,h=y,p=m,d=x,v=b,w.point=o}function s(){e(_,y,g,m,x,b,l,h,f,p,d,v,Yd,n),w.lineEnd=u,u()}var f,l,h,p,d,v,g,_,y,m,x,b,w={point:r,lineStart:i,lineEnd:u,polygonStart:function(){n.polygonStart(),w.lineStart=a},polygonEnd:function(){n.polygonEnd(),w.lineStart=i}};return w}}(t,n):function(t){return Ci({point:function(n,e){n=t(n,e),this.stream.point(n[0],n[1])}})}(t)}function Oi(t){return Fi(function(){return t})()}function Fi(t){function n(t){return t=s(t[0]*Ep,t[1]*Ep),[t[0]*v+u,a-t[1]*v]}function e(t,n){return t=o(t,n),[t[0]*v+u,a-t[1]*v]}function r(){s=zr(c=Rr(x,b,w),o);var t=o(y,m);return u=g-t[0]*v,a=_+t[1]*v,i()}function i(){return p=d=null,n}var o,u,a,c,s,f,l,h,p,d,v=150,g=480,_=250,y=0,m=0,x=0,b=0,w=0,M=null,T=ad,N=null,k=li,S=.5,E=Ui(e,S);return n.stream=function(t){return p&&d===t?p:p=Hd(function(t){return Ci({point:function(n,e){var r=t(n,e);return this.stream.point(r[0],r[1])}})}(c)(T(E(k(d=t)))))},n.preclip=function(t){return arguments.length?(T=t,M=void 0,i()):T},n.postclip=function(t){return arguments.length?(k=t,N=f=l=h=null,i()):k},n.clipAngle=function(t){return arguments.length?(T=+t?Zr(M=t*Ep):(M=null,ad),i()):M*Sp},n.clipExtent=function(t){return arguments.length?(k=null==t?(N=f=l=h=null,li):Gr(N=+t[0][0],f=+t[0][1],l=+t[1][0],h=+t[1][1]),i()):null==N?null:[[N,f],[l,h]]},n.scale=function(t){return arguments.length?(v=+t,r()):v},n.translate=function(t){return arguments.length?(g=+t[0],_=+t[1],r()):[g,_]},n.center=function(t){return arguments.length?(y=t[0]%360*Ep,m=t[1]%360*Ep,r()):[y*Sp,m*Sp]},n.rotate=function(t){return arguments.length?(x=t[0]%360*Ep,b=t[1]%360*Ep,w=t.length>2?t[2]%360*Ep:0,r()):[x*Sp,b*Sp,w*Sp]},n.precision=function(t){return arguments.length?(E=Ui(e,S=t*t),i()):Fp(S)},n.fitExtent=function(t,e){return Ri(n,t,e)},n.fitSize=function(t,e){return Li(n,t,e)},n.fitWidth=function(t,e){return qi(n,t,e)},n.fitHeight=function(t,e){return Di(n,t,e)},function(){return o=t.apply(this,arguments),n.invert=o.invert&&function(t){return(t=s.invert((t[0]-u)/v,(a-t[1])/v))&&[t[0]*Sp,t[1]*Sp]},r()}}function Ii(t){var n=0,e=Mp/3,r=Fi(t),i=r(n,e);return i.parallels=function(t){return arguments.length?r(n=t[0]*Ep,e=t[1]*Ep):[n*Sp,e*Sp]},i}function Yi(t,n){function e(t,n){var e=Fp(o-2*i*Up(n))/i;return[e*Up(t*=i),u-e*Pp(t)]}var r=Up(t),i=(r+Up(n))/2;if(Ap(i)<bp)return function(t){function n(t,n){return[t*e,Up(n)/e]}var e=Pp(t);return n.invert=function(t,n){return[t/e,Ve(n*e)]},n}(t);var o=1+r*(2*i-r),u=Fp(o)/i;return e.invert=function(t,n){var e=u-n;return[zp(t,Ap(e))/i*Op(e),Ve((o-(t*t+e*e)*i*i)/(2*i))]},e}function Bi(){return Ii(Yi).scale(155.424).center([0,33.6442])}function Hi(){return Bi().parallels([29.5,45.5]).scale(1070).translate([480,250]).rotate([96,0]).center([-.6,38.7])}function ji(t){return function(n,e){var r=Pp(n),i=Pp(e),o=t(r*i);return[o*i*Up(n),o*Up(e)]}}function Xi(t){return function(n,e){var r=Fp(n*n+e*e),i=t(r),o=Up(i),u=Pp(i);return[zp(n*o,r*u),Ve(r&&e*o/r)]}}function Vi(t,n){return[t,qp(Ip((Tp+n)/2))]}function $i(t){function n(){var n=Mp*a(),u=o(Ur(o.rotate()).invert([0,0]));return s(null==f?[[u[0]-n,u[1]-n],[u[0]+n,u[1]+n]]:t===Vi?[[Math.max(u[0]-n,f),e],[Math.min(u[0]+n,r),i]]:[[f,Math.max(u[1]-n,e)],[r,Math.min(u[1]+n,i)]])}var e,r,i,o=Oi(t),u=o.center,a=o.scale,c=o.translate,s=o.clipExtent,f=null;return o.scale=function(t){return arguments.length?(a(t),n()):a()},o.translate=function(t){return arguments.length?(c(t),n()):c()},o.center=function(t){return arguments.length?(u(t),n()):u()},o.clipExtent=function(t){return arguments.length?(null==t?f=e=r=i=null:(f=+t[0][0],e=+t[0][1],r=+t[1][0],i=+t[1][1]),n()):null==f?null:[[f,e],[r,i]]},n()}function Wi(t){return Ip((Tp+t)/2)}function Zi(t,n){function e(t,n){o>0?n<-Tp+bp&&(n=-Tp+bp):n>Tp-bp&&(n=Tp-bp);var e=o/Dp(Wi(n),i);return[e*Up(i*t),o-e*Pp(i*t)]}var r=Pp(t),i=t===n?Up(t):qp(r/Pp(n))/qp(Wi(n)/Wi(t)),o=r*Dp(Wi(t),i)/i;return i?(e.invert=function(t,n){var e=o-n,r=Op(i)*Fp(t*t+e*e);return[zp(t,Ap(e))/i*Op(e),2*Cp(Dp(o/r,1/i))-Tp]},e):Vi}function Gi(t,n){return[t,n]}function Qi(t,n){function e(t,n){var e=o-n,r=i*t;return[e*Up(r),o-e*Pp(r)]}var r=Pp(t),i=t===n?Up(t):(r-Pp(n))/(n-t),o=r/i+t;return Ap(i)<bp?Gi:(e.invert=function(t,n){var e=o-n;return[zp(t,Ap(e))/i*Op(e),o-Op(i)*Fp(t*t+e*e)]},e)}function Ji(t,n){var e=Pp(n),r=Pp(t)*e;return[e*Up(t)/r,Up(n)/r]}function Ki(t,n,e,r){return 1===t&&1===n&&0===e&&0===r?li:Ci({point:function(i,o){this.stream.point(i*t+e,o*n+r)}})}function to(t,n){var e=n*n,r=e*e;return[t*(.8707-.131979*e+r*(r*(.003971*e-.001529*r)-.013791)),n*(1.007226+e*(.015085+r*(.028874*e-.044475-.005916*r)))]}function no(t,n){return[Pp(n)*Up(t),Up(n)]}function eo(t,n){var e=Pp(n),r=1+Pp(t)*e;return[e*Up(t)/r,Up(n)/r]}function ro(t,n){return[qp(Ip((Tp+n)/2)),-t]}function io(t,n){return t.parent===n.parent?1:2}function oo(t,n){return t+n.x}function uo(t,n){return Math.max(t,n.y)}function ao(t){var n=0,e=t.children,r=e&&e.length;if(r)for(;--r>=0;)n+=e[r].value;else n=1;t.value=n}function co(t,n){var e,r,i,o,u,a=new ho(t),c=+t.value&&(a.value=t.value),s=[a];for(null==n&&(n=so);e=s.pop();)if(c&&(e.value=+e.data.value),(i=n(e.data))&&(u=i.length))for(e.children=new Array(u),o=u-1;o>=0;--o)s.push(r=e.children[o]=new ho(i[o])),r.parent=e,r.depth=e.depth+1;return a.eachBefore(lo)}function so(t){return t.children}function fo(t){t.data=t.data.data}function lo(t){var n=0;do{t.height=n}while((t=t.parent)&&t.height<++n)}function ho(t){this.data=t,this.depth=this.height=0,this.parent=null}function po(t){for(var n,e,r=0,i=(t=function(t){for(var n,e,r=t.length;r;)e=Math.random()*r--|0,n=t[r],t[r]=t[e],t[e]=n;return t}(Vd.call(t))).length,o=[];r<i;)n=t[r],e&&go(e,n)?++r:(e=function(t){switch(t.length){case 1:return function(t){return{x:t.x,y:t.y,r:t.r}}(t[0]);case 2:return yo(t[0],t[1]);case 3:return mo(t[0],t[1],t[2])}}(o=function(t,n){var e,r;if(_o(n,t))return[n];for(e=0;e<t.length;++e)if(vo(n,t[e])&&_o(yo(t[e],n),t))return[t[e],n];for(e=0;e<t.length-1;++e)for(r=e+1;r<t.length;++r)if(vo(yo(t[e],t[r]),n)&&vo(yo(t[e],n),t[r])&&vo(yo(t[r],n),t[e])&&_o(mo(t[e],t[r],n),t))return[t[e],t[r],n];throw new Error}(o,n)),r=0);return e}function vo(t,n){var e=t.r-n.r,r=n.x-t.x,i=n.y-t.y;return e<0||e*e<r*r+i*i}function go(t,n){var e=t.r-n.r+1e-6,r=n.x-t.x,i=n.y-t.y;return e>0&&e*e>r*r+i*i}function _o(t,n){for(var e=0;e<n.length;++e)if(!go(t,n[e]))return!1;return!0}function yo(t,n){var e=t.x,r=t.y,i=t.r,o=n.x,u=n.y,a=n.r,c=o-e,s=u-r,f=a-i,l=Math.sqrt(c*c+s*s);return{x:(e+o+c/l*f)/2,y:(r+u+s/l*f)/2,r:(l+i+a)/2}}function mo(t,n,e){var r=t.x,i=t.y,o=t.r,u=n.x,a=n.y,c=n.r,s=e.x,f=e.y,l=e.r,h=r-u,p=r-s,d=i-a,v=i-f,g=c-o,_=l-o,y=r*r+i*i-o*o,m=y-u*u-a*a+c*c,x=y-s*s-f*f+l*l,b=p*d-h*v,w=(d*x-v*m)/(2*b)-r,M=(v*g-d*_)/b,T=(p*m-h*x)/(2*b)-i,N=(h*_-p*g)/b,k=M*M+N*N-1,S=2*(o+w*M+T*N),E=w*w+T*T-o*o,A=-(k?(S+Math.sqrt(S*S-4*k*E))/(2*k):E/S);return{x:r+w+M*A,y:i+T+N*A,r:A}}function xo(t,n,e){var r=t.x,i=t.y,o=n.r+e.r,u=t.r+e.r,a=n.x-r,c=n.y-i,s=a*a+c*c;if(s){var f=.5+((u*=u)-(o*=o))/(2*s),l=Math.sqrt(Math.max(0,2*o*(u+s)-(u-=s)*u-o*o))/(2*s);e.x=r+f*a+l*c,e.y=i+f*c-l*a}else e.x=r+u,e.y=i}function bo(t,n){var e=n.x-t.x,r=n.y-t.y,i=t.r+n.r;return i*i-1e-6>e*e+r*r}function wo(t){var n=t._,e=t.next._,r=n.r+e.r,i=(n.x*e.r+e.x*n.r)/r,o=(n.y*e.r+e.y*n.r)/r;return i*i+o*o}function Mo(t){this._=t,this.next=null,this.previous=null}function To(t){if(!(i=t.length))return 0;var n,e,r,i,o,u,a,c,s,f,l;if(n=t[0],n.x=0,n.y=0,!(i>1))return n.r;if(e=t[1],n.x=-e.r,e.x=n.r,e.y=0,!(i>2))return n.r+e.r;xo(e,n,r=t[2]),n=new Mo(n),e=new Mo(e),r=new Mo(r),n.next=r.previous=e,e.next=n.previous=r,r.next=e.previous=n;t:for(a=3;a<i;++a){xo(n._,e._,r=t[a]),r=new Mo(r),c=e.next,s=n.previous,f=e._.r,l=n._.r;do{if(f<=l){if(bo(c._,r._)){e=c,n.next=e,e.previous=n,--a;continue t}f+=c._.r,c=c.next}else{if(bo(s._,r._)){(n=s).next=e,e.previous=n,--a;continue t}l+=s._.r,s=s.previous}}while(c!==s.next);for(r.previous=n,r.next=e,n.next=e.previous=e=r,o=wo(n);(r=r.next)!==e;)(u=wo(r))<o&&(n=r,o=u);e=n.next}for(n=[e._],r=e;(r=r.next)!==e;)n.push(r._);for(r=po(n),a=0;a<i;++a)n=t[a],n.x-=r.x,n.y-=r.y;return r.r}function No(t){if("function"!=typeof t)throw new Error;return t}function ko(){return 0}function So(t){return function(){return t}}function Eo(t){return Math.sqrt(t.value)}function Ao(t){return function(n){n.children||(n.r=Math.max(0,+t(n)||0))}}function Co(t,n){return function(e){if(r=e.children){var r,i,o,u=r.length,a=t(e)*n||0;if(a)for(i=0;i<u;++i)r[i].r+=a;if(o=To(r),a)for(i=0;i<u;++i)r[i].r-=a;e.r=o+a}}}function zo(t){return function(n){var e=n.parent;n.r*=t,e&&(n.x=e.x+t*n.x,n.y=e.y+t*n.y)}}function Po(t){t.x0=Math.round(t.x0),t.y0=Math.round(t.y0),t.x1=Math.round(t.x1),t.y1=Math.round(t.y1)}function Ro(t,n,e,r,i){for(var o,u=t.children,a=-1,c=u.length,s=t.value&&(r-n)/t.value;++a<c;)(o=u[a]).y0=e,o.y1=i,o.x0=n,o.x1=n+=o.value*s}function Lo(t){return t.id}function qo(t){return t.parentId}function Do(t,n){return t.parent===n.parent?1:2}function Uo(t){var n=t.children;return n?n[0]:t.t}function Oo(t){var n=t.children;return n?n[n.length-1]:t.t}function Fo(t,n,e){var r=e/(n.i-t.i);n.c-=r,n.s+=e,t.c+=r,n.z+=e,n.m+=e}function Io(t,n,e){return t.a.parent===n.parent?t.a:e}function Yo(t,n){this._=t,this.parent=null,this.children=null,this.A=null,this.a=this,this.z=0,this.m=0,this.c=0,this.s=0,this.t=null,this.i=n}function Bo(t,n,e,r,i){for(var o,u=t.children,a=-1,c=u.length,s=t.value&&(i-e)/t.value;++a<c;)(o=u[a]).x0=n,o.x1=r,o.y0=e,o.y1=e+=o.value*s}function Ho(t,n,e,r,i,o){for(var u,a,c,s,f,l,h,p,d,v,g,_=[],y=n.children,m=0,x=0,b=y.length,w=n.value;m<b;){c=i-e,s=o-r;do{f=y[x++].value}while(!f&&x<b);for(l=h=f,g=f*f*(v=Math.max(s/c,c/s)/(w*t)),d=Math.max(h/g,g/l);x<b;++x){if(f+=a=y[x].value,a<l&&(l=a),a>h&&(h=a),g=f*f*v,(p=Math.max(h/g,g/l))>d){f-=a;break}d=p}_.push(u={value:f,dice:c<s,children:y.slice(m,x)}),u.dice?Ro(u,e,r,i,w?r+=s*f/w:o):Bo(u,e,r,w?e+=c*f/w:i,o),w-=f,m=x}return _}function jo(t,n,e){return(n[0]-t[0])*(e[1]-t[1])-(n[1]-t[1])*(e[0]-t[0])}function Xo(t,n){return t[0]-n[0]||t[1]-n[1]}function Vo(t){for(var n=t.length,e=[0,1],r=2,i=2;i<n;++i){for(;r>1&&jo(t[e[r-2]],t[e[r-1]],t[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function $o(t){this._size=t,this._call=this._error=null,this._tasks=[],this._data=[],this._waiting=this._active=this._ended=this._start=0}function Wo(t){if(!t._start)try{(function(t){for(;t._start=t._waiting&&t._active<t._size;){var n=t._ended+t._active,e=t._tasks[n],r=e.length-1,i=e[r];e[r]=function(t,n){return function(e,r){t._tasks[n]&&(--t._active,++t._ended,t._tasks[n]=null,null==t._error&&(null!=e?Zo(t,e):(t._data[n]=r,t._waiting?Wo(t):Go(t))))}}(t,n),--t._waiting,++t._active,e=i.apply(null,e),t._tasks[n]&&(t._tasks[n]=e||tv)}})(t)}catch(n){if(t._tasks[t._ended+t._active-1])Zo(t,n);else if(!t._data)throw n}}function Zo(t,n){var e,r=t._tasks.length;for(t._error=n,t._data=void 0,t._waiting=NaN;--r>=0;)if((e=t._tasks[r])&&(t._tasks[r]=null,e.abort))try{e.abort()}catch(n){}t._active=NaN,Go(t)}function Go(t){if(!t._active&&t._call){var n=t._data;t._data=void 0,t._call(t._error,n)}}function Qo(t){if(null==t)t=1/0;else if(!((t=+t)>=1))throw new Error("invalid concurrency");return new $o(t)}function Jo(){return Math.random()}function Ko(t,n){function e(t){var n,e=s.status;if(!e&&function(t){var n=t.responseType;return n&&"text"!==n?t.response:t.responseText}(s)||e>=200&&e<300||304===e){if(o)try{n=o.call(r,s)}catch(t){return void a.call("error",r,t)}else n=s;a.call("load",r,n)}else a.call("error",r,t)}var r,i,o,u,a=N("beforesend","progress","load","error"),c=ae(),s=new XMLHttpRequest,f=null,l=null,h=0;if("undefined"==typeof XDomainRequest||"withCredentials"in s||!/^(http(s)?:)?\/\//.test(t)||(s=new XDomainRequest),"onload"in s?s.onload=s.onerror=s.ontimeout=e:s.onreadystatechange=function(t){s.readyState>3&&e(t)},s.onprogress=function(t){a.call("progress",r,t)},r={header:function(t,n){return t=(t+"").toLowerCase(),arguments.length<2?c.get(t):(null==n?c.remove(t):c.set(t,n+""),r)},mimeType:function(t){return arguments.length?(i=null==t?null:t+"",r):i},responseType:function(t){return arguments.length?(u=t,r):u},timeout:function(t){return arguments.length?(h=+t,r):h},user:function(t){return arguments.length<1?f:(f=null==t?null:t+"",r)},password:function(t){return arguments.length<1?l:(l=null==t?null:t+"",r)},response:function(t){return o=t,r},get:function(t,n){return r.send("GET",t,n)},post:function(t,n){return r.send("POST",t,n)},send:function(n,e,o){return s.open(n,t,!0,f,l),null==i||c.has("accept")||c.set("accept",i+",*/*"),s.setRequestHeader&&c.each(function(t,n){s.setRequestHeader(n,t)}),null!=i&&s.overrideMimeType&&s.overrideMimeType(i),null!=u&&(s.responseType=u),h>0&&(s.timeout=h),null==o&&"function"==typeof e&&(o=e,e=null),null!=o&&1===o.length&&(o=function(t){return function(n,e){t(null==n?e:null)}}(o)),null!=o&&r.on("error",o).on("load",function(t){o(null,t)}),a.call("beforesend",r,s),s.send(null==e?null:e),r},abort:function(){return s.abort(),r},on:function(){var t=a.on.apply(a,arguments);return t===a?r:t}},null!=n){if("function"!=typeof n)throw new Error("invalid callback: "+n);return r.get(n)}return r}function tu(t,n){return function(e,r){var i=Ko(e).mimeType(t).response(n);if(null!=r){if("function"!=typeof r)throw new Error("invalid callback: "+r);return i.get(r)}return i}}function nu(t,n){return function(e,r,i){arguments.length<3&&(i=r,r=null);var o=Ko(e).mimeType(t);return o.row=function(t){return arguments.length?o.response(function(t,n){return function(e){return t(e.responseText,n)}}(n,r=t)):r},o.row(r),i?o.get(i):o}}function eu(t){function n(n){var o=n+"",u=e.get(o);if(!u){if(i!==gv)return i;e.set(o,u=r.push(n))}return t[(u-1)%t.length]}var e=ae(),r=[],i=gv;return t=null==t?[]:vv.call(t),n.domain=function(t){if(!arguments.length)return r.slice();r=[],e=ae();for(var i,o,u=-1,a=t.length;++u<a;)e.has(o=(i=t[u])+"")||e.set(o,r.push(i));return n},n.range=function(e){return arguments.length?(t=vv.call(e),n):t.slice()},n.unknown=function(t){return arguments.length?(i=t,n):i},n.copy=function(){return eu().domain(r).range(t).unknown(i)},n}function ru(){function t(){var t=i().length,r=u[1]<u[0],h=u[r-0],p=u[1-r];n=(p-h)/Math.max(1,t-c+2*s),a&&(n=Math.floor(n)),h+=(p-h-n*(t-c))*l,e=n*(1-c),a&&(h=Math.round(h),e=Math.round(e));var d=f(t).map(function(t){return h+n*t});return o(r?d.reverse():d)}var n,e,r=eu().unknown(void 0),i=r.domain,o=r.range,u=[0,1],a=!1,c=0,s=0,l=.5;return delete r.unknown,r.domain=function(n){return arguments.length?(i(n),t()):i()},r.range=function(n){return arguments.length?(u=[+n[0],+n[1]],t()):u.slice()},r.rangeRound=function(n){return u=[+n[0],+n[1]],a=!0,t()},r.bandwidth=function(){return e},r.step=function(){return n},r.round=function(n){return arguments.length?(a=!!n,t()):a},r.padding=function(n){return arguments.length?(c=s=Math.max(0,Math.min(1,n)),t()):c},r.paddingInner=function(n){return arguments.length?(c=Math.max(0,Math.min(1,n)),t()):c},r.paddingOuter=function(n){return arguments.length?(s=Math.max(0,Math.min(1,n)),t()):s},r.align=function(n){return arguments.length?(l=Math.max(0,Math.min(1,n)),t()):l},r.copy=function(){return ru().domain(i()).range(u).round(a).paddingInner(c).paddingOuter(s).align(l)},t()}function iu(t){var n=t.copy;return t.padding=t.paddingOuter,delete t.paddingInner,delete t.paddingOuter,t.copy=function(){return iu(n())},t}function ou(t){return function(){return t}}function uu(t){return+t}function au(t,n){return(n-=t=+t)?function(e){return(e-t)/n}:ou(n)}function cu(t,n,e,r){var i=t[0],o=t[1],u=n[0],a=n[1];return o<i?(i=e(o,i),u=r(a,u)):(i=e(i,o),u=r(u,a)),function(t){return u(i(t))}}function su(t,n,e,r){var i=Math.min(t.length,n.length)-1,o=new Array(i),u=new Array(i),a=-1;for(t[i]<t[0]&&(t=t.slice().reverse(),n=n.slice().reverse());++a<i;)o[a]=e(t[a],t[a+1]),u[a]=r(n[a],n[a+1]);return function(n){var e=Ds(t,n,1,i)-1;return u[e](o[e](n))}}function fu(t,n){return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp())}function lu(t,n){function e(){return i=Math.min(a.length,c.length)>2?su:cu,o=u=null,r}function r(n){return(o||(o=i(a,c,f?function(t){return function(n,e){var r=t(n=+n,e=+e);return function(t){return t<=n?0:t>=e?1:r(t)}}}(t):t,s)))(+n)}var i,o,u,a=_v,c=_v,s=cn,f=!1;return r.invert=function(t){return(u||(u=i(c,a,au,f?function(t){return function(n,e){var r=t(n=+n,e=+e);return function(t){return t<=0?n:t>=1?e:r(t)}}}(n):n)))(+t)},r.domain=function(t){return arguments.length?(a=dv.call(t,uu),e()):a.slice()},r.range=function(t){return arguments.length?(c=vv.call(t),e()):c.slice()},r.rangeRound=function(t){return c=vv.call(t),s=sn,e()},r.clamp=function(t){return arguments.length?(f=!!t,e()):f},r.interpolate=function(t){return arguments.length?(s=t,e()):s},e()}function hu(n){var e=n.domain;return n.ticks=function(t){var n=e();return l(n[0],n[n.length-1],null==t?10:t)},n.tickFormat=function(n,r){return function(n,e,r){var i,o=n[0],u=n[n.length-1],a=p(o,u,null==e?10:e);switch((r=Le(null==r?",f":r)).type){case"s":var c=Math.max(Math.abs(o),Math.abs(u));return null!=r.precision||isNaN(i=Ie(a,c))||(r.precision=i),t.formatPrefix(r,c);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(i=Ye(a,Math.max(Math.abs(o),Math.abs(u))))||(r.precision=i-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(i=Fe(a))||(r.precision=i-2*("%"===r.type))}return t.format(r)}(e(),n,r)},n.nice=function(t){null==t&&(t=10);var r,i=e(),o=0,u=i.length-1,a=i[o],c=i[u];return c<a&&(r=a,a=c,c=r,r=o,o=u,u=r),(r=h(a,c,t))>0?r=h(a=Math.floor(a/r)*r,c=Math.ceil(c/r)*r,t):r<0&&(r=h(a=Math.ceil(a*r)/r,c=Math.floor(c*r)/r,t)),r>0?(i[o]=Math.floor(a/r)*r,i[u]=Math.ceil(c/r)*r,e(i)):r<0&&(i[o]=Math.ceil(a*r)/r,i[u]=Math.floor(c*r)/r,e(i)),n},n}function pu(){var t=lu(au,on);return t.copy=function(){return fu(t,pu())},hu(t)}function du(){function t(t){return+t}var n=[0,1];return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=dv.call(e,uu),t):n.slice()},t.copy=function(){return du().domain(n)},hu(t)}function vu(t,n){var e,r=0,i=(t=t.slice()).length-1,o=t[r],u=t[i];return u<o&&(e=r,r=i,i=e,e=o,o=u,u=e),t[r]=n.floor(o),t[i]=n.ceil(u),t}function gu(t,n){return(n=Math.log(n/t))?function(e){return Math.log(e/t)/n}:ou(n)}function _u(t,n){return t<0?function(e){return-Math.pow(-n,e)*Math.pow(-t,1-e)}:function(e){return Math.pow(n,e)*Math.pow(t,1-e)}}function yu(t){return isFinite(t)?+("1e"+t):t<0?0:t}function mu(t){return 10===t?yu:t===Math.E?Math.exp:function(n){return Math.pow(t,n)}}function xu(t){return t===Math.E?Math.log:10===t&&Math.log10||2===t&&Math.log2||(t=Math.log(t),function(n){return Math.log(n)/t})}function bu(t){return function(n){return-t(-n)}}function wu(){function n(){return o=xu(i),u=mu(i),r()[0]<0&&(o=bu(o),u=bu(u)),e}var e=lu(gu,_u).domain([1,10]),r=e.domain,i=10,o=xu(10),u=mu(10);return e.base=function(t){return arguments.length?(i=+t,n()):i},e.domain=function(t){return arguments.length?(r(t),n()):r()},e.ticks=function(t){var n,e=r(),a=e[0],c=e[e.length-1];(n=c<a)&&(p=a,a=c,c=p);var s,f,h,p=o(a),d=o(c),v=null==t?10:+t,g=[];if(!(i%1)&&d-p<v){if(p=Math.round(p)-1,d=Math.round(d)+1,a>0){for(;p<d;++p)for(f=1,s=u(p);f<i;++f)if(!((h=s*f)<a)){if(h>c)break;g.push(h)}}else for(;p<d;++p)for(f=i-1,s=u(p);f>=1;--f)if(!((h=s*f)<a)){if(h>c)break;g.push(h)}}else g=l(p,d,Math.min(d-p,v)).map(u);return n?g.reverse():g},e.tickFormat=function(n,r){if(null==r&&(r=10===i?".0e":","),"function"!=typeof r&&(r=t.format(r)),n===1/0)return r;null==n&&(n=10);var a=Math.max(1,i*n/e.ticks().length);return function(t){var n=t/u(Math.round(o(t)));return n*i<i-.5&&(n*=i),n<=a?r(t):""}},e.nice=function(){return r(vu(r(),{floor:function(t){return u(Math.floor(o(t)))},ceil:function(t){return u(Math.ceil(o(t)))}}))},e.copy=function(){return fu(e,wu().base(i))},e}function Mu(t,n){return t<0?-Math.pow(-t,n):Math.pow(t,n)}function Tu(){var t=1,n=lu(function(n,e){return(e=Mu(e,t)-(n=Mu(n,t)))?function(r){return(Mu(r,t)-n)/e}:ou(e)},function(n,e){return e=Mu(e,t)-(n=Mu(n,t)),function(r){return Mu(n+e*r,1/t)}}),e=n.domain;return n.exponent=function(n){return arguments.length?(t=+n,e(e())):t},n.copy=function(){return fu(n,Tu().exponent(t))},hu(n)}function Nu(){function t(){var t=0,n=Math.max(1,i.length);for(o=new Array(n-1);++t<n;)o[t-1]=v(r,t/n);return e}function e(t){if(!isNaN(t=+t))return i[Ds(o,t)]}var r=[],i=[],o=[];return e.invertExtent=function(t){var n=i.indexOf(t);return n<0?[NaN,NaN]:[n>0?o[n-1]:r[0],n<o.length?o[n]:r[r.length-1]]},e.domain=function(e){if(!arguments.length)return r.slice();r=[];for(var i,o=0,u=e.length;o<u;++o)null==(i=e[o])||isNaN(i=+i)||r.push(i);return r.sort(n),t()},e.range=function(n){return arguments.length?(i=vv.call(n),t()):i.slice()},e.quantiles=function(){return o.slice()},e.copy=function(){return Nu().domain(r).range(i)},e}function ku(){function t(t){if(t<=t)return u[Ds(o,t,0,i)]}function n(){var n=-1;for(o=new Array(i);++n<i;)o[n]=((n+1)*r-(n-i)*e)/(i+1);return t}var e=0,r=1,i=1,o=[.5],u=[0,1];return t.domain=function(t){return arguments.length?(e=+t[0],r=+t[1],n()):[e,r]},t.range=function(t){return arguments.length?(i=(u=vv.call(t)).length-1,n()):u.slice()},t.invertExtent=function(t){var n=u.indexOf(t);return n<0?[NaN,NaN]:n<1?[e,o[0]]:n>=i?[o[i-1],r]:[o[n-1],o[n]]},t.copy=function(){return ku().domain([e,r]).range(u)},hu(t)}function Su(){function t(t){if(t<=t)return e[Ds(n,t,0,r)]}var n=[.5],e=[0,1],r=1;return t.domain=function(i){return arguments.length?(n=vv.call(i),r=Math.min(n.length,e.length-1),t):n.slice()},t.range=function(i){return arguments.length?(e=vv.call(i),r=Math.min(n.length,e.length-1),t):e.slice()},t.invertExtent=function(t){var r=e.indexOf(t);return[n[r-1],n[r]]},t.copy=function(){return Su().domain(n).range(e)},t}function Eu(t,n,e,r){function i(n){return t(n=new Date(+n)),n}return i.floor=i,i.ceil=function(e){return t(e=new Date(e-1)),n(e,1),t(e),e},i.round=function(t){var n=i(t),e=i.ceil(t);return t-n<e-t?n:e},i.offset=function(t,e){return n(t=new Date(+t),null==e?1:Math.floor(e)),t},i.range=function(e,r,o){var u,a=[];if(e=i.ceil(e),o=null==o?1:Math.floor(o),!(e<r&&o>0))return a;do{a.push(u=new Date(+e)),n(e,o),t(e)}while(u<e&&e<r);return a},i.filter=function(e){return Eu(function(n){if(n>=n)for(;t(n),!e(n);)n.setTime(n-1)},function(t,r){if(t>=t)if(r<0)for(;++r<=0;)for(;n(t,-1),!e(t););else for(;--r>=0;)for(;n(t,1),!e(t););})},e&&(i.count=function(n,r){return yv.setTime(+n),mv.setTime(+r),t(yv),t(mv),Math.floor(e(yv,mv))},i.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?i.filter(r?function(n){return r(n)%t==0}:function(n){return i.count(0,n)%t==0}):i:null}),i}function Au(t){return Eu(function(n){n.setDate(n.getDate()-(n.getDay()+7-t)%7),n.setHours(0,0,0,0)},function(t,n){t.setDate(t.getDate()+7*n)},function(t,n){return(n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*wv)/Mv})}function Cu(t){return Eu(function(n){n.setUTCDate(n.getUTCDate()-(n.getUTCDay()+7-t)%7),n.setUTCHours(0,0,0,0)},function(t,n){t.setUTCDate(t.getUTCDate()+7*n)},function(t,n){return(n-t)/Mv})}function zu(t){if(0<=t.y&&t.y<100){var n=new Date(-1,t.m,t.d,t.H,t.M,t.S,t.L);return n.setFullYear(t.y),n}return new Date(t.y,t.m,t.d,t.H,t.M,t.S,t.L)}function Pu(t){if(0<=t.y&&t.y<100){var n=new Date(Date.UTC(-1,t.m,t.d,t.H,t.M,t.S,t.L));return n.setUTCFullYear(t.y),n}return new Date(Date.UTC(t.y,t.m,t.d,t.H,t.M,t.S,t.L))}function Ru(t){return{y:t,m:0,d:1,H:0,M:0,S:0,L:0}}function Lu(t){function n(t,n){return function(e){var r,i,o,u=[],a=-1,c=0,s=t.length;for(e instanceof Date||(e=new Date(+e));++a<s;)37===t.charCodeAt(a)&&(u.push(t.slice(c,a)),null!=(i=bg[r=t.charAt(++a)])?r=t.charAt(++a):i="e"===r?" ":"0",(o=n[r])&&(r=o(e,i)),u.push(r),c=a+1);return u.push(t.slice(c,a)),u.join("")}}function e(t,n){return function(e){var i,o,u=Ru(1900);if(r(u,t,e+="",0)!=e.length)return null;if("Q"in u)return new Date(u.Q);if("p"in u&&(u.H=u.H%12+12*u.p),"V"in u){if(u.V<1||u.V>53)return null;"w"in u||(u.w=1),"Z"in u?(i=(o=(i=Pu(Ru(u.y))).getUTCDay())>4||0===o?rg.ceil(i):rg(i),i=tg.offset(i,7*(u.V-1)),u.y=i.getUTCFullYear(),u.m=i.getUTCMonth(),u.d=i.getUTCDate()+(u.w+6)%7):(i=(o=(i=n(Ru(u.y))).getDay())>4||0===o?Rv.ceil(i):Rv(i),i=Cv.offset(i,7*(u.V-1)),u.y=i.getFullYear(),u.m=i.getMonth(),u.d=i.getDate()+(u.w+6)%7)}else("W"in u||"U"in u)&&("w"in u||(u.w="u"in u?u.u%7:"W"in u?1:0),o="Z"in u?Pu(Ru(u.y)).getUTCDay():n(Ru(u.y)).getDay(),u.m=0,u.d="W"in u?(u.w+6)%7+7*u.W-(o+5)%7:u.w+7*u.U-(o+6)%7);return"Z"in u?(u.H+=u.Z/100|0,u.M+=u.Z%100,Pu(u)):n(u)}}function r(t,n,e,r){for(var i,o,u=0,a=n.length,c=e.length;u<a;){if(r>=c)return-1;if(37===(i=n.charCodeAt(u++))){if(i=n.charAt(u++),!(o=T[i in bg?n.charAt(u++):i])||(r=o(t,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}var i=t.dateTime,o=t.date,u=t.time,a=t.periods,c=t.days,s=t.shortDays,f=t.months,l=t.shortMonths,h=Uu(a),p=Ou(a),d=Uu(c),v=Ou(c),g=Uu(s),_=Ou(s),y=Uu(f),m=Ou(f),x=Uu(l),b=Ou(l),w={a:function(t){return s[t.getDay()]},A:function(t){return c[t.getDay()]},b:function(t){return l[t.getMonth()]},B:function(t){return f[t.getMonth()]},c:null,d:ia,e:ia,f:sa,H:oa,I:ua,j:aa,L:ca,m:fa,M:la,p:function(t){return a[+(t.getHours()>=12)]},Q:Fa,s:Ia,S:ha,u:pa,U:da,V:va,w:ga,W:_a,x:null,X:null,y:ya,Y:ma,Z:xa,"%":Oa},M={a:function(t){return s[t.getUTCDay()]},A:function(t){return c[t.getUTCDay()]},b:function(t){return l[t.getUTCMonth()]},B:function(t){return f[t.getUTCMonth()]},c:null,d:ba,e:ba,f:ka,H:wa,I:Ma,j:Ta,L:Na,m:Sa,M:Ea,p:function(t){return a[+(t.getUTCHours()>=12)]},Q:Fa,s:Ia,S:Aa,u:Ca,U:za,V:Pa,w:Ra,W:La,x:null,X:null,y:qa,Y:Da,Z:Ua,"%":Oa},T={a:function(t,n,e){var r=g.exec(n.slice(e));return r?(t.w=_[r[0].toLowerCase()],e+r[0].length):-1},A:function(t,n,e){var r=d.exec(n.slice(e));return r?(t.w=v[r[0].toLowerCase()],e+r[0].length):-1},b:function(t,n,e){var r=x.exec(n.slice(e));return r?(t.m=b[r[0].toLowerCase()],e+r[0].length):-1},B:function(t,n,e){var r=y.exec(n.slice(e));return r?(t.m=m[r[0].toLowerCase()],e+r[0].length):-1},c:function(t,n,e){return r(t,i,n,e)},d:Wu,e:Wu,f:ta,H:Gu,I:Gu,j:Zu,L:Ku,m:$u,M:Qu,p:function(t,n,e){var r=h.exec(n.slice(e));return r?(t.p=p[r[0].toLowerCase()],e+r[0].length):-1},Q:ea,s:ra,S:Ju,u:Iu,U:Yu,V:Bu,w:Fu,W:Hu,x:function(t,n,e){return r(t,o,n,e)},X:function(t,n,e){return r(t,u,n,e)},y:Xu,Y:ju,Z:Vu,"%":na};return w.x=n(o,w),w.X=n(u,w),w.c=n(i,w),M.x=n(o,M),M.X=n(u,M),M.c=n(i,M),{format:function(t){var e=n(t+="",w);return e.toString=function(){return t},e},parse:function(t){var n=e(t+="",zu);return n.toString=function(){return t},n},utcFormat:function(t){var e=n(t+="",M);return e.toString=function(){return t},e},utcParse:function(t){var n=e(t,Pu);return n.toString=function(){return t},n}}}function qu(t,n,e){var r=t<0?"-":"",i=(r?-t:t)+"",o=i.length;return r+(o<e?new Array(e-o+1).join(n)+i:i)}function Du(t){return t.replace(Tg,"\\$&")}function Uu(t){return new RegExp("^(?:"+t.map(Du).join("|")+")","i")}function Ou(t){for(var n={},e=-1,r=t.length;++e<r;)n[t[e].toLowerCase()]=e;return n}function Fu(t,n,e){var r=wg.exec(n.slice(e,e+1));return r?(t.w=+r[0],e+r[0].length):-1}function Iu(t,n,e){var r=wg.exec(n.slice(e,e+1));return r?(t.u=+r[0],e+r[0].length):-1}function Yu(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.U=+r[0],e+r[0].length):-1}function Bu(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.V=+r[0],e+r[0].length):-1}function Hu(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.W=+r[0],e+r[0].length):-1}function ju(t,n,e){var r=wg.exec(n.slice(e,e+4));return r?(t.y=+r[0],e+r[0].length):-1}function Xu(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.y=+r[0]+(+r[0]>68?1900:2e3),e+r[0].length):-1}function Vu(t,n,e){var r=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e,e+6));return r?(t.Z=r[1]?0:-(r[2]+(r[3]||"00")),e+r[0].length):-1}function $u(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.m=r[0]-1,e+r[0].length):-1}function Wu(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.d=+r[0],e+r[0].length):-1}function Zu(t,n,e){var r=wg.exec(n.slice(e,e+3));return r?(t.m=0,t.d=+r[0],e+r[0].length):-1}function Gu(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.H=+r[0],e+r[0].length):-1}function Qu(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.M=+r[0],e+r[0].length):-1}function Ju(t,n,e){var r=wg.exec(n.slice(e,e+2));return r?(t.S=+r[0],e+r[0].length):-1}function Ku(t,n,e){var r=wg.exec(n.slice(e,e+3));return r?(t.L=+r[0],e+r[0].length):-1}function ta(t,n,e){var r=wg.exec(n.slice(e,e+6));return r?(t.L=Math.floor(r[0]/1e3),e+r[0].length):-1}function na(t,n,e){var r=Mg.exec(n.slice(e,e+1));return r?e+r[0].length:-1}function ea(t,n,e){var r=wg.exec(n.slice(e));return r?(t.Q=+r[0],e+r[0].length):-1}function ra(t,n,e){var r=wg.exec(n.slice(e));return r?(t.Q=1e3*+r[0],e+r[0].length):-1}function ia(t,n){return qu(t.getDate(),n,2)}function oa(t,n){return qu(t.getHours(),n,2)}function ua(t,n){return qu(t.getHours()%12||12,n,2)}function aa(t,n){return qu(1+Cv.count(Wv(t),t),n,3)}function ca(t,n){return qu(t.getMilliseconds(),n,3)}function sa(t,n){return ca(t,n)+"000"}function fa(t,n){return qu(t.getMonth()+1,n,2)}function la(t,n){return qu(t.getMinutes(),n,2)}function ha(t,n){return qu(t.getSeconds(),n,2)}function pa(t){var n=t.getDay();return 0===n?7:n}function da(t,n){return qu(Pv.count(Wv(t),t),n,2)}function va(t,n){var e=t.getDay();return t=e>=4||0===e?Dv(t):Dv.ceil(t),qu(Dv.count(Wv(t),t)+(4===Wv(t).getDay()),n,2)}function ga(t){return t.getDay()}function _a(t,n){return qu(Rv.count(Wv(t),t),n,2)}function ya(t,n){return qu(t.getFullYear()%100,n,2)}function ma(t,n){return qu(t.getFullYear()%1e4,n,4)}function xa(t){var n=t.getTimezoneOffset();return(n>0?"-":(n*=-1,"+"))+qu(n/60|0,"0",2)+qu(n%60,"0",2)}function ba(t,n){return qu(t.getUTCDate(),n,2)}function wa(t,n){return qu(t.getUTCHours(),n,2)}function Ma(t,n){return qu(t.getUTCHours()%12||12,n,2)}function Ta(t,n){return qu(1+tg.count(yg(t),t),n,3)}function Na(t,n){return qu(t.getUTCMilliseconds(),n,3)}function ka(t,n){return Na(t,n)+"000"}function Sa(t,n){return qu(t.getUTCMonth()+1,n,2)}function Ea(t,n){return qu(t.getUTCMinutes(),n,2)}function Aa(t,n){return qu(t.getUTCSeconds(),n,2)}function Ca(t){var n=t.getUTCDay();return 0===n?7:n}function za(t,n){return qu(eg.count(yg(t),t),n,2)}function Pa(t,n){var e=t.getUTCDay();return t=e>=4||0===e?ug(t):ug.ceil(t),qu(ug.count(yg(t),t)+(4===yg(t).getUTCDay()),n,2)}function Ra(t){return t.getUTCDay()}function La(t,n){return qu(rg.count(yg(t),t),n,2)}function qa(t,n){return qu(t.getUTCFullYear()%100,n,2)}function Da(t,n){return qu(t.getUTCFullYear()%1e4,n,4)}function Ua(){return"+0000"}function Oa(){return"%"}function Fa(t){return+t}function Ia(t){return Math.floor(+t/1e3)}function Ya(n){return mg=Lu(n),t.timeFormat=mg.format,t.timeParse=mg.parse,t.utcFormat=mg.utcFormat,t.utcParse=mg.utcParse,mg}function Ba(t){return new Date(t)}function Ha(t){return t instanceof Date?+t:+new Date(+t)}function ja(t,n,r,i,o,u,a,c,s){function f(e){return(a(e)<e?g:u(e)<e?_:o(e)<e?y:i(e)<e?m:n(e)<e?r(e)<e?x:b:t(e)<e?w:M)(e)}function l(n,r,i,o){if(null==n&&(n=10),"number"==typeof n){var u=Math.abs(i-r)/n,a=e(function(t){return t[2]}).right(T,u);a===T.length?(o=p(r/Lg,i/Lg,n),n=t):a?(o=(a=T[u/T[a-1][2]<T[a][2]/u?a-1:a])[1],n=a[0]):(o=Math.max(p(r,i,n),1),n=c)}return null==o?n:n.every(o)}var h=lu(au,on),d=h.invert,v=h.domain,g=s(".%L"),_=s(":%S"),y=s("%I:%M"),m=s("%I %p"),x=s("%a %d"),b=s("%b %d"),w=s("%B"),M=s("%Y"),T=[[a,1,Eg],[a,5,5*Eg],[a,15,15*Eg],[a,30,30*Eg],[u,1,Ag],[u,5,5*Ag],[u,15,15*Ag],[u,30,30*Ag],[o,1,Cg],[o,3,3*Cg],[o,6,6*Cg],[o,12,12*Cg],[i,1,zg],[i,2,2*zg],[r,1,Pg],[n,1,Rg],[n,3,3*Rg],[t,1,Lg]];return h.invert=function(t){return new Date(d(t))},h.domain=function(t){return arguments.length?v(dv.call(t,Ha)):v().map(Ba)},h.ticks=function(t,n){var e,r=v(),i=r[0],o=r[r.length-1],u=o<i;return u&&(e=i,i=o,o=e),e=l(t,i,o,n),e=e?e.range(i,o+1):[],u?e.reverse():e},h.tickFormat=function(t,n){return null==n?f:s(n)},h.nice=function(t,n){var e=v();return(t=l(t,e[0],e[e.length-1],n))?v(vu(e,t)):h},h.copy=function(){return fu(h,ja(t,n,r,i,o,u,a,c,s))},h}function Xa(t){return t.match(/.{6}/g).map(function(t){return"#"+t})}function Va(t){var n=t.length;return function(e){return t[Math.max(0,Math.min(n-1,Math.floor(e*n)))]}}function $a(t){function n(n){var o=(n-e)/(r-e);return t(i?Math.max(0,Math.min(1,o)):o)}var e=0,r=1,i=!1;return n.domain=function(t){return arguments.length?(e=+t[0],r=+t[1],n):[e,r]},n.clamp=function(t){return arguments.length?(i=!!t,n):i},n.interpolator=function(e){return arguments.length?(t=e,n):t},n.copy=function(){return $a(t).domain([e,r]).clamp(i)},hu(n)}function Wa(t){return function(){return t}}function Za(t){return t>=1?e_:t<=-1?-e_:Math.asin(t)}function Ga(t){return t.innerRadius}function Qa(t){return t.outerRadius}function Ja(t){return t.startAngle}function Ka(t){return t.endAngle}function tc(t){return t&&t.padAngle}function nc(t,n,e,r,i,o,u){var a=t-e,c=n-r,s=(u?o:-o)/Kg(a*a+c*c),f=s*c,l=-s*a,h=t+f,p=n+l,d=e+f,v=r+l,g=(h+d)/2,_=(p+v)/2,y=d-h,m=v-p,x=y*y+m*m,b=i-o,w=h*v-d*p,M=(m<0?-1:1)*Kg(Gg(0,b*b*x-w*w)),T=(w*m-y*M)/x,N=(-w*y-m*M)/x,k=(w*m+y*M)/x,S=(-w*y+m*M)/x,E=T-g,A=N-_,C=k-g,z=S-_;return E*E+A*A>C*C+z*z&&(T=k,N=S),{cx:T,cy:N,x01:-f,y01:-l,x11:T*(i/b-1),y11:N*(i/b-1)}}function ec(t){this._context=t}function rc(t){return new ec(t)}function ic(t){return t[0]}function oc(t){return t[1]}function uc(){function t(t){var a,c,s,f=t.length,l=!1;for(null==i&&(u=o(s=te())),a=0;a<=f;++a)!(a<f&&r(c=t[a],a,t))===l&&((l=!l)?u.lineStart():u.lineEnd()),l&&u.point(+n(c,a,t),+e(c,a,t));if(s)return u=null,s+""||null}var n=ic,e=oc,r=Wa(!0),i=null,o=rc,u=null;return t.x=function(e){return arguments.length?(n="function"==typeof e?e:Wa(+e),t):n},t.y=function(n){return arguments.length?(e="function"==typeof n?n:Wa(+n),t):e},t.defined=function(n){return arguments.length?(r="function"==typeof n?n:Wa(!!n),t):r},t.curve=function(n){return arguments.length?(o=n,null!=i&&(u=o(i)),t):o},t.context=function(n){return arguments.length?(null==n?i=u=null:u=o(i=n),t):i},t}function ac(){function t(t){var n,f,l,h,p,d=t.length,v=!1,g=new Array(d),_=new Array(d);for(null==a&&(s=c(p=te())),n=0;n<=d;++n){if(!(n<d&&u(h=t[n],n,t))===v)if(v=!v)f=n,s.areaStart(),s.lineStart();else{for(s.lineEnd(),s.lineStart(),l=n-1;l>=f;--l)s.point(g[l],_[l]);s.lineEnd(),s.areaEnd()}v&&(g[n]=+e(h,n,t),_[n]=+i(h,n,t),s.point(r?+r(h,n,t):g[n],o?+o(h,n,t):_[n]))}if(p)return s=null,p+""||null}function n(){return uc().defined(u).curve(c).context(a)}var e=ic,r=null,i=Wa(0),o=oc,u=Wa(!0),a=null,c=rc,s=null;return t.x=function(n){return arguments.length?(e="function"==typeof n?n:Wa(+n),r=null,t):e},t.x0=function(n){return arguments.length?(e="function"==typeof n?n:Wa(+n),t):e},t.x1=function(n){return arguments.length?(r=null==n?null:"function"==typeof n?n:Wa(+n),t):r},t.y=function(n){return arguments.length?(i="function"==typeof n?n:Wa(+n),o=null,t):i},t.y0=function(n){return arguments.length?(i="function"==typeof n?n:Wa(+n),t):i},t.y1=function(n){return arguments.length?(o=null==n?null:"function"==typeof n?n:Wa(+n),t):o},t.lineX0=t.lineY0=function(){return n().x(e).y(i)},t.lineY1=function(){return n().x(e).y(o)},t.lineX1=function(){return n().x(r).y(i)},t.defined=function(n){return arguments.length?(u="function"==typeof n?n:Wa(!!n),t):u},t.curve=function(n){return arguments.length?(c=n,null!=a&&(s=c(a)),t):c},t.context=function(n){return arguments.length?(null==n?a=s=null:s=c(a=n),t):a},t}function cc(t,n){return n<t?-1:n>t?1:n>=t?0:NaN}function sc(t){return t}function fc(t){this._curve=t}function lc(t){function n(n){return new fc(t(n))}return n._curve=t,n}function hc(t){var n=t.curve;return t.angle=t.x,delete t.x,t.radius=t.y,delete t.y,t.curve=function(t){return arguments.length?n(lc(t)):n()._curve},t}function pc(){return hc(uc().curve(i_))}function dc(){var t=ac().curve(i_),n=t.curve,e=t.lineX0,r=t.lineX1,i=t.lineY0,o=t.lineY1;return t.angle=t.x,delete t.x,t.startAngle=t.x0,delete t.x0,t.endAngle=t.x1,delete t.x1,t.radius=t.y,delete t.y,t.innerRadius=t.y0,delete t.y0,t.outerRadius=t.y1,delete t.y1,t.lineStartAngle=function(){return hc(e())},delete t.lineX0,t.lineEndAngle=function(){return hc(r())},delete t.lineX1,t.lineInnerRadius=function(){return hc(i())},delete t.lineY0,t.lineOuterRadius=function(){return hc(o())},delete t.lineY1,t.curve=function(t){return arguments.length?n(lc(t)):n()._curve},t}function vc(t,n){return[(n=+n)*Math.cos(t-=Math.PI/2),n*Math.sin(t)]}function gc(t){return t.source}function _c(t){return t.target}function yc(t){function n(){var n,a=o_.call(arguments),c=e.apply(this,a),s=r.apply(this,a);if(u||(u=n=te()),t(u,+i.apply(this,(a[0]=c,a)),+o.apply(this,a),+i.apply(this,(a[0]=s,a)),+o.apply(this,a)),n)return u=null,n+""||null}var e=gc,r=_c,i=ic,o=oc,u=null;return n.source=function(t){return arguments.length?(e=t,n):e},n.target=function(t){return arguments.length?(r=t,n):r},n.x=function(t){return arguments.length?(i="function"==typeof t?t:Wa(+t),n):i},n.y=function(t){return arguments.length?(o="function"==typeof t?t:Wa(+t),n):o},n.context=function(t){return arguments.length?(u=null==t?null:t,n):u},n}function mc(t,n,e,r,i){t.moveTo(n,e),t.bezierCurveTo(n=(n+r)/2,e,n,i,r,i)}function xc(t,n,e,r,i){t.moveTo(n,e),t.bezierCurveTo(n,e=(e+i)/2,r,e,r,i)}function bc(t,n,e,r,i){var o=vc(n,e),u=vc(n,e=(e+i)/2),a=vc(r,e),c=vc(r,i);t.moveTo(o[0],o[1]),t.bezierCurveTo(u[0],u[1],a[0],a[1],c[0],c[1])}function wc(){}function Mc(t,n,e){t._context.bezierCurveTo((2*t._x0+t._x1)/3,(2*t._y0+t._y1)/3,(t._x0+2*t._x1)/3,(t._y0+2*t._y1)/3,(t._x0+4*t._x1+n)/6,(t._y0+4*t._y1+e)/6)}function Tc(t){this._context=t}function Nc(t){this._context=t}function kc(t){this._context=t}function Sc(t,n){this._basis=new Tc(t),this._beta=n}function Ec(t,n,e){t._context.bezierCurveTo(t._x1+t._k*(t._x2-t._x0),t._y1+t._k*(t._y2-t._y0),t._x2+t._k*(t._x1-n),t._y2+t._k*(t._y1-e),t._x2,t._y2)}function Ac(t,n){this._context=t,this._k=(1-n)/6}function Cc(t,n){this._context=t,this._k=(1-n)/6}function zc(t,n){this._context=t,this._k=(1-n)/6}function Pc(t,n,e){var r=t._x1,i=t._y1,o=t._x2,u=t._y2;if(t._l01_a>t_){var a=2*t._l01_2a+3*t._l01_a*t._l12_a+t._l12_2a,c=3*t._l01_a*(t._l01_a+t._l12_a);r=(r*a-t._x0*t._l12_2a+t._x2*t._l01_2a)/c,i=(i*a-t._y0*t._l12_2a+t._y2*t._l01_2a)/c}if(t._l23_a>t_){var s=2*t._l23_2a+3*t._l23_a*t._l12_a+t._l12_2a,f=3*t._l23_a*(t._l23_a+t._l12_a);o=(o*s+t._x1*t._l23_2a-n*t._l12_2a)/f,u=(u*s+t._y1*t._l23_2a-e*t._l12_2a)/f}t._context.bezierCurveTo(r,i,o,u,t._x2,t._y2)}function Rc(t,n){this._context=t,this._alpha=n}function Lc(t,n){this._context=t,this._alpha=n}function qc(t,n){this._context=t,this._alpha=n}function Dc(t){this._context=t}function Uc(t){return t<0?-1:1}function Oc(t,n,e){var r=t._x1-t._x0,i=n-t._x1,o=(t._y1-t._y0)/(r||i<0&&-0),u=(e-t._y1)/(i||r<0&&-0),a=(o*i+u*r)/(r+i);return(Uc(o)+Uc(u))*Math.min(Math.abs(o),Math.abs(u),.5*Math.abs(a))||0}function Fc(t,n){var e=t._x1-t._x0;return e?(3*(t._y1-t._y0)/e-n)/2:n}function Ic(t,n,e){var r=t._x0,i=t._y0,o=t._x1,u=t._y1,a=(o-r)/3;t._context.bezierCurveTo(r+a,i+a*n,o-a,u-a*e,o,u)}function Yc(t){this._context=t}function Bc(t){this._context=new Hc(t)}function Hc(t){this._context=t}function jc(t){this._context=t}function Xc(t){var n,e,r=t.length-1,i=new Array(r),o=new Array(r),u=new Array(r);for(i[0]=0,o[0]=2,u[0]=t[0]+2*t[1],n=1;n<r-1;++n)i[n]=1,o[n]=4,u[n]=4*t[n]+2*t[n+1];for(i[r-1]=2,o[r-1]=7,u[r-1]=8*t[r-1]+t[r],n=1;n<r;++n)e=i[n]/o[n-1],o[n]-=e,u[n]-=e*u[n-1];for(i[r-1]=u[r-1]/o[r-1],n=r-2;n>=0;--n)i[n]=(u[n]-i[n+1])/o[n];for(o[r-1]=(t[r]+i[r-1])/2,n=0;n<r-1;++n)o[n]=2*t[n+1]-i[n+1];return[i,o]}function Vc(t,n){this._context=t,this._t=n}function $c(t,n){if((i=t.length)>1)for(var e,r,i,o=1,u=t[n[0]],a=u.length;o<i;++o)for(r=u,u=t[n[o]],e=0;e<a;++e)u[e][1]+=u[e][0]=isNaN(r[e][1])?r[e][0]:r[e][1]}function Wc(t){for(var n=t.length,e=new Array(n);--n>=0;)e[n]=n;return e}function Zc(t,n){return t[n]}function Gc(t){var n=t.map(Qc);return Wc(t).sort(function(t,e){return n[t]-n[e]})}function Qc(t){for(var n,e=0,r=-1,i=t.length;++r<i;)(n=+t[r][1])&&(e+=n);return e}function Jc(t){return function(){return t}}function Kc(t){return t[0]}function ts(t){return t[1]}function ns(){this._=null}function es(t){t.U=t.C=t.L=t.R=t.P=t.N=null}function rs(t,n){var e=n,r=n.R,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function is(t,n){var e=n,r=n.L,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function os(t){for(;t.L;)t=t.L;return t}function us(t,n,e,r){var i=[null,null],o=L_.push(i)-1;return i.left=t,i.right=n,e&&cs(i,t,n,e),r&&cs(i,n,t,r),P_[t.index].halfedges.push(o),P_[n.index].halfedges.push(o),i}function as(t,n,e){var r=[n,e];return r.left=t,r}function cs(t,n,e,r){t[0]||t[1]?t.left===e?t[1]=r:t[0]=r:(t[0]=r,t.left=n,t.right=e)}function ss(t,n,e,r,i){var o,u=t[0],a=t[1],c=u[0],s=u[1],f=0,l=1,h=a[0]-c,p=a[1]-s;if(o=n-c,h||!(o>0)){if(o/=h,h<0){if(o<f)return;o<l&&(l=o)}else if(h>0){if(o>l)return;o>f&&(f=o)}if(o=r-c,h||!(o<0)){if(o/=h,h<0){if(o>l)return;o>f&&(f=o)}else if(h>0){if(o<f)return;o<l&&(l=o)}if(o=e-s,p||!(o>0)){if(o/=p,p<0){if(o<f)return;o<l&&(l=o)}else if(p>0){if(o>l)return;o>f&&(f=o)}if(o=i-s,p||!(o<0)){if(o/=p,p<0){if(o>l)return;o>f&&(f=o)}else if(p>0){if(o<f)return;o<l&&(l=o)}return!(f>0||l<1)||(f>0&&(t[0]=[c+f*h,s+f*p]),l<1&&(t[1]=[c+l*h,s+l*p]),!0)}}}}}function fs(t,n,e,r,i){var o=t[1];if(o)return!0;var u,a,c=t[0],s=t.left,f=t.right,l=s[0],h=s[1],p=f[0],d=f[1],v=(l+p)/2,g=(h+d)/2;if(d===h){if(v<n||v>=r)return;if(l>p){if(c){if(c[1]>=i)return}else c=[v,e];o=[v,i]}else{if(c){if(c[1]<e)return}else c=[v,i];o=[v,e]}}else if(u=(l-p)/(d-h),a=g-u*v,u<-1||u>1)if(l>p){if(c){if(c[1]>=i)return}else c=[(e-a)/u,e];o=[(i-a)/u,i]}else{if(c){if(c[1]<e)return}else c=[(i-a)/u,i];o=[(e-a)/u,e]}else if(h<d){if(c){if(c[0]>=r)return}else c=[n,u*n+a];o=[r,u*r+a]}else{if(c){if(c[0]<n)return}else c=[r,u*r+a];o=[n,u*n+a]}return t[0]=c,t[1]=o,!0}function ls(t,n){var e=t.site,r=n.left,i=n.right;return e===i&&(i=r,r=e),i?Math.atan2(i[1]-r[1],i[0]-r[0]):(e===r?(r=n[1],i=n[0]):(r=n[0],i=n[1]),Math.atan2(r[0]-i[0],i[1]-r[1]))}function hs(t,n){return n[+(n.left!==t.site)]}function ps(t,n){return n[+(n.left===t.site)]}function ds(t){var n=t.P,e=t.N;if(n&&e){var r=n.site,i=t.site,o=e.site;if(r!==o){var u=i[0],a=i[1],c=r[0]-u,s=r[1]-a,f=o[0]-u,l=o[1]-a,h=2*(c*l-s*f);if(!(h>=-O_)){var p=c*c+s*s,d=f*f+l*l,v=(l*p-s*d)/h,g=(c*d-f*p)/h,_=q_.pop()||new function(){es(this),this.x=this.y=this.arc=this.site=this.cy=null};_.arc=t,_.site=i,_.x=v+u,_.y=(_.cy=g+a)+Math.sqrt(v*v+g*g),t.circle=_;for(var y=null,m=R_._;m;)if(_.y<m.y||_.y===m.y&&_.x<=m.x){if(!m.L){y=m.P;break}m=m.L}else{if(!m.R){y=m;break}m=m.R}R_.insert(y,_),y||(C_=_)}}}}function vs(t){var n=t.circle;n&&(n.P||(C_=n.N),R_.remove(n),q_.push(n),es(n),t.circle=null)}function gs(t){var n=D_.pop()||new function(){es(this),this.edge=this.site=this.circle=null};return n.site=t,n}function _s(t){vs(t),z_.remove(t),D_.push(t),es(t)}function ys(t){var n=t.circle,e=n.x,r=n.cy,i=[e,r],o=t.P,u=t.N,a=[t];_s(t);for(var c=o;c.circle&&Math.abs(e-c.circle.x)<U_&&Math.abs(r-c.circle.cy)<U_;)o=c.P,a.unshift(c),_s(c),c=o;a.unshift(c),vs(c);for(var s=u;s.circle&&Math.abs(e-s.circle.x)<U_&&Math.abs(r-s.circle.cy)<U_;)u=s.N,a.push(s),_s(s),s=u;a.push(s),vs(s);var f,l=a.length;for(f=1;f<l;++f)s=a[f],c=a[f-1],cs(s.edge,c.site,s.site,i);c=a[0],(s=a[l-1]).edge=us(c.site,s.site,null,i),ds(c),ds(s)}function ms(t){for(var n,e,r,i,o=t[0],u=t[1],a=z_._;a;)if((r=xs(a,u)-o)>U_)a=a.L;else{if(!((i=o-function(t,n){var e=t.N;if(e)return xs(e,n);var r=t.site;return r[1]===n?r[0]:1/0}(a,u))>U_)){r>-U_?(n=a.P,e=a):i>-U_?(n=a,e=a.N):n=e=a;break}if(!a.R){n=a;break}a=a.R}(function(t){P_[t.index]={site:t,halfedges:[]}})(t);var c=gs(t);if(z_.insert(n,c),n||e){if(n===e)return vs(n),e=gs(n.site),z_.insert(c,e),c.edge=e.edge=us(n.site,c.site),ds(n),void ds(e);if(e){vs(n),vs(e);var s=n.site,f=s[0],l=s[1],h=t[0]-f,p=t[1]-l,d=e.site,v=d[0]-f,g=d[1]-l,_=2*(h*g-p*v),y=h*h+p*p,m=v*v+g*g,x=[(g*y-p*m)/_+f,(h*m-v*y)/_+l];cs(e.edge,s,d,x),c.edge=us(s,t,null,x),e.edge=us(t,d,null,x),ds(n),ds(e)}else c.edge=us(n.site,c.site)}}function xs(t,n){var e=t.site,r=e[0],i=e[1],o=i-n;if(!o)return r;var u=t.P;if(!u)return-1/0;var a=(e=u.site)[0],c=e[1],s=c-n;if(!s)return a;var f=a-r,l=1/o-1/s,h=f/s;return l?(-h+Math.sqrt(h*h-2*l*(f*f/(-2*s)-c+s/2+i-o/2)))/l+r:(r+a)/2}function bs(t,n,e){return(t[0]-e[0])*(n[1]-t[1])-(t[0]-n[0])*(e[1]-t[1])}function ws(t,n){return n[1]-t[1]||n[0]-t[0]}function Ms(t,n){var e,r,i,o=t.sort(ws).pop();for(L_=[],P_=new Array(t.length),z_=new ns,R_=new ns;;)if(i=C_,o&&(!i||o[1]<i.y||o[1]===i.y&&o[0]<i.x))o[0]===e&&o[1]===r||(ms(o),e=o[0],r=o[1]),o=t.pop();else{if(!i)break;ys(i.arc)}if(function(){for(var t,n,e,r,i=0,o=P_.length;i<o;++i)if((t=P_[i])&&(r=(n=t.halfedges).length)){var u=new Array(r),a=new Array(r);for(e=0;e<r;++e)u[e]=e,a[e]=ls(t,L_[n[e]]);for(u.sort(function(t,n){return a[n]-a[t]}),e=0;e<r;++e)a[e]=n[u[e]];for(e=0;e<r;++e)n[e]=a[e]}}(),n){var u=+n[0][0],a=+n[0][1],c=+n[1][0],s=+n[1][1];(function(t,n,e,r){for(var i,o=L_.length;o--;)fs(i=L_[o],t,n,e,r)&&ss(i,t,n,e,r)&&(Math.abs(i[0][0]-i[1][0])>U_||Math.abs(i[0][1]-i[1][1])>U_)||delete L_[o]})(u,a,c,s),function(t,n,e,r){var i,o,u,a,c,s,f,l,h,p,d,v,g=P_.length,_=!0;for(i=0;i<g;++i)if(o=P_[i]){for(u=o.site,a=(c=o.halfedges).length;a--;)L_[c[a]]||c.splice(a,1);for(a=0,s=c.length;a<s;)d=(p=ps(o,L_[c[a]]))[0],v=p[1],l=(f=hs(o,L_[c[++a%s]]))[0],h=f[1],(Math.abs(d-l)>U_||Math.abs(v-h)>U_)&&(c.splice(a,0,L_.push(as(u,p,Math.abs(d-t)<U_&&r-v>U_?[t,Math.abs(l-t)<U_?h:r]:Math.abs(v-r)<U_&&e-d>U_?[Math.abs(h-r)<U_?l:e,r]:Math.abs(d-e)<U_&&v-n>U_?[e,Math.abs(l-e)<U_?h:n]:Math.abs(v-n)<U_&&d-t>U_?[Math.abs(h-n)<U_?l:t,n]:null))-1),++s);s&&(_=!1)}if(_){var y,m,x,b=1/0;for(i=0,_=null;i<g;++i)(o=P_[i])&&(x=(y=(u=o.site)[0]-t)*y+(m=u[1]-n)*m)<b&&(b=x,_=o);if(_){var w=[t,n],M=[t,r],T=[e,r],N=[e,n];_.halfedges.push(L_.push(as(u=_.site,w,M))-1,L_.push(as(u,M,T))-1,L_.push(as(u,T,N))-1,L_.push(as(u,N,w))-1)}}for(i=0;i<g;++i)(o=P_[i])&&(o.halfedges.length||delete P_[i])}(u,a,c,s)}this.edges=L_,this.cells=P_,z_=R_=L_=P_=null}function Ts(t){return function(){return t}}function Ns(t,n,e){this.k=t,this.x=n,this.y=e}function ks(t){return t.__zoom||F_}function Ss(){t.event.stopImmediatePropagation()}function Es(){t.event.preventDefault(),t.event.stopImmediatePropagation()}function As(){return!t.event.button}function Cs(){var t,n,e=this;return e instanceof SVGElement?(t=(e=e.ownerSVGElement||e).width.baseVal.value,n=e.height.baseVal.value):(t=e.clientWidth,n=e.clientHeight),[[0,0],[t,n]]}function zs(){return this.__zoom||F_}function Ps(){return-t.event.deltaY*(t.event.deltaMode?120:1)/500}function Rs(){return"ontouchstart"in this}function Ls(t,n,e){var r=t.invertX(n[0][0])-e[0][0],i=t.invertX(n[1][0])-e[1][0],o=t.invertY(n[0][1])-e[0][1],u=t.invertY(n[1][1])-e[1][1];return t.translate(i>r?(r+i)/2:Math.min(0,r)||Math.max(0,i),u>o?(o+u)/2:Math.min(0,o)||Math.max(0,u))}var qs=e(n),Ds=qs.right,Us=qs.left,Os=Array.prototype,Fs=Os.slice,Is=Os.map,Ys=Math.sqrt(50),Bs=Math.sqrt(10),Hs=Math.sqrt(2),js=Array.prototype.slice,Xs=1,Vs=2,$s=3,Ws=4,Zs=1e-6,Gs={value:function(){}};k.prototype=N.prototype={constructor:k,on:function(t,n){var e,r=this._,i=function(t,n){return t.trim().split(/^|\s+/).map(function(t){var e="",r=t.indexOf(".");if(r>=0&&(e=t.slice(r+1),t=t.slice(0,r)),t&&!n.hasOwnProperty(t))throw new Error("unknown type: "+t);return{type:t,name:e}})}(t+"",r),o=-1,u=i.length;{if(!(arguments.length<2)){if(null!=n&&"function"!=typeof n)throw new Error("invalid callback: "+n);for(;++o<u;)if(e=(t=i[o]).type)r[e]=S(r[e],t.name,n);else if(null==n)for(e in r)r[e]=S(r[e],t.name,null);return this}for(;++o<u;)if((e=(t=i[o]).type)&&(e=function(t,n){for(var e,r=0,i=t.length;r<i;++r)if((e=t[r]).name===n)return e.value}(r[e],t.name)))return e}},copy:function(){var t={},n=this._;for(var e in n)t[e]=n[e].slice();return new k(t)},call:function(t,n){if((e=arguments.length-2)>0)for(var e,r,i=new Array(e),o=0;o<e;++o)i[o]=arguments[o+2];if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(o=0,e=(r=this._[t]).length;o<e;++o)r[o].value.apply(n,i)},apply:function(t,n,e){if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(var r=this._[t],i=0,o=r.length;i<o;++i)r[i].value.apply(n,e)}};var Qs="http://www.w3.org/1999/xhtml",Js={svg:"http://www.w3.org/2000/svg",xhtml:Qs,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},Ks=0;z.prototype=C.prototype={constructor:z,get:function(t){for(var n=this._;!(n in t);)if(!(t=t.parentNode))return;return t[n]},set:function(t,n){return t[this._]=n},remove:function(t){return this._ in t&&delete t[this._]},toString:function(){return this._}};var tf=function(t){return function(){return this.matches(t)}};if("undefined"!=typeof document){var nf=document.documentElement;if(!nf.matches){var ef=nf.webkitMatchesSelector||nf.msMatchesSelector||nf.mozMatchesSelector||nf.oMatchesSelector;tf=function(t){return function(){return ef.call(this,t)}}}}var rf=tf,of={};if(t.event=null,"undefined"!=typeof document){"onmouseenter"in document.documentElement||(of={mouseenter:"mouseover",mouseleave:"mouseout"})}X.prototype={constructor:X,appendChild:function(t){return this._parent.insertBefore(t,this._next)},insertBefore:function(t,n){return this._parent.insertBefore(t,n)},querySelector:function(t){return this._parent.querySelector(t)},querySelectorAll:function(t){return this._parent.querySelectorAll(t)}};var uf="$";K.prototype={add:function(t){this._names.indexOf(t)<0&&(this._names.push(t),this._node.setAttribute("class",this._names.join(" ")))},remove:function(t){var n=this._names.indexOf(t);n>=0&&(this._names.splice(n,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(t){return this._names.indexOf(t)>=0}};var af=[null];st.prototype=ft.prototype={constructor:st,select:function(t){"function"!=typeof t&&(t=Y(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,u,a=n[i],c=a.length,s=r[i]=new Array(c),f=0;f<c;++f)(o=a[f])&&(u=t.call(o,o.__data__,f,a))&&("__data__"in o&&(u.__data__=o.__data__),s[f]=u);return new st(r,this._parents)},selectAll:function(t){"function"!=typeof t&&(t=H(t));for(var n=this._groups,e=n.length,r=[],i=[],o=0;o<e;++o)for(var u,a=n[o],c=a.length,s=0;s<c;++s)(u=a[s])&&(r.push(t.call(u,u.__data__,s,a)),i.push(u));return new st(r,i)},filter:function(t){"function"!=typeof t&&(t=rf(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,u=n[i],a=u.length,c=r[i]=[],s=0;s<a;++s)(o=u[s])&&t.call(o,o.__data__,s,u)&&c.push(o);return new st(r,this._parents)},data:function(t,n){if(!t)return p=new Array(this.size()),s=-1,this.each(function(t){p[++s]=t}),p;var e=n?$:V,r=this._parents,i=this._groups;"function"!=typeof t&&(t=function(t){return function(){return t}}(t));for(var o=i.length,u=new Array(o),a=new Array(o),c=new Array(o),s=0;s<o;++s){var f=r[s],l=i[s],h=l.length,p=t.call(f,f&&f.__data__,s,r),d=p.length,v=a[s]=new Array(d),g=u[s]=new Array(d);e(f,l,v,g,c[s]=new Array(h),p,n);for(var _,y,m=0,x=0;m<d;++m)if(_=v[m]){for(m>=x&&(x=m+1);!(y=g[x])&&++x<d;);_._next=y||null}}return u=new st(u,r),u._enter=a,u._exit=c,u},enter:function(){return new st(this._enter||this._groups.map(j),this._parents)},exit:function(){return new st(this._exit||this._groups.map(j),this._parents)},merge:function(t){for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),u=new Array(r),a=0;a<o;++a)for(var c,s=n[a],f=e[a],l=s.length,h=u[a]=new Array(l),p=0;p<l;++p)(c=s[p]||f[p])&&(h[p]=c);for(;a<r;++a)u[a]=n[a];return new st(u,this._parents)},order:function(){for(var t=this._groups,n=-1,e=t.length;++n<e;)for(var r,i=t[n],o=i.length-1,u=i[o];--o>=0;)(r=i[o])&&(u&&u!==r.nextSibling&&u.parentNode.insertBefore(r,u),u=r);return this},sort:function(t){function n(n,e){return n&&e?t(n.__data__,e.__data__):!n-!e}t||(t=W);for(var e=this._groups,r=e.length,i=new Array(r),o=0;o<r;++o){for(var u,a=e[o],c=a.length,s=i[o]=new Array(c),f=0;f<c;++f)(u=a[f])&&(s[f]=u);s.sort(n)}return new st(i,this._parents).order()},call:function(){var t=arguments[0];return arguments[0]=this,t.apply(null,arguments),this},nodes:function(){var t=new Array(this.size()),n=-1;return this.each(function(){t[++n]=this}),t},node:function(){for(var t=this._groups,n=0,e=t.length;n<e;++n)for(var r=t[n],i=0,o=r.length;i<o;++i){var u=r[i];if(u)return u}return null},size:function(){var t=0;return this.each(function(){++t}),t},empty:function(){return!this.node()},each:function(t){for(var n=this._groups,e=0,r=n.length;e<r;++e)for(var i,o=n[e],u=0,a=o.length;u<a;++u)(i=o[u])&&t.call(i,i.__data__,u,o);return this},attr:function(t,n){var e=E(t);if(arguments.length<2){var r=this.node();return e.local?r.getAttributeNS(e.space,e.local):r.getAttribute(e)}return this.each((null==n?e.local?function(t){return function(){this.removeAttributeNS(t.space,t.local)}}:function(t){return function(){this.removeAttribute(t)}}:"function"==typeof n?e.local?function(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,e)}}:function(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttribute(t):this.setAttribute(t,e)}}:e.local?function(t,n){return function(){this.setAttributeNS(t.space,t.local,n)}}:function(t,n){return function(){this.setAttribute(t,n)}})(e,n))},style:function(t,n,e){return arguments.length>1?this.each((null==n?function(t){return function(){this.style.removeProperty(t)}}:"function"==typeof n?function(t,n,e){return function(){var r=n.apply(this,arguments);null==r?this.style.removeProperty(t):this.style.setProperty(t,r,e)}}:function(t,n,e){return function(){this.style.setProperty(t,n,e)}})(t,n,null==e?"":e)):G(this.node(),t)},property:function(t,n){return arguments.length>1?this.each((null==n?function(t){return function(){delete this[t]}}:"function"==typeof n?function(t,n){return function(){var e=n.apply(this,arguments);null==e?delete this[t]:this[t]=e}}:function(t,n){return function(){this[t]=n}})(t,n)):this.node()[t]},classed:function(t,n){var e=Q(t+"");if(arguments.length<2){for(var r=J(this.node()),i=-1,o=e.length;++i<o;)if(!r.contains(e[i]))return!1;return!0}return this.each(("function"==typeof n?function(t,n){return function(){(n.apply(this,arguments)?tt:nt)(this,t)}}:n?function(t){return function(){tt(this,t)}}:function(t){return function(){nt(this,t)}})(e,n))},text:function(t){return arguments.length?this.each(null==t?et:("function"==typeof t?function(t){return function(){var n=t.apply(this,arguments);this.textContent=null==n?"":n}}:function(t){return function(){this.textContent=t}})(t)):this.node().textContent},html:function(t){return arguments.length?this.each(null==t?rt:("function"==typeof t?function(t){return function(){var n=t.apply(this,arguments);this.innerHTML=null==n?"":n}}:function(t){return function(){this.innerHTML=t}})(t)):this.node().innerHTML},raise:function(){return this.each(it)},lower:function(){return this.each(ot)},append:function(t){var n="function"==typeof t?t:A(t);return this.select(function(){return this.appendChild(n.apply(this,arguments))})},insert:function(t,n){var e="function"==typeof t?t:A(t),r=null==n?ut:"function"==typeof n?n:Y(n);return this.select(function(){return this.insertBefore(e.apply(this,arguments),r.apply(this,arguments)||null)})},remove:function(){return this.each(at)},datum:function(t){return arguments.length?this.property("__data__",t):this.node().__data__},on:function(t,n,e){var r,i,o=function(t){return t.trim().split(/^|\s+/).map(function(t){var n="",e=t.indexOf(".");return e>=0&&(n=t.slice(e+1),t=t.slice(0,e)),{type:t,name:n}})}(t+""),u=o.length;if(!(arguments.length<2)){for(a=n?q:L,null==e&&(e=!1),r=0;r<u;++r)this.each(a(o[r],n,e));return this}var a=this.node().__on;if(a)for(var c,s=0,f=a.length;s<f;++s)for(r=0,c=a[s];r<u;++r)if((i=o[r]).type===c.type&&i.name===c.name)return c.value},dispatch:function(t,n){return this.each(("function"==typeof n?function(t,n){return function(){return ct(this,t,n.apply(this,arguments))}}:function(t,n){return function(){return ct(this,t,n)}})(t,n))}},yt.prototype.on=function(){var t=this._.on.apply(this._,arguments);return t===this._?this:t};var cf="\\s*([+-]?\\d+)\\s*",sf="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",ff="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",lf=/^#([0-9a-f]{3})$/,hf=/^#([0-9a-f]{6})$/,pf=new RegExp("^rgb\\("+[cf,cf,cf]+"\\)$"),df=new RegExp("^rgb\\("+[ff,ff,ff]+"\\)$"),vf=new RegExp("^rgba\\("+[cf,cf,cf,sf]+"\\)$"),gf=new RegExp("^rgba\\("+[ff,ff,ff,sf]+"\\)$"),_f=new RegExp("^hsl\\("+[sf,ff,ff]+"\\)$"),yf=new RegExp("^hsla\\("+[sf,ff,ff,sf]+"\\)$"),mf={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};Mt(Nt,kt,{displayable:function(){return this.rgb().displayable()},toString:function(){return this.rgb()+""}}),Mt(zt,Ct,Tt(Nt,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new zt(this.r*t,this.g*t,this.b*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new zt(this.r*t,this.g*t,this.b*t,this.opacity)},rgb:function(){return this},displayable:function(){return 0<=this.r&&this.r<=255&&0<=this.g&&this.g<=255&&0<=this.b&&this.b<=255&&0<=this.opacity&&this.opacity<=1},toString:function(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"rgb(":"rgba(")+Math.max(0,Math.min(255,Math.round(this.r)||0))+", "+Math.max(0,Math.min(255,Math.round(this.g)||0))+", "+Math.max(0,Math.min(255,Math.round(this.b)||0))+(1===t?")":", "+t+")")}})),Mt(Lt,Rt,Tt(Nt,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new Lt(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new Lt(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=this.h%360+360*(this.h<0),n=isNaN(t)||isNaN(this.s)?0:this.s,e=this.l,r=e+(e<.5?e:1-e)*n,i=2*e-r;return new zt(qt(t>=240?t-240:t+120,i,r),qt(t,i,r),qt(t<120?t+240:t-120,i,r),this.opacity)},displayable:function(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1}}));var xf=Math.PI/180,bf=180/Math.PI,wf=.95047,Mf=1,Tf=1.08883,Nf=4/29,kf=6/29,Sf=3*kf*kf,Ef=kf*kf*kf;Mt(Ot,Ut,Tt(Nt,{brighter:function(t){return new Ot(this.l+18*(null==t?1:t),this.a,this.b,this.opacity)},darker:function(t){return new Ot(this.l-18*(null==t?1:t),this.a,this.b,this.opacity)},rgb:function(){var t=(this.l+16)/116,n=isNaN(this.a)?t:t+this.a/500,e=isNaN(this.b)?t:t-this.b/200;return t=Mf*It(t),n=wf*It(n),e=Tf*It(e),new zt(Yt(3.2404542*n-1.5371385*t-.4985314*e),Yt(-.969266*n+1.8760108*t+.041556*e),Yt(.0556434*n-.2040259*t+1.0572252*e),this.opacity)}})),Mt(jt,Ht,Tt(Nt,{brighter:function(t){return new jt(this.h,this.c,this.l+18*(null==t?1:t),this.opacity)},darker:function(t){return new jt(this.h,this.c,this.l-18*(null==t?1:t),this.opacity)},rgb:function(){return Dt(this).rgb()}}));var Af=-.29227,Cf=-.90649,zf=1.97294,Pf=zf*Cf,Rf=1.78277*zf,Lf=1.78277*Af- -.14861*Cf;Mt(Vt,Xt,Tt(Nt,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new Vt(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new Vt(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=isNaN(this.h)?0:(this.h+120)*xf,n=+this.l,e=isNaN(this.s)?0:this.s*n*(1-n),r=Math.cos(t),i=Math.sin(t);return new zt(255*(n+e*(-.14861*r+1.78277*i)),255*(n+e*(Af*r+Cf*i)),255*(n+e*(zf*r)),this.opacity)}}));var qf,Df,Uf,Of,Ff,If,Yf=function t(n){function e(t,n){var e=r((t=Ct(t)).r,(n=Ct(n)).r),i=r(t.g,n.g),o=r(t.b,n.b),u=tn(t.opacity,n.opacity);return function(n){return t.r=e(n),t.g=i(n),t.b=o(n),t.opacity=u(n),t+""}}var r=Kt(n);return e.gamma=t,e}(1),Bf=nn(Wt),Hf=nn(Zt),jf=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Xf=new RegExp(jf.source,"g"),Vf=180/Math.PI,$f={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1},Wf=ln(function(t){return"none"===t?$f:(qf||(qf=document.createElement("DIV"),Df=document.documentElement,Uf=document.defaultView),qf.style.transform=t,t=Uf.getComputedStyle(Df.appendChild(qf),null).getPropertyValue("transform"),Df.removeChild(qf),t=t.slice(7,-1).split(","),fn(+t[0],+t[1],+t[2],+t[3],+t[4],+t[5]))},"px, ","px)","deg)"),Zf=ln(function(t){return null==t?$f:(Of||(Of=document.createElementNS("http://www.w3.org/2000/svg","g")),Of.setAttribute("transform",t),(t=Of.transform.baseVal.consolidate())?(t=t.matrix,fn(t.a,t.b,t.c,t.d,t.e,t.f)):$f)},", ",")",")"),Gf=Math.SQRT2,Qf=2,Jf=4,Kf=1e-12,tl=dn(Jt),nl=dn(tn),el=vn(Jt),rl=vn(tn),il=gn(Jt),ol=gn(tn),ul=0,al=0,cl=0,sl=1e3,fl=0,ll=0,hl=0,pl="object"==typeof performance&&performance.now?performance:Date,dl="object"==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(t){setTimeout(t,17)};mn.prototype=xn.prototype={constructor:mn,restart:function(t,n,e){if("function"!=typeof t)throw new TypeError("callback is not a function");e=(null==e?_n():+e)+(null==n?0:+n),this._next||If===this||(If?If._next=this:Ff=this,If=this),this._call=t,this._time=e,Tn()},stop:function(){this._call&&(this._call=null,this._time=1/0,Tn())}};var vl=N("start","end","interrupt"),gl=[],_l=0,yl=1,ml=2,xl=3,bl=4,wl=5,Ml=6,Tl=ft.prototype.constructor,Nl=0,kl=ft.prototype;Rn.prototype=Ln.prototype={constructor:Rn,select:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=Y(t));for(var r=this._groups,i=r.length,o=new Array(i),u=0;u<i;++u)for(var a,c,s=r[u],f=s.length,l=o[u]=new Array(f),h=0;h<f;++h)(a=s[h])&&(c=t.call(a,a.__data__,h,s))&&("__data__"in a&&(c.__data__=a.__data__),l[h]=c,kn(l[h],n,e,h,l,An(a,e)));return new Rn(o,this._parents,n,e)},selectAll:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=H(t));for(var r=this._groups,i=r.length,o=[],u=[],a=0;a<i;++a)for(var c,s=r[a],f=s.length,l=0;l<f;++l)if(c=s[l]){for(var h,p=t.call(c,c.__data__,l,s),d=An(c,e),v=0,g=p.length;v<g;++v)(h=p[v])&&kn(h,n,e,v,p,d);o.push(p),u.push(c)}return new Rn(o,u,n,e)},filter:function(t){"function"!=typeof t&&(t=rf(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,u=n[i],a=u.length,c=r[i]=[],s=0;s<a;++s)(o=u[s])&&t.call(o,o.__data__,s,u)&&c.push(o);return new Rn(r,this._parents,this._name,this._id)},merge:function(t){if(t._id!==this._id)throw new Error;for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),u=new Array(r),a=0;a<o;++a)for(var c,s=n[a],f=e[a],l=s.length,h=u[a]=new Array(l),p=0;p<l;++p)(c=s[p]||f[p])&&(h[p]=c);for(;a<r;++a)u[a]=n[a];return new Rn(u,this._parents,this._name,this._id)},selection:function(){return new Tl(this._groups,this._parents)},transition:function(){for(var t=this._name,n=this._id,e=qn(),r=this._groups,i=r.length,o=0;o<i;++o)for(var u,a=r[o],c=a.length,s=0;s<c;++s)if(u=a[s]){var f=An(u,n);kn(u,t,e,s,a,{time:f.time+f.delay+f.duration,delay:0,duration:f.duration,ease:f.ease})}return new Rn(r,this._parents,t,e)},call:kl.call,nodes:kl.nodes,node:kl.node,size:kl.size,empty:kl.empty,each:kl.each,on:function(t,n){var e=this._id;return arguments.length<2?An(this.node(),e).on.on(t):this.each(function(t,n,e){var r,i,o=function(t){return(t+"").trim().split(/^|\s+/).every(function(t){var n=t.indexOf(".");return n>=0&&(t=t.slice(0,n)),!t||"start"===t})}(n)?Sn:En;return function(){var u=o(this,t),a=u.on;a!==r&&(i=(r=a).copy()).on(n,e),u.on=i}}(e,t,n))},attr:function(t,n){var e=E(t),r="transform"===e?Zf:Pn;return this.attrTween(t,"function"==typeof n?(e.local?function(t,n,e){var r,i,o;return function(){var u,a=e(this);if(null!=a)return(u=this.getAttributeNS(t.space,t.local))===a?null:u===r&&a===i?o:o=n(r=u,i=a);this.removeAttributeNS(t.space,t.local)}}:function(t,n,e){var r,i,o;return function(){var u,a=e(this);if(null!=a)return(u=this.getAttribute(t))===a?null:u===r&&a===i?o:o=n(r=u,i=a);this.removeAttribute(t)}})(e,r,zn(this,"attr."+t,n)):null==n?(e.local?function(t){return function(){this.removeAttributeNS(t.space,t.local)}}:function(t){return function(){this.removeAttribute(t)}})(e):(e.local?function(t,n,e){var r,i;return function(){var o=this.getAttributeNS(t.space,t.local);return o===e?null:o===r?i:i=n(r=o,e)}}:function(t,n,e){var r,i;return function(){var o=this.getAttribute(t);return o===e?null:o===r?i:i=n(r=o,e)}})(e,r,n+""))},attrTween:function(t,n){var e="attr."+t;if(arguments.length<2)return(e=this.tween(e))&&e._value;if(null==n)return this.tween(e,null);if("function"!=typeof n)throw new Error;var r=E(t);return this.tween(e,(r.local?function(t,n){function e(){var e=this,r=n.apply(e,arguments);return r&&function(n){e.setAttributeNS(t.space,t.local,r(n))}}return e._value=n,e}:function(t,n){function e(){var e=this,r=n.apply(e,arguments);return r&&function(n){e.setAttribute(t,r(n))}}return e._value=n,e})(r,n))},style:function(t,n,e){var r="transform"==(t+="")?Wf:Pn;return null==n?this.styleTween(t,function(t,n){var e,r,i;return function(){var o=G(this,t),u=(this.style.removeProperty(t),G(this,t));return o===u?null:o===e&&u===r?i:i=n(e=o,r=u)}}(t,r)).on("end.style."+t,function(t){return function(){this.style.removeProperty(t)}}(t)):this.styleTween(t,"function"==typeof n?function(t,n,e){var r,i,o;return function(){var u=G(this,t),a=e(this);return null==a&&(this.style.removeProperty(t),a=G(this,t)),u===a?null:u===r&&a===i?o:o=n(r=u,i=a)}}(t,r,zn(this,"style."+t,n)):function(t,n,e){var r,i;return function(){var o=G(this,t);return o===e?null:o===r?i:i=n(r=o,e)}}(t,r,n+""),e)},styleTween:function(t,n,e){var r="style."+(t+="");if(arguments.length<2)return(r=this.tween(r))&&r._value;if(null==n)return this.tween(r,null);if("function"!=typeof n)throw new Error;return this.tween(r,function(t,n,e){function r(){var r=this,i=n.apply(r,arguments);return i&&function(n){r.style.setProperty(t,i(n),e)}}return r._value=n,r}(t,n,null==e?"":e))},text:function(t){return this.tween("text","function"==typeof t?function(t){return function(){var n=t(this);this.textContent=null==n?"":n}}(zn(this,"text",t)):function(t){return function(){this.textContent=t}}(null==t?"":t+""))},remove:function(){return this.on("end.remove",function(t){return function(){var n=this.parentNode;for(var e in this.__transition)if(+e!==t)return;n&&n.removeChild(this)}}(this._id))},tween:function(t,n){var e=this._id;if(t+="",arguments.length<2){for(var r,i=An(this.node(),e).tween,o=0,u=i.length;o<u;++o)if((r=i[o]).name===t)return r.value;return null}return this.each((null==n?function(t,n){var e,r;return function(){var i=En(this,t),o=i.tween;if(o!==e)for(var u=0,a=(r=e=o).length;u<a;++u)if(r[u].name===n){(r=r.slice()).splice(u,1);break}i.tween=r}}:function(t,n,e){var r,i;if("function"!=typeof e)throw new Error;return function(){var o=En(this,t),u=o.tween;if(u!==r){i=(r=u).slice();for(var a={name:n,value:e},c=0,s=i.length;c<s;++c)if(i[c].name===n){i[c]=a;break}c===s&&i.push(a)}o.tween=i}})(e,t,n))},delay:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?function(t,n){return function(){Sn(this,t).delay=+n.apply(this,arguments)}}:function(t,n){return n=+n,function(){Sn(this,t).delay=n}})(n,t)):An(this.node(),n).delay},duration:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?function(t,n){return function(){En(this,t).duration=+n.apply(this,arguments)}}:function(t,n){return n=+n,function(){En(this,t).duration=n}})(n,t)):An(this.node(),n).duration},ease:function(t){var n=this._id;return arguments.length?this.each(function(t,n){if("function"!=typeof n)throw new Error;return function(){En(this,t).ease=n}}(n,t)):An(this.node(),n).ease}};var Sl=function t(n){function e(t){return Math.pow(t,n)}return n=+n,e.exponent=t,e}(3),El=function t(n){function e(t){return 1-Math.pow(1-t,n)}return n=+n,e.exponent=t,e}(3),Al=function t(n){function e(t){return((t*=2)<=1?Math.pow(t,n):2-Math.pow(2-t,n))/2}return n=+n,e.exponent=t,e}(3),Cl=Math.PI,zl=Cl/2,Pl=4/11,Rl=6/11,Ll=8/11,ql=.75,Dl=9/11,Ul=10/11,Ol=.9375,Fl=21/22,Il=63/64,Yl=1/Pl/Pl,Bl=function t(n){function e(t){return t*t*((n+1)*t-n)}return n=+n,e.overshoot=t,e}(1.70158),Hl=function t(n){function e(t){return--t*t*((n+1)*t+n)+1}return n=+n,e.overshoot=t,e}(1.70158),jl=function t(n){function e(t){return((t*=2)<1?t*t*((n+1)*t-n):(t-=2)*t*((n+1)*t+n)+2)/2}return n=+n,e.overshoot=t,e}(1.70158),Xl=2*Math.PI,Vl=function t(n,e){function r(t){return n*Math.pow(2,10*--t)*Math.sin((i-t)/e)}var i=Math.asin(1/(n=Math.max(1,n)))*(e/=Xl);return r.amplitude=function(n){return t(n,e*Xl)},r.period=function(e){return t(n,e)},r}(1,.3),$l=function t(n,e){function r(t){return 1-n*Math.pow(2,-10*(t=+t))*Math.sin((t+i)/e)}var i=Math.asin(1/(n=Math.max(1,n)))*(e/=Xl);return r.amplitude=function(n){return t(n,e*Xl)},r.period=function(e){return t(n,e)},r}(1,.3),Wl=function t(n,e){function r(t){return((t=2*t-1)<0?n*Math.pow(2,10*t)*Math.sin((i-t)/e):2-n*Math.pow(2,-10*t)*Math.sin((i+t)/e))/2}var i=Math.asin(1/(n=Math.max(1,n)))*(e/=Xl);return r.amplitude=function(n){return t(n,e*Xl)},r.period=function(e){return t(n,e)},r}(1,.3),Zl={time:null,delay:0,duration:250,ease:Un};ft.prototype.interrupt=function(t){return this.each(function(){Cn(this,t)})},ft.prototype.transition=function(t){var n,e;t instanceof Rn?(n=t._id,t=t._name):(n=qn(),(e=Zl).time=_n(),t=null==t?null:t+"");for(var r=this._groups,i=r.length,o=0;o<i;++o)for(var u,a=r[o],c=a.length,s=0;s<c;++s)(u=a[s])&&kn(u,t,n,s,a,e||Bn(u,n));return new Rn(r,this._parents,t,n)};var Gl=[null],Ql={name:"drag"},Jl={name:"space"},Kl={name:"handle"},th={name:"center"},nh={name:"x",handles:["e","w"].map(Vn),input:function(t,n){return t&&[[t[0],n[0][1]],[t[1],n[1][1]]]},output:function(t){return t&&[t[0][0],t[1][0]]}},eh={name:"y",handles:["n","s"].map(Vn),input:function(t,n){return t&&[[n[0][0],t[0]],[n[1][0],t[1]]]},output:function(t){return t&&[t[0][1],t[1][1]]}},rh={name:"xy",handles:["n","e","s","w","nw","ne","se","sw"].map(Vn),input:function(t){return t},output:function(t){return t}},ih={overlay:"crosshair",selection:"move",n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},oh={e:"w",w:"e",nw:"ne",ne:"nw",se:"sw",sw:"se"},uh={n:"s",s:"n",nw:"sw",ne:"se",se:"ne",sw:"nw"},ah={overlay:1,selection:1,n:null,e:1,s:null,w:-1,nw:-1,ne:1,se:1,sw:-1},ch={overlay:1,selection:1,n:-1,e:null,s:1,w:null,nw:-1,ne:-1,se:1,sw:1},sh=Math.cos,fh=Math.sin,lh=Math.PI,hh=lh/2,ph=2*lh,dh=Math.max,vh=Array.prototype.slice,gh=Math.PI,_h=2*gh,yh=_h-1e-6;Kn.prototype=te.prototype={constructor:Kn,moveTo:function(t,n){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)},closePath:function(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(t,n){this._+="L"+(this._x1=+t)+","+(this._y1=+n)},quadraticCurveTo:function(t,n,e,r){this._+="Q"+ +t+","+ +n+","+(this._x1=+e)+","+(this._y1=+r)},bezierCurveTo:function(t,n,e,r,i,o){this._+="C"+ +t+","+ +n+","+ +e+","+ +r+","+(this._x1=+i)+","+(this._y1=+o)},arcTo:function(t,n,e,r,i){t=+t,n=+n,e=+e,r=+r,i=+i;var o=this._x1,u=this._y1,a=e-t,c=r-n,s=o-t,f=u-n,l=s*s+f*f;if(i<0)throw new Error("negative radius: "+i);if(null===this._x1)this._+="M"+(this._x1=t)+","+(this._y1=n);else if(l>1e-6)if(Math.abs(f*a-c*s)>1e-6&&i){var h=e-o,p=r-u,d=a*a+c*c,v=h*h+p*p,g=Math.sqrt(d),_=Math.sqrt(l),y=i*Math.tan((gh-Math.acos((d+l-v)/(2*g*_)))/2),m=y/_,x=y/g;Math.abs(m-1)>1e-6&&(this._+="L"+(t+m*s)+","+(n+m*f)),this._+="A"+i+","+i+",0,0,"+ +(f*h>s*p)+","+(this._x1=t+x*a)+","+(this._y1=n+x*c)}else this._+="L"+(this._x1=t)+","+(this._y1=n);else;},arc:function(t,n,e,r,i,o){t=+t,n=+n;var u=(e=+e)*Math.cos(r),a=e*Math.sin(r),c=t+u,s=n+a,f=1^o,l=o?r-i:i-r;if(e<0)throw new Error("negative radius: "+e);null===this._x1?this._+="M"+c+","+s:(Math.abs(this._x1-c)>1e-6||Math.abs(this._y1-s)>1e-6)&&(this._+="L"+c+","+s),e&&(l<0&&(l=l%_h+_h),l>yh?this._+="A"+e+","+e+",0,1,"+f+","+(t-u)+","+(n-a)+"A"+e+","+e+",0,1,"+f+","+(this._x1=c)+","+(this._y1=s):l>1e-6&&(this._+="A"+e+","+e+",0,"+ +(l>=gh)+","+f+","+(this._x1=t+e*Math.cos(i))+","+(this._y1=n+e*Math.sin(i))))},rect:function(t,n,e,r){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)+"h"+ +e+"v"+ +r+"h"+-e+"Z"},toString:function(){return this._}};ue.prototype=ae.prototype={constructor:ue,has:function(t){return"$"+t in this},get:function(t){return this["$"+t]},set:function(t,n){return this["$"+t]=n,this},remove:function(t){var n="$"+t;return n in this&&delete this[n]},clear:function(){for(var t in this)"$"===t[0]&&delete this[t]},keys:function(){var t=[];for(var n in this)"$"===n[0]&&t.push(n.slice(1));return t},values:function(){var t=[];for(var n in this)"$"===n[0]&&t.push(this[n]);return t},entries:function(){var t=[];for(var n in this)"$"===n[0]&&t.push({key:n.slice(1),value:this[n]});return t},size:function(){var t=0;for(var n in this)"$"===n[0]&&++t;return t},empty:function(){for(var t in this)if("$"===t[0])return!1;return!0},each:function(t){for(var n in this)"$"===n[0]&&t(this[n],n.slice(1),this)}};var mh=ae.prototype;he.prototype=pe.prototype={constructor:he,has:mh.has,add:function(t){return t+="",this["$"+t]=t,this},remove:mh.remove,clear:mh.clear,values:mh.keys,size:mh.size,empty:mh.empty,each:mh.each};var xh={},bh={},wh=34,Mh=10,Th=13,Nh=ve(","),kh=Nh.parse,Sh=Nh.parseRows,Eh=Nh.format,Ah=Nh.formatRows,Ch=ve("\t"),zh=Ch.parse,Ph=Ch.parseRows,Rh=Ch.format,Lh=Ch.formatRows,qh=we.prototype=Me.prototype;qh.copy=function(){var t,n,e=new Me(this._x,this._y,this._x0,this._y0,this._x1,this._y1),r=this._root;if(!r)return e;if(!r.length)return e._root=Te(r),e;for(t=[{source:r,target:e._root=new Array(4)}];r=t.pop();)for(var i=0;i<4;++i)(n=r.source[i])&&(n.length?t.push({source:n,target:r.target[i]=new Array(4)}):r.target[i]=Te(n));return e},qh.add=function(t){var n=+this._x.call(null,t),e=+this._y.call(null,t);return ye(this.cover(n,e),n,e,t)},qh.addAll=function(t){var n,e,r,i,o=t.length,u=new Array(o),a=new Array(o),c=1/0,s=1/0,f=-1/0,l=-1/0;for(e=0;e<o;++e)isNaN(r=+this._x.call(null,n=t[e]))||isNaN(i=+this._y.call(null,n))||(u[e]=r,a[e]=i,r<c&&(c=r),r>f&&(f=r),i<s&&(s=i),i>l&&(l=i));for(f<c&&(c=this._x0,f=this._x1),l<s&&(s=this._y0,l=this._y1),this.cover(c,s).cover(f,l),e=0;e<o;++e)ye(this,u[e],a[e],t[e]);return this},qh.cover=function(t,n){if(isNaN(t=+t)||isNaN(n=+n))return this;var e=this._x0,r=this._y0,i=this._x1,o=this._y1;if(isNaN(e))i=(e=Math.floor(t))+1,o=(r=Math.floor(n))+1;else{if(!(e>t||t>i||r>n||n>o))return this;var u,a,c=i-e,s=this._root;switch(a=(n<(r+o)/2)<<1|t<(e+i)/2){case 0:do{u=new Array(4),u[a]=s,s=u}while(c*=2,i=e+c,o=r+c,t>i||n>o);break;case 1:do{u=new Array(4),u[a]=s,s=u}while(c*=2,e=i-c,o=r+c,e>t||n>o);break;case 2:do{u=new Array(4),u[a]=s,s=u}while(c*=2,i=e+c,r=o-c,t>i||r>n);break;case 3:do{u=new Array(4),u[a]=s,s=u}while(c*=2,e=i-c,r=o-c,e>t||r>n)}this._root&&this._root.length&&(this._root=s)}return this._x0=e,this._y0=r,this._x1=i,this._y1=o,this},qh.data=function(){var t=[];return this.visit(function(n){if(!n.length)do{t.push(n.data)}while(n=n.next)}),t},qh.extent=function(t){return arguments.length?this.cover(+t[0][0],+t[0][1]).cover(+t[1][0],+t[1][1]):isNaN(this._x0)?void 0:[[this._x0,this._y0],[this._x1,this._y1]]},qh.find=function(t,n,e){var r,i,o,u,a,c,s,f=this._x0,l=this._y0,h=this._x1,p=this._y1,d=[],v=this._root;for(v&&d.push(new me(v,f,l,h,p)),null==e?e=1/0:(f=t-e,l=n-e,h=t+e,p=n+e,e*=e);c=d.pop();)if(!(!(v=c.node)||(i=c.x0)>h||(o=c.y0)>p||(u=c.x1)<f||(a=c.y1)<l))if(v.length){var g=(i+u)/2,_=(o+a)/2;d.push(new me(v[3],g,_,u,a),new me(v[2],i,_,g,a),new me(v[1],g,o,u,_),new me(v[0],i,o,g,_)),(s=(n>=_)<<1|t>=g)&&(c=d[d.length-1],d[d.length-1]=d[d.length-1-s],d[d.length-1-s]=c)}else{var y=t-+this._x.call(null,v.data),m=n-+this._y.call(null,v.data),x=y*y+m*m;if(x<e){var b=Math.sqrt(e=x);f=t-b,l=n-b,h=t+b,p=n+b,r=v.data}}return r},qh.remove=function(t){if(isNaN(o=+this._x.call(null,t))||isNaN(u=+this._y.call(null,t)))return this;var n,e,r,i,o,u,a,c,s,f,l,h,p=this._root,d=this._x0,v=this._y0,g=this._x1,_=this._y1;if(!p)return this;if(p.length)for(;;){if((s=o>=(a=(d+g)/2))?d=a:g=a,(f=u>=(c=(v+_)/2))?v=c:_=c,n=p,!(p=p[l=f<<1|s]))return this;if(!p.length)break;(n[l+1&3]||n[l+2&3]||n[l+3&3])&&(e=n,h=l)}for(;p.data!==t;)if(r=p,!(p=p.next))return this;return(i=p.next)&&delete p.next,r?(i?r.next=i:delete r.next,this):n?(i?n[l]=i:delete n[l],(p=n[0]||n[1]||n[2]||n[3])&&p===(n[3]||n[2]||n[1]||n[0])&&!p.length&&(e?e[h]=p:this._root=p),this):(this._root=i,this)},qh.removeAll=function(t){for(var n=0,e=t.length;n<e;++n)this.remove(t[n]);return this},qh.root=function(){return this._root},qh.size=function(){var t=0;return this.visit(function(n){if(!n.length)do{++t}while(n=n.next)}),t},qh.visit=function(t){var n,e,r,i,o,u,a=[],c=this._root;for(c&&a.push(new me(c,this._x0,this._y0,this._x1,this._y1));n=a.pop();)if(!t(c=n.node,r=n.x0,i=n.y0,o=n.x1,u=n.y1)&&c.length){var s=(r+o)/2,f=(i+u)/2;(e=c[3])&&a.push(new me(e,s,f,o,u)),(e=c[2])&&a.push(new me(e,r,f,s,u)),(e=c[1])&&a.push(new me(e,s,i,o,f)),(e=c[0])&&a.push(new me(e,r,i,s,f))}return this},qh.visitAfter=function(t){var n,e=[],r=[];for(this._root&&e.push(new me(this._root,this._x0,this._y0,this._x1,this._y1));n=e.pop();){var i=n.node;if(i.length){var o,u=n.x0,a=n.y0,c=n.x1,s=n.y1,f=(u+c)/2,l=(a+s)/2;(o=i[0])&&e.push(new me(o,u,a,f,l)),(o=i[1])&&e.push(new me(o,f,a,c,l)),(o=i[2])&&e.push(new me(o,u,l,f,s)),(o=i[3])&&e.push(new me(o,f,l,c,s))}r.push(n)}for(;n=r.pop();)t(n.node,n.x0,n.y0,n.x1,n.y1);return this},qh.x=function(t){return arguments.length?(this._x=t,this):this._x},qh.y=function(t){return arguments.length?(this._y=t,this):this._y};var Dh,Uh=10,Oh=Math.PI*(3-Math.sqrt(5)),Fh={"":function(t,n){t:for(var e,r=(t=t.toPrecision(n)).length,i=1,o=-1;i<r;++i)switch(t[i]){case".":o=e=i;break;case"0":0===o&&(o=i),e=i;break;case"e":break t;default:o>0&&(o=0)}return o>0?t.slice(0,o)+t.slice(e+1):t},"%":function(t,n){return(100*t).toFixed(n)},b:function(t){return Math.round(t).toString(2)},c:function(t){return t+""},d:function(t){return Math.round(t).toString(10)},e:function(t,n){return t.toExponential(n)},f:function(t,n){return t.toFixed(n)},g:function(t,n){return t.toPrecision(n)},o:function(t){return Math.round(t).toString(8)},p:function(t,n){return Re(100*t,n)},r:Re,s:function(t,n){var e=ze(t,n);if(!e)return t+"";var r=e[0],i=e[1],o=i-(Dh=3*Math.max(-8,Math.min(8,Math.floor(i/3))))+1,u=r.length;return o===u?r:o>u?r+new Array(o-u+1).join("0"):o>0?r.slice(0,o)+"."+r.slice(o):"0."+new Array(1-o).join("0")+ze(t,Math.max(0,n+o-1))[0]},X:function(t){return Math.round(t).toString(16).toUpperCase()},x:function(t){return Math.round(t).toString(16)}},Ih=/^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;Le.prototype=qe.prototype,qe.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(null==this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(null==this.precision?"":"."+Math.max(0,0|this.precision))+this.type};var Yh,Bh=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];Oe({decimal:".",thousands:",",grouping:[3],currency:["$",""]}),He.prototype={constructor:He,reset:function(){this.s=this.t=0},add:function(t){je(xp,t,this.t),je(this,xp.s,this.s),this.s?this.t+=xp.t:this.s=xp.t},valueOf:function(){return this.s}};var Hh,jh,Xh,Vh,$h,Wh,Zh,Gh,Qh,Jh,Kh,tp,np,ep,rp,ip,op,up,ap,cp,sp,fp,lp,hp,pp,dp,vp,gp,_p,yp,mp,xp=new He,bp=1e-6,wp=1e-12,Mp=Math.PI,Tp=Mp/2,Np=Mp/4,kp=2*Mp,Sp=180/Mp,Ep=Mp/180,Ap=Math.abs,Cp=Math.atan,zp=Math.atan2,Pp=Math.cos,Rp=Math.ceil,Lp=Math.exp,qp=Math.log,Dp=Math.pow,Up=Math.sin,Op=Math.sign||function(t){return t>0?1:t<0?-1:0},Fp=Math.sqrt,Ip=Math.tan,Yp={Feature:function(t,n){Ze(t.geometry,n)},FeatureCollection:function(t,n){for(var e=t.features,r=-1,i=e.length;++r<i;)Ze(e[r].geometry,n)}},Bp={Sphere:function(t,n){n.sphere()},Point:function(t,n){t=t.coordinates,n.point(t[0],t[1],t[2])},MultiPoint:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)t=e[r],n.point(t[0],t[1],t[2])},LineString:function(t,n){Ge(t.coordinates,n,0)},MultiLineString:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)Ge(e[r],n,0)},Polygon:function(t,n){Qe(t.coordinates,n)},MultiPolygon:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)Qe(e[r],n)},GeometryCollection:function(t,n){for(var e=t.geometries,r=-1,i=e.length;++r<i;)Ze(e[r],n)}},Hp=Be(),jp=Be(),Xp={point:We,lineStart:We,lineEnd:We,polygonStart:function(){Hp.reset(),Xp.lineStart=Ke,Xp.lineEnd=tr},polygonEnd:function(){var t=+Hp;jp.add(t<0?kp+t:t),this.lineStart=this.lineEnd=this.point=We},sphere:function(){jp.add(kp)}},Vp=Be(),$p={point:fr,lineStart:hr,lineEnd:pr,polygonStart:function(){$p.point=dr,$p.lineStart=vr,$p.lineEnd=gr,Vp.reset(),Xp.polygonStart()},polygonEnd:function(){Xp.polygonEnd(),$p.point=fr,$p.lineStart=hr,$p.lineEnd=pr,Hp<0?(Wh=-(Gh=180),Zh=-(Qh=90)):Vp>bp?Qh=90:Vp<-bp&&(Zh=-90),rp[0]=Wh,rp[1]=Gh}},Wp={sphere:We,point:xr,lineStart:wr,lineEnd:Nr,polygonStart:function(){Wp.lineStart=kr,Wp.lineEnd=Sr},polygonEnd:function(){Wp.lineStart=wr,Wp.lineEnd=Nr}};Pr.invert=Pr;var Zp,Gp,Qp,Jp,Kp,td,nd,ed,rd,id,od,ud=Be(),ad=Vr(function(){return!0},function(t){var n,e=NaN,r=NaN,i=NaN;return{lineStart:function(){t.lineStart(),n=1},point:function(o,u){var a=o>0?Mp:-Mp,c=Ap(o-e);Ap(c-Mp)<bp?(t.point(e,r=(r+u)/2>0?Tp:-Tp),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(a,r),t.point(o,r),n=0):i!==a&&c>=Mp&&(Ap(e-i)<bp&&(e-=i*bp),Ap(o-a)<bp&&(o-=a*bp),r=function(t,n,e,r){var i,o,u=Up(t-e);return Ap(u)>bp?Cp((Up(n)*(o=Pp(r))*Up(e)-Up(r)*(i=Pp(n))*Up(t))/(i*o*u)):(n+r)/2}(e,r,o,u),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(a,r),n=0),t.point(e=o,r=u),i=a},lineEnd:function(){t.lineEnd(),e=r=NaN},clean:function(){return 2-n}}},function(t,n,e,r){var i;if(null==t)i=e*Tp,r.point(-Mp,i),r.point(0,i),r.point(Mp,i),r.point(Mp,0),r.point(Mp,-i),r.point(0,-i),r.point(-Mp,-i),r.point(-Mp,0),r.point(-Mp,i);else if(Ap(t[0]-n[0])>bp){var o=t[0]<n[0]?Mp:-Mp;i=e*o/2,r.point(-o,i),r.point(0,i),r.point(o,i)}else r.point(n[0],n[1])},[-Mp,-Tp]),cd=1e9,sd=-cd,fd=Be(),ld={sphere:We,point:We,lineStart:function(){ld.point=Jr,ld.lineEnd=Qr},lineEnd:We,polygonStart:We,polygonEnd:We},hd=[null,null],pd={type:"LineString",coordinates:hd},dd={Feature:function(t,n){return ei(t.geometry,n)},FeatureCollection:function(t,n){for(var e=t.features,r=-1,i=e.length;++r<i;)if(ei(e[r].geometry,n))return!0;return!1}},vd={Sphere:function(){return!0},Point:function(t,n){return ri(t.coordinates,n)},MultiPoint:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)if(ri(e[r],n))return!0;return!1},LineString:function(t,n){return ii(t.coordinates,n)},MultiLineString:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)if(ii(e[r],n))return!0;return!1},Polygon:function(t,n){return oi(t.coordinates,n)},MultiPolygon:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)if(oi(e[r],n))return!0;return!1},GeometryCollection:function(t,n){for(var e=t.geometries,r=-1,i=e.length;++r<i;)if(ei(e[r],n))return!0;return!1}},gd=Be(),_d=Be(),yd={point:We,lineStart:We,lineEnd:We,polygonStart:function(){yd.lineStart=hi,yd.lineEnd=vi},polygonEnd:function(){yd.lineStart=yd.lineEnd=yd.point=We,gd.add(Ap(_d)),_d.reset()},result:function(){var t=gd/2;return gd.reset(),t}},md=1/0,xd=md,bd=-md,wd=bd,Md={point:function(t,n){t<md&&(md=t),t>bd&&(bd=t),n<xd&&(xd=n),n>wd&&(wd=n)},lineStart:We,lineEnd:We,polygonStart:We,polygonEnd:We,result:function(){var t=[[md,xd],[bd,wd]];return bd=wd=-(xd=md=1/0),t}},Td=0,Nd=0,kd=0,Sd=0,Ed=0,Ad=0,Cd=0,zd=0,Pd=0,Rd={point:gi,lineStart:_i,lineEnd:xi,polygonStart:function(){Rd.lineStart=bi,Rd.lineEnd=wi},polygonEnd:function(){Rd.point=gi,Rd.lineStart=_i,Rd.lineEnd=xi},result:function(){var t=Pd?[Cd/Pd,zd/Pd]:Ad?[Sd/Ad,Ed/Ad]:kd?[Td/kd,Nd/kd]:[NaN,NaN];return Td=Nd=kd=Sd=Ed=Ad=Cd=zd=Pd=0,t}};Ni.prototype={_radius:4.5,pointRadius:function(t){return this._radius=t,this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._context.closePath(),this._point=NaN},point:function(t,n){switch(this._point){case 0:this._context.moveTo(t,n),this._point=1;break;case 1:this._context.lineTo(t,n);break;default:this._context.moveTo(t+this._radius,n),this._context.arc(t,n,this._radius,0,kp)}},result:We};var Ld,qd,Dd,Ud,Od,Fd=Be(),Id={point:We,lineStart:function(){Id.point=ki},lineEnd:function(){Ld&&Si(qd,Dd),Id.point=We},polygonStart:function(){Ld=!0},polygonEnd:function(){Ld=null},result:function(){var t=+Fd;return Fd.reset(),t}};Ei.prototype={_radius:4.5,_circle:Ai(4.5),pointRadius:function(t){return(t=+t)!==this._radius&&(this._radius=t,this._circle=null),this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._string.push("Z"),this._point=NaN},point:function(t,n){switch(this._point){case 0:this._string.push("M",t,",",n),this._point=1;break;case 1:this._string.push("L",t,",",n);break;default:null==this._circle&&(this._circle=Ai(this._radius)),this._string.push("M",t,",",n,this._circle)}},result:function(){if(this._string.length){var t=this._string.join("");return this._string=[],t}return null}},zi.prototype={constructor:zi,point:function(t,n){this.stream.point(t,n)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var Yd=16,Bd=Pp(30*Ep),Hd=Ci({point:function(t,n){this.stream.point(t*Ep,n*Ep)}}),jd=ji(function(t){return Fp(2/(1+t))});jd.invert=Xi(function(t){return 2*Ve(t/2)});var Xd=ji(function(t){return(t=Xe(t))&&t/Up(t)});Xd.invert=Xi(function(t){return t}),Vi.invert=function(t,n){return[t,2*Cp(Lp(n))-Tp]},Gi.invert=Gi,Ji.invert=Xi(Cp),to.invert=function(t,n){var e,r=n,i=25;do{var o=r*r,u=o*o;r-=e=(r*(1.007226+o*(.015085+u*(.028874*o-.044475-.005916*u)))-n)/(1.007226+o*(.045255+u*(.259866*o-.311325-.005916*11*u)))}while(Ap(e)>bp&&--i>0);return[t/(.8707+(o=r*r)*(o*(o*o*o*(.003971-.001529*o)-.013791)-.131979)),r]},no.invert=Xi(Ve),eo.invert=Xi(function(t){return 2*Cp(t)}),ro.invert=function(t,n){return[-n,2*Cp(Lp(t))-Tp]},ho.prototype=co.prototype={constructor:ho,count:function(){return this.eachAfter(ao)},each:function(t){var n,e,r,i,o=this,u=[o];do{for(n=u.reverse(),u=[];o=n.pop();)if(t(o),e=o.children)for(r=0,i=e.length;r<i;++r)u.push(e[r])}while(u.length);return this},eachAfter:function(t){for(var n,e,r,i=this,o=[i],u=[];i=o.pop();)if(u.push(i),n=i.children)for(e=0,r=n.length;e<r;++e)o.push(n[e]);for(;i=u.pop();)t(i);return this},eachBefore:function(t){for(var n,e,r=this,i=[r];r=i.pop();)if(t(r),n=r.children)for(e=n.length-1;e>=0;--e)i.push(n[e]);return this},sum:function(t){return this.eachAfter(function(n){for(var e=+t(n.data)||0,r=n.children,i=r&&r.length;--i>=0;)e+=r[i].value;n.value=e})},sort:function(t){return this.eachBefore(function(n){n.children&&n.children.sort(t)})},path:function(t){for(var n=this,e=function(t,n){if(t===n)return t;var e=t.ancestors(),r=n.ancestors(),i=null;for(t=e.pop(),n=r.pop();t===n;)i=t,t=e.pop(),n=r.pop();return i}(n,t),r=[n];n!==e;)n=n.parent,r.push(n);for(var i=r.length;t!==e;)r.splice(i,0,t),t=t.parent;return r},ancestors:function(){for(var t=this,n=[t];t=t.parent;)n.push(t);return n},descendants:function(){var t=[];return this.each(function(n){t.push(n)}),t},leaves:function(){var t=[];return this.eachBefore(function(n){n.children||t.push(n)}),t},links:function(){var t=this,n=[];return t.each(function(e){e!==t&&n.push({source:e.parent,target:e})}),n},copy:function(){return co(this).eachBefore(fo)}};var Vd=Array.prototype.slice,$d="$",Wd={depth:-1},Zd={};Yo.prototype=Object.create(ho.prototype);var Gd=(1+Math.sqrt(5))/2,Qd=function t(n){function e(t,e,r,i,o){Ho(n,t,e,r,i,o)}return e.ratio=function(n){return t((n=+n)>1?n:1)},e}(Gd),Jd=function t(n){function e(t,e,r,i,o){if((u=t._squarify)&&u.ratio===n)for(var u,a,c,s,f,l=-1,h=u.length,p=t.value;++l<h;){for(c=(a=u[l]).children,s=a.value=0,f=c.length;s<f;++s)a.value+=c[s].value;a.dice?Ro(a,e,r,i,r+=(o-r)*a.value/p):Bo(a,e,r,e+=(i-e)*a.value/p,o),p-=a.value}else t._squarify=u=Ho(n,t,e,r,i,o),u.ratio=n}return e.ratio=function(n){return t((n=+n)>1?n:1)},e}(Gd),Kd=[].slice,tv={};$o.prototype=Qo.prototype={constructor:$o,defer:function(t){if("function"!=typeof t)throw new Error("invalid callback");if(this._call)throw new Error("defer after await");if(null!=this._error)return this;var n=Kd.call(arguments,1);return n.push(t),++this._waiting,this._tasks.push(n),Wo(this),this},abort:function(){return null==this._error&&Zo(this,new Error("abort")),this},await:function(t){if("function"!=typeof t)throw new Error("invalid callback");if(this._call)throw new Error("multiple await");return this._call=function(n,e){t.apply(null,[n].concat(e))},Go(this),this},awaitAll:function(t){if("function"!=typeof t)throw new Error("invalid callback");if(this._call)throw new Error("multiple await");return this._call=t,Go(this),this}};var nv=function t(n){function e(t,e){return t=null==t?0:+t,e=null==e?1:+e,1===arguments.length?(e=t,t=0):e-=t,function(){return n()*e+t}}return e.source=t,e}(Jo),ev=function t(n){function e(t,e){var r,i;return t=null==t?0:+t,e=null==e?1:+e,function(){var o;if(null!=r)o=r,r=null;else do{r=2*n()-1,o=2*n()-1,i=r*r+o*o}while(!i||i>1);return t+e*o*Math.sqrt(-2*Math.log(i)/i)}}return e.source=t,e}(Jo),rv=function t(n){function e(){var t=ev.source(n).apply(this,arguments);return function(){return Math.exp(t())}}return e.source=t,e}(Jo),iv=function t(n){function e(t){return function(){for(var e=0,r=0;r<t;++r)e+=n();return e}}return e.source=t,e}(Jo),ov=function t(n){function e(t){var e=iv.source(n)(t);return function(){return e()/t}}return e.source=t,e}(Jo),uv=function t(n){function e(t){return function(){return-Math.log(1-n())/t}}return e.source=t,e}(Jo),av=tu("text/html",function(t){return document.createRange().createContextualFragment(t.responseText)}),cv=tu("application/json",function(t){return JSON.parse(t.responseText)}),sv=tu("text/plain",function(t){return t.responseText}),fv=tu("application/xml",function(t){var n=t.responseXML;if(!n)throw new Error("parse error");return n}),lv=nu("text/csv",kh),hv=nu("text/tab-separated-values",zh),pv=Array.prototype,dv=pv.map,vv=pv.slice,gv={name:"implicit"},_v=[0,1],yv=new Date,mv=new Date,xv=Eu(function(){},function(t,n){t.setTime(+t+n)},function(t,n){return n-t});xv.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?Eu(function(n){n.setTime(Math.floor(n/t)*t)},function(n,e){n.setTime(+n+e*t)},function(n,e){return(e-n)/t}):xv:null};var bv=xv.range,wv=6e4,Mv=6048e5,Tv=Eu(function(t){t.setTime(1e3*Math.floor(t/1e3))},function(t,n){t.setTime(+t+1e3*n)},function(t,n){return(n-t)/1e3},function(t){return t.getUTCSeconds()}),Nv=Tv.range,kv=Eu(function(t){t.setTime(Math.floor(t/wv)*wv)},function(t,n){t.setTime(+t+n*wv)},function(t,n){return(n-t)/wv},function(t){return t.getMinutes()}),Sv=kv.range,Ev=Eu(function(t){var n=t.getTimezoneOffset()*wv%36e5;n<0&&(n+=36e5),t.setTime(36e5*Math.floor((+t-n)/36e5)+n)},function(t,n){t.setTime(+t+36e5*n)},function(t,n){return(n-t)/36e5},function(t){return t.getHours()}),Av=Ev.range,Cv=Eu(function(t){t.setHours(0,0,0,0)},function(t,n){t.setDate(t.getDate()+n)},function(t,n){return(n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*wv)/864e5},function(t){return t.getDate()-1}),zv=Cv.range,Pv=Au(0),Rv=Au(1),Lv=Au(2),qv=Au(3),Dv=Au(4),Uv=Au(5),Ov=Au(6),Fv=Pv.range,Iv=Rv.range,Yv=Lv.range,Bv=qv.range,Hv=Dv.range,jv=Uv.range,Xv=Ov.range,Vv=Eu(function(t){t.setDate(1),t.setHours(0,0,0,0)},function(t,n){t.setMonth(t.getMonth()+n)},function(t,n){return n.getMonth()-t.getMonth()+12*(n.getFullYear()-t.getFullYear())},function(t){return t.getMonth()}),$v=Vv.range,Wv=Eu(function(t){t.setMonth(0,1),t.setHours(0,0,0,0)},function(t,n){t.setFullYear(t.getFullYear()+n)},function(t,n){return n.getFullYear()-t.getFullYear()},function(t){return t.getFullYear()});Wv.every=function(t){return isFinite(t=Math.floor(t))&&t>0?Eu(function(n){n.setFullYear(Math.floor(n.getFullYear()/t)*t),n.setMonth(0,1),n.setHours(0,0,0,0)},function(n,e){n.setFullYear(n.getFullYear()+e*t)}):null};var Zv=Wv.range,Gv=Eu(function(t){t.setUTCSeconds(0,0)},function(t,n){t.setTime(+t+n*wv)},function(t,n){return(n-t)/wv},function(t){return t.getUTCMinutes()}),Qv=Gv.range,Jv=Eu(function(t){t.setUTCMinutes(0,0,0)},function(t,n){t.setTime(+t+36e5*n)},function(t,n){return(n-t)/36e5},function(t){return t.getUTCHours()}),Kv=Jv.range,tg=Eu(function(t){t.setUTCHours(0,0,0,0)},function(t,n){t.setUTCDate(t.getUTCDate()+n)},function(t,n){return(n-t)/864e5},function(t){return t.getUTCDate()-1}),ng=tg.range,eg=Cu(0),rg=Cu(1),ig=Cu(2),og=Cu(3),ug=Cu(4),ag=Cu(5),cg=Cu(6),sg=eg.range,fg=rg.range,lg=ig.range,hg=og.range,pg=ug.range,dg=ag.range,vg=cg.range,gg=Eu(function(t){t.setUTCDate(1),t.setUTCHours(0,0,0,0)},function(t,n){t.setUTCMonth(t.getUTCMonth()+n)},function(t,n){return n.getUTCMonth()-t.getUTCMonth()+12*(n.getUTCFullYear()-t.getUTCFullYear())},function(t){return t.getUTCMonth()}),_g=gg.range,yg=Eu(function(t){t.setUTCMonth(0,1),t.setUTCHours(0,0,0,0)},function(t,n){t.setUTCFullYear(t.getUTCFullYear()+n)},function(t,n){return n.getUTCFullYear()-t.getUTCFullYear()},function(t){return t.getUTCFullYear()});yg.every=function(t){return isFinite(t=Math.floor(t))&&t>0?Eu(function(n){n.setUTCFullYear(Math.floor(n.getUTCFullYear()/t)*t),n.setUTCMonth(0,1),n.setUTCHours(0,0,0,0)},function(n,e){n.setUTCFullYear(n.getUTCFullYear()+e*t)}):null};var mg,xg=yg.range,bg={"-":"",_:" ",0:"0"},wg=/^\s*\d+/,Mg=/^%/,Tg=/[\\^$*+?|[\]().{}]/g;Ya({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});var Ng="%Y-%m-%dT%H:%M:%S.%LZ",kg=Date.prototype.toISOString?function(t){return t.toISOString()}:t.utcFormat(Ng),Sg=+new Date("2000-01-01T00:00:00.000Z")?function(t){var n=new Date(t);return isNaN(n)?null:n}:t.utcParse(Ng),Eg=1e3,Ag=60*Eg,Cg=60*Ag,zg=24*Cg,Pg=7*zg,Rg=30*zg,Lg=365*zg,qg=Xa("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),Dg=Xa("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"),Ug=Xa("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"),Og=Xa("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"),Fg=ol(Xt(300,.5,0),Xt(-240,.5,1)),Ig=ol(Xt(-100,.75,.35),Xt(80,1.5,.8)),Yg=ol(Xt(260,.75,.35),Xt(80,1.5,.8)),Bg=Xt(),Hg=Va(Xa("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")),jg=Va(Xa("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),Xg=Va(Xa("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),Vg=Va(Xa("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")),$g=Math.abs,Wg=Math.atan2,Zg=Math.cos,Gg=Math.max,Qg=Math.min,Jg=Math.sin,Kg=Math.sqrt,t_=1e-12,n_=Math.PI,e_=n_/2,r_=2*n_;ec.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:this._context.lineTo(t,n)}}};var i_=lc(rc);fc.prototype={areaStart:function(){this._curve.areaStart()},areaEnd:function(){this._curve.areaEnd()},lineStart:function(){this._curve.lineStart()},lineEnd:function(){this._curve.lineEnd()},point:function(t,n){this._curve.point(n*Math.sin(t),n*-Math.cos(t))}};var o_=Array.prototype.slice,u_={draw:function(t,n){var e=Math.sqrt(n/n_);t.moveTo(e,0),t.arc(0,0,e,0,r_)}},a_={draw:function(t,n){var e=Math.sqrt(n/5)/2;t.moveTo(-3*e,-e),t.lineTo(-e,-e),t.lineTo(-e,-3*e),t.lineTo(e,-3*e),t.lineTo(e,-e),t.lineTo(3*e,-e),t.lineTo(3*e,e),t.lineTo(e,e),t.lineTo(e,3*e),t.lineTo(-e,3*e),t.lineTo(-e,e),t.lineTo(-3*e,e),t.closePath()}},c_=Math.sqrt(1/3),s_=2*c_,f_={draw:function(t,n){var e=Math.sqrt(n/s_),r=e*c_;t.moveTo(0,-e),t.lineTo(r,0),t.lineTo(0,e),t.lineTo(-r,0),t.closePath()}},l_=Math.sin(n_/10)/Math.sin(7*n_/10),h_=Math.sin(r_/10)*l_,p_=-Math.cos(r_/10)*l_,d_={draw:function(t,n){var e=Math.sqrt(.8908130915292852*n),r=h_*e,i=p_*e;t.moveTo(0,-e),t.lineTo(r,i);for(var o=1;o<5;++o){var u=r_*o/5,a=Math.cos(u),c=Math.sin(u);t.lineTo(c*e,-a*e),t.lineTo(a*r-c*i,c*r+a*i)}t.closePath()}},v_={draw:function(t,n){var e=Math.sqrt(n),r=-e/2;t.rect(r,r,e,e)}},g_=Math.sqrt(3),__={draw:function(t,n){var e=-Math.sqrt(n/(3*g_));t.moveTo(0,2*e),t.lineTo(-g_*e,-e),t.lineTo(g_*e,-e),t.closePath()}},y_=Math.sqrt(3)/2,m_=1/Math.sqrt(12),x_=3*(m_/2+1),b_={draw:function(t,n){var e=Math.sqrt(n/x_),r=e/2,i=e*m_,o=r,u=e*m_+e,a=-o,c=u;t.moveTo(r,i),t.lineTo(o,u),t.lineTo(a,c),t.lineTo(-.5*r-y_*i,y_*r+-.5*i),t.lineTo(-.5*o-y_*u,y_*o+-.5*u),t.lineTo(-.5*a-y_*c,y_*a+-.5*c),t.lineTo(-.5*r+y_*i,-.5*i-y_*r),t.lineTo(-.5*o+y_*u,-.5*u-y_*o),t.lineTo(-.5*a+y_*c,-.5*c-y_*a),t.closePath()}},w_=[u_,a_,f_,v_,d_,__,b_];Tc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){switch(this._point){case 3:Mc(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:Mc(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}},Nc.prototype={areaStart:wc,areaEnd:wc,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x2,this._y2),this._context.closePath();break;case 2:this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3),this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3),this._context.closePath();break;case 3:this.point(this._x2,this._y2),this.point(this._x3,this._y3),this.point(this._x4,this._y4)}},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._x2=t,this._y2=n;break;case 1:this._point=2,this._x3=t,this._y3=n;break;case 2:this._point=3,this._x4=t,this._y4=n,this._context.moveTo((this._x0+4*this._x1+t)/6,(this._y0+4*this._y1+n)/6);break;default:Mc(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}},kc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var e=(this._x0+4*this._x1+t)/6,r=(this._y0+4*this._y1+n)/6;this._line?this._context.lineTo(e,r):this._context.moveTo(e,r);break;case 3:this._point=4;default:Mc(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}},Sc.prototype={lineStart:function(){this._x=[],this._y=[],this._basis.lineStart()},lineEnd:function(){var t=this._x,n=this._y,e=t.length-1;if(e>0)for(var r,i=t[0],o=n[0],u=t[e]-i,a=n[e]-o,c=-1;++c<=e;)r=c/e,this._basis.point(this._beta*t[c]+(1-this._beta)*(i+r*u),this._beta*n[c]+(1-this._beta)*(o+r*a));this._x=this._y=null,this._basis.lineEnd()},point:function(t,n){this._x.push(+t),this._y.push(+n)}};var M_=function t(n){function e(t){return 1===n?new Tc(t):new Sc(t,n)}return e.beta=function(n){return t(+n)},e}(.85);Ac.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:Ec(this,this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2,this._x1=t,this._y1=n;break;case 2:this._point=3;default:Ec(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var T_=function t(n){function e(t){return new Ac(t,n)}return e.tension=function(n){return t(+n)},e}(0);Cc.prototype={areaStart:wc,areaEnd:wc,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._x3=t,this._y3=n;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=n);break;case 2:this._point=3,this._x5=t,this._y5=n;break;default:Ec(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var N_=function t(n){function e(t){return new Cc(t,n)}return e.tension=function(n){return t(+n)},e}(0);zc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:Ec(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var k_=function t(n){function e(t){return new zc(t,n)}return e.tension=function(n){return t(+n)},e}(0);Rc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3;default:Pc(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var S_=function t(n){function e(t){return n?new Rc(t,n):new Ac(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);Lc.prototype={areaStart:wc,areaEnd:wc,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._x3=t,this._y3=n;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=n);break;case 2:this._point=3,this._x5=t,this._y5=n;break;default:Pc(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var E_=function t(n){function e(t){return n?new Lc(t,n):new Cc(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);qc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:Pc(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var A_=function t(n){function e(t){return n?new qc(t,n):new zc(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);Dc.prototype={areaStart:wc,areaEnd:wc,lineStart:function(){this._point=0},lineEnd:function(){this._point&&this._context.closePath()},point:function(t,n){t=+t,n=+n,this._point?this._context.lineTo(t,n):(this._point=1,this._context.moveTo(t,n))}},Yc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:Ic(this,this._t0,Fc(this,this._t0))}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){var e=NaN;if(t=+t,n=+n,t!==this._x1||n!==this._y1){switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,Ic(this,Fc(this,e=Oc(this,t,n)),e);break;default:Ic(this,this._t0,e=Oc(this,t,n))}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n,this._t0=e}}},(Bc.prototype=Object.create(Yc.prototype)).point=function(t,n){Yc.prototype.point.call(this,n,t)},Hc.prototype={moveTo:function(t,n){this._context.moveTo(n,t)},closePath:function(){this._context.closePath()},lineTo:function(t,n){this._context.lineTo(n,t)},bezierCurveTo:function(t,n,e,r,i,o){this._context.bezierCurveTo(n,t,r,e,o,i)}},jc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=[],this._y=[]},lineEnd:function(){var t=this._x,n=this._y,e=t.length;if(e)if(this._line?this._context.lineTo(t[0],n[0]):this._context.moveTo(t[0],n[0]),2===e)this._context.lineTo(t[1],n[1]);else for(var r=Xc(t),i=Xc(n),o=0,u=1;u<e;++o,++u)this._context.bezierCurveTo(r[0][o],i[0][o],r[1][o],i[1][o],t[u],n[u]);(this._line||0!==this._line&&1===e)&&this._context.closePath(),this._line=1-this._line,this._x=this._y=null},point:function(t,n){this._x.push(+t),this._y.push(+n)}},Vc.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=this._y=NaN,this._point=0},lineEnd:function(){0<this._t&&this._t<1&&2===this._point&&this._context.lineTo(this._x,this._y),(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line>=0&&(this._t=1-this._t,this._line=1-this._line)},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:if(this._t<=0)this._context.lineTo(this._x,n),this._context.lineTo(t,n);else{var e=this._x*(1-this._t)+t*this._t;this._context.lineTo(e,this._y),this._context.lineTo(e,n)}}this._x=t,this._y=n}},ns.prototype={constructor:ns,insert:function(t,n){var e,r,i;if(t){if(n.P=t,n.N=t.N,t.N&&(t.N.P=n),t.N=n,t.R){for(t=t.R;t.L;)t=t.L;t.L=n}else t.R=n;e=t}else this._?(t=os(this._),n.P=null,n.N=t,t.P=t.L=n,e=t):(n.P=n.N=null,this._=n,e=null);for(n.L=n.R=null,n.U=e,n.C=!0,t=n;e&&e.C;)e===(r=e.U).L?(i=r.R)&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.R&&(rs(this,e),e=(t=e).U),e.C=!1,r.C=!0,is(this,r)):(i=r.L)&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.L&&(is(this,e),e=(t=e).U),e.C=!1,r.C=!0,rs(this,r)),e=t.U;this._.C=!1},remove:function(t){t.N&&(t.N.P=t.P),t.P&&(t.P.N=t.N),t.N=t.P=null;var n,e,r,i=t.U,o=t.L,u=t.R;if(e=o?u?os(u):o:u,i?i.L===t?i.L=e:i.R=e:this._=e,o&&u?(r=e.C,e.C=t.C,e.L=o,o.U=e,e!==u?(i=e.U,e.U=t.U,t=e.R,i.L=t,e.R=u,u.U=e):(e.U=i,i=e,t=e.R)):(r=t.C,t=e),t&&(t.U=i),!r)if(t&&t.C)t.C=!1;else{do{if(t===this._)break;if(t===i.L){if((n=i.R).C&&(n.C=!1,i.C=!0,rs(this,i),n=i.R),n.L&&n.L.C||n.R&&n.R.C){n.R&&n.R.C||(n.L.C=!1,n.C=!0,is(this,n),n=i.R),n.C=i.C,i.C=n.R.C=!1,rs(this,i),t=this._;break}}else if((n=i.L).C&&(n.C=!1,i.C=!0,is(this,i),n=i.L),n.L&&n.L.C||n.R&&n.R.C){n.L&&n.L.C||(n.R.C=!1,n.C=!0,rs(this,n),n=i.L),n.C=i.C,i.C=n.L.C=!1,is(this,i),t=this._;break}n.C=!0,t=i,i=i.U}while(!t.C);t&&(t.C=!1)}}};var C_,z_,P_,R_,L_,q_=[],D_=[],U_=1e-6,O_=1e-12;Ms.prototype={constructor:Ms,polygons:function(){var t=this.edges;return this.cells.map(function(n){var e=n.halfedges.map(function(e){return hs(n,t[e])});return e.data=n.site.data,e})},triangles:function(){var t=[],n=this.edges;return this.cells.forEach(function(e,r){if(o=(i=e.halfedges).length)for(var i,o,u,a=e.site,c=-1,s=n[i[o-1]],f=s.left===a?s.right:s.left;++c<o;)u=f,f=(s=n[i[c]]).left===a?s.right:s.left,u&&f&&r<u.index&&r<f.index&&bs(a,u,f)<0&&t.push([a.data,u.data,f.data])}),t},links:function(){return this.edges.filter(function(t){return t.right}).map(function(t){return{source:t.left.data,target:t.right.data}})},find:function(t,n,e){for(var r,i,o=this,u=o._found||0,a=o.cells.length;!(i=o.cells[u]);)if(++u>=a)return null;var c=t-i.site[0],s=n-i.site[1],f=c*c+s*s;do{i=o.cells[r=u],u=null,i.halfedges.forEach(function(e){var r=o.edges[e],a=r.left;if(a!==i.site&&a||(a=r.right)){var c=t-a[0],s=n-a[1],l=c*c+s*s;l<f&&(f=l,u=a.index)}})}while(null!==u);return o._found=r,null==e||f<=e*e?i.site:null}},Ns.prototype={constructor:Ns,scale:function(t){return 1===t?this:new Ns(this.k*t,this.x,this.y)},translate:function(t,n){return 0===t&0===n?this:new Ns(this.k,this.x+this.k*t,this.y+this.k*n)},apply:function(t){return[t[0]*this.k+this.x,t[1]*this.k+this.y]},applyX:function(t){return t*this.k+this.x},applyY:function(t){return t*this.k+this.y},invert:function(t){return[(t[0]-this.x)/this.k,(t[1]-this.y)/this.k]},invertX:function(t){return(t-this.x)/this.k},invertY:function(t){return(t-this.y)/this.k},rescaleX:function(t){return t.copy().domain(t.range().map(this.invertX,this).map(t.invert,t))},rescaleY:function(t){return t.copy().domain(t.range().map(this.invertY,this).map(t.invert,t))},toString:function(){return"translate("+this.x+","+this.y+") scale("+this.k+")"}};var F_=new Ns(1,0,0);ks.prototype=Ns.prototype,t.version="4.12.2",t.bisect=Ds,t.bisectRight=Ds,t.bisectLeft=Us,t.ascending=n,t.bisector=e,t.cross=function(t,n,e){var i,o,u,a,c=t.length,s=n.length,f=new Array(c*s);for(null==e&&(e=r),i=u=0;i<c;++i)for(a=t[i],o=0;o<s;++o,++u)f[u]=e(a,n[o]);return f},t.descending=function(t,n){return n<t?-1:n>t?1:n>=t?0:NaN},t.deviation=u,t.extent=a,t.histogram=function(){function t(t){var i,o,u=t.length,a=new Array(u);for(i=0;i<u;++i)a[i]=n(t[i],i,t);var c=e(a),s=c[0],l=c[1],h=r(a,s,l);Array.isArray(h)||(h=p(s,l,h),h=f(Math.ceil(s/h)*h,Math.floor(l/h)*h,h));for(var d=h.length;h[0]<=s;)h.shift(),--d;for(;h[d-1]>l;)h.pop(),--d;var v,g=new Array(d+1);for(i=0;i<=d;++i)(v=g[i]=[]).x0=i>0?h[i-1]:s,v.x1=i<d?h[i]:l;for(i=0;i<u;++i)s<=(o=a[i])&&o<=l&&g[Ds(h,o,0,d)].push(t[i]);return g}var n=s,e=a,r=d;return t.value=function(e){return arguments.length?(n="function"==typeof e?e:c(e),t):n},t.domain=function(n){return arguments.length?(e="function"==typeof n?n:c([n[0],n[1]]),t):e},t.thresholds=function(n){return arguments.length?(r="function"==typeof n?n:Array.isArray(n)?c(Fs.call(n)):c(n),t):r},t},t.thresholdFreedmanDiaconis=function(t,e,r){return t=Is.call(t,i).sort(n),Math.ceil((r-e)/(2*(v(t,.75)-v(t,.25))*Math.pow(t.length,-1/3)))},t.thresholdScott=function(t,n,e){return Math.ceil((e-n)/(3.5*u(t)*Math.pow(t.length,-1/3)))},t.thresholdSturges=d,t.max=function(t,n){var e,r,i=t.length,o=-1;if(null==n){for(;++o<i;)if(null!=(e=t[o])&&e>=e)for(r=e;++o<i;)null!=(e=t[o])&&e>r&&(r=e)}else for(;++o<i;)if(null!=(e=n(t[o],o,t))&&e>=e)for(r=e;++o<i;)null!=(e=n(t[o],o,t))&&e>r&&(r=e);return r},t.mean=function(t,n){var e,r=t.length,o=r,u=-1,a=0;if(null==n)for(;++u<r;)isNaN(e=i(t[u]))?--o:a+=e;else for(;++u<r;)isNaN(e=i(n(t[u],u,t)))?--o:a+=e;if(o)return a/o},t.median=function(t,e){var r,o=t.length,u=-1,a=[];if(null==e)for(;++u<o;)isNaN(r=i(t[u]))||a.push(r);else for(;++u<o;)isNaN(r=i(e(t[u],u,t)))||a.push(r);return v(a.sort(n),.5)},t.merge=g,t.min=_,t.pairs=function(t,n){null==n&&(n=r);for(var e=0,i=t.length-1,o=t[0],u=new Array(i<0?0:i);e<i;)u[e]=n(o,o=t[++e]);return u},t.permute=function(t,n){for(var e=n.length,r=new Array(e);e--;)r[e]=t[n[e]];return r},t.quantile=v,t.range=f,t.scan=function(t,e){if(r=t.length){var r,i,o=0,u=0,a=t[u];for(null==e&&(e=n);++o<r;)(e(i=t[o],a)<0||0!==e(a,a))&&(a=i,u=o);return 0===e(a,a)?u:void 0}},t.shuffle=function(t,n,e){for(var r,i,o=(null==e?t.length:e)-(n=null==n?0:+n);o;)i=Math.random()*o--|0,r=t[o+n],t[o+n]=t[i+n],t[i+n]=r;return t},t.sum=function(t,n){var e,r=t.length,i=-1,o=0;if(null==n)for(;++i<r;)(e=+t[i])&&(o+=e);else for(;++i<r;)(e=+n(t[i],i,t))&&(o+=e);return o},t.ticks=l,t.tickIncrement=h,t.tickStep=p,t.transpose=y,t.variance=o,t.zip=function(){return y(arguments)},t.axisTop=function(t){return T(Xs,t)},t.axisRight=function(t){return T(Vs,t)},t.axisBottom=function(t){return T($s,t)},t.axisLeft=function(t){return T(Ws,t)},t.brush=function(){return Qn(rh)},t.brushX=function(){return Qn(nh)},t.brushY=function(){return Qn(eh)},t.brushSelection=function(t){var n=t.__brush;return n?n.dim.output(n.selection):null},t.chord=function(){function t(t){var o,u,a,c,s,l,h=t.length,p=[],d=f(h),v=[],g=[],_=g.groups=new Array(h),y=new Array(h*h);for(o=0,s=-1;++s<h;){for(u=0,l=-1;++l<h;)u+=t[s][l];p.push(u),v.push(f(h)),o+=u}for(e&&d.sort(function(t,n){return e(p[t],p[n])}),r&&v.forEach(function(n,e){n.sort(function(n,i){return r(t[e][n],t[e][i])})}),c=(o=dh(0,ph-n*h)/o)?n:ph/h,u=0,s=-1;++s<h;){for(a=u,l=-1;++l<h;){var m=d[s],x=v[m][l],b=t[m][x],w=u,M=u+=b*o;y[x*h+m]={index:m,subindex:x,startAngle:w,endAngle:M,value:b}}_[m]={index:m,startAngle:a,endAngle:u,value:p[m]},u+=c}for(s=-1;++s<h;)for(l=s-1;++l<h;){var T=y[l*h+s],N=y[s*h+l];(T.value||N.value)&&g.push(T.value<N.value?{source:N,target:T}:{source:T,target:N})}return i?g.sort(i):g}var n=0,e=null,r=null,i=null;return t.padAngle=function(e){return arguments.length?(n=dh(0,e),t):n},t.sortGroups=function(n){return arguments.length?(e=n,t):e},t.sortSubgroups=function(n){return arguments.length?(r=n,t):r},t.sortChords=function(n){return arguments.length?(null==n?i=null:(i=function(t){return function(n,e){return t(n.source.value+n.target.value,e.source.value+e.target.value)}}(n))._=n,t):i&&i._},t},t.ribbon=function(){function t(){var t,a=vh.call(arguments),c=n.apply(this,a),s=e.apply(this,a),f=+r.apply(this,(a[0]=c,a)),l=i.apply(this,a)-hh,h=o.apply(this,a)-hh,p=f*sh(l),d=f*fh(l),v=+r.apply(this,(a[0]=s,a)),g=i.apply(this,a)-hh,_=o.apply(this,a)-hh;if(u||(u=t=te()),u.moveTo(p,d),u.arc(0,0,f,l,h),l===g&&h===_||(u.quadraticCurveTo(0,0,v*sh(g),v*fh(g)),u.arc(0,0,v,g,_)),u.quadraticCurveTo(0,0,p,d),u.closePath(),t)return u=null,t+""||null}var n=ne,e=ee,r=re,i=ie,o=oe,u=null;return t.radius=function(n){return arguments.length?(r="function"==typeof n?n:Jn(+n),t):r},t.startAngle=function(n){return arguments.length?(i="function"==typeof n?n:Jn(+n),t):i},t.endAngle=function(n){return arguments.length?(o="function"==typeof n?n:Jn(+n),t):o},t.source=function(e){return arguments.length?(n=e,t):n},t.target=function(n){return arguments.length?(e=n,t):e},t.context=function(n){return arguments.length?(u=null==n?null:n,t):u},t},t.nest=function(){function t(n,i,u,a){if(i>=o.length)return null!=e&&n.sort(e),null!=r?r(n):n;for(var c,s,f,l=-1,h=n.length,p=o[i++],d=ae(),v=u();++l<h;)(f=d.get(c=p(s=n[l])+""))?f.push(s):d.set(c,[s]);return d.each(function(n,e){a(v,e,t(n,i,u,a))}),v}function n(t,e){if(++e>o.length)return t;var i,a=u[e-1];return null!=r&&e>=o.length?i=t.entries():(i=[],t.each(function(t,r){i.push({key:r,values:n(t,e)})})),null!=a?i.sort(function(t,n){return a(t.key,n.key)}):i}var e,r,i,o=[],u=[];return i={object:function(n){return t(n,0,ce,se)},map:function(n){return t(n,0,fe,le)},entries:function(e){return n(t(e,0,fe,le),0)},key:function(t){return o.push(t),i},sortKeys:function(t){return u[o.length-1]=t,i},sortValues:function(t){return e=t,i},rollup:function(t){return r=t,i}}},t.set=pe,t.map=ae,t.keys=function(t){var n=[];for(var e in t)n.push(e);return n},t.values=function(t){var n=[];for(var e in t)n.push(t[e]);return n},t.entries=function(t){var n=[];for(var e in t)n.push({key:e,value:t[e]});return n},t.color=kt,t.rgb=Ct,t.hsl=Rt,t.lab=Ut,t.hcl=Ht,t.cubehelix=Xt,t.dispatch=N,t.drag=function(){function n(t){t.on("mousedown.drag",e).filter(g).on("touchstart.drag",o).on("touchmove.drag",u).on("touchend.drag touchcancel.drag",a).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function e(){if(!h&&p.apply(this,arguments)){var n=c("mouse",d.apply(this,arguments),F,this,arguments);n&&(lt(t.event.view).on("mousemove.drag",r,!0).on("mouseup.drag",i,!0),vt(t.event.view),pt(),l=!1,s=t.event.clientX,f=t.event.clientY,n("start"))}}function r(){if(dt(),!l){var n=t.event.clientX-s,e=t.event.clientY-f;l=n*n+e*e>x}_.mouse("drag")}function i(){lt(t.event.view).on("mousemove.drag mouseup.drag",null),gt(t.event.view,l),dt(),_.mouse("end")}function o(){if(p.apply(this,arguments)){var n,e,r=t.event.changedTouches,i=d.apply(this,arguments),o=r.length;for(n=0;n<o;++n)(e=c(r[n].identifier,i,ht,this,arguments))&&(pt(),e("start"))}}function u(){var n,e,r=t.event.changedTouches,i=r.length;for(n=0;n<i;++n)(e=_[r[n].identifier])&&(dt(),e("drag"))}function a(){var n,e,r=t.event.changedTouches,i=r.length;for(h&&clearTimeout(h),h=setTimeout(function(){h=null},500),n=0;n<i;++n)(e=_[r[n].identifier])&&(pt(),e("end"))}function c(e,r,i,o,u){var a,c,s,f=i(r,e),l=y.copy();if(D(new yt(n,"beforestart",a,e,m,f[0],f[1],0,0,l),function(){return null!=(t.event.subject=a=v.apply(o,u))&&(c=a.x-f[0]||0,s=a.y-f[1]||0,!0)}))return function t(h){var p,d=f;switch(h){case"start":_[e]=t,p=m++;break;case"end":delete _[e],--m;case"drag":f=i(r,e),p=m}D(new yt(n,h,a,e,p,f[0]+c,f[1]+s,f[0]-d[0],f[1]-d[1],l),l.apply,l,[h,o,u])}}var s,f,l,h,p=mt,d=xt,v=bt,g=wt,_={},y=N("start","drag","end"),m=0,x=0;return n.filter=function(t){return arguments.length?(p="function"==typeof t?t:_t(!!t),n):p},n.container=function(t){return arguments.length?(d="function"==typeof t?t:_t(t),n):d},n.subject=function(t){return arguments.length?(v="function"==typeof t?t:_t(t),n):v},n.touchable=function(t){return arguments.length?(g="function"==typeof t?t:_t(!!t),n):g},n.on=function(){var t=y.on.apply(y,arguments);return t===y?n:t},n.clickDistance=function(t){return arguments.length?(x=(t=+t)*t,n):Math.sqrt(x)},n},t.dragDisable=vt,t.dragEnable=gt,t.dsvFormat=ve,t.csvParse=kh,t.csvParseRows=Sh,t.csvFormat=Eh,t.csvFormatRows=Ah,t.tsvParse=zh,t.tsvParseRows=Ph,t.tsvFormat=Rh,t.tsvFormatRows=Lh,t.easeLinear=function(t){return+t},t.easeQuad=Dn,t.easeQuadIn=function(t){return t*t},t.easeQuadOut=function(t){return t*(2-t)},t.easeQuadInOut=Dn,t.easeCubic=Un,t.easeCubicIn=function(t){return t*t*t},t.easeCubicOut=function(t){return--t*t*t+1},t.easeCubicInOut=Un,t.easePoly=Al,t.easePolyIn=Sl,t.easePolyOut=El,t.easePolyInOut=Al,t.easeSin=On,t.easeSinIn=function(t){return 1-Math.cos(t*zl)},t.easeSinOut=function(t){return Math.sin(t*zl)},t.easeSinInOut=On,t.easeExp=Fn,t.easeExpIn=function(t){return Math.pow(2,10*t-10)},t.easeExpOut=function(t){return 1-Math.pow(2,-10*t)},t.easeExpInOut=Fn,t.easeCircle=In,t.easeCircleIn=function(t){return 1-Math.sqrt(1-t*t)},t.easeCircleOut=function(t){return Math.sqrt(1- --t*t)},t.easeCircleInOut=In,t.easeBounce=Yn,t.easeBounceIn=function(t){return 1-Yn(1-t)},t.easeBounceOut=Yn,t.easeBounceInOut=function(t){return((t*=2)<=1?1-Yn(1-t):Yn(t-1)+1)/2},t.easeBack=jl,t.easeBackIn=Bl,t.easeBackOut=Hl,t.easeBackInOut=jl,t.easeElastic=$l,t.easeElasticIn=Vl,t.easeElasticOut=$l,t.easeElasticInOut=Wl,t.forceCenter=function(t,n){function e(){var e,i,o=r.length,u=0,a=0;for(e=0;e<o;++e)u+=(i=r[e]).x,a+=i.y;for(u=u/o-t,a=a/o-n,e=0;e<o;++e)(i=r[e]).x-=u,i.y-=a}var r;return null==t&&(t=0),null==n&&(n=0),e.initialize=function(t){r=t},e.x=function(n){return arguments.length?(t=+n,e):t},e.y=function(t){return arguments.length?(n=+t,e):n},e},t.forceCollide=function(t){function n(){for(var t,n,r,c,s,f,l,h=i.length,p=0;p<a;++p)for(n=we(i,Ne,ke).visitAfter(e),t=0;t<h;++t)r=i[t],f=o[r.index],l=f*f,c=r.x+r.vx,s=r.y+r.vy,n.visit(function(t,n,e,i,o){var a=t.data,h=t.r,p=f+h;if(!a)return n>c+p||i<c-p||e>s+p||o<s-p;if(a.index>r.index){var d=c-a.x-a.vx,v=s-a.y-a.vy,g=d*d+v*v;g<p*p&&(0===d&&(d=_e(),g+=d*d),0===v&&(v=_e(),g+=v*v),g=(p-(g=Math.sqrt(g)))/g*u,r.vx+=(d*=g)*(p=(h*=h)/(l+h)),r.vy+=(v*=g)*p,a.vx-=d*(p=1-p),a.vy-=v*p)}})}function e(t){if(t.data)return t.r=o[t.data.index];for(var n=t.r=0;n<4;++n)t[n]&&t[n].r>t.r&&(t.r=t[n].r)}function r(){if(i){var n,e,r=i.length;for(o=new Array(r),n=0;n<r;++n)e=i[n],o[e.index]=+t(e,n,i)}}var i,o,u=1,a=1;return"function"!=typeof t&&(t=ge(null==t?1:+t)),n.initialize=function(t){i=t,r()},n.iterations=function(t){return arguments.length?(a=+t,n):a},n.strength=function(t){return arguments.length?(u=+t,n):u},n.radius=function(e){return arguments.length?(t="function"==typeof e?e:ge(+e),r(),n):t},n},t.forceLink=function(t){function n(n){for(var e=0,r=t.length;e<p;++e)for(var i,a,c,f,l,h,d,v=0;v<r;++v)a=(i=t[v]).source,f=(c=i.target).x+c.vx-a.x-a.vx||_e(),l=c.y+c.vy-a.y-a.vy||_e(),f*=h=((h=Math.sqrt(f*f+l*l))-u[v])/h*n*o[v],l*=h,c.vx-=f*(d=s[v]),c.vy-=l*d,a.vx+=f*(d=1-d),a.vy+=l*d}function e(){if(a){var n,e,l=a.length,h=t.length,p=ae(a,f);for(n=0,c=new Array(l);n<h;++n)(e=t[n]).index=n,"object"!=typeof e.source&&(e.source=Ee(p,e.source)),"object"!=typeof e.target&&(e.target=Ee(p,e.target)),c[e.source.index]=(c[e.source.index]||0)+1,c[e.target.index]=(c[e.target.index]||0)+1;for(n=0,s=new Array(h);n<h;++n)e=t[n],s[n]=c[e.source.index]/(c[e.source.index]+c[e.target.index]);o=new Array(h),r(),u=new Array(h),i()}}function r(){if(a)for(var n=0,e=t.length;n<e;++n)o[n]=+l(t[n],n,t)}function i(){if(a)for(var n=0,e=t.length;n<e;++n)u[n]=+h(t[n],n,t)}var o,u,a,c,s,f=Se,l=function(t){return 1/Math.min(c[t.source.index],c[t.target.index])},h=ge(30),p=1;return null==t&&(t=[]),n.initialize=function(t){a=t,e()},n.links=function(r){return arguments.length?(t=r,e(),n):t},n.id=function(t){return arguments.length?(f=t,n):f},n.iterations=function(t){return arguments.length?(p=+t,n):p},n.strength=function(t){return arguments.length?(l="function"==typeof t?t:ge(+t),r(),n):l},n.distance=function(t){return arguments.length?(h="function"==typeof t?t:ge(+t),i(),n):h},n},t.forceManyBody=function(){function t(t){var n,a=i.length,c=we(i,Ae,Ce).visitAfter(e);for(u=t,n=0;n<a;++n)o=i[n],c.visit(r)}function n(){if(i){var t,n,e=i.length;for(a=new Array(e),t=0;t<e;++t)n=i[t],a[n.index]=+c(n,t,i)}}function e(t){var n,e,r,i,o,u=0,c=0;if(t.length){for(r=i=o=0;o<4;++o)(n=t[o])&&(e=Math.abs(n.value))&&(u+=n.value,c+=e,r+=e*n.x,i+=e*n.y);t.x=r/c,t.y=i/c}else{(n=t).x=n.data.x,n.y=n.data.y;do{u+=a[n.data.index]}while(n=n.next)}t.value=u}function r(t,n,e,r){if(!t.value)return!0;var i=t.x-o.x,c=t.y-o.y,h=r-n,p=i*i+c*c;if(h*h/l<p)return p<f&&(0===i&&(i=_e(),p+=i*i),0===c&&(c=_e(),p+=c*c),p<s&&(p=Math.sqrt(s*p)),o.vx+=i*t.value*u/p,o.vy+=c*t.value*u/p),!0;if(!(t.length||p>=f)){(t.data!==o||t.next)&&(0===i&&(i=_e(),p+=i*i),0===c&&(c=_e(),p+=c*c),p<s&&(p=Math.sqrt(s*p)));do{t.data!==o&&(h=a[t.data.index]*u/p,o.vx+=i*h,o.vy+=c*h)}while(t=t.next)}}var i,o,u,a,c=ge(-30),s=1,f=1/0,l=.81;return t.initialize=function(t){i=t,n()},t.strength=function(e){return arguments.length?(c="function"==typeof e?e:ge(+e),n(),t):c},t.distanceMin=function(n){return arguments.length?(s=n*n,t):Math.sqrt(s)},t.distanceMax=function(n){return arguments.length?(f=n*n,t):Math.sqrt(f)},t.theta=function(n){return arguments.length?(l=n*n,t):Math.sqrt(l)},t},t.forceRadial=function(t,n,e){function r(t){for(var r=0,i=o.length;r<i;++r){var c=o[r],s=c.x-n||1e-6,f=c.y-e||1e-6,l=Math.sqrt(s*s+f*f),h=(a[r]-l)*u[r]*t/l;c.vx+=s*h,c.vy+=f*h}}function i(){if(o){var n,e=o.length;for(u=new Array(e),a=new Array(e),n=0;n<e;++n)a[n]=+t(o[n],n,o),u[n]=isNaN(a[n])?0:+c(o[n],n,o)}}var o,u,a,c=ge(.1);return"function"!=typeof t&&(t=ge(+t)),null==n&&(n=0),null==e&&(e=0),r.initialize=function(t){o=t,i()},r.strength=function(t){return arguments.length?(c="function"==typeof t?t:ge(+t),i(),r):c},r.radius=function(n){return arguments.length?(t="function"==typeof n?n:ge(+n),i(),r):t},r.x=function(t){return arguments.length?(n=+t,r):n},r.y=function(t){return arguments.length?(e=+t,r):e},r},t.forceSimulation=function(t){function n(){e(),p.call("tick",o),u<a&&(h.stop(),p.call("end",o))}function e(){var n,e,r=t.length;for(u+=(s-u)*c,l.each(function(t){t(u)}),n=0;n<r;++n)null==(e=t[n]).fx?e.x+=e.vx*=f:(e.x=e.fx,e.vx=0),null==e.fy?e.y+=e.vy*=f:(e.y=e.fy,e.vy=0)}function r(){for(var n,e=0,r=t.length;e<r;++e){if(n=t[e],n.index=e,isNaN(n.x)||isNaN(n.y)){var i=Uh*Math.sqrt(e),o=e*Oh;n.x=i*Math.cos(o),n.y=i*Math.sin(o)}(isNaN(n.vx)||isNaN(n.vy))&&(n.vx=n.vy=0)}}function i(n){return n.initialize&&n.initialize(t),n}var o,u=1,a=.001,c=1-Math.pow(a,1/300),s=0,f=.6,l=ae(),h=xn(n),p=N("tick","end");return null==t&&(t=[]),r(),o={tick:e,restart:function(){return h.restart(n),o},stop:function(){return h.stop(),o},nodes:function(n){return arguments.length?(t=n,r(),l.each(i),o):t},alpha:function(t){return arguments.length?(u=+t,o):u},alphaMin:function(t){return arguments.length?(a=+t,o):a},alphaDecay:function(t){return arguments.length?(c=+t,o):+c},alphaTarget:function(t){return arguments.length?(s=+t,o):s},velocityDecay:function(t){return arguments.length?(f=1-t,o):1-f},force:function(t,n){return arguments.length>1?(null==n?l.remove(t):l.set(t,i(n)),o):l.get(t)},find:function(n,e,r){var i,o,u,a,c,s=0,f=t.length;for(null==r?r=1/0:r*=r,s=0;s<f;++s)(u=(i=n-(a=t[s]).x)*i+(o=e-a.y)*o)<r&&(c=a,r=u);return c},on:function(t,n){return arguments.length>1?(p.on(t,n),o):p.on(t)}}},t.forceX=function(t){function n(t){for(var n,e=0,u=r.length;e<u;++e)(n=r[e]).vx+=(o[e]-n.x)*i[e]*t}function e(){if(r){var n,e=r.length;for(i=new Array(e),o=new Array(e),n=0;n<e;++n)i[n]=isNaN(o[n]=+t(r[n],n,r))?0:+u(r[n],n,r)}}var r,i,o,u=ge(.1);return"function"!=typeof t&&(t=ge(null==t?0:+t)),n.initialize=function(t){r=t,e()},n.strength=function(t){return arguments.length?(u="function"==typeof t?t:ge(+t),e(),n):u},n.x=function(r){return arguments.length?(t="function"==typeof r?r:ge(+r),e(),n):t},n},t.forceY=function(t){function n(t){for(var n,e=0,u=r.length;e<u;++e)(n=r[e]).vy+=(o[e]-n.y)*i[e]*t}function e(){if(r){var n,e=r.length;for(i=new Array(e),o=new Array(e),n=0;n<e;++n)i[n]=isNaN(o[n]=+t(r[n],n,r))?0:+u(r[n],n,r)}}var r,i,o,u=ge(.1);return"function"!=typeof t&&(t=ge(null==t?0:+t)),n.initialize=function(t){r=t,e()},n.strength=function(t){return arguments.length?(u="function"==typeof t?t:ge(+t),e(),n):u},n.y=function(r){return arguments.length?(t="function"==typeof r?r:ge(+r),e(),n):t},n},t.formatDefaultLocale=Oe,t.formatLocale=Ue,t.formatSpecifier=Le,t.precisionFixed=Fe,t.precisionPrefix=Ie,t.precisionRound=Ye,t.geoArea=function(t){return jp.reset(),Je(t,Xp),2*jp},t.geoBounds=function(t){var n,e,r,i,o,u,a;if(Qh=Gh=-(Wh=Zh=1/0),ep=[],Je(t,$p),e=ep.length){for(ep.sort(yr),n=1,o=[r=ep[0]];n<e;++n)mr(r,(i=ep[n])[0])||mr(r,i[1])?(_r(r[0],i[1])>_r(r[0],r[1])&&(r[1]=i[1]),_r(i[0],r[1])>_r(r[0],r[1])&&(r[0]=i[0])):o.push(r=i);for(u=-1/0,n=0,r=o[e=o.length-1];n<=e;r=i,++n)i=o[n],(a=_r(r[1],i[0]))>u&&(u=a,Wh=i[0],Gh=r[1])}return ep=rp=null,Wh===1/0||Zh===1/0?[[NaN,NaN],[NaN,NaN]]:[[Wh,Zh],[Gh,Qh]]},t.geoCentroid=function(t){ip=op=up=ap=cp=sp=fp=lp=hp=pp=dp=0,Je(t,Wp);var n=hp,e=pp,r=dp,i=n*n+e*e+r*r;return i<wp&&(n=sp,e=fp,r=lp,op<bp&&(n=up,e=ap,r=cp),(i=n*n+e*e+r*r)<wp)?[NaN,NaN]:[zp(e,n)*Sp,Ve(r/Fp(i))*Sp]},t.geoCircle=function(){function t(){var t=r.apply(this,arguments),a=i.apply(this,arguments)*Ep,c=o.apply(this,arguments)*Ep;return n=[],e=Rr(-t[0]*Ep,-t[1]*Ep,0).invert,Or(u,a,c,1),t={type:"Polygon",coordinates:[n]},n=e=null,t}var n,e,r=Cr([0,0]),i=Cr(90),o=Cr(6),u={point:function(t,r){n.push(t=e(t,r)),t[0]*=Sp,t[1]*=Sp}};return t.center=function(n){return arguments.length?(r="function"==typeof n?n:Cr([+n[0],+n[1]]),t):r},t.radius=function(n){return arguments.length?(i="function"==typeof n?n:Cr(+n),t):i},t.precision=function(n){return arguments.length?(o="function"==typeof n?n:Cr(+n),t):o},t},t.geoClipAntimeridian=ad,t.geoClipCircle=Zr,t.geoClipExtent=function(){var t,n,e,r=0,i=0,o=960,u=500;return e={stream:function(e){return t&&n===e?t:t=Gr(r,i,o,u)(n=e)},extent:function(a){return arguments.length?(r=+a[0][0],i=+a[0][1],o=+a[1][0],u=+a[1][1],t=n=null,e):[[r,i],[o,u]]}}},t.geoClipRectangle=Gr,t.geoContains=function(t,n){return(t&&dd.hasOwnProperty(t.type)?dd[t.type]:ei)(t,n)},t.geoDistance=ni,t.geoGraticule=fi,t.geoGraticule10=function(){return fi()()},t.geoInterpolate=function(t,n){var e=t[0]*Ep,r=t[1]*Ep,i=n[0]*Ep,o=n[1]*Ep,u=Pp(r),a=Up(r),c=Pp(o),s=Up(o),f=u*Pp(e),l=u*Up(e),h=c*Pp(i),p=c*Up(i),d=2*Ve(Fp($e(o-r)+u*c*$e(i-e))),v=Up(d),g=d?function(t){var n=Up(t*=d)/v,e=Up(d-t)/v,r=e*f+n*h,i=e*l+n*p,o=e*a+n*s;return[zp(i,r)*Sp,zp(o,Fp(r*r+i*i))*Sp]}:function(){return[e*Sp,r*Sp]};return g.distance=d,g},t.geoLength=ti,t.geoPath=function(t,n){function e(t){return t&&("function"==typeof o&&i.pointRadius(+o.apply(this,arguments)),Je(t,r(i))),i.result()}var r,i,o=4.5;return e.area=function(t){return Je(t,r(yd)),yd.result()},e.measure=function(t){return Je(t,r(Id)),Id.result()},e.bounds=function(t){return Je(t,r(Md)),Md.result()},e.centroid=function(t){return Je(t,r(Rd)),Rd.result()},e.projection=function(n){return arguments.length?(r=null==n?(t=null,li):(t=n).stream,e):t},e.context=function(t){return arguments.length?(i=null==t?(n=null,new Ei):new Ni(n=t),"function"!=typeof o&&i.pointRadius(o),e):n},e.pointRadius=function(t){return arguments.length?(o="function"==typeof t?t:(i.pointRadius(+t),+t),e):o},e.projection(t).context(n)},t.geoAlbers=Hi,t.geoAlbersUsa=function(){function t(t){var n=t[0],e=t[1];return a=null,i.point(n,e),a||(o.point(n,e),a)||(u.point(n,e),a)}function n(){return e=r=null,t}var e,r,i,o,u,a,c=Hi(),s=Bi().rotate([154,0]).center([-2,58.5]).parallels([55,65]),f=Bi().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(t,n){a=[t,n]}};return t.invert=function(t){var n=c.scale(),e=c.translate(),r=(t[0]-e[0])/n,i=(t[1]-e[1])/n;return(i>=.12&&i<.234&&r>=-.425&&r<-.214?s:i>=.166&&i<.234&&r>=-.214&&r<-.115?f:c).invert(t)},t.stream=function(t){return e&&r===t?e:e=function(t){var n=t.length;return{point:function(e,r){for(var i=-1;++i<n;)t[i].point(e,r)},sphere:function(){for(var e=-1;++e<n;)t[e].sphere()},lineStart:function(){for(var e=-1;++e<n;)t[e].lineStart()},lineEnd:function(){for(var e=-1;++e<n;)t[e].lineEnd()},polygonStart:function(){for(var e=-1;++e<n;)t[e].polygonStart()},polygonEnd:function(){for(var e=-1;++e<n;)t[e].polygonEnd()}}}([c.stream(r=t),s.stream(t),f.stream(t)])},t.precision=function(t){return arguments.length?(c.precision(t),s.precision(t),f.precision(t),n()):c.precision()},t.scale=function(n){return arguments.length?(c.scale(n),s.scale(.35*n),f.scale(n),t.translate(c.translate())):c.scale()},t.translate=function(t){if(!arguments.length)return c.translate();var e=c.scale(),r=+t[0],a=+t[1];return i=c.translate(t).clipExtent([[r-.455*e,a-.238*e],[r+.455*e,a+.238*e]]).stream(l),o=s.translate([r-.307*e,a+.201*e]).clipExtent([[r-.425*e+bp,a+.12*e+bp],[r-.214*e-bp,a+.234*e-bp]]).stream(l),u=f.translate([r-.205*e,a+.212*e]).clipExtent([[r-.214*e+bp,a+.166*e+bp],[r-.115*e-bp,a+.234*e-bp]]).stream(l),n()},t.fitExtent=function(n,e){return Ri(t,n,e)},t.fitSize=function(n,e){return Li(t,n,e)},t.fitWidth=function(n,e){return qi(t,n,e)},t.fitHeight=function(n,e){return Di(t,n,e)},t.scale(1070)},t.geoAzimuthalEqualArea=function(){return Oi(jd).scale(124.75).clipAngle(179.999)},t.geoAzimuthalEqualAreaRaw=jd,t.geoAzimuthalEquidistant=function(){return Oi(Xd).scale(79.4188).clipAngle(179.999)},t.geoAzimuthalEquidistantRaw=Xd,t.geoConicConformal=function(){return Ii(Zi).scale(109.5).parallels([30,30])},t.geoConicConformalRaw=Zi,t.geoConicEqualArea=Bi,t.geoConicEqualAreaRaw=Yi,t.geoConicEquidistant=function(){return Ii(Qi).scale(131.154).center([0,13.9389])},t.geoConicEquidistantRaw=Qi,t.geoEquirectangular=function(){return Oi(Gi).scale(152.63)},t.geoEquirectangularRaw=Gi,t.geoGnomonic=function(){return Oi(Ji).scale(144.049).clipAngle(60)},t.geoGnomonicRaw=Ji,t.geoIdentity=function(){function t(){return i=o=null,u}var n,e,r,i,o,u,a=1,c=0,s=0,f=1,l=1,h=li,p=null,d=li;return u={stream:function(t){return i&&o===t?i:i=h(d(o=t))},postclip:function(i){return arguments.length?(d=i,p=n=e=r=null,t()):d},clipExtent:function(i){return arguments.length?(d=null==i?(p=n=e=r=null,li):Gr(p=+i[0][0],n=+i[0][1],e=+i[1][0],r=+i[1][1]),t()):null==p?null:[[p,n],[e,r]]},scale:function(n){return arguments.length?(h=Ki((a=+n)*f,a*l,c,s),t()):a},translate:function(n){return arguments.length?(h=Ki(a*f,a*l,c=+n[0],s=+n[1]),t()):[c,s]},reflectX:function(n){return arguments.length?(h=Ki(a*(f=n?-1:1),a*l,c,s),t()):f<0},reflectY:function(n){return arguments.length?(h=Ki(a*f,a*(l=n?-1:1),c,s),t()):l<0},fitExtent:function(t,n){return Ri(u,t,n)},fitSize:function(t,n){return Li(u,t,n)},fitWidth:function(t,n){return qi(u,t,n)},fitHeight:function(t,n){return Di(u,t,n)}}},t.geoProjection=Oi,t.geoProjectionMutator=Fi,t.geoMercator=function(){return $i(Vi).scale(961/kp)},t.geoMercatorRaw=Vi,t.geoNaturalEarth1=function(){return Oi(to).scale(175.295)},t.geoNaturalEarth1Raw=to,t.geoOrthographic=function(){return Oi(no).scale(249.5).clipAngle(90+bp)},t.geoOrthographicRaw=no,t.geoStereographic=function(){return Oi(eo).scale(250).clipAngle(142)},t.geoStereographicRaw=eo,t.geoTransverseMercator=function(){var t=$i(ro),n=t.center,e=t.rotate;return t.center=function(t){return arguments.length?n([-t[1],t[0]]):(t=n(),[t[1],-t[0]])},t.rotate=function(t){return arguments.length?e([t[0],t[1],t.length>2?t[2]+90:90]):(t=e(),[t[0],t[1],t[2]-90])},e([0,0,90]).scale(159.155)},t.geoTransverseMercatorRaw=ro,t.geoRotation=Ur,t.geoStream=Je,t.geoTransform=function(t){return{stream:Ci(t)}},t.cluster=function(){function t(t){var o,u=0;t.eachAfter(function(t){var e=t.children;e?(t.x=function(t){return t.reduce(oo,0)/t.length}(e),t.y=function(t){return 1+t.reduce(uo,0)}(e)):(t.x=o?u+=n(t,o):0,t.y=0,o=t)});var a=function(t){for(var n;n=t.children;)t=n[0];return t}(t),c=function(t){for(var n;n=t.children;)t=n[n.length-1];return t}(t),s=a.x-n(a,c)/2,f=c.x+n(c,a)/2;return t.eachAfter(i?function(n){n.x=(n.x-t.x)*e,n.y=(t.y-n.y)*r}:function(n){n.x=(n.x-s)/(f-s)*e,n.y=(1-(t.y?n.y/t.y:1))*r})}var n=io,e=1,r=1,i=!1;return t.separation=function(e){return arguments.length?(n=e,t):n},t.size=function(n){return arguments.length?(i=!1,e=+n[0],r=+n[1],t):i?null:[e,r]},t.nodeSize=function(n){return arguments.length?(i=!0,e=+n[0],r=+n[1],t):i?[e,r]:null},t},t.hierarchy=co,t.pack=function(){function t(t){return t.x=e/2,t.y=r/2,n?t.eachBefore(Ao(n)).eachAfter(Co(i,.5)).eachBefore(zo(1)):t.eachBefore(Ao(Eo)).eachAfter(Co(ko,1)).eachAfter(Co(i,t.r/Math.min(e,r))).eachBefore(zo(Math.min(e,r)/(2*t.r))),t}var n=null,e=1,r=1,i=ko;return t.radius=function(e){return arguments.length?(n=function(t){return null==t?null:No(t)}(e),t):n},t.size=function(n){return arguments.length?(e=+n[0],r=+n[1],t):[e,r]},t.padding=function(n){return arguments.length?(i="function"==typeof n?n:So(+n),t):i},t},t.packSiblings=function(t){return To(t),t},t.packEnclose=po,t.partition=function(){function t(t){var o=t.height+1;return t.x0=t.y0=r,t.x1=n,t.y1=e/o,t.eachBefore(function(t,n){return function(e){e.children&&Ro(e,e.x0,t*(e.depth+1)/n,e.x1,t*(e.depth+2)/n);var i=e.x0,o=e.y0,u=e.x1-r,a=e.y1-r;u<i&&(i=u=(i+u)/2),a<o&&(o=a=(o+a)/2),e.x0=i,e.y0=o,e.x1=u,e.y1=a}}(e,o)),i&&t.eachBefore(Po),t}var n=1,e=1,r=0,i=!1;return t.round=function(n){return arguments.length?(i=!!n,t):i},t.size=function(r){return arguments.length?(n=+r[0],e=+r[1],t):[n,e]},t.padding=function(n){return arguments.length?(r=+n,t):r},t},t.stratify=function(){function t(t){var r,i,o,u,a,c,s,f=t.length,l=new Array(f),h={};for(i=0;i<f;++i)r=t[i],a=l[i]=new ho(r),null!=(c=n(r,i,t))&&(c+="")&&(h[s=$d+(a.id=c)]=s in h?Zd:a);for(i=0;i<f;++i)if(a=l[i],null!=(c=e(t[i],i,t))&&(c+="")){if(!(u=h[$d+c]))throw new Error("missing: "+c);if(u===Zd)throw new Error("ambiguous: "+c);u.children?u.children.push(a):u.children=[a],a.parent=u}else{if(o)throw new Error("multiple roots");o=a}if(!o)throw new Error("no root");if(o.parent=Wd,o.eachBefore(function(t){t.depth=t.parent.depth+1,--f}).eachBefore(lo),o.parent=null,f>0)throw new Error("cycle");return o}var n=Lo,e=qo;return t.id=function(e){return arguments.length?(n=No(e),t):n},t.parentId=function(n){return arguments.length?(e=No(n),t):e},t},t.tree=function(){function t(t){var c=function(t){for(var n,e,r,i,o,u=new Yo(t,0),a=[u];n=a.pop();)if(r=n._.children)for(n.children=new Array(o=r.length),i=o-1;i>=0;--i)a.push(e=n.children[i]=new Yo(r[i],i)),e.parent=n;return(u.parent=new Yo(null,0)).children=[u],u}(t);if(c.eachAfter(n),c.parent.m=-c.z,c.eachBefore(e),a)t.eachBefore(r);else{var s=t,f=t,l=t;t.eachBefore(function(t){t.x<s.x&&(s=t),t.x>f.x&&(f=t),t.depth>l.depth&&(l=t)});var h=s===f?1:i(s,f)/2,p=h-s.x,d=o/(f.x+h+p),v=u/(l.depth||1);t.eachBefore(function(t){t.x=(t.x+p)*d,t.y=t.depth*v})}return t}function n(t){var n=t.children,e=t.parent.children,r=t.i?e[t.i-1]:null;if(n){(function(t){for(var n,e=0,r=0,i=t.children,o=i.length;--o>=0;)(n=i[o]).z+=e,n.m+=e,e+=n.s+(r+=n.c)})(t);var o=(n[0].z+n[n.length-1].z)/2;r?(t.z=r.z+i(t._,r._),t.m=t.z-o):t.z=o}else r&&(t.z=r.z+i(t._,r._));t.parent.A=function(t,n,e){if(n){for(var r,o=t,u=t,a=n,c=o.parent.children[0],s=o.m,f=u.m,l=a.m,h=c.m;a=Oo(a),o=Uo(o),a&&o;)c=Uo(c),(u=Oo(u)).a=t,(r=a.z+l-o.z-s+i(a._,o._))>0&&(Fo(Io(a,t,e),t,r),s+=r,f+=r),l+=a.m,s+=o.m,h+=c.m,f+=u.m;a&&!Oo(u)&&(u.t=a,u.m+=l-f),o&&!Uo(c)&&(c.t=o,c.m+=s-h,e=t)}return e}(t,r,t.parent.A||e[0])}function e(t){t._.x=t.z+t.parent.m,t.m+=t.parent.m}function r(t){t.x*=o,t.y=t.depth*u}var i=Do,o=1,u=1,a=null;return t.separation=function(n){return arguments.length?(i=n,t):i},t.size=function(n){return arguments.length?(a=!1,o=+n[0],u=+n[1],t):a?null:[o,u]},t.nodeSize=function(n){return arguments.length?(a=!0,o=+n[0],u=+n[1],t):a?[o,u]:null},t},t.treemap=function(){function t(t){return t.x0=t.y0=0,t.x1=i,t.y1=o,t.eachBefore(n),u=[0],r&&t.eachBefore(Po),t}function n(t){var n=u[t.depth],r=t.x0+n,i=t.y0+n,o=t.x1-n,h=t.y1-n;o<r&&(r=o=(r+o)/2),h<i&&(i=h=(i+h)/2),t.x0=r,t.y0=i,t.x1=o,t.y1=h,t.children&&(n=u[t.depth+1]=a(t)/2,r+=l(t)-n,i+=c(t)-n,o-=s(t)-n,h-=f(t)-n,o<r&&(r=o=(r+o)/2),h<i&&(i=h=(i+h)/2),e(t,r,i,o,h))}var e=Qd,r=!1,i=1,o=1,u=[0],a=ko,c=ko,s=ko,f=ko,l=ko;return t.round=function(n){return arguments.length?(r=!!n,t):r},t.size=function(n){return arguments.length?(i=+n[0],o=+n[1],t):[i,o]},t.tile=function(n){return arguments.length?(e=No(n),t):e},t.padding=function(n){return arguments.length?t.paddingInner(n).paddingOuter(n):t.paddingInner()},t.paddingInner=function(n){return arguments.length?(a="function"==typeof n?n:So(+n),t):a},t.paddingOuter=function(n){return arguments.length?t.paddingTop(n).paddingRight(n).paddingBottom(n).paddingLeft(n):t.paddingTop()},t.paddingTop=function(n){return arguments.length?(c="function"==typeof n?n:So(+n),t):c},t.paddingRight=function(n){return arguments.length?(s="function"==typeof n?n:So(+n),t):s},t.paddingBottom=function(n){return arguments.length?(f="function"==typeof n?n:So(+n),t):f},t.paddingLeft=function(n){return arguments.length?(l="function"==typeof n?n:So(+n),t):l},t},t.treemapBinary=function(t,n,e,r,i){function o(t,n,e,r,i,u,a){if(t>=n-1){var s=c[t];return s.x0=r,s.y0=i,s.x1=u,void(s.y1=a)}for(var l=f[t],h=e/2+l,p=t+1,d=n-1;p<d;){var v=p+d>>>1;f[v]<h?p=v+1:d=v}h-f[p-1]<f[p]-h&&t+1<p&&--p;var g=f[p]-l,_=e-g;if(u-r>a-i){var y=(r*_+u*g)/e;o(t,p,g,r,i,y,a),o(p,n,_,y,i,u,a)}else{var m=(i*_+a*g)/e;o(t,p,g,r,i,u,m),o(p,n,_,r,m,u,a)}}var u,a,c=t.children,s=c.length,f=new Array(s+1);for(f[0]=a=u=0;u<s;++u)f[u+1]=a+=c[u].value;o(0,s,t.value,n,e,r,i)},t.treemapDice=Ro,t.treemapSlice=Bo,t.treemapSliceDice=function(t,n,e,r,i){(1&t.depth?Bo:Ro)(t,n,e,r,i)},t.treemapSquarify=Qd,t.treemapResquarify=Jd,t.interpolate=cn,t.interpolateArray=en,t.interpolateBasis=Wt,t.interpolateBasisClosed=Zt,t.interpolateDate=rn,t.interpolateNumber=on,t.interpolateObject=un,t.interpolateRound=sn,t.interpolateString=an,t.interpolateTransformCss=Wf,t.interpolateTransformSvg=Zf,t.interpolateZoom=pn,t.interpolateRgb=Yf,t.interpolateRgbBasis=Bf,t.interpolateRgbBasisClosed=Hf,t.interpolateHsl=tl,t.interpolateHslLong=nl,t.interpolateLab=function(t,n){var e=tn((t=Ut(t)).l,(n=Ut(n)).l),r=tn(t.a,n.a),i=tn(t.b,n.b),o=tn(t.opacity,n.opacity);return function(n){return t.l=e(n),t.a=r(n),t.b=i(n),t.opacity=o(n),t+""}},t.interpolateHcl=el,t.interpolateHclLong=rl,t.interpolateCubehelix=il,t.interpolateCubehelixLong=ol,t.quantize=function(t,n){for(var e=new Array(n),r=0;r<n;++r)e[r]=t(r/(n-1));return e},t.path=te,t.polygonArea=function(t){for(var n,e=-1,r=t.length,i=t[r-1],o=0;++e<r;)n=i,i=t[e],o+=n[1]*i[0]-n[0]*i[1];return o/2},t.polygonCentroid=function(t){for(var n,e,r=-1,i=t.length,o=0,u=0,a=t[i-1],c=0;++r<i;)n=a,a=t[r],c+=e=n[0]*a[1]-a[0]*n[1],o+=(n[0]+a[0])*e,u+=(n[1]+a[1])*e;return c*=3,[o/c,u/c]},t.polygonHull=function(t){if((e=t.length)<3)return null;var n,e,r=new Array(e),i=new Array(e);for(n=0;n<e;++n)r[n]=[+t[n][0],+t[n][1],n];for(r.sort(Xo),n=0;n<e;++n)i[n]=[r[n][0],-r[n][1]];var o=Vo(r),u=Vo(i),a=u[0]===o[0],c=u[u.length-1]===o[o.length-1],s=[];for(n=o.length-1;n>=0;--n)s.push(t[r[o[n]][2]]);for(n=+a;n<u.length-c;++n)s.push(t[r[u[n]][2]]);return s},t.polygonContains=function(t,n){for(var e,r,i=t.length,o=t[i-1],u=n[0],a=n[1],c=o[0],s=o[1],f=!1,l=0;l<i;++l)e=(o=t[l])[0],(r=o[1])>a!=s>a&&u<(c-e)*(a-r)/(s-r)+e&&(f=!f),c=e,s=r;return f},t.polygonLength=function(t){for(var n,e,r=-1,i=t.length,o=t[i-1],u=o[0],a=o[1],c=0;++r<i;)n=u,e=a,n-=u=(o=t[r])[0],e-=a=o[1],c+=Math.sqrt(n*n+e*e);return c},t.quadtree=we,t.queue=Qo,t.randomUniform=nv,t.randomNormal=ev,t.randomLogNormal=rv,t.randomBates=ov,t.randomIrwinHall=iv,t.randomExponential=uv,t.request=Ko,t.html=av,t.json=cv,t.text=sv,t.xml=fv,t.csv=lv,t.tsv=hv,t.scaleBand=ru,t.scalePoint=function(){return iu(ru().paddingInner(1))},t.scaleIdentity=du,t.scaleLinear=pu,t.scaleLog=wu,t.scaleOrdinal=eu,t.scaleImplicit=gv,t.scalePow=Tu,t.scaleSqrt=function(){return Tu().exponent(.5)},t.scaleQuantile=Nu,t.scaleQuantize=ku,t.scaleThreshold=Su,t.scaleTime=function(){return ja(Wv,Vv,Pv,Cv,Ev,kv,Tv,xv,t.timeFormat).domain([new Date(2e3,0,1),new Date(2e3,0,2)])},t.scaleUtc=function(){return ja(yg,gg,eg,tg,Jv,Gv,Tv,xv,t.utcFormat).domain([Date.UTC(2e3,0,1),Date.UTC(2e3,0,2)])},t.schemeCategory10=qg,t.schemeCategory20b=Dg,t.schemeCategory20c=Ug,t.schemeCategory20=Og,t.interpolateCubehelixDefault=Fg,t.interpolateRainbow=function(t){(t<0||t>1)&&(t-=Math.floor(t));var n=Math.abs(t-.5);return Bg.h=360*t-100,Bg.s=1.5-1.5*n,Bg.l=.8-.9*n,Bg+""},t.interpolateWarm=Ig,t.interpolateCool=Yg,t.interpolateViridis=Hg,t.interpolateMagma=jg,t.interpolateInferno=Xg,t.interpolatePlasma=Vg,t.scaleSequential=$a,t.creator=A,t.local=C,t.matcher=rf,t.mouse=F,t.namespace=E,t.namespaces=Js,t.clientPoint=O,t.select=lt,t.selectAll=function(t){return"string"==typeof t?new st([document.querySelectorAll(t)],[document.documentElement]):new st([null==t?[]:t],af)},t.selection=ft,t.selector=Y,t.selectorAll=H,t.style=G,t.touch=ht,t.touches=function(t,n){null==n&&(n=U().touches);for(var e=0,r=n?n.length:0,i=new Array(r);e<r;++e)i[e]=O(t,n[e]);return i},t.window=Z,t.customEvent=D,t.arc=function(){function t(){var t,s,f=+n.apply(this,arguments),l=+e.apply(this,arguments),h=o.apply(this,arguments)-e_,p=u.apply(this,arguments)-e_,d=$g(p-h),v=p>h;if(c||(c=t=te()),l<f&&(s=l,l=f,f=s),l>t_)if(d>r_-t_)c.moveTo(l*Zg(h),l*Jg(h)),c.arc(0,0,l,h,p,!v),f>t_&&(c.moveTo(f*Zg(p),f*Jg(p)),c.arc(0,0,f,p,h,v));else{var g,_,y=h,m=p,x=h,b=p,w=d,M=d,T=a.apply(this,arguments)/2,N=T>t_&&(i?+i.apply(this,arguments):Kg(f*f+l*l)),k=Qg($g(l-f)/2,+r.apply(this,arguments)),S=k,E=k;if(N>t_){var A=Za(N/f*Jg(T)),C=Za(N/l*Jg(T));(w-=2*A)>t_?(A*=v?1:-1,x+=A,b-=A):(w=0,x=b=(h+p)/2),(M-=2*C)>t_?(C*=v?1:-1,y+=C,m-=C):(M=0,y=m=(h+p)/2)}var z=l*Zg(y),P=l*Jg(y),R=f*Zg(b),L=f*Jg(b);if(k>t_){var q=l*Zg(m),D=l*Jg(m),U=f*Zg(x),O=f*Jg(x);if(d<n_){var F=w>t_?function(t,n,e,r,i,o,u,a){var c=e-t,s=r-n,f=u-i,l=a-o,h=(f*(n-o)-l*(t-i))/(l*c-f*s);return[t+h*c,n+h*s]}(z,P,U,O,q,D,R,L):[R,L],I=z-F[0],Y=P-F[1],B=q-F[0],H=D-F[1],j=1/Jg(function(t){return t>1?0:t<-1?n_:Math.acos(t)}((I*B+Y*H)/(Kg(I*I+Y*Y)*Kg(B*B+H*H)))/2),X=Kg(F[0]*F[0]+F[1]*F[1]);S=Qg(k,(f-X)/(j-1)),E=Qg(k,(l-X)/(j+1))}}M>t_?E>t_?(g=nc(U,O,z,P,l,E,v),_=nc(q,D,R,L,l,E,v),c.moveTo(g.cx+g.x01,g.cy+g.y01),E<k?c.arc(g.cx,g.cy,E,Wg(g.y01,g.x01),Wg(_.y01,_.x01),!v):(c.arc(g.cx,g.cy,E,Wg(g.y01,g.x01),Wg(g.y11,g.x11),!v),c.arc(0,0,l,Wg(g.cy+g.y11,g.cx+g.x11),Wg(_.cy+_.y11,_.cx+_.x11),!v),c.arc(_.cx,_.cy,E,Wg(_.y11,_.x11),Wg(_.y01,_.x01),!v))):(c.moveTo(z,P),c.arc(0,0,l,y,m,!v)):c.moveTo(z,P),f>t_&&w>t_?S>t_?(g=nc(R,L,q,D,f,-S,v),_=nc(z,P,U,O,f,-S,v),c.lineTo(g.cx+g.x01,g.cy+g.y01),S<k?c.arc(g.cx,g.cy,S,Wg(g.y01,g.x01),Wg(_.y01,_.x01),!v):(c.arc(g.cx,g.cy,S,Wg(g.y01,g.x01),Wg(g.y11,g.x11),!v),c.arc(0,0,f,Wg(g.cy+g.y11,g.cx+g.x11),Wg(_.cy+_.y11,_.cx+_.x11),v),c.arc(_.cx,_.cy,S,Wg(_.y11,_.x11),Wg(_.y01,_.x01),!v))):c.arc(0,0,f,b,x,v):c.lineTo(R,L)}else c.moveTo(0,0);if(c.closePath(),t)return c=null,t+""||null}var n=Ga,e=Qa,r=Wa(0),i=null,o=Ja,u=Ka,a=tc,c=null;return t.centroid=function(){var t=(+n.apply(this,arguments)+ +e.apply(this,arguments))/2,r=(+o.apply(this,arguments)+ +u.apply(this,arguments))/2-n_/2;return[Zg(r)*t,Jg(r)*t]},t.innerRadius=function(e){return arguments.length?(n="function"==typeof e?e:Wa(+e),t):n},t.outerRadius=function(n){return arguments.length?(e="function"==typeof n?n:Wa(+n),t):e},t.cornerRadius=function(n){return arguments.length?(r="function"==typeof n?n:Wa(+n),t):r},t.padRadius=function(n){return arguments.length?(i=null==n?null:"function"==typeof n?n:Wa(+n),t):i},t.startAngle=function(n){return arguments.length?(o="function"==typeof n?n:Wa(+n),t):o},t.endAngle=function(n){return arguments.length?(u="function"==typeof n?n:Wa(+n),t):u},t.padAngle=function(n){return arguments.length?(a="function"==typeof n?n:Wa(+n),t):a},t.context=function(n){return arguments.length?(c=null==n?null:n,t):c},t},t.area=ac,t.line=uc,t.pie=function(){function t(t){var a,c,s,f,l,h=t.length,p=0,d=new Array(h),v=new Array(h),g=+i.apply(this,arguments),_=Math.min(r_,Math.max(-r_,o.apply(this,arguments)-g)),y=Math.min(Math.abs(_)/h,u.apply(this,arguments)),m=y*(_<0?-1:1);for(a=0;a<h;++a)(l=v[d[a]=a]=+n(t[a],a,t))>0&&(p+=l);for(null!=e?d.sort(function(t,n){return e(v[t],v[n])}):null!=r&&d.sort(function(n,e){return r(t[n],t[e])}),a=0,s=p?(_-h*m)/p:0;a<h;++a,g=f)c=d[a],f=g+((l=v[c])>0?l*s:0)+m,v[c]={data:t[c],index:a,value:l,startAngle:g,endAngle:f,padAngle:y};return v}var n=sc,e=cc,r=null,i=Wa(0),o=Wa(r_),u=Wa(0);return t.value=function(e){return arguments.length?(n="function"==typeof e?e:Wa(+e),t):n},t.sortValues=function(n){return arguments.length?(e=n,r=null,t):e},t.sort=function(n){return arguments.length?(r=n,e=null,t):r},t.startAngle=function(n){return arguments.length?(i="function"==typeof n?n:Wa(+n),t):i},t.endAngle=function(n){return arguments.length?(o="function"==typeof n?n:Wa(+n),t):o},t.padAngle=function(n){return arguments.length?(u="function"==typeof n?n:Wa(+n),t):u},t},t.areaRadial=dc,t.radialArea=dc,t.lineRadial=pc,t.radialLine=pc,t.pointRadial=vc,t.linkHorizontal=function(){return yc(mc)},t.linkVertical=function(){return yc(xc)},t.linkRadial=function(){var t=yc(bc);return t.angle=t.x,delete t.x,t.radius=t.y,delete t.y,t},t.symbol=function(){function t(){var t;if(r||(r=t=te()),n.apply(this,arguments).draw(r,+e.apply(this,arguments)),t)return r=null,t+""||null}var n=Wa(u_),e=Wa(64),r=null;return t.type=function(e){return arguments.length?(n="function"==typeof e?e:Wa(e),t):n},t.size=function(n){return arguments.length?(e="function"==typeof n?n:Wa(+n),t):e},t.context=function(n){return arguments.length?(r=null==n?null:n,t):r},t},t.symbols=w_,t.symbolCircle=u_,t.symbolCross=a_,t.symbolDiamond=f_,t.symbolSquare=v_,t.symbolStar=d_,t.symbolTriangle=__,t.symbolWye=b_,t.curveBasisClosed=function(t){return new Nc(t)},t.curveBasisOpen=function(t){return new kc(t)},t.curveBasis=function(t){return new Tc(t)},t.curveBundle=M_,t.curveCardinalClosed=N_,t.curveCardinalOpen=k_,t.curveCardinal=T_,t.curveCatmullRomClosed=E_,t.curveCatmullRomOpen=A_,t.curveCatmullRom=S_,t.curveLinearClosed=function(t){return new Dc(t)},t.curveLinear=rc,t.curveMonotoneX=function(t){return new Yc(t)},t.curveMonotoneY=function(t){return new Bc(t)},t.curveNatural=function(t){return new jc(t)},t.curveStep=function(t){return new Vc(t,.5)},t.curveStepAfter=function(t){return new Vc(t,1)},t.curveStepBefore=function(t){return new Vc(t,0)},t.stack=function(){function t(t){var o,u,a=n.apply(this,arguments),c=t.length,s=a.length,f=new Array(s);for(o=0;o<s;++o){for(var l,h=a[o],p=f[o]=new Array(c),d=0;d<c;++d)p[d]=l=[0,+i(t[d],h,d,t)],l.data=t[d];p.key=h}for(o=0,u=e(f);o<s;++o)f[u[o]].index=o;return r(f,u),f}var n=Wa([]),e=Wc,r=$c,i=Zc;return t.keys=function(e){return arguments.length?(n="function"==typeof e?e:Wa(o_.call(e)),t):n},t.value=function(n){return arguments.length?(i="function"==typeof n?n:Wa(+n),t):i},t.order=function(n){return arguments.length?(e=null==n?Wc:"function"==typeof n?n:Wa(o_.call(n)),t):e},t.offset=function(n){return arguments.length?(r=null==n?$c:n,t):r},t},t.stackOffsetExpand=function(t,n){if((r=t.length)>0){for(var e,r,i,o=0,u=t[0].length;o<u;++o){for(i=e=0;e<r;++e)i+=t[e][o][1]||0;if(i)for(e=0;e<r;++e)t[e][o][1]/=i}$c(t,n)}},t.stackOffsetDiverging=function(t,n){if((a=t.length)>1)for(var e,r,i,o,u,a,c=0,s=t[n[0]].length;c<s;++c)for(o=u=0,e=0;e<a;++e)(i=(r=t[n[e]][c])[1]-r[0])>=0?(r[0]=o,r[1]=o+=i):i<0?(r[1]=u,r[0]=u+=i):r[0]=o},t.stackOffsetNone=$c,t.stackOffsetSilhouette=function(t,n){if((e=t.length)>0){for(var e,r=0,i=t[n[0]],o=i.length;r<o;++r){for(var u=0,a=0;u<e;++u)a+=t[u][r][1]||0;i[r][1]+=i[r][0]=-a/2}$c(t,n)}},t.stackOffsetWiggle=function(t,n){if((i=t.length)>0&&(r=(e=t[n[0]]).length)>0){for(var e,r,i,o=0,u=1;u<r;++u){for(var a=0,c=0,s=0;a<i;++a){for(var f=t[n[a]],l=f[u][1]||0,h=(l-(f[u-1][1]||0))/2,p=0;p<a;++p){var d=t[n[p]];h+=(d[u][1]||0)-(d[u-1][1]||0)}c+=l,s+=h*l}e[u-1][1]+=e[u-1][0]=o,c&&(o-=s/c)}e[u-1][1]+=e[u-1][0]=o,$c(t,n)}},t.stackOrderAscending=Gc,t.stackOrderDescending=function(t){return Gc(t).reverse()},t.stackOrderInsideOut=function(t){var n,e,r=t.length,i=t.map(Qc),o=Wc(t).sort(function(t,n){return i[n]-i[t]}),u=0,a=0,c=[],s=[];for(n=0;n<r;++n)e=o[n],u<a?(u+=i[e],c.push(e)):(a+=i[e],s.push(e));return s.reverse().concat(c)},t.stackOrderNone=Wc,t.stackOrderReverse=function(t){return Wc(t).reverse()},t.timeInterval=Eu,t.timeMillisecond=xv,t.timeMilliseconds=bv,t.utcMillisecond=xv,t.utcMilliseconds=bv,t.timeSecond=Tv,t.timeSeconds=Nv,t.utcSecond=Tv,t.utcSeconds=Nv,t.timeMinute=kv,t.timeMinutes=Sv,t.timeHour=Ev,t.timeHours=Av,t.timeDay=Cv,t.timeDays=zv,t.timeWeek=Pv,t.timeWeeks=Fv,t.timeSunday=Pv,t.timeSundays=Fv,t.timeMonday=Rv,t.timeMondays=Iv,t.timeTuesday=Lv,t.timeTuesdays=Yv,t.timeWednesday=qv,t.timeWednesdays=Bv,t.timeThursday=Dv,t.timeThursdays=Hv,t.timeFriday=Uv,t.timeFridays=jv,t.timeSaturday=Ov,t.timeSaturdays=Xv,t.timeMonth=Vv,t.timeMonths=$v,t.timeYear=Wv,t.timeYears=Zv,t.utcMinute=Gv,t.utcMinutes=Qv,t.utcHour=Jv,t.utcHours=Kv,t.utcDay=tg,t.utcDays=ng,t.utcWeek=eg,t.utcWeeks=sg,t.utcSunday=eg,t.utcSundays=sg,t.utcMonday=rg,t.utcMondays=fg,t.utcTuesday=ig,t.utcTuesdays=lg,t.utcWednesday=og,t.utcWednesdays=hg,t.utcThursday=ug,t.utcThursdays=pg,t.utcFriday=ag,t.utcFridays=dg,t.utcSaturday=cg,t.utcSaturdays=vg,t.utcMonth=gg,t.utcMonths=_g,t.utcYear=yg,t.utcYears=xg,t.timeFormatDefaultLocale=Ya,t.timeFormatLocale=Lu,t.isoFormat=kg,t.isoParse=Sg,t.now=_n,t.timer=xn,t.timerFlush=bn,t.timeout=Nn,t.interval=function(t,n,e){var r=new mn,i=n;return null==n?(r.restart(t,n,e),r):(n=+n,e=null==e?_n():+e,r.restart(function o(u){u+=i,r.restart(o,i+=n,e),t(u)},n,e),r)},t.transition=Ln,t.active=function(t,n){var e,r,i=t.__transition;if(i){n=null==n?null:n+"";for(r in i)if((e=i[r]).state>yl&&e.name===n)return new Rn([[t]],Gl,n,+r)}return null},t.interrupt=Cn,t.voronoi=function(){function t(t){return new Ms(t.map(function(r,i){var o=[Math.round(n(r,i,t)/U_)*U_,Math.round(e(r,i,t)/U_)*U_];return o.index=i,o.data=r,o}),r)}var n=Kc,e=ts,r=null;return t.polygons=function(n){return t(n).polygons()},t.links=function(n){return t(n).links()},t.triangles=function(n){return t(n).triangles()},t.x=function(e){return arguments.length?(n="function"==typeof e?e:Jc(+e),t):n},t.y=function(n){return arguments.length?(e="function"==typeof n?n:Jc(+n),t):e},t.extent=function(n){return arguments.length?(r=null==n?null:[[+n[0][0],+n[0][1]],[+n[1][0],+n[1][1]]],t):r&&[[r[0][0],r[0][1]],[r[1][0],r[1][1]]]},t.size=function(n){return arguments.length?(r=null==n?null:[[0,0],[+n[0],+n[1]]],t):r&&[r[1][0]-r[0][0],r[1][1]-r[0][1]]},t},t.zoom=function(){function n(t){t.property("__zoom",zs).on("wheel.zoom",c).on("mousedown.zoom",s).on("dblclick.zoom",f).filter(x).on("touchstart.zoom",l).on("touchmove.zoom",h).on("touchend.zoom touchcancel.zoom",p).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function e(t,n){return(n=Math.max(b[0],Math.min(b[1],n)))===t.k?t:new Ns(n,t.x,t.y)}function r(t,n,e){var r=n[0]-e[0]*t.k,i=n[1]-e[1]*t.k;return r===t.x&&i===t.y?t:new Ns(t.k,r,i)}function i(t){return[(+t[0][0]+ +t[1][0])/2,(+t[0][1]+ +t[1][1])/2]}function o(t,n,e){t.on("start.zoom",function(){u(this,arguments).start()}).on("interrupt.zoom end.zoom",function(){u(this,arguments).end()}).tween("zoom",function(){var t=arguments,r=u(this,t),o=_.apply(this,t),a=e||i(o),c=Math.max(o[1][0]-o[0][0],o[1][1]-o[0][1]),s=this.__zoom,f="function"==typeof n?n.apply(this,t):n,l=T(s.invert(a).concat(c/s.k),f.invert(a).concat(c/f.k));return function(t){if(1===t)t=f;else{var n=l(t),e=c/n[2];t=new Ns(e,a[0]-n[0]*e,a[1]-n[1]*e)}r.zoom(null,t)}})}function u(t,n){for(var e,r=0,i=k.length;r<i;++r)if((e=k[r]).that===t)return e;return new a(t,n)}function a(t,n){this.that=t,this.args=n,this.index=-1,this.active=0,this.extent=_.apply(t,n)}function c(){if(g.apply(this,arguments)){var t=u(this,arguments),n=this.__zoom,i=Math.max(b[0],Math.min(b[1],n.k*Math.pow(2,m.apply(this,arguments)))),o=F(this);if(t.wheel)t.mouse[0][0]===o[0]&&t.mouse[0][1]===o[1]||(t.mouse[1]=n.invert(t.mouse[0]=o)),clearTimeout(t.wheel);else{if(n.k===i)return;t.mouse=[o,n.invert(o)],Cn(this),t.start()}Es(),t.wheel=setTimeout(function(){t.wheel=null,t.end()},A),t.zoom("mouse",y(r(e(n,i),t.mouse[0],t.mouse[1]),t.extent,w))}}function s(){if(!v&&g.apply(this,arguments)){var n=u(this,arguments),e=lt(t.event.view).on("mousemove.zoom",function(){if(Es(),!n.moved){var e=t.event.clientX-o,i=t.event.clientY-a;n.moved=e*e+i*i>C}n.zoom("mouse",y(r(n.that.__zoom,n.mouse[0]=F(n.that),n.mouse[1]),n.extent,w))},!0).on("mouseup.zoom",function(){e.on("mousemove.zoom mouseup.zoom",null),gt(t.event.view,n.moved),Es(),n.end()},!0),i=F(this),o=t.event.clientX,a=t.event.clientY;vt(t.event.view),Ss(),n.mouse=[i,this.__zoom.invert(i)],Cn(this),n.start()}}function f(){if(g.apply(this,arguments)){var i=this.__zoom,u=F(this),a=i.invert(u),c=i.k*(t.event.shiftKey?.5:2),s=y(r(e(i,c),u,a),_.apply(this,arguments),w);Es(),M>0?lt(this).transition().duration(M).call(o,s,u):lt(this).call(n.transform,s)}}function l(){if(g.apply(this,arguments)){var n,e,r,i,o=u(this,arguments),a=t.event.changedTouches,c=a.length;for(Ss(),e=0;e<c;++e)i=[i=ht(this,a,(r=a[e]).identifier),this.__zoom.invert(i),r.identifier],o.touch0?o.touch1||(o.touch1=i):(o.touch0=i,n=!0);if(d&&(d=clearTimeout(d),!o.touch1))return o.end(),void((i=lt(this).on("dblclick.zoom"))&&i.apply(this,arguments));n&&(d=setTimeout(function(){d=null},E),Cn(this),o.start())}}function h(){var n,i,o,a,c=u(this,arguments),s=t.event.changedTouches,f=s.length;for(Es(),d&&(d=clearTimeout(d)),n=0;n<f;++n)o=ht(this,s,(i=s[n]).identifier),c.touch0&&c.touch0[2]===i.identifier?c.touch0[0]=o:c.touch1&&c.touch1[2]===i.identifier&&(c.touch1[0]=o);if(i=c.that.__zoom,c.touch1){var l=c.touch0[0],h=c.touch0[1],p=c.touch1[0],v=c.touch1[1],g=(g=p[0]-l[0])*g+(g=p[1]-l[1])*g,_=(_=v[0]-h[0])*_+(_=v[1]-h[1])*_;i=e(i,Math.sqrt(g/_)),o=[(l[0]+p[0])/2,(l[1]+p[1])/2],a=[(h[0]+v[0])/2,(h[1]+v[1])/2]}else{if(!c.touch0)return;o=c.touch0[0],a=c.touch0[1]}c.zoom("touch",y(r(i,o,a),c.extent,w))}function p(){var n,e,r=u(this,arguments),i=t.event.changedTouches,o=i.length;for(Ss(),v&&clearTimeout(v),v=setTimeout(function(){v=null},E),n=0;n<o;++n)e=i[n],r.touch0&&r.touch0[2]===e.identifier?delete r.touch0:r.touch1&&r.touch1[2]===e.identifier&&delete r.touch1;r.touch1&&!r.touch0&&(r.touch0=r.touch1,delete r.touch1),r.touch0?r.touch0[1]=this.__zoom.invert(r.touch0[0]):r.end()}var d,v,g=As,_=Cs,y=Ls,m=Ps,x=Rs,b=[0,1/0],w=[[-1/0,-1/0],[1/0,1/0]],M=250,T=pn,k=[],S=N("start","zoom","end"),E=500,A=150,C=0;return n.transform=function(t,n){var e=t.selection?t.selection():t;e.property("__zoom",zs),t!==e?o(t,n):e.interrupt().each(function(){u(this,arguments).start().zoom(null,"function"==typeof n?n.apply(this,arguments):n).end()})},n.scaleBy=function(t,e){n.scaleTo(t,function(){return this.__zoom.k*("function"==typeof e?e.apply(this,arguments):e)})},n.scaleTo=function(t,o){n.transform(t,function(){var t=_.apply(this,arguments),n=this.__zoom,u=i(t),a=n.invert(u),c="function"==typeof o?o.apply(this,arguments):o;return y(r(e(n,c),u,a),t,w)})},n.translateBy=function(t,e,r){n.transform(t,function(){return y(this.__zoom.translate("function"==typeof e?e.apply(this,arguments):e,"function"==typeof r?r.apply(this,arguments):r),_.apply(this,arguments),w)})},n.translateTo=function(t,e,r){n.transform(t,function(){var t=_.apply(this,arguments),n=this.__zoom,o=i(t);return y(F_.translate(o[0],o[1]).scale(n.k).translate("function"==typeof e?-e.apply(this,arguments):-e,"function"==typeof r?-r.apply(this,arguments):-r),t,w)})},a.prototype={start:function(){return 1==++this.active&&(this.index=k.push(this)-1,this.emit("start")),this},zoom:function(t,n){return this.mouse&&"mouse"!==t&&(this.mouse[1]=n.invert(this.mouse[0])),this.touch0&&"touch"!==t&&(this.touch0[1]=n.invert(this.touch0[0])),this.touch1&&"touch"!==t&&(this.touch1[1]=n.invert(this.touch1[0])),this.that.__zoom=n,this.emit("zoom"),this},end:function(){return 0==--this.active&&(k.splice(this.index,1),this.index=-1,this.emit("end")),this},emit:function(t){D(new function(t,n,e){this.target=t,this.type=n,this.transform=e}(n,t,this.that.__zoom),S.apply,S,[t,this.that,this.args])}},n.wheelDelta=function(t){return arguments.length?(m="function"==typeof t?t:Ts(+t),n):m},n.filter=function(t){return arguments.length?(g="function"==typeof t?t:Ts(!!t),n):g},n.touchable=function(t){return arguments.length?(x="function"==typeof t?t:Ts(!!t),n):x},n.extent=function(t){return arguments.length?(_="function"==typeof t?t:Ts([[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]]),n):_},n.scaleExtent=function(t){return arguments.length?(b[0]=+t[0],b[1]=+t[1],n):[b[0],b[1]]},n.translateExtent=function(t){return arguments.length?(w[0][0]=+t[0][0],w[1][0]=+t[1][0],w[0][1]=+t[0][1],w[1][1]=+t[1][1],n):[[w[0][0],w[0][1]],[w[1][0],w[1][1]]]},n.constrain=function(t){return arguments.length?(y=t,n):y},n.duration=function(t){return arguments.length?(M=+t,n):M},n.interpolate=function(t){return arguments.length?(T=t,n):T},n.on=function(){var t=S.on.apply(S,arguments);return t===S?n:t},n.clickDistance=function(t){return arguments.length?(C=(t=+t)*t,n):Math.sqrt(C)},n},t.zoomTransform=ks,t.zoomIdentity=F_,Object.defineProperty(t,"__esModule",{value:!0})});
},{}],"myModule":[function(require,module,exports){
exports.myVar = "myVariable";

exports.myFunction = function() {
  return print("myFunction is running");
};

exports.myArray = [1, 2, 3];


},{}]},{},[])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWVyLm1vZHVsZXMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL1VzZXJzL1BoaWxpbmUgU2NoZWxsL0RvY3VtZW50cy9TdHVkaXVtL0hUVy9iZXJsaW5lcmx1ZnQvYmVybGluZXJsdWZ0X2xpZ2h0LmZyYW1lci9tb2R1bGVzL215TW9kdWxlLmNvZmZlZSIsIi4uLy4uLy4uLy4uLy4uL1VzZXJzL1BoaWxpbmUgU2NoZWxsL0RvY3VtZW50cy9TdHVkaXVtL0hUVy9iZXJsaW5lcmx1ZnQvYmVybGluZXJsdWZ0X2xpZ2h0LmZyYW1lci9tb2R1bGVzL2QzLm1pbi5qcyIsIi4uLy4uLy4uLy4uLy4uL1VzZXJzL1BoaWxpbmUgU2NoZWxsL0RvY3VtZW50cy9TdHVkaXVtL0hUVy9iZXJsaW5lcmx1ZnQvYmVybGluZXJsdWZ0X2xpZ2h0LmZyYW1lci9tb2R1bGVzL1RleHRMYXllci5jb2ZmZWUiLCIuLi8uLi8uLi8uLi8uLi9Vc2Vycy9QaGlsaW5lIFNjaGVsbC9Eb2N1bWVudHMvU3R1ZGl1bS9IVFcvYmVybGluZXJsdWZ0L2JlcmxpbmVybHVmdF9saWdodC5mcmFtZXIvbW9kdWxlcy9USFJFRS1yNzIuanMiLCIuLi8uLi8uLi8uLi8uLi9Vc2Vycy9QaGlsaW5lIFNjaGVsbC9Eb2N1bWVudHMvU3R1ZGl1bS9IVFcvYmVybGluZXJsdWZ0L2JlcmxpbmVybHVmdF9saWdodC5mcmFtZXIvbW9kdWxlcy9TUEUubWluLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIjIEFkZCB0aGUgZm9sbG93aW5nIGxpbmUgdG8geW91ciBwcm9qZWN0IGluIEZyYW1lciBTdHVkaW8uIFxuIyBteU1vZHVsZSA9IHJlcXVpcmUgXCJteU1vZHVsZVwiXG4jIFJlZmVyZW5jZSB0aGUgY29udGVudHMgYnkgbmFtZSwgbGlrZSBteU1vZHVsZS5teUZ1bmN0aW9uKCkgb3IgbXlNb2R1bGUubXlWYXJcblxuZXhwb3J0cy5teVZhciA9IFwibXlWYXJpYWJsZVwiXG5cbmV4cG9ydHMubXlGdW5jdGlvbiA9IC0+XG5cdHByaW50IFwibXlGdW5jdGlvbiBpcyBydW5uaW5nXCJcblxuZXhwb3J0cy5teUFycmF5ID0gWzEsIDIsIDNdIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZyBWZXJzaW9uIDQuMTIuMi4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bihleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sbik6bih0LmQzPXQuZDN8fHt9KX0pKHRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LG4pe3JldHVybiB0PG4/LTE6dD5uPzE6dD49bj8wOk5hTn1mdW5jdGlvbiBlKHQpe3JldHVybiAxPT09dC5sZW5ndGgmJih0PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIpe3JldHVybiBuKHQoZSkscil9fSh0KSkse2xlZnQ6ZnVuY3Rpb24obixlLHIsaSl7Zm9yKG51bGw9PXImJihyPTApLG51bGw9PWkmJihpPW4ubGVuZ3RoKTtyPGk7KXt2YXIgbz1yK2k+Pj4xO3QobltvXSxlKTwwP3I9bysxOmk9b31yZXR1cm4gcn0scmlnaHQ6ZnVuY3Rpb24obixlLHIsaSl7Zm9yKG51bGw9PXImJihyPTApLG51bGw9PWkmJihpPW4ubGVuZ3RoKTtyPGk7KXt2YXIgbz1yK2k+Pj4xO3QobltvXSxlKT4wP2k9bzpyPW8rMX1yZXR1cm4gcn19fWZ1bmN0aW9uIHIodCxuKXtyZXR1cm5bdCxuXX1mdW5jdGlvbiBpKHQpe3JldHVybiBudWxsPT09dD9OYU46K3R9ZnVuY3Rpb24gbyh0LG4pe3ZhciBlLHIsbz10Lmxlbmd0aCx1PTAsYT0tMSxjPTAscz0wO2lmKG51bGw9PW4pZm9yKDsrK2E8bzspaXNOYU4oZT1pKHRbYV0pKXx8KHMrPShyPWUtYykqKGUtKGMrPXIvKyt1KSkpO2Vsc2UgZm9yKDsrK2E8bzspaXNOYU4oZT1pKG4odFthXSxhLHQpKSl8fChzKz0ocj1lLWMpKihlLShjKz1yLysrdSkpKTtpZih1PjEpcmV0dXJuIHMvKHUtMSl9ZnVuY3Rpb24gdSh0LG4pe3ZhciBlPW8odCxuKTtyZXR1cm4gZT9NYXRoLnNxcnQoZSk6ZX1mdW5jdGlvbiBhKHQsbil7dmFyIGUscixpLG89dC5sZW5ndGgsdT0tMTtpZihudWxsPT1uKXtmb3IoOysrdTxvOylpZihudWxsIT0oZT10W3VdKSYmZT49ZSlmb3Iocj1pPWU7Kyt1PG87KW51bGwhPShlPXRbdV0pJiYocj5lJiYocj1lKSxpPGUmJihpPWUpKX1lbHNlIGZvcig7Kyt1PG87KWlmKG51bGwhPShlPW4odFt1XSx1LHQpKSYmZT49ZSlmb3Iocj1pPWU7Kyt1PG87KW51bGwhPShlPW4odFt1XSx1LHQpKSYmKHI+ZSYmKHI9ZSksaTxlJiYoaT1lKSk7cmV0dXJuW3IsaV19ZnVuY3Rpb24gYyh0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdH19ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdH1mdW5jdGlvbiBmKHQsbixlKXt0PSt0LG49K24sZT0oaT1hcmd1bWVudHMubGVuZ3RoKTwyPyhuPXQsdD0wLDEpOmk8Mz8xOitlO2Zvcih2YXIgcj0tMSxpPTB8TWF0aC5tYXgoMCxNYXRoLmNlaWwoKG4tdCkvZSkpLG89bmV3IEFycmF5KGkpOysrcjxpOylvW3JdPXQrciplO3JldHVybiBvfWZ1bmN0aW9uIGwodCxuLGUpe3ZhciByLGksbyx1LGE9LTE7aWYobj0rbix0PSt0LGU9K2UsdD09PW4mJmU+MClyZXR1cm5bdF07aWYoKHI9bjx0KSYmKGk9dCx0PW4sbj1pKSwwPT09KHU9aCh0LG4sZSkpfHwhaXNGaW5pdGUodSkpcmV0dXJuW107aWYodT4wKWZvcih0PU1hdGguY2VpbCh0L3UpLG49TWF0aC5mbG9vcihuL3UpLG89bmV3IEFycmF5KGk9TWF0aC5jZWlsKG4tdCsxKSk7KythPGk7KW9bYV09KHQrYSkqdTtlbHNlIGZvcih0PU1hdGguZmxvb3IodCp1KSxuPU1hdGguY2VpbChuKnUpLG89bmV3IEFycmF5KGk9TWF0aC5jZWlsKHQtbisxKSk7KythPGk7KW9bYV09KHQtYSkvdTtyZXR1cm4gciYmby5yZXZlcnNlKCksb31mdW5jdGlvbiBoKHQsbixlKXt2YXIgcj0obi10KS9NYXRoLm1heCgwLGUpLGk9TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMTApLG89ci9NYXRoLnBvdygxMCxpKTtyZXR1cm4gaT49MD8obz49WXM/MTA6bz49QnM/NTpvPj1Icz8yOjEpKk1hdGgucG93KDEwLGkpOi1NYXRoLnBvdygxMCwtaSkvKG8+PVlzPzEwOm8+PUJzPzU6bz49SHM/MjoxKX1mdW5jdGlvbiBwKHQsbixlKXt2YXIgcj1NYXRoLmFicyhuLXQpL01hdGgubWF4KDAsZSksaT1NYXRoLnBvdygxMCxNYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4xMCkpLG89ci9pO3JldHVybiBvPj1Zcz9pKj0xMDpvPj1Ccz9pKj01Om8+PUhzJiYoaSo9Miksbjx0Py1pOml9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHQubGVuZ3RoKS9NYXRoLkxOMikrMX1mdW5jdGlvbiB2KHQsbixlKXtpZihudWxsPT1lJiYoZT1pKSxyPXQubGVuZ3RoKXtpZigobj0rbik8PTB8fHI8MilyZXR1cm4rZSh0WzBdLDAsdCk7aWYobj49MSlyZXR1cm4rZSh0W3ItMV0sci0xLHQpO3ZhciByLG89KHItMSkqbix1PU1hdGguZmxvb3IobyksYT0rZSh0W3VdLHUsdCk7cmV0dXJuIGErKCtlKHRbdSsxXSx1KzEsdCktYSkqKG8tdSl9fWZ1bmN0aW9uIGcodCl7Zm9yKHZhciBuLGUscixpPXQubGVuZ3RoLG89LTEsdT0wOysrbzxpOyl1Kz10W29dLmxlbmd0aDtmb3IoZT1uZXcgQXJyYXkodSk7LS1pPj0wOylmb3Iobj0ocj10W2ldKS5sZW5ndGg7LS1uPj0wOyllWy0tdV09cltuXTtyZXR1cm4gZX1mdW5jdGlvbiBfKHQsbil7dmFyIGUscixpPXQubGVuZ3RoLG89LTE7aWYobnVsbD09bil7Zm9yKDsrK288aTspaWYobnVsbCE9KGU9dFtvXSkmJmU+PWUpZm9yKHI9ZTsrK288aTspbnVsbCE9KGU9dFtvXSkmJnI+ZSYmKHI9ZSl9ZWxzZSBmb3IoOysrbzxpOylpZihudWxsIT0oZT1uKHRbb10sbyx0KSkmJmU+PWUpZm9yKHI9ZTsrK288aTspbnVsbCE9KGU9bih0W29dLG8sdCkpJiZyPmUmJihyPWUpO3JldHVybiByfWZ1bmN0aW9uIHkodCl7aWYoIShpPXQubGVuZ3RoKSlyZXR1cm5bXTtmb3IodmFyIG49LTEsZT1fKHQsbSkscj1uZXcgQXJyYXkoZSk7KytuPGU7KWZvcih2YXIgaSxvPS0xLHU9cltuXT1uZXcgQXJyYXkoaSk7KytvPGk7KXVbb109dFtvXVtuXTtyZXR1cm4gcn1mdW5jdGlvbiBtKHQpe3JldHVybiB0Lmxlbmd0aH1mdW5jdGlvbiB4KHQpe3JldHVybiB0fWZ1bmN0aW9uIGIodCl7cmV0dXJuXCJ0cmFuc2xhdGUoXCIrKHQrLjUpK1wiLDApXCJ9ZnVuY3Rpb24gdyh0KXtyZXR1cm5cInRyYW5zbGF0ZSgwLFwiKyh0Ky41KStcIilcIn1mdW5jdGlvbiBNKCl7cmV0dXJuIXRoaXMuX19heGlzfWZ1bmN0aW9uIFQodCxuKXtmdW5jdGlvbiBlKGUpe3ZhciBoPW51bGw9PWk/bi50aWNrcz9uLnRpY2tzLmFwcGx5KG4scik6bi5kb21haW4oKTppLHA9bnVsbD09bz9uLnRpY2tGb3JtYXQ/bi50aWNrRm9ybWF0LmFwcGx5KG4scik6eDpvLGQ9TWF0aC5tYXgodSwwKStjLHY9bi5yYW5nZSgpLGc9K3ZbMF0rLjUsXz0rdlt2Lmxlbmd0aC0xXSsuNSx5PShuLmJhbmR3aWR0aD9mdW5jdGlvbih0KXt2YXIgbj1NYXRoLm1heCgwLHQuYmFuZHdpZHRoKCktMSkvMjtyZXR1cm4gdC5yb3VuZCgpJiYobj1NYXRoLnJvdW5kKG4pKSxmdW5jdGlvbihlKXtyZXR1cm4rdChlKStufX06ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybit0KG4pfX0pKG4uY29weSgpKSxtPWUuc2VsZWN0aW9uP2Uuc2VsZWN0aW9uKCk6ZSxiPW0uc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFtudWxsXSksdz1tLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEoaCxuKS5vcmRlcigpLFQ9dy5leGl0KCksTj13LmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIixcInRpY2tcIiksaz13LnNlbGVjdChcImxpbmVcIiksUz13LnNlbGVjdChcInRleHRcIik7Yj1iLm1lcmdlKGIuZW50ZXIoKS5pbnNlcnQoXCJwYXRoXCIsXCIudGlja1wiKS5hdHRyKFwiY2xhc3NcIixcImRvbWFpblwiKS5hdHRyKFwic3Ryb2tlXCIsXCIjMDAwXCIpKSx3PXcubWVyZ2UoTiksaz1rLm1lcmdlKE4uYXBwZW5kKFwibGluZVwiKS5hdHRyKFwic3Ryb2tlXCIsXCIjMDAwXCIpLmF0dHIoZitcIjJcIixzKnUpKSxTPVMubWVyZ2UoTi5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJmaWxsXCIsXCIjMDAwXCIpLmF0dHIoZixzKmQpLmF0dHIoXCJkeVwiLHQ9PT1Ycz9cIjBlbVwiOnQ9PT0kcz9cIjAuNzFlbVwiOlwiMC4zMmVtXCIpKSxlIT09bSYmKGI9Yi50cmFuc2l0aW9uKGUpLHc9dy50cmFuc2l0aW9uKGUpLGs9ay50cmFuc2l0aW9uKGUpLFM9Uy50cmFuc2l0aW9uKGUpLFQ9VC50cmFuc2l0aW9uKGUpLmF0dHIoXCJvcGFjaXR5XCIsWnMpLmF0dHIoXCJ0cmFuc2Zvcm1cIixmdW5jdGlvbih0KXtyZXR1cm4gaXNGaW5pdGUodD15KHQpKT9sKHQpOnRoaXMuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpfSksTi5hdHRyKFwib3BhY2l0eVwiLFpzKS5hdHRyKFwidHJhbnNmb3JtXCIsZnVuY3Rpb24odCl7dmFyIG49dGhpcy5wYXJlbnROb2RlLl9fYXhpcztyZXR1cm4gbChuJiZpc0Zpbml0ZShuPW4odCkpP246eSh0KSl9KSksVC5yZW1vdmUoKSxiLmF0dHIoXCJkXCIsdD09PVdzfHx0PT1Wcz9cIk1cIitzKmErXCIsXCIrZytcIkgwLjVWXCIrXytcIkhcIitzKmE6XCJNXCIrZytcIixcIitzKmErXCJWMC41SFwiK18rXCJWXCIrcyphKSx3LmF0dHIoXCJvcGFjaXR5XCIsMSkuYXR0cihcInRyYW5zZm9ybVwiLGZ1bmN0aW9uKHQpe3JldHVybiBsKHkodCkpfSksay5hdHRyKGYrXCIyXCIscyp1KSxTLmF0dHIoZixzKmQpLnRleHQocCksbS5maWx0ZXIoTSkuYXR0cihcImZpbGxcIixcIm5vbmVcIikuYXR0cihcImZvbnQtc2l6ZVwiLDEwKS5hdHRyKFwiZm9udC1mYW1pbHlcIixcInNhbnMtc2VyaWZcIikuYXR0cihcInRleHQtYW5jaG9yXCIsdD09PVZzP1wic3RhcnRcIjp0PT09V3M/XCJlbmRcIjpcIm1pZGRsZVwiKSxtLmVhY2goZnVuY3Rpb24oKXt0aGlzLl9fYXhpcz15fSl9dmFyIHI9W10saT1udWxsLG89bnVsbCx1PTYsYT02LGM9MyxzPXQ9PT1Yc3x8dD09PVdzPy0xOjEsZj10PT09V3N8fHQ9PT1Wcz9cInhcIjpcInlcIixsPXQ9PT1Yc3x8dD09PSRzP2I6dztyZXR1cm4gZS5zY2FsZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obj10LGUpOm59LGUudGlja3M9ZnVuY3Rpb24oKXtyZXR1cm4gcj1qcy5jYWxsKGFyZ3VtZW50cyksZX0sZS50aWNrQXJndW1lbnRzPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhyPW51bGw9PXQ/W106anMuY2FsbCh0KSxlKTpyLnNsaWNlKCl9LGUudGlja1ZhbHVlcz1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT1udWxsPT10P251bGw6anMuY2FsbCh0KSxlKTppJiZpLnNsaWNlKCl9LGUudGlja0Zvcm1hdD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obz10LGUpOm99LGUudGlja1NpemU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHU9YT0rdCxlKTp1fSxlLnRpY2tTaXplSW5uZXI9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHU9K3QsZSk6dX0sZS50aWNrU2l6ZU91dGVyPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhhPSt0LGUpOmF9LGUudGlja1BhZGRpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGM9K3QsZSk6Y30sZX1mdW5jdGlvbiBOKCl7Zm9yKHZhciB0LG49MCxlPWFyZ3VtZW50cy5sZW5ndGgscj17fTtuPGU7KytuKXtpZighKHQ9YXJndW1lbnRzW25dK1wiXCIpfHx0IGluIHIpdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIit0KTtyW3RdPVtdfXJldHVybiBuZXcgayhyKX1mdW5jdGlvbiBrKHQpe3RoaXMuXz10fWZ1bmN0aW9uIFModCxuLGUpe2Zvcih2YXIgcj0wLGk9dC5sZW5ndGg7cjxpOysrcilpZih0W3JdLm5hbWU9PT1uKXt0W3JdPUdzLHQ9dC5zbGljZSgwLHIpLmNvbmNhdCh0LnNsaWNlKHIrMSkpO2JyZWFrfXJldHVybiBudWxsIT1lJiZ0LnB1c2goe25hbWU6bix2YWx1ZTplfSksdH1mdW5jdGlvbiBFKHQpe3ZhciBuPXQrPVwiXCIsZT1uLmluZGV4T2YoXCI6XCIpO3JldHVybiBlPj0wJiZcInhtbG5zXCIhPT0obj10LnNsaWNlKDAsZSkpJiYodD10LnNsaWNlKGUrMSkpLEpzLmhhc093blByb3BlcnR5KG4pP3tzcGFjZTpKc1tuXSxsb2NhbDp0fTp0fWZ1bmN0aW9uIEEodCl7dmFyIG49RSh0KTtyZXR1cm4obi5sb2NhbD9mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0LnNwYWNlLHQubG9jYWwpfX06ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpcy5vd25lckRvY3VtZW50LGU9dGhpcy5uYW1lc3BhY2VVUkk7cmV0dXJuIGU9PT1RcyYmbi5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJPT09UXM/bi5jcmVhdGVFbGVtZW50KHQpOm4uY3JlYXRlRWxlbWVudE5TKGUsdCl9fSkobil9ZnVuY3Rpb24gQygpe3JldHVybiBuZXcgen1mdW5jdGlvbiB6KCl7dGhpcy5fPVwiQFwiKygrK0tzKS50b1N0cmluZygzNil9ZnVuY3Rpb24gUCh0LG4sZSl7cmV0dXJuIHQ9Uih0LG4sZSksZnVuY3Rpb24obil7dmFyIGU9bi5yZWxhdGVkVGFyZ2V0O2UmJihlPT09dGhpc3x8OCZlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpKXx8dC5jYWxsKHRoaXMsbil9fWZ1bmN0aW9uIFIobixlLHIpe3JldHVybiBmdW5jdGlvbihpKXt2YXIgbz10LmV2ZW50O3QuZXZlbnQ9aTt0cnl7bi5jYWxsKHRoaXMsdGhpcy5fX2RhdGFfXyxlLHIpfWZpbmFsbHl7dC5ldmVudD1vfX19ZnVuY3Rpb24gTCh0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9fb247aWYobil7Zm9yKHZhciBlLHI9MCxpPS0xLG89bi5sZW5ndGg7cjxvOysrcillPW5bcl0sdC50eXBlJiZlLnR5cGUhPT10LnR5cGV8fGUubmFtZSE9PXQubmFtZT9uWysraV09ZTp0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZS50eXBlLGUubGlzdGVuZXIsZS5jYXB0dXJlKTsrK2k/bi5sZW5ndGg9aTpkZWxldGUgdGhpcy5fX29ufX19ZnVuY3Rpb24gcSh0LG4sZSl7dmFyIHI9b2YuaGFzT3duUHJvcGVydHkodC50eXBlKT9QOlI7cmV0dXJuIGZ1bmN0aW9uKGksbyx1KXt2YXIgYSxjPXRoaXMuX19vbixzPXIobixvLHUpO2lmKGMpZm9yKHZhciBmPTAsbD1jLmxlbmd0aDtmPGw7KytmKWlmKChhPWNbZl0pLnR5cGU9PT10LnR5cGUmJmEubmFtZT09PXQubmFtZSlyZXR1cm4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGEudHlwZSxhLmxpc3RlbmVyLGEuY2FwdHVyZSksdGhpcy5hZGRFdmVudExpc3RlbmVyKGEudHlwZSxhLmxpc3RlbmVyPXMsYS5jYXB0dXJlPWUpLHZvaWQoYS52YWx1ZT1uKTt0aGlzLmFkZEV2ZW50TGlzdGVuZXIodC50eXBlLHMsZSksYT17dHlwZTp0LnR5cGUsbmFtZTp0Lm5hbWUsdmFsdWU6bixsaXN0ZW5lcjpzLGNhcHR1cmU6ZX0sYz9jLnB1c2goYSk6dGhpcy5fX29uPVthXX19ZnVuY3Rpb24gRChuLGUscixpKXt2YXIgbz10LmV2ZW50O24uc291cmNlRXZlbnQ9dC5ldmVudCx0LmV2ZW50PW47dHJ5e3JldHVybiBlLmFwcGx5KHIsaSl9ZmluYWxseXt0LmV2ZW50PW99fWZ1bmN0aW9uIFUoKXtmb3IodmFyIG4sZT10LmV2ZW50O249ZS5zb3VyY2VFdmVudDspZT1uO3JldHVybiBlfWZ1bmN0aW9uIE8odCxuKXt2YXIgZT10Lm93bmVyU1ZHRWxlbWVudHx8dDtpZihlLmNyZWF0ZVNWR1BvaW50KXt2YXIgcj1lLmNyZWF0ZVNWR1BvaW50KCk7cmV0dXJuIHIueD1uLmNsaWVudFgsci55PW4uY2xpZW50WSxyPXIubWF0cml4VHJhbnNmb3JtKHQuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKSxbci54LHIueV19dmFyIGk9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm5bbi5jbGllbnRYLWkubGVmdC10LmNsaWVudExlZnQsbi5jbGllbnRZLWkudG9wLXQuY2xpZW50VG9wXX1mdW5jdGlvbiBGKHQpe3ZhciBuPVUoKTtyZXR1cm4gbi5jaGFuZ2VkVG91Y2hlcyYmKG49bi5jaGFuZ2VkVG91Y2hlc1swXSksTyh0LG4pfWZ1bmN0aW9uIEkoKXt9ZnVuY3Rpb24gWSh0KXtyZXR1cm4gbnVsbD09dD9JOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcih0KX19ZnVuY3Rpb24gQigpe3JldHVybltdfWZ1bmN0aW9uIEgodCl7cmV0dXJuIG51bGw9PXQ/QjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwodCl9fWZ1bmN0aW9uIGoodCl7cmV0dXJuIG5ldyBBcnJheSh0Lmxlbmd0aCl9ZnVuY3Rpb24gWCh0LG4pe3RoaXMub3duZXJEb2N1bWVudD10Lm93bmVyRG9jdW1lbnQsdGhpcy5uYW1lc3BhY2VVUkk9dC5uYW1lc3BhY2VVUkksdGhpcy5fbmV4dD1udWxsLHRoaXMuX3BhcmVudD10LHRoaXMuX19kYXRhX189bn1mdW5jdGlvbiBWKHQsbixlLHIsaSxvKXtmb3IodmFyIHUsYT0wLGM9bi5sZW5ndGgscz1vLmxlbmd0aDthPHM7KythKSh1PW5bYV0pPyh1Ll9fZGF0YV9fPW9bYV0sclthXT11KTplW2FdPW5ldyBYKHQsb1thXSk7Zm9yKDthPGM7KythKSh1PW5bYV0pJiYoaVthXT11KX1mdW5jdGlvbiAkKHQsbixlLHIsaSxvLHUpe3ZhciBhLGMscyxmPXt9LGw9bi5sZW5ndGgsaD1vLmxlbmd0aCxwPW5ldyBBcnJheShsKTtmb3IoYT0wO2E8bDsrK2EpKGM9blthXSkmJihwW2FdPXM9dWYrdS5jYWxsKGMsYy5fX2RhdGFfXyxhLG4pLHMgaW4gZj9pW2FdPWM6ZltzXT1jKTtmb3IoYT0wO2E8aDsrK2EpKGM9ZltzPXVmK3UuY2FsbCh0LG9bYV0sYSxvKV0pPyhyW2FdPWMsYy5fX2RhdGFfXz1vW2FdLGZbc109bnVsbCk6ZVthXT1uZXcgWCh0LG9bYV0pO2ZvcihhPTA7YTxsOysrYSkoYz1uW2FdKSYmZltwW2FdXT09PWMmJihpW2FdPWMpfWZ1bmN0aW9uIFcodCxuKXtyZXR1cm4gdDxuPy0xOnQ+bj8xOnQ+PW4/MDpOYU59ZnVuY3Rpb24gWih0KXtyZXR1cm4gdC5vd25lckRvY3VtZW50JiZ0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHQuZG9jdW1lbnQmJnR8fHQuZGVmYXVsdFZpZXd9ZnVuY3Rpb24gRyh0LG4pe3JldHVybiB0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUobil8fFoodCkuZ2V0Q29tcHV0ZWRTdHlsZSh0LG51bGwpLmdldFByb3BlcnR5VmFsdWUobil9ZnVuY3Rpb24gUSh0KXtyZXR1cm4gdC50cmltKCkuc3BsaXQoL158XFxzKy8pfWZ1bmN0aW9uIEoodCl7cmV0dXJuIHQuY2xhc3NMaXN0fHxuZXcgSyh0KX1mdW5jdGlvbiBLKHQpe3RoaXMuX25vZGU9dCx0aGlzLl9uYW1lcz1RKHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIpfWZ1bmN0aW9uIHR0KHQsbil7Zm9yKHZhciBlPUoodCkscj0tMSxpPW4ubGVuZ3RoOysrcjxpOyllLmFkZChuW3JdKX1mdW5jdGlvbiBudCh0LG4pe2Zvcih2YXIgZT1KKHQpLHI9LTEsaT1uLmxlbmd0aDsrK3I8aTspZS5yZW1vdmUobltyXSl9ZnVuY3Rpb24gZXQoKXt0aGlzLnRleHRDb250ZW50PVwiXCJ9ZnVuY3Rpb24gcnQoKXt0aGlzLmlubmVySFRNTD1cIlwifWZ1bmN0aW9uIGl0KCl7dGhpcy5uZXh0U2libGluZyYmdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpfWZ1bmN0aW9uIG90KCl7dGhpcy5wcmV2aW91c1NpYmxpbmcmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcyx0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCl9ZnVuY3Rpb24gdXQoKXtyZXR1cm4gbnVsbH1mdW5jdGlvbiBhdCgpe3ZhciB0PXRoaXMucGFyZW50Tm9kZTt0JiZ0LnJlbW92ZUNoaWxkKHRoaXMpfWZ1bmN0aW9uIGN0KHQsbixlKXt2YXIgcj1aKHQpLGk9ci5DdXN0b21FdmVudDtcImZ1bmN0aW9uXCI9PXR5cGVvZiBpP2k9bmV3IGkobixlKTooaT1yLmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIiksZT8oaS5pbml0RXZlbnQobixlLmJ1YmJsZXMsZS5jYW5jZWxhYmxlKSxpLmRldGFpbD1lLmRldGFpbCk6aS5pbml0RXZlbnQobiwhMSwhMSkpLHQuZGlzcGF0Y2hFdmVudChpKX1mdW5jdGlvbiBzdCh0LG4pe3RoaXMuX2dyb3Vwcz10LHRoaXMuX3BhcmVudHM9bn1mdW5jdGlvbiBmdCgpe3JldHVybiBuZXcgc3QoW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSxhZil9ZnVuY3Rpb24gbHQodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/bmV3IHN0KFtbZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KV1dLFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKTpuZXcgc3QoW1t0XV0sYWYpfWZ1bmN0aW9uIGh0KHQsbixlKXthcmd1bWVudHMubGVuZ3RoPDMmJihlPW4sbj1VKCkuY2hhbmdlZFRvdWNoZXMpO2Zvcih2YXIgcixpPTAsbz1uP24ubGVuZ3RoOjA7aTxvOysraSlpZigocj1uW2ldKS5pZGVudGlmaWVyPT09ZSlyZXR1cm4gTyh0LHIpO3JldHVybiBudWxsfWZ1bmN0aW9uIHB0KCl7dC5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX1mdW5jdGlvbiBkdCgpe3QuZXZlbnQucHJldmVudERlZmF1bHQoKSx0LmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfWZ1bmN0aW9uIHZ0KHQpe3ZhciBuPXQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGU9bHQodCkub24oXCJkcmFnc3RhcnQuZHJhZ1wiLGR0LCEwKTtcIm9uc2VsZWN0c3RhcnRcImluIG4/ZS5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIixkdCwhMCk6KG4uX19ub3NlbGVjdD1uLnN0eWxlLk1velVzZXJTZWxlY3Qsbi5zdHlsZS5Nb3pVc2VyU2VsZWN0PVwibm9uZVwiKX1mdW5jdGlvbiBndCh0LG4pe3ZhciBlPXQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHI9bHQodCkub24oXCJkcmFnc3RhcnQuZHJhZ1wiLG51bGwpO24mJihyLm9uKFwiY2xpY2suZHJhZ1wiLGR0LCEwKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ci5vbihcImNsaWNrLmRyYWdcIixudWxsKX0sMCkpLFwib25zZWxlY3RzdGFydFwiaW4gZT9yLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLG51bGwpOihlLnN0eWxlLk1velVzZXJTZWxlY3Q9ZS5fX25vc2VsZWN0LGRlbGV0ZSBlLl9fbm9zZWxlY3QpfWZ1bmN0aW9uIF90KHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX1mdW5jdGlvbiB5dCh0LG4sZSxyLGksbyx1LGEsYyxzKXt0aGlzLnRhcmdldD10LHRoaXMudHlwZT1uLHRoaXMuc3ViamVjdD1lLHRoaXMuaWRlbnRpZmllcj1yLHRoaXMuYWN0aXZlPWksdGhpcy54PW8sdGhpcy55PXUsdGhpcy5keD1hLHRoaXMuZHk9Yyx0aGlzLl89c31mdW5jdGlvbiBtdCgpe3JldHVybiF0LmV2ZW50LmJ1dHRvbn1mdW5jdGlvbiB4dCgpe3JldHVybiB0aGlzLnBhcmVudE5vZGV9ZnVuY3Rpb24gYnQobil7cmV0dXJuIG51bGw9PW4/e3g6dC5ldmVudC54LHk6dC5ldmVudC55fTpufWZ1bmN0aW9uIHd0KCl7cmV0dXJuXCJvbnRvdWNoc3RhcnRcImluIHRoaXN9ZnVuY3Rpb24gTXQodCxuLGUpe3QucHJvdG90eXBlPW4ucHJvdG90eXBlPWUsZS5jb25zdHJ1Y3Rvcj10fWZ1bmN0aW9uIFR0KHQsbil7dmFyIGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSk7Zm9yKHZhciByIGluIG4pZVtyXT1uW3JdO3JldHVybiBlfWZ1bmN0aW9uIE50KCl7fWZ1bmN0aW9uIGt0KHQpe3ZhciBuO3JldHVybiB0PSh0K1wiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLChuPWxmLmV4ZWModCkpPyhuPXBhcnNlSW50KG5bMV0sMTYpLG5ldyB6dChuPj44JjE1fG4+PjQmMjQwLG4+PjQmMTV8MjQwJm4sKDE1Jm4pPDw0fDE1Jm4sMSkpOihuPWhmLmV4ZWModCkpP1N0KHBhcnNlSW50KG5bMV0sMTYpKToobj1wZi5leGVjKHQpKT9uZXcgenQoblsxXSxuWzJdLG5bM10sMSk6KG49ZGYuZXhlYyh0KSk/bmV3IHp0KDI1NSpuWzFdLzEwMCwyNTUqblsyXS8xMDAsMjU1Km5bM10vMTAwLDEpOihuPXZmLmV4ZWModCkpP0V0KG5bMV0sblsyXSxuWzNdLG5bNF0pOihuPWdmLmV4ZWModCkpP0V0KDI1NSpuWzFdLzEwMCwyNTUqblsyXS8xMDAsMjU1Km5bM10vMTAwLG5bNF0pOihuPV9mLmV4ZWModCkpP1B0KG5bMV0sblsyXS8xMDAsblszXS8xMDAsMSk6KG49eWYuZXhlYyh0KSk/UHQoblsxXSxuWzJdLzEwMCxuWzNdLzEwMCxuWzRdKTptZi5oYXNPd25Qcm9wZXJ0eSh0KT9TdChtZlt0XSk6XCJ0cmFuc3BhcmVudFwiPT09dD9uZXcgenQoTmFOLE5hTixOYU4sMCk6bnVsbH1mdW5jdGlvbiBTdCh0KXtyZXR1cm4gbmV3IHp0KHQ+PjE2JjI1NSx0Pj44JjI1NSwyNTUmdCwxKX1mdW5jdGlvbiBFdCh0LG4sZSxyKXtyZXR1cm4gcjw9MCYmKHQ9bj1lPU5hTiksbmV3IHp0KHQsbixlLHIpfWZ1bmN0aW9uIEF0KHQpe3JldHVybiB0IGluc3RhbmNlb2YgTnR8fCh0PWt0KHQpKSx0Pyh0PXQucmdiKCksbmV3IHp0KHQucix0LmcsdC5iLHQub3BhY2l0eSkpOm5ldyB6dH1mdW5jdGlvbiBDdCh0LG4sZSxyKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/QXQodCk6bmV3IHp0KHQsbixlLG51bGw9PXI/MTpyKX1mdW5jdGlvbiB6dCh0LG4sZSxyKXt0aGlzLnI9K3QsdGhpcy5nPStuLHRoaXMuYj0rZSx0aGlzLm9wYWNpdHk9K3J9ZnVuY3Rpb24gUHQodCxuLGUscil7cmV0dXJuIHI8PTA/dD1uPWU9TmFOOmU8PTB8fGU+PTE/dD1uPU5hTjpuPD0wJiYodD1OYU4pLG5ldyBMdCh0LG4sZSxyKX1mdW5jdGlvbiBSdCh0LG4sZSxyKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIEx0KXJldHVybiBuZXcgTHQodC5oLHQucyx0LmwsdC5vcGFjaXR5KTtpZih0IGluc3RhbmNlb2YgTnR8fCh0PWt0KHQpKSwhdClyZXR1cm4gbmV3IEx0O2lmKHQgaW5zdGFuY2VvZiBMdClyZXR1cm4gdDt2YXIgbj0odD10LnJnYigpKS5yLzI1NSxlPXQuZy8yNTUscj10LmIvMjU1LGk9TWF0aC5taW4obixlLHIpLG89TWF0aC5tYXgobixlLHIpLHU9TmFOLGE9by1pLGM9KG8raSkvMjtyZXR1cm4gYT8odT1uPT09bz8oZS1yKS9hKzYqKGU8cik6ZT09PW8/KHItbikvYSsyOihuLWUpL2ErNCxhLz1jPC41P28raToyLW8taSx1Kj02MCk6YT1jPjAmJmM8MT8wOnUsbmV3IEx0KHUsYSxjLHQub3BhY2l0eSl9KHQpOm5ldyBMdCh0LG4sZSxudWxsPT1yPzE6cil9ZnVuY3Rpb24gTHQodCxuLGUscil7dGhpcy5oPSt0LHRoaXMucz0rbix0aGlzLmw9K2UsdGhpcy5vcGFjaXR5PStyfWZ1bmN0aW9uIHF0KHQsbixlKXtyZXR1cm4gMjU1Kih0PDYwP24rKGUtbikqdC82MDp0PDE4MD9lOnQ8MjQwP24rKGUtbikqKDI0MC10KS82MDpuKX1mdW5jdGlvbiBEdCh0KXtpZih0IGluc3RhbmNlb2YgT3QpcmV0dXJuIG5ldyBPdCh0LmwsdC5hLHQuYix0Lm9wYWNpdHkpO2lmKHQgaW5zdGFuY2VvZiBqdCl7dmFyIG49dC5oKnhmO3JldHVybiBuZXcgT3QodC5sLE1hdGguY29zKG4pKnQuYyxNYXRoLnNpbihuKSp0LmMsdC5vcGFjaXR5KX10IGluc3RhbmNlb2YgenR8fCh0PUF0KHQpKTt2YXIgZT1CdCh0LnIpLHI9QnQodC5nKSxpPUJ0KHQuYiksbz1GdCgoLjQxMjQ1NjQqZSsuMzU3NTc2MSpyKy4xODA0Mzc1KmkpL3dmKSx1PUZ0KCguMjEyNjcyOSplKy43MTUxNTIyKnIrLjA3MjE3NSppKS9NZik7cmV0dXJuIG5ldyBPdCgxMTYqdS0xNiw1MDAqKG8tdSksMjAwKih1LUZ0KCguMDE5MzMzOSplKy4xMTkxOTIqcisuOTUwMzA0MSppKS9UZikpLHQub3BhY2l0eSl9ZnVuY3Rpb24gVXQodCxuLGUscil7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP0R0KHQpOm5ldyBPdCh0LG4sZSxudWxsPT1yPzE6cil9ZnVuY3Rpb24gT3QodCxuLGUscil7dGhpcy5sPSt0LHRoaXMuYT0rbix0aGlzLmI9K2UsdGhpcy5vcGFjaXR5PStyfWZ1bmN0aW9uIEZ0KHQpe3JldHVybiB0PkVmP01hdGgucG93KHQsMS8zKTp0L1NmK05mfWZ1bmN0aW9uIEl0KHQpe3JldHVybiB0PmtmP3QqdCp0OlNmKih0LU5mKX1mdW5jdGlvbiBZdCh0KXtyZXR1cm4gMjU1Kih0PD0uMDAzMTMwOD8xMi45Mip0OjEuMDU1Kk1hdGgucG93KHQsMS8yLjQpLS4wNTUpfWZ1bmN0aW9uIEJ0KHQpe3JldHVybih0Lz0yNTUpPD0uMDQwNDU/dC8xMi45MjpNYXRoLnBvdygodCsuMDU1KS8xLjA1NSwyLjQpfWZ1bmN0aW9uIEh0KHQsbixlLHIpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD9mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YganQpcmV0dXJuIG5ldyBqdCh0LmgsdC5jLHQubCx0Lm9wYWNpdHkpO3QgaW5zdGFuY2VvZiBPdHx8KHQ9RHQodCkpO3ZhciBuPU1hdGguYXRhbjIodC5iLHQuYSkqYmY7cmV0dXJuIG5ldyBqdChuPDA/biszNjA6bixNYXRoLnNxcnQodC5hKnQuYSt0LmIqdC5iKSx0LmwsdC5vcGFjaXR5KX0odCk6bmV3IGp0KHQsbixlLG51bGw9PXI/MTpyKX1mdW5jdGlvbiBqdCh0LG4sZSxyKXt0aGlzLmg9K3QsdGhpcy5jPStuLHRoaXMubD0rZSx0aGlzLm9wYWNpdHk9K3J9ZnVuY3Rpb24gWHQodCxuLGUscil7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP2Z1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBWdClyZXR1cm4gbmV3IFZ0KHQuaCx0LnMsdC5sLHQub3BhY2l0eSk7dCBpbnN0YW5jZW9mIHp0fHwodD1BdCh0KSk7dmFyIG49dC5yLzI1NSxlPXQuZy8yNTUscj10LmIvMjU1LGk9KExmKnIrUGYqbi1SZiplKS8oTGYrUGYtUmYpLG89ci1pLHU9KHpmKihlLWkpLUFmKm8pL0NmLGE9TWF0aC5zcXJ0KHUqdStvKm8pLyh6ZippKigxLWkpKSxjPWE/TWF0aC5hdGFuMih1LG8pKmJmLTEyMDpOYU47cmV0dXJuIG5ldyBWdChjPDA/YyszNjA6YyxhLGksdC5vcGFjaXR5KX0odCk6bmV3IFZ0KHQsbixlLG51bGw9PXI/MTpyKX1mdW5jdGlvbiBWdCh0LG4sZSxyKXt0aGlzLmg9K3QsdGhpcy5zPStuLHRoaXMubD0rZSx0aGlzLm9wYWNpdHk9K3J9ZnVuY3Rpb24gJHQodCxuLGUscixpKXt2YXIgbz10KnQsdT1vKnQ7cmV0dXJuKCgxLTMqdCszKm8tdSkqbisoNC02Km8rMyp1KSplKygxKzMqdCszKm8tMyp1KSpyK3UqaSkvNn1mdW5jdGlvbiBXdCh0KXt2YXIgbj10Lmxlbmd0aC0xO3JldHVybiBmdW5jdGlvbihlKXt2YXIgcj1lPD0wP2U9MDplPj0xPyhlPTEsbi0xKTpNYXRoLmZsb29yKGUqbiksaT10W3JdLG89dFtyKzFdLHU9cj4wP3Rbci0xXToyKmktbyxhPXI8bi0xP3RbcisyXToyKm8taTtyZXR1cm4gJHQoKGUtci9uKSpuLHUsaSxvLGEpfX1mdW5jdGlvbiBadCh0KXt2YXIgbj10Lmxlbmd0aDtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI9TWF0aC5mbG9vcigoKGUlPTEpPDA/KytlOmUpKm4pLGk9dFsocituLTEpJW5dLG89dFtyJW5dLHU9dFsocisxKSVuXSxhPXRbKHIrMiklbl07cmV0dXJuICR0KChlLXIvbikqbixpLG8sdSxhKX19ZnVuY3Rpb24gR3QodCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR9fWZ1bmN0aW9uIFF0KHQsbil7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0K2Uqbn19ZnVuY3Rpb24gSnQodCxuKXt2YXIgZT1uLXQ7cmV0dXJuIGU/UXQodCxlPjE4MHx8ZTwtMTgwP2UtMzYwKk1hdGgucm91bmQoZS8zNjApOmUpOkd0KGlzTmFOKHQpP246dCl9ZnVuY3Rpb24gS3QodCl7cmV0dXJuIDE9PSh0PSt0KT90bjpmdW5jdGlvbihuLGUpe3JldHVybiBlLW4/ZnVuY3Rpb24odCxuLGUpe3JldHVybiB0PU1hdGgucG93KHQsZSksbj1NYXRoLnBvdyhuLGUpLXQsZT0xL2UsZnVuY3Rpb24ocil7cmV0dXJuIE1hdGgucG93KHQrcipuLGUpfX0obixlLHQpOkd0KGlzTmFOKG4pP2U6bil9fWZ1bmN0aW9uIHRuKHQsbil7dmFyIGU9bi10O3JldHVybiBlP1F0KHQsZSk6R3QoaXNOYU4odCk/bjp0KX1mdW5jdGlvbiBubih0KXtyZXR1cm4gZnVuY3Rpb24obil7dmFyIGUscixpPW4ubGVuZ3RoLG89bmV3IEFycmF5KGkpLHU9bmV3IEFycmF5KGkpLGE9bmV3IEFycmF5KGkpO2ZvcihlPTA7ZTxpOysrZSlyPUN0KG5bZV0pLG9bZV09ci5yfHwwLHVbZV09ci5nfHwwLGFbZV09ci5ifHwwO3JldHVybiBvPXQobyksdT10KHUpLGE9dChhKSxyLm9wYWNpdHk9MSxmdW5jdGlvbih0KXtyZXR1cm4gci5yPW8odCksci5nPXUodCksci5iPWEodCkscitcIlwifX19ZnVuY3Rpb24gZW4odCxuKXt2YXIgZSxyPW4/bi5sZW5ndGg6MCxpPXQ/TWF0aC5taW4ocix0Lmxlbmd0aCk6MCxvPW5ldyBBcnJheShpKSx1PW5ldyBBcnJheShyKTtmb3IoZT0wO2U8aTsrK2Upb1tlXT1jbih0W2VdLG5bZV0pO2Zvcig7ZTxyOysrZSl1W2VdPW5bZV07cmV0dXJuIGZ1bmN0aW9uKHQpe2ZvcihlPTA7ZTxpOysrZSl1W2VdPW9bZV0odCk7cmV0dXJuIHV9fWZ1bmN0aW9uIHJuKHQsbil7dmFyIGU9bmV3IERhdGU7cmV0dXJuIHQ9K3Qsbi09dCxmdW5jdGlvbihyKXtyZXR1cm4gZS5zZXRUaW1lKHQrbipyKSxlfX1mdW5jdGlvbiBvbih0LG4pe3JldHVybiB0PSt0LG4tPXQsZnVuY3Rpb24oZSl7cmV0dXJuIHQrbiplfX1mdW5jdGlvbiB1bih0LG4pe3ZhciBlLHI9e30saT17fTtudWxsIT09dCYmXCJvYmplY3RcIj09dHlwZW9mIHR8fCh0PXt9KSxudWxsIT09biYmXCJvYmplY3RcIj09dHlwZW9mIG58fChuPXt9KTtmb3IoZSBpbiBuKWUgaW4gdD9yW2VdPWNuKHRbZV0sbltlXSk6aVtlXT1uW2VdO3JldHVybiBmdW5jdGlvbih0KXtmb3IoZSBpbiByKWlbZV09cltlXSh0KTtyZXR1cm4gaX19ZnVuY3Rpb24gYW4odCxuKXt2YXIgZSxyLGksbz1qZi5sYXN0SW5kZXg9WGYubGFzdEluZGV4PTAsdT0tMSxhPVtdLGM9W107Zm9yKHQrPVwiXCIsbis9XCJcIjsoZT1qZi5leGVjKHQpKSYmKHI9WGYuZXhlYyhuKSk7KShpPXIuaW5kZXgpPm8mJihpPW4uc2xpY2UobyxpKSxhW3VdP2FbdV0rPWk6YVsrK3VdPWkpLChlPWVbMF0pPT09KHI9clswXSk/YVt1XT9hW3VdKz1yOmFbKyt1XT1yOihhWysrdV09bnVsbCxjLnB1c2goe2k6dSx4Om9uKGUscil9KSksbz1YZi5sYXN0SW5kZXg7cmV0dXJuIG88bi5sZW5ndGgmJihpPW4uc2xpY2UobyksYVt1XT9hW3VdKz1pOmFbKyt1XT1pKSxhLmxlbmd0aDwyP2NbMF0/ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiB0KG4pK1wiXCJ9fShjWzBdLngpOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX0obik6KG49Yy5sZW5ndGgsZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9MDtyPG47KytyKWFbKGU9Y1tyXSkuaV09ZS54KHQpO3JldHVybiBhLmpvaW4oXCJcIil9KX1mdW5jdGlvbiBjbih0LG4pe3ZhciBlLHI9dHlwZW9mIG47cmV0dXJuIG51bGw9PW58fFwiYm9vbGVhblwiPT09cj9HdChuKTooXCJudW1iZXJcIj09PXI/b246XCJzdHJpbmdcIj09PXI/KGU9a3QobikpPyhuPWUsWWYpOmFuOm4gaW5zdGFuY2VvZiBrdD9ZZjpuIGluc3RhbmNlb2YgRGF0ZT9ybjpBcnJheS5pc0FycmF5KG4pP2VuOlwiZnVuY3Rpb25cIiE9dHlwZW9mIG4udmFsdWVPZiYmXCJmdW5jdGlvblwiIT10eXBlb2Ygbi50b1N0cmluZ3x8aXNOYU4obik/dW46b24pKHQsbil9ZnVuY3Rpb24gc24odCxuKXtyZXR1cm4gdD0rdCxuLT10LGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLnJvdW5kKHQrbiplKX19ZnVuY3Rpb24gZm4odCxuLGUscixpLG8pe3ZhciB1LGEsYztyZXR1cm4odT1NYXRoLnNxcnQodCp0K24qbikpJiYodC89dSxuLz11KSwoYz10KmUrbipyKSYmKGUtPXQqYyxyLT1uKmMpLChhPU1hdGguc3FydChlKmUrcipyKSkmJihlLz1hLHIvPWEsYy89YSksdCpyPG4qZSYmKHQ9LXQsbj0tbixjPS1jLHU9LXUpLHt0cmFuc2xhdGVYOmksdHJhbnNsYXRlWTpvLHJvdGF0ZTpNYXRoLmF0YW4yKG4sdCkqVmYsc2tld1g6TWF0aC5hdGFuKGMpKlZmLHNjYWxlWDp1LHNjYWxlWTphfX1mdW5jdGlvbiBsbih0LG4sZSxyKXtmdW5jdGlvbiBpKHQpe3JldHVybiB0Lmxlbmd0aD90LnBvcCgpK1wiIFwiOlwiXCJ9cmV0dXJuIGZ1bmN0aW9uKG8sdSl7dmFyIGE9W10sYz1bXTtyZXR1cm4gbz10KG8pLHU9dCh1KSxmdW5jdGlvbih0LHIsaSxvLHUsYSl7aWYodCE9PWl8fHIhPT1vKXt2YXIgYz11LnB1c2goXCJ0cmFuc2xhdGUoXCIsbnVsbCxuLG51bGwsZSk7YS5wdXNoKHtpOmMtNCx4Om9uKHQsaSl9LHtpOmMtMix4Om9uKHIsbyl9KX1lbHNlKGl8fG8pJiZ1LnB1c2goXCJ0cmFuc2xhdGUoXCIraStuK28rZSl9KG8udHJhbnNsYXRlWCxvLnRyYW5zbGF0ZVksdS50cmFuc2xhdGVYLHUudHJhbnNsYXRlWSxhLGMpLGZ1bmN0aW9uKHQsbixlLG8pe3QhPT1uPyh0LW4+MTgwP24rPTM2MDpuLXQ+MTgwJiYodCs9MzYwKSxvLnB1c2goe2k6ZS5wdXNoKGkoZSkrXCJyb3RhdGUoXCIsbnVsbCxyKS0yLHg6b24odCxuKX0pKTpuJiZlLnB1c2goaShlKStcInJvdGF0ZShcIituK3IpfShvLnJvdGF0ZSx1LnJvdGF0ZSxhLGMpLGZ1bmN0aW9uKHQsbixlLG8pe3QhPT1uP28ucHVzaCh7aTplLnB1c2goaShlKStcInNrZXdYKFwiLG51bGwsciktMix4Om9uKHQsbil9KTpuJiZlLnB1c2goaShlKStcInNrZXdYKFwiK24rcil9KG8uc2tld1gsdS5za2V3WCxhLGMpLGZ1bmN0aW9uKHQsbixlLHIsbyx1KXtpZih0IT09ZXx8biE9PXIpe3ZhciBhPW8ucHVzaChpKG8pK1wic2NhbGUoXCIsbnVsbCxcIixcIixudWxsLFwiKVwiKTt1LnB1c2goe2k6YS00LHg6b24odCxlKX0se2k6YS0yLHg6b24obixyKX0pfWVsc2UgMT09PWUmJjE9PT1yfHxvLnB1c2goaShvKStcInNjYWxlKFwiK2UrXCIsXCIrcitcIilcIil9KG8uc2NhbGVYLG8uc2NhbGVZLHUuc2NhbGVYLHUuc2NhbGVZLGEsYyksbz11PW51bGwsZnVuY3Rpb24odCl7Zm9yKHZhciBuLGU9LTEscj1jLmxlbmd0aDsrK2U8cjspYVsobj1jW2VdKS5pXT1uLngodCk7cmV0dXJuIGEuam9pbihcIlwiKX19fWZ1bmN0aW9uIGhuKHQpe3JldHVybigodD1NYXRoLmV4cCh0KSkrMS90KS8yfWZ1bmN0aW9uIHBuKHQsbil7dmFyIGUscixpPXRbMF0sbz10WzFdLHU9dFsyXSxhPW5bMF0sYz1uWzFdLHM9blsyXSxmPWEtaSxsPWMtbyxoPWYqZitsKmw7aWYoaDxLZilyPU1hdGgubG9nKHMvdSkvR2YsZT1mdW5jdGlvbih0KXtyZXR1cm5baSt0KmYsbyt0KmwsdSpNYXRoLmV4cChHZip0KnIpXX07ZWxzZXt2YXIgcD1NYXRoLnNxcnQoaCksZD0ocypzLXUqdStKZipoKS8oMip1KlFmKnApLHY9KHMqcy11KnUtSmYqaCkvKDIqcypRZipwKSxnPU1hdGgubG9nKE1hdGguc3FydChkKmQrMSktZCksXz1NYXRoLmxvZyhNYXRoLnNxcnQodip2KzEpLXYpO3I9KF8tZykvR2YsZT1mdW5jdGlvbih0KXt2YXIgbj10KnIsZT1obihnKSxhPXUvKFFmKnApKihlKmZ1bmN0aW9uKHQpe3JldHVybigodD1NYXRoLmV4cCgyKnQpKS0xKS8odCsxKX0oR2YqbitnKS1mdW5jdGlvbih0KXtyZXR1cm4oKHQ9TWF0aC5leHAodCkpLTEvdCkvMn0oZykpO3JldHVybltpK2EqZixvK2EqbCx1KmUvaG4oR2YqbitnKV19fXJldHVybiBlLmR1cmF0aW9uPTFlMypyLGV9ZnVuY3Rpb24gZG4odCl7cmV0dXJuIGZ1bmN0aW9uKG4sZSl7dmFyIHI9dCgobj1SdChuKSkuaCwoZT1SdChlKSkuaCksaT10bihuLnMsZS5zKSxvPXRuKG4ubCxlLmwpLHU9dG4obi5vcGFjaXR5LGUub3BhY2l0eSk7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBuLmg9cih0KSxuLnM9aSh0KSxuLmw9byh0KSxuLm9wYWNpdHk9dSh0KSxuK1wiXCJ9fX1mdW5jdGlvbiB2bih0KXtyZXR1cm4gZnVuY3Rpb24obixlKXt2YXIgcj10KChuPUh0KG4pKS5oLChlPUh0KGUpKS5oKSxpPXRuKG4uYyxlLmMpLG89dG4obi5sLGUubCksdT10bihuLm9wYWNpdHksZS5vcGFjaXR5KTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG4uaD1yKHQpLG4uYz1pKHQpLG4ubD1vKHQpLG4ub3BhY2l0eT11KHQpLG4rXCJcIn19fWZ1bmN0aW9uIGduKHQpe3JldHVybiBmdW5jdGlvbiBuKGUpe2Z1bmN0aW9uIHIobixyKXt2YXIgaT10KChuPVh0KG4pKS5oLChyPVh0KHIpKS5oKSxvPXRuKG4ucyxyLnMpLHU9dG4obi5sLHIubCksYT10bihuLm9wYWNpdHksci5vcGFjaXR5KTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG4uaD1pKHQpLG4ucz1vKHQpLG4ubD11KE1hdGgucG93KHQsZSkpLG4ub3BhY2l0eT1hKHQpLG4rXCJcIn19cmV0dXJuIGU9K2Usci5nYW1tYT1uLHJ9KDEpfWZ1bmN0aW9uIF9uKCl7cmV0dXJuIGxsfHwoZGwoeW4pLGxsPXBsLm5vdygpK2hsKX1mdW5jdGlvbiB5bigpe2xsPTB9ZnVuY3Rpb24gbW4oKXt0aGlzLl9jYWxsPXRoaXMuX3RpbWU9dGhpcy5fbmV4dD1udWxsfWZ1bmN0aW9uIHhuKHQsbixlKXt2YXIgcj1uZXcgbW47cmV0dXJuIHIucmVzdGFydCh0LG4sZSkscn1mdW5jdGlvbiBibigpe19uKCksKyt1bDtmb3IodmFyIHQsbj1GZjtuOykodD1sbC1uLl90aW1lKT49MCYmbi5fY2FsbC5jYWxsKG51bGwsdCksbj1uLl9uZXh0Oy0tdWx9ZnVuY3Rpb24gd24oKXtsbD0oZmw9cGwubm93KCkpK2hsLHVsPWFsPTA7dHJ5e2JuKCl9ZmluYWxseXt1bD0wLGZ1bmN0aW9uKCl7dmFyIHQsbixlPUZmLHI9MS8wO2Zvcig7ZTspZS5fY2FsbD8ocj5lLl90aW1lJiYocj1lLl90aW1lKSx0PWUsZT1lLl9uZXh0KToobj1lLl9uZXh0LGUuX25leHQ9bnVsbCxlPXQ/dC5fbmV4dD1uOkZmPW4pO0lmPXQsVG4ocil9KCksbGw9MH19ZnVuY3Rpb24gTW4oKXt2YXIgdD1wbC5ub3coKSxuPXQtZmw7bj5zbCYmKGhsLT1uLGZsPXQpfWZ1bmN0aW9uIFRuKHQpe2lmKCF1bCl7YWwmJihhbD1jbGVhclRpbWVvdXQoYWwpKTt0LWxsPjI0Pyh0PDEvMCYmKGFsPXNldFRpbWVvdXQod24sdC1wbC5ub3coKS1obCkpLGNsJiYoY2w9Y2xlYXJJbnRlcnZhbChjbCkpKTooY2x8fChmbD1wbC5ub3coKSxjbD1zZXRJbnRlcnZhbChNbixzbCkpLHVsPTEsZGwod24pKX19ZnVuY3Rpb24gTm4odCxuLGUpe3ZhciByPW5ldyBtbjtyZXR1cm4gbj1udWxsPT1uPzA6K24sci5yZXN0YXJ0KGZ1bmN0aW9uKGUpe3Iuc3RvcCgpLHQoZStuKX0sbixlKSxyfWZ1bmN0aW9uIGtuKHQsbixlLHIsaSxvKXt2YXIgdT10Ll9fdHJhbnNpdGlvbjtpZih1KXtpZihlIGluIHUpcmV0dXJufWVsc2UgdC5fX3RyYW5zaXRpb249e307KGZ1bmN0aW9uKHQsbixlKXtmdW5jdGlvbiByKGMpe3ZhciBzLGYsbCxoO2lmKGUuc3RhdGUhPT15bClyZXR1cm4gbygpO2ZvcihzIGluIGEpaWYoKGg9YVtzXSkubmFtZT09PWUubmFtZSl7aWYoaC5zdGF0ZT09PXhsKXJldHVybiBObihyKTtoLnN0YXRlPT09Ymw/KGguc3RhdGU9TWwsaC50aW1lci5zdG9wKCksaC5vbi5jYWxsKFwiaW50ZXJydXB0XCIsdCx0Ll9fZGF0YV9fLGguaW5kZXgsaC5ncm91cCksZGVsZXRlIGFbc10pOitzPG4mJihoLnN0YXRlPU1sLGgudGltZXIuc3RvcCgpLGRlbGV0ZSBhW3NdKX1pZihObihmdW5jdGlvbigpe2Uuc3RhdGU9PT14bCYmKGUuc3RhdGU9YmwsZS50aW1lci5yZXN0YXJ0KGksZS5kZWxheSxlLnRpbWUpLGkoYykpfSksZS5zdGF0ZT1tbCxlLm9uLmNhbGwoXCJzdGFydFwiLHQsdC5fX2RhdGFfXyxlLmluZGV4LGUuZ3JvdXApLGUuc3RhdGU9PT1tbCl7Zm9yKGUuc3RhdGU9eGwsdT1uZXcgQXJyYXkobD1lLnR3ZWVuLmxlbmd0aCkscz0wLGY9LTE7czxsOysrcykoaD1lLnR3ZWVuW3NdLnZhbHVlLmNhbGwodCx0Ll9fZGF0YV9fLGUuaW5kZXgsZS5ncm91cCkpJiYodVsrK2ZdPWgpO3UubGVuZ3RoPWYrMX19ZnVuY3Rpb24gaShuKXtmb3IodmFyIHI9bjxlLmR1cmF0aW9uP2UuZWFzZS5jYWxsKG51bGwsbi9lLmR1cmF0aW9uKTooZS50aW1lci5yZXN0YXJ0KG8pLGUuc3RhdGU9d2wsMSksaT0tMSxhPXUubGVuZ3RoOysraTxhOyl1W2ldLmNhbGwobnVsbCxyKTtlLnN0YXRlPT09d2wmJihlLm9uLmNhbGwoXCJlbmRcIix0LHQuX19kYXRhX18sZS5pbmRleCxlLmdyb3VwKSxvKCkpfWZ1bmN0aW9uIG8oKXtlLnN0YXRlPU1sLGUudGltZXIuc3RvcCgpLGRlbGV0ZSBhW25dO2Zvcih2YXIgciBpbiBhKXJldHVybjtkZWxldGUgdC5fX3RyYW5zaXRpb259dmFyIHUsYT10Ll9fdHJhbnNpdGlvbjthW25dPWUsZS50aW1lcj14bihmdW5jdGlvbih0KXtlLnN0YXRlPXlsLGUudGltZXIucmVzdGFydChyLGUuZGVsYXksZS50aW1lKSxlLmRlbGF5PD10JiZyKHQtZS5kZWxheSl9LDAsZS50aW1lKX0pKHQsZSx7bmFtZTpuLGluZGV4OnIsZ3JvdXA6aSxvbjp2bCx0d2VlbjpnbCx0aW1lOm8udGltZSxkZWxheTpvLmRlbGF5LGR1cmF0aW9uOm8uZHVyYXRpb24sZWFzZTpvLmVhc2UsdGltZXI6bnVsbCxzdGF0ZTpfbH0pfWZ1bmN0aW9uIFNuKHQsbil7dmFyIGU9QW4odCxuKTtpZihlLnN0YXRlPl9sKXRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtyZXR1cm4gZX1mdW5jdGlvbiBFbih0LG4pe3ZhciBlPUFuKHQsbik7aWYoZS5zdGF0ZT5tbCl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzdGFydGVkXCIpO3JldHVybiBlfWZ1bmN0aW9uIEFuKHQsbil7dmFyIGU9dC5fX3RyYW5zaXRpb247aWYoIWV8fCEoZT1lW25dKSl0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtyZXR1cm4gZX1mdW5jdGlvbiBDbih0LG4pe3ZhciBlLHIsaSxvPXQuX190cmFuc2l0aW9uLHU9ITA7aWYobyl7bj1udWxsPT1uP251bGw6bitcIlwiO2ZvcihpIGluIG8pKGU9b1tpXSkubmFtZT09PW4/KHI9ZS5zdGF0ZT5tbCYmZS5zdGF0ZTx3bCxlLnN0YXRlPU1sLGUudGltZXIuc3RvcCgpLHImJmUub24uY2FsbChcImludGVycnVwdFwiLHQsdC5fX2RhdGFfXyxlLmluZGV4LGUuZ3JvdXApLGRlbGV0ZSBvW2ldKTp1PSExO3UmJmRlbGV0ZSB0Ll9fdHJhbnNpdGlvbn19ZnVuY3Rpb24gem4odCxuLGUpe3ZhciByPXQuX2lkO3JldHVybiB0LmVhY2goZnVuY3Rpb24oKXt2YXIgdD1Fbih0aGlzLHIpOyh0LnZhbHVlfHwodC52YWx1ZT17fSkpW25dPWUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSksZnVuY3Rpb24odCl7cmV0dXJuIEFuKHQscikudmFsdWVbbl19fWZ1bmN0aW9uIFBuKHQsbil7dmFyIGU7cmV0dXJuKFwibnVtYmVyXCI9PXR5cGVvZiBuP29uOm4gaW5zdGFuY2VvZiBrdD9ZZjooZT1rdChuKSk/KG49ZSxZZik6YW4pKHQsbil9ZnVuY3Rpb24gUm4odCxuLGUscil7dGhpcy5fZ3JvdXBzPXQsdGhpcy5fcGFyZW50cz1uLHRoaXMuX25hbWU9ZSx0aGlzLl9pZD1yfWZ1bmN0aW9uIExuKHQpe3JldHVybiBmdCgpLnRyYW5zaXRpb24odCl9ZnVuY3Rpb24gcW4oKXtyZXR1cm4rK05sfWZ1bmN0aW9uIERuKHQpe3JldHVybigodCo9Mik8PTE/dCp0Oi0tdCooMi10KSsxKS8yfWZ1bmN0aW9uIFVuKHQpe3JldHVybigodCo9Mik8PTE/dCp0KnQ6KHQtPTIpKnQqdCsyKS8yfWZ1bmN0aW9uIE9uKHQpe3JldHVybigxLU1hdGguY29zKENsKnQpKS8yfWZ1bmN0aW9uIEZuKHQpe3JldHVybigodCo9Mik8PTE/TWF0aC5wb3coMiwxMCp0LTEwKToyLU1hdGgucG93KDIsMTAtMTAqdCkpLzJ9ZnVuY3Rpb24gSW4odCl7cmV0dXJuKCh0Kj0yKTw9MT8xLU1hdGguc3FydCgxLXQqdCk6TWF0aC5zcXJ0KDEtKHQtPTIpKnQpKzEpLzJ9ZnVuY3Rpb24gWW4odCl7cmV0dXJuKHQ9K3QpPFBsP1lsKnQqdDp0PExsP1lsKih0LT1SbCkqdCtxbDp0PFVsP1lsKih0LT1EbCkqdCtPbDpZbCoodC09RmwpKnQrSWx9ZnVuY3Rpb24gQm4odCxuKXtmb3IodmFyIGU7IShlPXQuX190cmFuc2l0aW9uKXx8IShlPWVbbl0pOylpZighKHQ9dC5wYXJlbnROb2RlKSlyZXR1cm4gWmwudGltZT1fbigpLFpsO3JldHVybiBlfWZ1bmN0aW9uIEhuKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX1mdW5jdGlvbiBqbigpe3QuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCl9ZnVuY3Rpb24gWG4oKXt0LmV2ZW50LnByZXZlbnREZWZhdWx0KCksdC5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX1mdW5jdGlvbiBWbih0KXtyZXR1cm57dHlwZTp0fX1mdW5jdGlvbiAkbigpe3JldHVybiF0LmV2ZW50LmJ1dHRvbn1mdW5jdGlvbiBXbigpe3ZhciB0PXRoaXMub3duZXJTVkdFbGVtZW50fHx0aGlzO3JldHVybltbMCwwXSxbdC53aWR0aC5iYXNlVmFsLnZhbHVlLHQuaGVpZ2h0LmJhc2VWYWwudmFsdWVdXX1mdW5jdGlvbiBabih0KXtmb3IoOyF0Ll9fYnJ1c2g7KWlmKCEodD10LnBhcmVudE5vZGUpKXJldHVybjtyZXR1cm4gdC5fX2JydXNofWZ1bmN0aW9uIEduKHQpe3JldHVybiB0WzBdWzBdPT09dFsxXVswXXx8dFswXVsxXT09PXRbMV1bMV19ZnVuY3Rpb24gUW4obil7ZnVuY3Rpb24gZSh0KXt2YXIgZT10LnByb3BlcnR5KFwiX19icnVzaFwiLGEpLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpLmRhdGEoW1ZuKFwib3ZlcmxheVwiKV0pO2UuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLFwib3ZlcmxheVwiKS5hdHRyKFwicG9pbnRlci1ldmVudHNcIixcImFsbFwiKS5hdHRyKFwiY3Vyc29yXCIsaWgub3ZlcmxheSkubWVyZ2UoZSkuZWFjaChmdW5jdGlvbigpe3ZhciB0PVpuKHRoaXMpLmV4dGVudDtsdCh0aGlzKS5hdHRyKFwieFwiLHRbMF1bMF0pLmF0dHIoXCJ5XCIsdFswXVsxXSkuYXR0cihcIndpZHRoXCIsdFsxXVswXS10WzBdWzBdKS5hdHRyKFwiaGVpZ2h0XCIsdFsxXVsxXS10WzBdWzFdKX0pLHQuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKS5kYXRhKFtWbihcInNlbGVjdGlvblwiKV0pLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIixcInNlbGVjdGlvblwiKS5hdHRyKFwiY3Vyc29yXCIsaWguc2VsZWN0aW9uKS5hdHRyKFwiZmlsbFwiLFwiIzc3N1wiKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsLjMpLmF0dHIoXCJzdHJva2VcIixcIiNmZmZcIikuYXR0cihcInNoYXBlLXJlbmRlcmluZ1wiLFwiY3Jpc3BFZGdlc1wiKTt2YXIgaT10LnNlbGVjdEFsbChcIi5oYW5kbGVcIikuZGF0YShuLmhhbmRsZXMsZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pO2kuZXhpdCgpLnJlbW92ZSgpLGkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLGZ1bmN0aW9uKHQpe3JldHVyblwiaGFuZGxlIGhhbmRsZS0tXCIrdC50eXBlfSkuYXR0cihcImN1cnNvclwiLGZ1bmN0aW9uKHQpe3JldHVybiBpaFt0LnR5cGVdfSksdC5lYWNoKHIpLmF0dHIoXCJmaWxsXCIsXCJub25lXCIpLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLFwiYWxsXCIpLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsXCJyZ2JhKDAsMCwwLDApXCIpLm9uKFwibW91c2Vkb3duLmJydXNoIHRvdWNoc3RhcnQuYnJ1c2hcIix1KX1mdW5jdGlvbiByKCl7dmFyIHQ9bHQodGhpcyksbj1abih0aGlzKS5zZWxlY3Rpb247bj8odC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uXCIpLnN0eWxlKFwiZGlzcGxheVwiLG51bGwpLmF0dHIoXCJ4XCIsblswXVswXSkuYXR0cihcInlcIixuWzBdWzFdKS5hdHRyKFwid2lkdGhcIixuWzFdWzBdLW5bMF1bMF0pLmF0dHIoXCJoZWlnaHRcIixuWzFdWzFdLW5bMF1bMV0pLHQuc2VsZWN0QWxsKFwiLmhhbmRsZVwiKS5zdHlsZShcImRpc3BsYXlcIixudWxsKS5hdHRyKFwieFwiLGZ1bmN0aW9uKHQpe3JldHVyblwiZVwiPT09dC50eXBlW3QudHlwZS5sZW5ndGgtMV0/blsxXVswXS1oLzI6blswXVswXS1oLzJ9KS5hdHRyKFwieVwiLGZ1bmN0aW9uKHQpe3JldHVyblwic1wiPT09dC50eXBlWzBdP25bMV1bMV0taC8yOm5bMF1bMV0taC8yfSkuYXR0cihcIndpZHRoXCIsZnVuY3Rpb24odCl7cmV0dXJuXCJuXCI9PT10LnR5cGV8fFwic1wiPT09dC50eXBlP25bMV1bMF0tblswXVswXStoOmh9KS5hdHRyKFwiaGVpZ2h0XCIsZnVuY3Rpb24odCl7cmV0dXJuXCJlXCI9PT10LnR5cGV8fFwid1wiPT09dC50eXBlP25bMV1bMV0tblswXVsxXStoOmh9KSk6dC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uLC5oYW5kbGVcIikuc3R5bGUoXCJkaXNwbGF5XCIsXCJub25lXCIpLmF0dHIoXCJ4XCIsbnVsbCkuYXR0cihcInlcIixudWxsKS5hdHRyKFwid2lkdGhcIixudWxsKS5hdHRyKFwiaGVpZ2h0XCIsbnVsbCl9ZnVuY3Rpb24gaSh0LG4pe3JldHVybiB0Ll9fYnJ1c2guZW1pdHRlcnx8bmV3IG8odCxuKX1mdW5jdGlvbiBvKHQsbil7dGhpcy50aGF0PXQsdGhpcy5hcmdzPW4sdGhpcy5zdGF0ZT10Ll9fYnJ1c2gsdGhpcy5hY3RpdmU9MH1mdW5jdGlvbiB1KCl7ZnVuY3Rpb24gZSgpe3ZhciB0PUYodyk7IUx8fHh8fGJ8fChNYXRoLmFicyh0WzBdLURbMF0pPk1hdGguYWJzKHRbMV0tRFsxXSk/Yj0hMDp4PSEwKSxEPXQsbT0hMCxYbigpLG8oKX1mdW5jdGlvbiBvKCl7dmFyIHQ7c3dpdGNoKF89RFswXS1xWzBdLHk9RFsxXS1xWzFdLFQpe2Nhc2UgSmw6Y2FzZSBRbDpOJiYoXz1NYXRoLm1heChDLWEsTWF0aC5taW4oUC1wLF8pKSxzPWErXyxkPXArXyksayYmKHk9TWF0aC5tYXgoei1sLE1hdGgubWluKFItdix5KSksaD1sK3ksZz12K3kpO2JyZWFrO2Nhc2UgS2w6TjwwPyhfPU1hdGgubWF4KEMtYSxNYXRoLm1pbihQLWEsXykpLHM9YStfLGQ9cCk6Tj4wJiYoXz1NYXRoLm1heChDLXAsTWF0aC5taW4oUC1wLF8pKSxzPWEsZD1wK18pLGs8MD8oeT1NYXRoLm1heCh6LWwsTWF0aC5taW4oUi1sLHkpKSxoPWwreSxnPXYpOms+MCYmKHk9TWF0aC5tYXgoei12LE1hdGgubWluKFItdix5KSksaD1sLGc9dit5KTticmVhaztjYXNlIHRoOk4mJihzPU1hdGgubWF4KEMsTWF0aC5taW4oUCxhLV8qTikpLGQ9TWF0aC5tYXgoQyxNYXRoLm1pbihQLHArXypOKSkpLGsmJihoPU1hdGgubWF4KHosTWF0aC5taW4oUixsLXkqaykpLGc9TWF0aC5tYXgoeixNYXRoLm1pbihSLHYreSprKSkpfWQ8cyYmKE4qPS0xLHQ9YSxhPXAscD10LHQ9cyxzPWQsZD10LE0gaW4gb2gmJkkuYXR0cihcImN1cnNvclwiLGloW009b2hbTV1dKSksZzxoJiYoayo9LTEsdD1sLGw9dix2PXQsdD1oLGg9ZyxnPXQsTSBpbiB1aCYmSS5hdHRyKFwiY3Vyc29yXCIsaWhbTT11aFtNXV0pKSxTLnNlbGVjdGlvbiYmKEE9Uy5zZWxlY3Rpb24pLHgmJihzPUFbMF1bMF0sZD1BWzFdWzBdKSxiJiYoaD1BWzBdWzFdLGc9QVsxXVsxXSksQVswXVswXT09PXMmJkFbMF1bMV09PT1oJiZBWzFdWzBdPT09ZCYmQVsxXVsxXT09PWd8fChTLnNlbGVjdGlvbj1bW3MsaF0sW2QsZ11dLHIuY2FsbCh3KSxVLmJydXNoKCkpfWZ1bmN0aW9uIHUoKXtpZihqbigpLHQuZXZlbnQudG91Y2hlcyl7aWYodC5ldmVudC50b3VjaGVzLmxlbmd0aClyZXR1cm47YyYmY2xlYXJUaW1lb3V0KGMpLGM9c2V0VGltZW91dChmdW5jdGlvbigpe2M9bnVsbH0sNTAwKSxPLm9uKFwidG91Y2htb3ZlLmJydXNoIHRvdWNoZW5kLmJydXNoIHRvdWNoY2FuY2VsLmJydXNoXCIsbnVsbCl9ZWxzZSBndCh0LmV2ZW50LnZpZXcsbSksWS5vbihcImtleWRvd24uYnJ1c2gga2V5dXAuYnJ1c2ggbW91c2Vtb3ZlLmJydXNoIG1vdXNldXAuYnJ1c2hcIixudWxsKTtPLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLFwiYWxsXCIpLEkuYXR0cihcImN1cnNvclwiLGloLm92ZXJsYXkpLFMuc2VsZWN0aW9uJiYoQT1TLnNlbGVjdGlvbiksR24oQSkmJihTLnNlbGVjdGlvbj1udWxsLHIuY2FsbCh3KSksVS5lbmQoKX1pZih0LmV2ZW50LnRvdWNoZXMpe2lmKHQuZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoPHQuZXZlbnQudG91Y2hlcy5sZW5ndGgpcmV0dXJuIFhuKCl9ZWxzZSBpZihjKXJldHVybjtpZihmLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7dmFyIGEscyxsLGgscCxkLHYsZyxfLHksbSx4LGIsdz10aGlzLE09dC5ldmVudC50YXJnZXQuX19kYXRhX18udHlwZSxUPVwic2VsZWN0aW9uXCI9PT0odC5ldmVudC5tZXRhS2V5P009XCJvdmVybGF5XCI6TSk/UWw6dC5ldmVudC5hbHRLZXk/dGg6S2wsTj1uPT09ZWg/bnVsbDphaFtNXSxrPW49PT1uaD9udWxsOmNoW01dLFM9Wm4odyksRT1TLmV4dGVudCxBPVMuc2VsZWN0aW9uLEM9RVswXVswXSx6PUVbMF1bMV0sUD1FWzFdWzBdLFI9RVsxXVsxXSxMPU4mJmsmJnQuZXZlbnQuc2hpZnRLZXkscT1GKHcpLEQ9cSxVPWkodyxhcmd1bWVudHMpLmJlZm9yZXN0YXJ0KCk7XCJvdmVybGF5XCI9PT1NP1Muc2VsZWN0aW9uPUE9W1thPW49PT1laD9DOnFbMF0sbD1uPT09bmg/ejpxWzFdXSxbcD1uPT09ZWg/UDphLHY9bj09PW5oP1I6bF1dOihhPUFbMF1bMF0sbD1BWzBdWzFdLHA9QVsxXVswXSx2PUFbMV1bMV0pLHM9YSxoPWwsZD1wLGc9djt2YXIgTz1sdCh3KS5hdHRyKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIiksST1PLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpLmF0dHIoXCJjdXJzb3JcIixpaFtNXSk7aWYodC5ldmVudC50b3VjaGVzKU8ub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIixlLCEwKS5vbihcInRvdWNoZW5kLmJydXNoIHRvdWNoY2FuY2VsLmJydXNoXCIsdSwhMCk7ZWxzZXt2YXIgWT1sdCh0LmV2ZW50LnZpZXcpLm9uKFwia2V5ZG93bi5icnVzaFwiLGZ1bmN0aW9uKCl7c3dpdGNoKHQuZXZlbnQua2V5Q29kZSl7Y2FzZSAxNjpMPU4mJms7YnJlYWs7Y2FzZSAxODpUPT09S2wmJihOJiYocD1kLV8qTixhPXMrXypOKSxrJiYodj1nLXkqayxsPWgreSprKSxUPXRoLG8oKSk7YnJlYWs7Y2FzZSAzMjpUIT09S2wmJlQhPT10aHx8KE48MD9wPWQtXzpOPjAmJihhPXMtXyksazwwP3Y9Zy15Oms+MCYmKGw9aC15KSxUPUpsLEkuYXR0cihcImN1cnNvclwiLGloLnNlbGVjdGlvbiksbygpKTticmVhaztkZWZhdWx0OnJldHVybn1YbigpfSwhMCkub24oXCJrZXl1cC5icnVzaFwiLGZ1bmN0aW9uKCl7c3dpdGNoKHQuZXZlbnQua2V5Q29kZSl7Y2FzZSAxNjpMJiYoeD1iPUw9ITEsbygpKTticmVhaztjYXNlIDE4OlQ9PT10aCYmKE48MD9wPWQ6Tj4wJiYoYT1zKSxrPDA/dj1nOms+MCYmKGw9aCksVD1LbCxvKCkpO2JyZWFrO2Nhc2UgMzI6VD09PUpsJiYodC5ldmVudC5hbHRLZXk/KE4mJihwPWQtXypOLGE9cytfKk4pLGsmJih2PWcteSprLGw9aCt5KmspLFQ9dGgpOihOPDA/cD1kOk4+MCYmKGE9cyksazwwP3Y9ZzprPjAmJihsPWgpLFQ9S2wpLEkuYXR0cihcImN1cnNvclwiLGloW01dKSxvKCkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJufVhuKCl9LCEwKS5vbihcIm1vdXNlbW92ZS5icnVzaFwiLGUsITApLm9uKFwibW91c2V1cC5icnVzaFwiLHUsITApO3Z0KHQuZXZlbnQudmlldyl9am4oKSxDbih3KSxyLmNhbGwodyksVS5zdGFydCgpfX1mdW5jdGlvbiBhKCl7dmFyIHQ9dGhpcy5fX2JydXNofHx7c2VsZWN0aW9uOm51bGx9O3JldHVybiB0LmV4dGVudD1zLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0LmRpbT1uLHR9dmFyIGMscz1XbixmPSRuLGw9TihlLFwic3RhcnRcIixcImJydXNoXCIsXCJlbmRcIiksaD02O3JldHVybiBlLm1vdmU9ZnVuY3Rpb24odCxlKXt0LnNlbGVjdGlvbj90Lm9uKFwic3RhcnQuYnJ1c2hcIixmdW5jdGlvbigpe2kodGhpcyxhcmd1bWVudHMpLmJlZm9yZXN0YXJ0KCkuc3RhcnQoKX0pLm9uKFwiaW50ZXJydXB0LmJydXNoIGVuZC5icnVzaFwiLGZ1bmN0aW9uKCl7aSh0aGlzLGFyZ3VtZW50cykuZW5kKCl9KS50d2VlbihcImJydXNoXCIsZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3Uuc2VsZWN0aW9uPTE9PT10JiZHbihzKT9udWxsOmYodCksci5jYWxsKG8pLGEuYnJ1c2goKX12YXIgbz10aGlzLHU9by5fX2JydXNoLGE9aShvLGFyZ3VtZW50cyksYz11LnNlbGVjdGlvbixzPW4uaW5wdXQoXCJmdW5jdGlvblwiPT10eXBlb2YgZT9lLmFwcGx5KHRoaXMsYXJndW1lbnRzKTplLHUuZXh0ZW50KSxmPWNuKGMscyk7cmV0dXJuIGMmJnM/dDp0KDEpfSk6dC5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLG89dGhpcy5fX2JydXNoLHU9bi5pbnB1dChcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UuYXBwbHkodGhpcyx0KTplLG8uZXh0ZW50KSxhPWkodGhpcyx0KS5iZWZvcmVzdGFydCgpO0NuKHRoaXMpLG8uc2VsZWN0aW9uPW51bGw9PXV8fEduKHUpP251bGw6dSxyLmNhbGwodGhpcyksYS5zdGFydCgpLmJydXNoKCkuZW5kKCl9KX0sby5wcm90b3R5cGU9e2JlZm9yZXN0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIDE9PSsrdGhpcy5hY3RpdmUmJih0aGlzLnN0YXRlLmVtaXR0ZXI9dGhpcyx0aGlzLnN0YXJ0aW5nPSEwKSx0aGlzfSxzdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0aW5nJiYodGhpcy5zdGFydGluZz0hMSx0aGlzLmVtaXQoXCJzdGFydFwiKSksdGhpc30sYnJ1c2g6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbWl0KFwiYnJ1c2hcIiksdGhpc30sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PS0tdGhpcy5hY3RpdmUmJihkZWxldGUgdGhpcy5zdGF0ZS5lbWl0dGVyLHRoaXMuZW1pdChcImVuZFwiKSksdGhpc30sZW1pdDpmdW5jdGlvbih0KXtEKG5ldyBmdW5jdGlvbih0LG4sZSl7dGhpcy50YXJnZXQ9dCx0aGlzLnR5cGU9bix0aGlzLnNlbGVjdGlvbj1lfShlLHQsbi5vdXRwdXQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pKSxsLmFwcGx5LGwsW3QsdGhpcy50aGF0LHRoaXMuYXJnc10pfX0sZS5leHRlbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHM9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OkhuKFtbK3RbMF1bMF0sK3RbMF1bMV1dLFsrdFsxXVswXSwrdFsxXVsxXV1dKSxlKTpzfSxlLmZpbHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6SG4oISF0KSxlKTpmfSxlLmhhbmRsZVNpemU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGg9K3QsZSk6aH0sZS5vbj1mdW5jdGlvbigpe3ZhciB0PWwub24uYXBwbHkobCxhcmd1bWVudHMpO3JldHVybiB0PT09bD9lOnR9LGV9ZnVuY3Rpb24gSm4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR9fWZ1bmN0aW9uIEtuKCl7dGhpcy5feDA9dGhpcy5feTA9dGhpcy5feDE9dGhpcy5feTE9bnVsbCx0aGlzLl89XCJcIn1mdW5jdGlvbiB0ZSgpe3JldHVybiBuZXcgS259ZnVuY3Rpb24gbmUodCl7cmV0dXJuIHQuc291cmNlfWZ1bmN0aW9uIGVlKHQpe3JldHVybiB0LnRhcmdldH1mdW5jdGlvbiByZSh0KXtyZXR1cm4gdC5yYWRpdXN9ZnVuY3Rpb24gaWUodCl7cmV0dXJuIHQuc3RhcnRBbmdsZX1mdW5jdGlvbiBvZSh0KXtyZXR1cm4gdC5lbmRBbmdsZX1mdW5jdGlvbiB1ZSgpe31mdW5jdGlvbiBhZSh0LG4pe3ZhciBlPW5ldyB1ZTtpZih0IGluc3RhbmNlb2YgdWUpdC5lYWNoKGZ1bmN0aW9uKHQsbil7ZS5zZXQobix0KX0pO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0KSl7dmFyIHIsaT0tMSxvPXQubGVuZ3RoO2lmKG51bGw9PW4pZm9yKDsrK2k8bzspZS5zZXQoaSx0W2ldKTtlbHNlIGZvcig7KytpPG87KWUuc2V0KG4ocj10W2ldLGksdCkscil9ZWxzZSBpZih0KWZvcih2YXIgdSBpbiB0KWUuc2V0KHUsdFt1XSk7cmV0dXJuIGV9ZnVuY3Rpb24gY2UoKXtyZXR1cm57fX1mdW5jdGlvbiBzZSh0LG4sZSl7dFtuXT1lfWZ1bmN0aW9uIGZlKCl7cmV0dXJuIGFlKCl9ZnVuY3Rpb24gbGUodCxuLGUpe3Quc2V0KG4sZSl9ZnVuY3Rpb24gaGUoKXt9ZnVuY3Rpb24gcGUodCxuKXt2YXIgZT1uZXcgaGU7aWYodCBpbnN0YW5jZW9mIGhlKXQuZWFjaChmdW5jdGlvbih0KXtlLmFkZCh0KX0pO2Vsc2UgaWYodCl7dmFyIHI9LTEsaT10Lmxlbmd0aDtpZihudWxsPT1uKWZvcig7KytyPGk7KWUuYWRkKHRbcl0pO2Vsc2UgZm9yKDsrK3I8aTspZS5hZGQobih0W3JdLHIsdCkpfXJldHVybiBlfWZ1bmN0aW9uIGRlKHQpe3JldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsXCJyZXR1cm4ge1wiK3QubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHQpK1wiOiBkW1wiK24rXCJdXCJ9KS5qb2luKFwiLFwiKStcIn1cIil9ZnVuY3Rpb24gdmUodCl7ZnVuY3Rpb24gbih0LG4pe2Z1bmN0aW9uIGUoKXtpZihzKXJldHVybiBiaDtpZihmKXJldHVybiBmPSExLHhoO3ZhciBuLGUscj1hO2lmKHQuY2hhckNvZGVBdChyKT09PXdoKXtmb3IoO2ErKzx1JiZ0LmNoYXJDb2RlQXQoYSkhPT13aHx8dC5jaGFyQ29kZUF0KCsrYSk9PT13aDspO3JldHVybihuPWEpPj11P3M9ITA6KGU9dC5jaGFyQ29kZUF0KGErKykpPT09TWg/Zj0hMDplPT09VGgmJihmPSEwLHQuY2hhckNvZGVBdChhKT09PU1oJiYrK2EpLHQuc2xpY2UocisxLG4tMSkucmVwbGFjZSgvXCJcIi9nLCdcIicpfWZvcig7YTx1Oyl7aWYoKGU9dC5jaGFyQ29kZUF0KG49YSsrKSk9PT1NaClmPSEwO2Vsc2UgaWYoZT09PVRoKWY9ITAsdC5jaGFyQ29kZUF0KGEpPT09TWgmJisrYTtlbHNlIGlmKGUhPT1vKWNvbnRpbnVlO3JldHVybiB0LnNsaWNlKHIsbil9cmV0dXJuIHM9ITAsdC5zbGljZShyLHUpfXZhciByLGk9W10sdT10Lmxlbmd0aCxhPTAsYz0wLHM9dTw9MCxmPSExO2Zvcih0LmNoYXJDb2RlQXQodS0xKT09PU1oJiYtLXUsdC5jaGFyQ29kZUF0KHUtMSk9PT1UaCYmLS11OyhyPWUoKSkhPT1iaDspe2Zvcih2YXIgbD1bXTtyIT09eGgmJnIhPT1iaDspbC5wdXNoKHIpLHI9ZSgpO24mJm51bGw9PShsPW4obCxjKyspKXx8aS5wdXNoKGwpfXJldHVybiBpfWZ1bmN0aW9uIGUobil7cmV0dXJuIG4ubWFwKHIpLmpvaW4odCl9ZnVuY3Rpb24gcih0KXtyZXR1cm4gbnVsbD09dD9cIlwiOmkudGVzdCh0Kz1cIlwiKT8nXCInK3QucmVwbGFjZSgvXCIvZywnXCJcIicpKydcIic6dH12YXIgaT1uZXcgUmVnRXhwKCdbXCInK3QrXCJcXG5cXHJdXCIpLG89dC5jaGFyQ29kZUF0KDApO3JldHVybntwYXJzZTpmdW5jdGlvbih0LGUpe3ZhciByLGksbz1uKHQsZnVuY3Rpb24odCxuKXtpZihyKXJldHVybiByKHQsbi0xKTtpPXQscj1lP2Z1bmN0aW9uKHQsbil7dmFyIGU9ZGUodCk7cmV0dXJuIGZ1bmN0aW9uKHIsaSl7cmV0dXJuIG4oZShyKSxpLHQpfX0odCxlKTpkZSh0KX0pO3JldHVybiBvLmNvbHVtbnM9aXx8W10sb30scGFyc2VSb3dzOm4sZm9ybWF0OmZ1bmN0aW9uKG4sZSl7cmV0dXJuIG51bGw9PWUmJihlPWZ1bmN0aW9uKHQpe3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCksZT1bXTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Zvcih2YXIgciBpbiB0KXIgaW4gbnx8ZS5wdXNoKG5bcl09cil9KSxlfShuKSksW2UubWFwKHIpLmpvaW4odCldLmNvbmNhdChuLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHIoblt0XSl9KS5qb2luKHQpfSkpLmpvaW4oXCJcXG5cIil9LGZvcm1hdFJvd3M6ZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGUpLmpvaW4oXCJcXG5cIil9fX1mdW5jdGlvbiBnZSh0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdH19ZnVuY3Rpb24gX2UoKXtyZXR1cm4gMWUtNiooTWF0aC5yYW5kb20oKS0uNSl9ZnVuY3Rpb24geWUodCxuLGUscil7aWYoaXNOYU4obil8fGlzTmFOKGUpKXJldHVybiB0O3ZhciBpLG8sdSxhLGMscyxmLGwsaCxwPXQuX3Jvb3QsZD17ZGF0YTpyfSx2PXQuX3gwLGc9dC5feTAsXz10Ll94MSx5PXQuX3kxO2lmKCFwKXJldHVybiB0Ll9yb290PWQsdDtmb3IoO3AubGVuZ3RoOylpZigocz1uPj0obz0oditfKS8yKSk/dj1vOl89bywoZj1lPj0odT0oZyt5KS8yKSk/Zz11Onk9dSxpPXAsIShwPXBbbD1mPDwxfHNdKSlyZXR1cm4gaVtsXT1kLHQ7aWYoYT0rdC5feC5jYWxsKG51bGwscC5kYXRhKSxjPSt0Ll95LmNhbGwobnVsbCxwLmRhdGEpLG49PT1hJiZlPT09YylyZXR1cm4gZC5uZXh0PXAsaT9pW2xdPWQ6dC5fcm9vdD1kLHQ7ZG97aT1pP2lbbF09bmV3IEFycmF5KDQpOnQuX3Jvb3Q9bmV3IEFycmF5KDQpLChzPW4+PShvPSh2K18pLzIpKT92PW86Xz1vLChmPWU+PSh1PShnK3kpLzIpKT9nPXU6eT11fXdoaWxlKChsPWY8PDF8cyk9PShoPShjPj11KTw8MXxhPj1vKSk7cmV0dXJuIGlbaF09cCxpW2xdPWQsdH1mdW5jdGlvbiBtZSh0LG4sZSxyLGkpe3RoaXMubm9kZT10LHRoaXMueDA9bix0aGlzLnkwPWUsdGhpcy54MT1yLHRoaXMueTE9aX1mdW5jdGlvbiB4ZSh0KXtyZXR1cm4gdFswXX1mdW5jdGlvbiBiZSh0KXtyZXR1cm4gdFsxXX1mdW5jdGlvbiB3ZSh0LG4sZSl7dmFyIHI9bmV3IE1lKG51bGw9PW4/eGU6bixudWxsPT1lP2JlOmUsTmFOLE5hTixOYU4sTmFOKTtyZXR1cm4gbnVsbD09dD9yOnIuYWRkQWxsKHQpfWZ1bmN0aW9uIE1lKHQsbixlLHIsaSxvKXt0aGlzLl94PXQsdGhpcy5feT1uLHRoaXMuX3gwPWUsdGhpcy5feTA9cix0aGlzLl94MT1pLHRoaXMuX3kxPW8sdGhpcy5fcm9vdD12b2lkIDB9ZnVuY3Rpb24gVGUodCl7Zm9yKHZhciBuPXtkYXRhOnQuZGF0YX0sZT1uO3Q9dC5uZXh0OyllPWUubmV4dD17ZGF0YTp0LmRhdGF9O3JldHVybiBufWZ1bmN0aW9uIE5lKHQpe3JldHVybiB0LngrdC52eH1mdW5jdGlvbiBrZSh0KXtyZXR1cm4gdC55K3Qudnl9ZnVuY3Rpb24gU2UodCl7cmV0dXJuIHQuaW5kZXh9ZnVuY3Rpb24gRWUodCxuKXt2YXIgZT10LmdldChuKTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nOiBcIituKTtyZXR1cm4gZX1mdW5jdGlvbiBBZSh0KXtyZXR1cm4gdC54fWZ1bmN0aW9uIENlKHQpe3JldHVybiB0Lnl9ZnVuY3Rpb24gemUodCxuKXtpZigoZT0odD1uP3QudG9FeHBvbmVudGlhbChuLTEpOnQudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSk8MClyZXR1cm4gbnVsbDt2YXIgZSxyPXQuc2xpY2UoMCxlKTtyZXR1cm5bci5sZW5ndGg+MT9yWzBdK3Iuc2xpY2UoMik6ciwrdC5zbGljZShlKzEpXX1mdW5jdGlvbiBQZSh0KXtyZXR1cm4odD16ZShNYXRoLmFicyh0KSkpP3RbMV06TmFOfWZ1bmN0aW9uIFJlKHQsbil7dmFyIGU9emUodCxuKTtpZighZSlyZXR1cm4gdCtcIlwiO3ZhciByPWVbMF0saT1lWzFdO3JldHVybiBpPDA/XCIwLlwiK25ldyBBcnJheSgtaSkuam9pbihcIjBcIikrcjpyLmxlbmd0aD5pKzE/ci5zbGljZSgwLGkrMSkrXCIuXCIrci5zbGljZShpKzEpOnIrbmV3IEFycmF5KGktci5sZW5ndGgrMikuam9pbihcIjBcIil9ZnVuY3Rpb24gTGUodCl7cmV0dXJuIG5ldyBxZSh0KX1mdW5jdGlvbiBxZSh0KXtpZighKG49SWguZXhlYyh0KSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiK3QpO3ZhciBuLGU9blsxXXx8XCIgXCIscj1uWzJdfHxcIj5cIixpPW5bM118fFwiLVwiLG89bls0XXx8XCJcIix1PSEhbls1XSxhPW5bNl0mJituWzZdLGM9ISFuWzddLHM9bls4XSYmK25bOF0uc2xpY2UoMSksZj1uWzldfHxcIlwiO1wiblwiPT09Zj8oYz0hMCxmPVwiZ1wiKTpGaFtmXXx8KGY9XCJcIiksKHV8fFwiMFwiPT09ZSYmXCI9XCI9PT1yKSYmKHU9ITAsZT1cIjBcIixyPVwiPVwiKSx0aGlzLmZpbGw9ZSx0aGlzLmFsaWduPXIsdGhpcy5zaWduPWksdGhpcy5zeW1ib2w9byx0aGlzLnplcm89dSx0aGlzLndpZHRoPWEsdGhpcy5jb21tYT1jLHRoaXMucHJlY2lzaW9uPXMsdGhpcy50eXBlPWZ9ZnVuY3Rpb24gRGUodCl7cmV0dXJuIHR9ZnVuY3Rpb24gVWUodCl7ZnVuY3Rpb24gbih0KXtmdW5jdGlvbiBuKHQpe3ZhciBuLHIsdSxmPWcseD1fO2lmKFwiY1wiPT09dil4PXkodCkreCx0PVwiXCI7ZWxzZXt2YXIgYj0odD0rdCk8MDtpZih0PXkoTWF0aC5hYnModCksZCksYiYmMD09K3QmJihiPSExKSxmPShiP1wiKFwiPT09cz9zOlwiLVwiOlwiLVwiPT09c3x8XCIoXCI9PT1zP1wiXCI6cykrZix4PXgrKFwic1wiPT09dj9CaFs4K0RoLzNdOlwiXCIpKyhiJiZcIihcIj09PXM/XCIpXCI6XCJcIiksbSlmb3Iobj0tMSxyPXQubGVuZ3RoOysrbjxyOylpZig0OD4odT10LmNoYXJDb2RlQXQobikpfHx1PjU3KXt4PSg0Nj09PXU/aSt0LnNsaWNlKG4rMSk6dC5zbGljZShuKSkreCx0PXQuc2xpY2UoMCxuKTticmVha319cCYmIWwmJih0PWUodCwxLzApKTt2YXIgdz1mLmxlbmd0aCt0Lmxlbmd0aCt4Lmxlbmd0aCxNPXc8aD9uZXcgQXJyYXkoaC13KzEpLmpvaW4oYSk6XCJcIjtzd2l0Y2gocCYmbCYmKHQ9ZShNK3QsTS5sZW5ndGg/aC14Lmxlbmd0aDoxLzApLE09XCJcIiksYyl7Y2FzZVwiPFwiOnQ9Zit0K3grTTticmVhaztjYXNlXCI9XCI6dD1mK00rdCt4O2JyZWFrO2Nhc2VcIl5cIjp0PU0uc2xpY2UoMCx3PU0ubGVuZ3RoPj4xKStmK3QreCtNLnNsaWNlKHcpO2JyZWFrO2RlZmF1bHQ6dD1NK2YrdCt4fXJldHVybiBvKHQpfXZhciBhPSh0PUxlKHQpKS5maWxsLGM9dC5hbGlnbixzPXQuc2lnbixmPXQuc3ltYm9sLGw9dC56ZXJvLGg9dC53aWR0aCxwPXQuY29tbWEsZD10LnByZWNpc2lvbix2PXQudHlwZSxnPVwiJFwiPT09Zj9yWzBdOlwiI1wiPT09ZiYmL1tib3hYXS8udGVzdCh2KT9cIjBcIit2LnRvTG93ZXJDYXNlKCk6XCJcIixfPVwiJFwiPT09Zj9yWzFdOi9bJXBdLy50ZXN0KHYpP3U6XCJcIix5PUZoW3ZdLG09IXZ8fC9bZGVmZ3BycyVdLy50ZXN0KHYpO3JldHVybiBkPW51bGw9PWQ/dj82OjEyOi9bZ3Byc10vLnRlc3Qodik/TWF0aC5tYXgoMSxNYXRoLm1pbigyMSxkKSk6TWF0aC5tYXgoMCxNYXRoLm1pbigyMCxkKSksbi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0K1wiXCJ9LG59dmFyIGU9dC5ncm91cGluZyYmdC50aG91c2FuZHM/ZnVuY3Rpb24odCxuKXtyZXR1cm4gZnVuY3Rpb24oZSxyKXtmb3IodmFyIGk9ZS5sZW5ndGgsbz1bXSx1PTAsYT10WzBdLGM9MDtpPjAmJmE+MCYmKGMrYSsxPnImJihhPU1hdGgubWF4KDEsci1jKSksby5wdXNoKGUuc3Vic3RyaW5nKGktPWEsaSthKSksISgoYys9YSsxKT5yKSk7KWE9dFt1PSh1KzEpJXQubGVuZ3RoXTtyZXR1cm4gby5yZXZlcnNlKCkuam9pbihuKX19KHQuZ3JvdXBpbmcsdC50aG91c2FuZHMpOkRlLHI9dC5jdXJyZW5jeSxpPXQuZGVjaW1hbCxvPXQubnVtZXJhbHM/ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlcGxhY2UoL1swLTldL2csZnVuY3Rpb24obil7cmV0dXJuIHRbK25dfSl9fSh0Lm51bWVyYWxzKTpEZSx1PXQucGVyY2VudHx8XCIlXCI7cmV0dXJue2Zvcm1hdDpuLGZvcm1hdFByZWZpeDpmdW5jdGlvbih0LGUpe3ZhciByPW4oKHQ9TGUodCksdC50eXBlPVwiZlwiLHQpKSxpPTMqTWF0aC5tYXgoLTgsTWF0aC5taW4oOCxNYXRoLmZsb29yKFBlKGUpLzMpKSksbz1NYXRoLnBvdygxMCwtaSksdT1CaFs4K2kvM107cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiByKG8qdCkrdX19fX1mdW5jdGlvbiBPZShuKXtyZXR1cm4gWWg9VWUobiksdC5mb3JtYXQ9WWguZm9ybWF0LHQuZm9ybWF0UHJlZml4PVloLmZvcm1hdFByZWZpeCxZaH1mdW5jdGlvbiBGZSh0KXtyZXR1cm4gTWF0aC5tYXgoMCwtUGUoTWF0aC5hYnModCkpKX1mdW5jdGlvbiBJZSh0LG4pe3JldHVybiBNYXRoLm1heCgwLDMqTWF0aC5tYXgoLTgsTWF0aC5taW4oOCxNYXRoLmZsb29yKFBlKG4pLzMpKSktUGUoTWF0aC5hYnModCkpKX1mdW5jdGlvbiBZZSh0LG4pe3JldHVybiB0PU1hdGguYWJzKHQpLG49TWF0aC5hYnMobiktdCxNYXRoLm1heCgwLFBlKG4pLVBlKHQpKSsxfWZ1bmN0aW9uIEJlKCl7cmV0dXJuIG5ldyBIZX1mdW5jdGlvbiBIZSgpe3RoaXMucmVzZXQoKX1mdW5jdGlvbiBqZSh0LG4sZSl7dmFyIHI9dC5zPW4rZSxpPXItbixvPXItaTt0LnQ9bi1vKyhlLWkpfWZ1bmN0aW9uIFhlKHQpe3JldHVybiB0PjE/MDp0PC0xP01wOk1hdGguYWNvcyh0KX1mdW5jdGlvbiBWZSh0KXtyZXR1cm4gdD4xP1RwOnQ8LTE/LVRwOk1hdGguYXNpbih0KX1mdW5jdGlvbiAkZSh0KXtyZXR1cm4odD1VcCh0LzIpKSp0fWZ1bmN0aW9uIFdlKCl7fWZ1bmN0aW9uIFplKHQsbil7dCYmQnAuaGFzT3duUHJvcGVydHkodC50eXBlKSYmQnBbdC50eXBlXSh0LG4pfWZ1bmN0aW9uIEdlKHQsbixlKXt2YXIgcixpPS0xLG89dC5sZW5ndGgtZTtmb3Iobi5saW5lU3RhcnQoKTsrK2k8bzspcj10W2ldLG4ucG9pbnQoclswXSxyWzFdLHJbMl0pO24ubGluZUVuZCgpfWZ1bmN0aW9uIFFlKHQsbil7dmFyIGU9LTEscj10Lmxlbmd0aDtmb3Iobi5wb2x5Z29uU3RhcnQoKTsrK2U8cjspR2UodFtlXSxuLDEpO24ucG9seWdvbkVuZCgpfWZ1bmN0aW9uIEplKHQsbil7dCYmWXAuaGFzT3duUHJvcGVydHkodC50eXBlKT9ZcFt0LnR5cGVdKHQsbik6WmUodCxuKX1mdW5jdGlvbiBLZSgpe1hwLnBvaW50PW5yfWZ1bmN0aW9uIHRyKCl7ZXIoSGgsamgpfWZ1bmN0aW9uIG5yKHQsbil7WHAucG9pbnQ9ZXIsSGg9dCxqaD1uLFhoPXQqPUVwLFZoPVBwKG49KG4qPUVwKS8yK05wKSwkaD1VcChuKX1mdW5jdGlvbiBlcih0LG4pe249KG4qPUVwKS8yK05wO3ZhciBlPSh0Kj1FcCktWGgscj1lPj0wPzE6LTEsaT1yKmUsbz1QcChuKSx1PVVwKG4pLGE9JGgqdSxjPVZoKm8rYSpQcChpKSxzPWEqcipVcChpKTtIcC5hZGQoenAocyxjKSksWGg9dCxWaD1vLCRoPXV9ZnVuY3Rpb24gcnIodCl7cmV0dXJuW3pwKHRbMV0sdFswXSksVmUodFsyXSldfWZ1bmN0aW9uIGlyKHQpe3ZhciBuPXRbMF0sZT10WzFdLHI9UHAoZSk7cmV0dXJuW3IqUHAobikscipVcChuKSxVcChlKV19ZnVuY3Rpb24gb3IodCxuKXtyZXR1cm4gdFswXSpuWzBdK3RbMV0qblsxXSt0WzJdKm5bMl19ZnVuY3Rpb24gdXIodCxuKXtyZXR1cm5bdFsxXSpuWzJdLXRbMl0qblsxXSx0WzJdKm5bMF0tdFswXSpuWzJdLHRbMF0qblsxXS10WzFdKm5bMF1dfWZ1bmN0aW9uIGFyKHQsbil7dFswXSs9blswXSx0WzFdKz1uWzFdLHRbMl0rPW5bMl19ZnVuY3Rpb24gY3IodCxuKXtyZXR1cm5bdFswXSpuLHRbMV0qbix0WzJdKm5dfWZ1bmN0aW9uIHNyKHQpe3ZhciBuPUZwKHRbMF0qdFswXSt0WzFdKnRbMV0rdFsyXSp0WzJdKTt0WzBdLz1uLHRbMV0vPW4sdFsyXS89bn1mdW5jdGlvbiBmcih0LG4pe2VwLnB1c2gocnA9W1doPXQsR2g9dF0pLG48WmgmJihaaD1uKSxuPlFoJiYoUWg9bil9ZnVuY3Rpb24gbHIodCxuKXt2YXIgZT1pcihbdCpFcCxuKkVwXSk7aWYobnApe3ZhciByPXVyKG5wLGUpLGk9dXIoW3JbMV0sLXJbMF0sMF0scik7c3IoaSksaT1ycihpKTt2YXIgbyx1PXQtSmgsYT11PjA/MTotMSxjPWlbMF0qU3AqYSxzPUFwKHUpPjE4MDtzXihhKkpoPGMmJmM8YSp0KT8obz1pWzFdKlNwKT5RaCYmKFFoPW8pOihjPShjKzM2MCklMzYwLTE4MCxzXihhKkpoPGMmJmM8YSp0KT8obz0taVsxXSpTcCk8WmgmJihaaD1vKToobjxaaCYmKFpoPW4pLG4+UWgmJihRaD1uKSkpLHM/dDxKaD9fcihXaCx0KT5fcihXaCxHaCkmJihHaD10KTpfcih0LEdoKT5fcihXaCxHaCkmJihXaD10KTpHaD49V2g/KHQ8V2gmJihXaD10KSx0PkdoJiYoR2g9dCkpOnQ+Smg/X3IoV2gsdCk+X3IoV2gsR2gpJiYoR2g9dCk6X3IodCxHaCk+X3IoV2gsR2gpJiYoV2g9dCl9ZWxzZSBlcC5wdXNoKHJwPVtXaD10LEdoPXRdKTtuPFpoJiYoWmg9biksbj5RaCYmKFFoPW4pLG5wPWUsSmg9dH1mdW5jdGlvbiBocigpeyRwLnBvaW50PWxyfWZ1bmN0aW9uIHByKCl7cnBbMF09V2gscnBbMV09R2gsJHAucG9pbnQ9ZnIsbnA9bnVsbH1mdW5jdGlvbiBkcih0LG4pe2lmKG5wKXt2YXIgZT10LUpoO1ZwLmFkZChBcChlKT4xODA/ZSsoZT4wPzM2MDotMzYwKTplKX1lbHNlIEtoPXQsdHA9bjtYcC5wb2ludCh0LG4pLGxyKHQsbil9ZnVuY3Rpb24gdnIoKXtYcC5saW5lU3RhcnQoKX1mdW5jdGlvbiBncigpe2RyKEtoLHRwKSxYcC5saW5lRW5kKCksQXAoVnApPmJwJiYoV2g9LShHaD0xODApKSxycFswXT1XaCxycFsxXT1HaCxucD1udWxsfWZ1bmN0aW9uIF9yKHQsbil7cmV0dXJuKG4tPXQpPDA/biszNjA6bn1mdW5jdGlvbiB5cih0LG4pe3JldHVybiB0WzBdLW5bMF19ZnVuY3Rpb24gbXIodCxuKXtyZXR1cm4gdFswXTw9dFsxXT90WzBdPD1uJiZuPD10WzFdOm48dFswXXx8dFsxXTxufWZ1bmN0aW9uIHhyKHQsbil7dCo9RXA7dmFyIGU9UHAobio9RXApO2JyKGUqUHAodCksZSpVcCh0KSxVcChuKSl9ZnVuY3Rpb24gYnIodCxuLGUpe3VwKz0odC11cCkvKytpcCxhcCs9KG4tYXApL2lwLGNwKz0oZS1jcCkvaXB9ZnVuY3Rpb24gd3IoKXtXcC5wb2ludD1Ncn1mdW5jdGlvbiBNcih0LG4pe3QqPUVwO3ZhciBlPVBwKG4qPUVwKTtfcD1lKlBwKHQpLHlwPWUqVXAodCksbXA9VXAobiksV3AucG9pbnQ9VHIsYnIoX3AseXAsbXApfWZ1bmN0aW9uIFRyKHQsbil7dCo9RXA7dmFyIGU9UHAobio9RXApLHI9ZSpQcCh0KSxpPWUqVXAodCksbz1VcChuKSx1PXpwKEZwKCh1PXlwKm8tbXAqaSkqdSsodT1tcCpyLV9wKm8pKnUrKHU9X3AqaS15cCpyKSp1KSxfcCpyK3lwKmkrbXAqbyk7b3ArPXUsc3ArPXUqKF9wKyhfcD1yKSksZnArPXUqKHlwKyh5cD1pKSksbHArPXUqKG1wKyhtcD1vKSksYnIoX3AseXAsbXApfWZ1bmN0aW9uIE5yKCl7V3AucG9pbnQ9eHJ9ZnVuY3Rpb24ga3IoKXtXcC5wb2ludD1Fcn1mdW5jdGlvbiBTcigpe0FyKHZwLGdwKSxXcC5wb2ludD14cn1mdW5jdGlvbiBFcih0LG4pe3ZwPXQsZ3A9bix0Kj1FcCxuKj1FcCxXcC5wb2ludD1Bcjt2YXIgZT1QcChuKTtfcD1lKlBwKHQpLHlwPWUqVXAodCksbXA9VXAobiksYnIoX3AseXAsbXApfWZ1bmN0aW9uIEFyKHQsbil7dCo9RXA7dmFyIGU9UHAobio9RXApLHI9ZSpQcCh0KSxpPWUqVXAodCksbz1VcChuKSx1PXlwKm8tbXAqaSxhPW1wKnItX3AqbyxjPV9wKmkteXAqcixzPUZwKHUqdSthKmErYypjKSxmPVZlKHMpLGw9cyYmLWYvcztocCs9bCp1LHBwKz1sKmEsZHArPWwqYyxvcCs9ZixzcCs9ZiooX3ArKF9wPXIpKSxmcCs9ZiooeXArKHlwPWkpKSxscCs9ZioobXArKG1wPW8pKSxicihfcCx5cCxtcCl9ZnVuY3Rpb24gQ3IodCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR9fWZ1bmN0aW9uIHpyKHQsbil7ZnVuY3Rpb24gZShlLHIpe3JldHVybiBlPXQoZSxyKSxuKGVbMF0sZVsxXSl9cmV0dXJuIHQuaW52ZXJ0JiZuLmludmVydCYmKGUuaW52ZXJ0PWZ1bmN0aW9uKGUscil7cmV0dXJuKGU9bi5pbnZlcnQoZSxyKSkmJnQuaW52ZXJ0KGVbMF0sZVsxXSl9KSxlfWZ1bmN0aW9uIFByKHQsbil7cmV0dXJuW3Q+TXA/dC1rcDp0PC1NcD90K2twOnQsbl19ZnVuY3Rpb24gUnIodCxuLGUpe3JldHVybih0JT1rcCk/bnx8ZT96cihxcih0KSxEcihuLGUpKTpxcih0KTpufHxlP0RyKG4sZSk6UHJ9ZnVuY3Rpb24gTHIodCl7cmV0dXJuIGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4rPXQsW24+TXA/bi1rcDpuPC1NcD9uK2twOm4sZV19fWZ1bmN0aW9uIHFyKHQpe3ZhciBuPUxyKHQpO3JldHVybiBuLmludmVydD1McigtdCksbn1mdW5jdGlvbiBEcih0LG4pe2Z1bmN0aW9uIGUodCxuKXt2YXIgZT1QcChuKSxhPVBwKHQpKmUsYz1VcCh0KSplLHM9VXAobiksZj1zKnIrYSppO3JldHVyblt6cChjKm8tZip1LGEqci1zKmkpLFZlKGYqbytjKnUpXX12YXIgcj1QcCh0KSxpPVVwKHQpLG89UHAobiksdT1VcChuKTtyZXR1cm4gZS5pbnZlcnQ9ZnVuY3Rpb24odCxuKXt2YXIgZT1QcChuKSxhPVBwKHQpKmUsYz1VcCh0KSplLHM9VXAobiksZj1zKm8tYyp1O3JldHVyblt6cChjKm8rcyp1LGEqcitmKmkpLFZlKGYqci1hKmkpXX0sZX1mdW5jdGlvbiBVcih0KXtmdW5jdGlvbiBuKG4pe3JldHVybiBuPXQoblswXSpFcCxuWzFdKkVwKSxuWzBdKj1TcCxuWzFdKj1TcCxufXJldHVybiB0PVJyKHRbMF0qRXAsdFsxXSpFcCx0Lmxlbmd0aD4yP3RbMl0qRXA6MCksbi5pbnZlcnQ9ZnVuY3Rpb24obil7cmV0dXJuIG49dC5pbnZlcnQoblswXSpFcCxuWzFdKkVwKSxuWzBdKj1TcCxuWzFdKj1TcCxufSxufWZ1bmN0aW9uIE9yKHQsbixlLHIsaSxvKXtpZihlKXt2YXIgdT1QcChuKSxhPVVwKG4pLGM9ciplO251bGw9PWk/KGk9bityKmtwLG89bi1jLzIpOihpPUZyKHUsaSksbz1Gcih1LG8pLChyPjA/aTxvOmk+bykmJihpKz1yKmtwKSk7Zm9yKHZhciBzLGY9aTtyPjA/Zj5vOmY8bztmLT1jKXM9cnIoW3UsLWEqUHAoZiksLWEqVXAoZildKSx0LnBvaW50KHNbMF0sc1sxXSl9fWZ1bmN0aW9uIEZyKHQsbil7KG49aXIobikpWzBdLT10LHNyKG4pO3ZhciBlPVhlKC1uWzFdKTtyZXR1cm4oKC1uWzJdPDA/LWU6ZSkra3AtYnApJWtwfWZ1bmN0aW9uIElyKCl7dmFyIHQsbj1bXTtyZXR1cm57cG9pbnQ6ZnVuY3Rpb24obixlKXt0LnB1c2goW24sZV0pfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXtuLnB1c2godD1bXSl9LGxpbmVFbmQ6V2UscmVqb2luOmZ1bmN0aW9uKCl7bi5sZW5ndGg+MSYmbi5wdXNoKG4ucG9wKCkuY29uY2F0KG4uc2hpZnQoKSkpfSxyZXN1bHQ6ZnVuY3Rpb24oKXt2YXIgZT1uO3JldHVybiBuPVtdLHQ9bnVsbCxlfX19ZnVuY3Rpb24gWXIodCxuKXtyZXR1cm4gQXAodFswXS1uWzBdKTxicCYmQXAodFsxXS1uWzFdKTxicH1mdW5jdGlvbiBCcih0LG4sZSxyKXt0aGlzLng9dCx0aGlzLno9bix0aGlzLm89ZSx0aGlzLmU9cix0aGlzLnY9ITEsdGhpcy5uPXRoaXMucD1udWxsfWZ1bmN0aW9uIEhyKHQsbixlLHIsaSl7dmFyIG8sdSxhPVtdLGM9W107aWYodC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKCEoKG49dC5sZW5ndGgtMSk8PTApKXt2YXIgbixlLHI9dFswXSx1PXRbbl07aWYoWXIocix1KSl7Zm9yKGkubGluZVN0YXJ0KCksbz0wO288bjsrK28paS5wb2ludCgocj10W29dKVswXSxyWzFdKTtpLmxpbmVFbmQoKX1lbHNlIGEucHVzaChlPW5ldyBCcihyLHQsbnVsbCwhMCkpLGMucHVzaChlLm89bmV3IEJyKHIsbnVsbCxlLCExKSksYS5wdXNoKGU9bmV3IEJyKHUsdCxudWxsLCExKSksYy5wdXNoKGUubz1uZXcgQnIodSxudWxsLGUsITApKX19KSxhLmxlbmd0aCl7Zm9yKGMuc29ydChuKSxqcihhKSxqcihjKSxvPTAsdT1jLmxlbmd0aDtvPHU7KytvKWNbb10uZT1lPSFlO2Zvcih2YXIgcyxmLGw9YVswXTs7KXtmb3IodmFyIGg9bCxwPSEwO2gudjspaWYoKGg9aC5uKT09PWwpcmV0dXJuO3M9aC56LGkubGluZVN0YXJ0KCk7ZG97aWYoaC52PWguby52PSEwLGguZSl7aWYocClmb3Iobz0wLHU9cy5sZW5ndGg7bzx1OysrbylpLnBvaW50KChmPXNbb10pWzBdLGZbMV0pO2Vsc2UgcihoLngsaC5uLngsMSxpKTtoPWgubn1lbHNle2lmKHApZm9yKHM9aC5wLnosbz1zLmxlbmd0aC0xO28+PTA7LS1vKWkucG9pbnQoKGY9c1tvXSlbMF0sZlsxXSk7ZWxzZSByKGgueCxoLnAueCwtMSxpKTtoPWgucH1zPShoPWgubykueixwPSFwfXdoaWxlKCFoLnYpO2kubGluZUVuZCgpfX19ZnVuY3Rpb24ganIodCl7aWYobj10Lmxlbmd0aCl7Zm9yKHZhciBuLGUscj0wLGk9dFswXTsrK3I8bjspaS5uPWU9dFtyXSxlLnA9aSxpPWU7aS5uPWU9dFswXSxlLnA9aX19ZnVuY3Rpb24gWHIodCxuKXt2YXIgZT1uWzBdLHI9blsxXSxpPVtVcChlKSwtUHAoZSksMF0sbz0wLHU9MDt1ZC5yZXNldCgpO2Zvcih2YXIgYT0wLGM9dC5sZW5ndGg7YTxjOysrYSlpZihmPShzPXRbYV0pLmxlbmd0aClmb3IodmFyIHMsZixsPXNbZi0xXSxoPWxbMF0scD1sWzFdLzIrTnAsZD1VcChwKSx2PVBwKHApLGc9MDtnPGY7KytnLGg9eSxkPXgsdj1iLGw9Xyl7dmFyIF89c1tnXSx5PV9bMF0sbT1fWzFdLzIrTnAseD1VcChtKSxiPVBwKG0pLHc9eS1oLE09dz49MD8xOi0xLFQ9TSp3LE49VD5NcCxrPWQqeDtpZih1ZC5hZGQoenAoaypNKlVwKFQpLHYqYitrKlBwKFQpKSksbys9Tj93K00qa3A6dyxOXmg+PWVeeT49ZSl7dmFyIFM9dXIoaXIobCksaXIoXykpO3NyKFMpO3ZhciBFPXVyKGksUyk7c3IoRSk7dmFyIEE9KE5edz49MD8tMToxKSpWZShFWzJdKTsocj5BfHxyPT09QSYmKFNbMF18fFNbMV0pKSYmKHUrPU5edz49MD8xOi0xKX19cmV0dXJuKG88LWJwfHxvPGJwJiZ1ZDwtYnApXjEmdX1mdW5jdGlvbiBWcih0LG4sZSxyKXtyZXR1cm4gZnVuY3Rpb24oaSl7ZnVuY3Rpb24gbyhuLGUpe3QobixlKSYmaS5wb2ludChuLGUpfWZ1bmN0aW9uIHUodCxuKXt2LnBvaW50KHQsbil9ZnVuY3Rpb24gYSgpe3gucG9pbnQ9dSx2LmxpbmVTdGFydCgpfWZ1bmN0aW9uIGMoKXt4LnBvaW50PW8sdi5saW5lRW5kKCl9ZnVuY3Rpb24gcyh0LG4pe2QucHVzaChbdCxuXSkseS5wb2ludCh0LG4pfWZ1bmN0aW9uIGYoKXt5LmxpbmVTdGFydCgpLGQ9W119ZnVuY3Rpb24gbCgpe3MoZFswXVswXSxkWzBdWzFdKSx5LmxpbmVFbmQoKTt2YXIgdCxuLGUscixvPXkuY2xlYW4oKSx1PV8ucmVzdWx0KCksYT11Lmxlbmd0aDtpZihkLnBvcCgpLGgucHVzaChkKSxkPW51bGwsYSlpZigxJm8pe2lmKGU9dVswXSwobj1lLmxlbmd0aC0xKT4wKXtmb3IobXx8KGkucG9seWdvblN0YXJ0KCksbT0hMCksaS5saW5lU3RhcnQoKSx0PTA7dDxuOysrdClpLnBvaW50KChyPWVbdF0pWzBdLHJbMV0pO2kubGluZUVuZCgpfX1lbHNlIGE+MSYmMiZvJiZ1LnB1c2godS5wb3AoKS5jb25jYXQodS5zaGlmdCgpKSkscC5wdXNoKHUuZmlsdGVyKCRyKSl9dmFyIGgscCxkLHY9bihpKSxfPUlyKCkseT1uKF8pLG09ITEseD17cG9pbnQ6byxsaW5lU3RhcnQ6YSxsaW5lRW5kOmMscG9seWdvblN0YXJ0OmZ1bmN0aW9uKCl7eC5wb2ludD1zLHgubGluZVN0YXJ0PWYseC5saW5lRW5kPWwscD1bXSxoPVtdfSxwb2x5Z29uRW5kOmZ1bmN0aW9uKCl7eC5wb2ludD1vLHgubGluZVN0YXJ0PWEseC5saW5lRW5kPWMscD1nKHApO3ZhciB0PVhyKGgscik7cC5sZW5ndGg/KG18fChpLnBvbHlnb25TdGFydCgpLG09ITApLEhyKHAsV3IsdCxlLGkpKTp0JiYobXx8KGkucG9seWdvblN0YXJ0KCksbT0hMCksaS5saW5lU3RhcnQoKSxlKG51bGwsbnVsbCwxLGkpLGkubGluZUVuZCgpKSxtJiYoaS5wb2x5Z29uRW5kKCksbT0hMSkscD1oPW51bGx9LHNwaGVyZTpmdW5jdGlvbigpe2kucG9seWdvblN0YXJ0KCksaS5saW5lU3RhcnQoKSxlKG51bGwsbnVsbCwxLGkpLGkubGluZUVuZCgpLGkucG9seWdvbkVuZCgpfX07cmV0dXJuIHh9fWZ1bmN0aW9uICRyKHQpe3JldHVybiB0Lmxlbmd0aD4xfWZ1bmN0aW9uIFdyKHQsbil7cmV0dXJuKCh0PXQueClbMF08MD90WzFdLVRwLWJwOlRwLXRbMV0pLSgobj1uLngpWzBdPDA/blsxXS1UcC1icDpUcC1uWzFdKX1mdW5jdGlvbiBacih0KXtmdW5jdGlvbiBuKHQsbil7cmV0dXJuIFBwKHQpKlBwKG4pPml9ZnVuY3Rpb24gZSh0LG4sZSl7dmFyIHI9WzEsMCwwXSxvPXVyKGlyKHQpLGlyKG4pKSx1PW9yKG8sbyksYT1vWzBdLGM9dS1hKmE7aWYoIWMpcmV0dXJuIWUmJnQ7dmFyIHM9aSp1L2MsZj0taSphL2MsbD11cihyLG8pLGg9Y3IocixzKTthcihoLGNyKG8sZikpO3ZhciBwPWwsZD1vcihoLHApLHY9b3IocCxwKSxnPWQqZC12KihvcihoLGgpLTEpO2lmKCEoZzwwKSl7dmFyIF89RnAoZykseT1jcihwLCgtZC1fKS92KTtpZihhcih5LGgpLHk9cnIoeSksIWUpcmV0dXJuIHk7dmFyIG0seD10WzBdLGI9blswXSx3PXRbMV0sTT1uWzFdO2I8eCYmKG09eCx4PWIsYj1tKTt2YXIgVD1iLXgsTj1BcChULU1wKTxicDtpZighTiYmTTx3JiYobT13LHc9TSxNPW0pLE58fFQ8YnA/Tj93K00+MF55WzFdPChBcCh5WzBdLXgpPGJwP3c6TSk6dzw9eVsxXSYmeVsxXTw9TTpUPk1wXih4PD15WzBdJiZ5WzBdPD1iKSl7dmFyIGs9Y3IocCwoLWQrXykvdik7cmV0dXJuIGFyKGssaCksW3kscnIoayldfX19ZnVuY3Rpb24gcihuLGUpe3ZhciByPXU/dDpNcC10LGk9MDtyZXR1cm4gbjwtcj9pfD0xOm4+ciYmKGl8PTIpLGU8LXI/aXw9NDplPnImJihpfD04KSxpfXZhciBpPVBwKHQpLG89NipFcCx1PWk+MCxhPUFwKGkpPmJwO3JldHVybiBWcihuLGZ1bmN0aW9uKHQpe3ZhciBpLG8sYyxzLGY7cmV0dXJue2xpbmVTdGFydDpmdW5jdGlvbigpe3M9Yz0hMSxmPTF9LHBvaW50OmZ1bmN0aW9uKGwsaCl7dmFyIHAsZD1bbCxoXSx2PW4obCxoKSxnPXU/dj8wOnIobCxoKTp2P3IobCsobDwwP01wOi1NcCksaCk6MDtpZighaSYmKHM9Yz12KSYmdC5saW5lU3RhcnQoKSx2IT09YyYmKCEocD1lKGksZCkpfHxZcihpLHApfHxZcihkLHApKSYmKGRbMF0rPWJwLGRbMV0rPWJwLHY9bihkWzBdLGRbMV0pKSx2IT09YylmPTAsdj8odC5saW5lU3RhcnQoKSxwPWUoZCxpKSx0LnBvaW50KHBbMF0scFsxXSkpOihwPWUoaSxkKSx0LnBvaW50KHBbMF0scFsxXSksdC5saW5lRW5kKCkpLGk9cDtlbHNlIGlmKGEmJmkmJnVedil7dmFyIF87ZyZvfHwhKF89ZShkLGksITApKXx8KGY9MCx1Pyh0LmxpbmVTdGFydCgpLHQucG9pbnQoX1swXVswXSxfWzBdWzFdKSx0LnBvaW50KF9bMV1bMF0sX1sxXVsxXSksdC5saW5lRW5kKCkpOih0LnBvaW50KF9bMV1bMF0sX1sxXVsxXSksdC5saW5lRW5kKCksdC5saW5lU3RhcnQoKSx0LnBvaW50KF9bMF1bMF0sX1swXVsxXSkpKX0hdnx8aSYmWXIoaSxkKXx8dC5wb2ludChkWzBdLGRbMV0pLGk9ZCxjPXYsbz1nfSxsaW5lRW5kOmZ1bmN0aW9uKCl7YyYmdC5saW5lRW5kKCksaT1udWxsfSxjbGVhbjpmdW5jdGlvbigpe3JldHVybiBmfChzJiZjKTw8MX19fSxmdW5jdGlvbihuLGUscixpKXtPcihpLHQsbyxyLG4sZSl9LHU/WzAsLXRdOlstTXAsdC1NcF0pfWZ1bmN0aW9uIEdyKHQsbixlLHIpe2Z1bmN0aW9uIGkoaSxvKXtyZXR1cm4gdDw9aSYmaTw9ZSYmbjw9byYmbzw9cn1mdW5jdGlvbiBvKGksbyxhLHMpe3ZhciBmPTAsbD0wO2lmKG51bGw9PWl8fChmPXUoaSxhKSkhPT0obD11KG8sYSkpfHxjKGksbyk8MF5hPjApZG97cy5wb2ludCgwPT09Znx8Mz09PWY/dDplLGY+MT9yOm4pfXdoaWxlKChmPShmK2ErNCklNCkhPT1sKTtlbHNlIHMucG9pbnQob1swXSxvWzFdKX1mdW5jdGlvbiB1KHIsaSl7cmV0dXJuIEFwKHJbMF0tdCk8YnA/aT4wPzA6MzpBcChyWzBdLWUpPGJwP2k+MD8yOjE6QXAoclsxXS1uKTxicD9pPjA/MTowOmk+MD8zOjJ9ZnVuY3Rpb24gYSh0LG4pe3JldHVybiBjKHQueCxuLngpfWZ1bmN0aW9uIGModCxuKXt2YXIgZT11KHQsMSkscj11KG4sMSk7cmV0dXJuIGUhPT1yP2UtcjowPT09ZT9uWzFdLXRbMV06MT09PWU/dFswXS1uWzBdOjI9PT1lP3RbMV0tblsxXTpuWzBdLXRbMF19cmV0dXJuIGZ1bmN0aW9uKHUpe2Z1bmN0aW9uIGModCxuKXtpKHQsbikmJncucG9pbnQodCxuKX1mdW5jdGlvbiBzKG8sdSl7dmFyIGE9aShvLHUpO2lmKGwmJmgucHVzaChbbyx1XSkseClwPW8sZD11LHY9YSx4PSExLGEmJih3LmxpbmVTdGFydCgpLHcucG9pbnQobyx1KSk7ZWxzZSBpZihhJiZtKXcucG9pbnQobyx1KTtlbHNle3ZhciBjPVtfPU1hdGgubWF4KHNkLE1hdGgubWluKGNkLF8pKSx5PU1hdGgubWF4KHNkLE1hdGgubWluKGNkLHkpKV0scz1bbz1NYXRoLm1heChzZCxNYXRoLm1pbihjZCxvKSksdT1NYXRoLm1heChzZCxNYXRoLm1pbihjZCx1KSldOyFmdW5jdGlvbih0LG4sZSxyLGksbyl7dmFyIHUsYT10WzBdLGM9dFsxXSxzPTAsZj0xLGw9blswXS1hLGg9blsxXS1jO2lmKHU9ZS1hLGx8fCEodT4wKSl7aWYodS89bCxsPDApe2lmKHU8cylyZXR1cm47dTxmJiYoZj11KX1lbHNlIGlmKGw+MCl7aWYodT5mKXJldHVybjt1PnMmJihzPXUpfWlmKHU9aS1hLGx8fCEodTwwKSl7aWYodS89bCxsPDApe2lmKHU+ZilyZXR1cm47dT5zJiYocz11KX1lbHNlIGlmKGw+MCl7aWYodTxzKXJldHVybjt1PGYmJihmPXUpfWlmKHU9ci1jLGh8fCEodT4wKSl7aWYodS89aCxoPDApe2lmKHU8cylyZXR1cm47dTxmJiYoZj11KX1lbHNlIGlmKGg+MCl7aWYodT5mKXJldHVybjt1PnMmJihzPXUpfWlmKHU9by1jLGh8fCEodTwwKSl7aWYodS89aCxoPDApe2lmKHU+ZilyZXR1cm47dT5zJiYocz11KX1lbHNlIGlmKGg+MCl7aWYodTxzKXJldHVybjt1PGYmJihmPXUpfXJldHVybiBzPjAmJih0WzBdPWErcypsLHRbMV09YytzKmgpLGY8MSYmKG5bMF09YStmKmwsblsxXT1jK2YqaCksITB9fX19fShjLHMsdCxuLGUscik/YSYmKHcubGluZVN0YXJ0KCksdy5wb2ludChvLHUpLGI9ITEpOihtfHwody5saW5lU3RhcnQoKSx3LnBvaW50KGNbMF0sY1sxXSkpLHcucG9pbnQoc1swXSxzWzFdKSxhfHx3LmxpbmVFbmQoKSxiPSExKX1fPW8seT11LG09YX12YXIgZixsLGgscCxkLHYsXyx5LG0seCxiLHc9dSxNPUlyKCksVD17cG9pbnQ6YyxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXtULnBvaW50PXMsbCYmbC5wdXNoKGg9W10pLHg9ITAsbT0hMSxfPXk9TmFOfSxsaW5lRW5kOmZ1bmN0aW9uKCl7ZiYmKHMocCxkKSx2JiZtJiZNLnJlam9pbigpLGYucHVzaChNLnJlc3VsdCgpKSksVC5wb2ludD1jLG0mJncubGluZUVuZCgpfSxwb2x5Z29uU3RhcnQ6ZnVuY3Rpb24oKXt3PU0sZj1bXSxsPVtdLGI9ITB9LHBvbHlnb25FbmQ6ZnVuY3Rpb24oKXt2YXIgbj1mdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCxpPWwubGVuZ3RoO2U8aTsrK2UpZm9yKHZhciBvLHUsYT1sW2VdLGM9MSxzPWEubGVuZ3RoLGY9YVswXSxoPWZbMF0scD1mWzFdO2M8czsrK2Mpbz1oLHU9cCxoPShmPWFbY10pWzBdLHA9ZlsxXSx1PD1yP3A+ciYmKGgtbykqKHItdSk+KHAtdSkqKHQtbykmJisrbjpwPD1yJiYoaC1vKSooci11KTwocC11KSoodC1vKSYmLS1uO3JldHVybiBufSgpLGU9YiYmbixpPShmPWcoZikpLmxlbmd0aDsoZXx8aSkmJih1LnBvbHlnb25TdGFydCgpLGUmJih1LmxpbmVTdGFydCgpLG8obnVsbCxudWxsLDEsdSksdS5saW5lRW5kKCkpLGkmJkhyKGYsYSxuLG8sdSksdS5wb2x5Z29uRW5kKCkpLHc9dSxmPWw9aD1udWxsfX07cmV0dXJuIFR9fWZ1bmN0aW9uIFFyKCl7bGQucG9pbnQ9bGQubGluZUVuZD1XZX1mdW5jdGlvbiBKcih0LG4pe1pwPXQqPUVwLEdwPVVwKG4qPUVwKSxRcD1QcChuKSxsZC5wb2ludD1Lcn1mdW5jdGlvbiBLcih0LG4pe3QqPUVwO3ZhciBlPVVwKG4qPUVwKSxyPVBwKG4pLGk9QXAodC1acCksbz1QcChpKSx1PXIqVXAoaSksYT1RcCplLUdwKnIqbyxjPUdwKmUrUXAqcipvO2ZkLmFkZCh6cChGcCh1KnUrYSphKSxjKSksWnA9dCxHcD1lLFFwPXJ9ZnVuY3Rpb24gdGkodCl7cmV0dXJuIGZkLnJlc2V0KCksSmUodCxsZCksK2ZkfWZ1bmN0aW9uIG5pKHQsbil7cmV0dXJuIGhkWzBdPXQsaGRbMV09bix0aShwZCl9ZnVuY3Rpb24gZWkodCxuKXtyZXR1cm4hKCF0fHwhdmQuaGFzT3duUHJvcGVydHkodC50eXBlKSkmJnZkW3QudHlwZV0odCxuKX1mdW5jdGlvbiByaSh0LG4pe3JldHVybiAwPT09bmkodCxuKX1mdW5jdGlvbiBpaSh0LG4pe3ZhciBlPW5pKHRbMF0sdFsxXSk7cmV0dXJuIG5pKHRbMF0sbikrbmkobix0WzFdKTw9ZSticH1mdW5jdGlvbiBvaSh0LG4pe3JldHVybiEhWHIodC5tYXAodWkpLGFpKG4pKX1mdW5jdGlvbiB1aSh0KXtyZXR1cm4odD10Lm1hcChhaSkpLnBvcCgpLHR9ZnVuY3Rpb24gYWkodCl7cmV0dXJuW3RbMF0qRXAsdFsxXSpFcF19ZnVuY3Rpb24gY2kodCxuLGUpe3ZhciByPWYodCxuLWJwLGUpLmNvbmNhdChuKTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHIubWFwKGZ1bmN0aW9uKG4pe3JldHVyblt0LG5dfSl9fWZ1bmN0aW9uIHNpKHQsbixlKXt2YXIgcj1mKHQsbi1icCxlKS5jb25jYXQobik7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiByLm1hcChmdW5jdGlvbihuKXtyZXR1cm5bbix0XX0pfX1mdW5jdGlvbiBmaSgpe2Z1bmN0aW9uIHQoKXtyZXR1cm57dHlwZTpcIk11bHRpTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOm4oKX19ZnVuY3Rpb24gbigpe3JldHVybiBmKFJwKG8vXykqXyxpLF8pLm1hcChwKS5jb25jYXQoZihScChzL3kpKnksYyx5KS5tYXAoZCkpLmNvbmNhdChmKFJwKHIvdikqdixlLHYpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gQXAodCVfKT5icH0pLm1hcChsKSkuY29uY2F0KGYoUnAoYS9nKSpnLHUsZykuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBBcCh0JXkpPmJwfSkubWFwKGgpKX12YXIgZSxyLGksbyx1LGEsYyxzLGwsaCxwLGQsdj0xMCxnPXYsXz05MCx5PTM2MCxtPTIuNTtyZXR1cm4gdC5saW5lcz1mdW5jdGlvbigpe3JldHVybiBuKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOlwiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOnR9fSl9LHQub3V0bGluZT1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiUG9seWdvblwiLGNvb3JkaW5hdGVzOltwKG8pLmNvbmNhdChkKGMpLnNsaWNlKDEpLHAoaSkucmV2ZXJzZSgpLnNsaWNlKDEpLGQocykucmV2ZXJzZSgpLnNsaWNlKDEpKV19fSx0LmV4dGVudD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90LmV4dGVudE1ham9yKG4pLmV4dGVudE1pbm9yKG4pOnQuZXh0ZW50TWlub3IoKX0sdC5leHRlbnRNYWpvcj1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obz0rblswXVswXSxpPStuWzFdWzBdLHM9K25bMF1bMV0sYz0rblsxXVsxXSxvPmkmJihuPW8sbz1pLGk9bikscz5jJiYobj1zLHM9YyxjPW4pLHQucHJlY2lzaW9uKG0pKTpbW28sc10sW2ksY11dfSx0LmV4dGVudE1pbm9yPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhyPStuWzBdWzBdLGU9K25bMV1bMF0sYT0rblswXVsxXSx1PStuWzFdWzFdLHI+ZSYmKG49cixyPWUsZT1uKSxhPnUmJihuPWEsYT11LHU9biksdC5wcmVjaXNpb24obSkpOltbcixhXSxbZSx1XV19LHQuc3RlcD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90LnN0ZXBNYWpvcihuKS5zdGVwTWlub3Iobik6dC5zdGVwTWlub3IoKX0sdC5zdGVwTWFqb3I9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KF89K25bMF0seT0rblsxXSx0KTpbXyx5XX0sdC5zdGVwTWlub3I9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHY9K25bMF0sZz0rblsxXSx0KTpbdixnXX0sdC5wcmVjaXNpb249ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG09K24sbD1jaShhLHUsOTApLGg9c2kocixlLG0pLHA9Y2kocyxjLDkwKSxkPXNpKG8saSxtKSx0KTptfSx0LmV4dGVudE1ham9yKFtbLTE4MCwtOTArYnBdLFsxODAsOTAtYnBdXSkuZXh0ZW50TWlub3IoW1stMTgwLC04MC1icF0sWzE4MCw4MCticF1dKX1mdW5jdGlvbiBsaSh0KXtyZXR1cm4gdH1mdW5jdGlvbiBoaSgpe3lkLnBvaW50PXBpfWZ1bmN0aW9uIHBpKHQsbil7eWQucG9pbnQ9ZGksSnA9dGQ9dCxLcD1uZD1ufWZ1bmN0aW9uIGRpKHQsbil7X2QuYWRkKG5kKnQtdGQqbiksdGQ9dCxuZD1ufWZ1bmN0aW9uIHZpKCl7ZGkoSnAsS3ApfWZ1bmN0aW9uIGdpKHQsbil7VGQrPXQsTmQrPW4sKytrZH1mdW5jdGlvbiBfaSgpe1JkLnBvaW50PXlpfWZ1bmN0aW9uIHlpKHQsbil7UmQucG9pbnQ9bWksZ2koaWQ9dCxvZD1uKX1mdW5jdGlvbiBtaSh0LG4pe3ZhciBlPXQtaWQscj1uLW9kLGk9RnAoZSplK3Iqcik7U2QrPWkqKGlkK3QpLzIsRWQrPWkqKG9kK24pLzIsQWQrPWksZ2koaWQ9dCxvZD1uKX1mdW5jdGlvbiB4aSgpe1JkLnBvaW50PWdpfWZ1bmN0aW9uIGJpKCl7UmQucG9pbnQ9TWl9ZnVuY3Rpb24gd2koKXtUaShlZCxyZCl9ZnVuY3Rpb24gTWkodCxuKXtSZC5wb2ludD1UaSxnaShlZD1pZD10LHJkPW9kPW4pfWZ1bmN0aW9uIFRpKHQsbil7dmFyIGU9dC1pZCxyPW4tb2QsaT1GcChlKmUrcipyKTtTZCs9aSooaWQrdCkvMixFZCs9aSoob2QrbikvMixBZCs9aSxDZCs9KGk9b2QqdC1pZCpuKSooaWQrdCksemQrPWkqKG9kK24pLFBkKz0zKmksZ2koaWQ9dCxvZD1uKX1mdW5jdGlvbiBOaSh0KXt0aGlzLl9jb250ZXh0PXR9ZnVuY3Rpb24ga2kodCxuKXtJZC5wb2ludD1TaSxxZD1VZD10LERkPU9kPW59ZnVuY3Rpb24gU2kodCxuKXtVZC09dCxPZC09bixGZC5hZGQoRnAoVWQqVWQrT2QqT2QpKSxVZD10LE9kPW59ZnVuY3Rpb24gRWkoKXt0aGlzLl9zdHJpbmc9W119ZnVuY3Rpb24gQWkodCl7cmV0dXJuXCJtMCxcIit0K1wiYVwiK3QrXCIsXCIrdCtcIiAwIDEsMSAwLFwiKy0yKnQrXCJhXCIrdCtcIixcIit0K1wiIDAgMSwxIDAsXCIrMip0K1wielwifWZ1bmN0aW9uIENpKHQpe3JldHVybiBmdW5jdGlvbihuKXt2YXIgZT1uZXcgemk7Zm9yKHZhciByIGluIHQpZVtyXT10W3JdO3JldHVybiBlLnN0cmVhbT1uLGV9fWZ1bmN0aW9uIHppKCl7fWZ1bmN0aW9uIFBpKHQsbixlKXt2YXIgcj10LmNsaXBFeHRlbnQmJnQuY2xpcEV4dGVudCgpO3JldHVybiB0LnNjYWxlKDE1MCkudHJhbnNsYXRlKFswLDBdKSxudWxsIT1yJiZ0LmNsaXBFeHRlbnQobnVsbCksSmUoZSx0LnN0cmVhbShNZCkpLG4oTWQucmVzdWx0KCkpLG51bGwhPXImJnQuY2xpcEV4dGVudChyKSx0fWZ1bmN0aW9uIFJpKHQsbixlKXtyZXR1cm4gUGkodCxmdW5jdGlvbihlKXt2YXIgcj1uWzFdWzBdLW5bMF1bMF0saT1uWzFdWzFdLW5bMF1bMV0sbz1NYXRoLm1pbihyLyhlWzFdWzBdLWVbMF1bMF0pLGkvKGVbMV1bMV0tZVswXVsxXSkpLHU9K25bMF1bMF0rKHItbyooZVsxXVswXStlWzBdWzBdKSkvMixhPStuWzBdWzFdKyhpLW8qKGVbMV1bMV0rZVswXVsxXSkpLzI7dC5zY2FsZSgxNTAqbykudHJhbnNsYXRlKFt1LGFdKX0sZSl9ZnVuY3Rpb24gTGkodCxuLGUpe3JldHVybiBSaSh0LFtbMCwwXSxuXSxlKX1mdW5jdGlvbiBxaSh0LG4sZSl7cmV0dXJuIFBpKHQsZnVuY3Rpb24oZSl7dmFyIHI9K24saT1yLyhlWzFdWzBdLWVbMF1bMF0pLG89KHItaSooZVsxXVswXStlWzBdWzBdKSkvMix1PS1pKmVbMF1bMV07dC5zY2FsZSgxNTAqaSkudHJhbnNsYXRlKFtvLHVdKX0sZSl9ZnVuY3Rpb24gRGkodCxuLGUpe3JldHVybiBQaSh0LGZ1bmN0aW9uKGUpe3ZhciByPStuLGk9ci8oZVsxXVsxXS1lWzBdWzFdKSxvPS1pKmVbMF1bMF0sdT0oci1pKihlWzFdWzFdK2VbMF1bMV0pKS8yO3Quc2NhbGUoMTUwKmkpLnRyYW5zbGF0ZShbbyx1XSl9LGUpfWZ1bmN0aW9uIFVpKHQsbil7cmV0dXJuK24/ZnVuY3Rpb24odCxuKXtmdW5jdGlvbiBlKHIsaSxvLHUsYSxjLHMsZixsLGgscCxkLHYsZyl7dmFyIF89cy1yLHk9Zi1pLG09XypfK3kqeTtpZihtPjQqbiYmdi0tKXt2YXIgeD11K2gsYj1hK3Asdz1jK2QsTT1GcCh4KngrYipiK3cqdyksVD1WZSh3Lz1NKSxOPUFwKEFwKHcpLTEpPGJwfHxBcChvLWwpPGJwPyhvK2wpLzI6enAoYix4KSxrPXQoTixUKSxTPWtbMF0sRT1rWzFdLEE9Uy1yLEM9RS1pLHo9eSpBLV8qQzsoeip6L20+bnx8QXAoKF8qQSt5KkMpL20tLjUpPi4zfHx1KmgrYSpwK2MqZDxCZCkmJihlKHIsaSxvLHUsYSxjLFMsRSxOLHgvPU0sYi89TSx3LHYsZyksZy5wb2ludChTLEUpLGUoUyxFLE4seCxiLHcscyxmLGwsaCxwLGQsdixnKSl9fXJldHVybiBmdW5jdGlvbihuKXtmdW5jdGlvbiByKGUscil7ZT10KGUsciksbi5wb2ludChlWzBdLGVbMV0pfWZ1bmN0aW9uIGkoKXtfPU5hTix3LnBvaW50PW8sbi5saW5lU3RhcnQoKX1mdW5jdGlvbiBvKHIsaSl7dmFyIG89aXIoW3IsaV0pLHU9dChyLGkpO2UoXyx5LGcsbSx4LGIsXz11WzBdLHk9dVsxXSxnPXIsbT1vWzBdLHg9b1sxXSxiPW9bMl0sWWQsbiksbi5wb2ludChfLHkpfWZ1bmN0aW9uIHUoKXt3LnBvaW50PXIsbi5saW5lRW5kKCl9ZnVuY3Rpb24gYSgpe2koKSx3LnBvaW50PWMsdy5saW5lRW5kPXN9ZnVuY3Rpb24gYyh0LG4pe28oZj10LG4pLGw9XyxoPXkscD1tLGQ9eCx2PWIsdy5wb2ludD1vfWZ1bmN0aW9uIHMoKXtlKF8seSxnLG0seCxiLGwsaCxmLHAsZCx2LFlkLG4pLHcubGluZUVuZD11LHUoKX12YXIgZixsLGgscCxkLHYsZyxfLHksbSx4LGIsdz17cG9pbnQ6cixsaW5lU3RhcnQ6aSxsaW5lRW5kOnUscG9seWdvblN0YXJ0OmZ1bmN0aW9uKCl7bi5wb2x5Z29uU3RhcnQoKSx3LmxpbmVTdGFydD1hfSxwb2x5Z29uRW5kOmZ1bmN0aW9uKCl7bi5wb2x5Z29uRW5kKCksdy5saW5lU3RhcnQ9aX19O3JldHVybiB3fX0odCxuKTpmdW5jdGlvbih0KXtyZXR1cm4gQ2koe3BvaW50OmZ1bmN0aW9uKG4sZSl7bj10KG4sZSksdGhpcy5zdHJlYW0ucG9pbnQoblswXSxuWzFdKX19KX0odCl9ZnVuY3Rpb24gT2kodCl7cmV0dXJuIEZpKGZ1bmN0aW9uKCl7cmV0dXJuIHR9KSgpfWZ1bmN0aW9uIEZpKHQpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIHQ9cyh0WzBdKkVwLHRbMV0qRXApLFt0WzBdKnYrdSxhLXRbMV0qdl19ZnVuY3Rpb24gZSh0LG4pe3JldHVybiB0PW8odCxuKSxbdFswXSp2K3UsYS10WzFdKnZdfWZ1bmN0aW9uIHIoKXtzPXpyKGM9UnIoeCxiLHcpLG8pO3ZhciB0PW8oeSxtKTtyZXR1cm4gdT1nLXRbMF0qdixhPV8rdFsxXSp2LGkoKX1mdW5jdGlvbiBpKCl7cmV0dXJuIHA9ZD1udWxsLG59dmFyIG8sdSxhLGMscyxmLGwsaCxwLGQsdj0xNTAsZz00ODAsXz0yNTAseT0wLG09MCx4PTAsYj0wLHc9MCxNPW51bGwsVD1hZCxOPW51bGwsaz1saSxTPS41LEU9VWkoZSxTKTtyZXR1cm4gbi5zdHJlYW09ZnVuY3Rpb24odCl7cmV0dXJuIHAmJmQ9PT10P3A6cD1IZChmdW5jdGlvbih0KXtyZXR1cm4gQ2koe3BvaW50OmZ1bmN0aW9uKG4sZSl7dmFyIHI9dChuLGUpO3JldHVybiB0aGlzLnN0cmVhbS5wb2ludChyWzBdLHJbMV0pfX0pfShjKShUKEUoayhkPXQpKSkpKX0sbi5wcmVjbGlwPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhUPXQsTT12b2lkIDAsaSgpKTpUfSxuLnBvc3RjbGlwPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhrPXQsTj1mPWw9aD1udWxsLGkoKSk6a30sbi5jbGlwQW5nbGU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KFQ9K3Q/WnIoTT10KkVwKTooTT1udWxsLGFkKSxpKCkpOk0qU3B9LG4uY2xpcEV4dGVudD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaz1udWxsPT10PyhOPWY9bD1oPW51bGwsbGkpOkdyKE49K3RbMF1bMF0sZj0rdFswXVsxXSxsPSt0WzFdWzBdLGg9K3RbMV1bMV0pLGkoKSk6bnVsbD09Tj9udWxsOltbTixmXSxbbCxoXV19LG4uc2NhbGU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHY9K3QscigpKTp2fSxuLnRyYW5zbGF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZz0rdFswXSxfPSt0WzFdLHIoKSk6W2csX119LG4uY2VudGVyPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh5PXRbMF0lMzYwKkVwLG09dFsxXSUzNjAqRXAscigpKTpbeSpTcCxtKlNwXX0sbi5yb3RhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHg9dFswXSUzNjAqRXAsYj10WzFdJTM2MCpFcCx3PXQubGVuZ3RoPjI/dFsyXSUzNjAqRXA6MCxyKCkpOlt4KlNwLGIqU3AsdypTcF19LG4ucHJlY2lzaW9uPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhFPVVpKGUsUz10KnQpLGkoKSk6RnAoUyl9LG4uZml0RXh0ZW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFJpKG4sdCxlKX0sbi5maXRTaXplPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIExpKG4sdCxlKX0sbi5maXRXaWR0aD1mdW5jdGlvbih0LGUpe3JldHVybiBxaShuLHQsZSl9LG4uZml0SGVpZ2h0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIERpKG4sdCxlKX0sZnVuY3Rpb24oKXtyZXR1cm4gbz10LmFwcGx5KHRoaXMsYXJndW1lbnRzKSxuLmludmVydD1vLmludmVydCYmZnVuY3Rpb24odCl7cmV0dXJuKHQ9cy5pbnZlcnQoKHRbMF0tdSkvdiwoYS10WzFdKS92KSkmJlt0WzBdKlNwLHRbMV0qU3BdfSxyKCl9fWZ1bmN0aW9uIElpKHQpe3ZhciBuPTAsZT1NcC8zLHI9RmkodCksaT1yKG4sZSk7cmV0dXJuIGkucGFyYWxsZWxzPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3Iobj10WzBdKkVwLGU9dFsxXSpFcCk6W24qU3AsZSpTcF19LGl9ZnVuY3Rpb24gWWkodCxuKXtmdW5jdGlvbiBlKHQsbil7dmFyIGU9RnAoby0yKmkqVXAobikpL2k7cmV0dXJuW2UqVXAodCo9aSksdS1lKlBwKHQpXX12YXIgcj1VcCh0KSxpPShyK1VwKG4pKS8yO2lmKEFwKGkpPGJwKXJldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBuKHQsbil7cmV0dXJuW3QqZSxVcChuKS9lXX12YXIgZT1QcCh0KTtyZXR1cm4gbi5pbnZlcnQ9ZnVuY3Rpb24odCxuKXtyZXR1cm5bdC9lLFZlKG4qZSldfSxufSh0KTt2YXIgbz0xK3IqKDIqaS1yKSx1PUZwKG8pL2k7cmV0dXJuIGUuaW52ZXJ0PWZ1bmN0aW9uKHQsbil7dmFyIGU9dS1uO3JldHVyblt6cCh0LEFwKGUpKS9pKk9wKGUpLFZlKChvLSh0KnQrZSplKSppKmkpLygyKmkpKV19LGV9ZnVuY3Rpb24gQmkoKXtyZXR1cm4gSWkoWWkpLnNjYWxlKDE1NS40MjQpLmNlbnRlcihbMCwzMy42NDQyXSl9ZnVuY3Rpb24gSGkoKXtyZXR1cm4gQmkoKS5wYXJhbGxlbHMoWzI5LjUsNDUuNV0pLnNjYWxlKDEwNzApLnRyYW5zbGF0ZShbNDgwLDI1MF0pLnJvdGF0ZShbOTYsMF0pLmNlbnRlcihbLS42LDM4LjddKX1mdW5jdGlvbiBqaSh0KXtyZXR1cm4gZnVuY3Rpb24obixlKXt2YXIgcj1QcChuKSxpPVBwKGUpLG89dChyKmkpO3JldHVybltvKmkqVXAobiksbypVcChlKV19fWZ1bmN0aW9uIFhpKHQpe3JldHVybiBmdW5jdGlvbihuLGUpe3ZhciByPUZwKG4qbitlKmUpLGk9dChyKSxvPVVwKGkpLHU9UHAoaSk7cmV0dXJuW3pwKG4qbyxyKnUpLFZlKHImJmUqby9yKV19fWZ1bmN0aW9uIFZpKHQsbil7cmV0dXJuW3QscXAoSXAoKFRwK24pLzIpKV19ZnVuY3Rpb24gJGkodCl7ZnVuY3Rpb24gbigpe3ZhciBuPU1wKmEoKSx1PW8oVXIoby5yb3RhdGUoKSkuaW52ZXJ0KFswLDBdKSk7cmV0dXJuIHMobnVsbD09Zj9bW3VbMF0tbix1WzFdLW5dLFt1WzBdK24sdVsxXStuXV06dD09PVZpP1tbTWF0aC5tYXgodVswXS1uLGYpLGVdLFtNYXRoLm1pbih1WzBdK24sciksaV1dOltbZixNYXRoLm1heCh1WzFdLW4sZSldLFtyLE1hdGgubWluKHVbMV0rbixpKV1dKX12YXIgZSxyLGksbz1PaSh0KSx1PW8uY2VudGVyLGE9by5zY2FsZSxjPW8udHJhbnNsYXRlLHM9by5jbGlwRXh0ZW50LGY9bnVsbDtyZXR1cm4gby5zY2FsZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYSh0KSxuKCkpOmEoKX0sby50cmFuc2xhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGModCksbigpKTpjKCl9LG8uY2VudGVyPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh1KHQpLG4oKSk6dSgpfSxvLmNsaXBFeHRlbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG51bGw9PXQ/Zj1lPXI9aT1udWxsOihmPSt0WzBdWzBdLGU9K3RbMF1bMV0scj0rdFsxXVswXSxpPSt0WzFdWzFdKSxuKCkpOm51bGw9PWY/bnVsbDpbW2YsZV0sW3IsaV1dfSxuKCl9ZnVuY3Rpb24gV2kodCl7cmV0dXJuIElwKChUcCt0KS8yKX1mdW5jdGlvbiBaaSh0LG4pe2Z1bmN0aW9uIGUodCxuKXtvPjA/bjwtVHArYnAmJihuPS1UcCticCk6bj5UcC1icCYmKG49VHAtYnApO3ZhciBlPW8vRHAoV2kobiksaSk7cmV0dXJuW2UqVXAoaSp0KSxvLWUqUHAoaSp0KV19dmFyIHI9UHAodCksaT10PT09bj9VcCh0KTpxcChyL1BwKG4pKS9xcChXaShuKS9XaSh0KSksbz1yKkRwKFdpKHQpLGkpL2k7cmV0dXJuIGk/KGUuaW52ZXJ0PWZ1bmN0aW9uKHQsbil7dmFyIGU9by1uLHI9T3AoaSkqRnAodCp0K2UqZSk7cmV0dXJuW3pwKHQsQXAoZSkpL2kqT3AoZSksMipDcChEcChvL3IsMS9pKSktVHBdfSxlKTpWaX1mdW5jdGlvbiBHaSh0LG4pe3JldHVyblt0LG5dfWZ1bmN0aW9uIFFpKHQsbil7ZnVuY3Rpb24gZSh0LG4pe3ZhciBlPW8tbixyPWkqdDtyZXR1cm5bZSpVcChyKSxvLWUqUHAocildfXZhciByPVBwKHQpLGk9dD09PW4/VXAodCk6KHItUHAobikpLyhuLXQpLG89ci9pK3Q7cmV0dXJuIEFwKGkpPGJwP0dpOihlLmludmVydD1mdW5jdGlvbih0LG4pe3ZhciBlPW8tbjtyZXR1cm5benAodCxBcChlKSkvaSpPcChlKSxvLU9wKGkpKkZwKHQqdCtlKmUpXX0sZSl9ZnVuY3Rpb24gSmkodCxuKXt2YXIgZT1QcChuKSxyPVBwKHQpKmU7cmV0dXJuW2UqVXAodCkvcixVcChuKS9yXX1mdW5jdGlvbiBLaSh0LG4sZSxyKXtyZXR1cm4gMT09PXQmJjE9PT1uJiYwPT09ZSYmMD09PXI/bGk6Q2koe3BvaW50OmZ1bmN0aW9uKGksbyl7dGhpcy5zdHJlYW0ucG9pbnQoaSp0K2UsbypuK3IpfX0pfWZ1bmN0aW9uIHRvKHQsbil7dmFyIGU9bipuLHI9ZSplO3JldHVyblt0KiguODcwNy0uMTMxOTc5KmUrcioociooLjAwMzk3MSplLS4wMDE1MjkqciktLjAxMzc5MSkpLG4qKDEuMDA3MjI2K2UqKC4wMTUwODUrciooLjAyODg3NCplLS4wNDQ0NzUtLjAwNTkxNipyKSkpXX1mdW5jdGlvbiBubyh0LG4pe3JldHVybltQcChuKSpVcCh0KSxVcChuKV19ZnVuY3Rpb24gZW8odCxuKXt2YXIgZT1QcChuKSxyPTErUHAodCkqZTtyZXR1cm5bZSpVcCh0KS9yLFVwKG4pL3JdfWZ1bmN0aW9uIHJvKHQsbil7cmV0dXJuW3FwKElwKChUcCtuKS8yKSksLXRdfWZ1bmN0aW9uIGlvKHQsbil7cmV0dXJuIHQucGFyZW50PT09bi5wYXJlbnQ/MToyfWZ1bmN0aW9uIG9vKHQsbil7cmV0dXJuIHQrbi54fWZ1bmN0aW9uIHVvKHQsbil7cmV0dXJuIE1hdGgubWF4KHQsbi55KX1mdW5jdGlvbiBhbyh0KXt2YXIgbj0wLGU9dC5jaGlsZHJlbixyPWUmJmUubGVuZ3RoO2lmKHIpZm9yKDstLXI+PTA7KW4rPWVbcl0udmFsdWU7ZWxzZSBuPTE7dC52YWx1ZT1ufWZ1bmN0aW9uIGNvKHQsbil7dmFyIGUscixpLG8sdSxhPW5ldyBobyh0KSxjPSt0LnZhbHVlJiYoYS52YWx1ZT10LnZhbHVlKSxzPVthXTtmb3IobnVsbD09biYmKG49c28pO2U9cy5wb3AoKTspaWYoYyYmKGUudmFsdWU9K2UuZGF0YS52YWx1ZSksKGk9bihlLmRhdGEpKSYmKHU9aS5sZW5ndGgpKWZvcihlLmNoaWxkcmVuPW5ldyBBcnJheSh1KSxvPXUtMTtvPj0wOy0tbylzLnB1c2gocj1lLmNoaWxkcmVuW29dPW5ldyBobyhpW29dKSksci5wYXJlbnQ9ZSxyLmRlcHRoPWUuZGVwdGgrMTtyZXR1cm4gYS5lYWNoQmVmb3JlKGxvKX1mdW5jdGlvbiBzbyh0KXtyZXR1cm4gdC5jaGlsZHJlbn1mdW5jdGlvbiBmbyh0KXt0LmRhdGE9dC5kYXRhLmRhdGF9ZnVuY3Rpb24gbG8odCl7dmFyIG49MDtkb3t0LmhlaWdodD1ufXdoaWxlKCh0PXQucGFyZW50KSYmdC5oZWlnaHQ8KytuKX1mdW5jdGlvbiBobyh0KXt0aGlzLmRhdGE9dCx0aGlzLmRlcHRoPXRoaXMuaGVpZ2h0PTAsdGhpcy5wYXJlbnQ9bnVsbH1mdW5jdGlvbiBwbyh0KXtmb3IodmFyIG4sZSxyPTAsaT0odD1mdW5jdGlvbih0KXtmb3IodmFyIG4sZSxyPXQubGVuZ3RoO3I7KWU9TWF0aC5yYW5kb20oKSpyLS18MCxuPXRbcl0sdFtyXT10W2VdLHRbZV09bjtyZXR1cm4gdH0oVmQuY2FsbCh0KSkpLmxlbmd0aCxvPVtdO3I8aTspbj10W3JdLGUmJmdvKGUsbik/KytyOihlPWZ1bmN0aW9uKHQpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0KXtyZXR1cm57eDp0LngseTp0Lnkscjp0LnJ9fSh0WzBdKTtjYXNlIDI6cmV0dXJuIHlvKHRbMF0sdFsxXSk7Y2FzZSAzOnJldHVybiBtbyh0WzBdLHRbMV0sdFsyXSl9fShvPWZ1bmN0aW9uKHQsbil7dmFyIGUscjtpZihfbyhuLHQpKXJldHVybltuXTtmb3IoZT0wO2U8dC5sZW5ndGg7KytlKWlmKHZvKG4sdFtlXSkmJl9vKHlvKHRbZV0sbiksdCkpcmV0dXJuW3RbZV0sbl07Zm9yKGU9MDtlPHQubGVuZ3RoLTE7KytlKWZvcihyPWUrMTtyPHQubGVuZ3RoOysrcilpZih2byh5byh0W2VdLHRbcl0pLG4pJiZ2byh5byh0W2VdLG4pLHRbcl0pJiZ2byh5byh0W3JdLG4pLHRbZV0pJiZfbyhtbyh0W2VdLHRbcl0sbiksdCkpcmV0dXJuW3RbZV0sdFtyXSxuXTt0aHJvdyBuZXcgRXJyb3J9KG8sbikpLHI9MCk7cmV0dXJuIGV9ZnVuY3Rpb24gdm8odCxuKXt2YXIgZT10LnItbi5yLHI9bi54LXQueCxpPW4ueS10Lnk7cmV0dXJuIGU8MHx8ZSplPHIqcitpKml9ZnVuY3Rpb24gZ28odCxuKXt2YXIgZT10LnItbi5yKzFlLTYscj1uLngtdC54LGk9bi55LXQueTtyZXR1cm4gZT4wJiZlKmU+cipyK2kqaX1mdW5jdGlvbiBfbyh0LG4pe2Zvcih2YXIgZT0wO2U8bi5sZW5ndGg7KytlKWlmKCFnbyh0LG5bZV0pKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHlvKHQsbil7dmFyIGU9dC54LHI9dC55LGk9dC5yLG89bi54LHU9bi55LGE9bi5yLGM9by1lLHM9dS1yLGY9YS1pLGw9TWF0aC5zcXJ0KGMqYytzKnMpO3JldHVybnt4OihlK28rYy9sKmYpLzIseToocit1K3MvbCpmKS8yLHI6KGwraSthKS8yfX1mdW5jdGlvbiBtbyh0LG4sZSl7dmFyIHI9dC54LGk9dC55LG89dC5yLHU9bi54LGE9bi55LGM9bi5yLHM9ZS54LGY9ZS55LGw9ZS5yLGg9ci11LHA9ci1zLGQ9aS1hLHY9aS1mLGc9Yy1vLF89bC1vLHk9cipyK2kqaS1vKm8sbT15LXUqdS1hKmErYypjLHg9eS1zKnMtZipmK2wqbCxiPXAqZC1oKnYsdz0oZCp4LXYqbSkvKDIqYiktcixNPSh2KmctZCpfKS9iLFQ9KHAqbS1oKngpLygyKmIpLWksTj0oaCpfLXAqZykvYixrPU0qTStOKk4tMSxTPTIqKG8rdypNK1QqTiksRT13KncrVCpULW8qbyxBPS0oaz8oUytNYXRoLnNxcnQoUypTLTQqaypFKSkvKDIqayk6RS9TKTtyZXR1cm57eDpyK3crTSpBLHk6aStUK04qQSxyOkF9fWZ1bmN0aW9uIHhvKHQsbixlKXt2YXIgcj10LngsaT10Lnksbz1uLnIrZS5yLHU9dC5yK2UucixhPW4ueC1yLGM9bi55LWkscz1hKmErYypjO2lmKHMpe3ZhciBmPS41KygodSo9dSktKG8qPW8pKS8oMipzKSxsPU1hdGguc3FydChNYXRoLm1heCgwLDIqbyoodStzKS0odS09cykqdS1vKm8pKS8oMipzKTtlLng9citmKmErbCpjLGUueT1pK2YqYy1sKmF9ZWxzZSBlLng9cit1LGUueT1pfWZ1bmN0aW9uIGJvKHQsbil7dmFyIGU9bi54LXQueCxyPW4ueS10LnksaT10LnIrbi5yO3JldHVybiBpKmktMWUtNj5lKmUrcipyfWZ1bmN0aW9uIHdvKHQpe3ZhciBuPXQuXyxlPXQubmV4dC5fLHI9bi5yK2UucixpPShuLngqZS5yK2UueCpuLnIpL3Isbz0obi55KmUucitlLnkqbi5yKS9yO3JldHVybiBpKmkrbypvfWZ1bmN0aW9uIE1vKHQpe3RoaXMuXz10LHRoaXMubmV4dD1udWxsLHRoaXMucHJldmlvdXM9bnVsbH1mdW5jdGlvbiBUbyh0KXtpZighKGk9dC5sZW5ndGgpKXJldHVybiAwO3ZhciBuLGUscixpLG8sdSxhLGMscyxmLGw7aWYobj10WzBdLG4ueD0wLG4ueT0wLCEoaT4xKSlyZXR1cm4gbi5yO2lmKGU9dFsxXSxuLng9LWUucixlLng9bi5yLGUueT0wLCEoaT4yKSlyZXR1cm4gbi5yK2Uucjt4byhlLG4scj10WzJdKSxuPW5ldyBNbyhuKSxlPW5ldyBNbyhlKSxyPW5ldyBNbyhyKSxuLm5leHQ9ci5wcmV2aW91cz1lLGUubmV4dD1uLnByZXZpb3VzPXIsci5uZXh0PWUucHJldmlvdXM9bjt0OmZvcihhPTM7YTxpOysrYSl7eG8obi5fLGUuXyxyPXRbYV0pLHI9bmV3IE1vKHIpLGM9ZS5uZXh0LHM9bi5wcmV2aW91cyxmPWUuXy5yLGw9bi5fLnI7ZG97aWYoZjw9bCl7aWYoYm8oYy5fLHIuXykpe2U9YyxuLm5leHQ9ZSxlLnByZXZpb3VzPW4sLS1hO2NvbnRpbnVlIHR9Zis9Yy5fLnIsYz1jLm5leHR9ZWxzZXtpZihibyhzLl8sci5fKSl7KG49cykubmV4dD1lLGUucHJldmlvdXM9biwtLWE7Y29udGludWUgdH1sKz1zLl8ucixzPXMucHJldmlvdXN9fXdoaWxlKGMhPT1zLm5leHQpO2ZvcihyLnByZXZpb3VzPW4sci5uZXh0PWUsbi5uZXh0PWUucHJldmlvdXM9ZT1yLG89d28obik7KHI9ci5uZXh0KSE9PWU7KSh1PXdvKHIpKTxvJiYobj1yLG89dSk7ZT1uLm5leHR9Zm9yKG49W2UuX10scj1lOyhyPXIubmV4dCkhPT1lOyluLnB1c2goci5fKTtmb3Iocj1wbyhuKSxhPTA7YTxpOysrYSluPXRbYV0sbi54LT1yLngsbi55LT1yLnk7cmV0dXJuIHIucn1mdW5jdGlvbiBObyh0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcjtyZXR1cm4gdH1mdW5jdGlvbiBrbygpe3JldHVybiAwfWZ1bmN0aW9uIFNvKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX1mdW5jdGlvbiBFbyh0KXtyZXR1cm4gTWF0aC5zcXJ0KHQudmFsdWUpfWZ1bmN0aW9uIEFvKHQpe3JldHVybiBmdW5jdGlvbihuKXtuLmNoaWxkcmVufHwobi5yPU1hdGgubWF4KDAsK3Qobil8fDApKX19ZnVuY3Rpb24gQ28odCxuKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYocj1lLmNoaWxkcmVuKXt2YXIgcixpLG8sdT1yLmxlbmd0aCxhPXQoZSkqbnx8MDtpZihhKWZvcihpPTA7aTx1OysraSlyW2ldLnIrPWE7aWYobz1UbyhyKSxhKWZvcihpPTA7aTx1OysraSlyW2ldLnItPWE7ZS5yPW8rYX19fWZ1bmN0aW9uIHpvKHQpe3JldHVybiBmdW5jdGlvbihuKXt2YXIgZT1uLnBhcmVudDtuLnIqPXQsZSYmKG4ueD1lLngrdCpuLngsbi55PWUueSt0Km4ueSl9fWZ1bmN0aW9uIFBvKHQpe3QueDA9TWF0aC5yb3VuZCh0LngwKSx0LnkwPU1hdGgucm91bmQodC55MCksdC54MT1NYXRoLnJvdW5kKHQueDEpLHQueTE9TWF0aC5yb3VuZCh0LnkxKX1mdW5jdGlvbiBSbyh0LG4sZSxyLGkpe2Zvcih2YXIgbyx1PXQuY2hpbGRyZW4sYT0tMSxjPXUubGVuZ3RoLHM9dC52YWx1ZSYmKHItbikvdC52YWx1ZTsrK2E8YzspKG89dVthXSkueTA9ZSxvLnkxPWksby54MD1uLG8ueDE9bis9by52YWx1ZSpzfWZ1bmN0aW9uIExvKHQpe3JldHVybiB0LmlkfWZ1bmN0aW9uIHFvKHQpe3JldHVybiB0LnBhcmVudElkfWZ1bmN0aW9uIERvKHQsbil7cmV0dXJuIHQucGFyZW50PT09bi5wYXJlbnQ/MToyfWZ1bmN0aW9uIFVvKHQpe3ZhciBuPXQuY2hpbGRyZW47cmV0dXJuIG4/blswXTp0LnR9ZnVuY3Rpb24gT28odCl7dmFyIG49dC5jaGlsZHJlbjtyZXR1cm4gbj9uW24ubGVuZ3RoLTFdOnQudH1mdW5jdGlvbiBGbyh0LG4sZSl7dmFyIHI9ZS8obi5pLXQuaSk7bi5jLT1yLG4ucys9ZSx0LmMrPXIsbi56Kz1lLG4ubSs9ZX1mdW5jdGlvbiBJbyh0LG4sZSl7cmV0dXJuIHQuYS5wYXJlbnQ9PT1uLnBhcmVudD90LmE6ZX1mdW5jdGlvbiBZbyh0LG4pe3RoaXMuXz10LHRoaXMucGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbj1udWxsLHRoaXMuQT1udWxsLHRoaXMuYT10aGlzLHRoaXMuej0wLHRoaXMubT0wLHRoaXMuYz0wLHRoaXMucz0wLHRoaXMudD1udWxsLHRoaXMuaT1ufWZ1bmN0aW9uIEJvKHQsbixlLHIsaSl7Zm9yKHZhciBvLHU9dC5jaGlsZHJlbixhPS0xLGM9dS5sZW5ndGgscz10LnZhbHVlJiYoaS1lKS90LnZhbHVlOysrYTxjOykobz11W2FdKS54MD1uLG8ueDE9cixvLnkwPWUsby55MT1lKz1vLnZhbHVlKnN9ZnVuY3Rpb24gSG8odCxuLGUscixpLG8pe2Zvcih2YXIgdSxhLGMscyxmLGwsaCxwLGQsdixnLF89W10seT1uLmNoaWxkcmVuLG09MCx4PTAsYj15Lmxlbmd0aCx3PW4udmFsdWU7bTxiOyl7Yz1pLWUscz1vLXI7ZG97Zj15W3grK10udmFsdWV9d2hpbGUoIWYmJng8Yik7Zm9yKGw9aD1mLGc9ZipmKih2PU1hdGgubWF4KHMvYyxjL3MpLyh3KnQpKSxkPU1hdGgubWF4KGgvZyxnL2wpO3g8YjsrK3gpe2lmKGYrPWE9eVt4XS52YWx1ZSxhPGwmJihsPWEpLGE+aCYmKGg9YSksZz1mKmYqdiwocD1NYXRoLm1heChoL2csZy9sKSk+ZCl7Zi09YTticmVha31kPXB9Xy5wdXNoKHU9e3ZhbHVlOmYsZGljZTpjPHMsY2hpbGRyZW46eS5zbGljZShtLHgpfSksdS5kaWNlP1JvKHUsZSxyLGksdz9yKz1zKmYvdzpvKTpCbyh1LGUscix3P2UrPWMqZi93Omksbyksdy09ZixtPXh9cmV0dXJuIF99ZnVuY3Rpb24gam8odCxuLGUpe3JldHVybihuWzBdLXRbMF0pKihlWzFdLXRbMV0pLShuWzFdLXRbMV0pKihlWzBdLXRbMF0pfWZ1bmN0aW9uIFhvKHQsbil7cmV0dXJuIHRbMF0tblswXXx8dFsxXS1uWzFdfWZ1bmN0aW9uIFZvKHQpe2Zvcih2YXIgbj10Lmxlbmd0aCxlPVswLDFdLHI9MixpPTI7aTxuOysraSl7Zm9yKDtyPjEmJmpvKHRbZVtyLTJdXSx0W2Vbci0xXV0sdFtpXSk8PTA7KS0tcjtlW3IrK109aX1yZXR1cm4gZS5zbGljZSgwLHIpfWZ1bmN0aW9uICRvKHQpe3RoaXMuX3NpemU9dCx0aGlzLl9jYWxsPXRoaXMuX2Vycm9yPW51bGwsdGhpcy5fdGFza3M9W10sdGhpcy5fZGF0YT1bXSx0aGlzLl93YWl0aW5nPXRoaXMuX2FjdGl2ZT10aGlzLl9lbmRlZD10aGlzLl9zdGFydD0wfWZ1bmN0aW9uIFdvKHQpe2lmKCF0Ll9zdGFydCl0cnl7KGZ1bmN0aW9uKHQpe2Zvcig7dC5fc3RhcnQ9dC5fd2FpdGluZyYmdC5fYWN0aXZlPHQuX3NpemU7KXt2YXIgbj10Ll9lbmRlZCt0Ll9hY3RpdmUsZT10Ll90YXNrc1tuXSxyPWUubGVuZ3RoLTEsaT1lW3JdO2Vbcl09ZnVuY3Rpb24odCxuKXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt0Ll90YXNrc1tuXSYmKC0tdC5fYWN0aXZlLCsrdC5fZW5kZWQsdC5fdGFza3Nbbl09bnVsbCxudWxsPT10Ll9lcnJvciYmKG51bGwhPWU/Wm8odCxlKToodC5fZGF0YVtuXT1yLHQuX3dhaXRpbmc/V28odCk6R28odCkpKSl9fSh0LG4pLC0tdC5fd2FpdGluZywrK3QuX2FjdGl2ZSxlPWkuYXBwbHkobnVsbCxlKSx0Ll90YXNrc1tuXSYmKHQuX3Rhc2tzW25dPWV8fHR2KX19KSh0KX1jYXRjaChuKXtpZih0Ll90YXNrc1t0Ll9lbmRlZCt0Ll9hY3RpdmUtMV0pWm8odCxuKTtlbHNlIGlmKCF0Ll9kYXRhKXRocm93IG59fWZ1bmN0aW9uIFpvKHQsbil7dmFyIGUscj10Ll90YXNrcy5sZW5ndGg7Zm9yKHQuX2Vycm9yPW4sdC5fZGF0YT12b2lkIDAsdC5fd2FpdGluZz1OYU47LS1yPj0wOylpZigoZT10Ll90YXNrc1tyXSkmJih0Ll90YXNrc1tyXT1udWxsLGUuYWJvcnQpKXRyeXtlLmFib3J0KCl9Y2F0Y2gobil7fXQuX2FjdGl2ZT1OYU4sR28odCl9ZnVuY3Rpb24gR28odCl7aWYoIXQuX2FjdGl2ZSYmdC5fY2FsbCl7dmFyIG49dC5fZGF0YTt0Ll9kYXRhPXZvaWQgMCx0Ll9jYWxsKHQuX2Vycm9yLG4pfX1mdW5jdGlvbiBRbyh0KXtpZihudWxsPT10KXQ9MS8wO2Vsc2UgaWYoISgodD0rdCk+PTEpKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29uY3VycmVuY3lcIik7cmV0dXJuIG5ldyAkbyh0KX1mdW5jdGlvbiBKbygpe3JldHVybiBNYXRoLnJhbmRvbSgpfWZ1bmN0aW9uIEtvKHQsbil7ZnVuY3Rpb24gZSh0KXt2YXIgbixlPXMuc3RhdHVzO2lmKCFlJiZmdW5jdGlvbih0KXt2YXIgbj10LnJlc3BvbnNlVHlwZTtyZXR1cm4gbiYmXCJ0ZXh0XCIhPT1uP3QucmVzcG9uc2U6dC5yZXNwb25zZVRleHR9KHMpfHxlPj0yMDAmJmU8MzAwfHwzMDQ9PT1lKXtpZihvKXRyeXtuPW8uY2FsbChyLHMpfWNhdGNoKHQpe3JldHVybiB2b2lkIGEuY2FsbChcImVycm9yXCIscix0KX1lbHNlIG49czthLmNhbGwoXCJsb2FkXCIscixuKX1lbHNlIGEuY2FsbChcImVycm9yXCIscix0KX12YXIgcixpLG8sdSxhPU4oXCJiZWZvcmVzZW5kXCIsXCJwcm9ncmVzc1wiLFwibG9hZFwiLFwiZXJyb3JcIiksYz1hZSgpLHM9bmV3IFhNTEh0dHBSZXF1ZXN0LGY9bnVsbCxsPW51bGwsaD0wO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBYRG9tYWluUmVxdWVzdHx8XCJ3aXRoQ3JlZGVudGlhbHNcImluIHN8fCEvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh0KXx8KHM9bmV3IFhEb21haW5SZXF1ZXN0KSxcIm9ubG9hZFwiaW4gcz9zLm9ubG9hZD1zLm9uZXJyb3I9cy5vbnRpbWVvdXQ9ZTpzLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbih0KXtzLnJlYWR5U3RhdGU+MyYmZSh0KX0scy5vbnByb2dyZXNzPWZ1bmN0aW9uKHQpe2EuY2FsbChcInByb2dyZXNzXCIscix0KX0scj17aGVhZGVyOmZ1bmN0aW9uKHQsbil7cmV0dXJuIHQ9KHQrXCJcIikudG9Mb3dlckNhc2UoKSxhcmd1bWVudHMubGVuZ3RoPDI/Yy5nZXQodCk6KG51bGw9PW4/Yy5yZW1vdmUodCk6Yy5zZXQodCxuK1wiXCIpLHIpfSxtaW1lVHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT1udWxsPT10P251bGw6dCtcIlwiLHIpOml9LHJlc3BvbnNlVHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odT10LHIpOnV9LHRpbWVvdXQ6ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGg9K3Qscik6aH0sdXNlcjpmdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aDwxP2Y6KGY9bnVsbD09dD9udWxsOnQrXCJcIixyKX0scGFzc3dvcmQ6ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8MT9sOihsPW51bGw9PXQ/bnVsbDp0K1wiXCIscil9LHJlc3BvbnNlOmZ1bmN0aW9uKHQpe3JldHVybiBvPXQscn0sZ2V0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIHIuc2VuZChcIkdFVFwiLHQsbil9LHBvc3Q6ZnVuY3Rpb24odCxuKXtyZXR1cm4gci5zZW5kKFwiUE9TVFwiLHQsbil9LHNlbmQ6ZnVuY3Rpb24obixlLG8pe3JldHVybiBzLm9wZW4obix0LCEwLGYsbCksbnVsbD09aXx8Yy5oYXMoXCJhY2NlcHRcIil8fGMuc2V0KFwiYWNjZXB0XCIsaStcIiwqLypcIikscy5zZXRSZXF1ZXN0SGVhZGVyJiZjLmVhY2goZnVuY3Rpb24odCxuKXtzLnNldFJlcXVlc3RIZWFkZXIobix0KX0pLG51bGwhPWkmJnMub3ZlcnJpZGVNaW1lVHlwZSYmcy5vdmVycmlkZU1pbWVUeXBlKGkpLG51bGwhPXUmJihzLnJlc3BvbnNlVHlwZT11KSxoPjAmJihzLnRpbWVvdXQ9aCksbnVsbD09byYmXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKG89ZSxlPW51bGwpLG51bGwhPW8mJjE9PT1vLmxlbmd0aCYmKG89ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKG4sZSl7dChudWxsPT1uP2U6bnVsbCl9fShvKSksbnVsbCE9byYmci5vbihcImVycm9yXCIsbykub24oXCJsb2FkXCIsZnVuY3Rpb24odCl7byhudWxsLHQpfSksYS5jYWxsKFwiYmVmb3Jlc2VuZFwiLHIscykscy5zZW5kKG51bGw9PWU/bnVsbDplKSxyfSxhYm9ydDpmdW5jdGlvbigpe3JldHVybiBzLmFib3J0KCkscn0sb246ZnVuY3Rpb24oKXt2YXIgdD1hLm9uLmFwcGx5KGEsYXJndW1lbnRzKTtyZXR1cm4gdD09PWE/cjp0fX0sbnVsbCE9bil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIituKTtyZXR1cm4gci5nZXQobil9cmV0dXJuIHJ9ZnVuY3Rpb24gdHUodCxuKXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt2YXIgaT1LbyhlKS5taW1lVHlwZSh0KS5yZXNwb25zZShuKTtpZihudWxsIT1yKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiK3IpO3JldHVybiBpLmdldChyKX1yZXR1cm4gaX19ZnVuY3Rpb24gbnUodCxuKXtyZXR1cm4gZnVuY3Rpb24oZSxyLGkpe2FyZ3VtZW50cy5sZW5ndGg8MyYmKGk9cixyPW51bGwpO3ZhciBvPUtvKGUpLm1pbWVUeXBlKHQpO3JldHVybiBvLnJvdz1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD9vLnJlc3BvbnNlKGZ1bmN0aW9uKHQsbil7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0KGUucmVzcG9uc2VUZXh0LG4pfX0obixyPXQpKTpyfSxvLnJvdyhyKSxpP28uZ2V0KGkpOm99fWZ1bmN0aW9uIGV1KHQpe2Z1bmN0aW9uIG4obil7dmFyIG89bitcIlwiLHU9ZS5nZXQobyk7aWYoIXUpe2lmKGkhPT1ndilyZXR1cm4gaTtlLnNldChvLHU9ci5wdXNoKG4pKX1yZXR1cm4gdFsodS0xKSV0Lmxlbmd0aF19dmFyIGU9YWUoKSxyPVtdLGk9Z3Y7cmV0dXJuIHQ9bnVsbD09dD9bXTp2di5jYWxsKHQpLG4uZG9tYWluPWZ1bmN0aW9uKHQpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiByLnNsaWNlKCk7cj1bXSxlPWFlKCk7Zm9yKHZhciBpLG8sdT0tMSxhPXQubGVuZ3RoOysrdTxhOyllLmhhcyhvPShpPXRbdV0pK1wiXCIpfHxlLnNldChvLHIucHVzaChpKSk7cmV0dXJuIG59LG4ucmFuZ2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHQ9dnYuY2FsbChlKSxuKTp0LnNsaWNlKCl9LG4udW5rbm93bj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT10LG4pOml9LG4uY29weT1mdW5jdGlvbigpe3JldHVybiBldSgpLmRvbWFpbihyKS5yYW5nZSh0KS51bmtub3duKGkpfSxufWZ1bmN0aW9uIHJ1KCl7ZnVuY3Rpb24gdCgpe3ZhciB0PWkoKS5sZW5ndGgscj11WzFdPHVbMF0saD11W3ItMF0scD11WzEtcl07bj0ocC1oKS9NYXRoLm1heCgxLHQtYysyKnMpLGEmJihuPU1hdGguZmxvb3IobikpLGgrPShwLWgtbioodC1jKSkqbCxlPW4qKDEtYyksYSYmKGg9TWF0aC5yb3VuZChoKSxlPU1hdGgucm91bmQoZSkpO3ZhciBkPWYodCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBoK24qdH0pO3JldHVybiBvKHI/ZC5yZXZlcnNlKCk6ZCl9dmFyIG4sZSxyPWV1KCkudW5rbm93bih2b2lkIDApLGk9ci5kb21haW4sbz1yLnJhbmdlLHU9WzAsMV0sYT0hMSxjPTAscz0wLGw9LjU7cmV0dXJuIGRlbGV0ZSByLnVua25vd24sci5kb21haW49ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGkobiksdCgpKTppKCl9LHIucmFuZ2U9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHU9WytuWzBdLCtuWzFdXSx0KCkpOnUuc2xpY2UoKX0sci5yYW5nZVJvdW5kPWZ1bmN0aW9uKG4pe3JldHVybiB1PVsrblswXSwrblsxXV0sYT0hMCx0KCl9LHIuYmFuZHdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIGV9LHIuc3RlcD1mdW5jdGlvbigpe3JldHVybiBufSxyLnJvdW5kPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhhPSEhbix0KCkpOmF9LHIucGFkZGluZz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYz1zPU1hdGgubWF4KDAsTWF0aC5taW4oMSxuKSksdCgpKTpjfSxyLnBhZGRpbmdJbm5lcj1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYz1NYXRoLm1heCgwLE1hdGgubWluKDEsbikpLHQoKSk6Y30sci5wYWRkaW5nT3V0ZXI9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHM9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG4pKSx0KCkpOnN9LHIuYWxpZ249ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGw9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG4pKSx0KCkpOmx9LHIuY29weT1mdW5jdGlvbigpe3JldHVybiBydSgpLmRvbWFpbihpKCkpLnJhbmdlKHUpLnJvdW5kKGEpLnBhZGRpbmdJbm5lcihjKS5wYWRkaW5nT3V0ZXIocykuYWxpZ24obCl9LHQoKX1mdW5jdGlvbiBpdSh0KXt2YXIgbj10LmNvcHk7cmV0dXJuIHQucGFkZGluZz10LnBhZGRpbmdPdXRlcixkZWxldGUgdC5wYWRkaW5nSW5uZXIsZGVsZXRlIHQucGFkZGluZ091dGVyLHQuY29weT1mdW5jdGlvbigpe3JldHVybiBpdShuKCkpfSx0fWZ1bmN0aW9uIG91KHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX1mdW5jdGlvbiB1dSh0KXtyZXR1cm4rdH1mdW5jdGlvbiBhdSh0LG4pe3JldHVybihuLT10PSt0KT9mdW5jdGlvbihlKXtyZXR1cm4oZS10KS9ufTpvdShuKX1mdW5jdGlvbiBjdSh0LG4sZSxyKXt2YXIgaT10WzBdLG89dFsxXSx1PW5bMF0sYT1uWzFdO3JldHVybiBvPGk/KGk9ZShvLGkpLHU9cihhLHUpKTooaT1lKGksbyksdT1yKHUsYSkpLGZ1bmN0aW9uKHQpe3JldHVybiB1KGkodCkpfX1mdW5jdGlvbiBzdSh0LG4sZSxyKXt2YXIgaT1NYXRoLm1pbih0Lmxlbmd0aCxuLmxlbmd0aCktMSxvPW5ldyBBcnJheShpKSx1PW5ldyBBcnJheShpKSxhPS0xO2Zvcih0W2ldPHRbMF0mJih0PXQuc2xpY2UoKS5yZXZlcnNlKCksbj1uLnNsaWNlKCkucmV2ZXJzZSgpKTsrK2E8aTspb1thXT1lKHRbYV0sdFthKzFdKSx1W2FdPXIoblthXSxuW2ErMV0pO3JldHVybiBmdW5jdGlvbihuKXt2YXIgZT1Ecyh0LG4sMSxpKS0xO3JldHVybiB1W2VdKG9bZV0obikpfX1mdW5jdGlvbiBmdSh0LG4pe3JldHVybiBuLmRvbWFpbih0LmRvbWFpbigpKS5yYW5nZSh0LnJhbmdlKCkpLmludGVycG9sYXRlKHQuaW50ZXJwb2xhdGUoKSkuY2xhbXAodC5jbGFtcCgpKX1mdW5jdGlvbiBsdSh0LG4pe2Z1bmN0aW9uIGUoKXtyZXR1cm4gaT1NYXRoLm1pbihhLmxlbmd0aCxjLmxlbmd0aCk+Mj9zdTpjdSxvPXU9bnVsbCxyfWZ1bmN0aW9uIHIobil7cmV0dXJuKG98fChvPWkoYSxjLGY/ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKG4sZSl7dmFyIHI9dChuPStuLGU9K2UpO3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gdDw9bj8wOnQ+PWU/MTpyKHQpfX19KHQpOnQscykpKSgrbil9dmFyIGksbyx1LGE9X3YsYz1fdixzPWNuLGY9ITE7cmV0dXJuIHIuaW52ZXJ0PWZ1bmN0aW9uKHQpe3JldHVybih1fHwodT1pKGMsYSxhdSxmP2Z1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihuLGUpe3ZhciByPXQobj0rbixlPStlKTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHQ8PTA/bjp0Pj0xP2U6cih0KX19fShuKTpuKSkpKCt0KX0sci5kb21haW49ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGE9ZHYuY2FsbCh0LHV1KSxlKCkpOmEuc2xpY2UoKX0sci5yYW5nZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYz12di5jYWxsKHQpLGUoKSk6Yy5zbGljZSgpfSxyLnJhbmdlUm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIGM9dnYuY2FsbCh0KSxzPXNuLGUoKX0sci5jbGFtcD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZj0hIXQsZSgpKTpmfSxyLmludGVycG9sYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhzPXQsZSgpKTpzfSxlKCl9ZnVuY3Rpb24gaHUobil7dmFyIGU9bi5kb21haW47cmV0dXJuIG4udGlja3M9ZnVuY3Rpb24odCl7dmFyIG49ZSgpO3JldHVybiBsKG5bMF0sbltuLmxlbmd0aC0xXSxudWxsPT10PzEwOnQpfSxuLnRpY2tGb3JtYXQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gZnVuY3Rpb24obixlLHIpe3ZhciBpLG89blswXSx1PW5bbi5sZW5ndGgtMV0sYT1wKG8sdSxudWxsPT1lPzEwOmUpO3N3aXRjaCgocj1MZShudWxsPT1yP1wiLGZcIjpyKSkudHlwZSl7Y2FzZVwic1wiOnZhciBjPU1hdGgubWF4KE1hdGguYWJzKG8pLE1hdGguYWJzKHUpKTtyZXR1cm4gbnVsbCE9ci5wcmVjaXNpb258fGlzTmFOKGk9SWUoYSxjKSl8fChyLnByZWNpc2lvbj1pKSx0LmZvcm1hdFByZWZpeChyLGMpO2Nhc2VcIlwiOmNhc2VcImVcIjpjYXNlXCJnXCI6Y2FzZVwicFwiOmNhc2VcInJcIjpudWxsIT1yLnByZWNpc2lvbnx8aXNOYU4oaT1ZZShhLE1hdGgubWF4KE1hdGguYWJzKG8pLE1hdGguYWJzKHUpKSkpfHwoci5wcmVjaXNpb249aS0oXCJlXCI9PT1yLnR5cGUpKTticmVhaztjYXNlXCJmXCI6Y2FzZVwiJVwiOm51bGwhPXIucHJlY2lzaW9ufHxpc05hTihpPUZlKGEpKXx8KHIucHJlY2lzaW9uPWktMiooXCIlXCI9PT1yLnR5cGUpKX1yZXR1cm4gdC5mb3JtYXQocil9KGUoKSxuLHIpfSxuLm5pY2U9ZnVuY3Rpb24odCl7bnVsbD09dCYmKHQ9MTApO3ZhciByLGk9ZSgpLG89MCx1PWkubGVuZ3RoLTEsYT1pW29dLGM9aVt1XTtyZXR1cm4gYzxhJiYocj1hLGE9YyxjPXIscj1vLG89dSx1PXIpLChyPWgoYSxjLHQpKT4wP3I9aChhPU1hdGguZmxvb3IoYS9yKSpyLGM9TWF0aC5jZWlsKGMvcikqcix0KTpyPDAmJihyPWgoYT1NYXRoLmNlaWwoYSpyKS9yLGM9TWF0aC5mbG9vcihjKnIpL3IsdCkpLHI+MD8oaVtvXT1NYXRoLmZsb29yKGEvcikqcixpW3VdPU1hdGguY2VpbChjL3IpKnIsZShpKSk6cjwwJiYoaVtvXT1NYXRoLmNlaWwoYSpyKS9yLGlbdV09TWF0aC5mbG9vcihjKnIpL3IsZShpKSksbn0sbn1mdW5jdGlvbiBwdSgpe3ZhciB0PWx1KGF1LG9uKTtyZXR1cm4gdC5jb3B5PWZ1bmN0aW9uKCl7cmV0dXJuIGZ1KHQscHUoKSl9LGh1KHQpfWZ1bmN0aW9uIGR1KCl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4rdH12YXIgbj1bMCwxXTtyZXR1cm4gdC5pbnZlcnQ9dCx0LmRvbWFpbj10LnJhbmdlPWZ1bmN0aW9uKGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhuPWR2LmNhbGwoZSx1dSksdCk6bi5zbGljZSgpfSx0LmNvcHk9ZnVuY3Rpb24oKXtyZXR1cm4gZHUoKS5kb21haW4obil9LGh1KHQpfWZ1bmN0aW9uIHZ1KHQsbil7dmFyIGUscj0wLGk9KHQ9dC5zbGljZSgpKS5sZW5ndGgtMSxvPXRbcl0sdT10W2ldO3JldHVybiB1PG8mJihlPXIscj1pLGk9ZSxlPW8sbz11LHU9ZSksdFtyXT1uLmZsb29yKG8pLHRbaV09bi5jZWlsKHUpLHR9ZnVuY3Rpb24gZ3UodCxuKXtyZXR1cm4obj1NYXRoLmxvZyhuL3QpKT9mdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5sb2coZS90KS9ufTpvdShuKX1mdW5jdGlvbiBfdSh0LG4pe3JldHVybiB0PDA/ZnVuY3Rpb24oZSl7cmV0dXJuLU1hdGgucG93KC1uLGUpKk1hdGgucG93KC10LDEtZSl9OmZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLnBvdyhuLGUpKk1hdGgucG93KHQsMS1lKX19ZnVuY3Rpb24geXUodCl7cmV0dXJuIGlzRmluaXRlKHQpPysoXCIxZVwiK3QpOnQ8MD8wOnR9ZnVuY3Rpb24gbXUodCl7cmV0dXJuIDEwPT09dD95dTp0PT09TWF0aC5FP01hdGguZXhwOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnBvdyh0LG4pfX1mdW5jdGlvbiB4dSh0KXtyZXR1cm4gdD09PU1hdGguRT9NYXRoLmxvZzoxMD09PXQmJk1hdGgubG9nMTB8fDI9PT10JiZNYXRoLmxvZzJ8fCh0PU1hdGgubG9nKHQpLGZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLmxvZyhuKS90fSl9ZnVuY3Rpb24gYnUodCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybi10KC1uKX19ZnVuY3Rpb24gd3UoKXtmdW5jdGlvbiBuKCl7cmV0dXJuIG89eHUoaSksdT1tdShpKSxyKClbMF08MCYmKG89YnUobyksdT1idSh1KSksZX12YXIgZT1sdShndSxfdSkuZG9tYWluKFsxLDEwXSkscj1lLmRvbWFpbixpPTEwLG89eHUoMTApLHU9bXUoMTApO3JldHVybiBlLmJhc2U9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9K3QsbigpKTppfSxlLmRvbWFpbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocih0KSxuKCkpOnIoKX0sZS50aWNrcz1mdW5jdGlvbih0KXt2YXIgbixlPXIoKSxhPWVbMF0sYz1lW2UubGVuZ3RoLTFdOyhuPWM8YSkmJihwPWEsYT1jLGM9cCk7dmFyIHMsZixoLHA9byhhKSxkPW8oYyksdj1udWxsPT10PzEwOit0LGc9W107aWYoIShpJTEpJiZkLXA8dil7aWYocD1NYXRoLnJvdW5kKHApLTEsZD1NYXRoLnJvdW5kKGQpKzEsYT4wKXtmb3IoO3A8ZDsrK3ApZm9yKGY9MSxzPXUocCk7ZjxpOysrZilpZighKChoPXMqZik8YSkpe2lmKGg+YylicmVhaztnLnB1c2goaCl9fWVsc2UgZm9yKDtwPGQ7KytwKWZvcihmPWktMSxzPXUocCk7Zj49MTstLWYpaWYoISgoaD1zKmYpPGEpKXtpZihoPmMpYnJlYWs7Zy5wdXNoKGgpfX1lbHNlIGc9bChwLGQsTWF0aC5taW4oZC1wLHYpKS5tYXAodSk7cmV0dXJuIG4/Zy5yZXZlcnNlKCk6Z30sZS50aWNrRm9ybWF0PWZ1bmN0aW9uKG4scil7aWYobnVsbD09ciYmKHI9MTA9PT1pP1wiLjBlXCI6XCIsXCIpLFwiZnVuY3Rpb25cIiE9dHlwZW9mIHImJihyPXQuZm9ybWF0KHIpKSxuPT09MS8wKXJldHVybiByO251bGw9PW4mJihuPTEwKTt2YXIgYT1NYXRoLm1heCgxLGkqbi9lLnRpY2tzKCkubGVuZ3RoKTtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG49dC91KE1hdGgucm91bmQobyh0KSkpO3JldHVybiBuKmk8aS0uNSYmKG4qPWkpLG48PWE/cih0KTpcIlwifX0sZS5uaWNlPWZ1bmN0aW9uKCl7cmV0dXJuIHIodnUocigpLHtmbG9vcjpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmZsb29yKG8odCkpKX0sY2VpbDpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmNlaWwobyh0KSkpfX0pKX0sZS5jb3B5PWZ1bmN0aW9uKCl7cmV0dXJuIGZ1KGUsd3UoKS5iYXNlKGkpKX0sZX1mdW5jdGlvbiBNdSh0LG4pe3JldHVybiB0PDA/LU1hdGgucG93KC10LG4pOk1hdGgucG93KHQsbil9ZnVuY3Rpb24gVHUoKXt2YXIgdD0xLG49bHUoZnVuY3Rpb24obixlKXtyZXR1cm4oZT1NdShlLHQpLShuPU11KG4sdCkpKT9mdW5jdGlvbihyKXtyZXR1cm4oTXUocix0KS1uKS9lfTpvdShlKX0sZnVuY3Rpb24obixlKXtyZXR1cm4gZT1NdShlLHQpLShuPU11KG4sdCkpLGZ1bmN0aW9uKHIpe3JldHVybiBNdShuK2UqciwxL3QpfX0pLGU9bi5kb21haW47cmV0dXJuIG4uZXhwb25lbnQ9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHQ9K24sZShlKCkpKTp0fSxuLmNvcHk9ZnVuY3Rpb24oKXtyZXR1cm4gZnUobixUdSgpLmV4cG9uZW50KHQpKX0saHUobil9ZnVuY3Rpb24gTnUoKXtmdW5jdGlvbiB0KCl7dmFyIHQ9MCxuPU1hdGgubWF4KDEsaS5sZW5ndGgpO2ZvcihvPW5ldyBBcnJheShuLTEpOysrdDxuOylvW3QtMV09dihyLHQvbik7cmV0dXJuIGV9ZnVuY3Rpb24gZSh0KXtpZighaXNOYU4odD0rdCkpcmV0dXJuIGlbRHMobyx0KV19dmFyIHI9W10saT1bXSxvPVtdO3JldHVybiBlLmludmVydEV4dGVudD1mdW5jdGlvbih0KXt2YXIgbj1pLmluZGV4T2YodCk7cmV0dXJuIG48MD9bTmFOLE5hTl06W24+MD9vW24tMV06clswXSxuPG8ubGVuZ3RoP29bbl06cltyLmxlbmd0aC0xXV19LGUuZG9tYWluPWZ1bmN0aW9uKGUpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiByLnNsaWNlKCk7cj1bXTtmb3IodmFyIGksbz0wLHU9ZS5sZW5ndGg7bzx1OysrbyludWxsPT0oaT1lW29dKXx8aXNOYU4oaT0raSl8fHIucHVzaChpKTtyZXR1cm4gci5zb3J0KG4pLHQoKX0sZS5yYW5nZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT12di5jYWxsKG4pLHQoKSk6aS5zbGljZSgpfSxlLnF1YW50aWxlcz1mdW5jdGlvbigpe3JldHVybiBvLnNsaWNlKCl9LGUuY29weT1mdW5jdGlvbigpe3JldHVybiBOdSgpLmRvbWFpbihyKS5yYW5nZShpKX0sZX1mdW5jdGlvbiBrdSgpe2Z1bmN0aW9uIHQodCl7aWYodDw9dClyZXR1cm4gdVtEcyhvLHQsMCxpKV19ZnVuY3Rpb24gbigpe3ZhciBuPS0xO2ZvcihvPW5ldyBBcnJheShpKTsrK248aTspb1tuXT0oKG4rMSkqci0obi1pKSplKS8oaSsxKTtyZXR1cm4gdH12YXIgZT0wLHI9MSxpPTEsbz1bLjVdLHU9WzAsMV07cmV0dXJuIHQuZG9tYWluPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPSt0WzBdLHI9K3RbMV0sbigpKTpbZSxyXX0sdC5yYW5nZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT0odT12di5jYWxsKHQpKS5sZW5ndGgtMSxuKCkpOnUuc2xpY2UoKX0sdC5pbnZlcnRFeHRlbnQ9ZnVuY3Rpb24odCl7dmFyIG49dS5pbmRleE9mKHQpO3JldHVybiBuPDA/W05hTixOYU5dOm48MT9bZSxvWzBdXTpuPj1pP1tvW2ktMV0scl06W29bbi0xXSxvW25dXX0sdC5jb3B5PWZ1bmN0aW9uKCl7cmV0dXJuIGt1KCkuZG9tYWluKFtlLHJdKS5yYW5nZSh1KX0saHUodCl9ZnVuY3Rpb24gU3UoKXtmdW5jdGlvbiB0KHQpe2lmKHQ8PXQpcmV0dXJuIGVbRHMobix0LDAscildfXZhciBuPVsuNV0sZT1bMCwxXSxyPTE7cmV0dXJuIHQuZG9tYWluPWZ1bmN0aW9uKGkpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhuPXZ2LmNhbGwoaSkscj1NYXRoLm1pbihuLmxlbmd0aCxlLmxlbmd0aC0xKSx0KTpuLnNsaWNlKCl9LHQucmFuZ2U9ZnVuY3Rpb24oaSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGU9dnYuY2FsbChpKSxyPU1hdGgubWluKG4ubGVuZ3RoLGUubGVuZ3RoLTEpLHQpOmUuc2xpY2UoKX0sdC5pbnZlcnRFeHRlbnQ9ZnVuY3Rpb24odCl7dmFyIHI9ZS5pbmRleE9mKHQpO3JldHVybltuW3ItMV0sbltyXV19LHQuY29weT1mdW5jdGlvbigpe3JldHVybiBTdSgpLmRvbWFpbihuKS5yYW5nZShlKX0sdH1mdW5jdGlvbiBFdSh0LG4sZSxyKXtmdW5jdGlvbiBpKG4pe3JldHVybiB0KG49bmV3IERhdGUoK24pKSxufXJldHVybiBpLmZsb29yPWksaS5jZWlsPWZ1bmN0aW9uKGUpe3JldHVybiB0KGU9bmV3IERhdGUoZS0xKSksbihlLDEpLHQoZSksZX0saS5yb3VuZD1mdW5jdGlvbih0KXt2YXIgbj1pKHQpLGU9aS5jZWlsKHQpO3JldHVybiB0LW48ZS10P246ZX0saS5vZmZzZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0PW5ldyBEYXRlKCt0KSxudWxsPT1lPzE6TWF0aC5mbG9vcihlKSksdH0saS5yYW5nZT1mdW5jdGlvbihlLHIsbyl7dmFyIHUsYT1bXTtpZihlPWkuY2VpbChlKSxvPW51bGw9PW8/MTpNYXRoLmZsb29yKG8pLCEoZTxyJiZvPjApKXJldHVybiBhO2Rve2EucHVzaCh1PW5ldyBEYXRlKCtlKSksbihlLG8pLHQoZSl9d2hpbGUodTxlJiZlPHIpO3JldHVybiBhfSxpLmZpbHRlcj1mdW5jdGlvbihlKXtyZXR1cm4gRXUoZnVuY3Rpb24obil7aWYobj49bilmb3IoO3QobiksIWUobik7KW4uc2V0VGltZShuLTEpfSxmdW5jdGlvbih0LHIpe2lmKHQ+PXQpaWYocjwwKWZvcig7KytyPD0wOylmb3IoO24odCwtMSksIWUodCk7KTtlbHNlIGZvcig7LS1yPj0wOylmb3IoO24odCwxKSwhZSh0KTspO30pfSxlJiYoaS5jb3VudD1mdW5jdGlvbihuLHIpe3JldHVybiB5di5zZXRUaW1lKCtuKSxtdi5zZXRUaW1lKCtyKSx0KHl2KSx0KG12KSxNYXRoLmZsb29yKGUoeXYsbXYpKX0saS5ldmVyeT1mdW5jdGlvbih0KXtyZXR1cm4gdD1NYXRoLmZsb29yKHQpLGlzRmluaXRlKHQpJiZ0PjA/dD4xP2kuZmlsdGVyKHI/ZnVuY3Rpb24obil7cmV0dXJuIHIobikldD09MH06ZnVuY3Rpb24obil7cmV0dXJuIGkuY291bnQoMCxuKSV0PT0wfSk6aTpudWxsfSksaX1mdW5jdGlvbiBBdSh0KXtyZXR1cm4gRXUoZnVuY3Rpb24obil7bi5zZXREYXRlKG4uZ2V0RGF0ZSgpLShuLmdldERheSgpKzctdCklNyksbi5zZXRIb3VycygwLDAsMCwwKX0sZnVuY3Rpb24odCxuKXt0LnNldERhdGUodC5nZXREYXRlKCkrNypuKX0sZnVuY3Rpb24odCxuKXtyZXR1cm4obi10LShuLmdldFRpbWV6b25lT2Zmc2V0KCktdC5nZXRUaW1lem9uZU9mZnNldCgpKSp3dikvTXZ9KX1mdW5jdGlvbiBDdSh0KXtyZXR1cm4gRXUoZnVuY3Rpb24obil7bi5zZXRVVENEYXRlKG4uZ2V0VVRDRGF0ZSgpLShuLmdldFVUQ0RheSgpKzctdCklNyksbi5zZXRVVENIb3VycygwLDAsMCwwKX0sZnVuY3Rpb24odCxuKXt0LnNldFVUQ0RhdGUodC5nZXRVVENEYXRlKCkrNypuKX0sZnVuY3Rpb24odCxuKXtyZXR1cm4obi10KS9Ndn0pfWZ1bmN0aW9uIHp1KHQpe2lmKDA8PXQueSYmdC55PDEwMCl7dmFyIG49bmV3IERhdGUoLTEsdC5tLHQuZCx0LkgsdC5NLHQuUyx0LkwpO3JldHVybiBuLnNldEZ1bGxZZWFyKHQueSksbn1yZXR1cm4gbmV3IERhdGUodC55LHQubSx0LmQsdC5ILHQuTSx0LlMsdC5MKX1mdW5jdGlvbiBQdSh0KXtpZigwPD10LnkmJnQueTwxMDApe3ZhciBuPW5ldyBEYXRlKERhdGUuVVRDKC0xLHQubSx0LmQsdC5ILHQuTSx0LlMsdC5MKSk7cmV0dXJuIG4uc2V0VVRDRnVsbFllYXIodC55KSxufXJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh0LnksdC5tLHQuZCx0LkgsdC5NLHQuUyx0LkwpKX1mdW5jdGlvbiBSdSh0KXtyZXR1cm57eTp0LG06MCxkOjEsSDowLE06MCxTOjAsTDowfX1mdW5jdGlvbiBMdSh0KXtmdW5jdGlvbiBuKHQsbil7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByLGksbyx1PVtdLGE9LTEsYz0wLHM9dC5sZW5ndGg7Zm9yKGUgaW5zdGFuY2VvZiBEYXRlfHwoZT1uZXcgRGF0ZSgrZSkpOysrYTxzOykzNz09PXQuY2hhckNvZGVBdChhKSYmKHUucHVzaCh0LnNsaWNlKGMsYSkpLG51bGwhPShpPWJnW3I9dC5jaGFyQXQoKythKV0pP3I9dC5jaGFyQXQoKythKTppPVwiZVwiPT09cj9cIiBcIjpcIjBcIiwobz1uW3JdKSYmKHI9byhlLGkpKSx1LnB1c2gociksYz1hKzEpO3JldHVybiB1LnB1c2godC5zbGljZShjLGEpKSx1LmpvaW4oXCJcIil9fWZ1bmN0aW9uIGUodCxuKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIGksbyx1PVJ1KDE5MDApO2lmKHIodSx0LGUrPVwiXCIsMCkhPWUubGVuZ3RoKXJldHVybiBudWxsO2lmKFwiUVwiaW4gdSlyZXR1cm4gbmV3IERhdGUodS5RKTtpZihcInBcImluIHUmJih1Lkg9dS5IJTEyKzEyKnUucCksXCJWXCJpbiB1KXtpZih1LlY8MXx8dS5WPjUzKXJldHVybiBudWxsO1wid1wiaW4gdXx8KHUudz0xKSxcIlpcImluIHU/KGk9KG89KGk9UHUoUnUodS55KSkpLmdldFVUQ0RheSgpKT40fHwwPT09bz9yZy5jZWlsKGkpOnJnKGkpLGk9dGcub2Zmc2V0KGksNyoodS5WLTEpKSx1Lnk9aS5nZXRVVENGdWxsWWVhcigpLHUubT1pLmdldFVUQ01vbnRoKCksdS5kPWkuZ2V0VVRDRGF0ZSgpKyh1LncrNiklNyk6KGk9KG89KGk9bihSdSh1LnkpKSkuZ2V0RGF5KCkpPjR8fDA9PT1vP1J2LmNlaWwoaSk6UnYoaSksaT1Ddi5vZmZzZXQoaSw3Kih1LlYtMSkpLHUueT1pLmdldEZ1bGxZZWFyKCksdS5tPWkuZ2V0TW9udGgoKSx1LmQ9aS5nZXREYXRlKCkrKHUudys2KSU3KX1lbHNlKFwiV1wiaW4gdXx8XCJVXCJpbiB1KSYmKFwid1wiaW4gdXx8KHUudz1cInVcImluIHU/dS51JTc6XCJXXCJpbiB1PzE6MCksbz1cIlpcImluIHU/UHUoUnUodS55KSkuZ2V0VVRDRGF5KCk6bihSdSh1LnkpKS5nZXREYXkoKSx1Lm09MCx1LmQ9XCJXXCJpbiB1Pyh1LncrNiklNys3KnUuVy0obys1KSU3OnUudys3KnUuVS0obys2KSU3KTtyZXR1cm5cIlpcImluIHU/KHUuSCs9dS5aLzEwMHwwLHUuTSs9dS5aJTEwMCxQdSh1KSk6bih1KX19ZnVuY3Rpb24gcih0LG4sZSxyKXtmb3IodmFyIGksbyx1PTAsYT1uLmxlbmd0aCxjPWUubGVuZ3RoO3U8YTspe2lmKHI+PWMpcmV0dXJuLTE7aWYoMzc9PT0oaT1uLmNoYXJDb2RlQXQodSsrKSkpe2lmKGk9bi5jaGFyQXQodSsrKSwhKG89VFtpIGluIGJnP24uY2hhckF0KHUrKyk6aV0pfHwocj1vKHQsZSxyKSk8MClyZXR1cm4tMX1lbHNlIGlmKGkhPWUuY2hhckNvZGVBdChyKyspKXJldHVybi0xfXJldHVybiByfXZhciBpPXQuZGF0ZVRpbWUsbz10LmRhdGUsdT10LnRpbWUsYT10LnBlcmlvZHMsYz10LmRheXMscz10LnNob3J0RGF5cyxmPXQubW9udGhzLGw9dC5zaG9ydE1vbnRocyxoPVV1KGEpLHA9T3UoYSksZD1VdShjKSx2PU91KGMpLGc9VXUocyksXz1PdShzKSx5PVV1KGYpLG09T3UoZikseD1VdShsKSxiPU91KGwpLHc9e2E6ZnVuY3Rpb24odCl7cmV0dXJuIHNbdC5nZXREYXkoKV19LEE6ZnVuY3Rpb24odCl7cmV0dXJuIGNbdC5nZXREYXkoKV19LGI6ZnVuY3Rpb24odCl7cmV0dXJuIGxbdC5nZXRNb250aCgpXX0sQjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LmdldE1vbnRoKCldfSxjOm51bGwsZDppYSxlOmlhLGY6c2EsSDpvYSxJOnVhLGo6YWEsTDpjYSxtOmZhLE06bGEscDpmdW5jdGlvbih0KXtyZXR1cm4gYVsrKHQuZ2V0SG91cnMoKT49MTIpXX0sUTpGYSxzOklhLFM6aGEsdTpwYSxVOmRhLFY6dmEsdzpnYSxXOl9hLHg6bnVsbCxYOm51bGwseTp5YSxZOm1hLFo6eGEsXCIlXCI6T2F9LE09e2E6ZnVuY3Rpb24odCl7cmV0dXJuIHNbdC5nZXRVVENEYXkoKV19LEE6ZnVuY3Rpb24odCl7cmV0dXJuIGNbdC5nZXRVVENEYXkoKV19LGI6ZnVuY3Rpb24odCl7cmV0dXJuIGxbdC5nZXRVVENNb250aCgpXX0sQjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LmdldFVUQ01vbnRoKCldfSxjOm51bGwsZDpiYSxlOmJhLGY6a2EsSDp3YSxJOk1hLGo6VGEsTDpOYSxtOlNhLE06RWEscDpmdW5jdGlvbih0KXtyZXR1cm4gYVsrKHQuZ2V0VVRDSG91cnMoKT49MTIpXX0sUTpGYSxzOklhLFM6QWEsdTpDYSxVOnphLFY6UGEsdzpSYSxXOkxhLHg6bnVsbCxYOm51bGwseTpxYSxZOkRhLFo6VWEsXCIlXCI6T2F9LFQ9e2E6ZnVuY3Rpb24odCxuLGUpe3ZhciByPWcuZXhlYyhuLnNsaWNlKGUpKTtyZXR1cm4gcj8odC53PV9bclswXS50b0xvd2VyQ2FzZSgpXSxlK3JbMF0ubGVuZ3RoKTotMX0sQTpmdW5jdGlvbih0LG4sZSl7dmFyIHI9ZC5leGVjKG4uc2xpY2UoZSkpO3JldHVybiByPyh0Lnc9dltyWzBdLnRvTG93ZXJDYXNlKCldLGUrclswXS5sZW5ndGgpOi0xfSxiOmZ1bmN0aW9uKHQsbixlKXt2YXIgcj14LmV4ZWMobi5zbGljZShlKSk7cmV0dXJuIHI/KHQubT1iW3JbMF0udG9Mb3dlckNhc2UoKV0sZStyWzBdLmxlbmd0aCk6LTF9LEI6ZnVuY3Rpb24odCxuLGUpe3ZhciByPXkuZXhlYyhuLnNsaWNlKGUpKTtyZXR1cm4gcj8odC5tPW1bclswXS50b0xvd2VyQ2FzZSgpXSxlK3JbMF0ubGVuZ3RoKTotMX0sYzpmdW5jdGlvbih0LG4sZSl7cmV0dXJuIHIodCxpLG4sZSl9LGQ6V3UsZTpXdSxmOnRhLEg6R3UsSTpHdSxqOlp1LEw6S3UsbTokdSxNOlF1LHA6ZnVuY3Rpb24odCxuLGUpe3ZhciByPWguZXhlYyhuLnNsaWNlKGUpKTtyZXR1cm4gcj8odC5wPXBbclswXS50b0xvd2VyQ2FzZSgpXSxlK3JbMF0ubGVuZ3RoKTotMX0sUTplYSxzOnJhLFM6SnUsdTpJdSxVOll1LFY6QnUsdzpGdSxXOkh1LHg6ZnVuY3Rpb24odCxuLGUpe3JldHVybiByKHQsbyxuLGUpfSxYOmZ1bmN0aW9uKHQsbixlKXtyZXR1cm4gcih0LHUsbixlKX0seTpYdSxZOmp1LFo6VnUsXCIlXCI6bmF9O3JldHVybiB3Lng9bihvLHcpLHcuWD1uKHUsdyksdy5jPW4oaSx3KSxNLng9bihvLE0pLE0uWD1uKHUsTSksTS5jPW4oaSxNKSx7Zm9ybWF0OmZ1bmN0aW9uKHQpe3ZhciBlPW4odCs9XCJcIix3KTtyZXR1cm4gZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0fSxlfSxwYXJzZTpmdW5jdGlvbih0KXt2YXIgbj1lKHQrPVwiXCIsenUpO3JldHVybiBuLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LG59LHV0Y0Zvcm1hdDpmdW5jdGlvbih0KXt2YXIgZT1uKHQrPVwiXCIsTSk7cmV0dXJuIGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sZX0sdXRjUGFyc2U6ZnVuY3Rpb24odCl7dmFyIG49ZSh0LFB1KTtyZXR1cm4gbi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0fSxufX19ZnVuY3Rpb24gcXUodCxuLGUpe3ZhciByPXQ8MD9cIi1cIjpcIlwiLGk9KHI/LXQ6dCkrXCJcIixvPWkubGVuZ3RoO3JldHVybiByKyhvPGU/bmV3IEFycmF5KGUtbysxKS5qb2luKG4pK2k6aSl9ZnVuY3Rpb24gRHUodCl7cmV0dXJuIHQucmVwbGFjZShUZyxcIlxcXFwkJlwiKX1mdW5jdGlvbiBVdSh0KXtyZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIit0Lm1hcChEdSkuam9pbihcInxcIikrXCIpXCIsXCJpXCIpfWZ1bmN0aW9uIE91KHQpe2Zvcih2YXIgbj17fSxlPS0xLHI9dC5sZW5ndGg7KytlPHI7KW5bdFtlXS50b0xvd2VyQ2FzZSgpXT1lO3JldHVybiBufWZ1bmN0aW9uIEZ1KHQsbixlKXt2YXIgcj13Zy5leGVjKG4uc2xpY2UoZSxlKzEpKTtyZXR1cm4gcj8odC53PStyWzBdLGUrclswXS5sZW5ndGgpOi0xfWZ1bmN0aW9uIEl1KHQsbixlKXt2YXIgcj13Zy5leGVjKG4uc2xpY2UoZSxlKzEpKTtyZXR1cm4gcj8odC51PStyWzBdLGUrclswXS5sZW5ndGgpOi0xfWZ1bmN0aW9uIFl1KHQsbixlKXt2YXIgcj13Zy5leGVjKG4uc2xpY2UoZSxlKzIpKTtyZXR1cm4gcj8odC5VPStyWzBdLGUrclswXS5sZW5ndGgpOi0xfWZ1bmN0aW9uIEJ1KHQsbixlKXt2YXIgcj13Zy5leGVjKG4uc2xpY2UoZSxlKzIpKTtyZXR1cm4gcj8odC5WPStyWzBdLGUrclswXS5sZW5ndGgpOi0xfWZ1bmN0aW9uIEh1KHQsbixlKXt2YXIgcj13Zy5leGVjKG4uc2xpY2UoZSxlKzIpKTtyZXR1cm4gcj8odC5XPStyWzBdLGUrclswXS5sZW5ndGgpOi0xfWZ1bmN0aW9uIGp1KHQsbixlKXt2YXIgcj13Zy5leGVjKG4uc2xpY2UoZSxlKzQpKTtyZXR1cm4gcj8odC55PStyWzBdLGUrclswXS5sZW5ndGgpOi0xfWZ1bmN0aW9uIFh1KHQsbixlKXt2YXIgcj13Zy5leGVjKG4uc2xpY2UoZSxlKzIpKTtyZXR1cm4gcj8odC55PStyWzBdKygrclswXT42OD8xOTAwOjJlMyksZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gVnUodCxuLGUpe3ZhciByPS9eKFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPy8uZXhlYyhuLnNsaWNlKGUsZSs2KSk7cmV0dXJuIHI/KHQuWj1yWzFdPzA6LShyWzJdKyhyWzNdfHxcIjAwXCIpKSxlK3JbMF0ubGVuZ3RoKTotMX1mdW5jdGlvbiAkdSh0LG4sZSl7dmFyIHI9d2cuZXhlYyhuLnNsaWNlKGUsZSsyKSk7cmV0dXJuIHI/KHQubT1yWzBdLTEsZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gV3UodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlLGUrMikpO3JldHVybiByPyh0LmQ9K3JbMF0sZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gWnUodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlLGUrMykpO3JldHVybiByPyh0Lm09MCx0LmQ9K3JbMF0sZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gR3UodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlLGUrMikpO3JldHVybiByPyh0Lkg9K3JbMF0sZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gUXUodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlLGUrMikpO3JldHVybiByPyh0Lk09K3JbMF0sZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gSnUodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlLGUrMikpO3JldHVybiByPyh0LlM9K3JbMF0sZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gS3UodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlLGUrMykpO3JldHVybiByPyh0Lkw9K3JbMF0sZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gdGEodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlLGUrNikpO3JldHVybiByPyh0Lkw9TWF0aC5mbG9vcihyWzBdLzFlMyksZStyWzBdLmxlbmd0aCk6LTF9ZnVuY3Rpb24gbmEodCxuLGUpe3ZhciByPU1nLmV4ZWMobi5zbGljZShlLGUrMSkpO3JldHVybiByP2UrclswXS5sZW5ndGg6LTF9ZnVuY3Rpb24gZWEodCxuLGUpe3ZhciByPXdnLmV4ZWMobi5zbGljZShlKSk7cmV0dXJuIHI/KHQuUT0rclswXSxlK3JbMF0ubGVuZ3RoKTotMX1mdW5jdGlvbiByYSh0LG4sZSl7dmFyIHI9d2cuZXhlYyhuLnNsaWNlKGUpKTtyZXR1cm4gcj8odC5RPTFlMyorclswXSxlK3JbMF0ubGVuZ3RoKTotMX1mdW5jdGlvbiBpYSh0LG4pe3JldHVybiBxdSh0LmdldERhdGUoKSxuLDIpfWZ1bmN0aW9uIG9hKHQsbil7cmV0dXJuIHF1KHQuZ2V0SG91cnMoKSxuLDIpfWZ1bmN0aW9uIHVhKHQsbil7cmV0dXJuIHF1KHQuZ2V0SG91cnMoKSUxMnx8MTIsbiwyKX1mdW5jdGlvbiBhYSh0LG4pe3JldHVybiBxdSgxK0N2LmNvdW50KFd2KHQpLHQpLG4sMyl9ZnVuY3Rpb24gY2EodCxuKXtyZXR1cm4gcXUodC5nZXRNaWxsaXNlY29uZHMoKSxuLDMpfWZ1bmN0aW9uIHNhKHQsbil7cmV0dXJuIGNhKHQsbikrXCIwMDBcIn1mdW5jdGlvbiBmYSh0LG4pe3JldHVybiBxdSh0LmdldE1vbnRoKCkrMSxuLDIpfWZ1bmN0aW9uIGxhKHQsbil7cmV0dXJuIHF1KHQuZ2V0TWludXRlcygpLG4sMil9ZnVuY3Rpb24gaGEodCxuKXtyZXR1cm4gcXUodC5nZXRTZWNvbmRzKCksbiwyKX1mdW5jdGlvbiBwYSh0KXt2YXIgbj10LmdldERheSgpO3JldHVybiAwPT09bj83Om59ZnVuY3Rpb24gZGEodCxuKXtyZXR1cm4gcXUoUHYuY291bnQoV3YodCksdCksbiwyKX1mdW5jdGlvbiB2YSh0LG4pe3ZhciBlPXQuZ2V0RGF5KCk7cmV0dXJuIHQ9ZT49NHx8MD09PWU/RHYodCk6RHYuY2VpbCh0KSxxdShEdi5jb3VudChXdih0KSx0KSsoND09PVd2KHQpLmdldERheSgpKSxuLDIpfWZ1bmN0aW9uIGdhKHQpe3JldHVybiB0LmdldERheSgpfWZ1bmN0aW9uIF9hKHQsbil7cmV0dXJuIHF1KFJ2LmNvdW50KFd2KHQpLHQpLG4sMil9ZnVuY3Rpb24geWEodCxuKXtyZXR1cm4gcXUodC5nZXRGdWxsWWVhcigpJTEwMCxuLDIpfWZ1bmN0aW9uIG1hKHQsbil7cmV0dXJuIHF1KHQuZ2V0RnVsbFllYXIoKSUxZTQsbiw0KX1mdW5jdGlvbiB4YSh0KXt2YXIgbj10LmdldFRpbWV6b25lT2Zmc2V0KCk7cmV0dXJuKG4+MD9cIi1cIjoobio9LTEsXCIrXCIpKStxdShuLzYwfDAsXCIwXCIsMikrcXUobiU2MCxcIjBcIiwyKX1mdW5jdGlvbiBiYSh0LG4pe3JldHVybiBxdSh0LmdldFVUQ0RhdGUoKSxuLDIpfWZ1bmN0aW9uIHdhKHQsbil7cmV0dXJuIHF1KHQuZ2V0VVRDSG91cnMoKSxuLDIpfWZ1bmN0aW9uIE1hKHQsbil7cmV0dXJuIHF1KHQuZ2V0VVRDSG91cnMoKSUxMnx8MTIsbiwyKX1mdW5jdGlvbiBUYSh0LG4pe3JldHVybiBxdSgxK3RnLmNvdW50KHlnKHQpLHQpLG4sMyl9ZnVuY3Rpb24gTmEodCxuKXtyZXR1cm4gcXUodC5nZXRVVENNaWxsaXNlY29uZHMoKSxuLDMpfWZ1bmN0aW9uIGthKHQsbil7cmV0dXJuIE5hKHQsbikrXCIwMDBcIn1mdW5jdGlvbiBTYSh0LG4pe3JldHVybiBxdSh0LmdldFVUQ01vbnRoKCkrMSxuLDIpfWZ1bmN0aW9uIEVhKHQsbil7cmV0dXJuIHF1KHQuZ2V0VVRDTWludXRlcygpLG4sMil9ZnVuY3Rpb24gQWEodCxuKXtyZXR1cm4gcXUodC5nZXRVVENTZWNvbmRzKCksbiwyKX1mdW5jdGlvbiBDYSh0KXt2YXIgbj10LmdldFVUQ0RheSgpO3JldHVybiAwPT09bj83Om59ZnVuY3Rpb24gemEodCxuKXtyZXR1cm4gcXUoZWcuY291bnQoeWcodCksdCksbiwyKX1mdW5jdGlvbiBQYSh0LG4pe3ZhciBlPXQuZ2V0VVRDRGF5KCk7cmV0dXJuIHQ9ZT49NHx8MD09PWU/dWcodCk6dWcuY2VpbCh0KSxxdSh1Zy5jb3VudCh5Zyh0KSx0KSsoND09PXlnKHQpLmdldFVUQ0RheSgpKSxuLDIpfWZ1bmN0aW9uIFJhKHQpe3JldHVybiB0LmdldFVUQ0RheSgpfWZ1bmN0aW9uIExhKHQsbil7cmV0dXJuIHF1KHJnLmNvdW50KHlnKHQpLHQpLG4sMil9ZnVuY3Rpb24gcWEodCxuKXtyZXR1cm4gcXUodC5nZXRVVENGdWxsWWVhcigpJTEwMCxuLDIpfWZ1bmN0aW9uIERhKHQsbil7cmV0dXJuIHF1KHQuZ2V0VVRDRnVsbFllYXIoKSUxZTQsbiw0KX1mdW5jdGlvbiBVYSgpe3JldHVyblwiKzAwMDBcIn1mdW5jdGlvbiBPYSgpe3JldHVyblwiJVwifWZ1bmN0aW9uIEZhKHQpe3JldHVybit0fWZ1bmN0aW9uIElhKHQpe3JldHVybiBNYXRoLmZsb29yKCt0LzFlMyl9ZnVuY3Rpb24gWWEobil7cmV0dXJuIG1nPUx1KG4pLHQudGltZUZvcm1hdD1tZy5mb3JtYXQsdC50aW1lUGFyc2U9bWcucGFyc2UsdC51dGNGb3JtYXQ9bWcudXRjRm9ybWF0LHQudXRjUGFyc2U9bWcudXRjUGFyc2UsbWd9ZnVuY3Rpb24gQmEodCl7cmV0dXJuIG5ldyBEYXRlKHQpfWZ1bmN0aW9uIEhhKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRGF0ZT8rdDorbmV3IERhdGUoK3QpfWZ1bmN0aW9uIGphKHQsbixyLGksbyx1LGEsYyxzKXtmdW5jdGlvbiBmKGUpe3JldHVybihhKGUpPGU/Zzp1KGUpPGU/XzpvKGUpPGU/eTppKGUpPGU/bTpuKGUpPGU/cihlKTxlP3g6Yjp0KGUpPGU/dzpNKShlKX1mdW5jdGlvbiBsKG4scixpLG8pe2lmKG51bGw9PW4mJihuPTEwKSxcIm51bWJlclwiPT10eXBlb2Ygbil7dmFyIHU9TWF0aC5hYnMoaS1yKS9uLGE9ZShmdW5jdGlvbih0KXtyZXR1cm4gdFsyXX0pLnJpZ2h0KFQsdSk7YT09PVQubGVuZ3RoPyhvPXAoci9MZyxpL0xnLG4pLG49dCk6YT8obz0oYT1UW3UvVFthLTFdWzJdPFRbYV1bMl0vdT9hLTE6YV0pWzFdLG49YVswXSk6KG89TWF0aC5tYXgocChyLGksbiksMSksbj1jKX1yZXR1cm4gbnVsbD09bz9uOm4uZXZlcnkobyl9dmFyIGg9bHUoYXUsb24pLGQ9aC5pbnZlcnQsdj1oLmRvbWFpbixnPXMoXCIuJUxcIiksXz1zKFwiOiVTXCIpLHk9cyhcIiVJOiVNXCIpLG09cyhcIiVJICVwXCIpLHg9cyhcIiVhICVkXCIpLGI9cyhcIiViICVkXCIpLHc9cyhcIiVCXCIpLE09cyhcIiVZXCIpLFQ9W1thLDEsRWddLFthLDUsNSpFZ10sW2EsMTUsMTUqRWddLFthLDMwLDMwKkVnXSxbdSwxLEFnXSxbdSw1LDUqQWddLFt1LDE1LDE1KkFnXSxbdSwzMCwzMCpBZ10sW28sMSxDZ10sW28sMywzKkNnXSxbbyw2LDYqQ2ddLFtvLDEyLDEyKkNnXSxbaSwxLHpnXSxbaSwyLDIqemddLFtyLDEsUGddLFtuLDEsUmddLFtuLDMsMypSZ10sW3QsMSxMZ11dO3JldHVybiBoLmludmVydD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IERhdGUoZCh0KSl9LGguZG9tYWluPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3YoZHYuY2FsbCh0LEhhKSk6digpLm1hcChCYSl9LGgudGlja3M9ZnVuY3Rpb24odCxuKXt2YXIgZSxyPXYoKSxpPXJbMF0sbz1yW3IubGVuZ3RoLTFdLHU9bzxpO3JldHVybiB1JiYoZT1pLGk9byxvPWUpLGU9bCh0LGksbyxuKSxlPWU/ZS5yYW5nZShpLG8rMSk6W10sdT9lLnJldmVyc2UoKTplfSxoLnRpY2tGb3JtYXQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gbnVsbD09bj9mOnMobil9LGgubmljZT1mdW5jdGlvbih0LG4pe3ZhciBlPXYoKTtyZXR1cm4odD1sKHQsZVswXSxlW2UubGVuZ3RoLTFdLG4pKT92KHZ1KGUsdCkpOmh9LGguY29weT1mdW5jdGlvbigpe3JldHVybiBmdShoLGphKHQsbixyLGksbyx1LGEsYyxzKSl9LGh9ZnVuY3Rpb24gWGEodCl7cmV0dXJuIHQubWF0Y2goLy57Nn0vZykubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiI1wiK3R9KX1mdW5jdGlvbiBWYSh0KXt2YXIgbj10Lmxlbmd0aDtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHRbTWF0aC5tYXgoMCxNYXRoLm1pbihuLTEsTWF0aC5mbG9vcihlKm4pKSldfX1mdW5jdGlvbiAkYSh0KXtmdW5jdGlvbiBuKG4pe3ZhciBvPShuLWUpLyhyLWUpO3JldHVybiB0KGk/TWF0aC5tYXgoMCxNYXRoLm1pbigxLG8pKTpvKX12YXIgZT0wLHI9MSxpPSExO3JldHVybiBuLmRvbWFpbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT0rdFswXSxyPSt0WzFdLG4pOltlLHJdfSxuLmNsYW1wPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPSEhdCxuKTppfSxuLmludGVycG9sYXRvcj1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odD1lLG4pOnR9LG4uY29weT1mdW5jdGlvbigpe3JldHVybiAkYSh0KS5kb21haW4oW2Uscl0pLmNsYW1wKGkpfSxodShuKX1mdW5jdGlvbiBXYSh0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdH19ZnVuY3Rpb24gWmEodCl7cmV0dXJuIHQ+PTE/ZV86dDw9LTE/LWVfOk1hdGguYXNpbih0KX1mdW5jdGlvbiBHYSh0KXtyZXR1cm4gdC5pbm5lclJhZGl1c31mdW5jdGlvbiBRYSh0KXtyZXR1cm4gdC5vdXRlclJhZGl1c31mdW5jdGlvbiBKYSh0KXtyZXR1cm4gdC5zdGFydEFuZ2xlfWZ1bmN0aW9uIEthKHQpe3JldHVybiB0LmVuZEFuZ2xlfWZ1bmN0aW9uIHRjKHQpe3JldHVybiB0JiZ0LnBhZEFuZ2xlfWZ1bmN0aW9uIG5jKHQsbixlLHIsaSxvLHUpe3ZhciBhPXQtZSxjPW4tcixzPSh1P286LW8pL0tnKGEqYStjKmMpLGY9cypjLGw9LXMqYSxoPXQrZixwPW4rbCxkPWUrZix2PXIrbCxnPShoK2QpLzIsXz0ocCt2KS8yLHk9ZC1oLG09di1wLHg9eSp5K20qbSxiPWktbyx3PWgqdi1kKnAsTT0obTwwPy0xOjEpKktnKEdnKDAsYipiKngtdyp3KSksVD0odyptLXkqTSkveCxOPSgtdyp5LW0qTSkveCxrPSh3Km0reSpNKS94LFM9KC13KnkrbSpNKS94LEU9VC1nLEE9Ti1fLEM9ay1nLHo9Uy1fO3JldHVybiBFKkUrQSpBPkMqQyt6KnomJihUPWssTj1TKSx7Y3g6VCxjeTpOLHgwMTotZix5MDE6LWwseDExOlQqKGkvYi0xKSx5MTE6TiooaS9iLTEpfX1mdW5jdGlvbiBlYyh0KXt0aGlzLl9jb250ZXh0PXR9ZnVuY3Rpb24gcmModCl7cmV0dXJuIG5ldyBlYyh0KX1mdW5jdGlvbiBpYyh0KXtyZXR1cm4gdFswXX1mdW5jdGlvbiBvYyh0KXtyZXR1cm4gdFsxXX1mdW5jdGlvbiB1Yygpe2Z1bmN0aW9uIHQodCl7dmFyIGEsYyxzLGY9dC5sZW5ndGgsbD0hMTtmb3IobnVsbD09aSYmKHU9byhzPXRlKCkpKSxhPTA7YTw9ZjsrK2EpIShhPGYmJnIoYz10W2FdLGEsdCkpPT09bCYmKChsPSFsKT91LmxpbmVTdGFydCgpOnUubGluZUVuZCgpKSxsJiZ1LnBvaW50KCtuKGMsYSx0KSwrZShjLGEsdCkpO2lmKHMpcmV0dXJuIHU9bnVsbCxzK1wiXCJ8fG51bGx9dmFyIG49aWMsZT1vYyxyPVdhKCEwKSxpPW51bGwsbz1yYyx1PW51bGw7cmV0dXJuIHQueD1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6V2EoK2UpLHQpOm59LHQueT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoK24pLHQpOmV9LHQuZGVmaW5lZD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoISFuKSx0KTpyfSx0LmN1cnZlPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhvPW4sbnVsbCE9aSYmKHU9byhpKSksdCk6b30sdC5jb250ZXh0PWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhudWxsPT1uP2k9dT1udWxsOnU9byhpPW4pLHQpOml9LHR9ZnVuY3Rpb24gYWMoKXtmdW5jdGlvbiB0KHQpe3ZhciBuLGYsbCxoLHAsZD10Lmxlbmd0aCx2PSExLGc9bmV3IEFycmF5KGQpLF89bmV3IEFycmF5KGQpO2ZvcihudWxsPT1hJiYocz1jKHA9dGUoKSkpLG49MDtuPD1kOysrbil7aWYoIShuPGQmJnUoaD10W25dLG4sdCkpPT09dilpZih2PSF2KWY9bixzLmFyZWFTdGFydCgpLHMubGluZVN0YXJ0KCk7ZWxzZXtmb3Iocy5saW5lRW5kKCkscy5saW5lU3RhcnQoKSxsPW4tMTtsPj1mOy0tbClzLnBvaW50KGdbbF0sX1tsXSk7cy5saW5lRW5kKCkscy5hcmVhRW5kKCl9diYmKGdbbl09K2UoaCxuLHQpLF9bbl09K2koaCxuLHQpLHMucG9pbnQocj8rcihoLG4sdCk6Z1tuXSxvPytvKGgsbix0KTpfW25dKSl9aWYocClyZXR1cm4gcz1udWxsLHArXCJcInx8bnVsbH1mdW5jdGlvbiBuKCl7cmV0dXJuIHVjKCkuZGVmaW5lZCh1KS5jdXJ2ZShjKS5jb250ZXh0KGEpfXZhciBlPWljLHI9bnVsbCxpPVdhKDApLG89b2MsdT1XYSghMCksYT1udWxsLGM9cmMscz1udWxsO3JldHVybiB0Lng9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGU9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOldhKCtuKSxyPW51bGwsdCk6ZX0sdC54MD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoK24pLHQpOmV9LHQueDE9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9bnVsbD09bj9udWxsOlwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpXYSgrbiksdCk6cn0sdC55PWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpXYSgrbiksbz1udWxsLHQpOml9LHQueTA9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOldhKCtuKSx0KTppfSx0LnkxPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhvPW51bGw9PW4/bnVsbDpcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoK24pLHQpOm99LHQubGluZVgwPXQubGluZVkwPWZ1bmN0aW9uKCl7cmV0dXJuIG4oKS54KGUpLnkoaSl9LHQubGluZVkxPWZ1bmN0aW9uKCl7cmV0dXJuIG4oKS54KGUpLnkobyl9LHQubGluZVgxPWZ1bmN0aW9uKCl7cmV0dXJuIG4oKS54KHIpLnkoaSl9LHQuZGVmaW5lZD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoISFuKSx0KTp1fSx0LmN1cnZlPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhjPW4sbnVsbCE9YSYmKHM9YyhhKSksdCk6Y30sdC5jb250ZXh0PWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhudWxsPT1uP2E9cz1udWxsOnM9YyhhPW4pLHQpOmF9LHR9ZnVuY3Rpb24gY2ModCxuKXtyZXR1cm4gbjx0Py0xOm4+dD8xOm4+PXQ/MDpOYU59ZnVuY3Rpb24gc2ModCl7cmV0dXJuIHR9ZnVuY3Rpb24gZmModCl7dGhpcy5fY3VydmU9dH1mdW5jdGlvbiBsYyh0KXtmdW5jdGlvbiBuKG4pe3JldHVybiBuZXcgZmModChuKSl9cmV0dXJuIG4uX2N1cnZlPXQsbn1mdW5jdGlvbiBoYyh0KXt2YXIgbj10LmN1cnZlO3JldHVybiB0LmFuZ2xlPXQueCxkZWxldGUgdC54LHQucmFkaXVzPXQueSxkZWxldGUgdC55LHQuY3VydmU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/bihsYyh0KSk6bigpLl9jdXJ2ZX0sdH1mdW5jdGlvbiBwYygpe3JldHVybiBoYyh1YygpLmN1cnZlKGlfKSl9ZnVuY3Rpb24gZGMoKXt2YXIgdD1hYygpLmN1cnZlKGlfKSxuPXQuY3VydmUsZT10LmxpbmVYMCxyPXQubGluZVgxLGk9dC5saW5lWTAsbz10LmxpbmVZMTtyZXR1cm4gdC5hbmdsZT10LngsZGVsZXRlIHQueCx0LnN0YXJ0QW5nbGU9dC54MCxkZWxldGUgdC54MCx0LmVuZEFuZ2xlPXQueDEsZGVsZXRlIHQueDEsdC5yYWRpdXM9dC55LGRlbGV0ZSB0LnksdC5pbm5lclJhZGl1cz10LnkwLGRlbGV0ZSB0LnkwLHQub3V0ZXJSYWRpdXM9dC55MSxkZWxldGUgdC55MSx0LmxpbmVTdGFydEFuZ2xlPWZ1bmN0aW9uKCl7cmV0dXJuIGhjKGUoKSl9LGRlbGV0ZSB0LmxpbmVYMCx0LmxpbmVFbmRBbmdsZT1mdW5jdGlvbigpe3JldHVybiBoYyhyKCkpfSxkZWxldGUgdC5saW5lWDEsdC5saW5lSW5uZXJSYWRpdXM9ZnVuY3Rpb24oKXtyZXR1cm4gaGMoaSgpKX0sZGVsZXRlIHQubGluZVkwLHQubGluZU91dGVyUmFkaXVzPWZ1bmN0aW9uKCl7cmV0dXJuIGhjKG8oKSl9LGRlbGV0ZSB0LmxpbmVZMSx0LmN1cnZlPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP24obGModCkpOm4oKS5fY3VydmV9LHR9ZnVuY3Rpb24gdmModCxuKXtyZXR1cm5bKG49K24pKk1hdGguY29zKHQtPU1hdGguUEkvMiksbipNYXRoLnNpbih0KV19ZnVuY3Rpb24gZ2ModCl7cmV0dXJuIHQuc291cmNlfWZ1bmN0aW9uIF9jKHQpe3JldHVybiB0LnRhcmdldH1mdW5jdGlvbiB5Yyh0KXtmdW5jdGlvbiBuKCl7dmFyIG4sYT1vXy5jYWxsKGFyZ3VtZW50cyksYz1lLmFwcGx5KHRoaXMsYSkscz1yLmFwcGx5KHRoaXMsYSk7aWYodXx8KHU9bj10ZSgpKSx0KHUsK2kuYXBwbHkodGhpcywoYVswXT1jLGEpKSwrby5hcHBseSh0aGlzLGEpLCtpLmFwcGx5KHRoaXMsKGFbMF09cyxhKSksK28uYXBwbHkodGhpcyxhKSksbilyZXR1cm4gdT1udWxsLG4rXCJcInx8bnVsbH12YXIgZT1nYyxyPV9jLGk9aWMsbz1vYyx1PW51bGw7cmV0dXJuIG4uc291cmNlPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPXQsbik6ZX0sbi50YXJnZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9dCxuKTpyfSxuLng9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OldhKCt0KSxuKTppfSxuLnk9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG89XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OldhKCt0KSxuKTpvfSxuLmNvbnRleHQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHU9bnVsbD09dD9udWxsOnQsbik6dX0sbn1mdW5jdGlvbiBtYyh0LG4sZSxyLGkpe3QubW92ZVRvKG4sZSksdC5iZXppZXJDdXJ2ZVRvKG49KG4rcikvMixlLG4saSxyLGkpfWZ1bmN0aW9uIHhjKHQsbixlLHIsaSl7dC5tb3ZlVG8obixlKSx0LmJlemllckN1cnZlVG8obixlPShlK2kpLzIscixlLHIsaSl9ZnVuY3Rpb24gYmModCxuLGUscixpKXt2YXIgbz12YyhuLGUpLHU9dmMobixlPShlK2kpLzIpLGE9dmMocixlKSxjPXZjKHIsaSk7dC5tb3ZlVG8ob1swXSxvWzFdKSx0LmJlemllckN1cnZlVG8odVswXSx1WzFdLGFbMF0sYVsxXSxjWzBdLGNbMV0pfWZ1bmN0aW9uIHdjKCl7fWZ1bmN0aW9uIE1jKHQsbixlKXt0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oKDIqdC5feDArdC5feDEpLzMsKDIqdC5feTArdC5feTEpLzMsKHQuX3gwKzIqdC5feDEpLzMsKHQuX3kwKzIqdC5feTEpLzMsKHQuX3gwKzQqdC5feDErbikvNiwodC5feTArNCp0Ll95MStlKS82KX1mdW5jdGlvbiBUYyh0KXt0aGlzLl9jb250ZXh0PXR9ZnVuY3Rpb24gTmModCl7dGhpcy5fY29udGV4dD10fWZ1bmN0aW9uIGtjKHQpe3RoaXMuX2NvbnRleHQ9dH1mdW5jdGlvbiBTYyh0LG4pe3RoaXMuX2Jhc2lzPW5ldyBUYyh0KSx0aGlzLl9iZXRhPW59ZnVuY3Rpb24gRWModCxuLGUpe3QuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh0Ll94MSt0Ll9rKih0Ll94Mi10Ll94MCksdC5feTErdC5fayoodC5feTItdC5feTApLHQuX3gyK3QuX2sqKHQuX3gxLW4pLHQuX3kyK3QuX2sqKHQuX3kxLWUpLHQuX3gyLHQuX3kyKX1mdW5jdGlvbiBBYyh0LG4pe3RoaXMuX2NvbnRleHQ9dCx0aGlzLl9rPSgxLW4pLzZ9ZnVuY3Rpb24gQ2ModCxuKXt0aGlzLl9jb250ZXh0PXQsdGhpcy5faz0oMS1uKS82fWZ1bmN0aW9uIHpjKHQsbil7dGhpcy5fY29udGV4dD10LHRoaXMuX2s9KDEtbikvNn1mdW5jdGlvbiBQYyh0LG4sZSl7dmFyIHI9dC5feDEsaT10Ll95MSxvPXQuX3gyLHU9dC5feTI7aWYodC5fbDAxX2E+dF8pe3ZhciBhPTIqdC5fbDAxXzJhKzMqdC5fbDAxX2EqdC5fbDEyX2ErdC5fbDEyXzJhLGM9Myp0Ll9sMDFfYSoodC5fbDAxX2ErdC5fbDEyX2EpO3I9KHIqYS10Ll94MCp0Ll9sMTJfMmErdC5feDIqdC5fbDAxXzJhKS9jLGk9KGkqYS10Ll95MCp0Ll9sMTJfMmErdC5feTIqdC5fbDAxXzJhKS9jfWlmKHQuX2wyM19hPnRfKXt2YXIgcz0yKnQuX2wyM18yYSszKnQuX2wyM19hKnQuX2wxMl9hK3QuX2wxMl8yYSxmPTMqdC5fbDIzX2EqKHQuX2wyM19hK3QuX2wxMl9hKTtvPShvKnMrdC5feDEqdC5fbDIzXzJhLW4qdC5fbDEyXzJhKS9mLHU9KHUqcyt0Ll95MSp0Ll9sMjNfMmEtZSp0Ll9sMTJfMmEpL2Z9dC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHIsaSxvLHUsdC5feDIsdC5feTIpfWZ1bmN0aW9uIFJjKHQsbil7dGhpcy5fY29udGV4dD10LHRoaXMuX2FscGhhPW59ZnVuY3Rpb24gTGModCxuKXt0aGlzLl9jb250ZXh0PXQsdGhpcy5fYWxwaGE9bn1mdW5jdGlvbiBxYyh0LG4pe3RoaXMuX2NvbnRleHQ9dCx0aGlzLl9hbHBoYT1ufWZ1bmN0aW9uIERjKHQpe3RoaXMuX2NvbnRleHQ9dH1mdW5jdGlvbiBVYyh0KXtyZXR1cm4gdDwwPy0xOjF9ZnVuY3Rpb24gT2ModCxuLGUpe3ZhciByPXQuX3gxLXQuX3gwLGk9bi10Ll94MSxvPSh0Ll95MS10Ll95MCkvKHJ8fGk8MCYmLTApLHU9KGUtdC5feTEpLyhpfHxyPDAmJi0wKSxhPShvKmkrdSpyKS8ocitpKTtyZXR1cm4oVWMobykrVWModSkpKk1hdGgubWluKE1hdGguYWJzKG8pLE1hdGguYWJzKHUpLC41Kk1hdGguYWJzKGEpKXx8MH1mdW5jdGlvbiBGYyh0LG4pe3ZhciBlPXQuX3gxLXQuX3gwO3JldHVybiBlPygzKih0Ll95MS10Ll95MCkvZS1uKS8yOm59ZnVuY3Rpb24gSWModCxuLGUpe3ZhciByPXQuX3gwLGk9dC5feTAsbz10Ll94MSx1PXQuX3kxLGE9KG8tcikvMzt0Ll9jb250ZXh0LmJlemllckN1cnZlVG8ocithLGkrYSpuLG8tYSx1LWEqZSxvLHUpfWZ1bmN0aW9uIFljKHQpe3RoaXMuX2NvbnRleHQ9dH1mdW5jdGlvbiBCYyh0KXt0aGlzLl9jb250ZXh0PW5ldyBIYyh0KX1mdW5jdGlvbiBIYyh0KXt0aGlzLl9jb250ZXh0PXR9ZnVuY3Rpb24gamModCl7dGhpcy5fY29udGV4dD10fWZ1bmN0aW9uIFhjKHQpe3ZhciBuLGUscj10Lmxlbmd0aC0xLGk9bmV3IEFycmF5KHIpLG89bmV3IEFycmF5KHIpLHU9bmV3IEFycmF5KHIpO2ZvcihpWzBdPTAsb1swXT0yLHVbMF09dFswXSsyKnRbMV0sbj0xO248ci0xOysrbilpW25dPTEsb1tuXT00LHVbbl09NCp0W25dKzIqdFtuKzFdO2ZvcihpW3ItMV09MixvW3ItMV09Nyx1W3ItMV09OCp0W3ItMV0rdFtyXSxuPTE7bjxyOysrbillPWlbbl0vb1tuLTFdLG9bbl0tPWUsdVtuXS09ZSp1W24tMV07Zm9yKGlbci0xXT11W3ItMV0vb1tyLTFdLG49ci0yO24+PTA7LS1uKWlbbl09KHVbbl0taVtuKzFdKS9vW25dO2ZvcihvW3ItMV09KHRbcl0raVtyLTFdKS8yLG49MDtuPHItMTsrK24pb1tuXT0yKnRbbisxXS1pW24rMV07cmV0dXJuW2ksb119ZnVuY3Rpb24gVmModCxuKXt0aGlzLl9jb250ZXh0PXQsdGhpcy5fdD1ufWZ1bmN0aW9uICRjKHQsbil7aWYoKGk9dC5sZW5ndGgpPjEpZm9yKHZhciBlLHIsaSxvPTEsdT10W25bMF1dLGE9dS5sZW5ndGg7bzxpOysrbylmb3Iocj11LHU9dFtuW29dXSxlPTA7ZTxhOysrZSl1W2VdWzFdKz11W2VdWzBdPWlzTmFOKHJbZV1bMV0pP3JbZV1bMF06cltlXVsxXX1mdW5jdGlvbiBXYyh0KXtmb3IodmFyIG49dC5sZW5ndGgsZT1uZXcgQXJyYXkobik7LS1uPj0wOyllW25dPW47cmV0dXJuIGV9ZnVuY3Rpb24gWmModCxuKXtyZXR1cm4gdFtuXX1mdW5jdGlvbiBHYyh0KXt2YXIgbj10Lm1hcChRYyk7cmV0dXJuIFdjKHQpLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gblt0XS1uW2VdfSl9ZnVuY3Rpb24gUWModCl7Zm9yKHZhciBuLGU9MCxyPS0xLGk9dC5sZW5ndGg7KytyPGk7KShuPSt0W3JdWzFdKSYmKGUrPW4pO3JldHVybiBlfWZ1bmN0aW9uIEpjKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX1mdW5jdGlvbiBLYyh0KXtyZXR1cm4gdFswXX1mdW5jdGlvbiB0cyh0KXtyZXR1cm4gdFsxXX1mdW5jdGlvbiBucygpe3RoaXMuXz1udWxsfWZ1bmN0aW9uIGVzKHQpe3QuVT10LkM9dC5MPXQuUj10LlA9dC5OPW51bGx9ZnVuY3Rpb24gcnModCxuKXt2YXIgZT1uLHI9bi5SLGk9ZS5VO2k/aS5MPT09ZT9pLkw9cjppLlI9cjp0Ll89cixyLlU9aSxlLlU9cixlLlI9ci5MLGUuUiYmKGUuUi5VPWUpLHIuTD1lfWZ1bmN0aW9uIGlzKHQsbil7dmFyIGU9bixyPW4uTCxpPWUuVTtpP2kuTD09PWU/aS5MPXI6aS5SPXI6dC5fPXIsci5VPWksZS5VPXIsZS5MPXIuUixlLkwmJihlLkwuVT1lKSxyLlI9ZX1mdW5jdGlvbiBvcyh0KXtmb3IoO3QuTDspdD10Lkw7cmV0dXJuIHR9ZnVuY3Rpb24gdXModCxuLGUscil7dmFyIGk9W251bGwsbnVsbF0sbz1MXy5wdXNoKGkpLTE7cmV0dXJuIGkubGVmdD10LGkucmlnaHQ9bixlJiZjcyhpLHQsbixlKSxyJiZjcyhpLG4sdCxyKSxQX1t0LmluZGV4XS5oYWxmZWRnZXMucHVzaChvKSxQX1tuLmluZGV4XS5oYWxmZWRnZXMucHVzaChvKSxpfWZ1bmN0aW9uIGFzKHQsbixlKXt2YXIgcj1bbixlXTtyZXR1cm4gci5sZWZ0PXQscn1mdW5jdGlvbiBjcyh0LG4sZSxyKXt0WzBdfHx0WzFdP3QubGVmdD09PWU/dFsxXT1yOnRbMF09cjoodFswXT1yLHQubGVmdD1uLHQucmlnaHQ9ZSl9ZnVuY3Rpb24gc3ModCxuLGUscixpKXt2YXIgbyx1PXRbMF0sYT10WzFdLGM9dVswXSxzPXVbMV0sZj0wLGw9MSxoPWFbMF0tYyxwPWFbMV0tcztpZihvPW4tYyxofHwhKG8+MCkpe2lmKG8vPWgsaDwwKXtpZihvPGYpcmV0dXJuO288bCYmKGw9byl9ZWxzZSBpZihoPjApe2lmKG8+bClyZXR1cm47bz5mJiYoZj1vKX1pZihvPXItYyxofHwhKG88MCkpe2lmKG8vPWgsaDwwKXtpZihvPmwpcmV0dXJuO28+ZiYmKGY9byl9ZWxzZSBpZihoPjApe2lmKG88ZilyZXR1cm47bzxsJiYobD1vKX1pZihvPWUtcyxwfHwhKG8+MCkpe2lmKG8vPXAscDwwKXtpZihvPGYpcmV0dXJuO288bCYmKGw9byl9ZWxzZSBpZihwPjApe2lmKG8+bClyZXR1cm47bz5mJiYoZj1vKX1pZihvPWktcyxwfHwhKG88MCkpe2lmKG8vPXAscDwwKXtpZihvPmwpcmV0dXJuO28+ZiYmKGY9byl9ZWxzZSBpZihwPjApe2lmKG88ZilyZXR1cm47bzxsJiYobD1vKX1yZXR1cm4hKGY+MHx8bDwxKXx8KGY+MCYmKHRbMF09W2MrZipoLHMrZipwXSksbDwxJiYodFsxXT1bYytsKmgscytsKnBdKSwhMCl9fX19fWZ1bmN0aW9uIGZzKHQsbixlLHIsaSl7dmFyIG89dFsxXTtpZihvKXJldHVybiEwO3ZhciB1LGEsYz10WzBdLHM9dC5sZWZ0LGY9dC5yaWdodCxsPXNbMF0saD1zWzFdLHA9ZlswXSxkPWZbMV0sdj0obCtwKS8yLGc9KGgrZCkvMjtpZihkPT09aCl7aWYodjxufHx2Pj1yKXJldHVybjtpZihsPnApe2lmKGMpe2lmKGNbMV0+PWkpcmV0dXJufWVsc2UgYz1bdixlXTtvPVt2LGldfWVsc2V7aWYoYyl7aWYoY1sxXTxlKXJldHVybn1lbHNlIGM9W3YsaV07bz1bdixlXX19ZWxzZSBpZih1PShsLXApLyhkLWgpLGE9Zy11KnYsdTwtMXx8dT4xKWlmKGw+cCl7aWYoYyl7aWYoY1sxXT49aSlyZXR1cm59ZWxzZSBjPVsoZS1hKS91LGVdO289WyhpLWEpL3UsaV19ZWxzZXtpZihjKXtpZihjWzFdPGUpcmV0dXJufWVsc2UgYz1bKGktYSkvdSxpXTtvPVsoZS1hKS91LGVdfWVsc2UgaWYoaDxkKXtpZihjKXtpZihjWzBdPj1yKXJldHVybn1lbHNlIGM9W24sdSpuK2FdO289W3IsdSpyK2FdfWVsc2V7aWYoYyl7aWYoY1swXTxuKXJldHVybn1lbHNlIGM9W3IsdSpyK2FdO289W24sdSpuK2FdfXJldHVybiB0WzBdPWMsdFsxXT1vLCEwfWZ1bmN0aW9uIGxzKHQsbil7dmFyIGU9dC5zaXRlLHI9bi5sZWZ0LGk9bi5yaWdodDtyZXR1cm4gZT09PWkmJihpPXIscj1lKSxpP01hdGguYXRhbjIoaVsxXS1yWzFdLGlbMF0tclswXSk6KGU9PT1yPyhyPW5bMV0saT1uWzBdKToocj1uWzBdLGk9blsxXSksTWF0aC5hdGFuMihyWzBdLWlbMF0saVsxXS1yWzFdKSl9ZnVuY3Rpb24gaHModCxuKXtyZXR1cm4gblsrKG4ubGVmdCE9PXQuc2l0ZSldfWZ1bmN0aW9uIHBzKHQsbil7cmV0dXJuIG5bKyhuLmxlZnQ9PT10LnNpdGUpXX1mdW5jdGlvbiBkcyh0KXt2YXIgbj10LlAsZT10Lk47aWYobiYmZSl7dmFyIHI9bi5zaXRlLGk9dC5zaXRlLG89ZS5zaXRlO2lmKHIhPT1vKXt2YXIgdT1pWzBdLGE9aVsxXSxjPXJbMF0tdSxzPXJbMV0tYSxmPW9bMF0tdSxsPW9bMV0tYSxoPTIqKGMqbC1zKmYpO2lmKCEoaD49LU9fKSl7dmFyIHA9YypjK3MqcyxkPWYqZitsKmwsdj0obCpwLXMqZCkvaCxnPShjKmQtZipwKS9oLF89cV8ucG9wKCl8fG5ldyBmdW5jdGlvbigpe2VzKHRoaXMpLHRoaXMueD10aGlzLnk9dGhpcy5hcmM9dGhpcy5zaXRlPXRoaXMuY3k9bnVsbH07Xy5hcmM9dCxfLnNpdGU9aSxfLng9dit1LF8ueT0oXy5jeT1nK2EpK01hdGguc3FydCh2KnYrZypnKSx0LmNpcmNsZT1fO2Zvcih2YXIgeT1udWxsLG09Ul8uXzttOylpZihfLnk8bS55fHxfLnk9PT1tLnkmJl8ueDw9bS54KXtpZighbS5MKXt5PW0uUDticmVha31tPW0uTH1lbHNle2lmKCFtLlIpe3k9bTticmVha31tPW0uUn1SXy5pbnNlcnQoeSxfKSx5fHwoQ189Xyl9fX19ZnVuY3Rpb24gdnModCl7dmFyIG49dC5jaXJjbGU7biYmKG4uUHx8KENfPW4uTiksUl8ucmVtb3ZlKG4pLHFfLnB1c2gobiksZXMobiksdC5jaXJjbGU9bnVsbCl9ZnVuY3Rpb24gZ3ModCl7dmFyIG49RF8ucG9wKCl8fG5ldyBmdW5jdGlvbigpe2VzKHRoaXMpLHRoaXMuZWRnZT10aGlzLnNpdGU9dGhpcy5jaXJjbGU9bnVsbH07cmV0dXJuIG4uc2l0ZT10LG59ZnVuY3Rpb24gX3ModCl7dnModCksel8ucmVtb3ZlKHQpLERfLnB1c2godCksZXModCl9ZnVuY3Rpb24geXModCl7dmFyIG49dC5jaXJjbGUsZT1uLngscj1uLmN5LGk9W2Uscl0sbz10LlAsdT10Lk4sYT1bdF07X3ModCk7Zm9yKHZhciBjPW87Yy5jaXJjbGUmJk1hdGguYWJzKGUtYy5jaXJjbGUueCk8VV8mJk1hdGguYWJzKHItYy5jaXJjbGUuY3kpPFVfOylvPWMuUCxhLnVuc2hpZnQoYyksX3MoYyksYz1vO2EudW5zaGlmdChjKSx2cyhjKTtmb3IodmFyIHM9dTtzLmNpcmNsZSYmTWF0aC5hYnMoZS1zLmNpcmNsZS54KTxVXyYmTWF0aC5hYnMoci1zLmNpcmNsZS5jeSk8VV87KXU9cy5OLGEucHVzaChzKSxfcyhzKSxzPXU7YS5wdXNoKHMpLHZzKHMpO3ZhciBmLGw9YS5sZW5ndGg7Zm9yKGY9MTtmPGw7KytmKXM9YVtmXSxjPWFbZi0xXSxjcyhzLmVkZ2UsYy5zaXRlLHMuc2l0ZSxpKTtjPWFbMF0sKHM9YVtsLTFdKS5lZGdlPXVzKGMuc2l0ZSxzLnNpdGUsbnVsbCxpKSxkcyhjKSxkcyhzKX1mdW5jdGlvbiBtcyh0KXtmb3IodmFyIG4sZSxyLGksbz10WzBdLHU9dFsxXSxhPXpfLl87YTspaWYoKHI9eHMoYSx1KS1vKT5VXylhPWEuTDtlbHNle2lmKCEoKGk9by1mdW5jdGlvbih0LG4pe3ZhciBlPXQuTjtpZihlKXJldHVybiB4cyhlLG4pO3ZhciByPXQuc2l0ZTtyZXR1cm4gclsxXT09PW4/clswXToxLzB9KGEsdSkpPlVfKSl7cj4tVV8/KG49YS5QLGU9YSk6aT4tVV8/KG49YSxlPWEuTik6bj1lPWE7YnJlYWt9aWYoIWEuUil7bj1hO2JyZWFrfWE9YS5SfShmdW5jdGlvbih0KXtQX1t0LmluZGV4XT17c2l0ZTp0LGhhbGZlZGdlczpbXX19KSh0KTt2YXIgYz1ncyh0KTtpZih6Xy5pbnNlcnQobixjKSxufHxlKXtpZihuPT09ZSlyZXR1cm4gdnMobiksZT1ncyhuLnNpdGUpLHpfLmluc2VydChjLGUpLGMuZWRnZT1lLmVkZ2U9dXMobi5zaXRlLGMuc2l0ZSksZHMobiksdm9pZCBkcyhlKTtpZihlKXt2cyhuKSx2cyhlKTt2YXIgcz1uLnNpdGUsZj1zWzBdLGw9c1sxXSxoPXRbMF0tZixwPXRbMV0tbCxkPWUuc2l0ZSx2PWRbMF0tZixnPWRbMV0tbCxfPTIqKGgqZy1wKnYpLHk9aCpoK3AqcCxtPXYqditnKmcseD1bKGcqeS1wKm0pL18rZiwoaCptLXYqeSkvXytsXTtjcyhlLmVkZ2UscyxkLHgpLGMuZWRnZT11cyhzLHQsbnVsbCx4KSxlLmVkZ2U9dXModCxkLG51bGwseCksZHMobiksZHMoZSl9ZWxzZSBjLmVkZ2U9dXMobi5zaXRlLGMuc2l0ZSl9fWZ1bmN0aW9uIHhzKHQsbil7dmFyIGU9dC5zaXRlLHI9ZVswXSxpPWVbMV0sbz1pLW47aWYoIW8pcmV0dXJuIHI7dmFyIHU9dC5QO2lmKCF1KXJldHVybi0xLzA7dmFyIGE9KGU9dS5zaXRlKVswXSxjPWVbMV0scz1jLW47aWYoIXMpcmV0dXJuIGE7dmFyIGY9YS1yLGw9MS9vLTEvcyxoPWYvcztyZXR1cm4gbD8oLWgrTWF0aC5zcXJ0KGgqaC0yKmwqKGYqZi8oLTIqcyktYytzLzIraS1vLzIpKSkvbCtyOihyK2EpLzJ9ZnVuY3Rpb24gYnModCxuLGUpe3JldHVybih0WzBdLWVbMF0pKihuWzFdLXRbMV0pLSh0WzBdLW5bMF0pKihlWzFdLXRbMV0pfWZ1bmN0aW9uIHdzKHQsbil7cmV0dXJuIG5bMV0tdFsxXXx8blswXS10WzBdfWZ1bmN0aW9uIE1zKHQsbil7dmFyIGUscixpLG89dC5zb3J0KHdzKS5wb3AoKTtmb3IoTF89W10sUF89bmV3IEFycmF5KHQubGVuZ3RoKSx6Xz1uZXcgbnMsUl89bmV3IG5zOzspaWYoaT1DXyxvJiYoIWl8fG9bMV08aS55fHxvWzFdPT09aS55JiZvWzBdPGkueCkpb1swXT09PWUmJm9bMV09PT1yfHwobXMobyksZT1vWzBdLHI9b1sxXSksbz10LnBvcCgpO2Vsc2V7aWYoIWkpYnJlYWs7eXMoaS5hcmMpfWlmKGZ1bmN0aW9uKCl7Zm9yKHZhciB0LG4sZSxyLGk9MCxvPVBfLmxlbmd0aDtpPG87KytpKWlmKCh0PVBfW2ldKSYmKHI9KG49dC5oYWxmZWRnZXMpLmxlbmd0aCkpe3ZhciB1PW5ldyBBcnJheShyKSxhPW5ldyBBcnJheShyKTtmb3IoZT0wO2U8cjsrK2UpdVtlXT1lLGFbZV09bHModCxMX1tuW2VdXSk7Zm9yKHUuc29ydChmdW5jdGlvbih0LG4pe3JldHVybiBhW25dLWFbdF19KSxlPTA7ZTxyOysrZSlhW2VdPW5bdVtlXV07Zm9yKGU9MDtlPHI7KytlKW5bZV09YVtlXX19KCksbil7dmFyIHU9K25bMF1bMF0sYT0rblswXVsxXSxjPStuWzFdWzBdLHM9K25bMV1bMV07KGZ1bmN0aW9uKHQsbixlLHIpe2Zvcih2YXIgaSxvPUxfLmxlbmd0aDtvLS07KWZzKGk9TF9bb10sdCxuLGUscikmJnNzKGksdCxuLGUscikmJihNYXRoLmFicyhpWzBdWzBdLWlbMV1bMF0pPlVffHxNYXRoLmFicyhpWzBdWzFdLWlbMV1bMV0pPlVfKXx8ZGVsZXRlIExfW29dfSkodSxhLGMscyksZnVuY3Rpb24odCxuLGUscil7dmFyIGksbyx1LGEsYyxzLGYsbCxoLHAsZCx2LGc9UF8ubGVuZ3RoLF89ITA7Zm9yKGk9MDtpPGc7KytpKWlmKG89UF9baV0pe2Zvcih1PW8uc2l0ZSxhPShjPW8uaGFsZmVkZ2VzKS5sZW5ndGg7YS0tOylMX1tjW2FdXXx8Yy5zcGxpY2UoYSwxKTtmb3IoYT0wLHM9Yy5sZW5ndGg7YTxzOylkPShwPXBzKG8sTF9bY1thXV0pKVswXSx2PXBbMV0sbD0oZj1ocyhvLExfW2NbKythJXNdXSkpWzBdLGg9ZlsxXSwoTWF0aC5hYnMoZC1sKT5VX3x8TWF0aC5hYnModi1oKT5VXykmJihjLnNwbGljZShhLDAsTF8ucHVzaChhcyh1LHAsTWF0aC5hYnMoZC10KTxVXyYmci12PlVfP1t0LE1hdGguYWJzKGwtdCk8VV8/aDpyXTpNYXRoLmFicyh2LXIpPFVfJiZlLWQ+VV8/W01hdGguYWJzKGgtcik8VV8/bDplLHJdOk1hdGguYWJzKGQtZSk8VV8mJnYtbj5VXz9bZSxNYXRoLmFicyhsLWUpPFVfP2g6bl06TWF0aC5hYnModi1uKTxVXyYmZC10PlVfP1tNYXRoLmFicyhoLW4pPFVfP2w6dCxuXTpudWxsKSktMSksKytzKTtzJiYoXz0hMSl9aWYoXyl7dmFyIHksbSx4LGI9MS8wO2ZvcihpPTAsXz1udWxsO2k8ZzsrK2kpKG89UF9baV0pJiYoeD0oeT0odT1vLnNpdGUpWzBdLXQpKnkrKG09dVsxXS1uKSptKTxiJiYoYj14LF89byk7aWYoXyl7dmFyIHc9W3Qsbl0sTT1bdCxyXSxUPVtlLHJdLE49W2Usbl07Xy5oYWxmZWRnZXMucHVzaChMXy5wdXNoKGFzKHU9Xy5zaXRlLHcsTSkpLTEsTF8ucHVzaChhcyh1LE0sVCkpLTEsTF8ucHVzaChhcyh1LFQsTikpLTEsTF8ucHVzaChhcyh1LE4sdykpLTEpfX1mb3IoaT0wO2k8ZzsrK2kpKG89UF9baV0pJiYoby5oYWxmZWRnZXMubGVuZ3RofHxkZWxldGUgUF9baV0pfSh1LGEsYyxzKX10aGlzLmVkZ2VzPUxfLHRoaXMuY2VsbHM9UF8sel89Ul89TF89UF89bnVsbH1mdW5jdGlvbiBUcyh0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdH19ZnVuY3Rpb24gTnModCxuLGUpe3RoaXMuaz10LHRoaXMueD1uLHRoaXMueT1lfWZ1bmN0aW9uIGtzKHQpe3JldHVybiB0Ll9fem9vbXx8Rl99ZnVuY3Rpb24gU3MoKXt0LmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfWZ1bmN0aW9uIEVzKCl7dC5ldmVudC5wcmV2ZW50RGVmYXVsdCgpLHQuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCl9ZnVuY3Rpb24gQXMoKXtyZXR1cm4hdC5ldmVudC5idXR0b259ZnVuY3Rpb24gQ3MoKXt2YXIgdCxuLGU9dGhpcztyZXR1cm4gZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ/KHQ9KGU9ZS5vd25lclNWR0VsZW1lbnR8fGUpLndpZHRoLmJhc2VWYWwudmFsdWUsbj1lLmhlaWdodC5iYXNlVmFsLnZhbHVlKToodD1lLmNsaWVudFdpZHRoLG49ZS5jbGllbnRIZWlnaHQpLFtbMCwwXSxbdCxuXV19ZnVuY3Rpb24genMoKXtyZXR1cm4gdGhpcy5fX3pvb218fEZffWZ1bmN0aW9uIFBzKCl7cmV0dXJuLXQuZXZlbnQuZGVsdGFZKih0LmV2ZW50LmRlbHRhTW9kZT8xMjA6MSkvNTAwfWZ1bmN0aW9uIFJzKCl7cmV0dXJuXCJvbnRvdWNoc3RhcnRcImluIHRoaXN9ZnVuY3Rpb24gTHModCxuLGUpe3ZhciByPXQuaW52ZXJ0WChuWzBdWzBdKS1lWzBdWzBdLGk9dC5pbnZlcnRYKG5bMV1bMF0pLWVbMV1bMF0sbz10LmludmVydFkoblswXVsxXSktZVswXVsxXSx1PXQuaW52ZXJ0WShuWzFdWzFdKS1lWzFdWzFdO3JldHVybiB0LnRyYW5zbGF0ZShpPnI/KHIraSkvMjpNYXRoLm1pbigwLHIpfHxNYXRoLm1heCgwLGkpLHU+bz8obyt1KS8yOk1hdGgubWluKDAsbyl8fE1hdGgubWF4KDAsdSkpfXZhciBxcz1lKG4pLERzPXFzLnJpZ2h0LFVzPXFzLmxlZnQsT3M9QXJyYXkucHJvdG90eXBlLEZzPU9zLnNsaWNlLElzPU9zLm1hcCxZcz1NYXRoLnNxcnQoNTApLEJzPU1hdGguc3FydCgxMCksSHM9TWF0aC5zcXJ0KDIpLGpzPUFycmF5LnByb3RvdHlwZS5zbGljZSxYcz0xLFZzPTIsJHM9MyxXcz00LFpzPTFlLTYsR3M9e3ZhbHVlOmZ1bmN0aW9uKCl7fX07ay5wcm90b3R5cGU9Ti5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmssb246ZnVuY3Rpb24odCxuKXt2YXIgZSxyPXRoaXMuXyxpPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHQudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCl7dmFyIGU9XCJcIixyPXQuaW5kZXhPZihcIi5cIik7aWYocj49MCYmKGU9dC5zbGljZShyKzEpLHQ9dC5zbGljZSgwLHIpKSx0JiYhbi5oYXNPd25Qcm9wZXJ0eSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiK3QpO3JldHVybnt0eXBlOnQsbmFtZTplfX0pfSh0K1wiXCIsciksbz0tMSx1PWkubGVuZ3RoO3tpZighKGFyZ3VtZW50cy5sZW5ndGg8Mikpe2lmKG51bGwhPW4mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIrbik7Zm9yKDsrK288dTspaWYoZT0odD1pW29dKS50eXBlKXJbZV09UyhyW2VdLHQubmFtZSxuKTtlbHNlIGlmKG51bGw9PW4pZm9yKGUgaW4gcilyW2VdPVMocltlXSx0Lm5hbWUsbnVsbCk7cmV0dXJuIHRoaXN9Zm9yKDsrK288dTspaWYoKGU9KHQ9aVtvXSkudHlwZSkmJihlPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlLHI9MCxpPXQubGVuZ3RoO3I8aTsrK3IpaWYoKGU9dFtyXSkubmFtZT09PW4pcmV0dXJuIGUudmFsdWV9KHJbZV0sdC5uYW1lKSkpcmV0dXJuIGV9fSxjb3B5OmZ1bmN0aW9uKCl7dmFyIHQ9e30sbj10aGlzLl87Zm9yKHZhciBlIGluIG4pdFtlXT1uW2VdLnNsaWNlKCk7cmV0dXJuIG5ldyBrKHQpfSxjYWxsOmZ1bmN0aW9uKHQsbil7aWYoKGU9YXJndW1lbnRzLmxlbmd0aC0yKT4wKWZvcih2YXIgZSxyLGk9bmV3IEFycmF5KGUpLG89MDtvPGU7KytvKWlbb109YXJndW1lbnRzW28rMl07aWYoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiK3QpO2ZvcihvPTAsZT0ocj10aGlzLl9bdF0pLmxlbmd0aDtvPGU7KytvKXJbb10udmFsdWUuYXBwbHkobixpKX0sYXBwbHk6ZnVuY3Rpb24odCxuLGUpe2lmKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodCkpdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIit0KTtmb3IodmFyIHI9dGhpcy5fW3RdLGk9MCxvPXIubGVuZ3RoO2k8bzsrK2kpcltpXS52YWx1ZS5hcHBseShuLGUpfX07dmFyIFFzPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLEpzPXtzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHhodG1sOlFzLHhsaW5rOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLHhtbDpcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIn0sS3M9MDt6LnByb3RvdHlwZT1DLnByb3RvdHlwZT17Y29uc3RydWN0b3I6eixnZXQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBuPXRoaXMuXzshKG4gaW4gdCk7KWlmKCEodD10LnBhcmVudE5vZGUpKXJldHVybjtyZXR1cm4gdFtuXX0sc2V0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbdGhpcy5fXT1ufSxyZW1vdmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuXyBpbiB0JiZkZWxldGUgdFt0aGlzLl9dfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl99fTt2YXIgdGY9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF0Y2hlcyh0KX19O2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCl7dmFyIG5mPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtpZighbmYubWF0Y2hlcyl7dmFyIGVmPW5mLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8bmYubXNNYXRjaGVzU2VsZWN0b3J8fG5mLm1vek1hdGNoZXNTZWxlY3Rvcnx8bmYub01hdGNoZXNTZWxlY3Rvcjt0Zj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZWYuY2FsbCh0aGlzLHQpfX19fXZhciByZj10ZixvZj17fTtpZih0LmV2ZW50PW51bGwsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50KXtcIm9ubW91c2VlbnRlclwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHwob2Y9e21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIn0pfVgucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpYLGFwcGVuZENoaWxkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKHQsdGhpcy5fbmV4dCl9LGluc2VydEJlZm9yZTpmdW5jdGlvbih0LG4pe3JldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKHQsbil9LHF1ZXJ5U2VsZWN0b3I6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHQpfSxxdWVyeVNlbGVjdG9yQWxsOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbCh0KX19O3ZhciB1Zj1cIiRcIjtLLnByb3RvdHlwZT17YWRkOmZ1bmN0aW9uKHQpe3RoaXMuX25hbWVzLmluZGV4T2YodCk8MCYmKHRoaXMuX25hbWVzLnB1c2godCksdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKSl9LHJlbW92ZTpmdW5jdGlvbih0KXt2YXIgbj10aGlzLl9uYW1lcy5pbmRleE9mKHQpO24+PTAmJih0aGlzLl9uYW1lcy5zcGxpY2UobiwxKSx0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsdGhpcy5fbmFtZXMuam9pbihcIiBcIikpKX0sY29udGFpbnM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YodCk+PTB9fTt2YXIgYWY9W251bGxdO3N0LnByb3RvdHlwZT1mdC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOnN0LHNlbGVjdDpmdW5jdGlvbih0KXtcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiYodD1ZKHQpKTtmb3IodmFyIG49dGhpcy5fZ3JvdXBzLGU9bi5sZW5ndGgscj1uZXcgQXJyYXkoZSksaT0wO2k8ZTsrK2kpZm9yKHZhciBvLHUsYT1uW2ldLGM9YS5sZW5ndGgscz1yW2ldPW5ldyBBcnJheShjKSxmPTA7ZjxjOysrZikobz1hW2ZdKSYmKHU9dC5jYWxsKG8sby5fX2RhdGFfXyxmLGEpKSYmKFwiX19kYXRhX19cImluIG8mJih1Ll9fZGF0YV9fPW8uX19kYXRhX18pLHNbZl09dSk7cmV0dXJuIG5ldyBzdChyLHRoaXMuX3BhcmVudHMpfSxzZWxlY3RBbGw6ZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiIT10eXBlb2YgdCYmKHQ9SCh0KSk7Zm9yKHZhciBuPXRoaXMuX2dyb3VwcyxlPW4ubGVuZ3RoLHI9W10saT1bXSxvPTA7bzxlOysrbylmb3IodmFyIHUsYT1uW29dLGM9YS5sZW5ndGgscz0wO3M8YzsrK3MpKHU9YVtzXSkmJihyLnB1c2godC5jYWxsKHUsdS5fX2RhdGFfXyxzLGEpKSxpLnB1c2godSkpO3JldHVybiBuZXcgc3QocixpKX0sZmlsdGVyOmZ1bmN0aW9uKHQpe1wiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJih0PXJmKHQpKTtmb3IodmFyIG49dGhpcy5fZ3JvdXBzLGU9bi5sZW5ndGgscj1uZXcgQXJyYXkoZSksaT0wO2k8ZTsrK2kpZm9yKHZhciBvLHU9bltpXSxhPXUubGVuZ3RoLGM9cltpXT1bXSxzPTA7czxhOysrcykobz11W3NdKSYmdC5jYWxsKG8sby5fX2RhdGFfXyxzLHUpJiZjLnB1c2gobyk7cmV0dXJuIG5ldyBzdChyLHRoaXMuX3BhcmVudHMpfSxkYXRhOmZ1bmN0aW9uKHQsbil7aWYoIXQpcmV0dXJuIHA9bmV3IEFycmF5KHRoaXMuc2l6ZSgpKSxzPS0xLHRoaXMuZWFjaChmdW5jdGlvbih0KXtwWysrc109dH0pLHA7dmFyIGU9bj8kOlYscj10aGlzLl9wYXJlbnRzLGk9dGhpcy5fZ3JvdXBzO1wiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJih0PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX0odCkpO2Zvcih2YXIgbz1pLmxlbmd0aCx1PW5ldyBBcnJheShvKSxhPW5ldyBBcnJheShvKSxjPW5ldyBBcnJheShvKSxzPTA7czxvOysrcyl7dmFyIGY9cltzXSxsPWlbc10saD1sLmxlbmd0aCxwPXQuY2FsbChmLGYmJmYuX19kYXRhX18scyxyKSxkPXAubGVuZ3RoLHY9YVtzXT1uZXcgQXJyYXkoZCksZz11W3NdPW5ldyBBcnJheShkKTtlKGYsbCx2LGcsY1tzXT1uZXcgQXJyYXkoaCkscCxuKTtmb3IodmFyIF8seSxtPTAseD0wO208ZDsrK20paWYoXz12W21dKXtmb3IobT49eCYmKHg9bSsxKTshKHk9Z1t4XSkmJisreDxkOyk7Xy5fbmV4dD15fHxudWxsfX1yZXR1cm4gdT1uZXcgc3QodSxyKSx1Ll9lbnRlcj1hLHUuX2V4aXQ9Yyx1fSxlbnRlcjpmdW5jdGlvbigpe3JldHVybiBuZXcgc3QodGhpcy5fZW50ZXJ8fHRoaXMuX2dyb3Vwcy5tYXAoaiksdGhpcy5fcGFyZW50cyl9LGV4aXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHN0KHRoaXMuX2V4aXR8fHRoaXMuX2dyb3Vwcy5tYXAoaiksdGhpcy5fcGFyZW50cyl9LG1lcmdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbj10aGlzLl9ncm91cHMsZT10Ll9ncm91cHMscj1uLmxlbmd0aCxpPWUubGVuZ3RoLG89TWF0aC5taW4ocixpKSx1PW5ldyBBcnJheShyKSxhPTA7YTxvOysrYSlmb3IodmFyIGMscz1uW2FdLGY9ZVthXSxsPXMubGVuZ3RoLGg9dVthXT1uZXcgQXJyYXkobCkscD0wO3A8bDsrK3ApKGM9c1twXXx8ZltwXSkmJihoW3BdPWMpO2Zvcig7YTxyOysrYSl1W2FdPW5bYV07cmV0dXJuIG5ldyBzdCh1LHRoaXMuX3BhcmVudHMpfSxvcmRlcjpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9ncm91cHMsbj0tMSxlPXQubGVuZ3RoOysrbjxlOylmb3IodmFyIHIsaT10W25dLG89aS5sZW5ndGgtMSx1PWlbb107LS1vPj0wOykocj1pW29dKSYmKHUmJnUhPT1yLm5leHRTaWJsaW5nJiZ1LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHIsdSksdT1yKTtyZXR1cm4gdGhpc30sc29ydDpmdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4sZSl7cmV0dXJuIG4mJmU/dChuLl9fZGF0YV9fLGUuX19kYXRhX18pOiFuLSFlfXR8fCh0PVcpO2Zvcih2YXIgZT10aGlzLl9ncm91cHMscj1lLmxlbmd0aCxpPW5ldyBBcnJheShyKSxvPTA7bzxyOysrbyl7Zm9yKHZhciB1LGE9ZVtvXSxjPWEubGVuZ3RoLHM9aVtvXT1uZXcgQXJyYXkoYyksZj0wO2Y8YzsrK2YpKHU9YVtmXSkmJihzW2ZdPXUpO3Muc29ydChuKX1yZXR1cm4gbmV3IHN0KGksdGhpcy5fcGFyZW50cykub3JkZXIoKX0sY2FsbDpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzBdPXRoaXMsdC5hcHBseShudWxsLGFyZ3VtZW50cyksdGhpc30sbm9kZXM6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLG49LTE7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3RbKytuXT10aGlzfSksdH0sbm9kZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9ncm91cHMsbj0wLGU9dC5sZW5ndGg7bjxlOysrbilmb3IodmFyIHI9dFtuXSxpPTAsbz1yLmxlbmd0aDtpPG87KytpKXt2YXIgdT1yW2ldO2lmKHUpcmV0dXJuIHV9cmV0dXJuIG51bGx9LHNpemU6ZnVuY3Rpb24oKXt2YXIgdD0wO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsrK3R9KSx0fSxlbXB0eTpmdW5jdGlvbigpe3JldHVybiF0aGlzLm5vZGUoKX0sZWFjaDpmdW5jdGlvbih0KXtmb3IodmFyIG49dGhpcy5fZ3JvdXBzLGU9MCxyPW4ubGVuZ3RoO2U8cjsrK2UpZm9yKHZhciBpLG89bltlXSx1PTAsYT1vLmxlbmd0aDt1PGE7Kyt1KShpPW9bdV0pJiZ0LmNhbGwoaSxpLl9fZGF0YV9fLHUsbyk7cmV0dXJuIHRoaXN9LGF0dHI6ZnVuY3Rpb24odCxuKXt2YXIgZT1FKHQpO2lmKGFyZ3VtZW50cy5sZW5ndGg8Mil7dmFyIHI9dGhpcy5ub2RlKCk7cmV0dXJuIGUubG9jYWw/ci5nZXRBdHRyaWJ1dGVOUyhlLnNwYWNlLGUubG9jYWwpOnIuZ2V0QXR0cmlidXRlKGUpfXJldHVybiB0aGlzLmVhY2goKG51bGw9PW4/ZS5sb2NhbD9mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKHQuc3BhY2UsdC5sb2NhbCl9fTpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0KX19OlwiZnVuY3Rpb25cIj09dHlwZW9mIG4/ZS5sb2NhbD9mdW5jdGlvbih0LG4pe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGw9PWU/dGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyh0LnNwYWNlLHQubG9jYWwpOnRoaXMuc2V0QXR0cmlidXRlTlModC5zcGFjZSx0LmxvY2FsLGUpfX06ZnVuY3Rpb24odCxuKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT1uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsPT1lP3RoaXMucmVtb3ZlQXR0cmlidXRlKHQpOnRoaXMuc2V0QXR0cmlidXRlKHQsZSl9fTplLmxvY2FsP2Z1bmN0aW9uKHQsbil7cmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy5zZXRBdHRyaWJ1dGVOUyh0LnNwYWNlLHQubG9jYWwsbil9fTpmdW5jdGlvbih0LG4pe3JldHVybiBmdW5jdGlvbigpe3RoaXMuc2V0QXR0cmlidXRlKHQsbil9fSkoZSxuKSl9LHN0eWxlOmZ1bmN0aW9uKHQsbixlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4xP3RoaXMuZWFjaCgobnVsbD09bj9mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KHQpfX06XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9mdW5jdGlvbih0LG4sZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHI9bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbD09cj90aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KHQpOnRoaXMuc3R5bGUuc2V0UHJvcGVydHkodCxyLGUpfX06ZnVuY3Rpb24odCxuLGUpe3JldHVybiBmdW5jdGlvbigpe3RoaXMuc3R5bGUuc2V0UHJvcGVydHkodCxuLGUpfX0pKHQsbixudWxsPT1lP1wiXCI6ZSkpOkcodGhpcy5ub2RlKCksdCl9LHByb3BlcnR5OmZ1bmN0aW9uKHQsbil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MT90aGlzLmVhY2goKG51bGw9PW4/ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZGVsZXRlIHRoaXNbdF19fTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP2Z1bmN0aW9uKHQsbil7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbD09ZT9kZWxldGUgdGhpc1t0XTp0aGlzW3RdPWV9fTpmdW5jdGlvbih0LG4pe3JldHVybiBmdW5jdGlvbigpe3RoaXNbdF09bn19KSh0LG4pKTp0aGlzLm5vZGUoKVt0XX0sY2xhc3NlZDpmdW5jdGlvbih0LG4pe3ZhciBlPVEodCtcIlwiKTtpZihhcmd1bWVudHMubGVuZ3RoPDIpe2Zvcih2YXIgcj1KKHRoaXMubm9kZSgpKSxpPS0xLG89ZS5sZW5ndGg7KytpPG87KWlmKCFyLmNvbnRhaW5zKGVbaV0pKXJldHVybiExO3JldHVybiEwfXJldHVybiB0aGlzLmVhY2goKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4/ZnVuY3Rpb24odCxuKXtyZXR1cm4gZnVuY3Rpb24oKXsobi5hcHBseSh0aGlzLGFyZ3VtZW50cyk/dHQ6bnQpKHRoaXMsdCl9fTpuP2Z1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3R0KHRoaXMsdCl9fTpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtudCh0aGlzLHQpfX0pKGUsbikpfSx0ZXh0OmZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMuZWFjaChudWxsPT10P2V0OihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0P2Z1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMudGV4dENvbnRlbnQ9bnVsbD09bj9cIlwiOm59fTpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLnRleHRDb250ZW50PXR9fSkodCkpOnRoaXMubm9kZSgpLnRleHRDb250ZW50fSxodG1sOmZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMuZWFjaChudWxsPT10P3J0OihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0P2Z1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuaW5uZXJIVE1MPW51bGw9PW4/XCJcIjpufX06ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy5pbm5lckhUTUw9dH19KSh0KSk6dGhpcy5ub2RlKCkuaW5uZXJIVE1MfSxyYWlzZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2goaXQpfSxsb3dlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2gob3QpfSxhcHBlbmQ6ZnVuY3Rpb24odCl7dmFyIG49XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OkEodCk7cmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQobi5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSl9LGluc2VydDpmdW5jdGlvbih0LG4pe3ZhciBlPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpBKHQpLHI9bnVsbD09bj91dDpcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246WShuKTtyZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksci5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fG51bGwpfSl9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2goYXQpfSxkYXR1bTpmdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIix0KTp0aGlzLm5vZGUoKS5fX2RhdGFfX30sb246ZnVuY3Rpb24odCxuLGUpe3ZhciByLGksbz1mdW5jdGlvbih0KXtyZXR1cm4gdC50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KXt2YXIgbj1cIlwiLGU9dC5pbmRleE9mKFwiLlwiKTtyZXR1cm4gZT49MCYmKG49dC5zbGljZShlKzEpLHQ9dC5zbGljZSgwLGUpKSx7dHlwZTp0LG5hbWU6bn19KX0odCtcIlwiKSx1PW8ubGVuZ3RoO2lmKCEoYXJndW1lbnRzLmxlbmd0aDwyKSl7Zm9yKGE9bj9xOkwsbnVsbD09ZSYmKGU9ITEpLHI9MDtyPHU7KytyKXRoaXMuZWFjaChhKG9bcl0sbixlKSk7cmV0dXJuIHRoaXN9dmFyIGE9dGhpcy5ub2RlKCkuX19vbjtpZihhKWZvcih2YXIgYyxzPTAsZj1hLmxlbmd0aDtzPGY7KytzKWZvcihyPTAsYz1hW3NdO3I8dTsrK3IpaWYoKGk9b1tyXSkudHlwZT09PWMudHlwZSYmaS5uYW1lPT09Yy5uYW1lKXJldHVybiBjLnZhbHVlfSxkaXNwYXRjaDpmdW5jdGlvbih0LG4pe3JldHVybiB0aGlzLmVhY2goKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4/ZnVuY3Rpb24odCxuKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gY3QodGhpcyx0LG4uYXBwbHkodGhpcyxhcmd1bWVudHMpKX19OmZ1bmN0aW9uKHQsbil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGN0KHRoaXMsdCxuKX19KSh0LG4pKX19LHl0LnByb3RvdHlwZS5vbj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuXy5vbi5hcHBseSh0aGlzLl8sYXJndW1lbnRzKTtyZXR1cm4gdD09PXRoaXMuXz90aGlzOnR9O3ZhciBjZj1cIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixzZj1cIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLGZmPVwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLGxmPS9eIyhbMC05YS1mXXszfSkkLyxoZj0vXiMoWzAtOWEtZl17Nn0pJC8scGY9bmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiK1tjZixjZixjZl0rXCJcXFxcKSRcIiksZGY9bmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiK1tmZixmZixmZl0rXCJcXFxcKSRcIiksdmY9bmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIitbY2YsY2YsY2Ysc2ZdK1wiXFxcXCkkXCIpLGdmPW5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIrW2ZmLGZmLGZmLHNmXStcIlxcXFwpJFwiKSxfZj1uZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIrW3NmLGZmLGZmXStcIlxcXFwpJFwiKSx5Zj1uZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiK1tzZixmZixmZixzZl0rXCJcXFxcKSRcIiksbWY9e2FsaWNlYmx1ZToxNTc5MjM4MyxhbnRpcXVld2hpdGU6MTY0NDQzNzUsYXF1YTo2NTUzNSxhcXVhbWFyaW5lOjgzODg1NjQsYXp1cmU6MTU3OTQxNzUsYmVpZ2U6MTYxMTkyNjAsYmlzcXVlOjE2NzcwMjQ0LGJsYWNrOjAsYmxhbmNoZWRhbG1vbmQ6MTY3NzIwNDUsYmx1ZToyNTUsYmx1ZXZpb2xldDo5MDU1MjAyLGJyb3duOjEwODI0MjM0LGJ1cmx5d29vZDoxNDU5NjIzMSxjYWRldGJsdWU6NjI2NjUyOCxjaGFydHJldXNlOjgzODgzNTIsY2hvY29sYXRlOjEzNzg5NDcwLGNvcmFsOjE2NzQ0MjcyLGNvcm5mbG93ZXJibHVlOjY1OTE5ODEsY29ybnNpbGs6MTY3NzUzODgsY3JpbXNvbjoxNDQyMzEwMCxjeWFuOjY1NTM1LGRhcmtibHVlOjEzOSxkYXJrY3lhbjozNTcyMyxkYXJrZ29sZGVucm9kOjEyMDkyOTM5LGRhcmtncmF5OjExMTE5MDE3LGRhcmtncmVlbjoyNTYwMCxkYXJrZ3JleToxMTExOTAxNyxkYXJra2hha2k6MTI0MzMyNTksZGFya21hZ2VudGE6OTEwOTY0MyxkYXJrb2xpdmVncmVlbjo1NTk3OTk5LGRhcmtvcmFuZ2U6MTY3NDc1MjAsZGFya29yY2hpZDoxMDA0MDAxMixkYXJrcmVkOjkxMDk1MDQsZGFya3NhbG1vbjoxNTMwODQxMCxkYXJrc2VhZ3JlZW46OTQxOTkxOSxkYXJrc2xhdGVibHVlOjQ3MzQzNDcsZGFya3NsYXRlZ3JheTozMTAwNDk1LGRhcmtzbGF0ZWdyZXk6MzEwMDQ5NSxkYXJrdHVycXVvaXNlOjUyOTQ1LGRhcmt2aW9sZXQ6OTY5OTUzOSxkZWVwcGluazoxNjcxNjk0NyxkZWVwc2t5Ymx1ZTo0OTE1MSxkaW1ncmF5OjY5MDgyNjUsZGltZ3JleTo2OTA4MjY1LGRvZGdlcmJsdWU6MjAwMzE5OSxmaXJlYnJpY2s6MTE2NzQxNDYsZmxvcmFsd2hpdGU6MTY3NzU5MjAsZm9yZXN0Z3JlZW46MjI2Mzg0MixmdWNoc2lhOjE2NzExOTM1LGdhaW5zYm9ybzoxNDQ3NDQ2MCxnaG9zdHdoaXRlOjE2MzE2NjcxLGdvbGQ6MTY3NjY3MjAsZ29sZGVucm9kOjE0MzI5MTIwLGdyYXk6ODQyMTUwNCxncmVlbjozMjc2OCxncmVlbnllbGxvdzoxMTQwMzA1NSxncmV5Ojg0MjE1MDQsaG9uZXlkZXc6MTU3OTQxNjAsaG90cGluazoxNjczODc0MCxpbmRpYW5yZWQ6MTM0NTg1MjQsaW5kaWdvOjQ5MTUzMzAsaXZvcnk6MTY3NzcyMDAsa2hha2k6MTU3ODc2NjAsbGF2ZW5kZXI6MTUxMzI0MTAsbGF2ZW5kZXJibHVzaDoxNjc3MzM2NSxsYXduZ3JlZW46ODE5MDk3NixsZW1vbmNoaWZmb246MTY3NzU4ODUsbGlnaHRibHVlOjExMzkzMjU0LGxpZ2h0Y29yYWw6MTU3NjE1MzYsbGlnaHRjeWFuOjE0NzQ1NTk5LGxpZ2h0Z29sZGVucm9keWVsbG93OjE2NDQ4MjEwLGxpZ2h0Z3JheToxMzg4MjMyMyxsaWdodGdyZWVuOjk0OTgyNTYsbGlnaHRncmV5OjEzODgyMzIzLGxpZ2h0cGluazoxNjc1ODQ2NSxsaWdodHNhbG1vbjoxNjc1Mjc2MixsaWdodHNlYWdyZWVuOjIxNDI4OTAsbGlnaHRza3libHVlOjg5MDAzNDYsbGlnaHRzbGF0ZWdyYXk6NzgzMzc1MyxsaWdodHNsYXRlZ3JleTo3ODMzNzUzLGxpZ2h0c3RlZWxibHVlOjExNTg0NzM0LGxpZ2h0eWVsbG93OjE2Nzc3MTg0LGxpbWU6NjUyODAsbGltZWdyZWVuOjMzMjkzMzAsbGluZW46MTY0NDU2NzAsbWFnZW50YToxNjcxMTkzNSxtYXJvb246ODM4ODYwOCxtZWRpdW1hcXVhbWFyaW5lOjY3MzczMjIsbWVkaXVtYmx1ZToyMDUsbWVkaXVtb3JjaGlkOjEyMjExNjY3LG1lZGl1bXB1cnBsZTo5NjYyNjgzLG1lZGl1bXNlYWdyZWVuOjM5NzgwOTcsbWVkaXVtc2xhdGVibHVlOjgwODc3OTAsbWVkaXVtc3ByaW5nZ3JlZW46NjQxNTQsbWVkaXVtdHVycXVvaXNlOjQ3NzIzMDAsbWVkaXVtdmlvbGV0cmVkOjEzMDQ3MTczLG1pZG5pZ2h0Ymx1ZToxNjQ0OTEyLG1pbnRjcmVhbToxNjEyMTg1MCxtaXN0eXJvc2U6MTY3NzAyNzMsbW9jY2FzaW46MTY3NzAyMjksbmF2YWpvd2hpdGU6MTY3Njg2ODUsbmF2eToxMjgsb2xkbGFjZToxNjY0MzU1OCxvbGl2ZTo4NDIxMzc2LG9saXZlZHJhYjo3MDQ4NzM5LG9yYW5nZToxNjc1MzkyMCxvcmFuZ2VyZWQ6MTY3MjkzNDQsb3JjaGlkOjE0MzE1NzM0LHBhbGVnb2xkZW5yb2Q6MTU2NTcxMzAscGFsZWdyZWVuOjEwMDI1ODgwLHBhbGV0dXJxdW9pc2U6MTE1Mjk5NjYscGFsZXZpb2xldHJlZDoxNDM4MTIwMyxwYXBheWF3aGlwOjE2NzczMDc3LHBlYWNocHVmZjoxNjc2NzY3MyxwZXJ1OjEzNDY4OTkxLHBpbms6MTY3NjEwMzUscGx1bToxNDUyNDYzNyxwb3dkZXJibHVlOjExNTkxOTEwLHB1cnBsZTo4Mzg4NzM2LHJlYmVjY2FwdXJwbGU6NjY5Nzg4MSxyZWQ6MTY3MTE2ODAscm9zeWJyb3duOjEyMzU3NTE5LHJveWFsYmx1ZTo0Mjg2OTQ1LHNhZGRsZWJyb3duOjkxMjcxODcsc2FsbW9uOjE2NDE2ODgyLHNhbmR5YnJvd246MTYwMzI4NjQsc2VhZ3JlZW46MzA1MDMyNyxzZWFzaGVsbDoxNjc3NDYzOCxzaWVubmE6MTA1MDY3OTcsc2lsdmVyOjEyNjMyMjU2LHNreWJsdWU6ODkwMDMzMSxzbGF0ZWJsdWU6Njk3MDA2MSxzbGF0ZWdyYXk6NzM3Mjk0NCxzbGF0ZWdyZXk6NzM3Mjk0NCxzbm93OjE2Nzc1OTMwLHNwcmluZ2dyZWVuOjY1NDA3LHN0ZWVsYmx1ZTo0NjIwOTgwLHRhbjoxMzgwODc4MCx0ZWFsOjMyODk2LHRoaXN0bGU6MTQyMDQ4ODgsdG9tYXRvOjE2NzM3MDk1LHR1cnF1b2lzZTo0MjUxODU2LHZpb2xldDoxNTYzMTA4Nix3aGVhdDoxNjExMzMzMSx3aGl0ZToxNjc3NzIxNSx3aGl0ZXNtb2tlOjE2MTE5Mjg1LHllbGxvdzoxNjc3Njk2MCx5ZWxsb3dncmVlbjoxMDE0NTA3NH07TXQoTnQsa3Qse2Rpc3BsYXlhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZ2IoKStcIlwifX0pLE10KHp0LEN0LFR0KE50LHticmlnaHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdD1udWxsPT10PzEvLjc6TWF0aC5wb3coMS8uNyx0KSxuZXcgenQodGhpcy5yKnQsdGhpcy5nKnQsdGhpcy5iKnQsdGhpcy5vcGFjaXR5KX0sZGFya2VyOmZ1bmN0aW9uKHQpe3JldHVybiB0PW51bGw9PXQ/Ljc6TWF0aC5wb3coLjcsdCksbmV3IHp0KHRoaXMucip0LHRoaXMuZyp0LHRoaXMuYip0LHRoaXMub3BhY2l0eSl9LHJnYjpmdW5jdGlvbigpe3JldHVybiB0aGlzfSxkaXNwbGF5YWJsZTpmdW5jdGlvbigpe3JldHVybiAwPD10aGlzLnImJnRoaXMucjw9MjU1JiYwPD10aGlzLmcmJnRoaXMuZzw9MjU1JiYwPD10aGlzLmImJnRoaXMuYjw9MjU1JiYwPD10aGlzLm9wYWNpdHkmJnRoaXMub3BhY2l0eTw9MX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wYWNpdHk7cmV0dXJuKDE9PT0odD1pc05hTih0KT8xOk1hdGgubWF4KDAsTWF0aC5taW4oMSx0KSkpP1wicmdiKFwiOlwicmdiYShcIikrTWF0aC5tYXgoMCxNYXRoLm1pbigyNTUsTWF0aC5yb3VuZCh0aGlzLnIpfHwwKSkrXCIsIFwiK01hdGgubWF4KDAsTWF0aC5taW4oMjU1LE1hdGgucm91bmQodGhpcy5nKXx8MCkpK1wiLCBcIitNYXRoLm1heCgwLE1hdGgubWluKDI1NSxNYXRoLnJvdW5kKHRoaXMuYil8fDApKSsoMT09PXQ/XCIpXCI6XCIsIFwiK3QrXCIpXCIpfX0pKSxNdChMdCxSdCxUdChOdCx7YnJpZ2h0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9bnVsbD09dD8xLy43Ok1hdGgucG93KDEvLjcsdCksbmV3IEx0KHRoaXMuaCx0aGlzLnMsdGhpcy5sKnQsdGhpcy5vcGFjaXR5KX0sZGFya2VyOmZ1bmN0aW9uKHQpe3JldHVybiB0PW51bGw9PXQ/Ljc6TWF0aC5wb3coLjcsdCksbmV3IEx0KHRoaXMuaCx0aGlzLnMsdGhpcy5sKnQsdGhpcy5vcGFjaXR5KX0scmdiOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5oJTM2MCszNjAqKHRoaXMuaDwwKSxuPWlzTmFOKHQpfHxpc05hTih0aGlzLnMpPzA6dGhpcy5zLGU9dGhpcy5sLHI9ZSsoZTwuNT9lOjEtZSkqbixpPTIqZS1yO3JldHVybiBuZXcgenQocXQodD49MjQwP3QtMjQwOnQrMTIwLGkscikscXQodCxpLHIpLHF0KHQ8MTIwP3QrMjQwOnQtMTIwLGksciksdGhpcy5vcGFjaXR5KX0sZGlzcGxheWFibGU6ZnVuY3Rpb24oKXtyZXR1cm4oMDw9dGhpcy5zJiZ0aGlzLnM8PTF8fGlzTmFOKHRoaXMucykpJiYwPD10aGlzLmwmJnRoaXMubDw9MSYmMDw9dGhpcy5vcGFjaXR5JiZ0aGlzLm9wYWNpdHk8PTF9fSkpO3ZhciB4Zj1NYXRoLlBJLzE4MCxiZj0xODAvTWF0aC5QSSx3Zj0uOTUwNDcsTWY9MSxUZj0xLjA4ODgzLE5mPTQvMjksa2Y9Ni8yOSxTZj0zKmtmKmtmLEVmPWtmKmtmKmtmO010KE90LFV0LFR0KE50LHticmlnaHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IE90KHRoaXMubCsxOCoobnVsbD09dD8xOnQpLHRoaXMuYSx0aGlzLmIsdGhpcy5vcGFjaXR5KX0sZGFya2VyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgT3QodGhpcy5sLTE4KihudWxsPT10PzE6dCksdGhpcy5hLHRoaXMuYix0aGlzLm9wYWNpdHkpfSxyZ2I6ZnVuY3Rpb24oKXt2YXIgdD0odGhpcy5sKzE2KS8xMTYsbj1pc05hTih0aGlzLmEpP3Q6dCt0aGlzLmEvNTAwLGU9aXNOYU4odGhpcy5iKT90OnQtdGhpcy5iLzIwMDtyZXR1cm4gdD1NZipJdCh0KSxuPXdmKkl0KG4pLGU9VGYqSXQoZSksbmV3IHp0KFl0KDMuMjQwNDU0MipuLTEuNTM3MTM4NSp0LS40OTg1MzE0KmUpLFl0KC0uOTY5MjY2Km4rMS44NzYwMTA4KnQrLjA0MTU1NiplKSxZdCguMDU1NjQzNCpuLS4yMDQwMjU5KnQrMS4wNTcyMjUyKmUpLHRoaXMub3BhY2l0eSl9fSkpLE10KGp0LEh0LFR0KE50LHticmlnaHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGp0KHRoaXMuaCx0aGlzLmMsdGhpcy5sKzE4KihudWxsPT10PzE6dCksdGhpcy5vcGFjaXR5KX0sZGFya2VyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcganQodGhpcy5oLHRoaXMuYyx0aGlzLmwtMTgqKG51bGw9PXQ/MTp0KSx0aGlzLm9wYWNpdHkpfSxyZ2I6ZnVuY3Rpb24oKXtyZXR1cm4gRHQodGhpcykucmdiKCl9fSkpO3ZhciBBZj0tLjI5MjI3LENmPS0uOTA2NDksemY9MS45NzI5NCxQZj16ZipDZixSZj0xLjc4Mjc3KnpmLExmPTEuNzgyNzcqQWYtIC0uMTQ4NjEqQ2Y7TXQoVnQsWHQsVHQoTnQse2JyaWdodGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0PW51bGw9PXQ/MS8uNzpNYXRoLnBvdygxLy43LHQpLG5ldyBWdCh0aGlzLmgsdGhpcy5zLHRoaXMubCp0LHRoaXMub3BhY2l0eSl9LGRhcmtlcjpmdW5jdGlvbih0KXtyZXR1cm4gdD1udWxsPT10Py43Ok1hdGgucG93KC43LHQpLG5ldyBWdCh0aGlzLmgsdGhpcy5zLHRoaXMubCp0LHRoaXMub3BhY2l0eSl9LHJnYjpmdW5jdGlvbigpe3ZhciB0PWlzTmFOKHRoaXMuaCk/MDoodGhpcy5oKzEyMCkqeGYsbj0rdGhpcy5sLGU9aXNOYU4odGhpcy5zKT8wOnRoaXMucypuKigxLW4pLHI9TWF0aC5jb3ModCksaT1NYXRoLnNpbih0KTtyZXR1cm4gbmV3IHp0KDI1NSoobitlKigtLjE0ODYxKnIrMS43ODI3NyppKSksMjU1KihuK2UqKEFmKnIrQ2YqaSkpLDI1NSoobitlKih6ZipyKSksdGhpcy5vcGFjaXR5KX19KSk7dmFyIHFmLERmLFVmLE9mLEZmLElmLFlmPWZ1bmN0aW9uIHQobil7ZnVuY3Rpb24gZSh0LG4pe3ZhciBlPXIoKHQ9Q3QodCkpLnIsKG49Q3QobikpLnIpLGk9cih0Lmcsbi5nKSxvPXIodC5iLG4uYiksdT10bih0Lm9wYWNpdHksbi5vcGFjaXR5KTtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHQucj1lKG4pLHQuZz1pKG4pLHQuYj1vKG4pLHQub3BhY2l0eT11KG4pLHQrXCJcIn19dmFyIHI9S3Qobik7cmV0dXJuIGUuZ2FtbWE9dCxlfSgxKSxCZj1ubihXdCksSGY9bm4oWnQpLGpmPS9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxYZj1uZXcgUmVnRXhwKGpmLnNvdXJjZSxcImdcIiksVmY9MTgwL01hdGguUEksJGY9e3RyYW5zbGF0ZVg6MCx0cmFuc2xhdGVZOjAscm90YXRlOjAsc2tld1g6MCxzY2FsZVg6MSxzY2FsZVk6MX0sV2Y9bG4oZnVuY3Rpb24odCl7cmV0dXJuXCJub25lXCI9PT10PyRmOihxZnx8KHFmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksRGY9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFVmPWRvY3VtZW50LmRlZmF1bHRWaWV3KSxxZi5zdHlsZS50cmFuc2Zvcm09dCx0PVVmLmdldENvbXB1dGVkU3R5bGUoRGYuYXBwZW5kQ2hpbGQocWYpLG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIiksRGYucmVtb3ZlQ2hpbGQocWYpLHQ9dC5zbGljZSg3LC0xKS5zcGxpdChcIixcIiksZm4oK3RbMF0sK3RbMV0sK3RbMl0sK3RbM10sK3RbNF0sK3RbNV0pKX0sXCJweCwgXCIsXCJweClcIixcImRlZylcIiksWmY9bG4oZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/JGY6KE9mfHwoT2Y9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpLE9mLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLHQpLCh0PU9mLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpPyh0PXQubWF0cml4LGZuKHQuYSx0LmIsdC5jLHQuZCx0LmUsdC5mKSk6JGYpfSxcIiwgXCIsXCIpXCIsXCIpXCIpLEdmPU1hdGguU1FSVDIsUWY9MixKZj00LEtmPTFlLTEyLHRsPWRuKEp0KSxubD1kbih0biksZWw9dm4oSnQpLHJsPXZuKHRuKSxpbD1nbihKdCksb2w9Z24odG4pLHVsPTAsYWw9MCxjbD0wLHNsPTFlMyxmbD0wLGxsPTAsaGw9MCxwbD1cIm9iamVjdFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz9wZXJmb3JtYW5jZTpEYXRlLGRsPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyk6ZnVuY3Rpb24odCl7c2V0VGltZW91dCh0LDE3KX07bW4ucHJvdG90eXBlPXhuLnByb3RvdHlwZT17Y29uc3RydWN0b3I6bW4scmVzdGFydDpmdW5jdGlvbih0LG4sZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7ZT0obnVsbD09ZT9fbigpOitlKSsobnVsbD09bj8wOituKSx0aGlzLl9uZXh0fHxJZj09PXRoaXN8fChJZj9JZi5fbmV4dD10aGlzOkZmPXRoaXMsSWY9dGhpcyksdGhpcy5fY2FsbD10LHRoaXMuX3RpbWU9ZSxUbigpfSxzdG9wOmZ1bmN0aW9uKCl7dGhpcy5fY2FsbCYmKHRoaXMuX2NhbGw9bnVsbCx0aGlzLl90aW1lPTEvMCxUbigpKX19O3ZhciB2bD1OKFwic3RhcnRcIixcImVuZFwiLFwiaW50ZXJydXB0XCIpLGdsPVtdLF9sPTAseWw9MSxtbD0yLHhsPTMsYmw9NCx3bD01LE1sPTYsVGw9ZnQucHJvdG90eXBlLmNvbnN0cnVjdG9yLE5sPTAsa2w9ZnQucHJvdG90eXBlO1JuLnByb3RvdHlwZT1Mbi5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlJuLHNlbGVjdDpmdW5jdGlvbih0KXt2YXIgbj10aGlzLl9uYW1lLGU9dGhpcy5faWQ7XCJmdW5jdGlvblwiIT10eXBlb2YgdCYmKHQ9WSh0KSk7Zm9yKHZhciByPXRoaXMuX2dyb3VwcyxpPXIubGVuZ3RoLG89bmV3IEFycmF5KGkpLHU9MDt1PGk7Kyt1KWZvcih2YXIgYSxjLHM9clt1XSxmPXMubGVuZ3RoLGw9b1t1XT1uZXcgQXJyYXkoZiksaD0wO2g8ZjsrK2gpKGE9c1toXSkmJihjPXQuY2FsbChhLGEuX19kYXRhX18saCxzKSkmJihcIl9fZGF0YV9fXCJpbiBhJiYoYy5fX2RhdGFfXz1hLl9fZGF0YV9fKSxsW2hdPWMsa24obFtoXSxuLGUsaCxsLEFuKGEsZSkpKTtyZXR1cm4gbmV3IFJuKG8sdGhpcy5fcGFyZW50cyxuLGUpfSxzZWxlY3RBbGw6ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5fbmFtZSxlPXRoaXMuX2lkO1wiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJih0PUgodCkpO2Zvcih2YXIgcj10aGlzLl9ncm91cHMsaT1yLmxlbmd0aCxvPVtdLHU9W10sYT0wO2E8aTsrK2EpZm9yKHZhciBjLHM9clthXSxmPXMubGVuZ3RoLGw9MDtsPGY7KytsKWlmKGM9c1tsXSl7Zm9yKHZhciBoLHA9dC5jYWxsKGMsYy5fX2RhdGFfXyxsLHMpLGQ9QW4oYyxlKSx2PTAsZz1wLmxlbmd0aDt2PGc7Kyt2KShoPXBbdl0pJiZrbihoLG4sZSx2LHAsZCk7by5wdXNoKHApLHUucHVzaChjKX1yZXR1cm4gbmV3IFJuKG8sdSxuLGUpfSxmaWx0ZXI6ZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiIT10eXBlb2YgdCYmKHQ9cmYodCkpO2Zvcih2YXIgbj10aGlzLl9ncm91cHMsZT1uLmxlbmd0aCxyPW5ldyBBcnJheShlKSxpPTA7aTxlOysraSlmb3IodmFyIG8sdT1uW2ldLGE9dS5sZW5ndGgsYz1yW2ldPVtdLHM9MDtzPGE7KytzKShvPXVbc10pJiZ0LmNhbGwobyxvLl9fZGF0YV9fLHMsdSkmJmMucHVzaChvKTtyZXR1cm4gbmV3IFJuKHIsdGhpcy5fcGFyZW50cyx0aGlzLl9uYW1lLHRoaXMuX2lkKX0sbWVyZ2U6ZnVuY3Rpb24odCl7aWYodC5faWQhPT10aGlzLl9pZCl0aHJvdyBuZXcgRXJyb3I7Zm9yKHZhciBuPXRoaXMuX2dyb3VwcyxlPXQuX2dyb3VwcyxyPW4ubGVuZ3RoLGk9ZS5sZW5ndGgsbz1NYXRoLm1pbihyLGkpLHU9bmV3IEFycmF5KHIpLGE9MDthPG87KythKWZvcih2YXIgYyxzPW5bYV0sZj1lW2FdLGw9cy5sZW5ndGgsaD11W2FdPW5ldyBBcnJheShsKSxwPTA7cDxsOysrcCkoYz1zW3BdfHxmW3BdKSYmKGhbcF09Yyk7Zm9yKDthPHI7KythKXVbYV09blthXTtyZXR1cm4gbmV3IFJuKHUsdGhpcy5fcGFyZW50cyx0aGlzLl9uYW1lLHRoaXMuX2lkKX0sc2VsZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUbCh0aGlzLl9ncm91cHMsdGhpcy5fcGFyZW50cyl9LHRyYW5zaXRpb246ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5fbmFtZSxuPXRoaXMuX2lkLGU9cW4oKSxyPXRoaXMuX2dyb3VwcyxpPXIubGVuZ3RoLG89MDtvPGk7KytvKWZvcih2YXIgdSxhPXJbb10sYz1hLmxlbmd0aCxzPTA7czxjOysrcylpZih1PWFbc10pe3ZhciBmPUFuKHUsbik7a24odSx0LGUscyxhLHt0aW1lOmYudGltZStmLmRlbGF5K2YuZHVyYXRpb24sZGVsYXk6MCxkdXJhdGlvbjpmLmR1cmF0aW9uLGVhc2U6Zi5lYXNlfSl9cmV0dXJuIG5ldyBSbihyLHRoaXMuX3BhcmVudHMsdCxlKX0sY2FsbDprbC5jYWxsLG5vZGVzOmtsLm5vZGVzLG5vZGU6a2wubm9kZSxzaXplOmtsLnNpemUsZW1wdHk6a2wuZW1wdHksZWFjaDprbC5lYWNoLG9uOmZ1bmN0aW9uKHQsbil7dmFyIGU9dGhpcy5faWQ7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8Mj9Bbih0aGlzLm5vZGUoKSxlKS5vbi5vbih0KTp0aGlzLmVhY2goZnVuY3Rpb24odCxuLGUpe3ZhciByLGksbz1mdW5jdGlvbih0KXtyZXR1cm4odCtcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpe3ZhciBuPXQuaW5kZXhPZihcIi5cIik7cmV0dXJuIG4+PTAmJih0PXQuc2xpY2UoMCxuKSksIXR8fFwic3RhcnRcIj09PXR9KX0obik/U246RW47cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHU9byh0aGlzLHQpLGE9dS5vbjthIT09ciYmKGk9KHI9YSkuY29weSgpKS5vbihuLGUpLHUub249aX19KGUsdCxuKSl9LGF0dHI6ZnVuY3Rpb24odCxuKXt2YXIgZT1FKHQpLHI9XCJ0cmFuc2Zvcm1cIj09PWU/WmY6UG47cmV0dXJuIHRoaXMuYXR0clR3ZWVuKHQsXCJmdW5jdGlvblwiPT10eXBlb2Ygbj8oZS5sb2NhbD9mdW5jdGlvbih0LG4sZSl7dmFyIHIsaSxvO3JldHVybiBmdW5jdGlvbigpe3ZhciB1LGE9ZSh0aGlzKTtpZihudWxsIT1hKXJldHVybih1PXRoaXMuZ2V0QXR0cmlidXRlTlModC5zcGFjZSx0LmxvY2FsKSk9PT1hP251bGw6dT09PXImJmE9PT1pP286bz1uKHI9dSxpPWEpO3RoaXMucmVtb3ZlQXR0cmlidXRlTlModC5zcGFjZSx0LmxvY2FsKX19OmZ1bmN0aW9uKHQsbixlKXt2YXIgcixpLG87cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHUsYT1lKHRoaXMpO2lmKG51bGwhPWEpcmV0dXJuKHU9dGhpcy5nZXRBdHRyaWJ1dGUodCkpPT09YT9udWxsOnU9PT1yJiZhPT09aT9vOm89bihyPXUsaT1hKTt0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0KX19KShlLHIsem4odGhpcyxcImF0dHIuXCIrdCxuKSk6bnVsbD09bj8oZS5sb2NhbD9mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKHQuc3BhY2UsdC5sb2NhbCl9fTpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0KX19KShlKTooZS5sb2NhbD9mdW5jdGlvbih0LG4sZSl7dmFyIHIsaTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbz10aGlzLmdldEF0dHJpYnV0ZU5TKHQuc3BhY2UsdC5sb2NhbCk7cmV0dXJuIG89PT1lP251bGw6bz09PXI/aTppPW4ocj1vLGUpfX06ZnVuY3Rpb24odCxuLGUpe3ZhciByLGk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG89dGhpcy5nZXRBdHRyaWJ1dGUodCk7cmV0dXJuIG89PT1lP251bGw6bz09PXI/aTppPW4ocj1vLGUpfX0pKGUscixuK1wiXCIpKX0sYXR0clR3ZWVuOmZ1bmN0aW9uKHQsbil7dmFyIGU9XCJhdHRyLlwiK3Q7aWYoYXJndW1lbnRzLmxlbmd0aDwyKXJldHVybihlPXRoaXMudHdlZW4oZSkpJiZlLl92YWx1ZTtpZihudWxsPT1uKXJldHVybiB0aGlzLnR3ZWVuKGUsbnVsbCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3I7dmFyIHI9RSh0KTtyZXR1cm4gdGhpcy50d2VlbihlLChyLmxvY2FsP2Z1bmN0aW9uKHQsbil7ZnVuY3Rpb24gZSgpe3ZhciBlPXRoaXMscj1uLmFwcGx5KGUsYXJndW1lbnRzKTtyZXR1cm4gciYmZnVuY3Rpb24obil7ZS5zZXRBdHRyaWJ1dGVOUyh0LnNwYWNlLHQubG9jYWwscihuKSl9fXJldHVybiBlLl92YWx1ZT1uLGV9OmZ1bmN0aW9uKHQsbil7ZnVuY3Rpb24gZSgpe3ZhciBlPXRoaXMscj1uLmFwcGx5KGUsYXJndW1lbnRzKTtyZXR1cm4gciYmZnVuY3Rpb24obil7ZS5zZXRBdHRyaWJ1dGUodCxyKG4pKX19cmV0dXJuIGUuX3ZhbHVlPW4sZX0pKHIsbikpfSxzdHlsZTpmdW5jdGlvbih0LG4sZSl7dmFyIHI9XCJ0cmFuc2Zvcm1cIj09KHQrPVwiXCIpP1dmOlBuO3JldHVybiBudWxsPT1uP3RoaXMuc3R5bGVUd2Vlbih0LGZ1bmN0aW9uKHQsbil7dmFyIGUscixpO3JldHVybiBmdW5jdGlvbigpe3ZhciBvPUcodGhpcyx0KSx1PSh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KHQpLEcodGhpcyx0KSk7cmV0dXJuIG89PT11P251bGw6bz09PWUmJnU9PT1yP2k6aT1uKGU9byxyPXUpfX0odCxyKSkub24oXCJlbmQuc3R5bGUuXCIrdCxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KHQpfX0odCkpOnRoaXMuc3R5bGVUd2Vlbih0LFwiZnVuY3Rpb25cIj09dHlwZW9mIG4/ZnVuY3Rpb24odCxuLGUpe3ZhciByLGksbztyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdT1HKHRoaXMsdCksYT1lKHRoaXMpO3JldHVybiBudWxsPT1hJiYodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0KSxhPUcodGhpcyx0KSksdT09PWE/bnVsbDp1PT09ciYmYT09PWk/bzpvPW4ocj11LGk9YSl9fSh0LHIsem4odGhpcyxcInN0eWxlLlwiK3QsbikpOmZ1bmN0aW9uKHQsbixlKXt2YXIgcixpO3JldHVybiBmdW5jdGlvbigpe3ZhciBvPUcodGhpcyx0KTtyZXR1cm4gbz09PWU/bnVsbDpvPT09cj9pOmk9bihyPW8sZSl9fSh0LHIsbitcIlwiKSxlKX0sc3R5bGVUd2VlbjpmdW5jdGlvbih0LG4sZSl7dmFyIHI9XCJzdHlsZS5cIisodCs9XCJcIik7aWYoYXJndW1lbnRzLmxlbmd0aDwyKXJldHVybihyPXRoaXMudHdlZW4ocikpJiZyLl92YWx1ZTtpZihudWxsPT1uKXJldHVybiB0aGlzLnR3ZWVuKHIsbnVsbCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3I7cmV0dXJuIHRoaXMudHdlZW4ocixmdW5jdGlvbih0LG4sZSl7ZnVuY3Rpb24gcigpe3ZhciByPXRoaXMsaT1uLmFwcGx5KHIsYXJndW1lbnRzKTtyZXR1cm4gaSYmZnVuY3Rpb24obil7ci5zdHlsZS5zZXRQcm9wZXJ0eSh0LGkobiksZSl9fXJldHVybiByLl92YWx1ZT1uLHJ9KHQsbixudWxsPT1lP1wiXCI6ZSkpfSx0ZXh0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dCh0aGlzKTt0aGlzLnRleHRDb250ZW50PW51bGw9PW4/XCJcIjpufX0oem4odGhpcyxcInRleHRcIix0KSk6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy50ZXh0Q29udGVudD10fX0obnVsbD09dD9cIlwiOnQrXCJcIikpfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj10aGlzLnBhcmVudE5vZGU7Zm9yKHZhciBlIGluIHRoaXMuX190cmFuc2l0aW9uKWlmKCtlIT09dClyZXR1cm47biYmbi5yZW1vdmVDaGlsZCh0aGlzKX19KHRoaXMuX2lkKSl9LHR3ZWVuOmZ1bmN0aW9uKHQsbil7dmFyIGU9dGhpcy5faWQ7aWYodCs9XCJcIixhcmd1bWVudHMubGVuZ3RoPDIpe2Zvcih2YXIgcixpPUFuKHRoaXMubm9kZSgpLGUpLnR3ZWVuLG89MCx1PWkubGVuZ3RoO288dTsrK28paWYoKHI9aVtvXSkubmFtZT09PXQpcmV0dXJuIHIudmFsdWU7cmV0dXJuIG51bGx9cmV0dXJuIHRoaXMuZWFjaCgobnVsbD09bj9mdW5jdGlvbih0LG4pe3ZhciBlLHI7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGk9RW4odGhpcyx0KSxvPWkudHdlZW47aWYobyE9PWUpZm9yKHZhciB1PTAsYT0ocj1lPW8pLmxlbmd0aDt1PGE7Kyt1KWlmKHJbdV0ubmFtZT09PW4peyhyPXIuc2xpY2UoKSkuc3BsaWNlKHUsMSk7YnJlYWt9aS50d2Vlbj1yfX06ZnVuY3Rpb24odCxuLGUpe3ZhciByLGk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3I7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG89RW4odGhpcyx0KSx1PW8udHdlZW47aWYodSE9PXIpe2k9KHI9dSkuc2xpY2UoKTtmb3IodmFyIGE9e25hbWU6bix2YWx1ZTplfSxjPTAscz1pLmxlbmd0aDtjPHM7KytjKWlmKGlbY10ubmFtZT09PW4pe2lbY109YTticmVha31jPT09cyYmaS5wdXNoKGEpfW8udHdlZW49aX19KShlLHQsbikpfSxkZWxheTpmdW5jdGlvbih0KXt2YXIgbj10aGlzLl9pZDtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLmVhY2goKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/ZnVuY3Rpb24odCxuKXtyZXR1cm4gZnVuY3Rpb24oKXtTbih0aGlzLHQpLmRlbGF5PStuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19OmZ1bmN0aW9uKHQsbil7cmV0dXJuIG49K24sZnVuY3Rpb24oKXtTbih0aGlzLHQpLmRlbGF5PW59fSkobix0KSk6QW4odGhpcy5ub2RlKCksbikuZGVsYXl9LGR1cmF0aW9uOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuX2lkO3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMuZWFjaCgoXCJmdW5jdGlvblwiPT10eXBlb2YgdD9mdW5jdGlvbih0LG4pe3JldHVybiBmdW5jdGlvbigpe0VuKHRoaXMsdCkuZHVyYXRpb249K24uYXBwbHkodGhpcyxhcmd1bWVudHMpfX06ZnVuY3Rpb24odCxuKXtyZXR1cm4gbj0rbixmdW5jdGlvbigpe0VuKHRoaXMsdCkuZHVyYXRpb249bn19KShuLHQpKTpBbih0aGlzLm5vZGUoKSxuKS5kdXJhdGlvbn0sZWFzZTpmdW5jdGlvbih0KXt2YXIgbj10aGlzLl9pZDtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLmVhY2goZnVuY3Rpb24odCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcjtyZXR1cm4gZnVuY3Rpb24oKXtFbih0aGlzLHQpLmVhc2U9bn19KG4sdCkpOkFuKHRoaXMubm9kZSgpLG4pLmVhc2V9fTt2YXIgU2w9ZnVuY3Rpb24gdChuKXtmdW5jdGlvbiBlKHQpe3JldHVybiBNYXRoLnBvdyh0LG4pfXJldHVybiBuPStuLGUuZXhwb25lbnQ9dCxlfSgzKSxFbD1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCl7cmV0dXJuIDEtTWF0aC5wb3coMS10LG4pfXJldHVybiBuPStuLGUuZXhwb25lbnQ9dCxlfSgzKSxBbD1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCl7cmV0dXJuKCh0Kj0yKTw9MT9NYXRoLnBvdyh0LG4pOjItTWF0aC5wb3coMi10LG4pKS8yfXJldHVybiBuPStuLGUuZXhwb25lbnQ9dCxlfSgzKSxDbD1NYXRoLlBJLHpsPUNsLzIsUGw9NC8xMSxSbD02LzExLExsPTgvMTEscWw9Ljc1LERsPTkvMTEsVWw9MTAvMTEsT2w9LjkzNzUsRmw9MjEvMjIsSWw9NjMvNjQsWWw9MS9QbC9QbCxCbD1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCl7cmV0dXJuIHQqdCooKG4rMSkqdC1uKX1yZXR1cm4gbj0rbixlLm92ZXJzaG9vdD10LGV9KDEuNzAxNTgpLEhsPWZ1bmN0aW9uIHQobil7ZnVuY3Rpb24gZSh0KXtyZXR1cm4tLXQqdCooKG4rMSkqdCtuKSsxfXJldHVybiBuPStuLGUub3ZlcnNob290PXQsZX0oMS43MDE1OCksamw9ZnVuY3Rpb24gdChuKXtmdW5jdGlvbiBlKHQpe3JldHVybigodCo9Mik8MT90KnQqKChuKzEpKnQtbik6KHQtPTIpKnQqKChuKzEpKnQrbikrMikvMn1yZXR1cm4gbj0rbixlLm92ZXJzaG9vdD10LGV9KDEuNzAxNTgpLFhsPTIqTWF0aC5QSSxWbD1mdW5jdGlvbiB0KG4sZSl7ZnVuY3Rpb24gcih0KXtyZXR1cm4gbipNYXRoLnBvdygyLDEwKi0tdCkqTWF0aC5zaW4oKGktdCkvZSl9dmFyIGk9TWF0aC5hc2luKDEvKG49TWF0aC5tYXgoMSxuKSkpKihlLz1YbCk7cmV0dXJuIHIuYW1wbGl0dWRlPWZ1bmN0aW9uKG4pe3JldHVybiB0KG4sZSpYbCl9LHIucGVyaW9kPWZ1bmN0aW9uKGUpe3JldHVybiB0KG4sZSl9LHJ9KDEsLjMpLCRsPWZ1bmN0aW9uIHQobixlKXtmdW5jdGlvbiByKHQpe3JldHVybiAxLW4qTWF0aC5wb3coMiwtMTAqKHQ9K3QpKSpNYXRoLnNpbigodCtpKS9lKX12YXIgaT1NYXRoLmFzaW4oMS8obj1NYXRoLm1heCgxLG4pKSkqKGUvPVhsKTtyZXR1cm4gci5hbXBsaXR1ZGU9ZnVuY3Rpb24obil7cmV0dXJuIHQobixlKlhsKX0sci5wZXJpb2Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHQobixlKX0scn0oMSwuMyksV2w9ZnVuY3Rpb24gdChuLGUpe2Z1bmN0aW9uIHIodCl7cmV0dXJuKCh0PTIqdC0xKTwwP24qTWF0aC5wb3coMiwxMCp0KSpNYXRoLnNpbigoaS10KS9lKToyLW4qTWF0aC5wb3coMiwtMTAqdCkqTWF0aC5zaW4oKGkrdCkvZSkpLzJ9dmFyIGk9TWF0aC5hc2luKDEvKG49TWF0aC5tYXgoMSxuKSkpKihlLz1YbCk7cmV0dXJuIHIuYW1wbGl0dWRlPWZ1bmN0aW9uKG4pe3JldHVybiB0KG4sZSpYbCl9LHIucGVyaW9kPWZ1bmN0aW9uKGUpe3JldHVybiB0KG4sZSl9LHJ9KDEsLjMpLFpsPXt0aW1lOm51bGwsZGVsYXk6MCxkdXJhdGlvbjoyNTAsZWFzZTpVbn07ZnQucHJvdG90eXBlLmludGVycnVwdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Q24odGhpcyx0KX0pfSxmdC5wcm90b3R5cGUudHJhbnNpdGlvbj1mdW5jdGlvbih0KXt2YXIgbixlO3QgaW5zdGFuY2VvZiBSbj8obj10Ll9pZCx0PXQuX25hbWUpOihuPXFuKCksKGU9WmwpLnRpbWU9X24oKSx0PW51bGw9PXQ/bnVsbDp0K1wiXCIpO2Zvcih2YXIgcj10aGlzLl9ncm91cHMsaT1yLmxlbmd0aCxvPTA7bzxpOysrbylmb3IodmFyIHUsYT1yW29dLGM9YS5sZW5ndGgscz0wO3M8YzsrK3MpKHU9YVtzXSkmJmtuKHUsdCxuLHMsYSxlfHxCbih1LG4pKTtyZXR1cm4gbmV3IFJuKHIsdGhpcy5fcGFyZW50cyx0LG4pfTt2YXIgR2w9W251bGxdLFFsPXtuYW1lOlwiZHJhZ1wifSxKbD17bmFtZTpcInNwYWNlXCJ9LEtsPXtuYW1lOlwiaGFuZGxlXCJ9LHRoPXtuYW1lOlwiY2VudGVyXCJ9LG5oPXtuYW1lOlwieFwiLGhhbmRsZXM6W1wiZVwiLFwid1wiXS5tYXAoVm4pLGlucHV0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIHQmJltbdFswXSxuWzBdWzFdXSxbdFsxXSxuWzFdWzFdXV19LG91dHB1dDpmdW5jdGlvbih0KXtyZXR1cm4gdCYmW3RbMF1bMF0sdFsxXVswXV19fSxlaD17bmFtZTpcInlcIixoYW5kbGVzOltcIm5cIixcInNcIl0ubWFwKFZuKSxpbnB1dDpmdW5jdGlvbih0LG4pe3JldHVybiB0JiZbW25bMF1bMF0sdFswXV0sW25bMV1bMF0sdFsxXV1dfSxvdXRwdXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlt0WzBdWzFdLHRbMV1bMV1dfX0scmg9e25hbWU6XCJ4eVwiLGhhbmRsZXM6W1wiblwiLFwiZVwiLFwic1wiLFwid1wiLFwibndcIixcIm5lXCIsXCJzZVwiLFwic3dcIl0ubWFwKFZuKSxpbnB1dDpmdW5jdGlvbih0KXtyZXR1cm4gdH0sb3V0cHV0OmZ1bmN0aW9uKHQpe3JldHVybiB0fX0saWg9e292ZXJsYXk6XCJjcm9zc2hhaXJcIixzZWxlY3Rpb246XCJtb3ZlXCIsbjpcIm5zLXJlc2l6ZVwiLGU6XCJldy1yZXNpemVcIixzOlwibnMtcmVzaXplXCIsdzpcImV3LXJlc2l6ZVwiLG53OlwibndzZS1yZXNpemVcIixuZTpcIm5lc3ctcmVzaXplXCIsc2U6XCJud3NlLXJlc2l6ZVwiLHN3OlwibmVzdy1yZXNpemVcIn0sb2g9e2U6XCJ3XCIsdzpcImVcIixudzpcIm5lXCIsbmU6XCJud1wiLHNlOlwic3dcIixzdzpcInNlXCJ9LHVoPXtuOlwic1wiLHM6XCJuXCIsbnc6XCJzd1wiLG5lOlwic2VcIixzZTpcIm5lXCIsc3c6XCJud1wifSxhaD17b3ZlcmxheToxLHNlbGVjdGlvbjoxLG46bnVsbCxlOjEsczpudWxsLHc6LTEsbnc6LTEsbmU6MSxzZToxLHN3Oi0xfSxjaD17b3ZlcmxheToxLHNlbGVjdGlvbjoxLG46LTEsZTpudWxsLHM6MSx3Om51bGwsbnc6LTEsbmU6LTEsc2U6MSxzdzoxfSxzaD1NYXRoLmNvcyxmaD1NYXRoLnNpbixsaD1NYXRoLlBJLGhoPWxoLzIscGg9MipsaCxkaD1NYXRoLm1heCx2aD1BcnJheS5wcm90b3R5cGUuc2xpY2UsZ2g9TWF0aC5QSSxfaD0yKmdoLHloPV9oLTFlLTY7S24ucHJvdG90eXBlPXRlLnByb3RvdHlwZT17Y29uc3RydWN0b3I6S24sbW92ZVRvOmZ1bmN0aW9uKHQsbil7dGhpcy5fKz1cIk1cIisodGhpcy5feDA9dGhpcy5feDE9K3QpK1wiLFwiKyh0aGlzLl95MD10aGlzLl95MT0rbil9LGNsb3NlUGF0aDpmdW5jdGlvbigpe251bGwhPT10aGlzLl94MSYmKHRoaXMuX3gxPXRoaXMuX3gwLHRoaXMuX3kxPXRoaXMuX3kwLHRoaXMuXys9XCJaXCIpfSxsaW5lVG86ZnVuY3Rpb24odCxuKXt0aGlzLl8rPVwiTFwiKyh0aGlzLl94MT0rdCkrXCIsXCIrKHRoaXMuX3kxPStuKX0scXVhZHJhdGljQ3VydmVUbzpmdW5jdGlvbih0LG4sZSxyKXt0aGlzLl8rPVwiUVwiKyArdCtcIixcIisgK24rXCIsXCIrKHRoaXMuX3gxPStlKStcIixcIisodGhpcy5feTE9K3IpfSxiZXppZXJDdXJ2ZVRvOmZ1bmN0aW9uKHQsbixlLHIsaSxvKXt0aGlzLl8rPVwiQ1wiKyArdCtcIixcIisgK24rXCIsXCIrICtlK1wiLFwiKyArcitcIixcIisodGhpcy5feDE9K2kpK1wiLFwiKyh0aGlzLl95MT0rbyl9LGFyY1RvOmZ1bmN0aW9uKHQsbixlLHIsaSl7dD0rdCxuPStuLGU9K2Uscj0rcixpPStpO3ZhciBvPXRoaXMuX3gxLHU9dGhpcy5feTEsYT1lLXQsYz1yLW4scz1vLXQsZj11LW4sbD1zKnMrZipmO2lmKGk8MCl0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiK2kpO2lmKG51bGw9PT10aGlzLl94MSl0aGlzLl8rPVwiTVwiKyh0aGlzLl94MT10KStcIixcIisodGhpcy5feTE9bik7ZWxzZSBpZihsPjFlLTYpaWYoTWF0aC5hYnMoZiphLWMqcyk+MWUtNiYmaSl7dmFyIGg9ZS1vLHA9ci11LGQ9YSphK2MqYyx2PWgqaCtwKnAsZz1NYXRoLnNxcnQoZCksXz1NYXRoLnNxcnQobCkseT1pKk1hdGgudGFuKChnaC1NYXRoLmFjb3MoKGQrbC12KS8oMipnKl8pKSkvMiksbT15L18seD15L2c7TWF0aC5hYnMobS0xKT4xZS02JiYodGhpcy5fKz1cIkxcIisodCttKnMpK1wiLFwiKyhuK20qZikpLHRoaXMuXys9XCJBXCIraStcIixcIitpK1wiLDAsMCxcIisgKyhmKmg+cypwKStcIixcIisodGhpcy5feDE9dCt4KmEpK1wiLFwiKyh0aGlzLl95MT1uK3gqYyl9ZWxzZSB0aGlzLl8rPVwiTFwiKyh0aGlzLl94MT10KStcIixcIisodGhpcy5feTE9bik7ZWxzZTt9LGFyYzpmdW5jdGlvbih0LG4sZSxyLGksbyl7dD0rdCxuPStuO3ZhciB1PShlPStlKSpNYXRoLmNvcyhyKSxhPWUqTWF0aC5zaW4ociksYz10K3Uscz1uK2EsZj0xXm8sbD1vP3ItaTppLXI7aWYoZTwwKXRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIrZSk7bnVsbD09PXRoaXMuX3gxP3RoaXMuXys9XCJNXCIrYytcIixcIitzOihNYXRoLmFicyh0aGlzLl94MS1jKT4xZS02fHxNYXRoLmFicyh0aGlzLl95MS1zKT4xZS02KSYmKHRoaXMuXys9XCJMXCIrYytcIixcIitzKSxlJiYobDwwJiYobD1sJV9oK19oKSxsPnloP3RoaXMuXys9XCJBXCIrZStcIixcIitlK1wiLDAsMSxcIitmK1wiLFwiKyh0LXUpK1wiLFwiKyhuLWEpK1wiQVwiK2UrXCIsXCIrZStcIiwwLDEsXCIrZitcIixcIisodGhpcy5feDE9YykrXCIsXCIrKHRoaXMuX3kxPXMpOmw+MWUtNiYmKHRoaXMuXys9XCJBXCIrZStcIixcIitlK1wiLDAsXCIrICsobD49Z2gpK1wiLFwiK2YrXCIsXCIrKHRoaXMuX3gxPXQrZSpNYXRoLmNvcyhpKSkrXCIsXCIrKHRoaXMuX3kxPW4rZSpNYXRoLnNpbihpKSkpKX0scmVjdDpmdW5jdGlvbih0LG4sZSxyKXt0aGlzLl8rPVwiTVwiKyh0aGlzLl94MD10aGlzLl94MT0rdCkrXCIsXCIrKHRoaXMuX3kwPXRoaXMuX3kxPStuKStcImhcIisgK2UrXCJ2XCIrICtyK1wiaFwiKy1lK1wiWlwifSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl99fTt1ZS5wcm90b3R5cGU9YWUucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjp1ZSxoYXM6ZnVuY3Rpb24odCl7cmV0dXJuXCIkXCIrdCBpbiB0aGlzfSxnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXNbXCIkXCIrdF19LHNldDpmdW5jdGlvbih0LG4pe3JldHVybiB0aGlzW1wiJFwiK3RdPW4sdGhpc30scmVtb3ZlOmZ1bmN0aW9uKHQpe3ZhciBuPVwiJFwiK3Q7cmV0dXJuIG4gaW4gdGhpcyYmZGVsZXRlIHRoaXNbbl19LGNsZWFyOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMpXCIkXCI9PT10WzBdJiZkZWxldGUgdGhpc1t0XX0sa2V5czpmdW5jdGlvbigpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiB0aGlzKVwiJFwiPT09blswXSYmdC5wdXNoKG4uc2xpY2UoMSkpO3JldHVybiB0fSx2YWx1ZXM6ZnVuY3Rpb24oKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gdGhpcylcIiRcIj09PW5bMF0mJnQucHVzaCh0aGlzW25dKTtyZXR1cm4gdH0sZW50cmllczpmdW5jdGlvbigpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiB0aGlzKVwiJFwiPT09blswXSYmdC5wdXNoKHtrZXk6bi5zbGljZSgxKSx2YWx1ZTp0aGlzW25dfSk7cmV0dXJuIHR9LHNpemU6ZnVuY3Rpb24oKXt2YXIgdD0wO2Zvcih2YXIgbiBpbiB0aGlzKVwiJFwiPT09blswXSYmKyt0O3JldHVybiB0fSxlbXB0eTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzKWlmKFwiJFwiPT09dFswXSlyZXR1cm4hMTtyZXR1cm4hMH0sZWFjaDpmdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gdGhpcylcIiRcIj09PW5bMF0mJnQodGhpc1tuXSxuLnNsaWNlKDEpLHRoaXMpfX07dmFyIG1oPWFlLnByb3RvdHlwZTtoZS5wcm90b3R5cGU9cGUucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpoZSxoYXM6bWguaGFzLGFkZDpmdW5jdGlvbih0KXtyZXR1cm4gdCs9XCJcIix0aGlzW1wiJFwiK3RdPXQsdGhpc30scmVtb3ZlOm1oLnJlbW92ZSxjbGVhcjptaC5jbGVhcix2YWx1ZXM6bWgua2V5cyxzaXplOm1oLnNpemUsZW1wdHk6bWguZW1wdHksZWFjaDptaC5lYWNofTt2YXIgeGg9e30sYmg9e30sd2g9MzQsTWg9MTAsVGg9MTMsTmg9dmUoXCIsXCIpLGtoPU5oLnBhcnNlLFNoPU5oLnBhcnNlUm93cyxFaD1OaC5mb3JtYXQsQWg9TmguZm9ybWF0Um93cyxDaD12ZShcIlxcdFwiKSx6aD1DaC5wYXJzZSxQaD1DaC5wYXJzZVJvd3MsUmg9Q2guZm9ybWF0LExoPUNoLmZvcm1hdFJvd3MscWg9d2UucHJvdG90eXBlPU1lLnByb3RvdHlwZTtxaC5jb3B5PWZ1bmN0aW9uKCl7dmFyIHQsbixlPW5ldyBNZSh0aGlzLl94LHRoaXMuX3ksdGhpcy5feDAsdGhpcy5feTAsdGhpcy5feDEsdGhpcy5feTEpLHI9dGhpcy5fcm9vdDtpZighcilyZXR1cm4gZTtpZighci5sZW5ndGgpcmV0dXJuIGUuX3Jvb3Q9VGUociksZTtmb3IodD1be3NvdXJjZTpyLHRhcmdldDplLl9yb290PW5ldyBBcnJheSg0KX1dO3I9dC5wb3AoKTspZm9yKHZhciBpPTA7aTw0OysraSkobj1yLnNvdXJjZVtpXSkmJihuLmxlbmd0aD90LnB1c2goe3NvdXJjZTpuLHRhcmdldDpyLnRhcmdldFtpXT1uZXcgQXJyYXkoNCl9KTpyLnRhcmdldFtpXT1UZShuKSk7cmV0dXJuIGV9LHFoLmFkZD1mdW5jdGlvbih0KXt2YXIgbj0rdGhpcy5feC5jYWxsKG51bGwsdCksZT0rdGhpcy5feS5jYWxsKG51bGwsdCk7cmV0dXJuIHllKHRoaXMuY292ZXIobixlKSxuLGUsdCl9LHFoLmFkZEFsbD1mdW5jdGlvbih0KXt2YXIgbixlLHIsaSxvPXQubGVuZ3RoLHU9bmV3IEFycmF5KG8pLGE9bmV3IEFycmF5KG8pLGM9MS8wLHM9MS8wLGY9LTEvMCxsPS0xLzA7Zm9yKGU9MDtlPG87KytlKWlzTmFOKHI9K3RoaXMuX3guY2FsbChudWxsLG49dFtlXSkpfHxpc05hTihpPSt0aGlzLl95LmNhbGwobnVsbCxuKSl8fCh1W2VdPXIsYVtlXT1pLHI8YyYmKGM9cikscj5mJiYoZj1yKSxpPHMmJihzPWkpLGk+bCYmKGw9aSkpO2ZvcihmPGMmJihjPXRoaXMuX3gwLGY9dGhpcy5feDEpLGw8cyYmKHM9dGhpcy5feTAsbD10aGlzLl95MSksdGhpcy5jb3ZlcihjLHMpLmNvdmVyKGYsbCksZT0wO2U8bzsrK2UpeWUodGhpcyx1W2VdLGFbZV0sdFtlXSk7cmV0dXJuIHRoaXN9LHFoLmNvdmVyPWZ1bmN0aW9uKHQsbil7aWYoaXNOYU4odD0rdCl8fGlzTmFOKG49K24pKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuX3gwLHI9dGhpcy5feTAsaT10aGlzLl94MSxvPXRoaXMuX3kxO2lmKGlzTmFOKGUpKWk9KGU9TWF0aC5mbG9vcih0KSkrMSxvPShyPU1hdGguZmxvb3IobikpKzE7ZWxzZXtpZighKGU+dHx8dD5pfHxyPm58fG4+bykpcmV0dXJuIHRoaXM7dmFyIHUsYSxjPWktZSxzPXRoaXMuX3Jvb3Q7c3dpdGNoKGE9KG48KHIrbykvMik8PDF8dDwoZStpKS8yKXtjYXNlIDA6ZG97dT1uZXcgQXJyYXkoNCksdVthXT1zLHM9dX13aGlsZShjKj0yLGk9ZStjLG89citjLHQ+aXx8bj5vKTticmVhaztjYXNlIDE6ZG97dT1uZXcgQXJyYXkoNCksdVthXT1zLHM9dX13aGlsZShjKj0yLGU9aS1jLG89citjLGU+dHx8bj5vKTticmVhaztjYXNlIDI6ZG97dT1uZXcgQXJyYXkoNCksdVthXT1zLHM9dX13aGlsZShjKj0yLGk9ZStjLHI9by1jLHQ+aXx8cj5uKTticmVhaztjYXNlIDM6ZG97dT1uZXcgQXJyYXkoNCksdVthXT1zLHM9dX13aGlsZShjKj0yLGU9aS1jLHI9by1jLGU+dHx8cj5uKX10aGlzLl9yb290JiZ0aGlzLl9yb290Lmxlbmd0aCYmKHRoaXMuX3Jvb3Q9cyl9cmV0dXJuIHRoaXMuX3gwPWUsdGhpcy5feTA9cix0aGlzLl94MT1pLHRoaXMuX3kxPW8sdGhpc30scWguZGF0YT1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0aGlzLnZpc2l0KGZ1bmN0aW9uKG4pe2lmKCFuLmxlbmd0aClkb3t0LnB1c2gobi5kYXRhKX13aGlsZShuPW4ubmV4dCl9KSx0fSxxaC5leHRlbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy5jb3ZlcigrdFswXVswXSwrdFswXVsxXSkuY292ZXIoK3RbMV1bMF0sK3RbMV1bMV0pOmlzTmFOKHRoaXMuX3gwKT92b2lkIDA6W1t0aGlzLl94MCx0aGlzLl95MF0sW3RoaXMuX3gxLHRoaXMuX3kxXV19LHFoLmZpbmQ9ZnVuY3Rpb24odCxuLGUpe3ZhciByLGksbyx1LGEsYyxzLGY9dGhpcy5feDAsbD10aGlzLl95MCxoPXRoaXMuX3gxLHA9dGhpcy5feTEsZD1bXSx2PXRoaXMuX3Jvb3Q7Zm9yKHYmJmQucHVzaChuZXcgbWUodixmLGwsaCxwKSksbnVsbD09ZT9lPTEvMDooZj10LWUsbD1uLWUsaD10K2UscD1uK2UsZSo9ZSk7Yz1kLnBvcCgpOylpZighKCEodj1jLm5vZGUpfHwoaT1jLngwKT5ofHwobz1jLnkwKT5wfHwodT1jLngxKTxmfHwoYT1jLnkxKTxsKSlpZih2Lmxlbmd0aCl7dmFyIGc9KGkrdSkvMixfPShvK2EpLzI7ZC5wdXNoKG5ldyBtZSh2WzNdLGcsXyx1LGEpLG5ldyBtZSh2WzJdLGksXyxnLGEpLG5ldyBtZSh2WzFdLGcsbyx1LF8pLG5ldyBtZSh2WzBdLGksbyxnLF8pKSwocz0obj49Xyk8PDF8dD49ZykmJihjPWRbZC5sZW5ndGgtMV0sZFtkLmxlbmd0aC0xXT1kW2QubGVuZ3RoLTEtc10sZFtkLmxlbmd0aC0xLXNdPWMpfWVsc2V7dmFyIHk9dC0rdGhpcy5feC5jYWxsKG51bGwsdi5kYXRhKSxtPW4tK3RoaXMuX3kuY2FsbChudWxsLHYuZGF0YSkseD15KnkrbSptO2lmKHg8ZSl7dmFyIGI9TWF0aC5zcXJ0KGU9eCk7Zj10LWIsbD1uLWIsaD10K2IscD1uK2Iscj12LmRhdGF9fXJldHVybiByfSxxaC5yZW1vdmU9ZnVuY3Rpb24odCl7aWYoaXNOYU4obz0rdGhpcy5feC5jYWxsKG51bGwsdCkpfHxpc05hTih1PSt0aGlzLl95LmNhbGwobnVsbCx0KSkpcmV0dXJuIHRoaXM7dmFyIG4sZSxyLGksbyx1LGEsYyxzLGYsbCxoLHA9dGhpcy5fcm9vdCxkPXRoaXMuX3gwLHY9dGhpcy5feTAsZz10aGlzLl94MSxfPXRoaXMuX3kxO2lmKCFwKXJldHVybiB0aGlzO2lmKHAubGVuZ3RoKWZvcig7Oyl7aWYoKHM9bz49KGE9KGQrZykvMikpP2Q9YTpnPWEsKGY9dT49KGM9KHYrXykvMikpP3Y9YzpfPWMsbj1wLCEocD1wW2w9Zjw8MXxzXSkpcmV0dXJuIHRoaXM7aWYoIXAubGVuZ3RoKWJyZWFrOyhuW2wrMSYzXXx8bltsKzImM118fG5bbCszJjNdKSYmKGU9bixoPWwpfWZvcig7cC5kYXRhIT09dDspaWYocj1wLCEocD1wLm5leHQpKXJldHVybiB0aGlzO3JldHVybihpPXAubmV4dCkmJmRlbGV0ZSBwLm5leHQscj8oaT9yLm5leHQ9aTpkZWxldGUgci5uZXh0LHRoaXMpOm4/KGk/bltsXT1pOmRlbGV0ZSBuW2xdLChwPW5bMF18fG5bMV18fG5bMl18fG5bM10pJiZwPT09KG5bM118fG5bMl18fG5bMV18fG5bMF0pJiYhcC5sZW5ndGgmJihlP2VbaF09cDp0aGlzLl9yb290PXApLHRoaXMpOih0aGlzLl9yb290PWksdGhpcyl9LHFoLnJlbW92ZUFsbD1mdW5jdGlvbih0KXtmb3IodmFyIG49MCxlPXQubGVuZ3RoO248ZTsrK24pdGhpcy5yZW1vdmUodFtuXSk7cmV0dXJuIHRoaXN9LHFoLnJvb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm9vdH0scWguc2l6ZT1mdW5jdGlvbigpe3ZhciB0PTA7cmV0dXJuIHRoaXMudmlzaXQoZnVuY3Rpb24obil7aWYoIW4ubGVuZ3RoKWRveysrdH13aGlsZShuPW4ubmV4dCl9KSx0fSxxaC52aXNpdD1mdW5jdGlvbih0KXt2YXIgbixlLHIsaSxvLHUsYT1bXSxjPXRoaXMuX3Jvb3Q7Zm9yKGMmJmEucHVzaChuZXcgbWUoYyx0aGlzLl94MCx0aGlzLl95MCx0aGlzLl94MSx0aGlzLl95MSkpO249YS5wb3AoKTspaWYoIXQoYz1uLm5vZGUscj1uLngwLGk9bi55MCxvPW4ueDEsdT1uLnkxKSYmYy5sZW5ndGgpe3ZhciBzPShyK28pLzIsZj0oaSt1KS8yOyhlPWNbM10pJiZhLnB1c2gobmV3IG1lKGUscyxmLG8sdSkpLChlPWNbMl0pJiZhLnB1c2gobmV3IG1lKGUscixmLHMsdSkpLChlPWNbMV0pJiZhLnB1c2gobmV3IG1lKGUscyxpLG8sZikpLChlPWNbMF0pJiZhLnB1c2gobmV3IG1lKGUscixpLHMsZikpfXJldHVybiB0aGlzfSxxaC52aXNpdEFmdGVyPWZ1bmN0aW9uKHQpe3ZhciBuLGU9W10scj1bXTtmb3IodGhpcy5fcm9vdCYmZS5wdXNoKG5ldyBtZSh0aGlzLl9yb290LHRoaXMuX3gwLHRoaXMuX3kwLHRoaXMuX3gxLHRoaXMuX3kxKSk7bj1lLnBvcCgpOyl7dmFyIGk9bi5ub2RlO2lmKGkubGVuZ3RoKXt2YXIgbyx1PW4ueDAsYT1uLnkwLGM9bi54MSxzPW4ueTEsZj0odStjKS8yLGw9KGErcykvMjsobz1pWzBdKSYmZS5wdXNoKG5ldyBtZShvLHUsYSxmLGwpKSwobz1pWzFdKSYmZS5wdXNoKG5ldyBtZShvLGYsYSxjLGwpKSwobz1pWzJdKSYmZS5wdXNoKG5ldyBtZShvLHUsbCxmLHMpKSwobz1pWzNdKSYmZS5wdXNoKG5ldyBtZShvLGYsbCxjLHMpKX1yLnB1c2gobil9Zm9yKDtuPXIucG9wKCk7KXQobi5ub2RlLG4ueDAsbi55MCxuLngxLG4ueTEpO3JldHVybiB0aGlzfSxxaC54PWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl94PXQsdGhpcyk6dGhpcy5feH0scWgueT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5feT10LHRoaXMpOnRoaXMuX3l9O3ZhciBEaCxVaD0xMCxPaD1NYXRoLlBJKigzLU1hdGguc3FydCg1KSksRmg9e1wiXCI6ZnVuY3Rpb24odCxuKXt0OmZvcih2YXIgZSxyPSh0PXQudG9QcmVjaXNpb24obikpLmxlbmd0aCxpPTEsbz0tMTtpPHI7KytpKXN3aXRjaCh0W2ldKXtjYXNlXCIuXCI6bz1lPWk7YnJlYWs7Y2FzZVwiMFwiOjA9PT1vJiYobz1pKSxlPWk7YnJlYWs7Y2FzZVwiZVwiOmJyZWFrIHQ7ZGVmYXVsdDpvPjAmJihvPTApfXJldHVybiBvPjA/dC5zbGljZSgwLG8pK3Quc2xpY2UoZSsxKTp0fSxcIiVcIjpmdW5jdGlvbih0LG4pe3JldHVybigxMDAqdCkudG9GaXhlZChuKX0sYjpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KS50b1N0cmluZygyKX0sYzpmdW5jdGlvbih0KXtyZXR1cm4gdCtcIlwifSxkOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnJvdW5kKHQpLnRvU3RyaW5nKDEwKX0sZTpmdW5jdGlvbih0LG4pe3JldHVybiB0LnRvRXhwb25lbnRpYWwobil9LGY6ZnVuY3Rpb24odCxuKXtyZXR1cm4gdC50b0ZpeGVkKG4pfSxnOmZ1bmN0aW9uKHQsbil7cmV0dXJuIHQudG9QcmVjaXNpb24obil9LG86ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucm91bmQodCkudG9TdHJpbmcoOCl9LHA6ZnVuY3Rpb24odCxuKXtyZXR1cm4gUmUoMTAwKnQsbil9LHI6UmUsczpmdW5jdGlvbih0LG4pe3ZhciBlPXplKHQsbik7aWYoIWUpcmV0dXJuIHQrXCJcIjt2YXIgcj1lWzBdLGk9ZVsxXSxvPWktKERoPTMqTWF0aC5tYXgoLTgsTWF0aC5taW4oOCxNYXRoLmZsb29yKGkvMykpKSkrMSx1PXIubGVuZ3RoO3JldHVybiBvPT09dT9yOm8+dT9yK25ldyBBcnJheShvLXUrMSkuam9pbihcIjBcIik6bz4wP3Iuc2xpY2UoMCxvKStcIi5cIityLnNsaWNlKG8pOlwiMC5cIituZXcgQXJyYXkoMS1vKS5qb2luKFwiMFwiKSt6ZSh0LE1hdGgubWF4KDAsbitvLTEpKVswXX0sWDpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX0seDpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KS50b1N0cmluZygxNil9fSxJaD0vXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KFthLXolXSk/JC9pO0xlLnByb3RvdHlwZT1xZS5wcm90b3R5cGUscWUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsbCt0aGlzLmFsaWduK3RoaXMuc2lnbit0aGlzLnN5bWJvbCsodGhpcy56ZXJvP1wiMFwiOlwiXCIpKyhudWxsPT10aGlzLndpZHRoP1wiXCI6TWF0aC5tYXgoMSwwfHRoaXMud2lkdGgpKSsodGhpcy5jb21tYT9cIixcIjpcIlwiKSsobnVsbD09dGhpcy5wcmVjaXNpb24/XCJcIjpcIi5cIitNYXRoLm1heCgwLDB8dGhpcy5wcmVjaXNpb24pKSt0aGlzLnR5cGV9O3ZhciBZaCxCaD1bXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO09lKHtkZWNpbWFsOlwiLlwiLHRob3VzYW5kczpcIixcIixncm91cGluZzpbM10sY3VycmVuY3k6W1wiJFwiLFwiXCJdfSksSGUucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpIZSxyZXNldDpmdW5jdGlvbigpe3RoaXMucz10aGlzLnQ9MH0sYWRkOmZ1bmN0aW9uKHQpe2plKHhwLHQsdGhpcy50KSxqZSh0aGlzLHhwLnMsdGhpcy5zKSx0aGlzLnM/dGhpcy50Kz14cC50OnRoaXMucz14cC50fSx2YWx1ZU9mOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc319O3ZhciBIaCxqaCxYaCxWaCwkaCxXaCxaaCxHaCxRaCxKaCxLaCx0cCxucCxlcCxycCxpcCxvcCx1cCxhcCxjcCxzcCxmcCxscCxocCxwcCxkcCx2cCxncCxfcCx5cCxtcCx4cD1uZXcgSGUsYnA9MWUtNix3cD0xZS0xMixNcD1NYXRoLlBJLFRwPU1wLzIsTnA9TXAvNCxrcD0yKk1wLFNwPTE4MC9NcCxFcD1NcC8xODAsQXA9TWF0aC5hYnMsQ3A9TWF0aC5hdGFuLHpwPU1hdGguYXRhbjIsUHA9TWF0aC5jb3MsUnA9TWF0aC5jZWlsLExwPU1hdGguZXhwLHFwPU1hdGgubG9nLERwPU1hdGgucG93LFVwPU1hdGguc2luLE9wPU1hdGguc2lnbnx8ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD8xOnQ8MD8tMTowfSxGcD1NYXRoLnNxcnQsSXA9TWF0aC50YW4sWXA9e0ZlYXR1cmU6ZnVuY3Rpb24odCxuKXtaZSh0Lmdlb21ldHJ5LG4pfSxGZWF0dXJlQ29sbGVjdGlvbjpmdW5jdGlvbih0LG4pe2Zvcih2YXIgZT10LmZlYXR1cmVzLHI9LTEsaT1lLmxlbmd0aDsrK3I8aTspWmUoZVtyXS5nZW9tZXRyeSxuKX19LEJwPXtTcGhlcmU6ZnVuY3Rpb24odCxuKXtuLnNwaGVyZSgpfSxQb2ludDpmdW5jdGlvbih0LG4pe3Q9dC5jb29yZGluYXRlcyxuLnBvaW50KHRbMF0sdFsxXSx0WzJdKX0sTXVsdGlQb2ludDpmdW5jdGlvbih0LG4pe2Zvcih2YXIgZT10LmNvb3JkaW5hdGVzLHI9LTEsaT1lLmxlbmd0aDsrK3I8aTspdD1lW3JdLG4ucG9pbnQodFswXSx0WzFdLHRbMl0pfSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQsbil7R2UodC5jb29yZGluYXRlcyxuLDApfSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCxuKXtmb3IodmFyIGU9dC5jb29yZGluYXRlcyxyPS0xLGk9ZS5sZW5ndGg7KytyPGk7KUdlKGVbcl0sbiwwKX0sUG9seWdvbjpmdW5jdGlvbih0LG4pe1FlKHQuY29vcmRpbmF0ZXMsbil9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0LG4pe2Zvcih2YXIgZT10LmNvb3JkaW5hdGVzLHI9LTEsaT1lLmxlbmd0aDsrK3I8aTspUWUoZVtyXSxuKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlPXQuZ2VvbWV0cmllcyxyPS0xLGk9ZS5sZW5ndGg7KytyPGk7KVplKGVbcl0sbil9fSxIcD1CZSgpLGpwPUJlKCksWHA9e3BvaW50OldlLGxpbmVTdGFydDpXZSxsaW5lRW5kOldlLHBvbHlnb25TdGFydDpmdW5jdGlvbigpe0hwLnJlc2V0KCksWHAubGluZVN0YXJ0PUtlLFhwLmxpbmVFbmQ9dHJ9LHBvbHlnb25FbmQ6ZnVuY3Rpb24oKXt2YXIgdD0rSHA7anAuYWRkKHQ8MD9rcCt0OnQpLHRoaXMubGluZVN0YXJ0PXRoaXMubGluZUVuZD10aGlzLnBvaW50PVdlfSxzcGhlcmU6ZnVuY3Rpb24oKXtqcC5hZGQoa3ApfX0sVnA9QmUoKSwkcD17cG9pbnQ6ZnIsbGluZVN0YXJ0OmhyLGxpbmVFbmQ6cHIscG9seWdvblN0YXJ0OmZ1bmN0aW9uKCl7JHAucG9pbnQ9ZHIsJHAubGluZVN0YXJ0PXZyLCRwLmxpbmVFbmQ9Z3IsVnAucmVzZXQoKSxYcC5wb2x5Z29uU3RhcnQoKX0scG9seWdvbkVuZDpmdW5jdGlvbigpe1hwLnBvbHlnb25FbmQoKSwkcC5wb2ludD1mciwkcC5saW5lU3RhcnQ9aHIsJHAubGluZUVuZD1wcixIcDwwPyhXaD0tKEdoPTE4MCksWmg9LShRaD05MCkpOlZwPmJwP1FoPTkwOlZwPC1icCYmKFpoPS05MCkscnBbMF09V2gscnBbMV09R2h9fSxXcD17c3BoZXJlOldlLHBvaW50OnhyLGxpbmVTdGFydDp3cixsaW5lRW5kOk5yLHBvbHlnb25TdGFydDpmdW5jdGlvbigpe1dwLmxpbmVTdGFydD1rcixXcC5saW5lRW5kPVNyfSxwb2x5Z29uRW5kOmZ1bmN0aW9uKCl7V3AubGluZVN0YXJ0PXdyLFdwLmxpbmVFbmQ9TnJ9fTtQci5pbnZlcnQ9UHI7dmFyIFpwLEdwLFFwLEpwLEtwLHRkLG5kLGVkLHJkLGlkLG9kLHVkPUJlKCksYWQ9VnIoZnVuY3Rpb24oKXtyZXR1cm4hMH0sZnVuY3Rpb24odCl7dmFyIG4sZT1OYU4scj1OYU4saT1OYU47cmV0dXJue2xpbmVTdGFydDpmdW5jdGlvbigpe3QubGluZVN0YXJ0KCksbj0xfSxwb2ludDpmdW5jdGlvbihvLHUpe3ZhciBhPW8+MD9NcDotTXAsYz1BcChvLWUpO0FwKGMtTXApPGJwPyh0LnBvaW50KGUscj0ocit1KS8yPjA/VHA6LVRwKSx0LnBvaW50KGksciksdC5saW5lRW5kKCksdC5saW5lU3RhcnQoKSx0LnBvaW50KGEsciksdC5wb2ludChvLHIpLG49MCk6aSE9PWEmJmM+PU1wJiYoQXAoZS1pKTxicCYmKGUtPWkqYnApLEFwKG8tYSk8YnAmJihvLT1hKmJwKSxyPWZ1bmN0aW9uKHQsbixlLHIpe3ZhciBpLG8sdT1VcCh0LWUpO3JldHVybiBBcCh1KT5icD9DcCgoVXAobikqKG89UHAocikpKlVwKGUpLVVwKHIpKihpPVBwKG4pKSpVcCh0KSkvKGkqbyp1KSk6KG4rcikvMn0oZSxyLG8sdSksdC5wb2ludChpLHIpLHQubGluZUVuZCgpLHQubGluZVN0YXJ0KCksdC5wb2ludChhLHIpLG49MCksdC5wb2ludChlPW8scj11KSxpPWF9LGxpbmVFbmQ6ZnVuY3Rpb24oKXt0LmxpbmVFbmQoKSxlPXI9TmFOfSxjbGVhbjpmdW5jdGlvbigpe3JldHVybiAyLW59fX0sZnVuY3Rpb24odCxuLGUscil7dmFyIGk7aWYobnVsbD09dClpPWUqVHAsci5wb2ludCgtTXAsaSksci5wb2ludCgwLGkpLHIucG9pbnQoTXAsaSksci5wb2ludChNcCwwKSxyLnBvaW50KE1wLC1pKSxyLnBvaW50KDAsLWkpLHIucG9pbnQoLU1wLC1pKSxyLnBvaW50KC1NcCwwKSxyLnBvaW50KC1NcCxpKTtlbHNlIGlmKEFwKHRbMF0tblswXSk+YnApe3ZhciBvPXRbMF08blswXT9NcDotTXA7aT1lKm8vMixyLnBvaW50KC1vLGkpLHIucG9pbnQoMCxpKSxyLnBvaW50KG8saSl9ZWxzZSByLnBvaW50KG5bMF0sblsxXSl9LFstTXAsLVRwXSksY2Q9MWU5LHNkPS1jZCxmZD1CZSgpLGxkPXtzcGhlcmU6V2UscG9pbnQ6V2UsbGluZVN0YXJ0OmZ1bmN0aW9uKCl7bGQucG9pbnQ9SnIsbGQubGluZUVuZD1Rcn0sbGluZUVuZDpXZSxwb2x5Z29uU3RhcnQ6V2UscG9seWdvbkVuZDpXZX0saGQ9W251bGwsbnVsbF0scGQ9e3R5cGU6XCJMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6aGR9LGRkPXtGZWF0dXJlOmZ1bmN0aW9uKHQsbil7cmV0dXJuIGVpKHQuZ2VvbWV0cnksbil9LEZlYXR1cmVDb2xsZWN0aW9uOmZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlPXQuZmVhdHVyZXMscj0tMSxpPWUubGVuZ3RoOysrcjxpOylpZihlaShlW3JdLmdlb21ldHJ5LG4pKXJldHVybiEwO3JldHVybiExfX0sdmQ9e1NwaGVyZTpmdW5jdGlvbigpe3JldHVybiEwfSxQb2ludDpmdW5jdGlvbih0LG4pe3JldHVybiByaSh0LmNvb3JkaW5hdGVzLG4pfSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlPXQuY29vcmRpbmF0ZXMscj0tMSxpPWUubGVuZ3RoOysrcjxpOylpZihyaShlW3JdLG4pKXJldHVybiEwO3JldHVybiExfSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQsbil7cmV0dXJuIGlpKHQuY29vcmRpbmF0ZXMsbil9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0LG4pe2Zvcih2YXIgZT10LmNvb3JkaW5hdGVzLHI9LTEsaT1lLmxlbmd0aDsrK3I8aTspaWYoaWkoZVtyXSxuKSlyZXR1cm4hMDtyZXR1cm4hMX0sUG9seWdvbjpmdW5jdGlvbih0LG4pe3JldHVybiBvaSh0LmNvb3JkaW5hdGVzLG4pfSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCxuKXtmb3IodmFyIGU9dC5jb29yZGluYXRlcyxyPS0xLGk9ZS5sZW5ndGg7KytyPGk7KWlmKG9pKGVbcl0sbikpcmV0dXJuITA7cmV0dXJuITF9LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0LG4pe2Zvcih2YXIgZT10Lmdlb21ldHJpZXMscj0tMSxpPWUubGVuZ3RoOysrcjxpOylpZihlaShlW3JdLG4pKXJldHVybiEwO3JldHVybiExfX0sZ2Q9QmUoKSxfZD1CZSgpLHlkPXtwb2ludDpXZSxsaW5lU3RhcnQ6V2UsbGluZUVuZDpXZSxwb2x5Z29uU3RhcnQ6ZnVuY3Rpb24oKXt5ZC5saW5lU3RhcnQ9aGkseWQubGluZUVuZD12aX0scG9seWdvbkVuZDpmdW5jdGlvbigpe3lkLmxpbmVTdGFydD15ZC5saW5lRW5kPXlkLnBvaW50PVdlLGdkLmFkZChBcChfZCkpLF9kLnJlc2V0KCl9LHJlc3VsdDpmdW5jdGlvbigpe3ZhciB0PWdkLzI7cmV0dXJuIGdkLnJlc2V0KCksdH19LG1kPTEvMCx4ZD1tZCxiZD0tbWQsd2Q9YmQsTWQ9e3BvaW50OmZ1bmN0aW9uKHQsbil7dDxtZCYmKG1kPXQpLHQ+YmQmJihiZD10KSxuPHhkJiYoeGQ9biksbj53ZCYmKHdkPW4pfSxsaW5lU3RhcnQ6V2UsbGluZUVuZDpXZSxwb2x5Z29uU3RhcnQ6V2UscG9seWdvbkVuZDpXZSxyZXN1bHQ6ZnVuY3Rpb24oKXt2YXIgdD1bW21kLHhkXSxbYmQsd2RdXTtyZXR1cm4gYmQ9d2Q9LSh4ZD1tZD0xLzApLHR9fSxUZD0wLE5kPTAsa2Q9MCxTZD0wLEVkPTAsQWQ9MCxDZD0wLHpkPTAsUGQ9MCxSZD17cG9pbnQ6Z2ksbGluZVN0YXJ0Ol9pLGxpbmVFbmQ6eGkscG9seWdvblN0YXJ0OmZ1bmN0aW9uKCl7UmQubGluZVN0YXJ0PWJpLFJkLmxpbmVFbmQ9d2l9LHBvbHlnb25FbmQ6ZnVuY3Rpb24oKXtSZC5wb2ludD1naSxSZC5saW5lU3RhcnQ9X2ksUmQubGluZUVuZD14aX0scmVzdWx0OmZ1bmN0aW9uKCl7dmFyIHQ9UGQ/W0NkL1BkLHpkL1BkXTpBZD9bU2QvQWQsRWQvQWRdOmtkP1tUZC9rZCxOZC9rZF06W05hTixOYU5dO3JldHVybiBUZD1OZD1rZD1TZD1FZD1BZD1DZD16ZD1QZD0wLHR9fTtOaS5wcm90b3R5cGU9e19yYWRpdXM6NC41LHBvaW50UmFkaXVzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9yYWRpdXM9dCx0aGlzfSxwb2x5Z29uU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPTB9LHBvbHlnb25FbmQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPU5hTn0sbGluZVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpezA9PT10aGlzLl9saW5lJiZ0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLHRoaXMuX3BvaW50PU5hTn0scG9pbnQ6ZnVuY3Rpb24odCxuKXtzd2l0Y2godGhpcy5fcG9pbnQpe2Nhc2UgMDp0aGlzLl9jb250ZXh0Lm1vdmVUbyh0LG4pLHRoaXMuX3BvaW50PTE7YnJlYWs7Y2FzZSAxOnRoaXMuX2NvbnRleHQubGluZVRvKHQsbik7YnJlYWs7ZGVmYXVsdDp0aGlzLl9jb250ZXh0Lm1vdmVUbyh0K3RoaXMuX3JhZGl1cyxuKSx0aGlzLl9jb250ZXh0LmFyYyh0LG4sdGhpcy5fcmFkaXVzLDAsa3ApfX0scmVzdWx0OldlfTt2YXIgTGQscWQsRGQsVWQsT2QsRmQ9QmUoKSxJZD17cG9pbnQ6V2UsbGluZVN0YXJ0OmZ1bmN0aW9uKCl7SWQucG9pbnQ9a2l9LGxpbmVFbmQ6ZnVuY3Rpb24oKXtMZCYmU2kocWQsRGQpLElkLnBvaW50PVdlfSxwb2x5Z29uU3RhcnQ6ZnVuY3Rpb24oKXtMZD0hMH0scG9seWdvbkVuZDpmdW5jdGlvbigpe0xkPW51bGx9LHJlc3VsdDpmdW5jdGlvbigpe3ZhciB0PStGZDtyZXR1cm4gRmQucmVzZXQoKSx0fX07RWkucHJvdG90eXBlPXtfcmFkaXVzOjQuNSxfY2lyY2xlOkFpKDQuNSkscG9pbnRSYWRpdXM6ZnVuY3Rpb24odCl7cmV0dXJuKHQ9K3QpIT09dGhpcy5fcmFkaXVzJiYodGhpcy5fcmFkaXVzPXQsdGhpcy5fY2lyY2xlPW51bGwpLHRoaXN9LHBvbHlnb25TdGFydDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9MH0scG9seWdvbkVuZDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9TmFOfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9wb2ludD0wfSxsaW5lRW5kOmZ1bmN0aW9uKCl7MD09PXRoaXMuX2xpbmUmJnRoaXMuX3N0cmluZy5wdXNoKFwiWlwiKSx0aGlzLl9wb2ludD1OYU59LHBvaW50OmZ1bmN0aW9uKHQsbil7c3dpdGNoKHRoaXMuX3BvaW50KXtjYXNlIDA6dGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsdCxcIixcIixuKSx0aGlzLl9wb2ludD0xO2JyZWFrO2Nhc2UgMTp0aGlzLl9zdHJpbmcucHVzaChcIkxcIix0LFwiLFwiLG4pO2JyZWFrO2RlZmF1bHQ6bnVsbD09dGhpcy5fY2lyY2xlJiYodGhpcy5fY2lyY2xlPUFpKHRoaXMuX3JhZGl1cykpLHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLHQsXCIsXCIsbix0aGlzLl9jaXJjbGUpfX0scmVzdWx0OmZ1bmN0aW9uKCl7aWYodGhpcy5fc3RyaW5nLmxlbmd0aCl7dmFyIHQ9dGhpcy5fc3RyaW5nLmpvaW4oXCJcIik7cmV0dXJuIHRoaXMuX3N0cmluZz1bXSx0fXJldHVybiBudWxsfX0semkucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjp6aSxwb2ludDpmdW5jdGlvbih0LG4pe3RoaXMuc3RyZWFtLnBvaW50KHQsbil9LHNwaGVyZTpmdW5jdGlvbigpe3RoaXMuc3RyZWFtLnNwaGVyZSgpfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLnN0cmVhbS5saW5lU3RhcnQoKX0sbGluZUVuZDpmdW5jdGlvbigpe3RoaXMuc3RyZWFtLmxpbmVFbmQoKX0scG9seWdvblN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCl9LHBvbHlnb25FbmQ6ZnVuY3Rpb24oKXt0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCl9fTt2YXIgWWQ9MTYsQmQ9UHAoMzAqRXApLEhkPUNpKHtwb2ludDpmdW5jdGlvbih0LG4pe3RoaXMuc3RyZWFtLnBvaW50KHQqRXAsbipFcCl9fSksamQ9amkoZnVuY3Rpb24odCl7cmV0dXJuIEZwKDIvKDErdCkpfSk7amQuaW52ZXJ0PVhpKGZ1bmN0aW9uKHQpe3JldHVybiAyKlZlKHQvMil9KTt2YXIgWGQ9amkoZnVuY3Rpb24odCl7cmV0dXJuKHQ9WGUodCkpJiZ0L1VwKHQpfSk7WGQuaW52ZXJ0PVhpKGZ1bmN0aW9uKHQpe3JldHVybiB0fSksVmkuaW52ZXJ0PWZ1bmN0aW9uKHQsbil7cmV0dXJuW3QsMipDcChMcChuKSktVHBdfSxHaS5pbnZlcnQ9R2ksSmkuaW52ZXJ0PVhpKENwKSx0by5pbnZlcnQ9ZnVuY3Rpb24odCxuKXt2YXIgZSxyPW4saT0yNTtkb3t2YXIgbz1yKnIsdT1vKm87ci09ZT0ociooMS4wMDcyMjYrbyooLjAxNTA4NSt1KiguMDI4ODc0Km8tLjA0NDQ3NS0uMDA1OTE2KnUpKSktbikvKDEuMDA3MjI2K28qKC4wNDUyNTUrdSooLjI1OTg2NipvLS4zMTEzMjUtLjAwNTkxNioxMSp1KSkpfXdoaWxlKEFwKGUpPmJwJiYtLWk+MCk7cmV0dXJuW3QvKC44NzA3KyhvPXIqcikqKG8qKG8qbypvKiguMDAzOTcxLS4wMDE1MjkqbyktLjAxMzc5MSktLjEzMTk3OSkpLHJdfSxuby5pbnZlcnQ9WGkoVmUpLGVvLmludmVydD1YaShmdW5jdGlvbih0KXtyZXR1cm4gMipDcCh0KX0pLHJvLmludmVydD1mdW5jdGlvbih0LG4pe3JldHVyblstbiwyKkNwKExwKHQpKS1UcF19LGhvLnByb3RvdHlwZT1jby5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmhvLGNvdW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaEFmdGVyKGFvKX0sZWFjaDpmdW5jdGlvbih0KXt2YXIgbixlLHIsaSxvPXRoaXMsdT1bb107ZG97Zm9yKG49dS5yZXZlcnNlKCksdT1bXTtvPW4ucG9wKCk7KWlmKHQobyksZT1vLmNoaWxkcmVuKWZvcihyPTAsaT1lLmxlbmd0aDtyPGk7KytyKXUucHVzaChlW3JdKX13aGlsZSh1Lmxlbmd0aCk7cmV0dXJuIHRoaXN9LGVhY2hBZnRlcjpmdW5jdGlvbih0KXtmb3IodmFyIG4sZSxyLGk9dGhpcyxvPVtpXSx1PVtdO2k9by5wb3AoKTspaWYodS5wdXNoKGkpLG49aS5jaGlsZHJlbilmb3IoZT0wLHI9bi5sZW5ndGg7ZTxyOysrZSlvLnB1c2gobltlXSk7Zm9yKDtpPXUucG9wKCk7KXQoaSk7cmV0dXJuIHRoaXN9LGVhY2hCZWZvcmU6ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGUscj10aGlzLGk9W3JdO3I9aS5wb3AoKTspaWYodChyKSxuPXIuY2hpbGRyZW4pZm9yKGU9bi5sZW5ndGgtMTtlPj0wOy0tZSlpLnB1c2gobltlXSk7cmV0dXJuIHRoaXN9LHN1bTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoZnVuY3Rpb24obil7Zm9yKHZhciBlPSt0KG4uZGF0YSl8fDAscj1uLmNoaWxkcmVuLGk9ciYmci5sZW5ndGg7LS1pPj0wOyllKz1yW2ldLnZhbHVlO24udmFsdWU9ZX0pfSxzb3J0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24obil7bi5jaGlsZHJlbiYmbi5jaGlsZHJlbi5zb3J0KHQpfSl9LHBhdGg6ZnVuY3Rpb24odCl7Zm9yKHZhciBuPXRoaXMsZT1mdW5jdGlvbih0LG4pe2lmKHQ9PT1uKXJldHVybiB0O3ZhciBlPXQuYW5jZXN0b3JzKCkscj1uLmFuY2VzdG9ycygpLGk9bnVsbDtmb3IodD1lLnBvcCgpLG49ci5wb3AoKTt0PT09bjspaT10LHQ9ZS5wb3AoKSxuPXIucG9wKCk7cmV0dXJuIGl9KG4sdCkscj1bbl07biE9PWU7KW49bi5wYXJlbnQsci5wdXNoKG4pO2Zvcih2YXIgaT1yLmxlbmd0aDt0IT09ZTspci5zcGxpY2UoaSwwLHQpLHQ9dC5wYXJlbnQ7cmV0dXJuIHJ9LGFuY2VzdG9yczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLG49W3RdO3Q9dC5wYXJlbnQ7KW4ucHVzaCh0KTtyZXR1cm4gbn0sZGVzY2VuZGFudHM6ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKG4pe3QucHVzaChuKX0pLHR9LGxlYXZlczpmdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24obil7bi5jaGlsZHJlbnx8dC5wdXNoKG4pfSksdH0sbGlua3M6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49W107cmV0dXJuIHQuZWFjaChmdW5jdGlvbihlKXtlIT09dCYmbi5wdXNoKHtzb3VyY2U6ZS5wYXJlbnQsdGFyZ2V0OmV9KX0pLG59LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gY28odGhpcykuZWFjaEJlZm9yZShmbyl9fTt2YXIgVmQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLCRkPVwiJFwiLFdkPXtkZXB0aDotMX0sWmQ9e307WW8ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaG8ucHJvdG90eXBlKTt2YXIgR2Q9KDErTWF0aC5zcXJ0KDUpKS8yLFFkPWZ1bmN0aW9uIHQobil7ZnVuY3Rpb24gZSh0LGUscixpLG8pe0hvKG4sdCxlLHIsaSxvKX1yZXR1cm4gZS5yYXRpbz1mdW5jdGlvbihuKXtyZXR1cm4gdCgobj0rbik+MT9uOjEpfSxlfShHZCksSmQ9ZnVuY3Rpb24gdChuKXtmdW5jdGlvbiBlKHQsZSxyLGksbyl7aWYoKHU9dC5fc3F1YXJpZnkpJiZ1LnJhdGlvPT09bilmb3IodmFyIHUsYSxjLHMsZixsPS0xLGg9dS5sZW5ndGgscD10LnZhbHVlOysrbDxoOyl7Zm9yKGM9KGE9dVtsXSkuY2hpbGRyZW4scz1hLnZhbHVlPTAsZj1jLmxlbmd0aDtzPGY7KytzKWEudmFsdWUrPWNbc10udmFsdWU7YS5kaWNlP1JvKGEsZSxyLGkscis9KG8tcikqYS52YWx1ZS9wKTpCbyhhLGUscixlKz0oaS1lKSphLnZhbHVlL3AsbykscC09YS52YWx1ZX1lbHNlIHQuX3NxdWFyaWZ5PXU9SG8obix0LGUscixpLG8pLHUucmF0aW89bn1yZXR1cm4gZS5yYXRpbz1mdW5jdGlvbihuKXtyZXR1cm4gdCgobj0rbik+MT9uOjEpfSxlfShHZCksS2Q9W10uc2xpY2UsdHY9e307JG8ucHJvdG90eXBlPVFvLnByb3RvdHlwZT17Y29uc3RydWN0b3I6JG8sZGVmZXI6ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO2lmKHRoaXMuX2NhbGwpdGhyb3cgbmV3IEVycm9yKFwiZGVmZXIgYWZ0ZXIgYXdhaXRcIik7aWYobnVsbCE9dGhpcy5fZXJyb3IpcmV0dXJuIHRoaXM7dmFyIG49S2QuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIG4ucHVzaCh0KSwrK3RoaXMuX3dhaXRpbmcsdGhpcy5fdGFza3MucHVzaChuKSxXbyh0aGlzKSx0aGlzfSxhYm9ydDpmdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLl9lcnJvciYmWm8odGhpcyxuZXcgRXJyb3IoXCJhYm9ydFwiKSksdGhpc30sYXdhaXQ6ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO2lmKHRoaXMuX2NhbGwpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgYXdhaXRcIik7cmV0dXJuIHRoaXMuX2NhbGw9ZnVuY3Rpb24obixlKXt0LmFwcGx5KG51bGwsW25dLmNvbmNhdChlKSl9LEdvKHRoaXMpLHRoaXN9LGF3YWl0QWxsOmZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKTtpZih0aGlzLl9jYWxsKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGF3YWl0XCIpO3JldHVybiB0aGlzLl9jYWxsPXQsR28odGhpcyksdGhpc319O3ZhciBudj1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCxlKXtyZXR1cm4gdD1udWxsPT10PzA6K3QsZT1udWxsPT1lPzE6K2UsMT09PWFyZ3VtZW50cy5sZW5ndGg/KGU9dCx0PTApOmUtPXQsZnVuY3Rpb24oKXtyZXR1cm4gbigpKmUrdH19cmV0dXJuIGUuc291cmNlPXQsZX0oSm8pLGV2PWZ1bmN0aW9uIHQobil7ZnVuY3Rpb24gZSh0LGUpe3ZhciByLGk7cmV0dXJuIHQ9bnVsbD09dD8wOit0LGU9bnVsbD09ZT8xOitlLGZ1bmN0aW9uKCl7dmFyIG87aWYobnVsbCE9cilvPXIscj1udWxsO2Vsc2UgZG97cj0yKm4oKS0xLG89MipuKCktMSxpPXIqcitvKm99d2hpbGUoIWl8fGk+MSk7cmV0dXJuIHQrZSpvKk1hdGguc3FydCgtMipNYXRoLmxvZyhpKS9pKX19cmV0dXJuIGUuc291cmNlPXQsZX0oSm8pLHJ2PWZ1bmN0aW9uIHQobil7ZnVuY3Rpb24gZSgpe3ZhciB0PWV2LnNvdXJjZShuKS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZXhwKHQoKSl9fXJldHVybiBlLnNvdXJjZT10LGV9KEpvKSxpdj1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTAscj0wO3I8dDsrK3IpZSs9bigpO3JldHVybiBlfX1yZXR1cm4gZS5zb3VyY2U9dCxlfShKbyksb3Y9ZnVuY3Rpb24gdChuKXtmdW5jdGlvbiBlKHQpe3ZhciBlPWl2LnNvdXJjZShuKSh0KTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZSgpL3R9fXJldHVybiBlLnNvdXJjZT10LGV9KEpvKSx1dj1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuLU1hdGgubG9nKDEtbigpKS90fX1yZXR1cm4gZS5zb3VyY2U9dCxlfShKbyksYXY9dHUoXCJ0ZXh0L2h0bWxcIixmdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQodC5yZXNwb25zZVRleHQpfSksY3Y9dHUoXCJhcHBsaWNhdGlvbi9qc29uXCIsZnVuY3Rpb24odCl7cmV0dXJuIEpTT04ucGFyc2UodC5yZXNwb25zZVRleHQpfSksc3Y9dHUoXCJ0ZXh0L3BsYWluXCIsZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzcG9uc2VUZXh0fSksZnY9dHUoXCJhcHBsaWNhdGlvbi94bWxcIixmdW5jdGlvbih0KXt2YXIgbj10LnJlc3BvbnNlWE1MO2lmKCFuKXRocm93IG5ldyBFcnJvcihcInBhcnNlIGVycm9yXCIpO3JldHVybiBufSksbHY9bnUoXCJ0ZXh0L2NzdlwiLGtoKSxodj1udShcInRleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXNcIix6aCkscHY9QXJyYXkucHJvdG90eXBlLGR2PXB2Lm1hcCx2dj1wdi5zbGljZSxndj17bmFtZTpcImltcGxpY2l0XCJ9LF92PVswLDFdLHl2PW5ldyBEYXRlLG12PW5ldyBEYXRlLHh2PUV1KGZ1bmN0aW9uKCl7fSxmdW5jdGlvbih0LG4pe3Quc2V0VGltZSgrdCtuKX0sZnVuY3Rpb24odCxuKXtyZXR1cm4gbi10fSk7eHYuZXZlcnk9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9TWF0aC5mbG9vcih0KSxpc0Zpbml0ZSh0KSYmdD4wP3Q+MT9FdShmdW5jdGlvbihuKXtuLnNldFRpbWUoTWF0aC5mbG9vcihuL3QpKnQpfSxmdW5jdGlvbihuLGUpe24uc2V0VGltZSgrbitlKnQpfSxmdW5jdGlvbihuLGUpe3JldHVybihlLW4pL3R9KTp4djpudWxsfTt2YXIgYnY9eHYucmFuZ2Usd3Y9NmU0LE12PTYwNDhlNSxUdj1FdShmdW5jdGlvbih0KXt0LnNldFRpbWUoMWUzKk1hdGguZmxvb3IodC8xZTMpKX0sZnVuY3Rpb24odCxuKXt0LnNldFRpbWUoK3QrMWUzKm4pfSxmdW5jdGlvbih0LG4pe3JldHVybihuLXQpLzFlM30sZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0VVRDU2Vjb25kcygpfSksTnY9VHYucmFuZ2Usa3Y9RXUoZnVuY3Rpb24odCl7dC5zZXRUaW1lKE1hdGguZmxvb3IodC93dikqd3YpfSxmdW5jdGlvbih0LG4pe3Quc2V0VGltZSgrdCtuKnd2KX0sZnVuY3Rpb24odCxuKXtyZXR1cm4obi10KS93dn0sZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0TWludXRlcygpfSksU3Y9a3YucmFuZ2UsRXY9RXUoZnVuY3Rpb24odCl7dmFyIG49dC5nZXRUaW1lem9uZU9mZnNldCgpKnd2JTM2ZTU7bjwwJiYobis9MzZlNSksdC5zZXRUaW1lKDM2ZTUqTWF0aC5mbG9vcigoK3QtbikvMzZlNSkrbil9LGZ1bmN0aW9uKHQsbil7dC5zZXRUaW1lKCt0KzM2ZTUqbil9LGZ1bmN0aW9uKHQsbil7cmV0dXJuKG4tdCkvMzZlNX0sZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0SG91cnMoKX0pLEF2PUV2LnJhbmdlLEN2PUV1KGZ1bmN0aW9uKHQpe3Quc2V0SG91cnMoMCwwLDAsMCl9LGZ1bmN0aW9uKHQsbil7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK24pfSxmdW5jdGlvbih0LG4pe3JldHVybihuLXQtKG4uZ2V0VGltZXpvbmVPZmZzZXQoKS10LmdldFRpbWV6b25lT2Zmc2V0KCkpKnd2KS84NjRlNX0sZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0RGF0ZSgpLTF9KSx6dj1Ddi5yYW5nZSxQdj1BdSgwKSxSdj1BdSgxKSxMdj1BdSgyKSxxdj1BdSgzKSxEdj1BdSg0KSxVdj1BdSg1KSxPdj1BdSg2KSxGdj1Qdi5yYW5nZSxJdj1Sdi5yYW5nZSxZdj1Mdi5yYW5nZSxCdj1xdi5yYW5nZSxIdj1Edi5yYW5nZSxqdj1Vdi5yYW5nZSxYdj1Pdi5yYW5nZSxWdj1FdShmdW5jdGlvbih0KXt0LnNldERhdGUoMSksdC5zZXRIb3VycygwLDAsMCwwKX0sZnVuY3Rpb24odCxuKXt0LnNldE1vbnRoKHQuZ2V0TW9udGgoKStuKX0sZnVuY3Rpb24odCxuKXtyZXR1cm4gbi5nZXRNb250aCgpLXQuZ2V0TW9udGgoKSsxMioobi5nZXRGdWxsWWVhcigpLXQuZ2V0RnVsbFllYXIoKSl9LGZ1bmN0aW9uKHQpe3JldHVybiB0LmdldE1vbnRoKCl9KSwkdj1Wdi5yYW5nZSxXdj1FdShmdW5jdGlvbih0KXt0LnNldE1vbnRoKDAsMSksdC5zZXRIb3VycygwLDAsMCwwKX0sZnVuY3Rpb24odCxuKXt0LnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKStuKX0sZnVuY3Rpb24odCxuKXtyZXR1cm4gbi5nZXRGdWxsWWVhcigpLXQuZ2V0RnVsbFllYXIoKX0sZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0RnVsbFllYXIoKX0pO1d2LmV2ZXJ5PWZ1bmN0aW9uKHQpe3JldHVybiBpc0Zpbml0ZSh0PU1hdGguZmxvb3IodCkpJiZ0PjA/RXUoZnVuY3Rpb24obil7bi5zZXRGdWxsWWVhcihNYXRoLmZsb29yKG4uZ2V0RnVsbFllYXIoKS90KSp0KSxuLnNldE1vbnRoKDAsMSksbi5zZXRIb3VycygwLDAsMCwwKX0sZnVuY3Rpb24obixlKXtuLnNldEZ1bGxZZWFyKG4uZ2V0RnVsbFllYXIoKStlKnQpfSk6bnVsbH07dmFyIFp2PVd2LnJhbmdlLEd2PUV1KGZ1bmN0aW9uKHQpe3Quc2V0VVRDU2Vjb25kcygwLDApfSxmdW5jdGlvbih0LG4pe3Quc2V0VGltZSgrdCtuKnd2KX0sZnVuY3Rpb24odCxuKXtyZXR1cm4obi10KS93dn0sZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0VVRDTWludXRlcygpfSksUXY9R3YucmFuZ2UsSnY9RXUoZnVuY3Rpb24odCl7dC5zZXRVVENNaW51dGVzKDAsMCwwKX0sZnVuY3Rpb24odCxuKXt0LnNldFRpbWUoK3QrMzZlNSpuKX0sZnVuY3Rpb24odCxuKXtyZXR1cm4obi10KS8zNmU1fSxmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXRVVENIb3VycygpfSksS3Y9SnYucmFuZ2UsdGc9RXUoZnVuY3Rpb24odCl7dC5zZXRVVENIb3VycygwLDAsMCwwKX0sZnVuY3Rpb24odCxuKXt0LnNldFVUQ0RhdGUodC5nZXRVVENEYXRlKCkrbil9LGZ1bmN0aW9uKHQsbil7cmV0dXJuKG4tdCkvODY0ZTV9LGZ1bmN0aW9uKHQpe3JldHVybiB0LmdldFVUQ0RhdGUoKS0xfSksbmc9dGcucmFuZ2UsZWc9Q3UoMCkscmc9Q3UoMSksaWc9Q3UoMiksb2c9Q3UoMyksdWc9Q3UoNCksYWc9Q3UoNSksY2c9Q3UoNiksc2c9ZWcucmFuZ2UsZmc9cmcucmFuZ2UsbGc9aWcucmFuZ2UsaGc9b2cucmFuZ2UscGc9dWcucmFuZ2UsZGc9YWcucmFuZ2Usdmc9Y2cucmFuZ2UsZ2c9RXUoZnVuY3Rpb24odCl7dC5zZXRVVENEYXRlKDEpLHQuc2V0VVRDSG91cnMoMCwwLDAsMCl9LGZ1bmN0aW9uKHQsbil7dC5zZXRVVENNb250aCh0LmdldFVUQ01vbnRoKCkrbil9LGZ1bmN0aW9uKHQsbil7cmV0dXJuIG4uZ2V0VVRDTW9udGgoKS10LmdldFVUQ01vbnRoKCkrMTIqKG4uZ2V0VVRDRnVsbFllYXIoKS10LmdldFVUQ0Z1bGxZZWFyKCkpfSxmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXRVVENNb250aCgpfSksX2c9Z2cucmFuZ2UseWc9RXUoZnVuY3Rpb24odCl7dC5zZXRVVENNb250aCgwLDEpLHQuc2V0VVRDSG91cnMoMCwwLDAsMCl9LGZ1bmN0aW9uKHQsbil7dC5zZXRVVENGdWxsWWVhcih0LmdldFVUQ0Z1bGxZZWFyKCkrbil9LGZ1bmN0aW9uKHQsbil7cmV0dXJuIG4uZ2V0VVRDRnVsbFllYXIoKS10LmdldFVUQ0Z1bGxZZWFyKCl9LGZ1bmN0aW9uKHQpe3JldHVybiB0LmdldFVUQ0Z1bGxZZWFyKCl9KTt5Zy5ldmVyeT1mdW5jdGlvbih0KXtyZXR1cm4gaXNGaW5pdGUodD1NYXRoLmZsb29yKHQpKSYmdD4wP0V1KGZ1bmN0aW9uKG4pe24uc2V0VVRDRnVsbFllYXIoTWF0aC5mbG9vcihuLmdldFVUQ0Z1bGxZZWFyKCkvdCkqdCksbi5zZXRVVENNb250aCgwLDEpLG4uc2V0VVRDSG91cnMoMCwwLDAsMCl9LGZ1bmN0aW9uKG4sZSl7bi5zZXRVVENGdWxsWWVhcihuLmdldFVUQ0Z1bGxZZWFyKCkrZSp0KX0pOm51bGx9O3ZhciBtZyx4Zz15Zy5yYW5nZSxiZz17XCItXCI6XCJcIixfOlwiIFwiLDA6XCIwXCJ9LHdnPS9eXFxzKlxcZCsvLE1nPS9eJS8sVGc9L1tcXFxcXiQqKz98W1xcXSgpLnt9XS9nO1lhKHtkYXRlVGltZTpcIiV4LCAlWFwiLGRhdGU6XCIlLW0vJS1kLyVZXCIsdGltZTpcIiUtSTolTTolUyAlcFwiLHBlcmlvZHM6W1wiQU1cIixcIlBNXCJdLGRheXM6W1wiU3VuZGF5XCIsXCJNb25kYXlcIixcIlR1ZXNkYXlcIixcIldlZG5lc2RheVwiLFwiVGh1cnNkYXlcIixcIkZyaWRheVwiLFwiU2F0dXJkYXlcIl0sc2hvcnREYXlzOltcIlN1blwiLFwiTW9uXCIsXCJUdWVcIixcIldlZFwiLFwiVGh1XCIsXCJGcmlcIixcIlNhdFwiXSxtb250aHM6W1wiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdLHNob3J0TW9udGhzOltcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl19KTt2YXIgTmc9XCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIixrZz1EYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZz9mdW5jdGlvbih0KXtyZXR1cm4gdC50b0lTT1N0cmluZygpfTp0LnV0Y0Zvcm1hdChOZyksU2c9K25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpP2Z1bmN0aW9uKHQpe3ZhciBuPW5ldyBEYXRlKHQpO3JldHVybiBpc05hTihuKT9udWxsOm59OnQudXRjUGFyc2UoTmcpLEVnPTFlMyxBZz02MCpFZyxDZz02MCpBZyx6Zz0yNCpDZyxQZz03KnpnLFJnPTMwKnpnLExnPTM2NSp6ZyxxZz1YYShcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKSxEZz1YYShcIjM5M2I3OTUyNTRhMzZiNmVjZjljOWVkZTYzNzkzOThjYTI1MmI1Y2Y2YmNlZGI5YzhjNmQzMWJkOWUzOWU3YmE1MmU3Y2I5NDg0M2MzOWFkNDk0YWQ2NjE2YmU3OTY5YzdiNDE3M2E1NTE5NGNlNmRiZGRlOWVkNlwiKSxVZz1YYShcIjMxODJiZDZiYWVkNjllY2FlMWM2ZGJlZmU2NTUwZGZkOGQzY2ZkYWU2YmZkZDBhMjMxYTM1NDc0YzQ3NmExZDk5YmM3ZTljMDc1NmJiMTllOWFjOGJjYmRkY2RhZGFlYjYzNjM2Mzk2OTY5NmJkYmRiZGQ5ZDlkOVwiKSxPZz1YYShcIjFmNzdiNGFlYzdlOGZmN2YwZWZmYmI3ODJjYTAyYzk4ZGY4YWQ2MjcyOGZmOTg5Njk0NjdiZGM1YjBkNThjNTY0YmM0OWM5NGUzNzdjMmY3YjZkMjdmN2Y3ZmM3YzdjN2JjYmQyMmRiZGI4ZDE3YmVjZjllZGFlNVwiKSxGZz1vbChYdCgzMDAsLjUsMCksWHQoLTI0MCwuNSwxKSksSWc9b2woWHQoLTEwMCwuNzUsLjM1KSxYdCg4MCwxLjUsLjgpKSxZZz1vbChYdCgyNjAsLjc1LC4zNSksWHQoODAsMS41LC44KSksQmc9WHQoKSxIZz1WYShYYShcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSksamc9VmEoWGEoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMDkwMjAyMGIwMjAyMGQwMzAzMGYwMzAzMTIwNDA0MTQwNTA0MTYwNjA1MTgwNjA1MWEwNzA2MWMwODA3MWUwOTA3MjAwYTA4MjIwYjA5MjQwYzA5MjYwZDBhMjkwZTBiMmIxMDBiMmQxMTBjMmYxMjBkMzExMzBkMzQxNDBlMzYxNTBlMzgxNjBmM2IxODBmM2QxOTEwM2YxYTEwNDIxYzEwNDQxZDExNDcxZTExNDkyMDExNGIyMTExNGUyMjExNTAyNDEyNTMyNTEyNTUyNzEyNTgyOTExNWEyYTExNWMyYzExNWYyZDExNjEyZjExNjMzMTExNjUzMzEwNjczNDEwNjkzNjEwNmIzODEwNmMzOTBmNmUzYjBmNzAzZDBmNzEzZjBmNzI0MDBmNzQ0MjBmNzU0NDBmNzY0NTEwNzc0NzEwNzg0OTEwNzg0YTEwNzk0YzExN2E0ZTExN2I0ZjEyN2I1MTEyN2M1MjEzN2M1NDEzN2Q1NjE0N2Q1NzE1N2U1OTE1N2U1YTE2N2U1YzE2N2Y1ZDE3N2Y1ZjE4N2Y2MDE4ODA2MjE5ODA2NDFhODA2NTFhODA2NzFiODA2ODFjODE2YTFjODE2YjFkODE2ZDFkODE2ZTFlODE3MDFmODE3MjFmODE3MzIwODE3NTIxODE3NjIxODE3ODIyODE3OTIyODI3YjIzODI3YzIzODI3ZTI0ODI4MDI1ODI4MTI1ODE4MzI2ODE4NDI2ODE4NjI3ODE4ODI3ODE4OTI4ODE4YjI5ODE4YzI5ODE4ZTJhODE5MDJhODE5MTJiODE5MzJiODA5NDJjODA5NjJjODA5ODJkODA5OTJkODA5YjJlN2Y5YzJlN2Y5ZTJmN2ZhMDJmN2ZhMTMwN2VhMzMwN2VhNTMxN2VhNjMxN2RhODMyN2RhYTMzN2RhYjMzN2NhZDM0N2NhZTM0N2JiMDM1N2JiMjM1N2JiMzM2N2FiNTM2N2FiNzM3NzliODM3NzliYTM4NzhiYzM5NzhiZDM5NzdiZjNhNzdjMDNhNzZjMjNiNzVjNDNjNzVjNTNjNzRjNzNkNzNjODNlNzNjYTNlNzJjYzNmNzFjZDQwNzFjZjQwNzBkMDQxNmZkMjQyNmZkMzQzNmVkNTQ0NmRkNjQ1NmNkODQ1NmNkOTQ2NmJkYjQ3NmFkYzQ4NjlkZTQ5NjhkZjRhNjhlMDRjNjdlMjRkNjZlMzRlNjVlNDRmNjRlNTUwNjRlNzUyNjNlODUzNjJlOTU0NjJlYTU2NjFlYjU3NjBlYzU4NjBlZDVhNWZlZTViNWVlZjVkNWVmMDVmNWVmMTYwNWRmMjYyNWRmMjY0NWNmMzY1NWNmNDY3NWNmNDY5NWNmNTZiNWNmNjZjNWNmNjZlNWNmNzcwNWNmNzcyNWNmODc0NWNmODc2NWNmOTc4NWRmOTc5NWRmOTdiNWRmYTdkNWVmYTdmNWVmYTgxNWZmYjgzNWZmYjg1NjBmYjg3NjFmYzg5NjFmYzhhNjJmYzhjNjNmYzhlNjRmYzkwNjVmZDkyNjZmZDk0NjdmZDk2NjhmZDk4NjlmZDlhNmFmZDliNmJmZTlkNmNmZTlmNmRmZWExNmVmZWEzNmZmZWE1NzFmZWE3NzJmZWE5NzNmZWFhNzRmZWFjNzZmZWFlNzdmZWIwNzhmZWIyN2FmZWI0N2JmZWI2N2NmZWI3N2VmZWI5N2ZmZWJiODFmZWJkODJmZWJmODRmZWMxODVmZWMyODdmZWM0ODhmZWM2OGFmZWM4OGNmZWNhOGRmZWNjOGZmZWNkOTBmZWNmOTJmZWQxOTRmZWQzOTVmZWQ1OTdmZWQ3OTlmZWQ4OWFmZGRhOWNmZGRjOWVmZGRlYTBmZGUwYTFmZGUyYTNmZGUzYTVmZGU1YTdmZGU3YTlmZGU5YWFmZGViYWNmY2VjYWVmY2VlYjBmY2YwYjJmY2YyYjRmY2Y0YjZmY2Y2YjhmY2Y3YjlmY2Y5YmJmY2ZiYmRmY2ZkYmZcIikpLFhnPVZhKFhhKFwiMDAwMDA0MDEwMDA1MDEwMTA2MDEwMTA4MDIwMTBhMDIwMjBjMDIwMjBlMDMwMjEwMDQwMzEyMDQwMzE0MDUwNDE3MDYwNDE5MDcwNTFiMDgwNTFkMDkwNjFmMGEwNzIyMGIwNzI0MGMwODI2MGQwODI5MGUwOTJiMTAwOTJkMTEwYTMwMTIwYTMyMTQwYjM0MTUwYjM3MTYwYjM5MTgwYzNjMTkwYzNlMWIwYzQxMWMwYzQzMWUwYzQ1MWYwYzQ4MjEwYzRhMjMwYzRjMjQwYzRmMjYwYzUxMjgwYjUzMjkwYjU1MmIwYjU3MmQwYjU5MmYwYTViMzEwYTVjMzIwYTVlMzQwYTVmMzYwOTYxMzgwOTYyMzkwOTYzM2IwOTY0M2QwOTY1M2UwOTY2NDAwYTY3NDIwYTY4NDQwYTY4NDUwYTY5NDcwYjZhNDkwYjZhNGEwYzZiNGMwYzZiNGQwZDZjNGYwZDZjNTEwZTZjNTIwZTZkNTQwZjZkNTUwZjZkNTcxMDZlNTkxMDZlNWExMTZlNWMxMjZlNWQxMjZlNWYxMzZlNjExMzZlNjIxNDZlNjQxNTZlNjUxNTZlNjcxNjZlNjkxNjZlNmExNzZlNmMxODZlNmQxODZlNmYxOTZlNzExOTZlNzIxYTZlNzQxYTZlNzUxYjZlNzcxYzZkNzgxYzZkN2ExZDZkN2MxZDZkN2QxZTZkN2YxZTZjODAxZjZjODIyMDZjODQyMDZiODUyMTZiODcyMTZiODgyMjZhOGEyMjZhOGMyMzY5OGQyMzY5OGYyNDY5OTAyNTY4OTIyNTY4OTMyNjY3OTUyNjY3OTcyNzY2OTgyNzY2OWEyODY1OWIyOTY0OWQyOTY0OWYyYTYzYTAyYTYzYTIyYjYyYTMyYzYxYTUyYzYwYTYyZDYwYTgyZTVmYTkyZTVlYWIyZjVlYWQzMDVkYWUzMDVjYjAzMTViYjEzMjVhYjMzMjVhYjQzMzU5YjYzNDU4YjczNTU3YjkzNTU2YmEzNjU1YmMzNzU0YmQzODUzYmYzOTUyYzAzYTUxYzEzYTUwYzMzYjRmYzQzYzRlYzYzZDRkYzczZTRjYzgzZjRiY2E0MDRhY2I0MTQ5Y2M0MjQ4Y2U0MzQ3Y2Y0NDQ2ZDA0NTQ1ZDI0NjQ0ZDM0NzQzZDQ0ODQyZDU0YTQxZDc0YjNmZDg0YzNlZDk0ZDNkZGE0ZTNjZGI1MDNiZGQ1MTNhZGU1MjM4ZGY1MzM3ZTA1NTM2ZTE1NjM1ZTI1NzM0ZTM1OTMzZTQ1YTMxZTU1YzMwZTY1ZDJmZTc1ZTJlZTg2MDJkZTk2MTJiZWE2MzJhZWI2NDI5ZWI2NjI4ZWM2NzI2ZWQ2OTI1ZWU2YTI0ZWY2YzIzZWY2ZTIxZjA2ZjIwZjE3MTFmZjE3MzFkZjI3NDFjZjM3NjFiZjM3ODE5ZjQ3OTE4ZjU3YjE3ZjU3ZDE1ZjY3ZTE0ZjY4MDEzZjc4MjEyZjc4NDEwZjg4NTBmZjg4NzBlZjg4OTBjZjk4YjBiZjk4YzBhZjk4ZTA5ZmE5MDA4ZmE5MjA3ZmE5NDA3ZmI5NjA2ZmI5NzA2ZmI5OTA2ZmI5YjA2ZmI5ZDA3ZmM5ZjA3ZmNhMTA4ZmNhMzA5ZmNhNTBhZmNhNjBjZmNhODBkZmNhYTBmZmNhYzExZmNhZTEyZmNiMDE0ZmNiMjE2ZmNiNDE4ZmJiNjFhZmJiODFkZmJiYTFmZmJiYzIxZmJiZTIzZmFjMDI2ZmFjMjI4ZmFjNDJhZmFjNjJkZjljNzJmZjljOTMyZjljYjM1ZjhjZDM3ZjhjZjNhZjdkMTNkZjdkMzQwZjZkNTQzZjZkNzQ2ZjVkOTQ5ZjVkYjRjZjRkZDRmZjRkZjUzZjRlMTU2ZjNlMzVhZjNlNTVkZjJlNjYxZjJlODY1ZjJlYTY5ZjFlYzZkZjFlZDcxZjFlZjc1ZjFmMTc5ZjJmMjdkZjJmNDgyZjNmNTg2ZjNmNjhhZjRmODhlZjVmOTkyZjZmYTk2ZjhmYjlhZjlmYzlkZmFmZGExZmNmZmE0XCIpKSxWZz1WYShYYShcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSksJGc9TWF0aC5hYnMsV2c9TWF0aC5hdGFuMixaZz1NYXRoLmNvcyxHZz1NYXRoLm1heCxRZz1NYXRoLm1pbixKZz1NYXRoLnNpbixLZz1NYXRoLnNxcnQsdF89MWUtMTIsbl89TWF0aC5QSSxlXz1uXy8yLHJfPTIqbl87ZWMucHJvdG90eXBlPXthcmVhU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPTB9LGFyZWFFbmQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPU5hTn0sbGluZVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpeyh0aGlzLl9saW5lfHwwIT09dGhpcy5fbGluZSYmMT09PXRoaXMuX3BvaW50KSYmdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSx0aGlzLl9saW5lPTEtdGhpcy5fbGluZX0scG9pbnQ6ZnVuY3Rpb24odCxuKXtzd2l0Y2godD0rdCxuPStuLHRoaXMuX3BvaW50KXtjYXNlIDA6dGhpcy5fcG9pbnQ9MSx0aGlzLl9saW5lP3RoaXMuX2NvbnRleHQubGluZVRvKHQsbik6dGhpcy5fY29udGV4dC5tb3ZlVG8odCxuKTticmVhaztjYXNlIDE6dGhpcy5fcG9pbnQ9MjtkZWZhdWx0OnRoaXMuX2NvbnRleHQubGluZVRvKHQsbil9fX07dmFyIGlfPWxjKHJjKTtmYy5wcm90b3R5cGU9e2FyZWFTdGFydDpmdW5jdGlvbigpe3RoaXMuX2N1cnZlLmFyZWFTdGFydCgpfSxhcmVhRW5kOmZ1bmN0aW9uKCl7dGhpcy5fY3VydmUuYXJlYUVuZCgpfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9jdXJ2ZS5saW5lU3RhcnQoKX0sbGluZUVuZDpmdW5jdGlvbigpe3RoaXMuX2N1cnZlLmxpbmVFbmQoKX0scG9pbnQ6ZnVuY3Rpb24odCxuKXt0aGlzLl9jdXJ2ZS5wb2ludChuKk1hdGguc2luKHQpLG4qLU1hdGguY29zKHQpKX19O3ZhciBvXz1BcnJheS5wcm90b3R5cGUuc2xpY2UsdV89e2RyYXc6ZnVuY3Rpb24odCxuKXt2YXIgZT1NYXRoLnNxcnQobi9uXyk7dC5tb3ZlVG8oZSwwKSx0LmFyYygwLDAsZSwwLHJfKX19LGFfPXtkcmF3OmZ1bmN0aW9uKHQsbil7dmFyIGU9TWF0aC5zcXJ0KG4vNSkvMjt0Lm1vdmVUbygtMyplLC1lKSx0LmxpbmVUbygtZSwtZSksdC5saW5lVG8oLWUsLTMqZSksdC5saW5lVG8oZSwtMyplKSx0LmxpbmVUbyhlLC1lKSx0LmxpbmVUbygzKmUsLWUpLHQubGluZVRvKDMqZSxlKSx0LmxpbmVUbyhlLGUpLHQubGluZVRvKGUsMyplKSx0LmxpbmVUbygtZSwzKmUpLHQubGluZVRvKC1lLGUpLHQubGluZVRvKC0zKmUsZSksdC5jbG9zZVBhdGgoKX19LGNfPU1hdGguc3FydCgxLzMpLHNfPTIqY18sZl89e2RyYXc6ZnVuY3Rpb24odCxuKXt2YXIgZT1NYXRoLnNxcnQobi9zXykscj1lKmNfO3QubW92ZVRvKDAsLWUpLHQubGluZVRvKHIsMCksdC5saW5lVG8oMCxlKSx0LmxpbmVUbygtciwwKSx0LmNsb3NlUGF0aCgpfX0sbF89TWF0aC5zaW4obl8vMTApL01hdGguc2luKDcqbl8vMTApLGhfPU1hdGguc2luKHJfLzEwKSpsXyxwXz0tTWF0aC5jb3Mocl8vMTApKmxfLGRfPXtkcmF3OmZ1bmN0aW9uKHQsbil7dmFyIGU9TWF0aC5zcXJ0KC44OTA4MTMwOTE1MjkyODUyKm4pLHI9aF8qZSxpPXBfKmU7dC5tb3ZlVG8oMCwtZSksdC5saW5lVG8ocixpKTtmb3IodmFyIG89MTtvPDU7KytvKXt2YXIgdT1yXypvLzUsYT1NYXRoLmNvcyh1KSxjPU1hdGguc2luKHUpO3QubGluZVRvKGMqZSwtYSplKSx0LmxpbmVUbyhhKnItYyppLGMqcithKmkpfXQuY2xvc2VQYXRoKCl9fSx2Xz17ZHJhdzpmdW5jdGlvbih0LG4pe3ZhciBlPU1hdGguc3FydChuKSxyPS1lLzI7dC5yZWN0KHIscixlLGUpfX0sZ189TWF0aC5zcXJ0KDMpLF9fPXtkcmF3OmZ1bmN0aW9uKHQsbil7dmFyIGU9LU1hdGguc3FydChuLygzKmdfKSk7dC5tb3ZlVG8oMCwyKmUpLHQubGluZVRvKC1nXyplLC1lKSx0LmxpbmVUbyhnXyplLC1lKSx0LmNsb3NlUGF0aCgpfX0seV89TWF0aC5zcXJ0KDMpLzIsbV89MS9NYXRoLnNxcnQoMTIpLHhfPTMqKG1fLzIrMSksYl89e2RyYXc6ZnVuY3Rpb24odCxuKXt2YXIgZT1NYXRoLnNxcnQobi94Xykscj1lLzIsaT1lKm1fLG89cix1PWUqbV8rZSxhPS1vLGM9dTt0Lm1vdmVUbyhyLGkpLHQubGluZVRvKG8sdSksdC5saW5lVG8oYSxjKSx0LmxpbmVUbygtLjUqci15XyppLHlfKnIrLS41KmkpLHQubGluZVRvKC0uNSpvLXlfKnUseV8qbystLjUqdSksdC5saW5lVG8oLS41KmEteV8qYyx5XyphKy0uNSpjKSx0LmxpbmVUbygtLjUqcit5XyppLC0uNSppLXlfKnIpLHQubGluZVRvKC0uNSpvK3lfKnUsLS41KnUteV8qbyksdC5saW5lVG8oLS41KmEreV8qYywtLjUqYy15XyphKSx0LmNsb3NlUGF0aCgpfX0sd189W3VfLGFfLGZfLHZfLGRfLF9fLGJfXTtUYy5wcm90b3R5cGU9e2FyZWFTdGFydDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9MH0sYXJlYUVuZDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9TmFOfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl94MD10aGlzLl94MT10aGlzLl95MD10aGlzLl95MT1OYU4sdGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLl9wb2ludCl7Y2FzZSAzOk1jKHRoaXMsdGhpcy5feDEsdGhpcy5feTEpO2Nhc2UgMjp0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSx0aGlzLl95MSl9KHRoaXMuX2xpbmV8fDAhPT10aGlzLl9saW5lJiYxPT09dGhpcy5fcG9pbnQpJiZ0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLHRoaXMuX2xpbmU9MS10aGlzLl9saW5lfSxwb2ludDpmdW5jdGlvbih0LG4pe3N3aXRjaCh0PSt0LG49K24sdGhpcy5fcG9pbnQpe2Nhc2UgMDp0aGlzLl9wb2ludD0xLHRoaXMuX2xpbmU/dGhpcy5fY29udGV4dC5saW5lVG8odCxuKTp0aGlzLl9jb250ZXh0Lm1vdmVUbyh0LG4pO2JyZWFrO2Nhc2UgMTp0aGlzLl9wb2ludD0yO2JyZWFrO2Nhc2UgMjp0aGlzLl9wb2ludD0zLHRoaXMuX2NvbnRleHQubGluZVRvKCg1KnRoaXMuX3gwK3RoaXMuX3gxKS82LCg1KnRoaXMuX3kwK3RoaXMuX3kxKS82KTtkZWZhdWx0Ok1jKHRoaXMsdCxuKX10aGlzLl94MD10aGlzLl94MSx0aGlzLl94MT10LHRoaXMuX3kwPXRoaXMuX3kxLHRoaXMuX3kxPW59fSxOYy5wcm90b3R5cGU9e2FyZWFTdGFydDp3YyxhcmVhRW5kOndjLGxpbmVTdGFydDpmdW5jdGlvbigpe3RoaXMuX3gwPXRoaXMuX3gxPXRoaXMuX3gyPXRoaXMuX3gzPXRoaXMuX3g0PXRoaXMuX3kwPXRoaXMuX3kxPXRoaXMuX3kyPXRoaXMuX3kzPXRoaXMuX3k0PU5hTix0aGlzLl9wb2ludD0wfSxsaW5lRW5kOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuX3BvaW50KXtjYXNlIDE6dGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsdGhpcy5feTIpLHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7YnJlYWs7Y2FzZSAyOnRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MisyKnRoaXMuX3gzKS8zLCh0aGlzLl95MisyKnRoaXMuX3kzKS8zKSx0aGlzLl9jb250ZXh0LmxpbmVUbygodGhpcy5feDMrMip0aGlzLl94MikvMywodGhpcy5feTMrMip0aGlzLl95MikvMyksdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTticmVhaztjYXNlIDM6dGhpcy5wb2ludCh0aGlzLl94Mix0aGlzLl95MiksdGhpcy5wb2ludCh0aGlzLl94Myx0aGlzLl95MyksdGhpcy5wb2ludCh0aGlzLl94NCx0aGlzLl95NCl9fSxwb2ludDpmdW5jdGlvbih0LG4pe3N3aXRjaCh0PSt0LG49K24sdGhpcy5fcG9pbnQpe2Nhc2UgMDp0aGlzLl9wb2ludD0xLHRoaXMuX3gyPXQsdGhpcy5feTI9bjticmVhaztjYXNlIDE6dGhpcy5fcG9pbnQ9Mix0aGlzLl94Mz10LHRoaXMuX3kzPW47YnJlYWs7Y2FzZSAyOnRoaXMuX3BvaW50PTMsdGhpcy5feDQ9dCx0aGlzLl95ND1uLHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MCs0KnRoaXMuX3gxK3QpLzYsKHRoaXMuX3kwKzQqdGhpcy5feTErbikvNik7YnJlYWs7ZGVmYXVsdDpNYyh0aGlzLHQsbil9dGhpcy5feDA9dGhpcy5feDEsdGhpcy5feDE9dCx0aGlzLl95MD10aGlzLl95MSx0aGlzLl95MT1ufX0sa2MucHJvdG90eXBlPXthcmVhU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPTB9LGFyZWFFbmQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPU5hTn0sbGluZVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5feDA9dGhpcy5feDE9dGhpcy5feTA9dGhpcy5feTE9TmFOLHRoaXMuX3BvaW50PTB9LGxpbmVFbmQ6ZnVuY3Rpb24oKXsodGhpcy5fbGluZXx8MCE9PXRoaXMuX2xpbmUmJjM9PT10aGlzLl9wb2ludCkmJnRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksdGhpcy5fbGluZT0xLXRoaXMuX2xpbmV9LHBvaW50OmZ1bmN0aW9uKHQsbil7c3dpdGNoKHQ9K3Qsbj0rbix0aGlzLl9wb2ludCl7Y2FzZSAwOnRoaXMuX3BvaW50PTE7YnJlYWs7Y2FzZSAxOnRoaXMuX3BvaW50PTI7YnJlYWs7Y2FzZSAyOnRoaXMuX3BvaW50PTM7dmFyIGU9KHRoaXMuX3gwKzQqdGhpcy5feDErdCkvNixyPSh0aGlzLl95MCs0KnRoaXMuX3kxK24pLzY7dGhpcy5fbGluZT90aGlzLl9jb250ZXh0LmxpbmVUbyhlLHIpOnRoaXMuX2NvbnRleHQubW92ZVRvKGUscik7YnJlYWs7Y2FzZSAzOnRoaXMuX3BvaW50PTQ7ZGVmYXVsdDpNYyh0aGlzLHQsbil9dGhpcy5feDA9dGhpcy5feDEsdGhpcy5feDE9dCx0aGlzLl95MD10aGlzLl95MSx0aGlzLl95MT1ufX0sU2MucHJvdG90eXBlPXtsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl94PVtdLHRoaXMuX3k9W10sdGhpcy5fYmFzaXMubGluZVN0YXJ0KCl9LGxpbmVFbmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl94LG49dGhpcy5feSxlPXQubGVuZ3RoLTE7aWYoZT4wKWZvcih2YXIgcixpPXRbMF0sbz1uWzBdLHU9dFtlXS1pLGE9bltlXS1vLGM9LTE7KytjPD1lOylyPWMvZSx0aGlzLl9iYXNpcy5wb2ludCh0aGlzLl9iZXRhKnRbY10rKDEtdGhpcy5fYmV0YSkqKGkrcip1KSx0aGlzLl9iZXRhKm5bY10rKDEtdGhpcy5fYmV0YSkqKG8rciphKSk7dGhpcy5feD10aGlzLl95PW51bGwsdGhpcy5fYmFzaXMubGluZUVuZCgpfSxwb2ludDpmdW5jdGlvbih0LG4pe3RoaXMuX3gucHVzaCgrdCksdGhpcy5feS5wdXNoKCtuKX19O3ZhciBNXz1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCl7cmV0dXJuIDE9PT1uP25ldyBUYyh0KTpuZXcgU2ModCxuKX1yZXR1cm4gZS5iZXRhPWZ1bmN0aW9uKG4pe3JldHVybiB0KCtuKX0sZX0oLjg1KTtBYy5wcm90b3R5cGU9e2FyZWFTdGFydDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9MH0sYXJlYUVuZDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9TmFOfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl94MD10aGlzLl94MT10aGlzLl94Mj10aGlzLl95MD10aGlzLl95MT10aGlzLl95Mj1OYU4sdGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLl9wb2ludCl7Y2FzZSAyOnRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLHRoaXMuX3kyKTticmVhaztjYXNlIDM6RWModGhpcyx0aGlzLl94MSx0aGlzLl95MSl9KHRoaXMuX2xpbmV8fDAhPT10aGlzLl9saW5lJiYxPT09dGhpcy5fcG9pbnQpJiZ0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLHRoaXMuX2xpbmU9MS10aGlzLl9saW5lfSxwb2ludDpmdW5jdGlvbih0LG4pe3N3aXRjaCh0PSt0LG49K24sdGhpcy5fcG9pbnQpe2Nhc2UgMDp0aGlzLl9wb2ludD0xLHRoaXMuX2xpbmU/dGhpcy5fY29udGV4dC5saW5lVG8odCxuKTp0aGlzLl9jb250ZXh0Lm1vdmVUbyh0LG4pO2JyZWFrO2Nhc2UgMTp0aGlzLl9wb2ludD0yLHRoaXMuX3gxPXQsdGhpcy5feTE9bjticmVhaztjYXNlIDI6dGhpcy5fcG9pbnQ9MztkZWZhdWx0OkVjKHRoaXMsdCxuKX10aGlzLl94MD10aGlzLl94MSx0aGlzLl94MT10aGlzLl94Mix0aGlzLl94Mj10LHRoaXMuX3kwPXRoaXMuX3kxLHRoaXMuX3kxPXRoaXMuX3kyLHRoaXMuX3kyPW59fTt2YXIgVF89ZnVuY3Rpb24gdChuKXtmdW5jdGlvbiBlKHQpe3JldHVybiBuZXcgQWModCxuKX1yZXR1cm4gZS50ZW5zaW9uPWZ1bmN0aW9uKG4pe3JldHVybiB0KCtuKX0sZX0oMCk7Q2MucHJvdG90eXBlPXthcmVhU3RhcnQ6d2MsYXJlYUVuZDp3YyxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl94MD10aGlzLl94MT10aGlzLl94Mj10aGlzLl94Mz10aGlzLl94ND10aGlzLl94NT10aGlzLl95MD10aGlzLl95MT10aGlzLl95Mj10aGlzLl95Mz10aGlzLl95ND10aGlzLl95NT1OYU4sdGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLl9wb2ludCl7Y2FzZSAxOnRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLHRoaXMuX3kzKSx0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO2JyZWFrO2Nhc2UgMjp0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94Myx0aGlzLl95MyksdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTticmVhaztjYXNlIDM6dGhpcy5wb2ludCh0aGlzLl94Myx0aGlzLl95MyksdGhpcy5wb2ludCh0aGlzLl94NCx0aGlzLl95NCksdGhpcy5wb2ludCh0aGlzLl94NSx0aGlzLl95NSl9fSxwb2ludDpmdW5jdGlvbih0LG4pe3N3aXRjaCh0PSt0LG49K24sdGhpcy5fcG9pbnQpe2Nhc2UgMDp0aGlzLl9wb2ludD0xLHRoaXMuX3gzPXQsdGhpcy5feTM9bjticmVhaztjYXNlIDE6dGhpcy5fcG9pbnQ9Mix0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94ND10LHRoaXMuX3k0PW4pO2JyZWFrO2Nhc2UgMjp0aGlzLl9wb2ludD0zLHRoaXMuX3g1PXQsdGhpcy5feTU9bjticmVhaztkZWZhdWx0OkVjKHRoaXMsdCxuKX10aGlzLl94MD10aGlzLl94MSx0aGlzLl94MT10aGlzLl94Mix0aGlzLl94Mj10LHRoaXMuX3kwPXRoaXMuX3kxLHRoaXMuX3kxPXRoaXMuX3kyLHRoaXMuX3kyPW59fTt2YXIgTl89ZnVuY3Rpb24gdChuKXtmdW5jdGlvbiBlKHQpe3JldHVybiBuZXcgQ2ModCxuKX1yZXR1cm4gZS50ZW5zaW9uPWZ1bmN0aW9uKG4pe3JldHVybiB0KCtuKX0sZX0oMCk7emMucHJvdG90eXBlPXthcmVhU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPTB9LGFyZWFFbmQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPU5hTn0sbGluZVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5feDA9dGhpcy5feDE9dGhpcy5feDI9dGhpcy5feTA9dGhpcy5feTE9dGhpcy5feTI9TmFOLHRoaXMuX3BvaW50PTB9LGxpbmVFbmQ6ZnVuY3Rpb24oKXsodGhpcy5fbGluZXx8MCE9PXRoaXMuX2xpbmUmJjM9PT10aGlzLl9wb2ludCkmJnRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksdGhpcy5fbGluZT0xLXRoaXMuX2xpbmV9LHBvaW50OmZ1bmN0aW9uKHQsbil7c3dpdGNoKHQ9K3Qsbj0rbix0aGlzLl9wb2ludCl7Y2FzZSAwOnRoaXMuX3BvaW50PTE7YnJlYWs7Y2FzZSAxOnRoaXMuX3BvaW50PTI7YnJlYWs7Y2FzZSAyOnRoaXMuX3BvaW50PTMsdGhpcy5fbGluZT90aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94Mix0aGlzLl95Mik6dGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsdGhpcy5feTIpO2JyZWFrO2Nhc2UgMzp0aGlzLl9wb2ludD00O2RlZmF1bHQ6RWModGhpcyx0LG4pfXRoaXMuX3gwPXRoaXMuX3gxLHRoaXMuX3gxPXRoaXMuX3gyLHRoaXMuX3gyPXQsdGhpcy5feTA9dGhpcy5feTEsdGhpcy5feTE9dGhpcy5feTIsdGhpcy5feTI9bn19O3ZhciBrXz1mdW5jdGlvbiB0KG4pe2Z1bmN0aW9uIGUodCl7cmV0dXJuIG5ldyB6Yyh0LG4pfXJldHVybiBlLnRlbnNpb249ZnVuY3Rpb24obil7cmV0dXJuIHQoK24pfSxlfSgwKTtSYy5wcm90b3R5cGU9e2FyZWFTdGFydDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9MH0sYXJlYUVuZDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9TmFOfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl94MD10aGlzLl94MT10aGlzLl94Mj10aGlzLl95MD10aGlzLl95MT10aGlzLl95Mj1OYU4sdGhpcy5fbDAxX2E9dGhpcy5fbDEyX2E9dGhpcy5fbDIzX2E9dGhpcy5fbDAxXzJhPXRoaXMuX2wxMl8yYT10aGlzLl9sMjNfMmE9dGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLl9wb2ludCl7Y2FzZSAyOnRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLHRoaXMuX3kyKTticmVhaztjYXNlIDM6dGhpcy5wb2ludCh0aGlzLl94Mix0aGlzLl95Mil9KHRoaXMuX2xpbmV8fDAhPT10aGlzLl9saW5lJiYxPT09dGhpcy5fcG9pbnQpJiZ0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLHRoaXMuX2xpbmU9MS10aGlzLl9saW5lfSxwb2ludDpmdW5jdGlvbih0LG4pe2lmKHQ9K3Qsbj0rbix0aGlzLl9wb2ludCl7dmFyIGU9dGhpcy5feDItdCxyPXRoaXMuX3kyLW47dGhpcy5fbDIzX2E9TWF0aC5zcXJ0KHRoaXMuX2wyM18yYT1NYXRoLnBvdyhlKmUrcipyLHRoaXMuX2FscGhhKSl9c3dpdGNoKHRoaXMuX3BvaW50KXtjYXNlIDA6dGhpcy5fcG9pbnQ9MSx0aGlzLl9saW5lP3RoaXMuX2NvbnRleHQubGluZVRvKHQsbik6dGhpcy5fY29udGV4dC5tb3ZlVG8odCxuKTticmVhaztjYXNlIDE6dGhpcy5fcG9pbnQ9MjticmVhaztjYXNlIDI6dGhpcy5fcG9pbnQ9MztkZWZhdWx0OlBjKHRoaXMsdCxuKX10aGlzLl9sMDFfYT10aGlzLl9sMTJfYSx0aGlzLl9sMTJfYT10aGlzLl9sMjNfYSx0aGlzLl9sMDFfMmE9dGhpcy5fbDEyXzJhLHRoaXMuX2wxMl8yYT10aGlzLl9sMjNfMmEsdGhpcy5feDA9dGhpcy5feDEsdGhpcy5feDE9dGhpcy5feDIsdGhpcy5feDI9dCx0aGlzLl95MD10aGlzLl95MSx0aGlzLl95MT10aGlzLl95Mix0aGlzLl95Mj1ufX07dmFyIFNfPWZ1bmN0aW9uIHQobil7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gbj9uZXcgUmModCxuKTpuZXcgQWModCwwKX1yZXR1cm4gZS5hbHBoYT1mdW5jdGlvbihuKXtyZXR1cm4gdCgrbil9LGV9KC41KTtMYy5wcm90b3R5cGU9e2FyZWFTdGFydDp3YyxhcmVhRW5kOndjLGxpbmVTdGFydDpmdW5jdGlvbigpe3RoaXMuX3gwPXRoaXMuX3gxPXRoaXMuX3gyPXRoaXMuX3gzPXRoaXMuX3g0PXRoaXMuX3g1PXRoaXMuX3kwPXRoaXMuX3kxPXRoaXMuX3kyPXRoaXMuX3kzPXRoaXMuX3k0PXRoaXMuX3k1PU5hTix0aGlzLl9sMDFfYT10aGlzLl9sMTJfYT10aGlzLl9sMjNfYT10aGlzLl9sMDFfMmE9dGhpcy5fbDEyXzJhPXRoaXMuX2wyM18yYT10aGlzLl9wb2ludD0wfSxsaW5lRW5kOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuX3BvaW50KXtjYXNlIDE6dGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsdGhpcy5feTMpLHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7YnJlYWs7Y2FzZSAyOnRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLHRoaXMuX3kzKSx0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO2JyZWFrO2Nhc2UgMzp0aGlzLnBvaW50KHRoaXMuX3gzLHRoaXMuX3kzKSx0aGlzLnBvaW50KHRoaXMuX3g0LHRoaXMuX3k0KSx0aGlzLnBvaW50KHRoaXMuX3g1LHRoaXMuX3k1KX19LHBvaW50OmZ1bmN0aW9uKHQsbil7aWYodD0rdCxuPStuLHRoaXMuX3BvaW50KXt2YXIgZT10aGlzLl94Mi10LHI9dGhpcy5feTItbjt0aGlzLl9sMjNfYT1NYXRoLnNxcnQodGhpcy5fbDIzXzJhPU1hdGgucG93KGUqZStyKnIsdGhpcy5fYWxwaGEpKX1zd2l0Y2godGhpcy5fcG9pbnQpe2Nhc2UgMDp0aGlzLl9wb2ludD0xLHRoaXMuX3gzPXQsdGhpcy5feTM9bjticmVhaztjYXNlIDE6dGhpcy5fcG9pbnQ9Mix0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94ND10LHRoaXMuX3k0PW4pO2JyZWFrO2Nhc2UgMjp0aGlzLl9wb2ludD0zLHRoaXMuX3g1PXQsdGhpcy5feTU9bjticmVhaztkZWZhdWx0OlBjKHRoaXMsdCxuKX10aGlzLl9sMDFfYT10aGlzLl9sMTJfYSx0aGlzLl9sMTJfYT10aGlzLl9sMjNfYSx0aGlzLl9sMDFfMmE9dGhpcy5fbDEyXzJhLHRoaXMuX2wxMl8yYT10aGlzLl9sMjNfMmEsdGhpcy5feDA9dGhpcy5feDEsdGhpcy5feDE9dGhpcy5feDIsdGhpcy5feDI9dCx0aGlzLl95MD10aGlzLl95MSx0aGlzLl95MT10aGlzLl95Mix0aGlzLl95Mj1ufX07dmFyIEVfPWZ1bmN0aW9uIHQobil7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gbj9uZXcgTGModCxuKTpuZXcgQ2ModCwwKX1yZXR1cm4gZS5hbHBoYT1mdW5jdGlvbihuKXtyZXR1cm4gdCgrbil9LGV9KC41KTtxYy5wcm90b3R5cGU9e2FyZWFTdGFydDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9MH0sYXJlYUVuZDpmdW5jdGlvbigpe3RoaXMuX2xpbmU9TmFOfSxsaW5lU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl94MD10aGlzLl94MT10aGlzLl94Mj10aGlzLl95MD10aGlzLl95MT10aGlzLl95Mj1OYU4sdGhpcy5fbDAxX2E9dGhpcy5fbDEyX2E9dGhpcy5fbDIzX2E9dGhpcy5fbDAxXzJhPXRoaXMuX2wxMl8yYT10aGlzLl9sMjNfMmE9dGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpeyh0aGlzLl9saW5lfHwwIT09dGhpcy5fbGluZSYmMz09PXRoaXMuX3BvaW50KSYmdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSx0aGlzLl9saW5lPTEtdGhpcy5fbGluZX0scG9pbnQ6ZnVuY3Rpb24odCxuKXtpZih0PSt0LG49K24sdGhpcy5fcG9pbnQpe3ZhciBlPXRoaXMuX3gyLXQscj10aGlzLl95Mi1uO3RoaXMuX2wyM19hPU1hdGguc3FydCh0aGlzLl9sMjNfMmE9TWF0aC5wb3coZSplK3Iqcix0aGlzLl9hbHBoYSkpfXN3aXRjaCh0aGlzLl9wb2ludCl7Y2FzZSAwOnRoaXMuX3BvaW50PTE7YnJlYWs7Y2FzZSAxOnRoaXMuX3BvaW50PTI7YnJlYWs7Y2FzZSAyOnRoaXMuX3BvaW50PTMsdGhpcy5fbGluZT90aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94Mix0aGlzLl95Mik6dGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsdGhpcy5feTIpO2JyZWFrO2Nhc2UgMzp0aGlzLl9wb2ludD00O2RlZmF1bHQ6UGModGhpcyx0LG4pfXRoaXMuX2wwMV9hPXRoaXMuX2wxMl9hLHRoaXMuX2wxMl9hPXRoaXMuX2wyM19hLHRoaXMuX2wwMV8yYT10aGlzLl9sMTJfMmEsdGhpcy5fbDEyXzJhPXRoaXMuX2wyM18yYSx0aGlzLl94MD10aGlzLl94MSx0aGlzLl94MT10aGlzLl94Mix0aGlzLl94Mj10LHRoaXMuX3kwPXRoaXMuX3kxLHRoaXMuX3kxPXRoaXMuX3kyLHRoaXMuX3kyPW59fTt2YXIgQV89ZnVuY3Rpb24gdChuKXtmdW5jdGlvbiBlKHQpe3JldHVybiBuP25ldyBxYyh0LG4pOm5ldyB6Yyh0LDApfXJldHVybiBlLmFscGhhPWZ1bmN0aW9uKG4pe3JldHVybiB0KCtuKX0sZX0oLjUpO0RjLnByb3RvdHlwZT17YXJlYVN0YXJ0OndjLGFyZWFFbmQ6d2MsbGluZVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpe3RoaXMuX3BvaW50JiZ0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpfSxwb2ludDpmdW5jdGlvbih0LG4pe3Q9K3Qsbj0rbix0aGlzLl9wb2ludD90aGlzLl9jb250ZXh0LmxpbmVUbyh0LG4pOih0aGlzLl9wb2ludD0xLHRoaXMuX2NvbnRleHQubW92ZVRvKHQsbikpfX0sWWMucHJvdG90eXBlPXthcmVhU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPTB9LGFyZWFFbmQ6ZnVuY3Rpb24oKXt0aGlzLl9saW5lPU5hTn0sbGluZVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5feDA9dGhpcy5feDE9dGhpcy5feTA9dGhpcy5feTE9dGhpcy5fdDA9TmFOLHRoaXMuX3BvaW50PTB9LGxpbmVFbmQ6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5fcG9pbnQpe2Nhc2UgMjp0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSx0aGlzLl95MSk7YnJlYWs7Y2FzZSAzOkljKHRoaXMsdGhpcy5fdDAsRmModGhpcyx0aGlzLl90MCkpfSh0aGlzLl9saW5lfHwwIT09dGhpcy5fbGluZSYmMT09PXRoaXMuX3BvaW50KSYmdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSx0aGlzLl9saW5lPTEtdGhpcy5fbGluZX0scG9pbnQ6ZnVuY3Rpb24odCxuKXt2YXIgZT1OYU47aWYodD0rdCxuPStuLHQhPT10aGlzLl94MXx8biE9PXRoaXMuX3kxKXtzd2l0Y2godGhpcy5fcG9pbnQpe2Nhc2UgMDp0aGlzLl9wb2ludD0xLHRoaXMuX2xpbmU/dGhpcy5fY29udGV4dC5saW5lVG8odCxuKTp0aGlzLl9jb250ZXh0Lm1vdmVUbyh0LG4pO2JyZWFrO2Nhc2UgMTp0aGlzLl9wb2ludD0yO2JyZWFrO2Nhc2UgMjp0aGlzLl9wb2ludD0zLEljKHRoaXMsRmModGhpcyxlPU9jKHRoaXMsdCxuKSksZSk7YnJlYWs7ZGVmYXVsdDpJYyh0aGlzLHRoaXMuX3QwLGU9T2ModGhpcyx0LG4pKX10aGlzLl94MD10aGlzLl94MSx0aGlzLl94MT10LHRoaXMuX3kwPXRoaXMuX3kxLHRoaXMuX3kxPW4sdGhpcy5fdDA9ZX19fSwoQmMucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoWWMucHJvdG90eXBlKSkucG9pbnQ9ZnVuY3Rpb24odCxuKXtZYy5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLG4sdCl9LEhjLnByb3RvdHlwZT17bW92ZVRvOmZ1bmN0aW9uKHQsbil7dGhpcy5fY29udGV4dC5tb3ZlVG8obix0KX0sY2xvc2VQYXRoOmZ1bmN0aW9uKCl7dGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKX0sbGluZVRvOmZ1bmN0aW9uKHQsbil7dGhpcy5fY29udGV4dC5saW5lVG8obix0KX0sYmV6aWVyQ3VydmVUbzpmdW5jdGlvbih0LG4sZSxyLGksbyl7dGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKG4sdCxyLGUsbyxpKX19LGpjLnByb3RvdHlwZT17YXJlYVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5fbGluZT0wfSxhcmVhRW5kOmZ1bmN0aW9uKCl7dGhpcy5fbGluZT1OYU59LGxpbmVTdGFydDpmdW5jdGlvbigpe3RoaXMuX3g9W10sdGhpcy5feT1bXX0sbGluZUVuZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3gsbj10aGlzLl95LGU9dC5sZW5ndGg7aWYoZSlpZih0aGlzLl9saW5lP3RoaXMuX2NvbnRleHQubGluZVRvKHRbMF0sblswXSk6dGhpcy5fY29udGV4dC5tb3ZlVG8odFswXSxuWzBdKSwyPT09ZSl0aGlzLl9jb250ZXh0LmxpbmVUbyh0WzFdLG5bMV0pO2Vsc2UgZm9yKHZhciByPVhjKHQpLGk9WGMobiksbz0wLHU9MTt1PGU7KytvLCsrdSl0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oclswXVtvXSxpWzBdW29dLHJbMV1bb10saVsxXVtvXSx0W3VdLG5bdV0pOyh0aGlzLl9saW5lfHwwIT09dGhpcy5fbGluZSYmMT09PWUpJiZ0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLHRoaXMuX2xpbmU9MS10aGlzLl9saW5lLHRoaXMuX3g9dGhpcy5feT1udWxsfSxwb2ludDpmdW5jdGlvbih0LG4pe3RoaXMuX3gucHVzaCgrdCksdGhpcy5feS5wdXNoKCtuKX19LFZjLnByb3RvdHlwZT17YXJlYVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5fbGluZT0wfSxhcmVhRW5kOmZ1bmN0aW9uKCl7dGhpcy5fbGluZT1OYU59LGxpbmVTdGFydDpmdW5jdGlvbigpe3RoaXMuX3g9dGhpcy5feT1OYU4sdGhpcy5fcG9pbnQ9MH0sbGluZUVuZDpmdW5jdGlvbigpezA8dGhpcy5fdCYmdGhpcy5fdDwxJiYyPT09dGhpcy5fcG9pbnQmJnRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsdGhpcy5feSksKHRoaXMuX2xpbmV8fDAhPT10aGlzLl9saW5lJiYxPT09dGhpcy5fcG9pbnQpJiZ0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLHRoaXMuX2xpbmU+PTAmJih0aGlzLl90PTEtdGhpcy5fdCx0aGlzLl9saW5lPTEtdGhpcy5fbGluZSl9LHBvaW50OmZ1bmN0aW9uKHQsbil7c3dpdGNoKHQ9K3Qsbj0rbix0aGlzLl9wb2ludCl7Y2FzZSAwOnRoaXMuX3BvaW50PTEsdGhpcy5fbGluZT90aGlzLl9jb250ZXh0LmxpbmVUbyh0LG4pOnRoaXMuX2NvbnRleHQubW92ZVRvKHQsbik7YnJlYWs7Y2FzZSAxOnRoaXMuX3BvaW50PTI7ZGVmYXVsdDppZih0aGlzLl90PD0wKXRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsbiksdGhpcy5fY29udGV4dC5saW5lVG8odCxuKTtlbHNle3ZhciBlPXRoaXMuX3gqKDEtdGhpcy5fdCkrdCp0aGlzLl90O3RoaXMuX2NvbnRleHQubGluZVRvKGUsdGhpcy5feSksdGhpcy5fY29udGV4dC5saW5lVG8oZSxuKX19dGhpcy5feD10LHRoaXMuX3k9bn19LG5zLnByb3RvdHlwZT17Y29uc3RydWN0b3I6bnMsaW5zZXJ0OmZ1bmN0aW9uKHQsbil7dmFyIGUscixpO2lmKHQpe2lmKG4uUD10LG4uTj10Lk4sdC5OJiYodC5OLlA9biksdC5OPW4sdC5SKXtmb3IodD10LlI7dC5MOyl0PXQuTDt0Lkw9bn1lbHNlIHQuUj1uO2U9dH1lbHNlIHRoaXMuXz8odD1vcyh0aGlzLl8pLG4uUD1udWxsLG4uTj10LHQuUD10Lkw9bixlPXQpOihuLlA9bi5OPW51bGwsdGhpcy5fPW4sZT1udWxsKTtmb3Iobi5MPW4uUj1udWxsLG4uVT1lLG4uQz0hMCx0PW47ZSYmZS5DOyllPT09KHI9ZS5VKS5MPyhpPXIuUikmJmkuQz8oZS5DPWkuQz0hMSxyLkM9ITAsdD1yKToodD09PWUuUiYmKHJzKHRoaXMsZSksZT0odD1lKS5VKSxlLkM9ITEsci5DPSEwLGlzKHRoaXMscikpOihpPXIuTCkmJmkuQz8oZS5DPWkuQz0hMSxyLkM9ITAsdD1yKToodD09PWUuTCYmKGlzKHRoaXMsZSksZT0odD1lKS5VKSxlLkM9ITEsci5DPSEwLHJzKHRoaXMscikpLGU9dC5VO3RoaXMuXy5DPSExfSxyZW1vdmU6ZnVuY3Rpb24odCl7dC5OJiYodC5OLlA9dC5QKSx0LlAmJih0LlAuTj10Lk4pLHQuTj10LlA9bnVsbDt2YXIgbixlLHIsaT10LlUsbz10LkwsdT10LlI7aWYoZT1vP3U/b3ModSk6bzp1LGk/aS5MPT09dD9pLkw9ZTppLlI9ZTp0aGlzLl89ZSxvJiZ1PyhyPWUuQyxlLkM9dC5DLGUuTD1vLG8uVT1lLGUhPT11PyhpPWUuVSxlLlU9dC5VLHQ9ZS5SLGkuTD10LGUuUj11LHUuVT1lKTooZS5VPWksaT1lLHQ9ZS5SKSk6KHI9dC5DLHQ9ZSksdCYmKHQuVT1pKSwhcilpZih0JiZ0LkMpdC5DPSExO2Vsc2V7ZG97aWYodD09PXRoaXMuXylicmVhaztpZih0PT09aS5MKXtpZigobj1pLlIpLkMmJihuLkM9ITEsaS5DPSEwLHJzKHRoaXMsaSksbj1pLlIpLG4uTCYmbi5MLkN8fG4uUiYmbi5SLkMpe24uUiYmbi5SLkN8fChuLkwuQz0hMSxuLkM9ITAsaXModGhpcyxuKSxuPWkuUiksbi5DPWkuQyxpLkM9bi5SLkM9ITEscnModGhpcyxpKSx0PXRoaXMuXzticmVha319ZWxzZSBpZigobj1pLkwpLkMmJihuLkM9ITEsaS5DPSEwLGlzKHRoaXMsaSksbj1pLkwpLG4uTCYmbi5MLkN8fG4uUiYmbi5SLkMpe24uTCYmbi5MLkN8fChuLlIuQz0hMSxuLkM9ITAscnModGhpcyxuKSxuPWkuTCksbi5DPWkuQyxpLkM9bi5MLkM9ITEsaXModGhpcyxpKSx0PXRoaXMuXzticmVha31uLkM9ITAsdD1pLGk9aS5VfXdoaWxlKCF0LkMpO3QmJih0LkM9ITEpfX19O3ZhciBDXyx6XyxQXyxSXyxMXyxxXz1bXSxEXz1bXSxVXz0xZS02LE9fPTFlLTEyO01zLnByb3RvdHlwZT17Y29uc3RydWN0b3I6TXMscG9seWdvbnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVkZ2VzO3JldHVybiB0aGlzLmNlbGxzLm1hcChmdW5jdGlvbihuKXt2YXIgZT1uLmhhbGZlZGdlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGhzKG4sdFtlXSl9KTtyZXR1cm4gZS5kYXRhPW4uc2l0ZS5kYXRhLGV9KX0sdHJpYW5nbGVzOmZ1bmN0aW9uKCl7dmFyIHQ9W10sbj10aGlzLmVkZ2VzO3JldHVybiB0aGlzLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oZSxyKXtpZihvPShpPWUuaGFsZmVkZ2VzKS5sZW5ndGgpZm9yKHZhciBpLG8sdSxhPWUuc2l0ZSxjPS0xLHM9bltpW28tMV1dLGY9cy5sZWZ0PT09YT9zLnJpZ2h0OnMubGVmdDsrK2M8bzspdT1mLGY9KHM9bltpW2NdXSkubGVmdD09PWE/cy5yaWdodDpzLmxlZnQsdSYmZiYmcjx1LmluZGV4JiZyPGYuaW5kZXgmJmJzKGEsdSxmKTwwJiZ0LnB1c2goW2EuZGF0YSx1LmRhdGEsZi5kYXRhXSl9KSx0fSxsaW5rczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5yaWdodH0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm57c291cmNlOnQubGVmdC5kYXRhLHRhcmdldDp0LnJpZ2h0LmRhdGF9fSl9LGZpbmQ6ZnVuY3Rpb24odCxuLGUpe2Zvcih2YXIgcixpLG89dGhpcyx1PW8uX2ZvdW5kfHwwLGE9by5jZWxscy5sZW5ndGg7IShpPW8uY2VsbHNbdV0pOylpZigrK3U+PWEpcmV0dXJuIG51bGw7dmFyIGM9dC1pLnNpdGVbMF0scz1uLWkuc2l0ZVsxXSxmPWMqYytzKnM7ZG97aT1vLmNlbGxzW3I9dV0sdT1udWxsLGkuaGFsZmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9by5lZGdlc1tlXSxhPXIubGVmdDtpZihhIT09aS5zaXRlJiZhfHwoYT1yLnJpZ2h0KSl7dmFyIGM9dC1hWzBdLHM9bi1hWzFdLGw9YypjK3MqcztsPGYmJihmPWwsdT1hLmluZGV4KX19KX13aGlsZShudWxsIT09dSk7cmV0dXJuIG8uX2ZvdW5kPXIsbnVsbD09ZXx8Zjw9ZSplP2kuc2l0ZTpudWxsfX0sTnMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpOcyxzY2FsZTpmdW5jdGlvbih0KXtyZXR1cm4gMT09PXQ/dGhpczpuZXcgTnModGhpcy5rKnQsdGhpcy54LHRoaXMueSl9LHRyYW5zbGF0ZTpmdW5jdGlvbih0LG4pe3JldHVybiAwPT09dCYwPT09bj90aGlzOm5ldyBOcyh0aGlzLmssdGhpcy54K3RoaXMuayp0LHRoaXMueSt0aGlzLmsqbil9LGFwcGx5OmZ1bmN0aW9uKHQpe3JldHVyblt0WzBdKnRoaXMuayt0aGlzLngsdFsxXSp0aGlzLmsrdGhpcy55XX0sYXBwbHlYOmZ1bmN0aW9uKHQpe3JldHVybiB0KnRoaXMuayt0aGlzLnh9LGFwcGx5WTpmdW5jdGlvbih0KXtyZXR1cm4gdCp0aGlzLmsrdGhpcy55fSxpbnZlcnQ6ZnVuY3Rpb24odCl7cmV0dXJuWyh0WzBdLXRoaXMueCkvdGhpcy5rLCh0WzFdLXRoaXMueSkvdGhpcy5rXX0saW52ZXJ0WDpmdW5jdGlvbih0KXtyZXR1cm4odC10aGlzLngpL3RoaXMua30saW52ZXJ0WTpmdW5jdGlvbih0KXtyZXR1cm4odC10aGlzLnkpL3RoaXMua30scmVzY2FsZVg6ZnVuY3Rpb24odCl7cmV0dXJuIHQuY29weSgpLmRvbWFpbih0LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCx0aGlzKS5tYXAodC5pbnZlcnQsdCkpfSxyZXNjYWxlWTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jb3B5KCkuZG9tYWluKHQucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRZLHRoaXMpLm1hcCh0LmludmVydCx0KSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJ0cmFuc2xhdGUoXCIrdGhpcy54K1wiLFwiK3RoaXMueStcIikgc2NhbGUoXCIrdGhpcy5rK1wiKVwifX07dmFyIEZfPW5ldyBOcygxLDAsMCk7a3MucHJvdG90eXBlPU5zLnByb3RvdHlwZSx0LnZlcnNpb249XCI0LjEyLjJcIix0LmJpc2VjdD1Ecyx0LmJpc2VjdFJpZ2h0PURzLHQuYmlzZWN0TGVmdD1Vcyx0LmFzY2VuZGluZz1uLHQuYmlzZWN0b3I9ZSx0LmNyb3NzPWZ1bmN0aW9uKHQsbixlKXt2YXIgaSxvLHUsYSxjPXQubGVuZ3RoLHM9bi5sZW5ndGgsZj1uZXcgQXJyYXkoYypzKTtmb3IobnVsbD09ZSYmKGU9ciksaT11PTA7aTxjOysraSlmb3IoYT10W2ldLG89MDtvPHM7KytvLCsrdSlmW3VdPWUoYSxuW29dKTtyZXR1cm4gZn0sdC5kZXNjZW5kaW5nPWZ1bmN0aW9uKHQsbil7cmV0dXJuIG48dD8tMTpuPnQ/MTpuPj10PzA6TmFOfSx0LmRldmlhdGlvbj11LHQuZXh0ZW50PWEsdC5oaXN0b2dyYW09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBpLG8sdT10Lmxlbmd0aCxhPW5ldyBBcnJheSh1KTtmb3IoaT0wO2k8dTsrK2kpYVtpXT1uKHRbaV0saSx0KTt2YXIgYz1lKGEpLHM9Y1swXSxsPWNbMV0saD1yKGEscyxsKTtBcnJheS5pc0FycmF5KGgpfHwoaD1wKHMsbCxoKSxoPWYoTWF0aC5jZWlsKHMvaCkqaCxNYXRoLmZsb29yKGwvaCkqaCxoKSk7Zm9yKHZhciBkPWgubGVuZ3RoO2hbMF08PXM7KWguc2hpZnQoKSwtLWQ7Zm9yKDtoW2QtMV0+bDspaC5wb3AoKSwtLWQ7dmFyIHYsZz1uZXcgQXJyYXkoZCsxKTtmb3IoaT0wO2k8PWQ7KytpKSh2PWdbaV09W10pLngwPWk+MD9oW2ktMV06cyx2LngxPWk8ZD9oW2ldOmw7Zm9yKGk9MDtpPHU7KytpKXM8PShvPWFbaV0pJiZvPD1sJiZnW0RzKGgsbywwLGQpXS5wdXNoKHRbaV0pO3JldHVybiBnfXZhciBuPXMsZT1hLHI9ZDtyZXR1cm4gdC52YWx1ZT1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6YyhlKSx0KTpufSx0LmRvbWFpbj1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246YyhbblswXSxuWzFdXSksdCk6ZX0sdC50aHJlc2hvbGRzPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhyPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpBcnJheS5pc0FycmF5KG4pP2MoRnMuY2FsbChuKSk6YyhuKSx0KTpyfSx0fSx0LnRocmVzaG9sZEZyZWVkbWFuRGlhY29uaXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PUlzLmNhbGwodCxpKS5zb3J0KG4pLE1hdGguY2VpbCgoci1lKS8oMioodih0LC43NSktdih0LC4yNSkpKk1hdGgucG93KHQubGVuZ3RoLC0xLzMpKSl9LHQudGhyZXNob2xkU2NvdHQ9ZnVuY3Rpb24odCxuLGUpe3JldHVybiBNYXRoLmNlaWwoKGUtbikvKDMuNSp1KHQpKk1hdGgucG93KHQubGVuZ3RoLC0xLzMpKSl9LHQudGhyZXNob2xkU3R1cmdlcz1kLHQubWF4PWZ1bmN0aW9uKHQsbil7dmFyIGUscixpPXQubGVuZ3RoLG89LTE7aWYobnVsbD09bil7Zm9yKDsrK288aTspaWYobnVsbCE9KGU9dFtvXSkmJmU+PWUpZm9yKHI9ZTsrK288aTspbnVsbCE9KGU9dFtvXSkmJmU+ciYmKHI9ZSl9ZWxzZSBmb3IoOysrbzxpOylpZihudWxsIT0oZT1uKHRbb10sbyx0KSkmJmU+PWUpZm9yKHI9ZTsrK288aTspbnVsbCE9KGU9bih0W29dLG8sdCkpJiZlPnImJihyPWUpO3JldHVybiByfSx0Lm1lYW49ZnVuY3Rpb24odCxuKXt2YXIgZSxyPXQubGVuZ3RoLG89cix1PS0xLGE9MDtpZihudWxsPT1uKWZvcig7Kyt1PHI7KWlzTmFOKGU9aSh0W3VdKSk/LS1vOmErPWU7ZWxzZSBmb3IoOysrdTxyOylpc05hTihlPWkobih0W3VdLHUsdCkpKT8tLW86YSs9ZTtpZihvKXJldHVybiBhL299LHQubWVkaWFuPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbz10Lmxlbmd0aCx1PS0xLGE9W107aWYobnVsbD09ZSlmb3IoOysrdTxvOylpc05hTihyPWkodFt1XSkpfHxhLnB1c2gocik7ZWxzZSBmb3IoOysrdTxvOylpc05hTihyPWkoZSh0W3VdLHUsdCkpKXx8YS5wdXNoKHIpO3JldHVybiB2KGEuc29ydChuKSwuNSl9LHQubWVyZ2U9Zyx0Lm1pbj1fLHQucGFpcnM9ZnVuY3Rpb24odCxuKXtudWxsPT1uJiYobj1yKTtmb3IodmFyIGU9MCxpPXQubGVuZ3RoLTEsbz10WzBdLHU9bmV3IEFycmF5KGk8MD8wOmkpO2U8aTspdVtlXT1uKG8sbz10WysrZV0pO3JldHVybiB1fSx0LnBlcm11dGU9ZnVuY3Rpb24odCxuKXtmb3IodmFyIGU9bi5sZW5ndGgscj1uZXcgQXJyYXkoZSk7ZS0tOylyW2VdPXRbbltlXV07cmV0dXJuIHJ9LHQucXVhbnRpbGU9dix0LnJhbmdlPWYsdC5zY2FuPWZ1bmN0aW9uKHQsZSl7aWYocj10Lmxlbmd0aCl7dmFyIHIsaSxvPTAsdT0wLGE9dFt1XTtmb3IobnVsbD09ZSYmKGU9bik7KytvPHI7KShlKGk9dFtvXSxhKTwwfHwwIT09ZShhLGEpKSYmKGE9aSx1PW8pO3JldHVybiAwPT09ZShhLGEpP3U6dm9pZCAwfX0sdC5zaHVmZmxlPWZ1bmN0aW9uKHQsbixlKXtmb3IodmFyIHIsaSxvPShudWxsPT1lP3QubGVuZ3RoOmUpLShuPW51bGw9PW4/MDorbik7bzspaT1NYXRoLnJhbmRvbSgpKm8tLXwwLHI9dFtvK25dLHRbbytuXT10W2krbl0sdFtpK25dPXI7cmV0dXJuIHR9LHQuc3VtPWZ1bmN0aW9uKHQsbil7dmFyIGUscj10Lmxlbmd0aCxpPS0xLG89MDtpZihudWxsPT1uKWZvcig7KytpPHI7KShlPSt0W2ldKSYmKG8rPWUpO2Vsc2UgZm9yKDsrK2k8cjspKGU9K24odFtpXSxpLHQpKSYmKG8rPWUpO3JldHVybiBvfSx0LnRpY2tzPWwsdC50aWNrSW5jcmVtZW50PWgsdC50aWNrU3RlcD1wLHQudHJhbnNwb3NlPXksdC52YXJpYW5jZT1vLHQuemlwPWZ1bmN0aW9uKCl7cmV0dXJuIHkoYXJndW1lbnRzKX0sdC5heGlzVG9wPWZ1bmN0aW9uKHQpe3JldHVybiBUKFhzLHQpfSx0LmF4aXNSaWdodD1mdW5jdGlvbih0KXtyZXR1cm4gVChWcyx0KX0sdC5heGlzQm90dG9tPWZ1bmN0aW9uKHQpe3JldHVybiBUKCRzLHQpfSx0LmF4aXNMZWZ0PWZ1bmN0aW9uKHQpe3JldHVybiBUKFdzLHQpfSx0LmJydXNoPWZ1bmN0aW9uKCl7cmV0dXJuIFFuKHJoKX0sdC5icnVzaFg9ZnVuY3Rpb24oKXtyZXR1cm4gUW4obmgpfSx0LmJydXNoWT1mdW5jdGlvbigpe3JldHVybiBRbihlaCl9LHQuYnJ1c2hTZWxlY3Rpb249ZnVuY3Rpb24odCl7dmFyIG49dC5fX2JydXNoO3JldHVybiBuP24uZGltLm91dHB1dChuLnNlbGVjdGlvbik6bnVsbH0sdC5jaG9yZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIG8sdSxhLGMscyxsLGg9dC5sZW5ndGgscD1bXSxkPWYoaCksdj1bXSxnPVtdLF89Zy5ncm91cHM9bmV3IEFycmF5KGgpLHk9bmV3IEFycmF5KGgqaCk7Zm9yKG89MCxzPS0xOysrczxoOyl7Zm9yKHU9MCxsPS0xOysrbDxoOyl1Kz10W3NdW2xdO3AucHVzaCh1KSx2LnB1c2goZihoKSksbys9dX1mb3IoZSYmZC5zb3J0KGZ1bmN0aW9uKHQsbil7cmV0dXJuIGUocFt0XSxwW25dKX0pLHImJnYuZm9yRWFjaChmdW5jdGlvbihuLGUpe24uc29ydChmdW5jdGlvbihuLGkpe3JldHVybiByKHRbZV1bbl0sdFtlXVtpXSl9KX0pLGM9KG89ZGgoMCxwaC1uKmgpL28pP246cGgvaCx1PTAscz0tMTsrK3M8aDspe2ZvcihhPXUsbD0tMTsrK2w8aDspe3ZhciBtPWRbc10seD12W21dW2xdLGI9dFttXVt4XSx3PXUsTT11Kz1iKm87eVt4KmgrbV09e2luZGV4Om0sc3ViaW5kZXg6eCxzdGFydEFuZ2xlOncsZW5kQW5nbGU6TSx2YWx1ZTpifX1fW21dPXtpbmRleDptLHN0YXJ0QW5nbGU6YSxlbmRBbmdsZTp1LHZhbHVlOnBbbV19LHUrPWN9Zm9yKHM9LTE7KytzPGg7KWZvcihsPXMtMTsrK2w8aDspe3ZhciBUPXlbbCpoK3NdLE49eVtzKmgrbF07KFQudmFsdWV8fE4udmFsdWUpJiZnLnB1c2goVC52YWx1ZTxOLnZhbHVlP3tzb3VyY2U6Tix0YXJnZXQ6VH06e3NvdXJjZTpULHRhcmdldDpOfSl9cmV0dXJuIGk/Zy5zb3J0KGkpOmd9dmFyIG49MCxlPW51bGwscj1udWxsLGk9bnVsbDtyZXR1cm4gdC5wYWRBbmdsZT1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obj1kaCgwLGUpLHQpOm59LHQuc29ydEdyb3Vwcz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT1uLHQpOmV9LHQuc29ydFN1Ymdyb3Vwcz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocj1uLHQpOnJ9LHQuc29ydENob3Jkcz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obnVsbD09bj9pPW51bGw6KGk9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKG4sZSl7cmV0dXJuIHQobi5zb3VyY2UudmFsdWUrbi50YXJnZXQudmFsdWUsZS5zb3VyY2UudmFsdWUrZS50YXJnZXQudmFsdWUpfX0obikpLl89bix0KTppJiZpLl99LHR9LHQucmliYm9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciB0LGE9dmguY2FsbChhcmd1bWVudHMpLGM9bi5hcHBseSh0aGlzLGEpLHM9ZS5hcHBseSh0aGlzLGEpLGY9K3IuYXBwbHkodGhpcywoYVswXT1jLGEpKSxsPWkuYXBwbHkodGhpcyxhKS1oaCxoPW8uYXBwbHkodGhpcyxhKS1oaCxwPWYqc2gobCksZD1mKmZoKGwpLHY9K3IuYXBwbHkodGhpcywoYVswXT1zLGEpKSxnPWkuYXBwbHkodGhpcyxhKS1oaCxfPW8uYXBwbHkodGhpcyxhKS1oaDtpZih1fHwodT10PXRlKCkpLHUubW92ZVRvKHAsZCksdS5hcmMoMCwwLGYsbCxoKSxsPT09ZyYmaD09PV98fCh1LnF1YWRyYXRpY0N1cnZlVG8oMCwwLHYqc2goZyksdipmaChnKSksdS5hcmMoMCwwLHYsZyxfKSksdS5xdWFkcmF0aWNDdXJ2ZVRvKDAsMCxwLGQpLHUuY2xvc2VQYXRoKCksdClyZXR1cm4gdT1udWxsLHQrXCJcInx8bnVsbH12YXIgbj1uZSxlPWVlLHI9cmUsaT1pZSxvPW9lLHU9bnVsbDtyZXR1cm4gdC5yYWRpdXM9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOkpuKCtuKSx0KTpyfSx0LnN0YXJ0QW5nbGU9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOkpuKCtuKSx0KTppfSx0LmVuZEFuZ2xlPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhvPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpKbigrbiksdCk6b30sdC5zb3VyY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG49ZSx0KTpufSx0LnRhcmdldD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT1uLHQpOmV9LHQuY29udGV4dD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odT1udWxsPT1uP251bGw6bix0KTp1fSx0fSx0Lm5lc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4saSx1LGEpe2lmKGk+PW8ubGVuZ3RoKXJldHVybiBudWxsIT1lJiZuLnNvcnQoZSksbnVsbCE9cj9yKG4pOm47Zm9yKHZhciBjLHMsZixsPS0xLGg9bi5sZW5ndGgscD1vW2krK10sZD1hZSgpLHY9dSgpOysrbDxoOykoZj1kLmdldChjPXAocz1uW2xdKStcIlwiKSk/Zi5wdXNoKHMpOmQuc2V0KGMsW3NdKTtyZXR1cm4gZC5lYWNoKGZ1bmN0aW9uKG4sZSl7YSh2LGUsdChuLGksdSxhKSl9KSx2fWZ1bmN0aW9uIG4odCxlKXtpZigrK2U+by5sZW5ndGgpcmV0dXJuIHQ7dmFyIGksYT11W2UtMV07cmV0dXJuIG51bGwhPXImJmU+PW8ubGVuZ3RoP2k9dC5lbnRyaWVzKCk6KGk9W10sdC5lYWNoKGZ1bmN0aW9uKHQscil7aS5wdXNoKHtrZXk6cix2YWx1ZXM6bih0LGUpfSl9KSksbnVsbCE9YT9pLnNvcnQoZnVuY3Rpb24odCxuKXtyZXR1cm4gYSh0LmtleSxuLmtleSl9KTppfXZhciBlLHIsaSxvPVtdLHU9W107cmV0dXJuIGk9e29iamVjdDpmdW5jdGlvbihuKXtyZXR1cm4gdChuLDAsY2Usc2UpfSxtYXA6ZnVuY3Rpb24obil7cmV0dXJuIHQobiwwLGZlLGxlKX0sZW50cmllczpmdW5jdGlvbihlKXtyZXR1cm4gbih0KGUsMCxmZSxsZSksMCl9LGtleTpmdW5jdGlvbih0KXtyZXR1cm4gby5wdXNoKHQpLGl9LHNvcnRLZXlzOmZ1bmN0aW9uKHQpe3JldHVybiB1W28ubGVuZ3RoLTFdPXQsaX0sc29ydFZhbHVlczpmdW5jdGlvbih0KXtyZXR1cm4gZT10LGl9LHJvbGx1cDpmdW5jdGlvbih0KXtyZXR1cm4gcj10LGl9fX0sdC5zZXQ9cGUsdC5tYXA9YWUsdC5rZXlzPWZ1bmN0aW9uKHQpe3ZhciBuPVtdO2Zvcih2YXIgZSBpbiB0KW4ucHVzaChlKTtyZXR1cm4gbn0sdC52YWx1ZXM9ZnVuY3Rpb24odCl7dmFyIG49W107Zm9yKHZhciBlIGluIHQpbi5wdXNoKHRbZV0pO3JldHVybiBufSx0LmVudHJpZXM9ZnVuY3Rpb24odCl7dmFyIG49W107Zm9yKHZhciBlIGluIHQpbi5wdXNoKHtrZXk6ZSx2YWx1ZTp0W2VdfSk7cmV0dXJuIG59LHQuY29sb3I9a3QsdC5yZ2I9Q3QsdC5oc2w9UnQsdC5sYWI9VXQsdC5oY2w9SHQsdC5jdWJlaGVsaXg9WHQsdC5kaXNwYXRjaD1OLHQuZHJhZz1mdW5jdGlvbigpe2Z1bmN0aW9uIG4odCl7dC5vbihcIm1vdXNlZG93bi5kcmFnXCIsZSkuZmlsdGVyKGcpLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsbykub24oXCJ0b3VjaG1vdmUuZHJhZ1wiLHUpLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsYSkuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIixcIm5vbmVcIikuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIixcInJnYmEoMCwwLDAsMClcIil9ZnVuY3Rpb24gZSgpe2lmKCFoJiZwLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7dmFyIG49YyhcIm1vdXNlXCIsZC5hcHBseSh0aGlzLGFyZ3VtZW50cyksRix0aGlzLGFyZ3VtZW50cyk7biYmKGx0KHQuZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZ1wiLHIsITApLm9uKFwibW91c2V1cC5kcmFnXCIsaSwhMCksdnQodC5ldmVudC52aWV3KSxwdCgpLGw9ITEscz10LmV2ZW50LmNsaWVudFgsZj10LmV2ZW50LmNsaWVudFksbihcInN0YXJ0XCIpKX19ZnVuY3Rpb24gcigpe2lmKGR0KCksIWwpe3ZhciBuPXQuZXZlbnQuY2xpZW50WC1zLGU9dC5ldmVudC5jbGllbnRZLWY7bD1uKm4rZSplPnh9Xy5tb3VzZShcImRyYWdcIil9ZnVuY3Rpb24gaSgpe2x0KHQuZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIixudWxsKSxndCh0LmV2ZW50LnZpZXcsbCksZHQoKSxfLm1vdXNlKFwiZW5kXCIpfWZ1bmN0aW9uIG8oKXtpZihwLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7dmFyIG4sZSxyPXQuZXZlbnQuY2hhbmdlZFRvdWNoZXMsaT1kLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxvPXIubGVuZ3RoO2ZvcihuPTA7bjxvOysrbikoZT1jKHJbbl0uaWRlbnRpZmllcixpLGh0LHRoaXMsYXJndW1lbnRzKSkmJihwdCgpLGUoXCJzdGFydFwiKSl9fWZ1bmN0aW9uIHUoKXt2YXIgbixlLHI9dC5ldmVudC5jaGFuZ2VkVG91Y2hlcyxpPXIubGVuZ3RoO2ZvcihuPTA7bjxpOysrbikoZT1fW3Jbbl0uaWRlbnRpZmllcl0pJiYoZHQoKSxlKFwiZHJhZ1wiKSl9ZnVuY3Rpb24gYSgpe3ZhciBuLGUscj10LmV2ZW50LmNoYW5nZWRUb3VjaGVzLGk9ci5sZW5ndGg7Zm9yKGgmJmNsZWFyVGltZW91dChoKSxoPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtoPW51bGx9LDUwMCksbj0wO248aTsrK24pKGU9X1tyW25dLmlkZW50aWZpZXJdKSYmKHB0KCksZShcImVuZFwiKSl9ZnVuY3Rpb24gYyhlLHIsaSxvLHUpe3ZhciBhLGMscyxmPWkocixlKSxsPXkuY29weSgpO2lmKEQobmV3IHl0KG4sXCJiZWZvcmVzdGFydFwiLGEsZSxtLGZbMF0sZlsxXSwwLDAsbCksZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9KHQuZXZlbnQuc3ViamVjdD1hPXYuYXBwbHkobyx1KSkmJihjPWEueC1mWzBdfHwwLHM9YS55LWZbMV18fDAsITApfSkpcmV0dXJuIGZ1bmN0aW9uIHQoaCl7dmFyIHAsZD1mO3N3aXRjaChoKXtjYXNlXCJzdGFydFwiOl9bZV09dCxwPW0rKzticmVhaztjYXNlXCJlbmRcIjpkZWxldGUgX1tlXSwtLW07Y2FzZVwiZHJhZ1wiOmY9aShyLGUpLHA9bX1EKG5ldyB5dChuLGgsYSxlLHAsZlswXStjLGZbMV0rcyxmWzBdLWRbMF0sZlsxXS1kWzFdLGwpLGwuYXBwbHksbCxbaCxvLHVdKX19dmFyIHMsZixsLGgscD1tdCxkPXh0LHY9YnQsZz13dCxfPXt9LHk9TihcInN0YXJ0XCIsXCJkcmFnXCIsXCJlbmRcIiksbT0wLHg9MDtyZXR1cm4gbi5maWx0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHA9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90Ol90KCEhdCksbik6cH0sbi5jb250YWluZXI9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGQ9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90Ol90KHQpLG4pOmR9LG4uc3ViamVjdD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6X3QodCksbik6dn0sbi50b3VjaGFibGU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGc9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90Ol90KCEhdCksbik6Z30sbi5vbj1mdW5jdGlvbigpe3ZhciB0PXkub24uYXBwbHkoeSxhcmd1bWVudHMpO3JldHVybiB0PT09eT9uOnR9LG4uY2xpY2tEaXN0YW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oeD0odD0rdCkqdCxuKTpNYXRoLnNxcnQoeCl9LG59LHQuZHJhZ0Rpc2FibGU9dnQsdC5kcmFnRW5hYmxlPWd0LHQuZHN2Rm9ybWF0PXZlLHQuY3N2UGFyc2U9a2gsdC5jc3ZQYXJzZVJvd3M9U2gsdC5jc3ZGb3JtYXQ9RWgsdC5jc3ZGb3JtYXRSb3dzPUFoLHQudHN2UGFyc2U9emgsdC50c3ZQYXJzZVJvd3M9UGgsdC50c3ZGb3JtYXQ9UmgsdC50c3ZGb3JtYXRSb3dzPUxoLHQuZWFzZUxpbmVhcj1mdW5jdGlvbih0KXtyZXR1cm4rdH0sdC5lYXNlUXVhZD1Ebix0LmVhc2VRdWFkSW49ZnVuY3Rpb24odCl7cmV0dXJuIHQqdH0sdC5lYXNlUXVhZE91dD1mdW5jdGlvbih0KXtyZXR1cm4gdCooMi10KX0sdC5lYXNlUXVhZEluT3V0PURuLHQuZWFzZUN1YmljPVVuLHQuZWFzZUN1YmljSW49ZnVuY3Rpb24odCl7cmV0dXJuIHQqdCp0fSx0LmVhc2VDdWJpY091dD1mdW5jdGlvbih0KXtyZXR1cm4tLXQqdCp0KzF9LHQuZWFzZUN1YmljSW5PdXQ9VW4sdC5lYXNlUG9seT1BbCx0LmVhc2VQb2x5SW49U2wsdC5lYXNlUG9seU91dD1FbCx0LmVhc2VQb2x5SW5PdXQ9QWwsdC5lYXNlU2luPU9uLHQuZWFzZVNpbkluPWZ1bmN0aW9uKHQpe3JldHVybiAxLU1hdGguY29zKHQqemwpfSx0LmVhc2VTaW5PdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguc2luKHQqemwpfSx0LmVhc2VTaW5Jbk91dD1Pbix0LmVhc2VFeHA9Rm4sdC5lYXNlRXhwSW49ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDIsMTAqdC0xMCl9LHQuZWFzZUV4cE91dD1mdW5jdGlvbih0KXtyZXR1cm4gMS1NYXRoLnBvdygyLC0xMCp0KX0sdC5lYXNlRXhwSW5PdXQ9Rm4sdC5lYXNlQ2lyY2xlPUluLHQuZWFzZUNpcmNsZUluPWZ1bmN0aW9uKHQpe3JldHVybiAxLU1hdGguc3FydCgxLXQqdCl9LHQuZWFzZUNpcmNsZU91dD1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5zcXJ0KDEtIC0tdCp0KX0sdC5lYXNlQ2lyY2xlSW5PdXQ9SW4sdC5lYXNlQm91bmNlPVluLHQuZWFzZUJvdW5jZUluPWZ1bmN0aW9uKHQpe3JldHVybiAxLVluKDEtdCl9LHQuZWFzZUJvdW5jZU91dD1Zbix0LmVhc2VCb3VuY2VJbk91dD1mdW5jdGlvbih0KXtyZXR1cm4oKHQqPTIpPD0xPzEtWW4oMS10KTpZbih0LTEpKzEpLzJ9LHQuZWFzZUJhY2s9amwsdC5lYXNlQmFja0luPUJsLHQuZWFzZUJhY2tPdXQ9SGwsdC5lYXNlQmFja0luT3V0PWpsLHQuZWFzZUVsYXN0aWM9JGwsdC5lYXNlRWxhc3RpY0luPVZsLHQuZWFzZUVsYXN0aWNPdXQ9JGwsdC5lYXNlRWxhc3RpY0luT3V0PVdsLHQuZm9yY2VDZW50ZXI9ZnVuY3Rpb24odCxuKXtmdW5jdGlvbiBlKCl7dmFyIGUsaSxvPXIubGVuZ3RoLHU9MCxhPTA7Zm9yKGU9MDtlPG87KytlKXUrPShpPXJbZV0pLngsYSs9aS55O2Zvcih1PXUvby10LGE9YS9vLW4sZT0wO2U8bzsrK2UpKGk9cltlXSkueC09dSxpLnktPWF9dmFyIHI7cmV0dXJuIG51bGw9PXQmJih0PTApLG51bGw9PW4mJihuPTApLGUuaW5pdGlhbGl6ZT1mdW5jdGlvbih0KXtyPXR9LGUueD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odD0rbixlKTp0fSxlLnk9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG49K3QsZSk6bn0sZX0sdC5mb3JjZUNvbGxpZGU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbigpe2Zvcih2YXIgdCxuLHIsYyxzLGYsbCxoPWkubGVuZ3RoLHA9MDtwPGE7KytwKWZvcihuPXdlKGksTmUsa2UpLnZpc2l0QWZ0ZXIoZSksdD0wO3Q8aDsrK3Qpcj1pW3RdLGY9b1tyLmluZGV4XSxsPWYqZixjPXIueCtyLnZ4LHM9ci55K3Iudnksbi52aXNpdChmdW5jdGlvbih0LG4sZSxpLG8pe3ZhciBhPXQuZGF0YSxoPXQucixwPWYraDtpZighYSlyZXR1cm4gbj5jK3B8fGk8Yy1wfHxlPnMrcHx8bzxzLXA7aWYoYS5pbmRleD5yLmluZGV4KXt2YXIgZD1jLWEueC1hLnZ4LHY9cy1hLnktYS52eSxnPWQqZCt2KnY7ZzxwKnAmJigwPT09ZCYmKGQ9X2UoKSxnKz1kKmQpLDA9PT12JiYodj1fZSgpLGcrPXYqdiksZz0ocC0oZz1NYXRoLnNxcnQoZykpKS9nKnUsci52eCs9KGQqPWcpKihwPShoKj1oKS8obCtoKSksci52eSs9KHYqPWcpKnAsYS52eC09ZCoocD0xLXApLGEudnktPXYqcCl9fSl9ZnVuY3Rpb24gZSh0KXtpZih0LmRhdGEpcmV0dXJuIHQucj1vW3QuZGF0YS5pbmRleF07Zm9yKHZhciBuPXQucj0wO248NDsrK24pdFtuXSYmdFtuXS5yPnQuciYmKHQucj10W25dLnIpfWZ1bmN0aW9uIHIoKXtpZihpKXt2YXIgbixlLHI9aS5sZW5ndGg7Zm9yKG89bmV3IEFycmF5KHIpLG49MDtuPHI7KytuKWU9aVtuXSxvW2UuaW5kZXhdPSt0KGUsbixpKX19dmFyIGksbyx1PTEsYT0xO3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJih0PWdlKG51bGw9PXQ/MTordCkpLG4uaW5pdGlhbGl6ZT1mdW5jdGlvbih0KXtpPXQscigpfSxuLml0ZXJhdGlvbnM9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGE9K3Qsbik6YX0sbi5zdHJlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odT0rdCxuKTp1fSxuLnJhZGl1cz1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6Z2UoK2UpLHIoKSxuKTp0fSxufSx0LmZvcmNlTGluaz1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4pe2Zvcih2YXIgZT0wLHI9dC5sZW5ndGg7ZTxwOysrZSlmb3IodmFyIGksYSxjLGYsbCxoLGQsdj0wO3Y8cjsrK3YpYT0oaT10W3ZdKS5zb3VyY2UsZj0oYz1pLnRhcmdldCkueCtjLnZ4LWEueC1hLnZ4fHxfZSgpLGw9Yy55K2MudnktYS55LWEudnl8fF9lKCksZio9aD0oKGg9TWF0aC5zcXJ0KGYqZitsKmwpKS11W3ZdKS9oKm4qb1t2XSxsKj1oLGMudngtPWYqKGQ9c1t2XSksYy52eS09bCpkLGEudngrPWYqKGQ9MS1kKSxhLnZ5Kz1sKmR9ZnVuY3Rpb24gZSgpe2lmKGEpe3ZhciBuLGUsbD1hLmxlbmd0aCxoPXQubGVuZ3RoLHA9YWUoYSxmKTtmb3Iobj0wLGM9bmV3IEFycmF5KGwpO248aDsrK24pKGU9dFtuXSkuaW5kZXg9bixcIm9iamVjdFwiIT10eXBlb2YgZS5zb3VyY2UmJihlLnNvdXJjZT1FZShwLGUuc291cmNlKSksXCJvYmplY3RcIiE9dHlwZW9mIGUudGFyZ2V0JiYoZS50YXJnZXQ9RWUocCxlLnRhcmdldCkpLGNbZS5zb3VyY2UuaW5kZXhdPShjW2Uuc291cmNlLmluZGV4XXx8MCkrMSxjW2UudGFyZ2V0LmluZGV4XT0oY1tlLnRhcmdldC5pbmRleF18fDApKzE7Zm9yKG49MCxzPW5ldyBBcnJheShoKTtuPGg7KytuKWU9dFtuXSxzW25dPWNbZS5zb3VyY2UuaW5kZXhdLyhjW2Uuc291cmNlLmluZGV4XStjW2UudGFyZ2V0LmluZGV4XSk7bz1uZXcgQXJyYXkoaCkscigpLHU9bmV3IEFycmF5KGgpLGkoKX19ZnVuY3Rpb24gcigpe2lmKGEpZm9yKHZhciBuPTAsZT10Lmxlbmd0aDtuPGU7KytuKW9bbl09K2wodFtuXSxuLHQpfWZ1bmN0aW9uIGkoKXtpZihhKWZvcih2YXIgbj0wLGU9dC5sZW5ndGg7bjxlOysrbil1W25dPStoKHRbbl0sbix0KX12YXIgbyx1LGEsYyxzLGY9U2UsbD1mdW5jdGlvbih0KXtyZXR1cm4gMS9NYXRoLm1pbihjW3Quc291cmNlLmluZGV4XSxjW3QudGFyZ2V0LmluZGV4XSl9LGg9Z2UoMzApLHA9MTtyZXR1cm4gbnVsbD09dCYmKHQ9W10pLG4uaW5pdGlhbGl6ZT1mdW5jdGlvbih0KXthPXQsZSgpfSxuLmxpbmtzPWZ1bmN0aW9uKHIpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0PXIsZSgpLG4pOnR9LG4uaWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGY9dCxuKTpmfSxuLml0ZXJhdGlvbnM9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHA9K3Qsbik6cH0sbi5zdHJlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6Z2UoK3QpLHIoKSxuKTpsfSxuLmRpc3RhbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhoPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpnZSgrdCksaSgpLG4pOmh9LG59LHQuZm9yY2VNYW55Qm9keT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIG4sYT1pLmxlbmd0aCxjPXdlKGksQWUsQ2UpLnZpc2l0QWZ0ZXIoZSk7Zm9yKHU9dCxuPTA7bjxhOysrbilvPWlbbl0sYy52aXNpdChyKX1mdW5jdGlvbiBuKCl7aWYoaSl7dmFyIHQsbixlPWkubGVuZ3RoO2ZvcihhPW5ldyBBcnJheShlKSx0PTA7dDxlOysrdCluPWlbdF0sYVtuLmluZGV4XT0rYyhuLHQsaSl9fWZ1bmN0aW9uIGUodCl7dmFyIG4sZSxyLGksbyx1PTAsYz0wO2lmKHQubGVuZ3RoKXtmb3Iocj1pPW89MDtvPDQ7KytvKShuPXRbb10pJiYoZT1NYXRoLmFicyhuLnZhbHVlKSkmJih1Kz1uLnZhbHVlLGMrPWUscis9ZSpuLngsaSs9ZSpuLnkpO3QueD1yL2MsdC55PWkvY31lbHNleyhuPXQpLng9bi5kYXRhLngsbi55PW4uZGF0YS55O2Rve3UrPWFbbi5kYXRhLmluZGV4XX13aGlsZShuPW4ubmV4dCl9dC52YWx1ZT11fWZ1bmN0aW9uIHIodCxuLGUscil7aWYoIXQudmFsdWUpcmV0dXJuITA7dmFyIGk9dC54LW8ueCxjPXQueS1vLnksaD1yLW4scD1pKmkrYypjO2lmKGgqaC9sPHApcmV0dXJuIHA8ZiYmKDA9PT1pJiYoaT1fZSgpLHArPWkqaSksMD09PWMmJihjPV9lKCkscCs9YypjKSxwPHMmJihwPU1hdGguc3FydChzKnApKSxvLnZ4Kz1pKnQudmFsdWUqdS9wLG8udnkrPWMqdC52YWx1ZSp1L3ApLCEwO2lmKCEodC5sZW5ndGh8fHA+PWYpKXsodC5kYXRhIT09b3x8dC5uZXh0KSYmKDA9PT1pJiYoaT1fZSgpLHArPWkqaSksMD09PWMmJihjPV9lKCkscCs9YypjKSxwPHMmJihwPU1hdGguc3FydChzKnApKSk7ZG97dC5kYXRhIT09byYmKGg9YVt0LmRhdGEuaW5kZXhdKnUvcCxvLnZ4Kz1pKmgsby52eSs9YypoKX13aGlsZSh0PXQubmV4dCl9fXZhciBpLG8sdSxhLGM9Z2UoLTMwKSxzPTEsZj0xLzAsbD0uODE7cmV0dXJuIHQuaW5pdGlhbGl6ZT1mdW5jdGlvbih0KXtpPXQsbigpfSx0LnN0cmVuZ3RoPWZ1bmN0aW9uKGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhjPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZTpnZSgrZSksbigpLHQpOmN9LHQuZGlzdGFuY2VNaW49ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHM9bipuLHQpOk1hdGguc3FydChzKX0sdC5kaXN0YW5jZU1heD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZj1uKm4sdCk6TWF0aC5zcXJ0KGYpfSx0LnRoZXRhPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhsPW4qbix0KTpNYXRoLnNxcnQobCl9LHR9LHQuZm9yY2VSYWRpYWw9ZnVuY3Rpb24odCxuLGUpe2Z1bmN0aW9uIHIodCl7Zm9yKHZhciByPTAsaT1vLmxlbmd0aDtyPGk7KytyKXt2YXIgYz1vW3JdLHM9Yy54LW58fDFlLTYsZj1jLnktZXx8MWUtNixsPU1hdGguc3FydChzKnMrZipmKSxoPShhW3JdLWwpKnVbcl0qdC9sO2MudngrPXMqaCxjLnZ5Kz1mKmh9fWZ1bmN0aW9uIGkoKXtpZihvKXt2YXIgbixlPW8ubGVuZ3RoO2Zvcih1PW5ldyBBcnJheShlKSxhPW5ldyBBcnJheShlKSxuPTA7bjxlOysrbilhW25dPSt0KG9bbl0sbixvKSx1W25dPWlzTmFOKGFbbl0pPzA6K2Mob1tuXSxuLG8pfX12YXIgbyx1LGEsYz1nZSguMSk7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmKHQ9Z2UoK3QpKSxudWxsPT1uJiYobj0wKSxudWxsPT1lJiYoZT0wKSxyLmluaXRpYWxpemU9ZnVuY3Rpb24odCl7bz10LGkoKX0sci5zdHJlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6Z2UoK3QpLGkoKSxyKTpjfSxyLnJhZGl1cz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246Z2UoK24pLGkoKSxyKTp0fSxyLng9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG49K3Qscik6bn0sci55PWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPSt0LHIpOmV9LHJ9LHQuZm9yY2VTaW11bGF0aW9uPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oKXtlKCkscC5jYWxsKFwidGlja1wiLG8pLHU8YSYmKGguc3RvcCgpLHAuY2FsbChcImVuZFwiLG8pKX1mdW5jdGlvbiBlKCl7dmFyIG4sZSxyPXQubGVuZ3RoO2Zvcih1Kz0ocy11KSpjLGwuZWFjaChmdW5jdGlvbih0KXt0KHUpfSksbj0wO248cjsrK24pbnVsbD09KGU9dFtuXSkuZng/ZS54Kz1lLnZ4Kj1mOihlLng9ZS5meCxlLnZ4PTApLG51bGw9PWUuZnk/ZS55Kz1lLnZ5Kj1mOihlLnk9ZS5meSxlLnZ5PTApfWZ1bmN0aW9uIHIoKXtmb3IodmFyIG4sZT0wLHI9dC5sZW5ndGg7ZTxyOysrZSl7aWYobj10W2VdLG4uaW5kZXg9ZSxpc05hTihuLngpfHxpc05hTihuLnkpKXt2YXIgaT1VaCpNYXRoLnNxcnQoZSksbz1lKk9oO24ueD1pKk1hdGguY29zKG8pLG4ueT1pKk1hdGguc2luKG8pfShpc05hTihuLnZ4KXx8aXNOYU4obi52eSkpJiYobi52eD1uLnZ5PTApfX1mdW5jdGlvbiBpKG4pe3JldHVybiBuLmluaXRpYWxpemUmJm4uaW5pdGlhbGl6ZSh0KSxufXZhciBvLHU9MSxhPS4wMDEsYz0xLU1hdGgucG93KGEsMS8zMDApLHM9MCxmPS42LGw9YWUoKSxoPXhuKG4pLHA9TihcInRpY2tcIixcImVuZFwiKTtyZXR1cm4gbnVsbD09dCYmKHQ9W10pLHIoKSxvPXt0aWNrOmUscmVzdGFydDpmdW5jdGlvbigpe3JldHVybiBoLnJlc3RhcnQobiksb30sc3RvcDpmdW5jdGlvbigpe3JldHVybiBoLnN0b3AoKSxvfSxub2RlczpmdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odD1uLHIoKSxsLmVhY2goaSksbyk6dH0sYWxwaGE6ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHU9K3Qsbyk6dX0sYWxwaGFNaW46ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGE9K3Qsbyk6YX0sYWxwaGFEZWNheTpmdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYz0rdCxvKTorY30sYWxwaGFUYXJnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHM9K3Qsbyk6c30sdmVsb2NpdHlEZWNheTpmdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZj0xLXQsbyk6MS1mfSxmb3JjZTpmdW5jdGlvbih0LG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjE/KG51bGw9PW4/bC5yZW1vdmUodCk6bC5zZXQodCxpKG4pKSxvKTpsLmdldCh0KX0sZmluZDpmdW5jdGlvbihuLGUscil7dmFyIGksbyx1LGEsYyxzPTAsZj10Lmxlbmd0aDtmb3IobnVsbD09cj9yPTEvMDpyKj1yLHM9MDtzPGY7KytzKSh1PShpPW4tKGE9dFtzXSkueCkqaSsobz1lLWEueSkqbyk8ciYmKGM9YSxyPXUpO3JldHVybiBjfSxvbjpmdW5jdGlvbih0LG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjE/KHAub24odCxuKSxvKTpwLm9uKHQpfX19LHQuZm9yY2VYPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4odCl7Zm9yKHZhciBuLGU9MCx1PXIubGVuZ3RoO2U8dTsrK2UpKG49cltlXSkudngrPShvW2VdLW4ueCkqaVtlXSp0fWZ1bmN0aW9uIGUoKXtpZihyKXt2YXIgbixlPXIubGVuZ3RoO2ZvcihpPW5ldyBBcnJheShlKSxvPW5ldyBBcnJheShlKSxuPTA7bjxlOysrbilpW25dPWlzTmFOKG9bbl09K3QocltuXSxuLHIpKT8wOit1KHJbbl0sbixyKX19dmFyIHIsaSxvLHU9Z2UoLjEpO3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJih0PWdlKG51bGw9PXQ/MDordCkpLG4uaW5pdGlhbGl6ZT1mdW5jdGlvbih0KXtyPXQsZSgpfSxuLnN0cmVuZ3RoPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpnZSgrdCksZSgpLG4pOnV9LG4ueD1mdW5jdGlvbihyKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP3I6Z2UoK3IpLGUoKSxuKTp0fSxufSx0LmZvcmNlWT1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKHQpe2Zvcih2YXIgbixlPTAsdT1yLmxlbmd0aDtlPHU7KytlKShuPXJbZV0pLnZ5Kz0ob1tlXS1uLnkpKmlbZV0qdH1mdW5jdGlvbiBlKCl7aWYocil7dmFyIG4sZT1yLmxlbmd0aDtmb3IoaT1uZXcgQXJyYXkoZSksbz1uZXcgQXJyYXkoZSksbj0wO248ZTsrK24paVtuXT1pc05hTihvW25dPSt0KHJbbl0sbixyKSk/MDordShyW25dLG4scil9fXZhciByLGksbyx1PWdlKC4xKTtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiYodD1nZShudWxsPT10PzA6K3QpKSxuLmluaXRpYWxpemU9ZnVuY3Rpb24odCl7cj10LGUoKX0sbi5zdHJlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6Z2UoK3QpLGUoKSxuKTp1fSxuLnk9ZnVuY3Rpb24ocil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHQ9XCJmdW5jdGlvblwiPT10eXBlb2Ygcj9yOmdlKCtyKSxlKCksbik6dH0sbn0sdC5mb3JtYXREZWZhdWx0TG9jYWxlPU9lLHQuZm9ybWF0TG9jYWxlPVVlLHQuZm9ybWF0U3BlY2lmaWVyPUxlLHQucHJlY2lzaW9uRml4ZWQ9RmUsdC5wcmVjaXNpb25QcmVmaXg9SWUsdC5wcmVjaXNpb25Sb3VuZD1ZZSx0Lmdlb0FyZWE9ZnVuY3Rpb24odCl7cmV0dXJuIGpwLnJlc2V0KCksSmUodCxYcCksMipqcH0sdC5nZW9Cb3VuZHM9ZnVuY3Rpb24odCl7dmFyIG4sZSxyLGksbyx1LGE7aWYoUWg9R2g9LShXaD1aaD0xLzApLGVwPVtdLEplKHQsJHApLGU9ZXAubGVuZ3RoKXtmb3IoZXAuc29ydCh5ciksbj0xLG89W3I9ZXBbMF1dO248ZTsrK24pbXIociwoaT1lcFtuXSlbMF0pfHxtcihyLGlbMV0pPyhfcihyWzBdLGlbMV0pPl9yKHJbMF0sclsxXSkmJihyWzFdPWlbMV0pLF9yKGlbMF0sclsxXSk+X3IoclswXSxyWzFdKSYmKHJbMF09aVswXSkpOm8ucHVzaChyPWkpO2Zvcih1PS0xLzAsbj0wLHI9b1tlPW8ubGVuZ3RoLTFdO248PWU7cj1pLCsrbilpPW9bbl0sKGE9X3IoclsxXSxpWzBdKSk+dSYmKHU9YSxXaD1pWzBdLEdoPXJbMV0pfXJldHVybiBlcD1ycD1udWxsLFdoPT09MS8wfHxaaD09PTEvMD9bW05hTixOYU5dLFtOYU4sTmFOXV06W1tXaCxaaF0sW0doLFFoXV19LHQuZ2VvQ2VudHJvaWQ9ZnVuY3Rpb24odCl7aXA9b3A9dXA9YXA9Y3A9c3A9ZnA9bHA9aHA9cHA9ZHA9MCxKZSh0LFdwKTt2YXIgbj1ocCxlPXBwLHI9ZHAsaT1uKm4rZSplK3IqcjtyZXR1cm4gaTx3cCYmKG49c3AsZT1mcCxyPWxwLG9wPGJwJiYobj11cCxlPWFwLHI9Y3ApLChpPW4qbitlKmUrcipyKTx3cCk/W05hTixOYU5dOlt6cChlLG4pKlNwLFZlKHIvRnAoaSkpKlNwXX0sdC5nZW9DaXJjbGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dmFyIHQ9ci5hcHBseSh0aGlzLGFyZ3VtZW50cyksYT1pLmFwcGx5KHRoaXMsYXJndW1lbnRzKSpFcCxjPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpKkVwO3JldHVybiBuPVtdLGU9UnIoLXRbMF0qRXAsLXRbMV0qRXAsMCkuaW52ZXJ0LE9yKHUsYSxjLDEpLHQ9e3R5cGU6XCJQb2x5Z29uXCIsY29vcmRpbmF0ZXM6W25dfSxuPWU9bnVsbCx0fXZhciBuLGUscj1DcihbMCwwXSksaT1Dcig5MCksbz1Dcig2KSx1PXtwb2ludDpmdW5jdGlvbih0LHIpe24ucHVzaCh0PWUodCxyKSksdFswXSo9U3AsdFsxXSo9U3B9fTtyZXR1cm4gdC5jZW50ZXI9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOkNyKFsrblswXSwrblsxXV0pLHQpOnJ9LHQucmFkaXVzPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpDcigrbiksdCk6aX0sdC5wcmVjaXNpb249ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG89XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOkNyKCtuKSx0KTpvfSx0fSx0Lmdlb0NsaXBBbnRpbWVyaWRpYW49YWQsdC5nZW9DbGlwQ2lyY2xlPVpyLHQuZ2VvQ2xpcEV4dGVudD1mdW5jdGlvbigpe3ZhciB0LG4sZSxyPTAsaT0wLG89OTYwLHU9NTAwO3JldHVybiBlPXtzdHJlYW06ZnVuY3Rpb24oZSl7cmV0dXJuIHQmJm49PT1lP3Q6dD1HcihyLGksbyx1KShuPWUpfSxleHRlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9K2FbMF1bMF0saT0rYVswXVsxXSxvPSthWzFdWzBdLHU9K2FbMV1bMV0sdD1uPW51bGwsZSk6W1tyLGldLFtvLHVdXX19fSx0Lmdlb0NsaXBSZWN0YW5nbGU9R3IsdC5nZW9Db250YWlucz1mdW5jdGlvbih0LG4pe3JldHVybih0JiZkZC5oYXNPd25Qcm9wZXJ0eSh0LnR5cGUpP2RkW3QudHlwZV06ZWkpKHQsbil9LHQuZ2VvRGlzdGFuY2U9bmksdC5nZW9HcmF0aWN1bGU9ZmksdC5nZW9HcmF0aWN1bGUxMD1mdW5jdGlvbigpe3JldHVybiBmaSgpKCl9LHQuZ2VvSW50ZXJwb2xhdGU9ZnVuY3Rpb24odCxuKXt2YXIgZT10WzBdKkVwLHI9dFsxXSpFcCxpPW5bMF0qRXAsbz1uWzFdKkVwLHU9UHAociksYT1VcChyKSxjPVBwKG8pLHM9VXAobyksZj11KlBwKGUpLGw9dSpVcChlKSxoPWMqUHAoaSkscD1jKlVwKGkpLGQ9MipWZShGcCgkZShvLXIpK3UqYyokZShpLWUpKSksdj1VcChkKSxnPWQ/ZnVuY3Rpb24odCl7dmFyIG49VXAodCo9ZCkvdixlPVVwKGQtdCkvdixyPWUqZituKmgsaT1lKmwrbipwLG89ZSphK24qcztyZXR1cm5benAoaSxyKSpTcCx6cChvLEZwKHIqcitpKmkpKSpTcF19OmZ1bmN0aW9uKCl7cmV0dXJuW2UqU3AscipTcF19O3JldHVybiBnLmRpc3RhbmNlPWQsZ30sdC5nZW9MZW5ndGg9dGksdC5nZW9QYXRoPWZ1bmN0aW9uKHQsbil7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gdCYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8mJmkucG9pbnRSYWRpdXMoK28uYXBwbHkodGhpcyxhcmd1bWVudHMpKSxKZSh0LHIoaSkpKSxpLnJlc3VsdCgpfXZhciByLGksbz00LjU7cmV0dXJuIGUuYXJlYT1mdW5jdGlvbih0KXtyZXR1cm4gSmUodCxyKHlkKSkseWQucmVzdWx0KCl9LGUubWVhc3VyZT1mdW5jdGlvbih0KXtyZXR1cm4gSmUodCxyKElkKSksSWQucmVzdWx0KCl9LGUuYm91bmRzPWZ1bmN0aW9uKHQpe3JldHVybiBKZSh0LHIoTWQpKSxNZC5yZXN1bHQoKX0sZS5jZW50cm9pZD1mdW5jdGlvbih0KXtyZXR1cm4gSmUodCxyKFJkKSksUmQucmVzdWx0KCl9LGUucHJvamVjdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocj1udWxsPT1uPyh0PW51bGwsbGkpOih0PW4pLnN0cmVhbSxlKTp0fSxlLmNvbnRleHQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9bnVsbD09dD8obj1udWxsLG5ldyBFaSk6bmV3IE5pKG49dCksXCJmdW5jdGlvblwiIT10eXBlb2YgbyYmaS5wb2ludFJhZGl1cyhvKSxlKTpufSxlLnBvaW50UmFkaXVzPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhvPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDooaS5wb2ludFJhZGl1cygrdCksK3QpLGUpOm99LGUucHJvamVjdGlvbih0KS5jb250ZXh0KG4pfSx0Lmdlb0FsYmVycz1IaSx0Lmdlb0FsYmVyc1VzYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIG49dFswXSxlPXRbMV07cmV0dXJuIGE9bnVsbCxpLnBvaW50KG4sZSksYXx8KG8ucG9pbnQobixlKSxhKXx8KHUucG9pbnQobixlKSxhKX1mdW5jdGlvbiBuKCl7cmV0dXJuIGU9cj1udWxsLHR9dmFyIGUscixpLG8sdSxhLGM9SGkoKSxzPUJpKCkucm90YXRlKFsxNTQsMF0pLmNlbnRlcihbLTIsNTguNV0pLnBhcmFsbGVscyhbNTUsNjVdKSxmPUJpKCkucm90YXRlKFsxNTcsMF0pLmNlbnRlcihbLTMsMTkuOV0pLnBhcmFsbGVscyhbOCwxOF0pLGw9e3BvaW50OmZ1bmN0aW9uKHQsbil7YT1bdCxuXX19O3JldHVybiB0LmludmVydD1mdW5jdGlvbih0KXt2YXIgbj1jLnNjYWxlKCksZT1jLnRyYW5zbGF0ZSgpLHI9KHRbMF0tZVswXSkvbixpPSh0WzFdLWVbMV0pL247cmV0dXJuKGk+PS4xMiYmaTwuMjM0JiZyPj0tLjQyNSYmcjwtLjIxND9zOmk+PS4xNjYmJmk8LjIzNCYmcj49LS4yMTQmJnI8LS4xMTU/ZjpjKS5pbnZlcnQodCl9LHQuc3RyZWFtPWZ1bmN0aW9uKHQpe3JldHVybiBlJiZyPT09dD9lOmU9ZnVuY3Rpb24odCl7dmFyIG49dC5sZW5ndGg7cmV0dXJue3BvaW50OmZ1bmN0aW9uKGUscil7Zm9yKHZhciBpPS0xOysraTxuOyl0W2ldLnBvaW50KGUscil9LHNwaGVyZTpmdW5jdGlvbigpe2Zvcih2YXIgZT0tMTsrK2U8bjspdFtlXS5zcGhlcmUoKX0sbGluZVN0YXJ0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPS0xOysrZTxuOyl0W2VdLmxpbmVTdGFydCgpfSxsaW5lRW5kOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPS0xOysrZTxuOyl0W2VdLmxpbmVFbmQoKX0scG9seWdvblN0YXJ0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPS0xOysrZTxuOyl0W2VdLnBvbHlnb25TdGFydCgpfSxwb2x5Z29uRW5kOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPS0xOysrZTxuOyl0W2VdLnBvbHlnb25FbmQoKX19fShbYy5zdHJlYW0ocj10KSxzLnN0cmVhbSh0KSxmLnN0cmVhbSh0KV0pfSx0LnByZWNpc2lvbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYy5wcmVjaXNpb24odCkscy5wcmVjaXNpb24odCksZi5wcmVjaXNpb24odCksbigpKTpjLnByZWNpc2lvbigpfSx0LnNjYWxlPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhjLnNjYWxlKG4pLHMuc2NhbGUoLjM1Km4pLGYuc2NhbGUobiksdC50cmFuc2xhdGUoYy50cmFuc2xhdGUoKSkpOmMuc2NhbGUoKX0sdC50cmFuc2xhdGU9ZnVuY3Rpb24odCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGMudHJhbnNsYXRlKCk7dmFyIGU9Yy5zY2FsZSgpLHI9K3RbMF0sYT0rdFsxXTtyZXR1cm4gaT1jLnRyYW5zbGF0ZSh0KS5jbGlwRXh0ZW50KFtbci0uNDU1KmUsYS0uMjM4KmVdLFtyKy40NTUqZSxhKy4yMzgqZV1dKS5zdHJlYW0obCksbz1zLnRyYW5zbGF0ZShbci0uMzA3KmUsYSsuMjAxKmVdKS5jbGlwRXh0ZW50KFtbci0uNDI1KmUrYnAsYSsuMTIqZSticF0sW3ItLjIxNCplLWJwLGErLjIzNCplLWJwXV0pLnN0cmVhbShsKSx1PWYudHJhbnNsYXRlKFtyLS4yMDUqZSxhKy4yMTIqZV0pLmNsaXBFeHRlbnQoW1tyLS4yMTQqZSticCxhKy4xNjYqZSticF0sW3ItLjExNSplLWJwLGErLjIzNCplLWJwXV0pLnN0cmVhbShsKSxuKCl9LHQuZml0RXh0ZW50PWZ1bmN0aW9uKG4sZSl7cmV0dXJuIFJpKHQsbixlKX0sdC5maXRTaXplPWZ1bmN0aW9uKG4sZSl7cmV0dXJuIExpKHQsbixlKX0sdC5maXRXaWR0aD1mdW5jdGlvbihuLGUpe3JldHVybiBxaSh0LG4sZSl9LHQuZml0SGVpZ2h0PWZ1bmN0aW9uKG4sZSl7cmV0dXJuIERpKHQsbixlKX0sdC5zY2FsZSgxMDcwKX0sdC5nZW9BemltdXRoYWxFcXVhbEFyZWE9ZnVuY3Rpb24oKXtyZXR1cm4gT2koamQpLnNjYWxlKDEyNC43NSkuY2xpcEFuZ2xlKDE3OS45OTkpfSx0Lmdlb0F6aW11dGhhbEVxdWFsQXJlYVJhdz1qZCx0Lmdlb0F6aW11dGhhbEVxdWlkaXN0YW50PWZ1bmN0aW9uKCl7cmV0dXJuIE9pKFhkKS5zY2FsZSg3OS40MTg4KS5jbGlwQW5nbGUoMTc5Ljk5OSl9LHQuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXc9WGQsdC5nZW9Db25pY0NvbmZvcm1hbD1mdW5jdGlvbigpe3JldHVybiBJaShaaSkuc2NhbGUoMTA5LjUpLnBhcmFsbGVscyhbMzAsMzBdKX0sdC5nZW9Db25pY0NvbmZvcm1hbFJhdz1aaSx0Lmdlb0NvbmljRXF1YWxBcmVhPUJpLHQuZ2VvQ29uaWNFcXVhbEFyZWFSYXc9WWksdC5nZW9Db25pY0VxdWlkaXN0YW50PWZ1bmN0aW9uKCl7cmV0dXJuIElpKFFpKS5zY2FsZSgxMzEuMTU0KS5jZW50ZXIoWzAsMTMuOTM4OV0pfSx0Lmdlb0NvbmljRXF1aWRpc3RhbnRSYXc9UWksdC5nZW9FcXVpcmVjdGFuZ3VsYXI9ZnVuY3Rpb24oKXtyZXR1cm4gT2koR2kpLnNjYWxlKDE1Mi42Myl9LHQuZ2VvRXF1aXJlY3Rhbmd1bGFyUmF3PUdpLHQuZ2VvR25vbW9uaWM9ZnVuY3Rpb24oKXtyZXR1cm4gT2koSmkpLnNjYWxlKDE0NC4wNDkpLmNsaXBBbmdsZSg2MCl9LHQuZ2VvR25vbW9uaWNSYXc9SmksdC5nZW9JZGVudGl0eT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gaT1vPW51bGwsdX12YXIgbixlLHIsaSxvLHUsYT0xLGM9MCxzPTAsZj0xLGw9MSxoPWxpLHA9bnVsbCxkPWxpO3JldHVybiB1PXtzdHJlYW06ZnVuY3Rpb24odCl7cmV0dXJuIGkmJm89PT10P2k6aT1oKGQobz10KSl9LHBvc3RjbGlwOmZ1bmN0aW9uKGkpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhkPWkscD1uPWU9cj1udWxsLHQoKSk6ZH0sY2xpcEV4dGVudDpmdW5jdGlvbihpKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZD1udWxsPT1pPyhwPW49ZT1yPW51bGwsbGkpOkdyKHA9K2lbMF1bMF0sbj0raVswXVsxXSxlPStpWzFdWzBdLHI9K2lbMV1bMV0pLHQoKSk6bnVsbD09cD9udWxsOltbcCxuXSxbZSxyXV19LHNjYWxlOmZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhoPUtpKChhPStuKSpmLGEqbCxjLHMpLHQoKSk6YX0sdHJhbnNsYXRlOmZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhoPUtpKGEqZixhKmwsYz0rblswXSxzPStuWzFdKSx0KCkpOltjLHNdfSxyZWZsZWN0WDpmdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaD1LaShhKihmPW4/LTE6MSksYSpsLGMscyksdCgpKTpmPDB9LHJlZmxlY3RZOmZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhoPUtpKGEqZixhKihsPW4/LTE6MSksYyxzKSx0KCkpOmw8MH0sZml0RXh0ZW50OmZ1bmN0aW9uKHQsbil7cmV0dXJuIFJpKHUsdCxuKX0sZml0U2l6ZTpmdW5jdGlvbih0LG4pe3JldHVybiBMaSh1LHQsbil9LGZpdFdpZHRoOmZ1bmN0aW9uKHQsbil7cmV0dXJuIHFpKHUsdCxuKX0sZml0SGVpZ2h0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIERpKHUsdCxuKX19fSx0Lmdlb1Byb2plY3Rpb249T2ksdC5nZW9Qcm9qZWN0aW9uTXV0YXRvcj1GaSx0Lmdlb01lcmNhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuICRpKFZpKS5zY2FsZSg5NjEva3ApfSx0Lmdlb01lcmNhdG9yUmF3PVZpLHQuZ2VvTmF0dXJhbEVhcnRoMT1mdW5jdGlvbigpe3JldHVybiBPaSh0bykuc2NhbGUoMTc1LjI5NSl9LHQuZ2VvTmF0dXJhbEVhcnRoMVJhdz10byx0Lmdlb09ydGhvZ3JhcGhpYz1mdW5jdGlvbigpe3JldHVybiBPaShubykuc2NhbGUoMjQ5LjUpLmNsaXBBbmdsZSg5MCticCl9LHQuZ2VvT3J0aG9ncmFwaGljUmF3PW5vLHQuZ2VvU3RlcmVvZ3JhcGhpYz1mdW5jdGlvbigpe3JldHVybiBPaShlbykuc2NhbGUoMjUwKS5jbGlwQW5nbGUoMTQyKX0sdC5nZW9TdGVyZW9ncmFwaGljUmF3PWVvLHQuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yPWZ1bmN0aW9uKCl7dmFyIHQ9JGkocm8pLG49dC5jZW50ZXIsZT10LnJvdGF0ZTtyZXR1cm4gdC5jZW50ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/bihbLXRbMV0sdFswXV0pOih0PW4oKSxbdFsxXSwtdFswXV0pfSx0LnJvdGF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD9lKFt0WzBdLHRbMV0sdC5sZW5ndGg+Mj90WzJdKzkwOjkwXSk6KHQ9ZSgpLFt0WzBdLHRbMV0sdFsyXS05MF0pfSxlKFswLDAsOTBdKS5zY2FsZSgxNTkuMTU1KX0sdC5nZW9UcmFuc3ZlcnNlTWVyY2F0b3JSYXc9cm8sdC5nZW9Sb3RhdGlvbj1Vcix0Lmdlb1N0cmVhbT1KZSx0Lmdlb1RyYW5zZm9ybT1mdW5jdGlvbih0KXtyZXR1cm57c3RyZWFtOkNpKHQpfX0sdC5jbHVzdGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgbyx1PTA7dC5lYWNoQWZ0ZXIoZnVuY3Rpb24odCl7dmFyIGU9dC5jaGlsZHJlbjtlPyh0Lng9ZnVuY3Rpb24odCl7cmV0dXJuIHQucmVkdWNlKG9vLDApL3QubGVuZ3RofShlKSx0Lnk9ZnVuY3Rpb24odCl7cmV0dXJuIDErdC5yZWR1Y2UodW8sMCl9KGUpKToodC54PW8/dSs9bih0LG8pOjAsdC55PTAsbz10KX0pO3ZhciBhPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbjtuPXQuY2hpbGRyZW47KXQ9blswXTtyZXR1cm4gdH0odCksYz1mdW5jdGlvbih0KXtmb3IodmFyIG47bj10LmNoaWxkcmVuOyl0PW5bbi5sZW5ndGgtMV07cmV0dXJuIHR9KHQpLHM9YS54LW4oYSxjKS8yLGY9Yy54K24oYyxhKS8yO3JldHVybiB0LmVhY2hBZnRlcihpP2Z1bmN0aW9uKG4pe24ueD0obi54LXQueCkqZSxuLnk9KHQueS1uLnkpKnJ9OmZ1bmN0aW9uKG4pe24ueD0obi54LXMpLyhmLXMpKmUsbi55PSgxLSh0Lnk/bi55L3QueToxKSkqcn0pfXZhciBuPWlvLGU9MSxyPTEsaT0hMTtyZXR1cm4gdC5zZXBhcmF0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhuPWUsdCk6bn0sdC5zaXplPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPSExLGU9K25bMF0scj0rblsxXSx0KTppP251bGw6W2Uscl19LHQubm9kZVNpemU9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9ITAsZT0rblswXSxyPStuWzFdLHQpOmk/W2Uscl06bnVsbH0sdH0sdC5oaWVyYXJjaHk9Y28sdC5wYWNrPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gdC54PWUvMix0Lnk9ci8yLG4/dC5lYWNoQmVmb3JlKEFvKG4pKS5lYWNoQWZ0ZXIoQ28oaSwuNSkpLmVhY2hCZWZvcmUoem8oMSkpOnQuZWFjaEJlZm9yZShBbyhFbykpLmVhY2hBZnRlcihDbyhrbywxKSkuZWFjaEFmdGVyKENvKGksdC5yL01hdGgubWluKGUscikpKS5lYWNoQmVmb3JlKHpvKE1hdGgubWluKGUscikvKDIqdC5yKSkpLHR9dmFyIG49bnVsbCxlPTEscj0xLGk9a287cmV0dXJuIHQucmFkaXVzPWZ1bmN0aW9uKGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhuPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10P251bGw6Tm8odCl9KGUpLHQpOm59LHQuc2l6ZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT0rblswXSxyPStuWzFdLHQpOltlLHJdfSx0LnBhZGRpbmc9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOlNvKCtuKSx0KTppfSx0fSx0LnBhY2tTaWJsaW5ncz1mdW5jdGlvbih0KXtyZXR1cm4gVG8odCksdH0sdC5wYWNrRW5jbG9zZT1wbyx0LnBhcnRpdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIG89dC5oZWlnaHQrMTtyZXR1cm4gdC54MD10LnkwPXIsdC54MT1uLHQueTE9ZS9vLHQuZWFjaEJlZm9yZShmdW5jdGlvbih0LG4pe3JldHVybiBmdW5jdGlvbihlKXtlLmNoaWxkcmVuJiZSbyhlLGUueDAsdCooZS5kZXB0aCsxKS9uLGUueDEsdCooZS5kZXB0aCsyKS9uKTt2YXIgaT1lLngwLG89ZS55MCx1PWUueDEtcixhPWUueTEtcjt1PGkmJihpPXU9KGkrdSkvMiksYTxvJiYobz1hPShvK2EpLzIpLGUueDA9aSxlLnkwPW8sZS54MT11LGUueTE9YX19KGUsbykpLGkmJnQuZWFjaEJlZm9yZShQbyksdH12YXIgbj0xLGU9MSxyPTAsaT0hMTtyZXR1cm4gdC5yb3VuZD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT0hIW4sdCk6aX0sdC5zaXplPWZ1bmN0aW9uKHIpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhuPStyWzBdLGU9K3JbMV0sdCk6W24sZV19LHQucGFkZGluZz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocj0rbix0KTpyfSx0fSx0LnN0cmF0aWZ5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgcixpLG8sdSxhLGMscyxmPXQubGVuZ3RoLGw9bmV3IEFycmF5KGYpLGg9e307Zm9yKGk9MDtpPGY7KytpKXI9dFtpXSxhPWxbaV09bmV3IGhvKHIpLG51bGwhPShjPW4ocixpLHQpKSYmKGMrPVwiXCIpJiYoaFtzPSRkKyhhLmlkPWMpXT1zIGluIGg/WmQ6YSk7Zm9yKGk9MDtpPGY7KytpKWlmKGE9bFtpXSxudWxsIT0oYz1lKHRbaV0saSx0KSkmJihjKz1cIlwiKSl7aWYoISh1PWhbJGQrY10pKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiK2MpO2lmKHU9PT1aZCl0aHJvdyBuZXcgRXJyb3IoXCJhbWJpZ3VvdXM6IFwiK2MpO3UuY2hpbGRyZW4/dS5jaGlsZHJlbi5wdXNoKGEpOnUuY2hpbGRyZW49W2FdLGEucGFyZW50PXV9ZWxzZXtpZihvKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIHJvb3RzXCIpO289YX1pZighbyl0aHJvdyBuZXcgRXJyb3IoXCJubyByb290XCIpO2lmKG8ucGFyZW50PVdkLG8uZWFjaEJlZm9yZShmdW5jdGlvbih0KXt0LmRlcHRoPXQucGFyZW50LmRlcHRoKzEsLS1mfSkuZWFjaEJlZm9yZShsbyksby5wYXJlbnQ9bnVsbCxmPjApdGhyb3cgbmV3IEVycm9yKFwiY3ljbGVcIik7cmV0dXJuIG99dmFyIG49TG8sZT1xbztyZXR1cm4gdC5pZD1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obj1ObyhlKSx0KTpufSx0LnBhcmVudElkPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPU5vKG4pLHQpOmV9LHR9LHQudHJlZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGM9ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGUscixpLG8sdT1uZXcgWW8odCwwKSxhPVt1XTtuPWEucG9wKCk7KWlmKHI9bi5fLmNoaWxkcmVuKWZvcihuLmNoaWxkcmVuPW5ldyBBcnJheShvPXIubGVuZ3RoKSxpPW8tMTtpPj0wOy0taSlhLnB1c2goZT1uLmNoaWxkcmVuW2ldPW5ldyBZbyhyW2ldLGkpKSxlLnBhcmVudD1uO3JldHVybih1LnBhcmVudD1uZXcgWW8obnVsbCwwKSkuY2hpbGRyZW49W3VdLHV9KHQpO2lmKGMuZWFjaEFmdGVyKG4pLGMucGFyZW50Lm09LWMueixjLmVhY2hCZWZvcmUoZSksYSl0LmVhY2hCZWZvcmUocik7ZWxzZXt2YXIgcz10LGY9dCxsPXQ7dC5lYWNoQmVmb3JlKGZ1bmN0aW9uKHQpe3QueDxzLngmJihzPXQpLHQueD5mLngmJihmPXQpLHQuZGVwdGg+bC5kZXB0aCYmKGw9dCl9KTt2YXIgaD1zPT09Zj8xOmkocyxmKS8yLHA9aC1zLngsZD1vLyhmLngraCtwKSx2PXUvKGwuZGVwdGh8fDEpO3QuZWFjaEJlZm9yZShmdW5jdGlvbih0KXt0Lng9KHQueCtwKSpkLHQueT10LmRlcHRoKnZ9KX1yZXR1cm4gdH1mdW5jdGlvbiBuKHQpe3ZhciBuPXQuY2hpbGRyZW4sZT10LnBhcmVudC5jaGlsZHJlbixyPXQuaT9lW3QuaS0xXTpudWxsO2lmKG4peyhmdW5jdGlvbih0KXtmb3IodmFyIG4sZT0wLHI9MCxpPXQuY2hpbGRyZW4sbz1pLmxlbmd0aDstLW8+PTA7KShuPWlbb10pLnorPWUsbi5tKz1lLGUrPW4ucysocis9bi5jKX0pKHQpO3ZhciBvPShuWzBdLnorbltuLmxlbmd0aC0xXS56KS8yO3I/KHQuej1yLnoraSh0Ll8sci5fKSx0Lm09dC56LW8pOnQuej1vfWVsc2UgciYmKHQuej1yLnoraSh0Ll8sci5fKSk7dC5wYXJlbnQuQT1mdW5jdGlvbih0LG4sZSl7aWYobil7Zm9yKHZhciByLG89dCx1PXQsYT1uLGM9by5wYXJlbnQuY2hpbGRyZW5bMF0scz1vLm0sZj11Lm0sbD1hLm0saD1jLm07YT1PbyhhKSxvPVVvKG8pLGEmJm87KWM9VW8oYyksKHU9T28odSkpLmE9dCwocj1hLnorbC1vLnotcytpKGEuXyxvLl8pKT4wJiYoRm8oSW8oYSx0LGUpLHQscikscys9cixmKz1yKSxsKz1hLm0scys9by5tLGgrPWMubSxmKz11Lm07YSYmIU9vKHUpJiYodS50PWEsdS5tKz1sLWYpLG8mJiFVbyhjKSYmKGMudD1vLGMubSs9cy1oLGU9dCl9cmV0dXJuIGV9KHQscix0LnBhcmVudC5BfHxlWzBdKX1mdW5jdGlvbiBlKHQpe3QuXy54PXQueit0LnBhcmVudC5tLHQubSs9dC5wYXJlbnQubX1mdW5jdGlvbiByKHQpe3QueCo9byx0Lnk9dC5kZXB0aCp1fXZhciBpPURvLG89MSx1PTEsYT1udWxsO3JldHVybiB0LnNlcGFyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9bix0KTppfSx0LnNpemU9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGE9ITEsbz0rblswXSx1PStuWzFdLHQpOmE/bnVsbDpbbyx1XX0sdC5ub2RlU2l6ZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYT0hMCxvPStuWzBdLHU9K25bMV0sdCk6YT9bbyx1XTpudWxsfSx0fSx0LnRyZWVtYXA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3JldHVybiB0LngwPXQueTA9MCx0LngxPWksdC55MT1vLHQuZWFjaEJlZm9yZShuKSx1PVswXSxyJiZ0LmVhY2hCZWZvcmUoUG8pLHR9ZnVuY3Rpb24gbih0KXt2YXIgbj11W3QuZGVwdGhdLHI9dC54MCtuLGk9dC55MCtuLG89dC54MS1uLGg9dC55MS1uO288ciYmKHI9bz0ocitvKS8yKSxoPGkmJihpPWg9KGkraCkvMiksdC54MD1yLHQueTA9aSx0LngxPW8sdC55MT1oLHQuY2hpbGRyZW4mJihuPXVbdC5kZXB0aCsxXT1hKHQpLzIscis9bCh0KS1uLGkrPWModCktbixvLT1zKHQpLW4saC09Zih0KS1uLG88ciYmKHI9bz0ocitvKS8yKSxoPGkmJihpPWg9KGkraCkvMiksZSh0LHIsaSxvLGgpKX12YXIgZT1RZCxyPSExLGk9MSxvPTEsdT1bMF0sYT1rbyxjPWtvLHM9a28sZj1rbyxsPWtvO3JldHVybiB0LnJvdW5kPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhyPSEhbix0KTpyfSx0LnNpemU9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9K25bMF0sbz0rblsxXSx0KTpbaSxvXX0sdC50aWxlPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPU5vKG4pLHQpOmV9LHQucGFkZGluZz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90LnBhZGRpbmdJbm5lcihuKS5wYWRkaW5nT3V0ZXIobik6dC5wYWRkaW5nSW5uZXIoKX0sdC5wYWRkaW5nSW5uZXI9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGE9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOlNvKCtuKSx0KTphfSx0LnBhZGRpbmdPdXRlcj1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90LnBhZGRpbmdUb3AobikucGFkZGluZ1JpZ2h0KG4pLnBhZGRpbmdCb3R0b20obikucGFkZGluZ0xlZnQobik6dC5wYWRkaW5nVG9wKCl9LHQucGFkZGluZ1RvcD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246U28oK24pLHQpOmN9LHQucGFkZGluZ1JpZ2h0PWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhzPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpTbygrbiksdCk6c30sdC5wYWRkaW5nQm90dG9tPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhmPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpTbygrbiksdCk6Zn0sdC5wYWRkaW5nTGVmdD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246U28oK24pLHQpOmx9LHR9LHQudHJlZW1hcEJpbmFyeT1mdW5jdGlvbih0LG4sZSxyLGkpe2Z1bmN0aW9uIG8odCxuLGUscixpLHUsYSl7aWYodD49bi0xKXt2YXIgcz1jW3RdO3JldHVybiBzLngwPXIscy55MD1pLHMueDE9dSx2b2lkKHMueTE9YSl9Zm9yKHZhciBsPWZbdF0saD1lLzIrbCxwPXQrMSxkPW4tMTtwPGQ7KXt2YXIgdj1wK2Q+Pj4xO2Zbdl08aD9wPXYrMTpkPXZ9aC1mW3AtMV08ZltwXS1oJiZ0KzE8cCYmLS1wO3ZhciBnPWZbcF0tbCxfPWUtZztpZih1LXI+YS1pKXt2YXIgeT0ocipfK3UqZykvZTtvKHQscCxnLHIsaSx5LGEpLG8ocCxuLF8seSxpLHUsYSl9ZWxzZXt2YXIgbT0oaSpfK2EqZykvZTtvKHQscCxnLHIsaSx1LG0pLG8ocCxuLF8scixtLHUsYSl9fXZhciB1LGEsYz10LmNoaWxkcmVuLHM9Yy5sZW5ndGgsZj1uZXcgQXJyYXkocysxKTtmb3IoZlswXT1hPXU9MDt1PHM7Kyt1KWZbdSsxXT1hKz1jW3VdLnZhbHVlO28oMCxzLHQudmFsdWUsbixlLHIsaSl9LHQudHJlZW1hcERpY2U9Um8sdC50cmVlbWFwU2xpY2U9Qm8sdC50cmVlbWFwU2xpY2VEaWNlPWZ1bmN0aW9uKHQsbixlLHIsaSl7KDEmdC5kZXB0aD9CbzpSbykodCxuLGUscixpKX0sdC50cmVlbWFwU3F1YXJpZnk9UWQsdC50cmVlbWFwUmVzcXVhcmlmeT1KZCx0LmludGVycG9sYXRlPWNuLHQuaW50ZXJwb2xhdGVBcnJheT1lbix0LmludGVycG9sYXRlQmFzaXM9V3QsdC5pbnRlcnBvbGF0ZUJhc2lzQ2xvc2VkPVp0LHQuaW50ZXJwb2xhdGVEYXRlPXJuLHQuaW50ZXJwb2xhdGVOdW1iZXI9b24sdC5pbnRlcnBvbGF0ZU9iamVjdD11bix0LmludGVycG9sYXRlUm91bmQ9c24sdC5pbnRlcnBvbGF0ZVN0cmluZz1hbix0LmludGVycG9sYXRlVHJhbnNmb3JtQ3NzPVdmLHQuaW50ZXJwb2xhdGVUcmFuc2Zvcm1Tdmc9WmYsdC5pbnRlcnBvbGF0ZVpvb209cG4sdC5pbnRlcnBvbGF0ZVJnYj1ZZix0LmludGVycG9sYXRlUmdiQmFzaXM9QmYsdC5pbnRlcnBvbGF0ZVJnYkJhc2lzQ2xvc2VkPUhmLHQuaW50ZXJwb2xhdGVIc2w9dGwsdC5pbnRlcnBvbGF0ZUhzbExvbmc9bmwsdC5pbnRlcnBvbGF0ZUxhYj1mdW5jdGlvbih0LG4pe3ZhciBlPXRuKCh0PVV0KHQpKS5sLChuPVV0KG4pKS5sKSxyPXRuKHQuYSxuLmEpLGk9dG4odC5iLG4uYiksbz10bih0Lm9wYWNpdHksbi5vcGFjaXR5KTtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHQubD1lKG4pLHQuYT1yKG4pLHQuYj1pKG4pLHQub3BhY2l0eT1vKG4pLHQrXCJcIn19LHQuaW50ZXJwb2xhdGVIY2w9ZWwsdC5pbnRlcnBvbGF0ZUhjbExvbmc9cmwsdC5pbnRlcnBvbGF0ZUN1YmVoZWxpeD1pbCx0LmludGVycG9sYXRlQ3ViZWhlbGl4TG9uZz1vbCx0LnF1YW50aXplPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlPW5ldyBBcnJheShuKSxyPTA7cjxuOysrcillW3JdPXQoci8obi0xKSk7cmV0dXJuIGV9LHQucGF0aD10ZSx0LnBvbHlnb25BcmVhPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbixlPS0xLHI9dC5sZW5ndGgsaT10W3ItMV0sbz0wOysrZTxyOyluPWksaT10W2VdLG8rPW5bMV0qaVswXS1uWzBdKmlbMV07cmV0dXJuIG8vMn0sdC5wb2x5Z29uQ2VudHJvaWQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGUscj0tMSxpPXQubGVuZ3RoLG89MCx1PTAsYT10W2ktMV0sYz0wOysrcjxpOyluPWEsYT10W3JdLGMrPWU9blswXSphWzFdLWFbMF0qblsxXSxvKz0oblswXSthWzBdKSplLHUrPShuWzFdK2FbMV0pKmU7cmV0dXJuIGMqPTMsW28vYyx1L2NdfSx0LnBvbHlnb25IdWxsPWZ1bmN0aW9uKHQpe2lmKChlPXQubGVuZ3RoKTwzKXJldHVybiBudWxsO3ZhciBuLGUscj1uZXcgQXJyYXkoZSksaT1uZXcgQXJyYXkoZSk7Zm9yKG49MDtuPGU7KytuKXJbbl09Wyt0W25dWzBdLCt0W25dWzFdLG5dO2ZvcihyLnNvcnQoWG8pLG49MDtuPGU7KytuKWlbbl09W3Jbbl1bMF0sLXJbbl1bMV1dO3ZhciBvPVZvKHIpLHU9Vm8oaSksYT11WzBdPT09b1swXSxjPXVbdS5sZW5ndGgtMV09PT1vW28ubGVuZ3RoLTFdLHM9W107Zm9yKG49by5sZW5ndGgtMTtuPj0wOy0tbilzLnB1c2godFtyW29bbl1dWzJdXSk7Zm9yKG49K2E7bjx1Lmxlbmd0aC1jOysrbilzLnB1c2godFtyW3Vbbl1dWzJdXSk7cmV0dXJuIHN9LHQucG9seWdvbkNvbnRhaW5zPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlLHIsaT10Lmxlbmd0aCxvPXRbaS0xXSx1PW5bMF0sYT1uWzFdLGM9b1swXSxzPW9bMV0sZj0hMSxsPTA7bDxpOysrbCllPShvPXRbbF0pWzBdLChyPW9bMV0pPmEhPXM+YSYmdTwoYy1lKSooYS1yKS8ocy1yKStlJiYoZj0hZiksYz1lLHM9cjtyZXR1cm4gZn0sdC5wb2x5Z29uTGVuZ3RoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbixlLHI9LTEsaT10Lmxlbmd0aCxvPXRbaS0xXSx1PW9bMF0sYT1vWzFdLGM9MDsrK3I8aTspbj11LGU9YSxuLT11PShvPXRbcl0pWzBdLGUtPWE9b1sxXSxjKz1NYXRoLnNxcnQobipuK2UqZSk7cmV0dXJuIGN9LHQucXVhZHRyZWU9d2UsdC5xdWV1ZT1Rbyx0LnJhbmRvbVVuaWZvcm09bnYsdC5yYW5kb21Ob3JtYWw9ZXYsdC5yYW5kb21Mb2dOb3JtYWw9cnYsdC5yYW5kb21CYXRlcz1vdix0LnJhbmRvbUlyd2luSGFsbD1pdix0LnJhbmRvbUV4cG9uZW50aWFsPXV2LHQucmVxdWVzdD1Lbyx0Lmh0bWw9YXYsdC5qc29uPWN2LHQudGV4dD1zdix0LnhtbD1mdix0LmNzdj1sdix0LnRzdj1odix0LnNjYWxlQmFuZD1ydSx0LnNjYWxlUG9pbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gaXUocnUoKS5wYWRkaW5nSW5uZXIoMSkpfSx0LnNjYWxlSWRlbnRpdHk9ZHUsdC5zY2FsZUxpbmVhcj1wdSx0LnNjYWxlTG9nPXd1LHQuc2NhbGVPcmRpbmFsPWV1LHQuc2NhbGVJbXBsaWNpdD1ndix0LnNjYWxlUG93PVR1LHQuc2NhbGVTcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIFR1KCkuZXhwb25lbnQoLjUpfSx0LnNjYWxlUXVhbnRpbGU9TnUsdC5zY2FsZVF1YW50aXplPWt1LHQuc2NhbGVUaHJlc2hvbGQ9U3UsdC5zY2FsZVRpbWU9ZnVuY3Rpb24oKXtyZXR1cm4gamEoV3YsVnYsUHYsQ3YsRXYsa3YsVHYseHYsdC50aW1lRm9ybWF0KS5kb21haW4oW25ldyBEYXRlKDJlMywwLDEpLG5ldyBEYXRlKDJlMywwLDIpXSl9LHQuc2NhbGVVdGM9ZnVuY3Rpb24oKXtyZXR1cm4gamEoeWcsZ2csZWcsdGcsSnYsR3YsVHYseHYsdC51dGNGb3JtYXQpLmRvbWFpbihbRGF0ZS5VVEMoMmUzLDAsMSksRGF0ZS5VVEMoMmUzLDAsMildKX0sdC5zY2hlbWVDYXRlZ29yeTEwPXFnLHQuc2NoZW1lQ2F0ZWdvcnkyMGI9RGcsdC5zY2hlbWVDYXRlZ29yeTIwYz1VZyx0LnNjaGVtZUNhdGVnb3J5MjA9T2csdC5pbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHQ9RmcsdC5pbnRlcnBvbGF0ZVJhaW5ib3c9ZnVuY3Rpb24odCl7KHQ8MHx8dD4xKSYmKHQtPU1hdGguZmxvb3IodCkpO3ZhciBuPU1hdGguYWJzKHQtLjUpO3JldHVybiBCZy5oPTM2MCp0LTEwMCxCZy5zPTEuNS0xLjUqbixCZy5sPS44LS45Km4sQmcrXCJcIn0sdC5pbnRlcnBvbGF0ZVdhcm09SWcsdC5pbnRlcnBvbGF0ZUNvb2w9WWcsdC5pbnRlcnBvbGF0ZVZpcmlkaXM9SGcsdC5pbnRlcnBvbGF0ZU1hZ21hPWpnLHQuaW50ZXJwb2xhdGVJbmZlcm5vPVhnLHQuaW50ZXJwb2xhdGVQbGFzbWE9VmcsdC5zY2FsZVNlcXVlbnRpYWw9JGEsdC5jcmVhdG9yPUEsdC5sb2NhbD1DLHQubWF0Y2hlcj1yZix0Lm1vdXNlPUYsdC5uYW1lc3BhY2U9RSx0Lm5hbWVzcGFjZXM9SnMsdC5jbGllbnRQb2ludD1PLHQuc2VsZWN0PWx0LHQuc2VsZWN0QWxsPWZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0P25ldyBzdChbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KV0sW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pOm5ldyBzdChbbnVsbD09dD9bXTp0XSxhZil9LHQuc2VsZWN0aW9uPWZ0LHQuc2VsZWN0b3I9WSx0LnNlbGVjdG9yQWxsPUgsdC5zdHlsZT1HLHQudG91Y2g9aHQsdC50b3VjaGVzPWZ1bmN0aW9uKHQsbil7bnVsbD09biYmKG49VSgpLnRvdWNoZXMpO2Zvcih2YXIgZT0wLHI9bj9uLmxlbmd0aDowLGk9bmV3IEFycmF5KHIpO2U8cjsrK2UpaVtlXT1PKHQsbltlXSk7cmV0dXJuIGl9LHQud2luZG93PVosdC5jdXN0b21FdmVudD1ELHQuYXJjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciB0LHMsZj0rbi5hcHBseSh0aGlzLGFyZ3VtZW50cyksbD0rZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksaD1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKS1lXyxwPXUuYXBwbHkodGhpcyxhcmd1bWVudHMpLWVfLGQ9JGcocC1oKSx2PXA+aDtpZihjfHwoYz10PXRlKCkpLGw8ZiYmKHM9bCxsPWYsZj1zKSxsPnRfKWlmKGQ+cl8tdF8pYy5tb3ZlVG8obCpaZyhoKSxsKkpnKGgpKSxjLmFyYygwLDAsbCxoLHAsIXYpLGY+dF8mJihjLm1vdmVUbyhmKlpnKHApLGYqSmcocCkpLGMuYXJjKDAsMCxmLHAsaCx2KSk7ZWxzZXt2YXIgZyxfLHk9aCxtPXAseD1oLGI9cCx3PWQsTT1kLFQ9YS5hcHBseSh0aGlzLGFyZ3VtZW50cykvMixOPVQ+dF8mJihpPytpLmFwcGx5KHRoaXMsYXJndW1lbnRzKTpLZyhmKmYrbCpsKSksaz1RZygkZyhsLWYpLzIsK3IuYXBwbHkodGhpcyxhcmd1bWVudHMpKSxTPWssRT1rO2lmKE4+dF8pe3ZhciBBPVphKE4vZipKZyhUKSksQz1aYShOL2wqSmcoVCkpOyh3LT0yKkEpPnRfPyhBKj12PzE6LTEseCs9QSxiLT1BKToodz0wLHg9Yj0oaCtwKS8yKSwoTS09MipDKT50Xz8oQyo9dj8xOi0xLHkrPUMsbS09Qyk6KE09MCx5PW09KGgrcCkvMil9dmFyIHo9bCpaZyh5KSxQPWwqSmcoeSksUj1mKlpnKGIpLEw9ZipKZyhiKTtpZihrPnRfKXt2YXIgcT1sKlpnKG0pLEQ9bCpKZyhtKSxVPWYqWmcoeCksTz1mKkpnKHgpO2lmKGQ8bl8pe3ZhciBGPXc+dF8/ZnVuY3Rpb24odCxuLGUscixpLG8sdSxhKXt2YXIgYz1lLXQscz1yLW4sZj11LWksbD1hLW8saD0oZioobi1vKS1sKih0LWkpKS8obCpjLWYqcyk7cmV0dXJuW3QraCpjLG4raCpzXX0oeixQLFUsTyxxLEQsUixMKTpbUixMXSxJPXotRlswXSxZPVAtRlsxXSxCPXEtRlswXSxIPUQtRlsxXSxqPTEvSmcoZnVuY3Rpb24odCl7cmV0dXJuIHQ+MT8wOnQ8LTE/bl86TWF0aC5hY29zKHQpfSgoSSpCK1kqSCkvKEtnKEkqSStZKlkpKktnKEIqQitIKkgpKSkvMiksWD1LZyhGWzBdKkZbMF0rRlsxXSpGWzFdKTtTPVFnKGssKGYtWCkvKGotMSkpLEU9UWcoaywobC1YKS8oaisxKSl9fU0+dF8/RT50Xz8oZz1uYyhVLE8seixQLGwsRSx2KSxfPW5jKHEsRCxSLEwsbCxFLHYpLGMubW92ZVRvKGcuY3grZy54MDEsZy5jeStnLnkwMSksRTxrP2MuYXJjKGcuY3gsZy5jeSxFLFdnKGcueTAxLGcueDAxKSxXZyhfLnkwMSxfLngwMSksIXYpOihjLmFyYyhnLmN4LGcuY3ksRSxXZyhnLnkwMSxnLngwMSksV2coZy55MTEsZy54MTEpLCF2KSxjLmFyYygwLDAsbCxXZyhnLmN5K2cueTExLGcuY3grZy54MTEpLFdnKF8uY3krXy55MTEsXy5jeCtfLngxMSksIXYpLGMuYXJjKF8uY3gsXy5jeSxFLFdnKF8ueTExLF8ueDExKSxXZyhfLnkwMSxfLngwMSksIXYpKSk6KGMubW92ZVRvKHosUCksYy5hcmMoMCwwLGwseSxtLCF2KSk6Yy5tb3ZlVG8oeixQKSxmPnRfJiZ3PnRfP1M+dF8/KGc9bmMoUixMLHEsRCxmLC1TLHYpLF89bmMoeixQLFUsTyxmLC1TLHYpLGMubGluZVRvKGcuY3grZy54MDEsZy5jeStnLnkwMSksUzxrP2MuYXJjKGcuY3gsZy5jeSxTLFdnKGcueTAxLGcueDAxKSxXZyhfLnkwMSxfLngwMSksIXYpOihjLmFyYyhnLmN4LGcuY3ksUyxXZyhnLnkwMSxnLngwMSksV2coZy55MTEsZy54MTEpLCF2KSxjLmFyYygwLDAsZixXZyhnLmN5K2cueTExLGcuY3grZy54MTEpLFdnKF8uY3krXy55MTEsXy5jeCtfLngxMSksdiksYy5hcmMoXy5jeCxfLmN5LFMsV2coXy55MTEsXy54MTEpLFdnKF8ueTAxLF8ueDAxKSwhdikpKTpjLmFyYygwLDAsZixiLHgsdik6Yy5saW5lVG8oUixMKX1lbHNlIGMubW92ZVRvKDAsMCk7aWYoYy5jbG9zZVBhdGgoKSx0KXJldHVybiBjPW51bGwsdCtcIlwifHxudWxsfXZhciBuPUdhLGU9UWEscj1XYSgwKSxpPW51bGwsbz1KYSx1PUthLGE9dGMsYz1udWxsO3JldHVybiB0LmNlbnRyb2lkPWZ1bmN0aW9uKCl7dmFyIHQ9KCtuLmFwcGx5KHRoaXMsYXJndW1lbnRzKSsgK2UuYXBwbHkodGhpcyxhcmd1bWVudHMpKS8yLHI9KCtvLmFwcGx5KHRoaXMsYXJndW1lbnRzKSsgK3UuYXBwbHkodGhpcyxhcmd1bWVudHMpKS8yLW5fLzI7cmV0dXJuW1pnKHIpKnQsSmcocikqdF19LHQuaW5uZXJSYWRpdXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG49XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lOldhKCtlKSx0KTpufSx0Lm91dGVyUmFkaXVzPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpXYSgrbiksdCk6ZX0sdC5jb3JuZXJSYWRpdXM9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOldhKCtuKSx0KTpyfSx0LnBhZFJhZGl1cz1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT1udWxsPT1uP251bGw6XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOldhKCtuKSx0KTppfSx0LnN0YXJ0QW5nbGU9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG89XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOldhKCtuKSx0KTpvfSx0LmVuZEFuZ2xlPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh1PVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpXYSgrbiksdCk6dX0sdC5wYWRBbmdsZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoK24pLHQpOmF9LHQuY29udGV4dD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYz1udWxsPT1uP251bGw6bix0KTpjfSx0fSx0LmFyZWE9YWMsdC5saW5lPXVjLHQucGllPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgYSxjLHMsZixsLGg9dC5sZW5ndGgscD0wLGQ9bmV3IEFycmF5KGgpLHY9bmV3IEFycmF5KGgpLGc9K2kuYXBwbHkodGhpcyxhcmd1bWVudHMpLF89TWF0aC5taW4ocl8sTWF0aC5tYXgoLXJfLG8uYXBwbHkodGhpcyxhcmd1bWVudHMpLWcpKSx5PU1hdGgubWluKE1hdGguYWJzKF8pL2gsdS5hcHBseSh0aGlzLGFyZ3VtZW50cykpLG09eSooXzwwPy0xOjEpO2ZvcihhPTA7YTxoOysrYSkobD12W2RbYV09YV09K24odFthXSxhLHQpKT4wJiYocCs9bCk7Zm9yKG51bGwhPWU/ZC5zb3J0KGZ1bmN0aW9uKHQsbil7cmV0dXJuIGUodlt0XSx2W25dKX0pOm51bGwhPXImJmQuc29ydChmdW5jdGlvbihuLGUpe3JldHVybiByKHRbbl0sdFtlXSl9KSxhPTAscz1wPyhfLWgqbSkvcDowO2E8aDsrK2EsZz1mKWM9ZFthXSxmPWcrKChsPXZbY10pPjA/bCpzOjApK20sdltjXT17ZGF0YTp0W2NdLGluZGV4OmEsdmFsdWU6bCxzdGFydEFuZ2xlOmcsZW5kQW5nbGU6ZixwYWRBbmdsZTp5fTtyZXR1cm4gdn12YXIgbj1zYyxlPWNjLHI9bnVsbCxpPVdhKDApLG89V2Eocl8pLHU9V2EoMCk7cmV0dXJuIHQudmFsdWU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG49XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lOldhKCtlKSx0KTpufSx0LnNvcnRWYWx1ZXM9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGU9bixyPW51bGwsdCk6ZX0sdC5zb3J0PWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhyPW4sZT1udWxsLHQpOnJ9LHQuc3RhcnRBbmdsZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoK24pLHQpOml9LHQuZW5kQW5nbGU9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG89XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOldhKCtuKSx0KTpvfSx0LnBhZEFuZ2xlPWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh1PVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpXYSgrbiksdCk6dX0sdH0sdC5hcmVhUmFkaWFsPWRjLHQucmFkaWFsQXJlYT1kYyx0LmxpbmVSYWRpYWw9cGMsdC5yYWRpYWxMaW5lPXBjLHQucG9pbnRSYWRpYWw9dmMsdC5saW5rSG9yaXpvbnRhbD1mdW5jdGlvbigpe3JldHVybiB5YyhtYyl9LHQubGlua1ZlcnRpY2FsPWZ1bmN0aW9uKCl7cmV0dXJuIHljKHhjKX0sdC5saW5rUmFkaWFsPWZ1bmN0aW9uKCl7dmFyIHQ9eWMoYmMpO3JldHVybiB0LmFuZ2xlPXQueCxkZWxldGUgdC54LHQucmFkaXVzPXQueSxkZWxldGUgdC55LHR9LHQuc3ltYm9sPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciB0O2lmKHJ8fChyPXQ9dGUoKSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cykuZHJhdyhyLCtlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSksdClyZXR1cm4gcj1udWxsLHQrXCJcInx8bnVsbH12YXIgbj1XYSh1XyksZT1XYSg2NCkscj1udWxsO3JldHVybiB0LnR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KG49XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lOldhKGUpLHQpOm59LHQuc2l6ZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoK24pLHQpOmV9LHQuY29udGV4dD1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocj1udWxsPT1uP251bGw6bix0KTpyfSx0fSx0LnN5bWJvbHM9d18sdC5zeW1ib2xDaXJjbGU9dV8sdC5zeW1ib2xDcm9zcz1hXyx0LnN5bWJvbERpYW1vbmQ9Zl8sdC5zeW1ib2xTcXVhcmU9dl8sdC5zeW1ib2xTdGFyPWRfLHQuc3ltYm9sVHJpYW5nbGU9X18sdC5zeW1ib2xXeWU9Yl8sdC5jdXJ2ZUJhc2lzQ2xvc2VkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTmModCl9LHQuY3VydmVCYXNpc09wZW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBrYyh0KX0sdC5jdXJ2ZUJhc2lzPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVGModCl9LHQuY3VydmVCdW5kbGU9TV8sdC5jdXJ2ZUNhcmRpbmFsQ2xvc2VkPU5fLHQuY3VydmVDYXJkaW5hbE9wZW49a18sdC5jdXJ2ZUNhcmRpbmFsPVRfLHQuY3VydmVDYXRtdWxsUm9tQ2xvc2VkPUVfLHQuY3VydmVDYXRtdWxsUm9tT3Blbj1BXyx0LmN1cnZlQ2F0bXVsbFJvbT1TXyx0LmN1cnZlTGluZWFyQ2xvc2VkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRGModCl9LHQuY3VydmVMaW5lYXI9cmMsdC5jdXJ2ZU1vbm90b25lWD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFljKHQpfSx0LmN1cnZlTW9ub3RvbmVZPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgQmModCl9LHQuY3VydmVOYXR1cmFsPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgamModCl9LHQuY3VydmVTdGVwPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVmModCwuNSl9LHQuY3VydmVTdGVwQWZ0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBWYyh0LDEpfSx0LmN1cnZlU3RlcEJlZm9yZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFZjKHQsMCl9LHQuc3RhY2s9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBvLHUsYT1uLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxjPXQubGVuZ3RoLHM9YS5sZW5ndGgsZj1uZXcgQXJyYXkocyk7Zm9yKG89MDtvPHM7KytvKXtmb3IodmFyIGwsaD1hW29dLHA9ZltvXT1uZXcgQXJyYXkoYyksZD0wO2Q8YzsrK2QpcFtkXT1sPVswLCtpKHRbZF0saCxkLHQpXSxsLmRhdGE9dFtkXTtwLmtleT1ofWZvcihvPTAsdT1lKGYpO288czsrK28pZlt1W29dXS5pbmRleD1vO3JldHVybiByKGYsdSksZn12YXIgbj1XYShbXSksZT1XYyxyPSRjLGk9WmM7cmV0dXJuIHQua2V5cz1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8obj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6V2Eob18uY2FsbChlKSksdCk6bn0sdC52YWx1ZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2EoK24pLHQpOml9LHQub3JkZXI9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGU9bnVsbD09bj9XYzpcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246V2Eob18uY2FsbChuKSksdCk6ZX0sdC5vZmZzZXQ9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9bnVsbD09bj8kYzpuLHQpOnJ9LHR9LHQuc3RhY2tPZmZzZXRFeHBhbmQ9ZnVuY3Rpb24odCxuKXtpZigocj10Lmxlbmd0aCk+MCl7Zm9yKHZhciBlLHIsaSxvPTAsdT10WzBdLmxlbmd0aDtvPHU7KytvKXtmb3IoaT1lPTA7ZTxyOysrZSlpKz10W2VdW29dWzFdfHwwO2lmKGkpZm9yKGU9MDtlPHI7KytlKXRbZV1bb11bMV0vPWl9JGModCxuKX19LHQuc3RhY2tPZmZzZXREaXZlcmdpbmc9ZnVuY3Rpb24odCxuKXtpZigoYT10Lmxlbmd0aCk+MSlmb3IodmFyIGUscixpLG8sdSxhLGM9MCxzPXRbblswXV0ubGVuZ3RoO2M8czsrK2MpZm9yKG89dT0wLGU9MDtlPGE7KytlKShpPShyPXRbbltlXV1bY10pWzFdLXJbMF0pPj0wPyhyWzBdPW8sclsxXT1vKz1pKTppPDA/KHJbMV09dSxyWzBdPXUrPWkpOnJbMF09b30sdC5zdGFja09mZnNldE5vbmU9JGMsdC5zdGFja09mZnNldFNpbGhvdWV0dGU9ZnVuY3Rpb24odCxuKXtpZigoZT10Lmxlbmd0aCk+MCl7Zm9yKHZhciBlLHI9MCxpPXRbblswXV0sbz1pLmxlbmd0aDtyPG87KytyKXtmb3IodmFyIHU9MCxhPTA7dTxlOysrdSlhKz10W3VdW3JdWzFdfHwwO2lbcl1bMV0rPWlbcl1bMF09LWEvMn0kYyh0LG4pfX0sdC5zdGFja09mZnNldFdpZ2dsZT1mdW5jdGlvbih0LG4pe2lmKChpPXQubGVuZ3RoKT4wJiYocj0oZT10W25bMF1dKS5sZW5ndGgpPjApe2Zvcih2YXIgZSxyLGksbz0wLHU9MTt1PHI7Kyt1KXtmb3IodmFyIGE9MCxjPTAscz0wO2E8aTsrK2Epe2Zvcih2YXIgZj10W25bYV1dLGw9Zlt1XVsxXXx8MCxoPShsLShmW3UtMV1bMV18fDApKS8yLHA9MDtwPGE7KytwKXt2YXIgZD10W25bcF1dO2grPShkW3VdWzFdfHwwKS0oZFt1LTFdWzFdfHwwKX1jKz1sLHMrPWgqbH1lW3UtMV1bMV0rPWVbdS0xXVswXT1vLGMmJihvLT1zL2MpfWVbdS0xXVsxXSs9ZVt1LTFdWzBdPW8sJGModCxuKX19LHQuc3RhY2tPcmRlckFzY2VuZGluZz1HYyx0LnN0YWNrT3JkZXJEZXNjZW5kaW5nPWZ1bmN0aW9uKHQpe3JldHVybiBHYyh0KS5yZXZlcnNlKCl9LHQuc3RhY2tPcmRlckluc2lkZU91dD1mdW5jdGlvbih0KXt2YXIgbixlLHI9dC5sZW5ndGgsaT10Lm1hcChRYyksbz1XYyh0KS5zb3J0KGZ1bmN0aW9uKHQsbil7cmV0dXJuIGlbbl0taVt0XX0pLHU9MCxhPTAsYz1bXSxzPVtdO2ZvcihuPTA7bjxyOysrbillPW9bbl0sdTxhPyh1Kz1pW2VdLGMucHVzaChlKSk6KGErPWlbZV0scy5wdXNoKGUpKTtyZXR1cm4gcy5yZXZlcnNlKCkuY29uY2F0KGMpfSx0LnN0YWNrT3JkZXJOb25lPVdjLHQuc3RhY2tPcmRlclJldmVyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIFdjKHQpLnJldmVyc2UoKX0sdC50aW1lSW50ZXJ2YWw9RXUsdC50aW1lTWlsbGlzZWNvbmQ9eHYsdC50aW1lTWlsbGlzZWNvbmRzPWJ2LHQudXRjTWlsbGlzZWNvbmQ9eHYsdC51dGNNaWxsaXNlY29uZHM9YnYsdC50aW1lU2Vjb25kPVR2LHQudGltZVNlY29uZHM9TnYsdC51dGNTZWNvbmQ9VHYsdC51dGNTZWNvbmRzPU52LHQudGltZU1pbnV0ZT1rdix0LnRpbWVNaW51dGVzPVN2LHQudGltZUhvdXI9RXYsdC50aW1lSG91cnM9QXYsdC50aW1lRGF5PUN2LHQudGltZURheXM9enYsdC50aW1lV2Vlaz1Qdix0LnRpbWVXZWVrcz1Gdix0LnRpbWVTdW5kYXk9UHYsdC50aW1lU3VuZGF5cz1Gdix0LnRpbWVNb25kYXk9UnYsdC50aW1lTW9uZGF5cz1Jdix0LnRpbWVUdWVzZGF5PUx2LHQudGltZVR1ZXNkYXlzPVl2LHQudGltZVdlZG5lc2RheT1xdix0LnRpbWVXZWRuZXNkYXlzPUJ2LHQudGltZVRodXJzZGF5PUR2LHQudGltZVRodXJzZGF5cz1Idix0LnRpbWVGcmlkYXk9VXYsdC50aW1lRnJpZGF5cz1qdix0LnRpbWVTYXR1cmRheT1Pdix0LnRpbWVTYXR1cmRheXM9WHYsdC50aW1lTW9udGg9VnYsdC50aW1lTW9udGhzPSR2LHQudGltZVllYXI9V3YsdC50aW1lWWVhcnM9WnYsdC51dGNNaW51dGU9R3YsdC51dGNNaW51dGVzPVF2LHQudXRjSG91cj1Kdix0LnV0Y0hvdXJzPUt2LHQudXRjRGF5PXRnLHQudXRjRGF5cz1uZyx0LnV0Y1dlZWs9ZWcsdC51dGNXZWVrcz1zZyx0LnV0Y1N1bmRheT1lZyx0LnV0Y1N1bmRheXM9c2csdC51dGNNb25kYXk9cmcsdC51dGNNb25kYXlzPWZnLHQudXRjVHVlc2RheT1pZyx0LnV0Y1R1ZXNkYXlzPWxnLHQudXRjV2VkbmVzZGF5PW9nLHQudXRjV2VkbmVzZGF5cz1oZyx0LnV0Y1RodXJzZGF5PXVnLHQudXRjVGh1cnNkYXlzPXBnLHQudXRjRnJpZGF5PWFnLHQudXRjRnJpZGF5cz1kZyx0LnV0Y1NhdHVyZGF5PWNnLHQudXRjU2F0dXJkYXlzPXZnLHQudXRjTW9udGg9Z2csdC51dGNNb250aHM9X2csdC51dGNZZWFyPXlnLHQudXRjWWVhcnM9eGcsdC50aW1lRm9ybWF0RGVmYXVsdExvY2FsZT1ZYSx0LnRpbWVGb3JtYXRMb2NhbGU9THUsdC5pc29Gb3JtYXQ9a2csdC5pc29QYXJzZT1TZyx0Lm5vdz1fbix0LnRpbWVyPXhuLHQudGltZXJGbHVzaD1ibix0LnRpbWVvdXQ9Tm4sdC5pbnRlcnZhbD1mdW5jdGlvbih0LG4sZSl7dmFyIHI9bmV3IG1uLGk9bjtyZXR1cm4gbnVsbD09bj8oci5yZXN0YXJ0KHQsbixlKSxyKToobj0rbixlPW51bGw9PWU/X24oKTorZSxyLnJlc3RhcnQoZnVuY3Rpb24gbyh1KXt1Kz1pLHIucmVzdGFydChvLGkrPW4sZSksdCh1KX0sbixlKSxyKX0sdC50cmFuc2l0aW9uPUxuLHQuYWN0aXZlPWZ1bmN0aW9uKHQsbil7dmFyIGUscixpPXQuX190cmFuc2l0aW9uO2lmKGkpe249bnVsbD09bj9udWxsOm4rXCJcIjtmb3IociBpbiBpKWlmKChlPWlbcl0pLnN0YXRlPnlsJiZlLm5hbWU9PT1uKXJldHVybiBuZXcgUm4oW1t0XV0sR2wsbiwrcil9cmV0dXJuIG51bGx9LHQuaW50ZXJydXB0PUNuLHQudm9yb25vaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIG5ldyBNcyh0Lm1hcChmdW5jdGlvbihyLGkpe3ZhciBvPVtNYXRoLnJvdW5kKG4ocixpLHQpL1VfKSpVXyxNYXRoLnJvdW5kKGUocixpLHQpL1VfKSpVX107cmV0dXJuIG8uaW5kZXg9aSxvLmRhdGE9cixvfSkscil9dmFyIG49S2MsZT10cyxyPW51bGw7cmV0dXJuIHQucG9seWdvbnM9ZnVuY3Rpb24obil7cmV0dXJuIHQobikucG9seWdvbnMoKX0sdC5saW5rcz1mdW5jdGlvbihuKXtyZXR1cm4gdChuKS5saW5rcygpfSx0LnRyaWFuZ2xlcz1mdW5jdGlvbihuKXtyZXR1cm4gdChuKS50cmlhbmdsZXMoKX0sdC54PWZ1bmN0aW9uKGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhuPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZTpKYygrZSksdCk6bn0sdC55PWZ1bmN0aW9uKG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpKYygrbiksdCk6ZX0sdC5leHRlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHI9bnVsbD09bj9udWxsOltbK25bMF1bMF0sK25bMF1bMV1dLFsrblsxXVswXSwrblsxXVsxXV1dLHQpOnImJltbclswXVswXSxyWzBdWzFdXSxbclsxXVswXSxyWzFdWzFdXV19LHQuc2l6ZT1mdW5jdGlvbihuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocj1udWxsPT1uP251bGw6W1swLDBdLFsrblswXSwrblsxXV1dLHQpOnImJltyWzFdWzBdLXJbMF1bMF0sclsxXVsxXS1yWzBdWzFdXX0sdH0sdC56b29tPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbih0KXt0LnByb3BlcnR5KFwiX196b29tXCIsenMpLm9uKFwid2hlZWwuem9vbVwiLGMpLm9uKFwibW91c2Vkb3duLnpvb21cIixzKS5vbihcImRibGNsaWNrLnpvb21cIixmKS5maWx0ZXIoeCkub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIixsKS5vbihcInRvdWNobW92ZS56b29tXCIsaCkub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIixwKS5zdHlsZShcInRvdWNoLWFjdGlvblwiLFwibm9uZVwiKS5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLFwicmdiYSgwLDAsMCwwKVwiKX1mdW5jdGlvbiBlKHQsbil7cmV0dXJuKG49TWF0aC5tYXgoYlswXSxNYXRoLm1pbihiWzFdLG4pKSk9PT10Lms/dDpuZXcgTnMobix0LngsdC55KX1mdW5jdGlvbiByKHQsbixlKXt2YXIgcj1uWzBdLWVbMF0qdC5rLGk9blsxXS1lWzFdKnQuaztyZXR1cm4gcj09PXQueCYmaT09PXQueT90Om5ldyBOcyh0LmsscixpKX1mdW5jdGlvbiBpKHQpe3JldHVyblsoK3RbMF1bMF0rICt0WzFdWzBdKS8yLCgrdFswXVsxXSsgK3RbMV1bMV0pLzJdfWZ1bmN0aW9uIG8odCxuLGUpe3Qub24oXCJzdGFydC56b29tXCIsZnVuY3Rpb24oKXt1KHRoaXMsYXJndW1lbnRzKS5zdGFydCgpfSkub24oXCJpbnRlcnJ1cHQuem9vbSBlbmQuem9vbVwiLGZ1bmN0aW9uKCl7dSh0aGlzLGFyZ3VtZW50cykuZW5kKCl9KS50d2VlbihcInpvb21cIixmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cyxyPXUodGhpcyx0KSxvPV8uYXBwbHkodGhpcyx0KSxhPWV8fGkobyksYz1NYXRoLm1heChvWzFdWzBdLW9bMF1bMF0sb1sxXVsxXS1vWzBdWzFdKSxzPXRoaXMuX196b29tLGY9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uLmFwcGx5KHRoaXMsdCk6bixsPVQocy5pbnZlcnQoYSkuY29uY2F0KGMvcy5rKSxmLmludmVydChhKS5jb25jYXQoYy9mLmspKTtyZXR1cm4gZnVuY3Rpb24odCl7aWYoMT09PXQpdD1mO2Vsc2V7dmFyIG49bCh0KSxlPWMvblsyXTt0PW5ldyBOcyhlLGFbMF0tblswXSplLGFbMV0tblsxXSplKX1yLnpvb20obnVsbCx0KX19KX1mdW5jdGlvbiB1KHQsbil7Zm9yKHZhciBlLHI9MCxpPWsubGVuZ3RoO3I8aTsrK3IpaWYoKGU9a1tyXSkudGhhdD09PXQpcmV0dXJuIGU7cmV0dXJuIG5ldyBhKHQsbil9ZnVuY3Rpb24gYSh0LG4pe3RoaXMudGhhdD10LHRoaXMuYXJncz1uLHRoaXMuaW5kZXg9LTEsdGhpcy5hY3RpdmU9MCx0aGlzLmV4dGVudD1fLmFwcGx5KHQsbil9ZnVuY3Rpb24gYygpe2lmKGcuYXBwbHkodGhpcyxhcmd1bWVudHMpKXt2YXIgdD11KHRoaXMsYXJndW1lbnRzKSxuPXRoaXMuX196b29tLGk9TWF0aC5tYXgoYlswXSxNYXRoLm1pbihiWzFdLG4uaypNYXRoLnBvdygyLG0uYXBwbHkodGhpcyxhcmd1bWVudHMpKSkpLG89Rih0aGlzKTtpZih0LndoZWVsKXQubW91c2VbMF1bMF09PT1vWzBdJiZ0Lm1vdXNlWzBdWzFdPT09b1sxXXx8KHQubW91c2VbMV09bi5pbnZlcnQodC5tb3VzZVswXT1vKSksY2xlYXJUaW1lb3V0KHQud2hlZWwpO2Vsc2V7aWYobi5rPT09aSlyZXR1cm47dC5tb3VzZT1bbyxuLmludmVydChvKV0sQ24odGhpcyksdC5zdGFydCgpfUVzKCksdC53aGVlbD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC53aGVlbD1udWxsLHQuZW5kKCl9LEEpLHQuem9vbShcIm1vdXNlXCIseShyKGUobixpKSx0Lm1vdXNlWzBdLHQubW91c2VbMV0pLHQuZXh0ZW50LHcpKX19ZnVuY3Rpb24gcygpe2lmKCF2JiZnLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7dmFyIG49dSh0aGlzLGFyZ3VtZW50cyksZT1sdCh0LmV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLnpvb21cIixmdW5jdGlvbigpe2lmKEVzKCksIW4ubW92ZWQpe3ZhciBlPXQuZXZlbnQuY2xpZW50WC1vLGk9dC5ldmVudC5jbGllbnRZLWE7bi5tb3ZlZD1lKmUraSppPkN9bi56b29tKFwibW91c2VcIix5KHIobi50aGF0Ll9fem9vbSxuLm1vdXNlWzBdPUYobi50aGF0KSxuLm1vdXNlWzFdKSxuLmV4dGVudCx3KSl9LCEwKS5vbihcIm1vdXNldXAuem9vbVwiLGZ1bmN0aW9uKCl7ZS5vbihcIm1vdXNlbW92ZS56b29tIG1vdXNldXAuem9vbVwiLG51bGwpLGd0KHQuZXZlbnQudmlldyxuLm1vdmVkKSxFcygpLG4uZW5kKCl9LCEwKSxpPUYodGhpcyksbz10LmV2ZW50LmNsaWVudFgsYT10LmV2ZW50LmNsaWVudFk7dnQodC5ldmVudC52aWV3KSxTcygpLG4ubW91c2U9W2ksdGhpcy5fX3pvb20uaW52ZXJ0KGkpXSxDbih0aGlzKSxuLnN0YXJ0KCl9fWZ1bmN0aW9uIGYoKXtpZihnLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7dmFyIGk9dGhpcy5fX3pvb20sdT1GKHRoaXMpLGE9aS5pbnZlcnQodSksYz1pLmsqKHQuZXZlbnQuc2hpZnRLZXk/LjU6Mikscz15KHIoZShpLGMpLHUsYSksXy5hcHBseSh0aGlzLGFyZ3VtZW50cyksdyk7RXMoKSxNPjA/bHQodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKE0pLmNhbGwobyxzLHUpOmx0KHRoaXMpLmNhbGwobi50cmFuc2Zvcm0scyl9fWZ1bmN0aW9uIGwoKXtpZihnLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7dmFyIG4sZSxyLGksbz11KHRoaXMsYXJndW1lbnRzKSxhPXQuZXZlbnQuY2hhbmdlZFRvdWNoZXMsYz1hLmxlbmd0aDtmb3IoU3MoKSxlPTA7ZTxjOysrZSlpPVtpPWh0KHRoaXMsYSwocj1hW2VdKS5pZGVudGlmaWVyKSx0aGlzLl9fem9vbS5pbnZlcnQoaSksci5pZGVudGlmaWVyXSxvLnRvdWNoMD9vLnRvdWNoMXx8KG8udG91Y2gxPWkpOihvLnRvdWNoMD1pLG49ITApO2lmKGQmJihkPWNsZWFyVGltZW91dChkKSwhby50b3VjaDEpKXJldHVybiBvLmVuZCgpLHZvaWQoKGk9bHQodGhpcykub24oXCJkYmxjbGljay56b29tXCIpKSYmaS5hcHBseSh0aGlzLGFyZ3VtZW50cykpO24mJihkPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtkPW51bGx9LEUpLENuKHRoaXMpLG8uc3RhcnQoKSl9fWZ1bmN0aW9uIGgoKXt2YXIgbixpLG8sYSxjPXUodGhpcyxhcmd1bWVudHMpLHM9dC5ldmVudC5jaGFuZ2VkVG91Y2hlcyxmPXMubGVuZ3RoO2ZvcihFcygpLGQmJihkPWNsZWFyVGltZW91dChkKSksbj0wO248ZjsrK24pbz1odCh0aGlzLHMsKGk9c1tuXSkuaWRlbnRpZmllciksYy50b3VjaDAmJmMudG91Y2gwWzJdPT09aS5pZGVudGlmaWVyP2MudG91Y2gwWzBdPW86Yy50b3VjaDEmJmMudG91Y2gxWzJdPT09aS5pZGVudGlmaWVyJiYoYy50b3VjaDFbMF09byk7aWYoaT1jLnRoYXQuX196b29tLGMudG91Y2gxKXt2YXIgbD1jLnRvdWNoMFswXSxoPWMudG91Y2gwWzFdLHA9Yy50b3VjaDFbMF0sdj1jLnRvdWNoMVsxXSxnPShnPXBbMF0tbFswXSkqZysoZz1wWzFdLWxbMV0pKmcsXz0oXz12WzBdLWhbMF0pKl8rKF89dlsxXS1oWzFdKSpfO2k9ZShpLE1hdGguc3FydChnL18pKSxvPVsobFswXStwWzBdKS8yLChsWzFdK3BbMV0pLzJdLGE9WyhoWzBdK3ZbMF0pLzIsKGhbMV0rdlsxXSkvMl19ZWxzZXtpZighYy50b3VjaDApcmV0dXJuO289Yy50b3VjaDBbMF0sYT1jLnRvdWNoMFsxXX1jLnpvb20oXCJ0b3VjaFwiLHkocihpLG8sYSksYy5leHRlbnQsdykpfWZ1bmN0aW9uIHAoKXt2YXIgbixlLHI9dSh0aGlzLGFyZ3VtZW50cyksaT10LmV2ZW50LmNoYW5nZWRUb3VjaGVzLG89aS5sZW5ndGg7Zm9yKFNzKCksdiYmY2xlYXJUaW1lb3V0KHYpLHY9c2V0VGltZW91dChmdW5jdGlvbigpe3Y9bnVsbH0sRSksbj0wO248bzsrK24pZT1pW25dLHIudG91Y2gwJiZyLnRvdWNoMFsyXT09PWUuaWRlbnRpZmllcj9kZWxldGUgci50b3VjaDA6ci50b3VjaDEmJnIudG91Y2gxWzJdPT09ZS5pZGVudGlmaWVyJiZkZWxldGUgci50b3VjaDE7ci50b3VjaDEmJiFyLnRvdWNoMCYmKHIudG91Y2gwPXIudG91Y2gxLGRlbGV0ZSByLnRvdWNoMSksci50b3VjaDA/ci50b3VjaDBbMV09dGhpcy5fX3pvb20uaW52ZXJ0KHIudG91Y2gwWzBdKTpyLmVuZCgpfXZhciBkLHYsZz1BcyxfPUNzLHk9THMsbT1Qcyx4PVJzLGI9WzAsMS8wXSx3PVtbLTEvMCwtMS8wXSxbMS8wLDEvMF1dLE09MjUwLFQ9cG4saz1bXSxTPU4oXCJzdGFydFwiLFwiem9vbVwiLFwiZW5kXCIpLEU9NTAwLEE9MTUwLEM9MDtyZXR1cm4gbi50cmFuc2Zvcm09ZnVuY3Rpb24odCxuKXt2YXIgZT10LnNlbGVjdGlvbj90LnNlbGVjdGlvbigpOnQ7ZS5wcm9wZXJ0eShcIl9fem9vbVwiLHpzKSx0IT09ZT9vKHQsbik6ZS5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCl7dSh0aGlzLGFyZ3VtZW50cykuc3RhcnQoKS56b29tKG51bGwsXCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTpuKS5lbmQoKX0pfSxuLnNjYWxlQnk9ZnVuY3Rpb24odCxlKXtuLnNjYWxlVG8odCxmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fem9vbS5rKihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UuYXBwbHkodGhpcyxhcmd1bWVudHMpOmUpfSl9LG4uc2NhbGVUbz1mdW5jdGlvbih0LG8pe24udHJhbnNmb3JtKHQsZnVuY3Rpb24oKXt2YXIgdD1fLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxuPXRoaXMuX196b29tLHU9aSh0KSxhPW4uaW52ZXJ0KHUpLGM9XCJmdW5jdGlvblwiPT10eXBlb2Ygbz9vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTpvO3JldHVybiB5KHIoZShuLGMpLHUsYSksdCx3KX0pfSxuLnRyYW5zbGF0ZUJ5PWZ1bmN0aW9uKHQsZSxyKXtuLnRyYW5zZm9ybSh0LGZ1bmN0aW9uKCl7cmV0dXJuIHkodGhpcy5fX3pvb20udHJhbnNsYXRlKFwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk6ZSxcImZ1bmN0aW9uXCI9PXR5cGVvZiByP3IuYXBwbHkodGhpcyxhcmd1bWVudHMpOnIpLF8uYXBwbHkodGhpcyxhcmd1bWVudHMpLHcpfSl9LG4udHJhbnNsYXRlVG89ZnVuY3Rpb24odCxlLHIpe24udHJhbnNmb3JtKHQsZnVuY3Rpb24oKXt2YXIgdD1fLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxuPXRoaXMuX196b29tLG89aSh0KTtyZXR1cm4geShGXy50cmFuc2xhdGUob1swXSxvWzFdKS5zY2FsZShuLmspLnRyYW5zbGF0ZShcImZ1bmN0aW9uXCI9PXR5cGVvZiBlPy1lLmFwcGx5KHRoaXMsYXJndW1lbnRzKTotZSxcImZ1bmN0aW9uXCI9PXR5cGVvZiByPy1yLmFwcGx5KHRoaXMsYXJndW1lbnRzKTotciksdCx3KX0pfSxhLnByb3RvdHlwZT17c3RhcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gMT09Kyt0aGlzLmFjdGl2ZSYmKHRoaXMuaW5kZXg9ay5wdXNoKHRoaXMpLTEsdGhpcy5lbWl0KFwic3RhcnRcIikpLHRoaXN9LHpvb206ZnVuY3Rpb24odCxuKXtyZXR1cm4gdGhpcy5tb3VzZSYmXCJtb3VzZVwiIT09dCYmKHRoaXMubW91c2VbMV09bi5pbnZlcnQodGhpcy5tb3VzZVswXSkpLHRoaXMudG91Y2gwJiZcInRvdWNoXCIhPT10JiYodGhpcy50b3VjaDBbMV09bi5pbnZlcnQodGhpcy50b3VjaDBbMF0pKSx0aGlzLnRvdWNoMSYmXCJ0b3VjaFwiIT09dCYmKHRoaXMudG91Y2gxWzFdPW4uaW52ZXJ0KHRoaXMudG91Y2gxWzBdKSksdGhpcy50aGF0Ll9fem9vbT1uLHRoaXMuZW1pdChcInpvb21cIiksdGhpc30sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PS0tdGhpcy5hY3RpdmUmJihrLnNwbGljZSh0aGlzLmluZGV4LDEpLHRoaXMuaW5kZXg9LTEsdGhpcy5lbWl0KFwiZW5kXCIpKSx0aGlzfSxlbWl0OmZ1bmN0aW9uKHQpe0QobmV3IGZ1bmN0aW9uKHQsbixlKXt0aGlzLnRhcmdldD10LHRoaXMudHlwZT1uLHRoaXMudHJhbnNmb3JtPWV9KG4sdCx0aGlzLnRoYXQuX196b29tKSxTLmFwcGx5LFMsW3QsdGhpcy50aGF0LHRoaXMuYXJnc10pfX0sbi53aGVlbERlbHRhPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhtPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpUcygrdCksbik6bX0sbi5maWx0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGc9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OlRzKCEhdCksbik6Z30sbi50b3VjaGFibGU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHg9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OlRzKCEhdCksbik6eH0sbi5leHRlbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KF89XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OlRzKFtbK3RbMF1bMF0sK3RbMF1bMV1dLFsrdFsxXVswXSwrdFsxXVsxXV1dKSxuKTpffSxuLnNjYWxlRXh0ZW50PWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhiWzBdPSt0WzBdLGJbMV09K3RbMV0sbik6W2JbMF0sYlsxXV19LG4udHJhbnNsYXRlRXh0ZW50PWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh3WzBdWzBdPSt0WzBdWzBdLHdbMV1bMF09K3RbMV1bMF0sd1swXVsxXT0rdFswXVsxXSx3WzFdWzFdPSt0WzFdWzFdLG4pOltbd1swXVswXSx3WzBdWzFdXSxbd1sxXVswXSx3WzFdWzFdXV19LG4uY29uc3RyYWluPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh5PXQsbik6eX0sbi5kdXJhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oTT0rdCxuKTpNfSxuLmludGVycG9sYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhUPXQsbik6VH0sbi5vbj1mdW5jdGlvbigpe3ZhciB0PVMub24uYXBwbHkoUyxhcmd1bWVudHMpO3JldHVybiB0PT09Uz9uOnR9LG4uY2xpY2tEaXN0YW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oQz0odD0rdCkqdCxuKTpNYXRoLnNxcnQoQyl9LG59LHQuem9vbVRyYW5zZm9ybT1rcyx0Lnpvb21JZGVudGl0eT1GXyxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pOyIsIiMgVE9ETzogUmVuYW1lIHRoaXMgY2xhc3Mgc28gdGhlcmUgYXJlbid0IG5hbWVzcGFjZSBjb25mbGljdHMuXG5jbGFzcyBUZXh0TGF5ZXIgZXh0ZW5kcyBMYXllclxuXHRcdFxuXHRjb25zdHJ1Y3RvcjogKG9wdGlvbnM9e30pIC0+XG5cdFx0QGRvQXV0b1NpemUgPSBmYWxzZVxuXHRcdEBkb0F1dG9TaXplSGVpZ2h0ID0gZmFsc2Vcblx0XHRvcHRpb25zLmJhY2tncm91bmRDb2xvciA/PSBpZiBvcHRpb25zLnNldHVwIHRoZW4gXCJoc2xhKDYwLCA5MCUsIDQ3JSwgLjQpXCIgZWxzZSBcInRyYW5zcGFyZW50XCJcblx0XHRvcHRpb25zLmNvbG9yID89IFwicmVkXCJcblx0XHRvcHRpb25zLmxpbmVIZWlnaHQgPz0gMS4yNVxuXHRcdG9wdGlvbnMuZm9udEZhbWlseSA/PSBcIkhlbHZldGljYVwiXG5cdFx0b3B0aW9ucy5mb250U2l6ZSA/PSAyMFxuXHRcdG9wdGlvbnMudGV4dCA/PSBcIlVzZSBsYXllci50ZXh0IHRvIGFkZCB0ZXh0XCJcblx0XHRzdXBlciBvcHRpb25zXG5cdFx0QHN0eWxlLndoaXRlU3BhY2UgPSBcInByZS1saW5lXCIgIyBhbGxvdyBcXG4gaW4gLnRleHRcblx0XHRAc3R5bGUub3V0bGluZSA9IFwibm9uZVwiICMgbm8gYm9yZGVyIHdoZW4gc2VsZWN0ZWRcblx0XHRcblx0c2V0U3R5bGU6IChwcm9wZXJ0eSwgdmFsdWUsIHB4U3VmZml4ID0gZmFsc2UpIC0+XG5cdFx0QHN0eWxlW3Byb3BlcnR5XSA9IGlmIHB4U3VmZml4IHRoZW4gdmFsdWUrXCJweFwiIGVsc2UgdmFsdWVcblx0XHRAZW1pdChcImNoYW5nZToje3Byb3BlcnR5fVwiLCB2YWx1ZSlcblx0XHRpZiBAZG9BdXRvU2l6ZSB0aGVuIEBjYWxjU2l6ZSgpXG5cdFx0XG5cdGNhbGNTaXplOiAtPlxuXHRcdHNpemVBZmZlY3RpbmdTdHlsZXMgPVxuXHRcdFx0bGluZUhlaWdodDogQHN0eWxlW1wibGluZS1oZWlnaHRcIl1cblx0XHRcdGZvbnRTaXplOiBAc3R5bGVbXCJmb250LXNpemVcIl1cblx0XHRcdGZvbnRXZWlnaHQ6IEBzdHlsZVtcImZvbnQtd2VpZ2h0XCJdXG5cdFx0XHRwYWRkaW5nVG9wOiBAc3R5bGVbXCJwYWRkaW5nLXRvcFwiXVxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBAc3R5bGVbXCJwYWRkaW5nLXJpZ2h0XCJdXG5cdFx0XHRwYWRkaW5nQm90dG9tOiBAc3R5bGVbXCJwYWRkaW5nLWJvdHRvbVwiXVxuXHRcdFx0cGFkZGluZ0xlZnQ6IEBzdHlsZVtcInBhZGRpbmctbGVmdFwiXVxuXHRcdFx0dGV4dFRyYW5zZm9ybTogQHN0eWxlW1widGV4dC10cmFuc2Zvcm1cIl1cblx0XHRcdGJvcmRlcldpZHRoOiBAc3R5bGVbXCJib3JkZXItd2lkdGhcIl1cblx0XHRcdGxldHRlclNwYWNpbmc6IEBzdHlsZVtcImxldHRlci1zcGFjaW5nXCJdXG5cdFx0XHRmb250RmFtaWx5OiBAc3R5bGVbXCJmb250LWZhbWlseVwiXVxuXHRcdFx0Zm9udFN0eWxlOiBAc3R5bGVbXCJmb250LXN0eWxlXCJdXG5cdFx0XHRmb250VmFyaWFudDogQHN0eWxlW1wiZm9udC12YXJpYW50XCJdXG5cdFx0Y29uc3RyYWludHMgPSB7fVxuXHRcdGlmIEBkb0F1dG9TaXplSGVpZ2h0IHRoZW4gY29uc3RyYWludHMud2lkdGggPSBAd2lkdGhcblx0XHRzaXplID0gVXRpbHMudGV4dFNpemUgQHRleHQsIHNpemVBZmZlY3RpbmdTdHlsZXMsIGNvbnN0cmFpbnRzXG5cdFx0aWYgQHN0eWxlLnRleHRBbGlnbiBpcyBcInJpZ2h0XCJcblx0XHRcdEB3aWR0aCA9IHNpemUud2lkdGhcblx0XHRcdEB4ID0gQHgtQHdpZHRoXG5cdFx0ZWxzZVxuXHRcdFx0QHdpZHRoID0gc2l6ZS53aWR0aFxuXHRcdEBoZWlnaHQgPSBzaXplLmhlaWdodFxuXG5cdEBkZWZpbmUgXCJhdXRvU2l6ZVwiLFxuXHRcdGdldDogLT4gQGRvQXV0b1NpemVcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gXG5cdFx0XHRAZG9BdXRvU2l6ZSA9IHZhbHVlXG5cdFx0XHRpZiBAZG9BdXRvU2l6ZSB0aGVuIEBjYWxjU2l6ZSgpXG5cdEBkZWZpbmUgXCJhdXRvU2l6ZUhlaWdodFwiLFxuXHRcdHNldDogKHZhbHVlKSAtPiBcblx0XHRcdEBkb0F1dG9TaXplID0gdmFsdWVcblx0XHRcdEBkb0F1dG9TaXplSGVpZ2h0ID0gdmFsdWVcblx0XHRcdGlmIEBkb0F1dG9TaXplIHRoZW4gQGNhbGNTaXplKClcblx0QGRlZmluZSBcImNvbnRlbnRFZGl0YWJsZVwiLFxuXHRcdHNldDogKGJvb2xlYW4pIC0+XG5cdFx0XHRAX2VsZW1lbnQuY29udGVudEVkaXRhYmxlID0gYm9vbGVhblxuXHRcdFx0QGlnbm9yZUV2ZW50cyA9ICFib29sZWFuXG5cdFx0XHRAb24gXCJpbnB1dFwiLCAtPiBAY2FsY1NpemUoKSBpZiBAZG9BdXRvU2l6ZVxuXHRAZGVmaW5lIFwidGV4dFwiLFxuXHRcdGdldDogLT4gQF9lbGVtZW50LnRleHRDb250ZW50XG5cdFx0c2V0OiAodmFsdWUpIC0+XG5cdFx0XHRAX2VsZW1lbnQudGV4dENvbnRlbnQgPSB2YWx1ZVxuXHRcdFx0QGVtaXQoXCJjaGFuZ2U6dGV4dFwiLCB2YWx1ZSlcblx0XHRcdGlmIEBkb0F1dG9TaXplIHRoZW4gQGNhbGNTaXplKClcblx0QGRlZmluZSBcImZvbnRGYW1pbHlcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUuZm9udEZhbWlseVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJmb250RmFtaWx5XCIsIHZhbHVlKVxuXHRAZGVmaW5lIFwiZm9udFNpemVcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUuZm9udFNpemUucmVwbGFjZShcInB4XCIsXCJcIilcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwiZm9udFNpemVcIiwgdmFsdWUsIHRydWUpXG5cdEBkZWZpbmUgXCJsaW5lSGVpZ2h0XCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLmxpbmVIZWlnaHQgXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcImxpbmVIZWlnaHRcIiwgdmFsdWUpXG5cdEBkZWZpbmUgXCJmb250V2VpZ2h0XCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLmZvbnRXZWlnaHQgXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcImZvbnRXZWlnaHRcIiwgdmFsdWUpXG5cdEBkZWZpbmUgXCJmb250U3R5bGVcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUuZm9udFN0eWxlXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcImZvbnRTdHlsZVwiLCB2YWx1ZSlcblx0QGRlZmluZSBcImZvbnRWYXJpYW50XCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLmZvbnRWYXJpYW50XG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcImZvbnRWYXJpYW50XCIsIHZhbHVlKVxuXHRAZGVmaW5lIFwicGFkZGluZ1wiLFxuXHRcdHNldDogKHZhbHVlKSAtPiBcblx0XHRcdEBzZXRTdHlsZShcInBhZGRpbmdUb3BcIiwgdmFsdWUsIHRydWUpXG5cdFx0XHRAc2V0U3R5bGUoXCJwYWRkaW5nUmlnaHRcIiwgdmFsdWUsIHRydWUpXG5cdFx0XHRAc2V0U3R5bGUoXCJwYWRkaW5nQm90dG9tXCIsIHZhbHVlLCB0cnVlKVxuXHRcdFx0QHNldFN0eWxlKFwicGFkZGluZ0xlZnRcIiwgdmFsdWUsIHRydWUpXG5cdEBkZWZpbmUgXCJwYWRkaW5nVG9wXCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLnBhZGRpbmdUb3AucmVwbGFjZShcInB4XCIsXCJcIilcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwicGFkZGluZ1RvcFwiLCB2YWx1ZSwgdHJ1ZSlcblx0QGRlZmluZSBcInBhZGRpbmdSaWdodFwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5wYWRkaW5nUmlnaHQucmVwbGFjZShcInB4XCIsXCJcIilcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwicGFkZGluZ1JpZ2h0XCIsIHZhbHVlLCB0cnVlKVxuXHRAZGVmaW5lIFwicGFkZGluZ0JvdHRvbVwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5wYWRkaW5nQm90dG9tLnJlcGxhY2UoXCJweFwiLFwiXCIpXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcInBhZGRpbmdCb3R0b21cIiwgdmFsdWUsIHRydWUpXG5cdEBkZWZpbmUgXCJwYWRkaW5nTGVmdFwiLFxuXHRcdGdldDogLT4gQHN0eWxlLnBhZGRpbmdMZWZ0LnJlcGxhY2UoXCJweFwiLFwiXCIpXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcInBhZGRpbmdMZWZ0XCIsIHZhbHVlLCB0cnVlKVxuXHRAZGVmaW5lIFwidGV4dEFsaWduXCIsXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcInRleHRBbGlnblwiLCB2YWx1ZSlcblx0QGRlZmluZSBcInRleHRUcmFuc2Zvcm1cIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUudGV4dFRyYW5zZm9ybSBcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwidGV4dFRyYW5zZm9ybVwiLCB2YWx1ZSlcblx0QGRlZmluZSBcImxldHRlclNwYWNpbmdcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUubGV0dGVyU3BhY2luZy5yZXBsYWNlKFwicHhcIixcIlwiKVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJsZXR0ZXJTcGFjaW5nXCIsIHZhbHVlLCB0cnVlKVxuXHRAZGVmaW5lIFwibGVuZ3RoXCIsIFxuXHRcdGdldDogLT4gQHRleHQubGVuZ3RoXG5cbmNvbnZlcnRUb1RleHRMYXllciA9IChsYXllciwgZGVidWcpIC0+XG5cblx0IyBDcmVhdGUgYSB0ZXh0IGxheWVyIHdpdGggYWxsIHRoZSBiYXNpYyBwcm9wZXJ0aWVzLlxuXHR0ID0gbmV3IFRleHRMYXllclxuXHRcdG5hbWU6IGxheWVyLm5hbWVcblx0XHRmcmFtZTogbGF5ZXIuZnJhbWVcblx0XHRwYXJlbnQ6IGxheWVyLnBhcmVudFxuXHRcdHRleHQ6IGxheWVyLl9pbmZvLm1ldGFkYXRhLnN0cmluZ1xuXG5cdCMgT2JqZWN0IGZvciBzdHlsZSBwcm9wcy5cblx0c3R5bGVPYmogPSB7fVxuXHRcblx0IyBHZXQgQ1NTIGZyb20gbWV0YWRhdGEuXG5cdGNzcyA9IGxheWVyLl9pbmZvLm1ldGFkYXRhLmNzc1xuXG5cdCMgR28gdGhyb3VnaCBlYWNoIHJ1bGVcblx0Y3NzLmZvckVhY2ggKHJ1bGUpIC0+XG5cblx0XHQjIERpdGNoIHRoZSBkdW1iIGxheWVyIG5hbWUuXG5cdFx0cmV0dXJuIGlmIF8uaW5jbHVkZXMgcnVsZSwgJy8qJ1xuXHRcdFxuXHRcdCMgU3BsaXQgdGhlIGtleSBhbmQgdmFsdWUgb3V0XG5cdFx0YXJyID0gcnVsZS5zcGxpdCgnOiAnKVxuXHRcdFxuXHRcdCNGb3JtYXQgdGhlIGtleSBhbmQgdmFsdWUgcHJvcGVybHlcblx0XHRwcm9wID0gXy5jYW1lbENhc2UoYXJyWzBdKVxuXHRcdHZhbHVlID0gYXJyWzFdLnJlcGxhY2UoJzsnLCcnKVxuXHRcdFxuXHRcdCNDb252ZXJ0IHRvIG51bWJlcnMgZm9yIG51bWVyaWMgcHJvcGVydGllc1xuXHRcdGlmIFtcImZvbnRTaXplXCIsXCJsZXR0ZXJTcGFjaW5nXCIsXCJsaW5lSGVpZ2h0XCJdLmluZGV4T2YocHJvcCkgPiAtMVxuXHRcdFx0dmFsdWUgPSBwYXJzZUludCh2YWx1ZSkgXG5cblx0XHQjIFNldCB0aGUga2V5IGFuZCB2YWx1ZSBpbiBzdHlsZU9ialxuXHRcdHN0eWxlT2JqW3Byb3BdID0gdmFsdWVcblx0XHRcblx0IyBTZXQgdGhlIGxpbmUtaGVpZ2h0IGFzIGEgcHJvcG9ydGlvbiBpbnN0ZWFkIG9mIHBpeGVsIHZhbHVlLlxuXHRpZiBzdHlsZU9iai5oYXNPd25Qcm9wZXJ0eShcImxpbmVIZWlnaHRcIilcblx0XHRzdHlsZU9ialtcImxpbmVIZWlnaHRcIl0gPSAgc3R5bGVPYmoubGluZUhlaWdodCAvIHN0eWxlT2JqLmZvbnRTaXplXG5cdGVsc2Vcblx0XHRzdHlsZU9ialtcImxpbmVIZWlnaHRcIl0gPSAxLjNcbiBcdFx0IyBUT0RPOiBGaW5kIGEgd2F5IHRvIHByb3Blcmx5IHNldCB0ZXh0IGxpbmUtaGVpZ2h0IGZvciBhdXRvIHZhbHVlcyBpbiBTa2V0Y2guXG4gXHRcdCMgQ3VycmVudGx5IGF1dG8gbGluZS1oZWlnaHRzIHZhcnkgYnkgZm9udCwgc28gdGhpcyBpcyBqdXN0IHNldHRpbmcgYSBmYWxsYmFjayBhcmJpdHJhcmlseS5cblx0XG5cdFxuXHQjIFNldCB0aGUgcHJvcGVydGllcyBmb3IgZXZlcnkga2V5IGluIHN0eWxlT2JqXG5cdGZvciBrZXksIHZhbCBvZiBzdHlsZU9ialxuXHRcdHRba2V5XSA9IHZhbFxuXG5cdCMgT2Zmc2V0cyB0byBjb21wZW5zYXRlIGZvciBTa2V0Y2gncyBwYWRkaW5nLlxuXHR0LnkgLT0gKHQuZm9udFNpemUgLyB0LmxpbmVIZWlnaHQpIC8gKDQgLSB0LmxpbmVIZWlnaHQpXG5cdHQueCAtPSB0LmZvbnRTaXplICogMC4wN1xuXHR0LndpZHRoICs9IHQuZm9udFNpemUgKiAwLjVcblxuXHQjIFNldCB1cCBkZWJ1ZzogaWYgdHJ1ZSwgaXQgZG9lc24ndCBkZXN0cm95IHRoZSBsYXllciBzbyB5b3UgY2FuXG5cdCMgbWFudWFsbHkgcG9zaXRpb24gbGluZS1oZWlnaHQgYW5kIHN0dWZmLiAgSGVscGZ1bC5cblx0aWYgZGVidWcgdGhlbiBsYXllci5vcGFjaXR5ID0gLjUgZWxzZSBsYXllci5kZXN0cm95KClcblx0XG5cdHJldHVybiB0XG5cbkxheWVyOjpjb252ZXJ0VG9UZXh0TGF5ZXIgPSAoZGVidWcpIC0+IGNvbnZlcnRUb1RleHRMYXllcihALCBkZWJ1ZylcblxuY29udmVydFRleHRMYXllcnMgPSAob2JqLCBkZWJ1ZykgLT5cblx0Zm9yIHByb3AsbGF5ZXIgb2Ygb2JqXG5cdFx0aWYgbGF5ZXIuX2luZm8ua2luZCBpcyBcInRleHRcIlxuXHRcdFx0b2JqW3Byb3BdID0gY29udmVydFRvVGV4dExheWVyKGxheWVyLCBkZWJ1ZylcblxuXG4jIEJhY2t3YXJkcyBjb21wYWJpbGl0eS4gUmVwbGFjZWQgYnkgY29udmVydFRvVGV4dExheWVyKClcbkxheWVyOjpmcmFtZUFzVGV4dExheWVyID0gKHByb3BlcnRpZXMpIC0+XG4gICAgdCA9IG5ldyBUZXh0TGF5ZXJcbiAgICB0LmZyYW1lID0gQGZyYW1lXG4gICAgdC5zdXBlckxheWVyID0gQHN1cGVyTGF5ZXJcbiAgICBfLmV4dGVuZCB0LHByb3BlcnRpZXNcbiAgICBAZGVzdHJveSgpXG4gICAgdFxuXG5leHBvcnRzLlRleHRMYXllciA9IFRleHRMYXllclxuZXhwb3J0cy5jb252ZXJ0VGV4dExheWVycyA9IGNvbnZlcnRUZXh0TGF5ZXJzXG4iLCIvLyBGaWxlOnNyYy9UaHJlZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIFRIUkVFID0ge1xuICAgIFJFVklTSU9OOiAnNzInXG59O1xuXG4vL1xuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblxuICAgIGRlZmluZSggJ3RocmVlJywgVEhSRUUgKTtcblxufVxuZWxzZSBpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZXhwb3J0cyAmJiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSApIHtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XG5cbn1cblxuXG4vLyBwb2x5ZmlsbHNcblxuaWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkIHx8IHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIC8vIE1pc3NpbmcgaW4gQW5kcm9pZCBzdG9jayBicm93c2VyLlxuXG4gICAgKCBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgICAgICB2YXIgdmVuZG9ycyA9IFsgJ21zJywgJ21veicsICd3ZWJraXQnLCAnbycgXTtcblxuICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCApIHtcblxuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuICAgICAgICAgICAgc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxBbmltYXRpb25GcmFtZScgXSB8fCBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgJiYgc2VsZi5zZXRUaW1lb3V0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJUaW1lID0gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XG5cbiAgICAgICAgICAgICAgICB9LCB0aW1lVG9DYWxsICk7XG4gICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCAmJiBzZWxmLmNsZWFyVGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGlkICkge1xuXG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQoIGlkICk7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgfSgpICk7XG5cbn1cblxuaWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxuXG4gICAgTWF0aC5zaWduID0gZnVuY3Rpb24oIHggKSB7XG5cbiAgICAgICAgcmV0dXJuICggeCA8IDAgKSA/IC0xIDogKCB4ID4gMCApID8gMSA6ICt4O1xuXG4gICAgfTtcblxufVxuXG5pZiAoIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSB1bmRlZmluZWQgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAvLyBNaXNzaW5nIGluIElFOS0xMS5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS5tYXRjaCggL15cXHMqZnVuY3Rpb25cXHMqKFxcUyopXFxzKlxcKC8gKVsgMSBdO1xuXG4gICAgICAgIH1cblxuICAgIH0gKTtcblxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC5idXR0b25cblxuVEhSRUUuTU9VU0UgPSB7XG4gICAgTEVGVDogMCxcbiAgICBNSURETEU6IDEsXG4gICAgUklHSFQ6IDJcbn07XG5cbi8vIEdMIFNUQVRFIENPTlNUQU5UU1xuXG5USFJFRS5DdWxsRmFjZU5vbmUgPSAwO1xuVEhSRUUuQ3VsbEZhY2VCYWNrID0gMTtcblRIUkVFLkN1bGxGYWNlRnJvbnQgPSAyO1xuVEhSRUUuQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuXG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DQ1cgPSAxO1xuXG4vLyBTSEFET1dJTkcgVFlQRVNcblxuVEhSRUUuQmFzaWNTaGFkb3dNYXAgPSAwO1xuVEhSRUUuUENGU2hhZG93TWFwID0gMTtcblRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgPSAyO1xuXG4vLyBNQVRFUklBTCBDT05TVEFOVFNcblxuLy8gc2lkZVxuXG5USFJFRS5Gcm9udFNpZGUgPSAwO1xuVEhSRUUuQmFja1NpZGUgPSAxO1xuVEhSRUUuRG91YmxlU2lkZSA9IDI7XG5cbi8vIHNoYWRpbmdcblxuVEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xuVEhSRUUuU21vb3RoU2hhZGluZyA9IDI7XG5cbi8vIGNvbG9yc1xuXG5USFJFRS5Ob0NvbG9ycyA9IDA7XG5USFJFRS5GYWNlQ29sb3JzID0gMTtcblRIUkVFLlZlcnRleENvbG9ycyA9IDI7XG5cbi8vIGJsZW5kaW5nIG1vZGVzXG5cblRIUkVFLk5vQmxlbmRpbmcgPSAwO1xuVEhSRUUuTm9ybWFsQmxlbmRpbmcgPSAxO1xuVEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5USFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcblRIUkVFLk11bHRpcGx5QmxlbmRpbmcgPSA0O1xuVEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgZXF1YXRpb25zXG4vLyAobnVtYmVycyBzdGFydCBmcm9tIDEwMCBub3QgdG8gY2xhc2ggd2l0aCBvdGhlclxuLy8gbWFwcGluZ3MgdG8gT3BlbkdMIGNvbnN0YW50cyBkZWZpbmVkIGluIFRleHR1cmUuanMpXG5cblRIUkVFLkFkZEVxdWF0aW9uID0gMTAwO1xuVEhSRUUuU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcblRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuVEhSRUUuTWluRXF1YXRpb24gPSAxMDM7XG5USFJFRS5NYXhFcXVhdGlvbiA9IDEwNDtcblxuLy8gY3VzdG9tIGJsZW5kaW5nIGRlc3RpbmF0aW9uIGZhY3RvcnNcblxuVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcblRIUkVFLk9uZUZhY3RvciA9IDIwMTtcblRIUkVFLlNyY0NvbG9yRmFjdG9yID0gMjAyO1xuVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcblRIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xuVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcblRIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xuVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcblxuLy8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXG5cbi8vVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcbi8vVEhSRUUuT25lRmFjdG9yID0gMjAxO1xuLy9USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcbi8vVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcbi8vVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG4vL1RIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5USFJFRS5Ec3RDb2xvckZhY3RvciA9IDIwODtcblRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG5USFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xuXG4vLyBkZXB0aCBtb2Rlc1xuXG5USFJFRS5OZXZlckRlcHRoID0gMDtcblRIUkVFLkFsd2F5c0RlcHRoID0gMTtcblRIUkVFLkxlc3NEZXB0aCA9IDI7XG5USFJFRS5MZXNzRXF1YWxEZXB0aCA9IDM7XG5USFJFRS5FcXVhbERlcHRoID0gNDtcblRIUkVFLkdyZWF0ZXJFcXVhbERlcHRoID0gNTtcblRIUkVFLkdyZWF0ZXJEZXB0aCA9IDY7XG5USFJFRS5Ob3RFcXVhbERlcHRoID0gNztcblxuXG4vLyBURVhUVVJFIENPTlNUQU5UU1xuXG5USFJFRS5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xuVEhSRUUuQWRkT3BlcmF0aW9uID0gMjtcblxuLy8gTWFwcGluZyBtb2Rlc1xuXG5USFJFRS5VVk1hcHBpbmcgPSAzMDA7XG5cblRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcblRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcblxuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcblxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDU7XG5cbi8vIFdyYXBwaW5nIG1vZGVzXG5cblRIUkVFLlJlcGVhdFdyYXBwaW5nID0gMTAwMDtcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG5cbi8vIEZpbHRlcnNcblxuVEhSRUUuTmVhcmVzdEZpbHRlciA9IDEwMDM7XG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcblRIUkVFLkxpbmVhckZpbHRlciA9IDEwMDY7XG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcblRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5cbi8vIERhdGEgdHlwZXNcblxuVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XG5USFJFRS5TaG9ydFR5cGUgPSAxMDExO1xuVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuVEhSRUUuSW50VHlwZSA9IDEwMTM7XG5USFJFRS5VbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuVEhSRUUuRmxvYXRUeXBlID0gMTAxNTtcblRIUkVFLkhhbGZGbG9hdFR5cGUgPSAxMDI1O1xuXG4vLyBQaXhlbCB0eXBlc1xuXG4vL1RIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNjtcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTc7XG5USFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTg7XG5cbi8vIFBpeGVsIGZvcm1hdHNcblxuVEhSRUUuQWxwaGFGb3JtYXQgPSAxMDE5O1xuVEhSRUUuUkdCRm9ybWF0ID0gMTAyMDtcblRIUkVFLlJHQkFGb3JtYXQgPSAxMDIxO1xuVEhSRUUuTHVtaW5hbmNlRm9ybWF0ID0gMTAyMjtcblRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyMztcbi8vIFRIUkVFLlJHQkVGb3JtYXQgaGFuZGxlZCBhcyBUSFJFRS5SR0JBRm9ybWF0IGluIHNoYWRlcnNcblRIUkVFLlJHQkVGb3JtYXQgPSBUSFJFRS5SR0JBRm9ybWF0OyAvLzEwMjQ7XG5cbi8vIEREUyAvIFNUM0MgQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcblRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xuXG5cbi8vIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXG5cblRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcblRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcblRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XG5USFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xuXG5cbi8vIERFUFJFQ0FURURcblxuVEhSRUUuUHJvamVjdG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLicgKTtcblxuICAgIHRoaXMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci5wcm9qZWN0KCkuJyApO1xuICAgICAgICB2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XG4gICAgICAgIHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xuXG4gICAgfTtcblxuICAgIHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yOiAucGlja2luZ1JheSgpIGlzIG5vdyByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSgpLicgKTtcblxuICAgIH07XG5cbn07XG5cblRIUkVFLkNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQ2FudmFzUmVuZGVyZXIgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9DYW52YXNSZW5kZXJlci5qcycgKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24oKSB7fTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9Db2xvci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ29sb3IgPSBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0UkdCKCBhcmd1bWVudHNbIDAgXSwgYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoIGNvbG9yICk7XG5cbn07XG5cblRIUkVFLkNvbG9yLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Db2xvcixcblxuICAgIHI6IDEsXG4gICAgZzogMSxcbiAgICBiOiAxLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xuXG4gICAgICAgICAgICB0aGlzLmNvcHkoIHZhbHVlICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRIZXgoIHZhbHVlICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0SGV4OiBmdW5jdGlvbiggaGV4ICkge1xuXG4gICAgICAgIGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xuXG4gICAgICAgIHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG4gICAgICAgIHRoaXMuZyA9ICggaGV4ID4+IDggJiAyNTUgKSAvIDI1NTtcbiAgICAgICAgdGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRSR0I6IGZ1bmN0aW9uKCByLCBnLCBiICkge1xuXG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgIHRoaXMuYiA9IGI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0SFNMOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xuXG4gICAgICAgICAgICBpZiAoIHQgPCAwICkgdCArPSAxO1xuICAgICAgICAgICAgaWYgKCB0ID4gMSApIHQgLT0gMTtcbiAgICAgICAgICAgIGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcbiAgICAgICAgICAgIGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XG4gICAgICAgICAgICBpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XG4gICAgICAgICAgICByZXR1cm4gcDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBoLCBzLCBsICkge1xuXG4gICAgICAgICAgICAvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuICAgICAgICAgICAgaCA9IFRIUkVFLk1hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XG4gICAgICAgICAgICBzID0gVEhSRUUuTWF0aC5jbGFtcCggcywgMCwgMSApO1xuICAgICAgICAgICAgbCA9IFRIUkVFLk1hdGguY2xhbXAoIGwsIDAsIDEgKTtcblxuICAgICAgICAgICAgaWYgKCBzID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuICAgICAgICAgICAgICAgIHZhciBxID0gKCAyICogbCApIC0gcDtcblxuICAgICAgICAgICAgICAgIHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xuICAgICAgICAgICAgICAgIHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcbiAgICAgICAgICAgICAgICB0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uKCBzdHlsZSApIHtcblxuICAgICAgICB2YXIgcGFyc2VBbHBoYSA9IGZ1bmN0aW9uKCBzdHJBbHBoYSApIHtcblxuICAgICAgICAgICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdCggc3RyQWxwaGEgKTtcblxuICAgICAgICAgICAgaWYgKCBhbHBoYSA8IDEgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWxwaGE7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIG07XG5cbiAgICAgICAgaWYgKCBtID0gL14oKD86cmdifGhzbClhPylcXChcXHMqKFteXFwpXSopXFwpLy5leGVjKCBzdHlsZSApICkge1xuXG4gICAgICAgICAgICAvLyByZ2IgLyBoc2xcblxuICAgICAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBtWyAxIF07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1bIDIgXTtcblxuICAgICAgICAgICAgc3dpdGNoICggbmFtZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYic6XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmdiKDI1NSwwLDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZ2IoMTAwJSwwJSwwJSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmdiYSgyNTUsMCwwLDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQWxwaGEoIGNvbG9yWyA0IF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29sb3IgPSAvXihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUFscGhhKCBjb2xvclsgNCBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFswLTldKlxcLj9bMC05XSspXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHNsKDEyMCw1MCUsNTAlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSAvIDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsYSc6XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFswLTldKlxcLj9bMC05XSspXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHNsYSgxMjAsNTAlLDUwJSwwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VBbHBoYSggY29sb3JbIDQgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtID0gL15cXCMoW0EtRmEtZjAtOV0rKSQvLmV4ZWMoIHN0eWxlICkgKSB7XG5cbiAgICAgICAgICAgIC8vIGhleCBjb2xvclxuXG4gICAgICAgICAgICB2YXIgaGV4ID0gbVsgMSBdO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBoZXgubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIHNpemUgPT09IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAjZmYwXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xuICAgICAgICAgICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIHNpemUgPT09IDYgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAjZmYwMDAwXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMyApLCAxNiApIC8gMjU1O1xuICAgICAgICAgICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCA0ICkgKyBoZXguY2hhckF0KCA1ICksIDE2ICkgLyAyNTU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbG9yIGtleXdvcmRzXG4gICAgICAgICAgICB2YXIgaGV4ID0gVEhSRUUuQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXTtcblxuICAgICAgICAgICAgaWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIC8vIHJlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGV4KCBoZXggKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyB1bmtub3duIGNvbG9yXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgICAgICB0aGlzLnIgPSBjb2xvci5yO1xuICAgICAgICB0aGlzLmcgPSBjb2xvci5nO1xuICAgICAgICB0aGlzLmIgPSBjb2xvci5iO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG4gICAgICAgIGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG4gICAgICAgIHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xuICAgICAgICB0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcbiAgICAgICAgdGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIGdhbW1hRmFjdG9yICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XG5cbiAgICAgICAgaWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cbiAgICAgICAgdmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcblxuICAgICAgICB0aGlzLnIgPSBNYXRoLnBvdyggY29sb3Iuciwgc2FmZUludmVyc2UgKTtcbiAgICAgICAgdGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIHNhZmVJbnZlcnNlICk7XG4gICAgICAgIHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgciA9IHRoaXMucixcbiAgICAgICAgICAgIGcgPSB0aGlzLmcsXG4gICAgICAgICAgICBiID0gdGhpcy5iO1xuXG4gICAgICAgIHRoaXMuciA9IHIgKiByO1xuICAgICAgICB0aGlzLmcgPSBnICogZztcbiAgICAgICAgdGhpcy5iID0gYiAqIGI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XG4gICAgICAgIHRoaXMuZyA9IE1hdGguc3FydCggdGhpcy5nICk7XG4gICAgICAgIHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0SGV4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gKCB0aGlzLnIgKiAyNTUgKSA8PCAxNiBeICggdGhpcy5nICogMjU1ICkgPDwgOCBeICggdGhpcy5iICogMjU1ICkgPDwgMDtcblxuICAgIH0sXG5cbiAgICBnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtNiApO1xuXG4gICAgfSxcblxuICAgIGdldEhTTDogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cbiAgICAgICAgdmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHtcbiAgICAgICAgICAgIGg6IDAsXG4gICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgbDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByID0gdGhpcy5yLFxuICAgICAgICAgICAgZyA9IHRoaXMuZyxcbiAgICAgICAgICAgIGIgPSB0aGlzLmI7XG5cbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xuXG4gICAgICAgIHZhciBodWUsIHNhdHVyYXRpb247XG4gICAgICAgIHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xuXG4gICAgICAgIGlmICggbWluID09PSBtYXggKSB7XG5cbiAgICAgICAgICAgIGh1ZSA9IDA7XG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gMDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cbiAgICAgICAgICAgIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcblxuICAgICAgICAgICAgc3dpdGNoICggbWF4ICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgICAgICAgICBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICAgICAgICAgIGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgICAgICAgICBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh1ZSAvPSA2O1xuXG4gICAgICAgIH1cblxuICAgICAgICBoc2wuaCA9IGh1ZTtcbiAgICAgICAgaHNsLnMgPSBzYXR1cmF0aW9uO1xuICAgICAgICBoc2wubCA9IGxpZ2h0bmVzcztcblxuICAgICAgICByZXR1cm4gaHNsO1xuXG4gICAgfSxcblxuICAgIGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xuXG4gICAgfSxcblxuICAgIG9mZnNldEhTTDogZnVuY3Rpb24oIGgsIHMsIGwgKSB7XG5cbiAgICAgICAgdmFyIGhzbCA9IHRoaXMuZ2V0SFNMKCk7XG5cbiAgICAgICAgaHNsLmggKz0gaDtcbiAgICAgICAgaHNsLnMgKz0gcztcbiAgICAgICAgaHNsLmwgKz0gbDtcblxuICAgICAgICB0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oIGNvbG9yICkge1xuXG4gICAgICAgIHRoaXMuciArPSBjb2xvci5yO1xuICAgICAgICB0aGlzLmcgKz0gY29sb3IuZztcbiAgICAgICAgdGhpcy5iICs9IGNvbG9yLmI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkQ29sb3JzOiBmdW5jdGlvbiggY29sb3IxLCBjb2xvcjIgKSB7XG5cbiAgICAgICAgdGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcbiAgICAgICAgdGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcbiAgICAgICAgdGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMuciArPSBzO1xuICAgICAgICB0aGlzLmcgKz0gcztcbiAgICAgICAgdGhpcy5iICs9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgICAgICB0aGlzLnIgKj0gY29sb3IucjtcbiAgICAgICAgdGhpcy5nICo9IGNvbG9yLmc7XG4gICAgICAgIHRoaXMuYiAqPSBjb2xvci5iO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnIgKj0gcztcbiAgICAgICAgdGhpcy5nICo9IHM7XG4gICAgICAgIHRoaXMuYiAqPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxlcnA6IGZ1bmN0aW9uKCBjb2xvciwgYWxwaGEgKSB7XG5cbiAgICAgICAgdGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XG4gICAgICAgIHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xuICAgICAgICB0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBjICkge1xuXG4gICAgICAgIHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSApIHtcblxuICAgICAgICB0aGlzLnIgPSBhcnJheVsgMCBdO1xuICAgICAgICB0aGlzLmcgPSBhcnJheVsgMSBdO1xuICAgICAgICB0aGlzLmIgPSBhcnJheVsgMiBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkNvbG9yS2V5d29yZHMgPSB7XG4gICAgJ2FsaWNlYmx1ZSc6IDB4RjBGOEZGLFxuICAgICdhbnRpcXVld2hpdGUnOiAweEZBRUJENyxcbiAgICAnYXF1YSc6IDB4MDBGRkZGLFxuICAgICdhcXVhbWFyaW5lJzogMHg3RkZGRDQsXG4gICAgJ2F6dXJlJzogMHhGMEZGRkYsXG4gICAgJ2JlaWdlJzogMHhGNUY1REMsXG4gICAgJ2Jpc3F1ZSc6IDB4RkZFNEM0LFxuICAgICdibGFjayc6IDB4MDAwMDAwLFxuICAgICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELFxuICAgICdibHVlJzogMHgwMDAwRkYsXG4gICAgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcbiAgICAnYnJvd24nOiAweEE1MkEyQSxcbiAgICAnYnVybHl3b29kJzogMHhERUI4ODcsXG4gICAgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLFxuICAgICdjaGFydHJldXNlJzogMHg3RkZGMDAsXG4gICAgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLFxuICAgICdjb3JhbCc6IDB4RkY3RjUwLFxuICAgICdjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELFxuICAgICdjb3Juc2lsayc6IDB4RkZGOERDLFxuICAgICdjcmltc29uJzogMHhEQzE0M0MsXG4gICAgJ2N5YW4nOiAweDAwRkZGRixcbiAgICAnZGFya2JsdWUnOiAweDAwMDA4QixcbiAgICAnZGFya2N5YW4nOiAweDAwOEI4QixcbiAgICAnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLFxuICAgICdkYXJrZ3JheSc6IDB4QTlBOUE5LFxuICAgICdkYXJrZ3JlZW4nOiAweDAwNjQwMCxcbiAgICAnZGFya2dyZXknOiAweEE5QTlBOSxcbiAgICAnZGFya2toYWtpJzogMHhCREI3NkIsXG4gICAgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG4gICAgJ2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsXG4gICAgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCxcbiAgICAnZGFya29yY2hpZCc6IDB4OTkzMkNDLFxuICAgICdkYXJrcmVkJzogMHg4QjAwMDAsXG4gICAgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSxcbiAgICAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXG4gICAgJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QixcbiAgICAnZGFya3NsYXRlZ3JheSc6IDB4MkY0RjRGLFxuICAgICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsXG4gICAgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSxcbiAgICAnZGFya3Zpb2xldCc6IDB4OTQwMEQzLFxuICAgICdkZWVwcGluayc6IDB4RkYxNDkzLFxuICAgICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLFxuICAgICdkaW1ncmF5JzogMHg2OTY5NjksXG4gICAgJ2RpbWdyZXknOiAweDY5Njk2OSxcbiAgICAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLFxuICAgICdmaXJlYnJpY2snOiAweEIyMjIyMixcbiAgICAnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCxcbiAgICAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMixcbiAgICAnZnVjaHNpYSc6IDB4RkYwMEZGLFxuICAgICdnYWluc2Jvcm8nOiAweERDRENEQyxcbiAgICAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLFxuICAgICdnb2xkJzogMHhGRkQ3MDAsXG4gICAgJ2dvbGRlbnJvZCc6IDB4REFBNTIwLFxuICAgICdncmF5JzogMHg4MDgwODAsXG4gICAgJ2dyZWVuJzogMHgwMDgwMDAsXG4gICAgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsXG4gICAgJ2dyZXknOiAweDgwODA4MCxcbiAgICAnaG9uZXlkZXcnOiAweEYwRkZGMCxcbiAgICAnaG90cGluayc6IDB4RkY2OUI0LFxuICAgICdpbmRpYW5yZWQnOiAweENENUM1QyxcbiAgICAnaW5kaWdvJzogMHg0QjAwODIsXG4gICAgJ2l2b3J5JzogMHhGRkZGRjAsXG4gICAgJ2toYWtpJzogMHhGMEU2OEMsXG4gICAgJ2xhdmVuZGVyJzogMHhFNkU2RkEsXG4gICAgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSxcbiAgICAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXG4gICAgJ2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELFxuICAgICdsaWdodGJsdWUnOiAweEFERDhFNixcbiAgICAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLFxuICAgICdsaWdodGN5YW4nOiAweEUwRkZGRixcbiAgICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMixcbiAgICAnbGlnaHRncmF5JzogMHhEM0QzRDMsXG4gICAgJ2xpZ2h0Z3JlZW4nOiAweDkwRUU5MCxcbiAgICAnbGlnaHRncmV5JzogMHhEM0QzRDMsXG4gICAgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLFxuICAgICdsaWdodHNhbG1vbic6IDB4RkZBMDdBLFxuICAgICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsXG4gICAgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuICAgICdsaWdodHNsYXRlZ3JheSc6IDB4Nzc4ODk5LFxuICAgICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LFxuICAgICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLFxuICAgICdsaWdodHllbGxvdyc6IDB4RkZGRkUwLFxuICAgICdsaW1lJzogMHgwMEZGMDAsXG4gICAgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxuICAgICdsaW5lbic6IDB4RkFGMEU2LFxuICAgICdtYWdlbnRhJzogMHhGRjAwRkYsXG4gICAgJ21hcm9vbic6IDB4ODAwMDAwLFxuICAgICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsXG4gICAgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCxcbiAgICAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXG4gICAgJ21lZGl1bXB1cnBsZSc6IDB4OTM3MERCLFxuICAgICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLFxuICAgICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSxcbiAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiAweDAwRkE5QSxcbiAgICAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG4gICAgJ21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LFxuICAgICdtaWRuaWdodGJsdWUnOiAweDE5MTk3MCxcbiAgICAnbWludGNyZWFtJzogMHhGNUZGRkEsXG4gICAgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLFxuICAgICdtb2NjYXNpbic6IDB4RkZFNEI1LFxuICAgICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuICAgICduYXZ5JzogMHgwMDAwODAsXG4gICAgJ29sZGxhY2UnOiAweEZERjVFNixcbiAgICAnb2xpdmUnOiAweDgwODAwMCxcbiAgICAnb2xpdmVkcmFiJzogMHg2QjhFMjMsXG4gICAgJ29yYW5nZSc6IDB4RkZBNTAwLFxuICAgICdvcmFuZ2VyZWQnOiAweEZGNDUwMCxcbiAgICAnb3JjaGlkJzogMHhEQTcwRDYsXG4gICAgJ3BhbGVnb2xkZW5yb2QnOiAweEVFRThBQSxcbiAgICAncGFsZWdyZWVuJzogMHg5OEZCOTgsXG4gICAgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSxcbiAgICAncGFsZXZpb2xldHJlZCc6IDB4REI3MDkzLFxuICAgICdwYXBheWF3aGlwJzogMHhGRkVGRDUsXG4gICAgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuICAgICdwZXJ1JzogMHhDRDg1M0YsXG4gICAgJ3BpbmsnOiAweEZGQzBDQixcbiAgICAncGx1bSc6IDB4RERBMERELFxuICAgICdwb3dkZXJibHVlJzogMHhCMEUwRTYsXG4gICAgJ3B1cnBsZSc6IDB4ODAwMDgwLFxuICAgICdyZWQnOiAweEZGMDAwMCxcbiAgICAncm9zeWJyb3duJzogMHhCQzhGOEYsXG4gICAgJ3JveWFsYmx1ZSc6IDB4NDE2OUUxLFxuICAgICdzYWRkbGVicm93bic6IDB4OEI0NTEzLFxuICAgICdzYWxtb24nOiAweEZBODA3MixcbiAgICAnc2FuZHlicm93bic6IDB4RjRBNDYwLFxuICAgICdzZWFncmVlbic6IDB4MkU4QjU3LFxuICAgICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxuICAgICdzaWVubmEnOiAweEEwNTIyRCxcbiAgICAnc2lsdmVyJzogMHhDMEMwQzAsXG4gICAgJ3NreWJsdWUnOiAweDg3Q0VFQixcbiAgICAnc2xhdGVibHVlJzogMHg2QTVBQ0QsXG4gICAgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLFxuICAgICdzbGF0ZWdyZXknOiAweDcwODA5MCxcbiAgICAnc25vdyc6IDB4RkZGQUZBLFxuICAgICdzcHJpbmdncmVlbic6IDB4MDBGRjdGLFxuICAgICdzdGVlbGJsdWUnOiAweDQ2ODJCNCxcbiAgICAndGFuJzogMHhEMkI0OEMsXG4gICAgJ3RlYWwnOiAweDAwODA4MCxcbiAgICAndGhpc3RsZSc6IDB4RDhCRkQ4LFxuICAgICd0b21hdG8nOiAweEZGNjM0NyxcbiAgICAndHVycXVvaXNlJzogMHg0MEUwRDAsXG4gICAgJ3Zpb2xldCc6IDB4RUU4MkVFLFxuICAgICd3aGVhdCc6IDB4RjVERUIzLFxuICAgICd3aGl0ZSc6IDB4RkZGRkZGLFxuICAgICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsXG4gICAgJ3llbGxvdyc6IDB4RkZGRjAwLFxuICAgICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1F1YXRlcm5pb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUXVhdGVybmlvbiA9IGZ1bmN0aW9uKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgdGhpcy5feCA9IHggfHwgMDtcbiAgICB0aGlzLl95ID0geSB8fCAwO1xuICAgIHRoaXMuX3ogPSB6IHx8IDA7XG4gICAgdGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufTtcblxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbixcblxuICAgIGdldCB4KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuXG4gICAgfSxcblxuICAgIHNldCB4KCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIGdldCB5KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuXG4gICAgfSxcblxuICAgIHNldCB5KCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIGdldCB6KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl96O1xuXG4gICAgfSxcblxuICAgIHNldCB6KCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl96ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIGdldCB3KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl93O1xuXG4gICAgfSxcblxuICAgIHNldCB3KCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl93ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oIHgsIHksIHosIHcgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl96ID0gejtcbiAgICAgICAgdGhpcy5fdyA9IHc7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBxdWF0ZXJuaW9uICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG4gICAgICAgIHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG4gICAgICAgIHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG4gICAgICAgIHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbUV1bGVyOiBmdW5jdGlvbiggZXVsZXIsIHVwZGF0ZSApIHtcblxuICAgICAgICBpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuICAgICAgICAvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuICAgICAgICAvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cbiAgICAgICAgdmFyIGMxID0gTWF0aC5jb3MoIGV1bGVyLl94IC8gMiApO1xuICAgICAgICB2YXIgYzIgPSBNYXRoLmNvcyggZXVsZXIuX3kgLyAyICk7XG4gICAgICAgIHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcbiAgICAgICAgdmFyIHMxID0gTWF0aC5zaW4oIGV1bGVyLl94IC8gMiApO1xuICAgICAgICB2YXIgczIgPSBNYXRoLnNpbiggZXVsZXIuX3kgLyAyICk7XG4gICAgICAgIHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcblxuICAgICAgICB2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcblxuICAgICAgICBpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG4gICAgICAgIC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cbiAgICAgICAgdmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMixcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cbiAgICAgICAgdGhpcy5feCA9IGF4aXMueCAqIHM7XG4gICAgICAgIHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuICAgICAgICB0aGlzLl96ID0gYXhpcy56ICogcztcbiAgICAgICAgdGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cbiAgICAgICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgICAgICB2YXIgdGUgPSBtLmVsZW1lbnRzLFxuXG4gICAgICAgICAgICBtMTEgPSB0ZVsgMCBdLFxuICAgICAgICAgICAgbTEyID0gdGVbIDQgXSxcbiAgICAgICAgICAgIG0xMyA9IHRlWyA4IF0sXG4gICAgICAgICAgICBtMjEgPSB0ZVsgMSBdLFxuICAgICAgICAgICAgbTIyID0gdGVbIDUgXSxcbiAgICAgICAgICAgIG0yMyA9IHRlWyA5IF0sXG4gICAgICAgICAgICBtMzEgPSB0ZVsgMiBdLFxuICAgICAgICAgICAgbTMyID0gdGVbIDYgXSxcbiAgICAgICAgICAgIG0zMyA9IHRlWyAxMCBdLFxuXG4gICAgICAgICAgICB0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcbiAgICAgICAgICAgIHM7XG5cbiAgICAgICAgaWYgKCB0cmFjZSA+IDAgKSB7XG5cbiAgICAgICAgICAgIHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3cgPSAwLjI1IC8gcztcbiAgICAgICAgICAgIHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcbiAgICAgICAgICAgIHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcbiAgICAgICAgICAgIHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG4gICAgICAgICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuICAgICAgICAgICAgdGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuICAgICAgICAgICAgdGhpcy5feCA9IDAuMjUgKiBzO1xuICAgICAgICAgICAgdGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuICAgICAgICAgICAgdGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcblxuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcbiAgICAgICAgICAgIHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwLjI1ICogcztcbiAgICAgICAgICAgIHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuICAgICAgICAgICAgdGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuICAgICAgICAgICAgdGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuICAgICAgICAgICAgdGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuICAgICAgICAgICAgdGhpcy5feiA9IDAuMjUgKiBzO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuICAgICAgICAvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuICAgICAgICB2YXIgdjEsIHI7XG5cbiAgICAgICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggdkZyb20sIHZUbyApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cbiAgICAgICAgICAgIGlmICggciA8IEVQUyApIHtcblxuICAgICAgICAgICAgICAgIHIgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2MS5zZXQoIC12RnJvbS55LCB2RnJvbS54LCAwICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdjEuc2V0KCAwLCAtdkZyb20ueiwgdkZyb20ueSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSB2MS54O1xuICAgICAgICAgICAgdGhpcy5feSA9IHYxLnk7XG4gICAgICAgICAgICB0aGlzLl96ID0gdjEuejtcbiAgICAgICAgICAgIHRoaXMuX3cgPSByO1xuXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICB9KCksXG5cbiAgICBpbnZlcnNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbmp1Z2F0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5feCAqPSAtMTtcbiAgICAgICAgdGhpcy5feSAqPSAtMTtcbiAgICAgICAgdGhpcy5feiAqPSAtMTtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkb3Q6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuICAgIH0sXG5cbiAgICBsZW5ndGhTcTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcblxuICAgIH0sXG5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBsID0gdGhpcy5sZW5ndGgoKTtcblxuICAgICAgICBpZiAoIGwgPT09IDAgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3cgPSAxO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGwgPSAxIC8gbDtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuICAgICAgICAgICAgdGhpcy5feSA9IHRoaXMuX3kgKiBsO1xuICAgICAgICAgICAgdGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuICAgICAgICAgICAgdGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oIHEsIHAgKSB7XG5cbiAgICAgICAgaWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG4gICAgICAgIHZhciBxYXggPSBhLl94LFxuICAgICAgICAgICAgcWF5ID0gYS5feSxcbiAgICAgICAgICAgIHFheiA9IGEuX3osXG4gICAgICAgICAgICBxYXcgPSBhLl93O1xuICAgICAgICB2YXIgcWJ4ID0gYi5feCxcbiAgICAgICAgICAgIHFieSA9IGIuX3ksXG4gICAgICAgICAgICBxYnogPSBiLl96LFxuICAgICAgICAgICAgcWJ3ID0gYi5fdztcblxuICAgICAgICB0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuICAgICAgICB0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuICAgICAgICB0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuICAgICAgICB0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgc2xlcnA6IGZ1bmN0aW9uKCBxYiwgdCApIHtcblxuICAgICAgICBpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuICAgICAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgICAgIHogPSB0aGlzLl96LFxuICAgICAgICAgICAgdyA9IHRoaXMuX3c7XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuICAgICAgICB2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG4gICAgICAgIGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcblxuICAgICAgICAgICAgdGhpcy5fdyA9IC1xYi5fdztcbiAgICAgICAgICAgIHRoaXMuX3ggPSAtcWIuX3g7XG4gICAgICAgICAgICB0aGlzLl95ID0gLXFiLl95O1xuICAgICAgICAgICAgdGhpcy5feiA9IC1xYi5fejtcblxuICAgICAgICAgICAgY29zSGFsZlRoZXRhID0gLWNvc0hhbGZUaGV0YTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmNvcHkoIHFiICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuICAgICAgICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgdGhpcy5feiA9IHo7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFsZlRoZXRhID0gTWF0aC5hY29zKCBjb3NIYWxmVGhldGEgKTtcbiAgICAgICAgdmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cbiAgICAgICAgaWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcblxuICAgICAgICAgICAgdGhpcy5fdyA9IDAuNSAqICggdyArIHRoaXMuX3cgKTtcbiAgICAgICAgICAgIHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XG4gICAgICAgICAgICB0aGlzLl95ID0gMC41ICogKCB5ICsgdGhpcy5feSApO1xuICAgICAgICAgICAgdGhpcy5feiA9IDAuNSAqICggeiArIHRoaXMuX3ogKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG4gICAgICAgICAgICByYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG4gICAgICAgIHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG4gICAgICAgIHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XG4gICAgICAgIHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XG4gICAgICAgIHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggcXVhdGVybmlvbiApIHtcblxuICAgICAgICByZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgICAgICB0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICAgICAgdGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG4gICAgICAgIHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgb25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24oKSB7fVxuXG59O1xuXG5USFJFRS5RdWF0ZXJuaW9uLnNsZXJwID0gZnVuY3Rpb24oIHFhLCBxYiwgcW0sIHQgKSB7XG5cbiAgICByZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiggeCwgeSApIHtcblxuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjIsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB4LCB5ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24oIHggKSB7XG5cbiAgICAgICAgdGhpcy54ID0geDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRZOiBmdW5jdGlvbiggeSApIHtcblxuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24oIGluZGV4LCB2YWx1ZSApIHtcblxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHM7XG4gICAgICAgIHRoaXMueSArPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55ICsgYi55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24oIHYsIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHYueCAqIHM7XG4gICAgICAgIHRoaXMueSArPSB2LnkgKiBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YjogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViU2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnggLT0gcztcbiAgICAgICAgdGhpcy55IC09IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViVmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gYS54IC0gYi54O1xuICAgICAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHRoaXMueCAqPSB2Lng7XG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMueCAqPSBzO1xuICAgICAgICB0aGlzLnkgKj0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiggc2NhbGFyICkge1xuXG4gICAgICAgIGlmICggc2NhbGFyICE9PSAwICkge1xuXG4gICAgICAgICAgICB2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuICAgICAgICAgICAgdGhpcy54ICo9IGludlNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueSAqPSBpbnZTY2FsYXI7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1pbjogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPiB2LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHYueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IHYueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBpZiAoIHRoaXMueCA8IHYueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA8IHYueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbGFtcDogZnVuY3Rpb24oIG1pbiwgbWF4ICkge1xuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gbWluLng7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IG1heC54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSBtaW4ueTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gbWF4Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsYW1wU2NhbGFyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWluLCBtYXg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgICAgICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgICAgICAgICAgbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xuICAgICAgICAgICAgbWF4LnNldCggbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGZsb29yOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2VpbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kVG9aZXJvOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbmVnYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRvdDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcblxuICAgIH0sXG5cbiAgICBsZW5ndGhTcTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcblxuICAgIH0sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xuXG4gICAgfSxcblxuICAgIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcblxuICAgIH0sXG5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB2YXIgZHggPSB0aGlzLnggLSB2LngsXG4gICAgICAgICAgICBkeSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG4gICAgfSxcblxuICAgIHNldExlbmd0aDogZnVuY3Rpb24oIGwgKSB7XG5cbiAgICAgICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICkge1xuXG4gICAgICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxlcnA6IGZ1bmN0aW9uKCB2LCBhbHBoYSApIHtcblxuICAgICAgICB0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgICAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxlcnBWZWN0b3JzOiBmdW5jdGlvbiggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgICAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICAgICAgdGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuICAgICAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yMy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yICpraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuVmVjdG9yMyA9IGZ1bmN0aW9uKCB4LCB5LCB6ICkge1xuXG4gICAgdGhpcy54ID0geCB8fCAwO1xuICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICB0aGlzLnogPSB6IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB4LCB5LCB6ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24oIHggKSB7XG5cbiAgICAgICAgdGhpcy54ID0geDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRZOiBmdW5jdGlvbiggeSApIHtcblxuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFo6IGZ1bmN0aW9uKCB6ICkge1xuXG4gICAgICAgIHRoaXMueiA9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiggaW5kZXgsIHZhbHVlICkge1xuXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy56ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLno7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICAgIHRoaXMueiArPSB2Lno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnggKz0gcztcbiAgICAgICAgdGhpcy55ICs9IHM7XG4gICAgICAgIHRoaXMueiArPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55ICsgYi55O1xuICAgICAgICB0aGlzLnogPSBhLnogKyBiLno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiggdiwgcyApIHtcblxuICAgICAgICB0aGlzLnggKz0gdi54ICogcztcbiAgICAgICAgdGhpcy55ICs9IHYueSAqIHM7XG4gICAgICAgIHRoaXMueiArPSB2LnogKiBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YjogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICAgIHRoaXMueiAtPSB2Lno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViU2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnggLT0gcztcbiAgICAgICAgdGhpcy55IC09IHM7XG4gICAgICAgIHRoaXMueiAtPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YlZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xuICAgICAgICB0aGlzLnogPSBhLnogLSBiLno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggKj0gdi54O1xuICAgICAgICB0aGlzLnkgKj0gdi55O1xuICAgICAgICB0aGlzLnogKj0gdi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiggc2NhbGFyICkge1xuXG4gICAgICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICAgIHRoaXMueiAqPSBzY2FsYXI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB0aGlzLnggPSBhLnggKiBiLng7XG4gICAgICAgIHRoaXMueSA9IGEueSAqIGIueTtcbiAgICAgICAgdGhpcy56ID0gYS56ICogYi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFwcGx5RXVsZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseUV1bGVyKCBldWxlciApIHtcblxuICAgICAgICAgICAgaWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHF1YXRlcm5pb247XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgYXBwbHlNYXRyaXgzOiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG4gICAgICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcbiAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXG4gICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgeSA9IHRoaXMueSxcbiAgICAgICAgICAgIHogPSB0aGlzLno7XG5cbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF07XG4gICAgICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF07XG4gICAgICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcblxuICAgICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgICAgICB6ID0gdGhpcy56O1xuXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcbiAgICAgICAgdmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcblxuICAgICAgICB0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIGQ7XG4gICAgICAgIHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogZDtcbiAgICAgICAgdGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogZDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uKCBxICkge1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICAgICAgdmFyIHF4ID0gcS54O1xuICAgICAgICB2YXIgcXkgPSBxLnk7XG4gICAgICAgIHZhciBxeiA9IHEuejtcbiAgICAgICAgdmFyIHF3ID0gcS53O1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cbiAgICAgICAgdmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgICAgICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgICAgIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgICAgICAgdmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgICAgICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICAgICAgdGhpcy55ID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICAgICAgdGhpcy56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBwcm9qZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWF0cml4O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwcm9qZWN0KCBjYW1lcmEgKSB7XG5cbiAgICAgICAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWF0cml4O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB1bnByb2plY3QoIGNhbWVyYSApIHtcblxuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcbiAgICAgICAgLy8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cbiAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICAgICAgeiA9IHRoaXMuejtcblxuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6O1xuICAgICAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHo7XG4gICAgICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cbiAgICAgICAgdGhpcy5ub3JtYWxpemUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XG4gICAgICAgIHRoaXMueiAvPSB2Lno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiggc2NhbGFyICkge1xuXG4gICAgICAgIGlmICggc2NhbGFyICE9PSAwICkge1xuXG4gICAgICAgICAgICB2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuICAgICAgICAgICAgdGhpcy54ICo9IGludlNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueSAqPSBpbnZTY2FsYXI7XG4gICAgICAgICAgICB0aGlzLnogKj0gaW52U2NhbGFyO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgdGhpcy56ID0gMDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBpZiAoIHRoaXMueCA+IHYueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA+IHYueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueiA+IHYueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGlmICggdGhpcy54IDwgdi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy56IDwgdi56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsYW1wOiBmdW5jdGlvbiggbWluLCBtYXggKSB7XG5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgICAgICBpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSBtaW4ueDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gbWF4Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IG1pbi55O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSBtYXgueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnogPCBtaW4ueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gbWluLno7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IG1heC56O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbGFtcFNjYWxhcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1pbiwgbWF4O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cbiAgICAgICAgICAgIGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuICAgICAgICAgICAgbWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZmxvb3I6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2VpbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICByb3VuZFRvWmVybzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgICAgIHRoaXMueiA9IC10aGlzLno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZG90OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aFNxOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xuXG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICB9LFxuXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbiggbCApIHtcblxuICAgICAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgICAgICBpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cbiAgICAgICAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVycDogZnVuY3Rpb24oIHYsIGFscGhhICkge1xuXG4gICAgICAgIHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG4gICAgICAgIHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG4gICAgICAgIHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNyb3NzOiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICAgICAgeiA9IHRoaXMuejtcblxuICAgICAgICB0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcbiAgICAgICAgdGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XG4gICAgICAgIHRoaXMueiA9IHggKiB2LnkgLSB5ICogdi54O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNyb3NzVmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdmFyIGF4ID0gYS54LFxuICAgICAgICAgICAgYXkgPSBhLnksXG4gICAgICAgICAgICBheiA9IGEuejtcbiAgICAgICAgdmFyIGJ4ID0gYi54LFxuICAgICAgICAgICAgYnkgPSBiLnksXG4gICAgICAgICAgICBieiA9IGIuejtcblxuICAgICAgICB0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICAgICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgICAgIHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxLCBkb3Q7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblZlY3RvciggdmVjdG9yICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHYxLmNvcHkoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICBkb3QgPSB0aGlzLmRvdCggdjEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHByb2plY3RPblBsYW5lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIoIHYxICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSgpLFxuXG4gICAgcmVmbGVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG4gICAgICAgIC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIoIHYxLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuICAgICAgICB9XG5cbiAgICB9KCksXG5cbiAgICBhbmdsZVRvOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xuXG4gICAgICAgIC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGhldGEsIC0xLCAxICkgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdi54O1xuICAgICAgICB2YXIgZHkgPSB0aGlzLnkgLSB2Lnk7XG4gICAgICAgIHZhciBkeiA9IHRoaXMueiAtIHYuejtcblxuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuXG4gICAgfSxcblxuICAgIHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiggbSwgb3JkZXIgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcblxuICAgIH0sXG5cbiAgICBzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiggcSwgb3JkZXIgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC4nICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xuXG4gICAgfSxcblxuICAgIGdldFNjYWxlRnJvbU1hdHJpeDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcblxuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiggaW5kZXgsIG1hdHJpeCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggaW5kZXgsIG1hdHJpeCApO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdGhpcy54ID0gbS5lbGVtZW50c1sgMTIgXTtcbiAgICAgICAgdGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcbiAgICAgICAgdGhpcy56ID0gbS5lbGVtZW50c1sgMTQgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgMiBdICkubGVuZ3RoKCk7XG4gICAgICAgIHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA0IF0sIG0uZWxlbWVudHNbIDUgXSwgbS5lbGVtZW50c1sgNiBdICkubGVuZ3RoKCk7XG4gICAgICAgIHZhciBzeiA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA4IF0sIG0uZWxlbWVudHNbIDkgXSwgbS5lbGVtZW50c1sgMTAgXSApLmxlbmd0aCgpO1xuXG4gICAgICAgIHRoaXMueCA9IHN4O1xuICAgICAgICB0aGlzLnkgPSBzeTtcbiAgICAgICAgdGhpcy56ID0gc3o7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24oIGluZGV4LCBtYXRyaXggKSB7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IGluZGV4ICogNDtcblxuICAgICAgICB2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy54ID0gbWVbIG9mZnNldCBdO1xuICAgICAgICB0aGlzLnkgPSBtZVsgb2Zmc2V0ICsgMSBdO1xuICAgICAgICB0aGlzLnogPSBtZVsgb2Zmc2V0ICsgMiBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICAgICAgdGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICAgICAgdGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuICAgICAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG4gICAgICAgIHRoaXMueiA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAyIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yNC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3I0ID0gZnVuY3Rpb24oIHgsIHksIHosIHcgKSB7XG5cbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICAgIHRoaXMueiA9IHogfHwgMDtcbiAgICB0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn07XG5cblRIUkVFLlZlY3RvcjQucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjQsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHRoaXMudyA9IHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24oIHggKSB7XG5cbiAgICAgICAgdGhpcy54ID0geDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRZOiBmdW5jdGlvbiggeSApIHtcblxuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFo6IGZ1bmN0aW9uKCB6ICkge1xuXG4gICAgICAgIHRoaXMueiA9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0VzogZnVuY3Rpb24oIHcgKSB7XG5cbiAgICAgICAgdGhpcy53ID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLnogPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLncgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuejtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgdGhpcy56ID0gdi56O1xuICAgICAgICB0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICAgIHRoaXMueiArPSB2Lno7XG4gICAgICAgIHRoaXMudyArPSB2Lnc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnggKz0gcztcbiAgICAgICAgdGhpcy55ICs9IHM7XG4gICAgICAgIHRoaXMueiArPSBzO1xuICAgICAgICB0aGlzLncgKz0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB0aGlzLnggPSBhLnggKyBiLng7XG4gICAgICAgIHRoaXMueSA9IGEueSArIGIueTtcbiAgICAgICAgdGhpcy56ID0gYS56ICsgYi56O1xuICAgICAgICB0aGlzLncgPSBhLncgKyBiLnc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiggdiwgcyApIHtcblxuICAgICAgICB0aGlzLnggKz0gdi54ICogcztcbiAgICAgICAgdGhpcy55ICs9IHYueSAqIHM7XG4gICAgICAgIHRoaXMueiArPSB2LnogKiBzO1xuICAgICAgICB0aGlzLncgKz0gdi53ICogcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWI6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuICAgICAgICB0aGlzLnogLT0gdi56O1xuICAgICAgICB0aGlzLncgLT0gdi53O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YlNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy54IC09IHM7XG4gICAgICAgIHRoaXMueSAtPSBzO1xuICAgICAgICB0aGlzLnogLT0gcztcbiAgICAgICAgdGhpcy53IC09IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViVmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gYS54IC0gYi54O1xuICAgICAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG4gICAgICAgIHRoaXMueiA9IGEueiAtIGIuejtcbiAgICAgICAgdGhpcy53ID0gYS53IC0gYi53O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiggc2NhbGFyICkge1xuXG4gICAgICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gICAgICAgIHRoaXMudyAqPSBzY2FsYXI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSAqIHc7XG4gICAgICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xuICAgICAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XG4gICAgICAgIHRoaXMudyA9IGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICogdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgaWYgKCBzY2FsYXIgIT09IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG4gICAgICAgICAgICB0aGlzLnggKj0gaW52U2NhbGFyO1xuICAgICAgICAgICAgdGhpcy55ICo9IGludlNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueiAqPSBpbnZTY2FsYXI7XG4gICAgICAgICAgICB0aGlzLncgKj0gaW52U2NhbGFyO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgdGhpcy56ID0gMDtcbiAgICAgICAgICAgIHRoaXMudyA9IDE7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiggcSApIHtcblxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cbiAgICAgICAgLy8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgICAgICB0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcblxuICAgICAgICB2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xuXG4gICAgICAgIGlmICggcyA8IDAuMDAwMSApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gMTtcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICB0aGlzLnogPSAwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHEueCAvIHM7XG4gICAgICAgICAgICB0aGlzLnkgPSBxLnkgLyBzO1xuICAgICAgICAgICAgdGhpcy56ID0gcS56IC8gcztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cblxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgICAgIHZhciBhbmdsZSwgeCwgeSwgeiwgLy8gdmFyaWFibGVzIGZvciByZXN1bHRcbiAgICAgICAgICAgIGVwc2lsb24gPSAwLjAxLCAvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xuICAgICAgICAgICAgZXBzaWxvbjIgPSAwLjEsIC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cbiAgICAgICAgICAgIHRlID0gbS5lbGVtZW50cyxcblxuICAgICAgICAgICAgbTExID0gdGVbIDAgXSxcbiAgICAgICAgICAgIG0xMiA9IHRlWyA0IF0sXG4gICAgICAgICAgICBtMTMgPSB0ZVsgOCBdLFxuICAgICAgICAgICAgbTIxID0gdGVbIDEgXSxcbiAgICAgICAgICAgIG0yMiA9IHRlWyA1IF0sXG4gICAgICAgICAgICBtMjMgPSB0ZVsgOSBdLFxuICAgICAgICAgICAgbTMxID0gdGVbIDIgXSxcbiAgICAgICAgICAgIG0zMiA9IHRlWyA2IF0sXG4gICAgICAgICAgICBtMzMgPSB0ZVsgMTAgXTtcblxuICAgICAgICBpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApICYmICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xuXG4gICAgICAgICAgICAvLyBzaW5ndWxhcml0eSBmb3VuZFxuICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuICAgICAgICAgICAgLy8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xuXG4gICAgICAgICAgICBpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKSAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yICkgJiYgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxuXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguUEk7XG5cbiAgICAgICAgICAgIHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcbiAgICAgICAgICAgIHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcbiAgICAgICAgICAgIHZhciB6eiA9ICggbTMzICsgMSApIC8gMjtcbiAgICAgICAgICAgIHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xuICAgICAgICAgICAgdmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XG4gICAgICAgICAgICB2YXIgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcblxuICAgICAgICAgICAgaWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cbiAgICAgICAgICAgICAgICBpZiAoIHh4IDwgZXBzaWxvbiApIHtcblxuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgICAgICAgICAgICB6ID0gMC43MDcxMDY3ODE7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGguc3FydCggeHggKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHh5IC8geDtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHh6IC8geDtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIHl5ID4genogKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG4gICAgICAgICAgICAgICAgaWYgKCB5eSA8IGVwc2lsb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoIHl5ICk7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4eSAvIHk7XG4gICAgICAgICAgICAgICAgICAgIHogPSB5eiAvIHk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xuXG4gICAgICAgICAgICAgICAgaWYgKCB6eiA8IGVwc2lsb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgICAgICAgICAgICB5ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgICAgICAgICAgIHogPSAwO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHogPSBNYXRoLnNxcnQoIHp6ICk7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4eiAvIHo7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5eiAvIHo7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XG5cbiAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApICsgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxICkgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG4gICAgICAgIGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XG5cbiAgICAgICAgLy8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxuICAgICAgICAvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuICAgICAgICB0aGlzLnggPSAoIG0zMiAtIG0yMyApIC8gcztcbiAgICAgICAgdGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG4gICAgICAgIHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xuICAgICAgICB0aGlzLncgPSBNYXRoLmFjb3MoICggbTExICsgbTIyICsgbTMzIC0gMSApIC8gMiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1pbjogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPiB2LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHYueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IHYueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnogPiB2LnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IHYuejtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLncgPiB2LncgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudyA9IHYudztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBpZiAoIHRoaXMueCA8IHYueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA8IHYueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueiA8IHYueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMudyA8IHYudyApIHtcblxuICAgICAgICAgICAgdGhpcy53ID0gdi53O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbGFtcDogZnVuY3Rpb24oIG1pbiwgbWF4ICkge1xuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gbWluLng7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IG1heC54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSBtaW4ueTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gbWF4Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy56IDwgbWluLnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IG1pbi56O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueiA+IG1heC56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSBtYXguejtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLncgPCBtaW4udyApIHtcblxuICAgICAgICAgICAgdGhpcy53ID0gbWluLnc7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy53ID4gbWF4LncgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudyA9IG1heC53O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbGFtcFNjYWxhcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1pbiwgbWF4O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cbiAgICAgICAgICAgIGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuICAgICAgICAgICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG4gICAgICAgICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGZsb29yOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjZWlsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICByb3VuZFRvWmVybzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcbiAgICAgICAgdGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbmVnYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgICB0aGlzLnogPSAtdGhpcy56O1xuICAgICAgICB0aGlzLncgPSAtdGhpcy53O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRvdDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcblxuICAgIH0sXG5cbiAgICBsZW5ndGhTcTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcblxuICAgIH0sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG4gICAgfSxcblxuICAgIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKSArIE1hdGguYWJzKCB0aGlzLncgKTtcblxuICAgIH0sXG5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gICAgfSxcblxuICAgIHNldExlbmd0aDogZnVuY3Rpb24oIGwgKSB7XG5cbiAgICAgICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICkge1xuXG4gICAgICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxlcnA6IGZ1bmN0aW9uKCB2LCBhbHBoYSApIHtcblxuICAgICAgICB0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgICAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuICAgICAgICB0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuICAgICAgICB0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxlcnBWZWN0b3JzOiBmdW5jdGlvbiggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgICAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgICAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgICAgICB0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuICAgICAgICB0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24oIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcbiAgICAgICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcbiAgICAgICAgdGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcbiAgICAgICAgdGhpcy53ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDMgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9FdWxlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkV1bGVyID0gZnVuY3Rpb24oIHgsIHksIHosIG9yZGVyICkge1xuXG4gICAgdGhpcy5feCA9IHggfHwgMDtcbiAgICB0aGlzLl95ID0geSB8fCAwO1xuICAgIHRoaXMuX3ogPSB6IHx8IDA7XG4gICAgdGhpcy5fb3JkZXIgPSBvcmRlciB8fCBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXI7XG5cbn07XG5cblRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XG5cblRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuXG5USFJFRS5FdWxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRXVsZXIsXG5cbiAgICBnZXQgeCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5feDtcblxuICAgIH0sXG5cbiAgICBzZXQgeCggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBnZXQgeSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5feTtcblxuICAgIH0sXG5cbiAgICBzZXQgeSggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBnZXQgeigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fejtcblxuICAgIH0sXG5cbiAgICBzZXQgeiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5feiA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBnZXQgb3JkZXIoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGVyO1xuXG4gICAgfSxcblxuICAgIHNldCBvcmRlciggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5fb3JkZXIgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiggeCwgeSwgeiwgb3JkZXIgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl96ID0gejtcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBldWxlciApIHtcblxuICAgICAgICB0aGlzLl94ID0gZXVsZXIuX3g7XG4gICAgICAgIHRoaXMuX3kgPSBldWxlci5feTtcbiAgICAgICAgdGhpcy5feiA9IGV1bGVyLl96O1xuICAgICAgICB0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uKCBtLCBvcmRlciwgdXBkYXRlICkge1xuXG4gICAgICAgIHZhciBjbGFtcCA9IFRIUkVFLk1hdGguY2xhbXA7XG5cbiAgICAgICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgICAgICB2YXIgdGUgPSBtLmVsZW1lbnRzO1xuICAgICAgICB2YXIgbTExID0gdGVbIDAgXSxcbiAgICAgICAgICAgIG0xMiA9IHRlWyA0IF0sXG4gICAgICAgICAgICBtMTMgPSB0ZVsgOCBdO1xuICAgICAgICB2YXIgbTIxID0gdGVbIDEgXSxcbiAgICAgICAgICAgIG0yMiA9IHRlWyA1IF0sXG4gICAgICAgICAgICBtMjMgPSB0ZVsgOSBdO1xuICAgICAgICB2YXIgbTMxID0gdGVbIDIgXSxcbiAgICAgICAgICAgIG0zMiA9IHRlWyA2IF0sXG4gICAgICAgICAgICBtMzMgPSB0ZVsgMTAgXTtcblxuICAgICAgICBvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG4gICAgICAgIGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtMSwgMSApICk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtbTIzLCBtMzMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLW0xMiwgbTExICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oIC1jbGFtcCggbTIzLCAtMSwgMSApICk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtbTMxLCBtMTEgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLTEsIDEgKSApO1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLW0zMSwgbTMzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIC1tMTIsIG0yMiApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hc2luKCAtY2xhbXAoIG0zMSwgLTEsIDEgKSApO1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLW0xMiwgbTIyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0xLCAxICkgKTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC1tMjMsIG0yMiApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtbTMxLCBtMTEgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXNpbiggLWNsYW1wKCBtMTIsIC0xLCAxICkgKTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC1tMjMsIG0zMyApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyIClcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuICAgICAgICBpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hdHJpeDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgICAgICAgbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG4gICAgICAgICAgICB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24oIHYsIG9yZGVyICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcblxuICAgIH0sXG5cbiAgICByZW9yZGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cbiAgICAgICAgdmFyIHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggbmV3T3JkZXIgKSB7XG5cbiAgICAgICAgICAgIHEuc2V0RnJvbUV1bGVyKCB0aGlzICk7XG4gICAgICAgICAgICB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBldWxlciApIHtcblxuICAgICAgICByZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IGFycmF5WyAwIF07XG4gICAgICAgIHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuICAgICAgICB0aGlzLl96ID0gYXJyYXlbIDIgXTtcbiAgICAgICAgaWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIHRvVmVjdG9yMzogZnVuY3Rpb24oIG9wdGlvbmFsUmVzdWx0ICkge1xuXG4gICAgICAgIGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbigpIHt9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTGluZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5MaW5lMyA9IGZ1bmN0aW9uKCBzdGFydCwgZW5kICkge1xuXG4gICAgdGhpcy5zdGFydCA9ICggc3RhcnQgIT09IHVuZGVmaW5lZCApID8gc3RhcnQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuTGluZTMucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkxpbmUzLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggc3RhcnQsIGVuZCApIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LmNvcHkoIHN0YXJ0ICk7XG4gICAgICAgIHRoaXMuZW5kLmNvcHkoIGVuZCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIGxpbmUgKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG4gICAgICAgIHRoaXMuZW5kLmNvcHkoIGxpbmUuZW5kICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2VudGVyOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICB9LFxuXG4gICAgZGVsdGE6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlU3E6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xuXG4gICAgfSxcblxuICAgIGF0OiBmdW5jdGlvbiggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XG5cbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0UCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBzdGFydEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XG5cbiAgICAgICAgICAgIHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuICAgICAgICAgICAgc3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcbiAgICAgICAgICAgIHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG4gICAgICAgICAgICB2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcblxuICAgICAgICAgICAgaWYgKCBjbGFtcFRvTGluZSApIHtcblxuICAgICAgICAgICAgICAgIHQgPSBUSFJFRS5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHQ7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uKCBtYXRyaXggKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuICAgICAgICB0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIGxpbmUgKSB7XG5cbiAgICAgICAgcmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKCB0aGlzLnN0YXJ0ICkgJiYgbGluZS5lbmQuZXF1YWxzKCB0aGlzLmVuZCApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0JveDIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5Cb3gyID0gZnVuY3Rpb24oIG1pbiwgbWF4ICkge1xuXG4gICAgdGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMiggSW5maW5pdHksIEluZmluaXR5ICk7XG4gICAgdGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVEhSRUUuVmVjdG9yMiggLUluZmluaXR5LCAtSW5maW5pdHkgKTtcblxufTtcblxuVEhSRUUuQm94Mi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQm94MixcblxuICAgIHNldDogZnVuY3Rpb24oIG1pbiwgbWF4ICkge1xuXG4gICAgICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgICAgICB0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiggcG9pbnRzICkge1xuXG4gICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBjZW50ZXIsIHNpemUgKSB7XG5cbiAgICAgICAgICAgIHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG4gICAgICAgICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgICAgICAgICB0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgdGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuICAgICAgICB0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZUVtcHR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC1JbmZpbml0eTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuICAgICAgICByZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcblxuICAgIH0sXG5cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICB9LFxuXG4gICAgc2l6ZTogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG4gICAgfSxcblxuICAgIGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICB0aGlzLm1pbi5taW4oIHBvaW50ICk7XG4gICAgICAgIHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICB0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuICAgICAgICB0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiggc2NhbGFyICkge1xuXG4gICAgICAgIHRoaXMubWluLmFkZFNjYWxhciggLXNjYWxhciApO1xuICAgICAgICB0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICBpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBjb250YWluc0JveDogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICBpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcbiAgICAgICAgICAgICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG4gICAgICAgIC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksICggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxuICAgICAgICApO1xuXG4gICAgfSxcblxuICAgIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG4gICAgICAgIGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9LFxuXG4gICAgY2xhbXBQb2ludDogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICAgICAgdmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGludGVyc2VjdDogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICB0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcbiAgICAgICAgdGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdW5pb246IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgdGhpcy5taW4ubWluKCBib3gubWluICk7XG4gICAgICAgIHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oIG9mZnNldCApIHtcblxuICAgICAgICB0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuICAgICAgICB0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICByZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uKCBtaW4sIG1heCApIHtcblxuICAgIHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjMoIEluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHkgKTtcbiAgICB0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDMucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJveDMsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBtaW4sIG1heCApIHtcblxuICAgICAgICB0aGlzLm1pbi5jb3B5KCBtaW4gKTtcbiAgICAgICAgdGhpcy5tYXguY29weSggbWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVBvaW50czogZnVuY3Rpb24oIHBvaW50cyApIHtcblxuICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGNlbnRlciwgc2l6ZSApIHtcblxuICAgICAgICAgICAgdmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICAgICAgICAgICAgdGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuICAgICAgICAgICAgdGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgc2V0RnJvbU9iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcbiAgICAgICAgLy8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICAgICAgb2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgICAgIG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24oIG5vZGUgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuY29weSggdmVydGljZXNbIGkgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXS5hcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcbiAgICAgICAgdGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VFbXB0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC1JbmZpbml0eTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuICAgICAgICByZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cbiAgICB9LFxuXG4gICAgY2VudGVyOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuICAgIH0sXG5cbiAgICBleHBhbmRCeVBvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgdGhpcy5taW4ubWluKCBwb2ludCApO1xuICAgICAgICB0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgdGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcbiAgICAgICAgdGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24oIHNjYWxhciApIHtcblxuICAgICAgICB0aGlzLm1pbi5hZGRTY2FsYXIoIC1zY2FsYXIgKTtcbiAgICAgICAgdGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgaWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcbiAgICAgICAgICAgIHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSxcblxuICAgIGNvbnRhaW5zQm94OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxuICAgICAgICAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSAmJlxuICAgICAgICAgICAgKCB0aGlzLm1pbi56IDw9IGJveC5taW4ueiApICYmICggYm94Lm1heC56IDw9IHRoaXMubWF4LnogKSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH0sXG5cbiAgICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgLy8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcbiAgICAgICAgLy8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldChcbiAgICAgICAgICAgICggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSwgKCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLCAoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcbiAgICAgICAgKTtcblxuICAgIH0sXG5cbiAgICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICAvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuICAgICAgICBpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XG4gICAgICAgICAgICBib3gubWF4LnogPCB0aGlzLm1pbi56IHx8IGJveC5taW4ueiA+IHRoaXMubWF4LnogKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9LFxuXG4gICAgY2xhbXBQb2ludDogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICAgICAgdmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0LnJhZGl1cyA9IHRoaXMuc2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuICAgICAgICB0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB1bmlvbjogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICB0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcbiAgICAgICAgdGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG1hdHJpeCApIHtcblxuICAgICAgICAgICAgLy8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcbiAgICAgICAgICAgIHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuICAgICAgICAgICAgcG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG4gICAgICAgICAgICBwb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcbiAgICAgICAgICAgIHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuICAgICAgICAgICAgcG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG4gICAgICAgICAgICBwb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcbiAgICAgICAgICAgIHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuICAgICAgICAgICAgcG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTExXG5cbiAgICAgICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG4gICAgICAgICAgICB0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiggb2Zmc2V0ICkge1xuXG4gICAgICAgIHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG4gICAgICAgIHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9NYXRyaXgzLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuTWF0cml4MyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblxuICAgICAgICAxLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLFxuICAgICAgICAwLCAwLCAxXG5cbiAgICBdICk7XG5cbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTWF0cml4My5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4MyxcblxuICAgIHNldDogZnVuY3Rpb24oIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0ZVsgMCBdID0gbjExO1xuICAgICAgICB0ZVsgMyBdID0gbjEyO1xuICAgICAgICB0ZVsgNiBdID0gbjEzO1xuICAgICAgICB0ZVsgMSBdID0gbjIxO1xuICAgICAgICB0ZVsgNCBdID0gbjIyO1xuICAgICAgICB0ZVsgNyBdID0gbjIzO1xuICAgICAgICB0ZVsgMiBdID0gbjMxO1xuICAgICAgICB0ZVsgNSBdID0gbjMyO1xuICAgICAgICB0ZVsgOCBdID0gbjMzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGlkZW50aXR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgMSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDEsIDAsXG4gICAgICAgICAgICAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgbWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcbiAgICAgICAgICAgIG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sXG4gICAgICAgICAgICBtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24oIGEgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICB2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgdjEudG9BcnJheSggYXJyYXksIGogKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpKyssIGorKyApIHtcblxuICAgICAgICAgICAgICAgIHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuICAgICAgICAgICAgICAgIHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xuICAgICAgICAgICAgICAgIHYxLnogPSBidWZmZXIuZ2V0WiggaiApO1xuXG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdGVbIDAgXSAqPSBzO1xuICAgICAgICB0ZVsgMyBdICo9IHM7XG4gICAgICAgIHRlWyA2IF0gKj0gcztcbiAgICAgICAgdGVbIDEgXSAqPSBzO1xuICAgICAgICB0ZVsgNCBdICo9IHM7XG4gICAgICAgIHRlWyA3IF0gKj0gcztcbiAgICAgICAgdGVbIDIgXSAqPSBzO1xuICAgICAgICB0ZVsgNSBdICo9IHM7XG4gICAgICAgIHRlWyA4IF0gKj0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkZXRlcm1pbmFudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB2YXIgYSA9IHRlWyAwIF0sXG4gICAgICAgICAgICBiID0gdGVbIDEgXSxcbiAgICAgICAgICAgIGMgPSB0ZVsgMiBdLFxuICAgICAgICAgICAgZCA9IHRlWyAzIF0sXG4gICAgICAgICAgICBlID0gdGVbIDQgXSxcbiAgICAgICAgICAgIGYgPSB0ZVsgNSBdLFxuICAgICAgICAgICAgZyA9IHRlWyA2IF0sXG4gICAgICAgICAgICBoID0gdGVbIDcgXSxcbiAgICAgICAgICAgIGkgPSB0ZVsgOCBdO1xuXG4gICAgICAgIHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XG5cbiAgICB9LFxuXG4gICAgZ2V0SW52ZXJzZTogZnVuY3Rpb24oIG1hdHJpeCwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcbiAgICAgICAgLy8gKCBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2ViZ2wtbWpzLyApXG5cbiAgICAgICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRlWyAwIF0gPSBtZVsgMTAgXSAqIG1lWyA1IF0gLSBtZVsgNiBdICogbWVbIDkgXTtcbiAgICAgICAgdGVbIDEgXSA9IC1tZVsgMTAgXSAqIG1lWyAxIF0gKyBtZVsgMiBdICogbWVbIDkgXTtcbiAgICAgICAgdGVbIDIgXSA9IG1lWyA2IF0gKiBtZVsgMSBdIC0gbWVbIDIgXSAqIG1lWyA1IF07XG4gICAgICAgIHRlWyAzIF0gPSAtbWVbIDEwIF0gKiBtZVsgNCBdICsgbWVbIDYgXSAqIG1lWyA4IF07XG4gICAgICAgIHRlWyA0IF0gPSBtZVsgMTAgXSAqIG1lWyAwIF0gLSBtZVsgMiBdICogbWVbIDggXTtcbiAgICAgICAgdGVbIDUgXSA9IC1tZVsgNiBdICogbWVbIDAgXSArIG1lWyAyIF0gKiBtZVsgNCBdO1xuICAgICAgICB0ZVsgNiBdID0gbWVbIDkgXSAqIG1lWyA0IF0gLSBtZVsgNSBdICogbWVbIDggXTtcbiAgICAgICAgdGVbIDcgXSA9IC1tZVsgOSBdICogbWVbIDAgXSArIG1lWyAxIF0gKiBtZVsgOCBdO1xuICAgICAgICB0ZVsgOCBdID0gbWVbIDUgXSAqIG1lWyAwIF0gLSBtZVsgMSBdICogbWVbIDQgXTtcblxuICAgICAgICB2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDMgXSArIG1lWyAyIF0gKiB0ZVsgNiBdO1xuXG4gICAgICAgIC8vIG5vIGludmVyc2VcblxuICAgICAgICBpZiAoIGRldCA9PT0gMCApIHtcblxuICAgICAgICAgICAgdmFyIG1zZyA9IFwiTWF0cml4My5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcblxuICAgICAgICAgICAgaWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBtc2cgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCAxLjAgLyBkZXQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0cmFuc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRtcCA9IG1bIDEgXTtcbiAgICAgICAgbVsgMSBdID0gbVsgMyBdO1xuICAgICAgICBtWyAzIF0gPSB0bXA7XG4gICAgICAgIHRtcCA9IG1bIDIgXTtcbiAgICAgICAgbVsgMiBdID0gbVsgNiBdO1xuICAgICAgICBtWyA2IF0gPSB0bXA7XG4gICAgICAgIHRtcCA9IG1bIDUgXTtcbiAgICAgICAgbVsgNSBdID0gbVsgNyBdO1xuICAgICAgICBtWyA3IF0gPSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgZ2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxuXG4gICAgICAgIHRoaXMuZ2V0SW52ZXJzZSggbSApLnRyYW5zcG9zZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24oIHIgKSB7XG5cbiAgICAgICAgdmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHJbIDAgXSA9IG1bIDAgXTtcbiAgICAgICAgclsgMSBdID0gbVsgMyBdO1xuICAgICAgICByWyAyIF0gPSBtWyA2IF07XG4gICAgICAgIHJbIDMgXSA9IG1bIDEgXTtcbiAgICAgICAgclsgNCBdID0gbVsgNCBdO1xuICAgICAgICByWyA1IF0gPSBtWyA3IF07XG4gICAgICAgIHJbIDYgXSA9IG1bIDIgXTtcbiAgICAgICAgclsgNyBdID0gbVsgNSBdO1xuICAgICAgICByWyA4IF0gPSBtWyA4IF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSxcbiAgICAgICAgICAgIHRlWyAzIF0sIHRlWyA0IF0sIHRlWyA1IF0sXG4gICAgICAgICAgICB0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXG4gICAgICAgIF07XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4NC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG4gICAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAgIDAsIDAsIDAsIDFcblxuICAgIF0gKTtcblxuICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRyaXg0LFxuXG4gICAgc2V0OiBmdW5jdGlvbiggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdGVbIDAgXSA9IG4xMTtcbiAgICAgICAgdGVbIDQgXSA9IG4xMjtcbiAgICAgICAgdGVbIDggXSA9IG4xMztcbiAgICAgICAgdGVbIDEyIF0gPSBuMTQ7XG4gICAgICAgIHRlWyAxIF0gPSBuMjE7XG4gICAgICAgIHRlWyA1IF0gPSBuMjI7XG4gICAgICAgIHRlWyA5IF0gPSBuMjM7XG4gICAgICAgIHRlWyAxMyBdID0gbjI0O1xuICAgICAgICB0ZVsgMiBdID0gbjMxO1xuICAgICAgICB0ZVsgNiBdID0gbjMyO1xuICAgICAgICB0ZVsgMTAgXSA9IG4zMztcbiAgICAgICAgdGVbIDE0IF0gPSBuMzQ7XG4gICAgICAgIHRlWyAzIF0gPSBuNDE7XG4gICAgICAgIHRlWyA3IF0gPSBuNDI7XG4gICAgICAgIHRlWyAxMSBdID0gbjQzO1xuICAgICAgICB0ZVsgMTUgXSA9IG40NDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBpZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB0aGlzLmVsZW1lbnRzLnNldCggbS5lbGVtZW50cyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGV4dHJhY3RQb3NpdGlvbjogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKCBtICk7XG5cbiAgICB9LFxuXG4gICAgY29weVBvc2l0aW9uOiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgIHRlWyAxMiBdID0gbWVbIDEyIF07XG4gICAgICAgIHRlWyAxMyBdID0gbWVbIDEzIF07XG4gICAgICAgIHRlWyAxNCBdID0gbWVbIDE0IF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHhBeGlzLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApO1xuICAgICAgICB5QXhpcy5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKTtcbiAgICAgICAgekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VCYXNpczogZnVuY3Rpb24oIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cbiAgICAgICAgdGhpcy5zZXQoXG4gICAgICAgICAgICB4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLFxuICAgICAgICAgICAgeEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcbiAgICAgICAgICAgIHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICB2YXIgc2NhbGVYID0gMSAvIHYxLnNldCggbWVbIDAgXSwgbWVbIDEgXSwgbWVbIDIgXSApLmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWyA0IF0sIG1lWyA1IF0sIG1lWyA2IF0gKS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZVogPSAxIC8gdjEuc2V0KCBtZVsgOCBdLCBtZVsgOSBdLCBtZVsgMTAgXSApLmxlbmd0aCgpO1xuXG4gICAgICAgICAgICB0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcbiAgICAgICAgICAgIHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xuICAgICAgICAgICAgdGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XG5cbiAgICAgICAgICAgIHRlWyA0IF0gPSBtZVsgNCBdICogc2NhbGVZO1xuICAgICAgICAgICAgdGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XG4gICAgICAgICAgICB0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcblxuICAgICAgICAgICAgdGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XG4gICAgICAgICAgICB0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcbiAgICAgICAgICAgIHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uKCBldWxlciApIHtcblxuICAgICAgICBpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB2YXIgeCA9IGV1bGVyLngsXG4gICAgICAgICAgICB5ID0gZXVsZXIueSxcbiAgICAgICAgICAgIHogPSBldWxlci56O1xuICAgICAgICB2YXIgYSA9IE1hdGguY29zKCB4ICksXG4gICAgICAgICAgICBiID0gTWF0aC5zaW4oIHggKTtcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggeSApLFxuICAgICAgICAgICAgZCA9IE1hdGguc2luKCB5ICk7XG4gICAgICAgIHZhciBlID0gTWF0aC5jb3MoIHogKSxcbiAgICAgICAgICAgIGYgPSBNYXRoLnNpbiggeiApO1xuXG4gICAgICAgIGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgICAgICAgICB2YXIgYWUgPSBhICogZSxcbiAgICAgICAgICAgICAgICBhZiA9IGEgKiBmLFxuICAgICAgICAgICAgICAgIGJlID0gYiAqIGUsXG4gICAgICAgICAgICAgICAgYmYgPSBiICogZjtcblxuICAgICAgICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgICAgICAgdGVbIDQgXSA9IC1jICogZjtcbiAgICAgICAgICAgIHRlWyA4IF0gPSBkO1xuXG4gICAgICAgICAgICB0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XG4gICAgICAgICAgICB0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XG4gICAgICAgICAgICB0ZVsgOSBdID0gLWIgKiBjO1xuXG4gICAgICAgICAgICB0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG4gICAgICAgICAgICB0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcblxuICAgICAgICAgICAgdmFyIGNlID0gYyAqIGUsXG4gICAgICAgICAgICAgICAgY2YgPSBjICogZixcbiAgICAgICAgICAgICAgICBkZSA9IGQgKiBlLFxuICAgICAgICAgICAgICAgIGRmID0gZCAqIGY7XG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSBjZSArIGRmICogYjtcbiAgICAgICAgICAgIHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcbiAgICAgICAgICAgIHRlWyA4IF0gPSBhICogZDtcblxuICAgICAgICAgICAgdGVbIDEgXSA9IGEgKiBmO1xuICAgICAgICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgICAgICAgdGVbIDkgXSA9IC1iO1xuXG4gICAgICAgICAgICB0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XG4gICAgICAgICAgICB0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgICAgICAgdmFyIGNlID0gYyAqIGUsXG4gICAgICAgICAgICAgICAgY2YgPSBjICogZixcbiAgICAgICAgICAgICAgICBkZSA9IGQgKiBlLFxuICAgICAgICAgICAgICAgIGRmID0gZCAqIGY7XG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSBjZSAtIGRmICogYjtcbiAgICAgICAgICAgIHRlWyA0IF0gPSAtYSAqIGY7XG4gICAgICAgICAgICB0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cbiAgICAgICAgICAgIHRlWyAxIF0gPSBjZiArIGRlICogYjtcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhICogZTtcbiAgICAgICAgICAgIHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuICAgICAgICAgICAgdGVbIDIgXSA9IC1hICogZDtcbiAgICAgICAgICAgIHRlWyA2IF0gPSBiO1xuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICAgICAgICAgIHZhciBhZSA9IGEgKiBlLFxuICAgICAgICAgICAgICAgIGFmID0gYSAqIGYsXG4gICAgICAgICAgICAgICAgYmUgPSBiICogZSxcbiAgICAgICAgICAgICAgICBiZiA9IGIgKiBmO1xuXG4gICAgICAgICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICAgICAgICB0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG4gICAgICAgICAgICB0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cbiAgICAgICAgICAgIHRlWyAxIF0gPSBjICogZjtcbiAgICAgICAgICAgIHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcbiAgICAgICAgICAgIHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuICAgICAgICAgICAgdGVbIDIgXSA9IC1kO1xuICAgICAgICAgICAgdGVbIDYgXSA9IGIgKiBjO1xuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cbiAgICAgICAgICAgIHZhciBhYyA9IGEgKiBjLFxuICAgICAgICAgICAgICAgIGFkID0gYSAqIGQsXG4gICAgICAgICAgICAgICAgYmMgPSBiICogYyxcbiAgICAgICAgICAgICAgICBiZCA9IGIgKiBkO1xuXG4gICAgICAgICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICAgICAgICB0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XG4gICAgICAgICAgICB0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XG5cbiAgICAgICAgICAgIHRlWyAxIF0gPSBmO1xuICAgICAgICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgICAgICAgdGVbIDkgXSA9IC1iICogZTtcblxuICAgICAgICAgICAgdGVbIDIgXSA9IC1kICogZTtcbiAgICAgICAgICAgIHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICAgICAgICB2YXIgYWMgPSBhICogYyxcbiAgICAgICAgICAgICAgICBhZCA9IGEgKiBkLFxuICAgICAgICAgICAgICAgIGJjID0gYiAqIGMsXG4gICAgICAgICAgICAgICAgYmQgPSBiICogZDtcblxuICAgICAgICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgICAgICAgdGVbIDQgXSA9IC1mO1xuICAgICAgICAgICAgdGVbIDggXSA9IGQgKiBlO1xuXG4gICAgICAgICAgICB0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG4gICAgICAgICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICAgICAgICB0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cbiAgICAgICAgICAgIHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcbiAgICAgICAgICAgIHRlWyA2IF0gPSBiICogZTtcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxhc3QgY29sdW1uXG4gICAgICAgIHRlWyAzIF0gPSAwO1xuICAgICAgICB0ZVsgNyBdID0gMDtcbiAgICAgICAgdGVbIDExIF0gPSAwO1xuXG4gICAgICAgIC8vIGJvdHRvbSByb3dcbiAgICAgICAgdGVbIDEyIF0gPSAwO1xuICAgICAgICB0ZVsgMTMgXSA9IDA7XG4gICAgICAgIHRlWyAxNCBdID0gMDtcbiAgICAgICAgdGVbIDE1IF0gPSAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uKCBxICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKS4nICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuICAgIH0sXG5cbiAgICBtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24oIHEgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB2YXIgeCA9IHEueCxcbiAgICAgICAgICAgIHkgPSBxLnksXG4gICAgICAgICAgICB6ID0gcS56LFxuICAgICAgICAgICAgdyA9IHEudztcbiAgICAgICAgdmFyIHgyID0geCArIHgsXG4gICAgICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICAgICAgejIgPSB6ICsgejtcbiAgICAgICAgdmFyIHh4ID0geCAqIHgyLFxuICAgICAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgICAgICB4eiA9IHggKiB6MjtcbiAgICAgICAgdmFyIHl5ID0geSAqIHkyLFxuICAgICAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgICAgICB6eiA9IHogKiB6MjtcbiAgICAgICAgdmFyIHd4ID0gdyAqIHgyLFxuICAgICAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgICAgICB0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xuICAgICAgICB0ZVsgNCBdID0geHkgLSB3ejtcbiAgICAgICAgdGVbIDggXSA9IHh6ICsgd3k7XG5cbiAgICAgICAgdGVbIDEgXSA9IHh5ICsgd3o7XG4gICAgICAgIHRlWyA1IF0gPSAxIC0gKCB4eCArIHp6ICk7XG4gICAgICAgIHRlWyA5IF0gPSB5eiAtIHd4O1xuXG4gICAgICAgIHRlWyAyIF0gPSB4eiAtIHd5O1xuICAgICAgICB0ZVsgNiBdID0geXogKyB3eDtcbiAgICAgICAgdGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XG5cbiAgICAgICAgLy8gbGFzdCBjb2x1bW5cbiAgICAgICAgdGVbIDMgXSA9IDA7XG4gICAgICAgIHRlWyA3IF0gPSAwO1xuICAgICAgICB0ZVsgMTEgXSA9IDA7XG5cbiAgICAgICAgLy8gYm90dG9tIHJvd1xuICAgICAgICB0ZVsgMTIgXSA9IDA7XG4gICAgICAgIHRlWyAxMyBdID0gMDtcbiAgICAgICAgdGVbIDE0IF0gPSAwO1xuICAgICAgICB0ZVsgMTUgXSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbG9va0F0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgeCwgeSwgejtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuICAgICAgICAgICAgaWYgKCB4ID09PSB1bmRlZmluZWQgKSB4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGlmICggeSA9PT0gdW5kZWZpbmVkICkgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBpZiAoIHogPT09IHVuZGVmaW5lZCApIHogPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICB6LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIGlmICggei5sZW5ndGgoKSA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIHoueiA9IDE7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIGlmICggeC5sZW5ndGgoKSA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIHoueCArPSAwLjAwMDE7XG4gICAgICAgICAgICAgICAgeC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcblxuXG4gICAgICAgICAgICB0ZVsgMCBdID0geC54O1xuICAgICAgICAgICAgdGVbIDQgXSA9IHkueDtcbiAgICAgICAgICAgIHRlWyA4IF0gPSB6Lng7XG4gICAgICAgICAgICB0ZVsgMSBdID0geC55O1xuICAgICAgICAgICAgdGVbIDUgXSA9IHkueTtcbiAgICAgICAgICAgIHRlWyA5IF0gPSB6Lnk7XG4gICAgICAgICAgICB0ZVsgMiBdID0geC56O1xuICAgICAgICAgICAgdGVbIDYgXSA9IHkuejtcbiAgICAgICAgICAgIHRlWyAxMCBdID0gei56O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKCBtLCBuICkge1xuXG4gICAgICAgIGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB2YXIgYWUgPSBhLmVsZW1lbnRzO1xuICAgICAgICB2YXIgYmUgPSBiLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHZhciBhMTEgPSBhZVsgMCBdLFxuICAgICAgICAgICAgYTEyID0gYWVbIDQgXSxcbiAgICAgICAgICAgIGExMyA9IGFlWyA4IF0sXG4gICAgICAgICAgICBhMTQgPSBhZVsgMTIgXTtcbiAgICAgICAgdmFyIGEyMSA9IGFlWyAxIF0sXG4gICAgICAgICAgICBhMjIgPSBhZVsgNSBdLFxuICAgICAgICAgICAgYTIzID0gYWVbIDkgXSxcbiAgICAgICAgICAgIGEyNCA9IGFlWyAxMyBdO1xuICAgICAgICB2YXIgYTMxID0gYWVbIDIgXSxcbiAgICAgICAgICAgIGEzMiA9IGFlWyA2IF0sXG4gICAgICAgICAgICBhMzMgPSBhZVsgMTAgXSxcbiAgICAgICAgICAgIGEzNCA9IGFlWyAxNCBdO1xuICAgICAgICB2YXIgYTQxID0gYWVbIDMgXSxcbiAgICAgICAgICAgIGE0MiA9IGFlWyA3IF0sXG4gICAgICAgICAgICBhNDMgPSBhZVsgMTEgXSxcbiAgICAgICAgICAgIGE0NCA9IGFlWyAxNSBdO1xuXG4gICAgICAgIHZhciBiMTEgPSBiZVsgMCBdLFxuICAgICAgICAgICAgYjEyID0gYmVbIDQgXSxcbiAgICAgICAgICAgIGIxMyA9IGJlWyA4IF0sXG4gICAgICAgICAgICBiMTQgPSBiZVsgMTIgXTtcbiAgICAgICAgdmFyIGIyMSA9IGJlWyAxIF0sXG4gICAgICAgICAgICBiMjIgPSBiZVsgNSBdLFxuICAgICAgICAgICAgYjIzID0gYmVbIDkgXSxcbiAgICAgICAgICAgIGIyNCA9IGJlWyAxMyBdO1xuICAgICAgICB2YXIgYjMxID0gYmVbIDIgXSxcbiAgICAgICAgICAgIGIzMiA9IGJlWyA2IF0sXG4gICAgICAgICAgICBiMzMgPSBiZVsgMTAgXSxcbiAgICAgICAgICAgIGIzNCA9IGJlWyAxNCBdO1xuICAgICAgICB2YXIgYjQxID0gYmVbIDMgXSxcbiAgICAgICAgICAgIGI0MiA9IGJlWyA3IF0sXG4gICAgICAgICAgICBiNDMgPSBiZVsgMTEgXSxcbiAgICAgICAgICAgIGI0NCA9IGJlWyAxNSBdO1xuXG4gICAgICAgIHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG4gICAgICAgIHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG4gICAgICAgIHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG4gICAgICAgIHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG4gICAgICAgIHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG4gICAgICAgIHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG4gICAgICAgIHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG4gICAgICAgIHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuXG4gICAgICAgIHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG4gICAgICAgIHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG4gICAgICAgIHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xuICAgICAgICB0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuICAgICAgICB0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuICAgICAgICB0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuICAgICAgICB0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcbiAgICAgICAgdGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiggYSwgYiwgciApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApO1xuXG4gICAgICAgIHJbIDAgXSA9IHRlWyAwIF07XG4gICAgICAgIHJbIDEgXSA9IHRlWyAxIF07XG4gICAgICAgIHJbIDIgXSA9IHRlWyAyIF07XG4gICAgICAgIHJbIDMgXSA9IHRlWyAzIF07XG4gICAgICAgIHJbIDQgXSA9IHRlWyA0IF07XG4gICAgICAgIHJbIDUgXSA9IHRlWyA1IF07XG4gICAgICAgIHJbIDYgXSA9IHRlWyA2IF07XG4gICAgICAgIHJbIDcgXSA9IHRlWyA3IF07XG4gICAgICAgIHJbIDggXSA9IHRlWyA4IF07XG4gICAgICAgIHJbIDkgXSA9IHRlWyA5IF07XG4gICAgICAgIHJbIDEwIF0gPSB0ZVsgMTAgXTtcbiAgICAgICAgclsgMTEgXSA9IHRlWyAxMSBdO1xuICAgICAgICByWyAxMiBdID0gdGVbIDEyIF07XG4gICAgICAgIHJbIDEzIF0gPSB0ZVsgMTMgXTtcbiAgICAgICAgclsgMTQgXSA9IHRlWyAxNCBdO1xuICAgICAgICByWyAxNSBdID0gdGVbIDE1IF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdGVbIDAgXSAqPSBzO1xuICAgICAgICB0ZVsgNCBdICo9IHM7XG4gICAgICAgIHRlWyA4IF0gKj0gcztcbiAgICAgICAgdGVbIDEyIF0gKj0gcztcbiAgICAgICAgdGVbIDEgXSAqPSBzO1xuICAgICAgICB0ZVsgNSBdICo9IHM7XG4gICAgICAgIHRlWyA5IF0gKj0gcztcbiAgICAgICAgdGVbIDEzIF0gKj0gcztcbiAgICAgICAgdGVbIDIgXSAqPSBzO1xuICAgICAgICB0ZVsgNiBdICo9IHM7XG4gICAgICAgIHRlWyAxMCBdICo9IHM7XG4gICAgICAgIHRlWyAxNCBdICo9IHM7XG4gICAgICAgIHRlWyAzIF0gKj0gcztcbiAgICAgICAgdGVbIDcgXSAqPSBzO1xuICAgICAgICB0ZVsgMTEgXSAqPSBzO1xuICAgICAgICB0ZVsgMTUgXSAqPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIG9yIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiggYSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcblxuICAgIH0sXG5cbiAgICBhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuICAgICAgICAgICAgICAgIHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcbiAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB2MS50b0FycmF5KCBhcnJheSwgaiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgYXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkrKywgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdjEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XG4gICAgICAgICAgICAgICAgdjEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XG4gICAgICAgICAgICAgICAgdjEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cbiAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVBeGlzOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cbiAgICAgICAgdi50cmFuc2Zvcm1EaXJlY3Rpb24oIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjcm9zc1ZlY3RvcjogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdmFyIG4xMSA9IHRlWyAwIF0sXG4gICAgICAgICAgICBuMTIgPSB0ZVsgNCBdLFxuICAgICAgICAgICAgbjEzID0gdGVbIDggXSxcbiAgICAgICAgICAgIG4xNCA9IHRlWyAxMiBdO1xuICAgICAgICB2YXIgbjIxID0gdGVbIDEgXSxcbiAgICAgICAgICAgIG4yMiA9IHRlWyA1IF0sXG4gICAgICAgICAgICBuMjMgPSB0ZVsgOSBdLFxuICAgICAgICAgICAgbjI0ID0gdGVbIDEzIF07XG4gICAgICAgIHZhciBuMzEgPSB0ZVsgMiBdLFxuICAgICAgICAgICAgbjMyID0gdGVbIDYgXSxcbiAgICAgICAgICAgIG4zMyA9IHRlWyAxMCBdLFxuICAgICAgICAgICAgbjM0ID0gdGVbIDE0IF07XG4gICAgICAgIHZhciBuNDEgPSB0ZVsgMyBdLFxuICAgICAgICAgICAgbjQyID0gdGVbIDcgXSxcbiAgICAgICAgICAgIG40MyA9IHRlWyAxMSBdLFxuICAgICAgICAgICAgbjQ0ID0gdGVbIDE1IF07XG5cbiAgICAgICAgLy9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcbiAgICAgICAgLy8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG40MSAqICggK24xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNCApICtcbiAgICAgICAgICAgIG40MiAqICggK24xMSAqIG4yMyAqIG4zNCAtIG4xMSAqIG4yNCAqIG4zMyArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSApICtcbiAgICAgICAgICAgIG40MyAqICggK24xMSAqIG4yNCAqIG4zMiAtIG4xMSAqIG4yMiAqIG4zNCAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCArIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSApICtcbiAgICAgICAgICAgIG40NCAqICggLW4xMyAqIG4yMiAqIG4zMSAtIG4xMSAqIG4yMyAqIG4zMiArIG4xMSAqIG4yMiAqIG4zMyArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMiAqIG4yMyAqIG4zMSApXG5cbiAgICAgICAgKTtcblxuICAgIH0sXG5cbiAgICB0cmFuc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB0bXA7XG5cbiAgICAgICAgdG1wID0gdGVbIDEgXTtcbiAgICAgICAgdGVbIDEgXSA9IHRlWyA0IF07XG4gICAgICAgIHRlWyA0IF0gPSB0bXA7XG4gICAgICAgIHRtcCA9IHRlWyAyIF07XG4gICAgICAgIHRlWyAyIF0gPSB0ZVsgOCBdO1xuICAgICAgICB0ZVsgOCBdID0gdG1wO1xuICAgICAgICB0bXAgPSB0ZVsgNiBdO1xuICAgICAgICB0ZVsgNiBdID0gdGVbIDkgXTtcbiAgICAgICAgdGVbIDkgXSA9IHRtcDtcblxuICAgICAgICB0bXAgPSB0ZVsgMyBdO1xuICAgICAgICB0ZVsgMyBdID0gdGVbIDEyIF07XG4gICAgICAgIHRlWyAxMiBdID0gdG1wO1xuICAgICAgICB0bXAgPSB0ZVsgNyBdO1xuICAgICAgICB0ZVsgNyBdID0gdGVbIDEzIF07XG4gICAgICAgIHRlWyAxMyBdID0gdG1wO1xuICAgICAgICB0bXAgPSB0ZVsgMTEgXTtcbiAgICAgICAgdGVbIDExIF0gPSB0ZVsgMTQgXTtcbiAgICAgICAgdGVbIDE0IF0gPSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDkgXSA9IHRlWyA5IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEyIF0gPSB0ZVsgMTIgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDE1IF0gPSB0ZVsgMTUgXTtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgICByZXR1cm4gdjEuc2V0KCB0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRlWyAxMiBdID0gdi54O1xuICAgICAgICB0ZVsgMTMgXSA9IHYueTtcbiAgICAgICAgdGVbIDE0IF0gPSB2Lno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0SW52ZXJzZTogZnVuY3Rpb24oIG0sIHRocm93T25JbnZlcnRpYmxlICkge1xuXG4gICAgICAgIC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgIHZhciBuMTEgPSBtZVsgMCBdLFxuICAgICAgICAgICAgbjEyID0gbWVbIDQgXSxcbiAgICAgICAgICAgIG4xMyA9IG1lWyA4IF0sXG4gICAgICAgICAgICBuMTQgPSBtZVsgMTIgXTtcbiAgICAgICAgdmFyIG4yMSA9IG1lWyAxIF0sXG4gICAgICAgICAgICBuMjIgPSBtZVsgNSBdLFxuICAgICAgICAgICAgbjIzID0gbWVbIDkgXSxcbiAgICAgICAgICAgIG4yNCA9IG1lWyAxMyBdO1xuICAgICAgICB2YXIgbjMxID0gbWVbIDIgXSxcbiAgICAgICAgICAgIG4zMiA9IG1lWyA2IF0sXG4gICAgICAgICAgICBuMzMgPSBtZVsgMTAgXSxcbiAgICAgICAgICAgIG4zNCA9IG1lWyAxNCBdO1xuICAgICAgICB2YXIgbjQxID0gbWVbIDMgXSxcbiAgICAgICAgICAgIG40MiA9IG1lWyA3IF0sXG4gICAgICAgICAgICBuNDMgPSBtZVsgMTEgXSxcbiAgICAgICAgICAgIG40NCA9IG1lWyAxNSBdO1xuXG4gICAgICAgIHRlWyAwIF0gPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQ7XG4gICAgICAgIHRlWyA0IF0gPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQ7XG4gICAgICAgIHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XG4gICAgICAgIHRlWyAxMiBdID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuICAgICAgICB0ZVsgMSBdID0gbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0O1xuICAgICAgICB0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xuICAgICAgICB0ZVsgOSBdID0gbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0O1xuICAgICAgICB0ZVsgMTMgXSA9IG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNDtcbiAgICAgICAgdGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcbiAgICAgICAgdGVbIDYgXSA9IG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NDtcbiAgICAgICAgdGVbIDEwIF0gPSBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQ7XG4gICAgICAgIHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xuICAgICAgICB0ZVsgMyBdID0gbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzO1xuICAgICAgICB0ZVsgNyBdID0gbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzO1xuICAgICAgICB0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MztcbiAgICAgICAgdGVbIDE1IF0gPSBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzM7XG5cbiAgICAgICAgdmFyIGRldCA9IG4xMSAqIHRlWyAwIF0gKyBuMjEgKiB0ZVsgNCBdICsgbjMxICogdGVbIDggXSArIG40MSAqIHRlWyAxMiBdO1xuXG4gICAgICAgIGlmICggZGV0ID09PSAwICkge1xuXG4gICAgICAgICAgICB2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG4gICAgICAgICAgICBpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIG1zZyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaWRlbnRpdHkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBkZXQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgcm90YXRlWDogZnVuY3Rpb24oIGFuZ2xlICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uKCBhbmdsZSApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICByb3RhdGVaOiBmdW5jdGlvbiggYW5nbGUgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgcm90YXRlQnlBeGlzOiBmdW5jdGlvbiggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHggPSB2LngsXG4gICAgICAgICAgICB5ID0gdi55LFxuICAgICAgICAgICAgeiA9IHYuejtcblxuICAgICAgICB0ZVsgMCBdICo9IHg7XG4gICAgICAgIHRlWyA0IF0gKj0geTtcbiAgICAgICAgdGVbIDggXSAqPSB6O1xuICAgICAgICB0ZVsgMSBdICo9IHg7XG4gICAgICAgIHRlWyA1IF0gKj0geTtcbiAgICAgICAgdGVbIDkgXSAqPSB6O1xuICAgICAgICB0ZVsgMiBdICo9IHg7XG4gICAgICAgIHRlWyA2IF0gKj0geTtcbiAgICAgICAgdGVbIDEwIF0gKj0gejtcbiAgICAgICAgdGVbIDMgXSAqPSB4O1xuICAgICAgICB0ZVsgNyBdICo9IHk7XG4gICAgICAgIHRlWyAxMSBdICo9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdmFyIHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuICAgICAgICB2YXIgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG4gICAgICAgIHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgTWF0aC5tYXgoIHNjYWxlWVNxLCBzY2FsZVpTcSApICkgKTtcblxuICAgIH0sXG5cbiAgICBtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uKCB4LCB5LCB6ICkge1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICAxLCAwLCAwLCB4LFxuICAgICAgICAgICAgMCwgMSwgMCwgeSxcbiAgICAgICAgICAgIDAsIDAsIDEsIHosXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlUm90YXRpb25YOiBmdW5jdGlvbiggdGhldGEgKSB7XG5cbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgMSwgMCwgMCwgMCxcbiAgICAgICAgICAgIDAsIGMsIC1zLCAwLFxuICAgICAgICAgICAgMCwgcywgYywgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uKCB0aGV0YSApIHtcblxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICBjLCAwLCBzLCAwLFxuICAgICAgICAgICAgMCwgMSwgMCwgMCwgLXMsIDAsIGMsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlUm90YXRpb25aOiBmdW5jdGlvbiggdGhldGEgKSB7XG5cbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgYywgLXMsIDAsIDAsXG4gICAgICAgICAgICBzLCBjLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uKCBheGlzLCBhbmdsZSApIHtcblxuICAgICAgICAvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcblxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuICAgICAgICB2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuICAgICAgICB2YXIgdCA9IDEgLSBjO1xuICAgICAgICB2YXIgeCA9IGF4aXMueCxcbiAgICAgICAgICAgIHkgPSBheGlzLnksXG4gICAgICAgICAgICB6ID0gYXhpcy56O1xuICAgICAgICB2YXIgdHggPSB0ICogeCxcbiAgICAgICAgICAgIHR5ID0gdCAqIHk7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcbiAgICAgICAgICAgIHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcbiAgICAgICAgICAgIHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VTY2FsZTogZnVuY3Rpb24oIHgsIHksIHogKSB7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIHgsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCB5LCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgeiwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cbiAgICAgICAgdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuICAgICAgICB0aGlzLnNjYWxlKCBzY2FsZSApO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHZlY3RvciwgbWF0cml4O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICB2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG4gICAgICAgICAgICAvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuICAgICAgICAgICAgdmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcbiAgICAgICAgICAgIGlmICggZGV0IDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHN4ID0gLXN4O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLnggPSB0ZVsgMTIgXTtcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcbiAgICAgICAgICAgIHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuICAgICAgICAgICAgLy8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcblxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzLnNldCggdGhpcy5lbGVtZW50cyApOyAvLyBhdCB0aGlzIHBvaW50IG1hdHJpeCBpcyBpbmNvbXBsZXRlIHNvIHdlIGNhbid0IHVzZSAuY29weSgpXG5cbiAgICAgICAgICAgIHZhciBpbnZTWCA9IDEgLyBzeDtcbiAgICAgICAgICAgIHZhciBpbnZTWSA9IDEgLyBzeTtcbiAgICAgICAgICAgIHZhciBpbnZTWiA9IDEgLyBzejtcblxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA5IF0gKj0gaW52U1o7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cbiAgICAgICAgICAgIHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXggKTtcblxuICAgICAgICAgICAgc2NhbGUueCA9IHN4O1xuICAgICAgICAgICAgc2NhbGUueSA9IHN5O1xuICAgICAgICAgICAgc2NhbGUueiA9IHN6O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbWFrZUZydXN0dW06IGZ1bmN0aW9uKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcbiAgICAgICAgdmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cbiAgICAgICAgdmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcbiAgICAgICAgdmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcbiAgICAgICAgdmFyIGMgPSAtKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcbiAgICAgICAgdmFyIGQgPSAtMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuICAgICAgICB0ZVsgMCBdID0geDtcbiAgICAgICAgdGVbIDQgXSA9IDA7XG4gICAgICAgIHRlWyA4IF0gPSBhO1xuICAgICAgICB0ZVsgMTIgXSA9IDA7XG4gICAgICAgIHRlWyAxIF0gPSAwO1xuICAgICAgICB0ZVsgNSBdID0geTtcbiAgICAgICAgdGVbIDkgXSA9IGI7XG4gICAgICAgIHRlWyAxMyBdID0gMDtcbiAgICAgICAgdGVbIDIgXSA9IDA7XG4gICAgICAgIHRlWyA2IF0gPSAwO1xuICAgICAgICB0ZVsgMTAgXSA9IGM7XG4gICAgICAgIHRlWyAxNCBdID0gZDtcbiAgICAgICAgdGVbIDMgXSA9IDA7XG4gICAgICAgIHRlWyA3IF0gPSAwO1xuICAgICAgICB0ZVsgMTEgXSA9IC0xO1xuICAgICAgICB0ZVsgMTUgXSA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuICAgICAgICB2YXIgeW1heCA9IG5lYXIgKiBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKTtcbiAgICAgICAgdmFyIHltaW4gPSAteW1heDtcbiAgICAgICAgdmFyIHhtaW4gPSB5bWluICogYXNwZWN0O1xuICAgICAgICB2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZUZydXN0dW0oIHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhciApO1xuXG4gICAgfSxcblxuICAgIG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdyA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgdmFyIGggPSB0b3AgLSBib3R0b207XG4gICAgICAgIHZhciBwID0gZmFyIC0gbmVhcjtcblxuICAgICAgICB2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgLyB3O1xuICAgICAgICB2YXIgeSA9ICggdG9wICsgYm90dG9tICkgLyBoO1xuICAgICAgICB2YXIgeiA9ICggZmFyICsgbmVhciApIC8gcDtcblxuICAgICAgICB0ZVsgMCBdID0gMiAvIHc7XG4gICAgICAgIHRlWyA0IF0gPSAwO1xuICAgICAgICB0ZVsgOCBdID0gMDtcbiAgICAgICAgdGVbIDEyIF0gPSAteDtcbiAgICAgICAgdGVbIDEgXSA9IDA7XG4gICAgICAgIHRlWyA1IF0gPSAyIC8gaDtcbiAgICAgICAgdGVbIDkgXSA9IDA7XG4gICAgICAgIHRlWyAxMyBdID0gLXk7XG4gICAgICAgIHRlWyAyIF0gPSAwO1xuICAgICAgICB0ZVsgNiBdID0gMDtcbiAgICAgICAgdGVbIDEwIF0gPSAtMiAvIHA7XG4gICAgICAgIHRlWyAxNCBdID0gLXo7XG4gICAgICAgIHRlWyAzIF0gPSAwO1xuICAgICAgICB0ZVsgNyBdID0gMDtcbiAgICAgICAgdGVbIDExIF0gPSAwO1xuICAgICAgICB0ZVsgMTUgXSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggbWF0cml4ICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSsrICkge1xuXG4gICAgICAgICAgICBpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5ICkge1xuXG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0sIHRlWyAzIF0sXG4gICAgICAgICAgICB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdLCB0ZVsgNyBdLFxuICAgICAgICAgICAgdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0sIHRlWyAxMSBdLFxuICAgICAgICAgICAgdGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSwgdGVbIDE1IF1cbiAgICAgICAgXTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9SYXkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5SYXkgPSBmdW5jdGlvbiggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICB0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5SYXkucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlJheSxcblxuICAgIHNldDogZnVuY3Rpb24oIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG4gICAgICAgIHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCByYXkgKSB7XG5cbiAgICAgICAgdGhpcy5vcmlnaW4uY29weSggcmF5Lm9yaWdpbiApO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXQ6IGZ1bmN0aW9uKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICB9LFxuXG4gICAgcmVjYXN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICAgICAgdGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xuICAgICAgICB2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSByZXN1bHQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgICAgIGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlU3FUb1BvaW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgICAgICAgICAgLy8gcG9pbnQgYmVoaW5kIHRoZSByYXlcblxuICAgICAgICAgICAgaWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdjEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgICAgICAgIHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZGlzdGFuY2VTcVRvU2VnbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlZ0NlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBzZWdEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuICAgICAgICAgICAgLy8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9EaXN0YW5jZS9XbTVEaXN0UmF5M1NlZ21lbnQzLmNwcFxuICAgICAgICAgICAgLy8gSXQgcmV0dXJucyB0aGUgbWluIGRpc3RhbmNlIGJldHdlZW4gdGhlIHJheSBhbmQgdGhlIHNlZ21lbnRcbiAgICAgICAgICAgIC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG4gICAgICAgICAgICAvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxuICAgICAgICAgICAgLy8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcmF5XG4gICAgICAgICAgICAvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cbiAgICAgICAgICAgIHNlZ0NlbnRlci5jb3B5KCB2MCApLmFkZCggdjEgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG4gICAgICAgICAgICBzZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICBkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcblxuICAgICAgICAgICAgdmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgYTAxID0gLXRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XG4gICAgICAgICAgICB2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcbiAgICAgICAgICAgIHZhciBiMSA9IC1kaWZmLmRvdCggc2VnRGlyICk7XG4gICAgICAgICAgICB2YXIgYyA9IGRpZmYubGVuZ3RoU3EoKTtcbiAgICAgICAgICAgIHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xuICAgICAgICAgICAgdmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xuXG4gICAgICAgICAgICBpZiAoIGRldCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXG5cbiAgICAgICAgICAgICAgICBzMCA9IGEwMSAqIGIxIC0gYjA7XG4gICAgICAgICAgICAgICAgczEgPSBhMDEgKiBiMCAtIGIxO1xuICAgICAgICAgICAgICAgIGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcblxuICAgICAgICAgICAgICAgIGlmICggczAgPj0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMxID49IC1leHREZXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggczEgPD0gZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIGF0IGludGVyaW9yIHBvaW50cyBvZiByYXkgYW5kIHNlZ21lbnQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW52RGV0ID0gMSAvIGRldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCAqPSBpbnZEZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgKj0gaW52RGV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDFcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gc2VnRXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0oIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiA1XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gLXNlZ0V4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0oIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMxIDw9IC1leHREZXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiA0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0oIC1hMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9ICggczAgPiAwICkgPyAtc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtc2VnRXh0ZW50LCAtYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gM1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLXNlZ0V4dGVudCwgLWIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gMlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC1zZWdFeHRlbnQsIC1iMSApLCBzZWdFeHRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cblxuICAgICAgICAgICAgICAgIHMxID0gKCBhMDEgPiAwICkgPyAtc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xuICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0oIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcblxuICAgICAgICAgICAgICAgIG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoIHNlZ0RpciApLm11bHRpcGx5U2NhbGFyKCBzMSApLmFkZCggc2VnQ2VudGVyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNxckRpc3Q7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuXG4gICAgaXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uKCBzcGhlcmUgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RTcGhlcmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LXNwaGVyZS1pbnRlcnNlY3Rpb24vXG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHYxLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luICk7XG5cbiAgICAgICAgICAgIHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICAgICAgICAgIHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcblxuICAgICAgICAgICAgdmFyIHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcblxuICAgICAgICAgICAgaWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgdmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XG5cbiAgICAgICAgICAgIC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXG4gICAgICAgICAgICB2YXIgdDAgPSB0Y2EgLSB0aGM7XG5cbiAgICAgICAgICAgIC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcbiAgICAgICAgICAgIHZhciB0MSA9IHRjYSArIHRoYztcblxuICAgICAgICAgICAgLy8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXG4gICAgICAgICAgICBpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgLy8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG4gICAgICAgICAgICAvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG4gICAgICAgICAgICAvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXG4gICAgICAgICAgICBpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgICAgICAgICAgLy8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0KCB0MCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgICAgICB9XG5cbiAgICB9KCksXG5cbiAgICBpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiggcGxhbmUgKSB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG4gICAgICAgIHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcblxuICAgICAgICBpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgICAgICBpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uKCBwbGFuZSApIHtcblxuICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuICAgICAgICBpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG4gICAgICAgICAgICAvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG4gICAgICAgICAgICBpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gLSggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuICAgICAgICAvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxuXG4gICAgICAgIHJldHVybiB0ID49IDAgPyB0IDogbnVsbDtcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RQbGFuZTogZnVuY3Rpb24oIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xuXG4gICAgICAgIGlmICggdCA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmF0KCB0LCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgfSxcblxuICAgIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oIGJveCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LWJveC1pbnRlcnNlY3Rpb24vXG5cbiAgICAgICAgdmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xuXG4gICAgICAgIHZhciBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXG4gICAgICAgICAgICBpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG4gICAgICAgICAgICBpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG4gICAgICAgIGlmICggaW52ZGlyeCA+PSAwICkge1xuXG4gICAgICAgICAgICB0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcbiAgICAgICAgICAgIHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuICAgICAgICAgICAgdG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaW52ZGlyeSA+PSAwICkge1xuXG4gICAgICAgICAgICB0eW1pbiA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG4gICAgICAgICAgICB0eW1heCA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgICAgICAgICAgdHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cbiAgICAgICAgLy8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG4gICAgICAgIGlmICggdHltaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHltaW47XG5cbiAgICAgICAgaWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcblxuICAgICAgICBpZiAoIGludmRpcnogPj0gMCApIHtcblxuICAgICAgICAgICAgdHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuICAgICAgICAgICAgdHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHR6bWluID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcbiAgICAgICAgICAgIHR6bWF4ID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xuXG4gICAgICAgIGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XG5cbiAgICAgICAgLy9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxuXG4gICAgICAgIGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuICAgICAgICB2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBlZGdlMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBlZGdlMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgLy8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9JbnRlcnNlY3Rpb24vV201SW50clJheTNUcmlhbmdsZTMuY3BwXG5cbiAgICAgICAgICAgIGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcbiAgICAgICAgICAgIGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcbiAgICAgICAgICAgIG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG4gICAgICAgICAgICAvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcbiAgICAgICAgICAgIC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcbiAgICAgICAgICAgIC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuICAgICAgICAgICAgLy8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG4gICAgICAgICAgICAvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuICAgICAgICAgICAgdmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG4gICAgICAgICAgICB2YXIgc2lnbjtcblxuICAgICAgICAgICAgaWYgKCBEZE4gPiAwICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBiYWNrZmFjZUN1bGxpbmcgKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBzaWduID0gMTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIERkTiA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAgICAgRGROID0gLURkTjtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG4gICAgICAgICAgICB2YXIgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTIuY3Jvc3NWZWN0b3JzKCBkaWZmLCBlZGdlMiApICk7XG5cbiAgICAgICAgICAgIC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICBpZiAoIERkUXhFMiA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xuXG4gICAgICAgICAgICAvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgICAgICAgICAgaWYgKCBEZEUxeFEgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cbiAgICAgICAgICAgIHZhciBRZE4gPSAtc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuICAgICAgICAgICAgLy8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgICAgICAgICAgaWYgKCBRZE4gPCAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uKCBtYXRyaXg0ICkge1xuXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcbiAgICAgICAgdGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggcmF5ICkge1xuXG4gICAgICAgIHJldHVybiByYXkub3JpZ2luLmVxdWFscyggdGhpcy5vcmlnaW4gKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9TcGhlcmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuU3BoZXJlID0gZnVuY3Rpb24oIGNlbnRlciwgcmFkaXVzICkge1xuXG4gICAgdGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMDtcblxufTtcblxuVEhSRUUuU3BoZXJlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5TcGhlcmUsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBjZW50ZXIsIHJhZGl1cyApIHtcblxuICAgICAgICB0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVBvaW50czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xuXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cbiAgICAgICAgICAgIGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGJveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5jZW50ZXIoIGNlbnRlciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXhSYWRpdXNTcSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNwaGVyZSApIHtcblxuICAgICAgICB0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xuXG4gICAgfSxcblxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICByZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG8oIHRoaXMuY2VudGVyICkgLSB0aGlzLnJhZGl1cyApO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uKCBzcGhlcmUgKSB7XG5cbiAgICAgICAgdmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuICAgICAgICByZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG4gICAgfSxcblxuICAgIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmVzdWx0LmNvcHkoIHBvaW50ICk7XG5cbiAgICAgICAgaWYgKCBkZWx0YUxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICByZXN1bHQubXVsdGlwbHlTY2FsYXIoIHRoaXMucmFkaXVzICkuYWRkKCB0aGlzLmNlbnRlciApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICAgICAgYm94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG4gICAgICAgIGJveC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuICAgICAgICByZXR1cm4gYm94O1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24oIG1hdHJpeCApIHtcblxuICAgICAgICB0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiggb2Zmc2V0ICkge1xuXG4gICAgICAgIHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggc3BoZXJlICkge1xuXG4gICAgICAgIHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvRnJ1c3R1bS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG4gICAgdGhpcy5wbGFuZXMgPSBbXG5cbiAgICAgICAgKCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLCAoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksICggcDIgIT09IHVuZGVmaW5lZCApID8gcDIgOiBuZXcgVEhSRUUuUGxhbmUoKSwgKCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLCAoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksICggcDUgIT09IHVuZGVmaW5lZCApID8gcDUgOiBuZXcgVEhSRUUuUGxhbmUoKVxuXG4gICAgXTtcblxufTtcblxuVEhSRUUuRnJ1c3R1bS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRnJ1c3R1bSxcblxuICAgIHNldDogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgICAgIHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XG4gICAgICAgIHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG4gICAgICAgIHBsYW5lc1sgMiBdLmNvcHkoIHAyICk7XG4gICAgICAgIHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XG4gICAgICAgIHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG4gICAgICAgIHBsYW5lc1sgNSBdLmNvcHkoIHA1ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggZnJ1c3R1bSApIHtcblxuICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICBwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcbiAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcbiAgICAgICAgdmFyIG1lMCA9IG1lWyAwIF0sXG4gICAgICAgICAgICBtZTEgPSBtZVsgMSBdLFxuICAgICAgICAgICAgbWUyID0gbWVbIDIgXSxcbiAgICAgICAgICAgIG1lMyA9IG1lWyAzIF07XG4gICAgICAgIHZhciBtZTQgPSBtZVsgNCBdLFxuICAgICAgICAgICAgbWU1ID0gbWVbIDUgXSxcbiAgICAgICAgICAgIG1lNiA9IG1lWyA2IF0sXG4gICAgICAgICAgICBtZTcgPSBtZVsgNyBdO1xuICAgICAgICB2YXIgbWU4ID0gbWVbIDggXSxcbiAgICAgICAgICAgIG1lOSA9IG1lWyA5IF0sXG4gICAgICAgICAgICBtZTEwID0gbWVbIDEwIF0sXG4gICAgICAgICAgICBtZTExID0gbWVbIDExIF07XG4gICAgICAgIHZhciBtZTEyID0gbWVbIDEyIF0sXG4gICAgICAgICAgICBtZTEzID0gbWVbIDEzIF0sXG4gICAgICAgICAgICBtZTE0ID0gbWVbIDE0IF0sXG4gICAgICAgICAgICBtZTE1ID0gbWVbIDE1IF07XG5cbiAgICAgICAgcGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XG4gICAgICAgIHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xuICAgICAgICBwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XG4gICAgICAgIHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdHNPYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICAgICAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICAgICAgICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgaW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24oIHNwaGVyZSApIHtcblxuICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG4gICAgICAgIHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xuICAgICAgICB2YXIgbmVnUmFkaXVzID0gLXNwaGVyZS5yYWRpdXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xuXG4gICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XG5cbiAgICAgICAgICAgICAgICBwMS54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1pbi54IDogYm94Lm1heC54O1xuICAgICAgICAgICAgICAgIHAyLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XG4gICAgICAgICAgICAgICAgcDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcbiAgICAgICAgICAgICAgICBwMi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xuICAgICAgICAgICAgICAgIHAxLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWluLnogOiBib3gubWF4Lno7XG4gICAgICAgICAgICAgICAgcDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcblxuICAgICAgICAgICAgICAgIHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcbiAgICAgICAgICAgICAgICB2YXIgZDIgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAyICk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxuXG4gICAgICAgICAgICAgICAgaWYgKCBkMSA8IDAgJiYgZDIgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgaWYgKCBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1BsYW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUGxhbmUgPSBmdW5jdGlvbiggbm9ybWFsLCBjb25zdGFudCApIHtcblxuICAgIHRoaXMubm9ybWFsID0gKCBub3JtYWwgIT09IHVuZGVmaW5lZCApID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcbiAgICB0aGlzLmNvbnN0YW50ID0gKCBjb25zdGFudCAhPT0gdW5kZWZpbmVkICkgPyBjb25zdGFudCA6IDA7XG5cbn07XG5cblRIUkVFLlBsYW5lLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5QbGFuZSxcblxuICAgIHNldDogZnVuY3Rpb24oIG5vcm1hbCwgY29uc3RhbnQgKSB7XG5cbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRDb21wb25lbnRzOiBmdW5jdGlvbiggeCwgeSwgeiwgdyApIHtcblxuICAgICAgICB0aGlzLm5vcm1hbC5zZXQoIHgsIHksIHogKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uKCBub3JtYWwsIHBvaW50ICkge1xuXG4gICAgICAgIHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgICAgICB0aGlzLmNvbnN0YW50ID0gLXBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTsgLy8gbXVzdCBiZSB0aGlzLm5vcm1hbCwgbm90IG5vcm1hbCwgYXMgdGhpcy5ub3JtYWwgaXMgbm9ybWFsaXplZFxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGEsIGIsIGMgKSB7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB2MS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIHYyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xuXG4gICAgICAgICAgICB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHBsYW5lICkge1xuXG4gICAgICAgIHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuICAgICAgICB0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuICAgICAgICB2YXIgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xuICAgICAgICB0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xuICAgICAgICB0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbmVnYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNvbnN0YW50ICo9IC0xO1xuICAgICAgICB0aGlzLm5vcm1hbC5uZWdhdGUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWwuZG90KCBwb2ludCApICsgdGhpcy5jb25zdGFudDtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiggc3BoZXJlICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcblxuICAgIH0sXG5cbiAgICBwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xuXG4gICAgfSxcblxuICAgIG9ydGhvUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XG5cbiAgICB9LFxuXG4gICAgaXNJbnRlcnNlY3Rpb25MaW5lOiBmdW5jdGlvbiggbGluZSApIHtcblxuICAgICAgICAvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cblxuICAgICAgICB2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcbiAgICAgICAgdmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcblxuICAgICAgICByZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XG5cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGxpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XG5cbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHRoaXMubm9ybWFsLmRvdCggZGlyZWN0aW9uICk7XG5cbiAgICAgICAgICAgIGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29weSggbGluZS5zdGFydCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdCA9IC0oIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICAgICAgICAgIGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29weSggZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIGxpbmUuc3RhcnQgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG5cbiAgICBjb3BsYW5hclBvaW50OiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLXRoaXMuY29uc3RhbnQgKTtcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xuXG4gICAgICAgICAgICAvLyBjb21wdXRlIG5ldyBub3JtYWwgYmFzZWQgb24gdGhlb3J5IGhlcmU6XG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfbm9ybWFsdHJhbnNmb3JtLmh0bWxcbiAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBtMS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuICAgICAgICAgICAgdmFyIG5ld05vcm1hbCA9IHYxLmNvcHkoIHRoaXMubm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKTtcblxuICAgICAgICAgICAgdmFyIG5ld0NvcGxhbmFyUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYyICk7XG4gICAgICAgICAgICBuZXdDb3BsYW5hclBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5ld05vcm1hbCwgbmV3Q29wbGFuYXJQb2ludCApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiggb2Zmc2V0ICkge1xuXG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBwbGFuZSApIHtcblxuICAgICAgICByZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGggPSB7XG5cbiAgICBnZW5lcmF0ZVVVSUQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXG5cbiAgICAgICAgdmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcbiAgICAgICAgdmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XG4gICAgICAgIHZhciBybmQgPSAwLFxuICAgICAgICAgICAgcjtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGkgPT09IDggfHwgaSA9PT0gMTMgfHwgaSA9PT0gMTggfHwgaSA9PT0gMjMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdXVpZFsgaSBdID0gJy0nO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBpID09PSAxNCApIHtcblxuICAgICAgICAgICAgICAgICAgICB1dWlkWyBpIF0gPSAnNCc7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBybmQgPD0gMHgwMiApIHJuZCA9IDB4MjAwMDAwMCArICggTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgciA9IHJuZCAmIDB4ZjtcbiAgICAgICAgICAgICAgICAgICAgcm5kID0gcm5kID4+IDQ7XG4gICAgICAgICAgICAgICAgICAgIHV1aWRbIGkgXSA9IGNoYXJzWyAoIGkgPT09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXVpZC5qb2luKCAnJyApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICAvLyBDbGFtcCB2YWx1ZSB0byByYW5nZSA8YSwgYj5cblxuICAgIGNsYW1wOiBmdW5jdGlvbiggeCwgYSwgYiApIHtcblxuICAgICAgICByZXR1cm4gKCB4IDwgYSApID8gYSA6ICggKCB4ID4gYiApID8gYiA6IHggKTtcblxuICAgIH0sXG5cbiAgICAvLyBDbGFtcCB2YWx1ZSB0byByYW5nZSA8YSwgaW5mKVxuXG4gICAgY2xhbXBCb3R0b206IGZ1bmN0aW9uKCB4LCBhICkge1xuXG4gICAgICAgIHJldHVybiB4IDwgYSA/IGEgOiB4O1xuXG4gICAgfSxcblxuICAgIC8vIGNvbXB1dGUgZXVjbGlkaWFuIG1vZHVsbyBvZiBtICUgblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cblxuICAgIGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24oIG4sIG0gKSB7XG5cbiAgICAgICAgcmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxuICAgIH0sXG5cbiAgICAvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XG5cbiAgICBtYXBMaW5lYXI6IGZ1bmN0aW9uKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuICAgICAgICByZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuICAgIH0sXG5cbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuICAgIHNtb290aHN0ZXA6IGZ1bmN0aW9uKCB4LCBtaW4sIG1heCApIHtcblxuICAgICAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgICAgIGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuICAgICAgICB4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG4gICAgICAgIHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cbiAgICB9LFxuXG4gICAgc21vb3RoZXJzdGVwOiBmdW5jdGlvbiggeCwgbWluLCBtYXggKSB7XG5cbiAgICAgICAgaWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuICAgICAgICBpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cbiAgICAgICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuICAgICAgICByZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG4gICAgfSxcblxuICAgIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwwLCAxPiB3aXRoIDE2IGJpdHMgb2YgcmFuZG9tbmVzc1xuICAgIC8vIChzdGFuZGFyZCBNYXRoLnJhbmRvbSgpIGNyZWF0ZXMgcmVwZXRpdGl2ZSBwYXR0ZXJucyB3aGVuIGFwcGxpZWQgb3ZlciBsYXJnZXIgc3BhY2UpXG5cbiAgICByYW5kb20xNjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XG5cbiAgICB9LFxuXG4gICAgLy8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG4gICAgcmFuZEludDogZnVuY3Rpb24oIGxvdywgaGlnaCApIHtcblxuICAgICAgICByZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG4gICAgfSxcblxuICAgIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cbiAgICByYW5kRmxvYXQ6IGZ1bmN0aW9uKCBsb3csIGhpZ2ggKSB7XG5cbiAgICAgICAgcmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuICAgIH0sXG5cbiAgICAvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5cbiAgICByYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uKCByYW5nZSApIHtcblxuICAgICAgICByZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuICAgIH0sXG5cbiAgICBkZWdUb1JhZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvciA9IE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBkZWdyZWVzICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcmFkVG9EZWc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciByYWRpYW5Ub0RlZ3JlZXNGYWN0b3IgPSAxODAgLyBNYXRoLlBJO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcmFkaWFucyApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHJhZGlhbnMgKiByYWRpYW5Ub0RlZ3JlZXNGYWN0b3I7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGlzUG93ZXJPZlR3bzogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xuXG4gICAgfSxcblxuICAgIG5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdmFsdWUtLTtcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gMTtcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gMjtcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gNDtcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gODtcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gMTY7XG4gICAgICAgIHZhbHVlKys7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwbGluZS5qc1xuXG4vKipcbiAqIFNwbGluZSBmcm9tIFR3ZWVuLmpzLCBzbGlnaHRseSBvcHRpbWl6ZWQgKGFuZCB0cmFzaGVkKVxuICogaHR0cDovL3NvbGUuZ2l0aHViLmNvbS90d2Vlbi5qcy9leGFtcGxlcy8wNV9zcGxpbmUuaHRtbFxuICpcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwbGluZSA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIHZhciBjID0gW10sXG4gICAgICAgIHYzID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB6OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXG4gICAgICAgIHBhLCBwYiwgcGMsIHBkO1xuXG4gICAgdGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24oIGEgKSB7XG5cbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLnBvaW50c1sgaSBdID0ge1xuICAgICAgICAgICAgICAgIHg6IGFbIGkgXVsgMCBdLFxuICAgICAgICAgICAgICAgIHk6IGFbIGkgXVsgMSBdLFxuICAgICAgICAgICAgICAgIHo6IGFbIGkgXVsgMiBdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24oIGsgKSB7XG5cbiAgICAgICAgcG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGs7XG4gICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgICAgICBjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xuICAgICAgICBjWyAxIF0gPSBpbnRQb2ludDtcbiAgICAgICAgY1sgMiBdID0gaW50UG9pbnQgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcbiAgICAgICAgY1sgMyBdID0gaW50UG9pbnQgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcblxuICAgICAgICBwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcbiAgICAgICAgcGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XG4gICAgICAgIHBjID0gdGhpcy5wb2ludHNbIGNbIDIgXSBdO1xuICAgICAgICBwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcblxuICAgICAgICB3MiA9IHdlaWdodCAqIHdlaWdodDtcbiAgICAgICAgdzMgPSB3ZWlnaHQgKiB3MjtcblxuICAgICAgICB2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XG4gICAgICAgIHYzLnkgPSBpbnRlcnBvbGF0ZSggcGEueSwgcGIueSwgcGMueSwgcGQueSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICAgICAgdjMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xuXG4gICAgICAgIHJldHVybiB2MztcblxuICAgIH07XG5cbiAgICB0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpLCBwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgY29vcmRzID0gW107XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHAgPSB0aGlzLnBvaW50c1sgaSBdO1xuICAgICAgICAgICAgY29vcmRzWyBpIF0gPSBbIHAueCwgcC55LCBwLnogXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcblxuICAgIH07XG5cbiAgICAvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcblxuICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oIG5TdWJEaXZpc2lvbnMgKSB7XG5cbiAgICAgICAgdmFyIGksIGluZGV4LCBuU2FtcGxlcywgcG9zaXRpb24sXG4gICAgICAgICAgICBwb2ludCA9IDAsXG4gICAgICAgICAgICBpbnRQb2ludCA9IDAsXG4gICAgICAgICAgICBvbGRJbnRQb2ludCA9IDAsXG4gICAgICAgICAgICBvbGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICB0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgY2h1bmtMZW5ndGhzID0gW10sXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICAgICAgLy8gZmlyc3QgcG9pbnQgaGFzIDAgbGVuZ3RoXG5cbiAgICAgICAgY2h1bmtMZW5ndGhzWyAwIF0gPSAwO1xuXG4gICAgICAgIGlmICggIW5TdWJEaXZpc2lvbnMgKSBuU3ViRGl2aXNpb25zID0gMTAwO1xuXG4gICAgICAgIG5TYW1wbGVzID0gdGhpcy5wb2ludHMubGVuZ3RoICogblN1YkRpdmlzaW9ucztcblxuICAgICAgICBvbGRQb3NpdGlvbi5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICk7XG5cbiAgICAgICAgZm9yICggaSA9IDE7IGkgPCBuU2FtcGxlczsgaSsrICkge1xuXG4gICAgICAgICAgICBpbmRleCA9IGkgLyBuU2FtcGxlcztcblxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuICAgICAgICAgICAgdG1wVmVjLmNvcHkoIHBvc2l0aW9uICk7XG5cbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IHRtcFZlYy5kaXN0YW5jZVRvKCBvbGRQb3NpdGlvbiApO1xuXG4gICAgICAgICAgICBvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xuXG4gICAgICAgICAgICBwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaW5kZXg7XG4gICAgICAgICAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cbiAgICAgICAgICAgIGlmICggaW50UG9pbnQgIT09IG9sZEludFBvaW50ICkge1xuXG4gICAgICAgICAgICAgICAgY2h1bmtMZW5ndGhzWyBpbnRQb2ludCBdID0gdG90YWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgb2xkSW50UG9pbnQgPSBpbnRQb2ludDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBsYXN0IHBvaW50IGVuZHMgd2l0aCB0b3RhbCBsZW5ndGhcblxuICAgICAgICBjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaHVua3M6IGNodW5rTGVuZ3RocyxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbExlbmd0aFxuICAgICAgICB9O1xuXG4gICAgfTtcblxuICAgIHRoaXMucmVwYXJhbWV0cml6ZUJ5QXJjTGVuZ3RoID0gZnVuY3Rpb24oIHNhbXBsaW5nQ29lZiApIHtcblxuICAgICAgICB2YXIgaSwgaixcbiAgICAgICAgICAgIGluZGV4LCBpbmRleEN1cnJlbnQsIGluZGV4TmV4dCxcbiAgICAgICAgICAgIHJlYWxEaXN0YW5jZSxcbiAgICAgICAgICAgIHNhbXBsaW5nLCBwb3NpdGlvbixcbiAgICAgICAgICAgIG5ld3BvaW50cyA9IFtdLFxuICAgICAgICAgICAgdG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIHNsID0gdGhpcy5nZXRMZW5ndGgoKTtcblxuICAgICAgICBuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKS5jbG9uZSgpICk7XG5cbiAgICAgICAgZm9yICggaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgLy90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcbiAgICAgICAgICAgIC8vbGluZWFyRGlzdGFuY2UgPSB0bXBWZWMuZGlzdGFuY2VUbyggdGhpcy5wb2ludHNbIGkgXSApO1xuXG4gICAgICAgICAgICByZWFsRGlzdGFuY2UgPSBzbC5jaHVua3NbIGkgXSAtIHNsLmNodW5rc1sgaSAtIDEgXTtcblxuICAgICAgICAgICAgc2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XG5cbiAgICAgICAgICAgIGluZGV4Q3VycmVudCA9ICggaSAtIDEgKSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuICAgICAgICAgICAgaW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuXG4gICAgICAgICAgICBmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG4gICAgICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApLmNsb25lKCkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xuXG4gICAgfTtcblxuICAgIC8vIENhdG11bGwtUm9tXG5cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcblxuICAgICAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcbiAgICAgICAgICAgIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cbiAgICAgICAgcmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0zICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9UcmlhbmdsZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5UcmlhbmdsZSA9IGZ1bmN0aW9uKCBhLCBiLCBjICkge1xuXG4gICAgdGhpcy5hID0gKCBhICE9PSB1bmRlZmluZWQgKSA/IGEgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLlRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcbiAgICAgICAgdjAuc3ViVmVjdG9ycyggYSwgYiApO1xuICAgICAgICByZXN1bHQuY3Jvc3MoIHYwICk7XG5cbiAgICAgICAgdmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XG4gICAgICAgIGlmICggcmVzdWx0TGVuZ3RoU3EgPiAwICkge1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XG5cbiAgICB9O1xuXG59KCk7XG5cbi8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4vLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcbiAgICAgICAgdjEuc3ViVmVjdG9ycyggYiwgYSApO1xuICAgICAgICB2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xuXG4gICAgICAgIHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcbiAgICAgICAgdmFyIGRvdDAxID0gdjAuZG90KCB2MSApO1xuICAgICAgICB2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XG4gICAgICAgIHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcbiAgICAgICAgdmFyIGRvdDEyID0gdjEuZG90KCB2MiApO1xuXG4gICAgICAgIHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAvLyBjb2xsaW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcbiAgICAgICAgaWYgKCBkZW5vbSA9PT0gMCApIHtcblxuICAgICAgICAgICAgLy8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XG4gICAgICAgICAgICAvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggLTIsIC0xLCAtMSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gZGVub207XG4gICAgICAgIHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG4gICAgICAgIHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XG5cbiAgICAgICAgLy8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG4gICAgfTtcblxufSgpO1xuXG5USFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBwb2ludCwgYSwgYiwgYyApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgYSwgYiwgYywgdjEgKTtcblxuICAgICAgICByZXR1cm4gKCByZXN1bHQueCA+PSAwICkgJiYgKCByZXN1bHQueSA+PSAwICkgJiYgKCAoIHJlc3VsdC54ICsgcmVzdWx0LnkgKSA8PSAxICk7XG5cbiAgICB9O1xuXG59KCk7XG5cblRIUkVFLlRyaWFuZ2xlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5UcmlhbmdsZSxcblxuICAgIHNldDogZnVuY3Rpb24oIGEsIGIsIGMgKSB7XG5cbiAgICAgICAgdGhpcy5hLmNvcHkoIGEgKTtcbiAgICAgICAgdGhpcy5iLmNvcHkoIGIgKTtcbiAgICAgICAgdGhpcy5jLmNvcHkoIGMgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24oIHBvaW50cywgaTAsIGkxLCBpMiApIHtcblxuICAgICAgICB0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG4gICAgICAgIHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcbiAgICAgICAgdGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHRyaWFuZ2xlICkge1xuXG4gICAgICAgIHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XG4gICAgICAgIHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG4gICAgICAgIHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXJlYTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XG4gICAgICAgICAgICB2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xuXG4gICAgICAgICAgICByZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIG1pZHBvaW50OiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG4gICAgfSxcblxuICAgIG5vcm1hbDogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICB9LFxuXG4gICAgcGxhbmU6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuICAgIH0sXG5cbiAgICBiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICB9LFxuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHRyaWFuZ2xlICkge1xuXG4gICAgICAgIHJldHVybiB0cmlhbmdsZS5hLmVxdWFscyggdGhpcy5hICkgJiYgdHJpYW5nbGUuYi5lcXVhbHMoIHRoaXMuYiApICYmIHRyaWFuZ2xlLmMuZXF1YWxzKCB0aGlzLmMgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9DbG9jay5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ2xvY2sgPSBmdW5jdGlvbiggYXV0b1N0YXJ0ICkge1xuXG4gICAgdGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xuXG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgIHRoaXMub2xkVGltZSA9IDA7XG4gICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG5cbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ2xvY2sucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkNsb2NrLFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWQgPyBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKTtcblxuICAgICAgICB0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgfSxcblxuICAgIGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmdldERlbHRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xuXG4gICAgfSxcblxuICAgIGdldERlbHRhOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZGlmZiA9IDA7XG5cbiAgICAgICAgaWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhdGhpcy5ydW5uaW5nICkge1xuXG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5ydW5uaW5nICkge1xuXG4gICAgICAgICAgICB2YXIgbmV3VGltZSA9IHNlbGYucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiBzZWxmLnBlcmZvcm1hbmNlLm5vdyAhPT0gdW5kZWZpbmVkID8gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIGRpZmYgPSAwLjAwMSAqICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApO1xuICAgICAgICAgICAgdGhpcy5vbGRUaW1lID0gbmV3VGltZTtcblxuICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlmZjtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9FdmVudERpc3BhdGNoZXIuanNcblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cbiAqL1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkV2ZW50RGlzcGF0Y2hlcixcblxuICAgIGFwcGx5OiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuICAgICAgICBvYmplY3QuaGFzRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgb2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50ID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xuXG4gICAgfSxcblxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLTEgKSB7XG5cbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0xICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfSxcblxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICBsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG4gICAgICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBhcnJheVsgaSBdID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgYXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL1JheWNhc3Rlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb20vXG4gKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cbiAqL1xuXG4oIGZ1bmN0aW9uKCBUSFJFRSApIHtcblxuICAgIFRIUkVFLlJheWNhc3RlciA9IGZ1bmN0aW9uKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xuXG4gICAgICAgIHRoaXMucmF5ID0gbmV3IFRIUkVFLlJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcbiAgICAgICAgLy8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuICAgICAgICB0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XG4gICAgICAgIHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xuXG4gICAgICAgIHRoaXMucGFyYW1zID0ge1xuICAgICAgICAgICAgTWVzaDoge30sXG4gICAgICAgICAgICBMaW5lOiB7fSxcbiAgICAgICAgICAgIExPRDoge30sXG4gICAgICAgICAgICBQb2ludHM6IHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTcHJpdGU6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMucGFyYW1zLCB7XG4gICAgICAgICAgICBQb2ludENsb3VkOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyOiBwYXJhbXMuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIHBhcmFtcy5Qb2ludHMuJyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Qb2ludHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVzY1NvcnQoIGEsIGIgKSB7XG5cbiAgICAgICAgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG4gICAgfVxuXG4gICAgdmFyIGludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xuXG4gICAgICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuICAgICAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vXG5cbiAgICBUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5SYXljYXN0ZXIsXG5cbiAgICAgICAgbGluZVByZWNpc2lvbjogMSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICAgICAgICAgICAgLy8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuICAgICAgICAgICAgdGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RnJvbUNhbWVyYTogZnVuY3Rpb24oIGNvb3JkcywgY2FtZXJhICkge1xuXG4gICAgICAgICAgICBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXkuZGlyZWN0aW9uLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAwLjUgKS51bnByb2plY3QoIGNhbWVyYSApLnN1YiggdGhpcy5yYXkub3JpZ2luICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIC0xICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCAwLCAwLCAtMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdHMgPSBbXTtcblxuICAgICAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24oIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0cztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oIFRIUkVFICkgKTtcblxuLy8gRmlsZTpzcmMvY29yZS9PYmplY3QzRC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxuICovXG5cblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24oKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IFRIUkVFLk9iamVjdDNESWRDb3VudCsrXG4gICAgfSApO1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XG5cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy51cCA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgcm90YXRpb24gPSBuZXcgVEhSRUUuRXVsZXIoKTtcbiAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcblxuICAgIHZhciBvblJvdGF0aW9uQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXG4gICAgfTtcblxuICAgIHZhciBvblF1YXRlcm5pb25DaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xuXG4gICAgfTtcblxuICAgIHJvdGF0aW9uLm9uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XG4gICAgcXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBwb3NpdGlvblxuICAgICAgICB9LFxuICAgICAgICByb3RhdGlvbjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiByb3RhdGlvblxuICAgICAgICB9LFxuICAgICAgICBxdWF0ZXJuaW9uOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHF1YXRlcm5pb25cbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogc2NhbGVcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZWxWaWV3TWF0cml4OiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLk1hdHJpeDQoKVxuICAgICAgICB9LFxuICAgICAgICBub3JtYWxNYXRyaXg6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4MygpXG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICB0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgdGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJPcmRlciA9IDA7XG5cbiAgICB0aGlzLnVzZXJEYXRhID0ge307XG5cbn07XG5cblRIUkVFLk9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5USFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cblRIUkVFLk9iamVjdDNELnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcblxuICAgIGdldCBldWxlck9yZGVyKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byAucm90YXRpb24ub3JkZXIuJyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xuXG4gICAgfSxcblxuICAgIHNldCBldWxlck9yZGVyKCB2YWx1ZSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gLnJvdGF0aW9uLm9yZGVyLicgKTtcblxuICAgICAgICB0aGlzLnJvdGF0aW9uLm9yZGVyID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgZ2V0IHVzZVF1YXRlcm5pb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG4gICAgfSxcblxuICAgIHNldCB1c2VRdWF0ZXJuaW9uKCB2YWx1ZSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG5cbiAgICB9LFxuXG4gICAgc2V0IHJlbmRlckRlcHRoKCB2YWx1ZSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnJlbmRlckRlcHRoIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAucmVuZGVyT3JkZXIsIGluc3RlYWQuJyApO1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4OiBmdW5jdGlvbiggbWF0cml4ICkge1xuXG4gICAgICAgIHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcblxuICAgICAgICB0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG4gICAgfSxcblxuICAgIHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24oIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICAgIC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uKCBldWxlciApIHtcblxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG4gICAgfSxcblxuICAgIHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24oIHEgKSB7XG5cbiAgICAgICAgLy8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weSggcSApO1xuXG4gICAgfSxcblxuICAgIHJvdGF0ZU9uQXhpczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxuICAgICAgICAvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgICAgIHZhciBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBheGlzLCBhbmdsZSApIHtcblxuICAgICAgICAgICAgcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlWDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGFuZ2xlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVZOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyB0cmFuc2xhdGUgb2JqZWN0IGJ5IGRpc3RhbmNlIGFsb25nIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG4gICAgICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGF4aXMsIGRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICB2MS5jb3B5KCBheGlzICkuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLnF1YXRlcm5pb24gKTtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGQoIHYxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCBkaXN0YW5jZSwgYXhpcyApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlWDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGVZOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZVo6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBkaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbG9jYWxUb1dvcmxkOiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICB9LFxuXG4gICAgd29ybGRUb0xvY2FsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGxvb2tBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cbiAgICAgICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICAgICAgbTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcblxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgYWRkOiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiwgb2JqZWN0ICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PYmplY3QzRCApIHtcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkZWQnXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsIG9iamVjdCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSAtMSApIHtcblxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZWQnXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0T2JqZWN0QnlJZDogZnVuY3Rpb24oIGlkICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuICAgIH0sXG5cbiAgICBnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgfSxcblxuICAgIGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIH0sXG5cbiAgICBnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHJlc3VsdCApO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByYXljYXN0OiBmdW5jdGlvbigpIHt9LFxuXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICBjYWxsYmFjayggdGhpcyApO1xuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICBpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgY2FsbGJhY2soIHRoaXMgKTtcblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgY2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICAgIGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBjYWxsYmFjayggcGFyZW50ICk7XG5cbiAgICAgICAgICAgIHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgfSxcblxuICAgIHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiggZm9yY2UgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICAgIGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGNoaWxkcmVuXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgICAgICB2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICAgIC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXG4gICAgICAgIC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG4gICAgICAgIC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG4gICAgICAgIGlmICggaXNSb290T2JqZWN0ICkge1xuXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIG1ldGEgb2JqXG4gICAgICAgICAgICBtZXRhID0ge1xuICAgICAgICAgICAgICAgIGdlb21ldHJpZXM6IHt9LFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsczoge30sXG4gICAgICAgICAgICAgICAgdGV4dHVyZXM6IHt9LFxuICAgICAgICAgICAgICAgIGltYWdlczoge31cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRhdGEubWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdPYmplY3QnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuICAgICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuICAgICAgICBpZiAoIHRoaXMudmlzaWJsZSAhPT0gdHJ1ZSApIGRhdGEudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgICAgICBkYXRhLm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblxuICAgICAgICBpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgZGF0YS5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZGF0YS5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgICAgIGlmICggaXNSb290T2JqZWN0ICkge1xuXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcbiAgICAgICAgICAgIGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuICAgICAgICAgICAgaWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5vYmplY3QgPSBkYXRhO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG5cbiAgICAgICAgLy8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcbiAgICAgICAgLy8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuICAgICAgICAvLyBhbmQgcmV0dXJuIGFzIGFycmF5XG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xuXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEubWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIGRhdGEgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG4gICAgICAgIGlmICggcmVjdXJzaXZlID09PSB1bmRlZmluZWQgKSByZWN1cnNpdmUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG4gICAgICAgIHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KCBzb3VyY2UucG9zaXRpb24gKTtcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XG4gICAgICAgIHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBzb3VyY2Uucm90YXRpb25BdXRvVXBkYXRlO1xuXG4gICAgICAgIHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuICAgICAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cbiAgICAgICAgdGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG4gICAgICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG4gICAgICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xuICAgICAgICB0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuXG4gICAgICAgIHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuICAgICAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLk9iamVjdDNESWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlMyA9IGZ1bmN0aW9uKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG5cbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XG5cbiAgICB0aGlzLmNvbG9yID0gY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciA/IGNvbG9yIDogbmV3IFRIUkVFLkNvbG9yKCk7XG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcblxuICAgIHRoaXMubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwO1xuXG59O1xuXG5USFJFRS5GYWNlMy5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdGhpcy5hID0gc291cmNlLmE7XG4gICAgICAgIHRoaXMuYiA9IHNvdXJjZS5iO1xuICAgICAgICB0aGlzLmMgPSBzb3VyY2UuYztcblxuICAgICAgICB0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XG4gICAgICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICAgICAgdGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdID0gc291cmNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2U0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXG4gICAgdGhpcy5keW5hbWljID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVSYW5nZSA9IHtcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBjb3VudDogLTFcbiAgICB9O1xuXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcblxufTtcblxuVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUsXG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICAgIH0sXG5cbiAgICBnZXQgY291bnQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZTtcblxuICAgIH0sXG5cbiAgICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24rKztcblxuICAgIH0sXG5cbiAgICBzZXREeW5hbWljOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5keW5hbWljID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG5cbiAgICAgICAgdGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weUF0OiBmdW5jdGlvbiggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuICAgICAgICBpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcbiAgICAgICAgaW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weUFycmF5OiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cbiAgICAgICAgdGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiggY29sb3JzICkge1xuXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgICAgICAgICBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gY29sb3IucjtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gY29sb3IuZztcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gY29sb3IuYjtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weUluZGljZXNBcnJheTogZnVuY3Rpb24oIGluZGljZXMgKSB7XG5cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcblxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSBpbmRleC5hO1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSBpbmRleC5iO1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSBpbmRleC5jO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5VmVjdG9yMnNBcnJheTogZnVuY3Rpb24oIHZlY3RvcnMgKSB7XG5cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLng7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci55O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5VmVjdG9yM3NBcnJheTogZnVuY3Rpb24oIHZlY3RvcnMgKSB7XG5cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLng7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci55O1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IuejtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weVZlY3RvcjRzQXJyYXk6IGZ1bmN0aW9uKCB2ZWN0b3JzICkge1xuXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3I0c0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci54O1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IueTtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLno7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci53O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0WDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcblxuICAgIH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbiggaW5kZXgsIHggKSB7XG5cbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldFk6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xuXG4gICAgfSxcblxuICAgIHNldFk6IGZ1bmN0aW9uKCBpbmRleCwgeSApIHtcblxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldFo6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG4gICAgfSxcblxuICAgIHNldFo6IGZ1bmN0aW9uKCBpbmRleCwgeiApIHtcblxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldFc6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xuXG4gICAgfSxcblxuICAgIHNldFc6IGZ1bmN0aW9uKCBpbmRleCwgdyApIHtcblxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFhZOiBmdW5jdGlvbiggaW5kZXgsIHgsIHkgKSB7XG5cbiAgICAgICAgaW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYWVo6IGZ1bmN0aW9uKCBpbmRleCwgeCwgeSwgeiApIHtcblxuICAgICAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WFlaVzogZnVuY3Rpb24oIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG4gICAgICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9XG5cbn07XG5cbi8vXG5cblRIUkVFLkludDhBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkludDE2QXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDE2QXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDMyQXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblxuLy8gRGVwcmVjYXRlZFxuXG5USFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoKS5zZXREeW5hbWljKCB0cnVlICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApLnNldER5bmFtaWMoIHRydWUgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG4gICAgVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xuXG4gICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uKCBhcnJheSwgc3RyaWRlICkge1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcblxuICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlUmFuZ2UgPSB7XG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY291bnQ6IC0xXG4gICAgfTtcblxuICAgIHRoaXMudmVyc2lvbiA9IDA7XG5cbn07XG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlcixcblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuXG4gICAgfSxcblxuICAgIGdldCBjb3VudCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggLyB0aGlzLnN0cmlkZTtcblxuICAgIH0sXG5cbiAgICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24rKztcblxuICAgIH0sXG5cbiAgICBzZXREeW5hbWljOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5keW5hbWljID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XG4gICAgICAgIHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcbiAgICAgICAgdGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XG5cbiAgICB9LFxuXG4gICAgY29weUF0OiBmdW5jdGlvbiggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuICAgICAgICBpbmRleDEgKj0gdGhpcy5zdHJpZGU7XG4gICAgICAgIGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiggdmFsdWUsIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG4gICAgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIuY2FsbCggdGhpcywgYXJyYXksIHN0cmlkZSApO1xuXG4gICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgKTtcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCApIHtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcbiAgICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cbn07XG5cblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLFxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgICB9LFxuXG4gICAgZ2V0IGNvdW50KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXkubGVuZ3RoIC8gdGhpcy5kYXRhLnN0cmlkZTtcblxuICAgIH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbiggaW5kZXgsIHggKSB7XG5cbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRZOiBmdW5jdGlvbiggaW5kZXgsIHkgKSB7XG5cbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WjogZnVuY3Rpb24oIGluZGV4LCB6ICkge1xuXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFc6IGZ1bmN0aW9uKCBpbmRleCwgdyApIHtcblxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRYOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcblxuICAgIH0sXG5cbiAgICBnZXRZOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XG5cbiAgICB9LFxuXG4gICAgZ2V0WjogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG4gICAgfSxcblxuICAgIGdldFc6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcblxuICAgIH0sXG5cbiAgICBzZXRYWTogZnVuY3Rpb24oIGluZGV4LCB4LCB5ICkge1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFhZWjogZnVuY3Rpb24oIGluZGV4LCB4LCB5LCB6ICkge1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYWVpXOiBmdW5jdGlvbiggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCsrXG4gICAgfSApO1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMudHlwZSA9ICdHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG4gICAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgICB0aGlzLmZhY2VzID0gW107XG4gICAgdGhpcy5mYWNlVmVydGV4VXZzID0gW1xuICAgICAgICBbXVxuICAgIF07XG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xuICAgIHRoaXMubW9ycGhDb2xvcnMgPSBbXTtcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xuXG4gICAgdGhpcy5za2luV2VpZ2h0cyA9IFtdO1xuICAgIHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuICAgIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbiAgICAvLyB1cGRhdGUgZmxhZ3NcblxuICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnksXG5cbiAgICBhcHBseU1hdHJpeDogZnVuY3Rpb24oIG1hdHJpeCApIHtcblxuICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgICAgICAgICB2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG4gICAgICAgICAgICBmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHNbIGogXS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgfSxcblxuICAgIHJvdGF0ZVg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlWTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVaOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gc2NhbGUgZ2VvbWV0cnlcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbG9va0F0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgb2JqO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcblxuICAgICAgICAgICAgaWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgICAgICAgICBvYmoubG9va0F0KCB2ZWN0b3IgKTtcblxuICAgICAgICAgICAgb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjb2xvcnMgPSBhdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLmNvbG9yLmFycmF5IDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHV2czIgPSBhdHRyaWJ1dGVzLnV2MiAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51djIuYXJyYXkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IFtdO1xuXG4gICAgICAgIHZhciB0ZW1wTm9ybWFscyA9IFtdO1xuICAgICAgICB2YXIgdGVtcFVWcyA9IFtdO1xuICAgICAgICB2YXIgdGVtcFVWczIgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzLCBqICs9IDIsIGsgKz0gNCApIHtcblxuICAgICAgICAgICAgc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cbiAgICAgICAgICAgIGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdGVtcE5vcm1hbHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBjb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHRlbXBVVnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2c1sgaiBdLCB1dnNbIGogKyAxIF0gKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdGVtcFVWczIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2czJbIGogXSwgdXZzMlsgaiArIDEgXSApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFkZEZhY2UgPSBmdW5jdGlvbiggYSwgYiwgYyApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBub3JtYWxzICE9PSB1bmRlZmluZWQgPyBbIHRlbXBOb3JtYWxzWyBhIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGIgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuICAgICAgICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycyApO1xuXG4gICAgICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICAgICAgICAgIGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB0ZW1wVVZzWyBhIF0uY2xvbmUoKSwgdGVtcFVWc1sgYiBdLmNsb25lKCksIHRlbXBVVnNbIGMgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuICAgICAgICAgICAgaWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmFjZSggaW5kaWNlc1sgaiBdLCBpbmRpY2VzWyBqICsgMSBdLCBpbmRpY2VzWyBqICsgMiBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWRkRmFjZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdLCBpbmRpY2VzWyBpICsgMiBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICBhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2VudGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcblxuICAgIH0sXG5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG5cbiAgICAgICAgdmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgICBtYXRyaXguc2V0KFxuICAgICAgICAgICAgcywgMCwgMCwgLXMgKiBjZW50ZXIueCxcbiAgICAgICAgICAgIDAsIHMsIDAsIC1zICogY2VudGVyLnksXG4gICAgICAgICAgICAwLCAwLCBzLCAtcyAqIGNlbnRlci56LFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICBmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcbiAgICAgICAgICAgIHZhciB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG4gICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcbiAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xuICAgICAgICAgICAgY2IuY3Jvc3MoIGFiICk7XG5cbiAgICAgICAgICAgIGNiLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24oIGFyZWFXZWlnaHRlZCApIHtcblxuICAgICAgICB2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcblxuICAgICAgICB2ZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcblxuICAgICAgICBmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2KysgKSB7XG5cbiAgICAgICAgICAgIHZlcnRpY2VzWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGFyZWFXZWlnaHRlZCApIHtcblxuICAgICAgICAgICAgLy8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cblxuICAgICAgICAgICAgdmFyIHZBLCB2QiwgdkM7XG4gICAgICAgICAgICB2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgICAgIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICAgICAgICAgIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XG4gICAgICAgICAgICAgICAgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcbiAgICAgICAgICAgICAgICB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG4gICAgICAgICAgICAgICAgY2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG4gICAgICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG4gICAgICAgICAgICAgICAgY2IuY3Jvc3MoIGFiICk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2KysgKSB7XG5cbiAgICAgICAgICAgIHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgICAgIGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xuXG4gICAgICAgIC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xuICAgICAgICAvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3NcbiAgICAgICAgLy8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxuXG4gICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICAgICAgaWYgKCAhZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICFmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggIWZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcblxuICAgICAgICB2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xuXG4gICAgICAgICAgICBpZiAoICF0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XG4gICAgICAgICAgICAgICAgdmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuICAgICAgICAgICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlTm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGE6IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBiOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzogbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcbiAgICAgICAgICAgICAgICAgICAgZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF07XG5cbiAgICAgICAgICAgIC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcblxuICAgICAgICAgICAgdG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgLy8gY29tcHV0ZSBtb3JwaCBub3JtYWxzXG5cbiAgICAgICAgICAgIHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICAgICAgICAgIHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSBtb3JwaCBub3JtYWxzXG5cbiAgICAgICAgICAgIHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xuXG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBub3JtYWxzXG5cbiAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgICAgICBmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XG4gICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkID0gMDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgaWYgKCBpID4gMCApIHtcblxuICAgICAgICAgICAgICAgIGQgKz0gdmVydGljZXNbIGkgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSAtIDEgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcblxuICAgIH0sXG5cbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cbiAgICB9LFxuXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCxcbiAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgdmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgICAgIHZlcnRpY2VzMiA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuICAgICAgICAgICAgZmFjZXMxID0gdGhpcy5mYWNlcyxcbiAgICAgICAgICAgIGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxuICAgICAgICAgICAgdXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLFxuICAgICAgICAgICAgdXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsSW5kZXhPZmZzZXQgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsSW5kZXhPZmZzZXQgPSAwO1xuXG4gICAgICAgIGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVydGljZXNcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcblxuICAgICAgICAgICAgdmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcblxuICAgICAgICAgICAgaWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHZlcnRleENvcHkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgICAgICAgICAgdmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFjZXNcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlczJbIGkgXSxcbiAgICAgICAgICAgICAgICBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcbiAgICAgICAgICAgICAgICBmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcbiAgICAgICAgICAgICAgICBmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgICAgICAgIGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XG4gICAgICAgICAgICBmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgICAgICAgaWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGZhY2VDb3B5Lm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgY29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XG4gICAgICAgICAgICAgICAgZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcblxuICAgICAgICAgICAgZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHV2c1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHV2ID0gdXZzMlsgaSBdLFxuICAgICAgICAgICAgICAgIHV2Q29weSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1dnMxLnB1c2goIHV2Q29weSApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXJnZU1lc2g6IGZ1bmN0aW9uKCBtZXNoICkge1xuXG4gICAgICAgIGlmICggbWVzaCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2VNZXNoKCk6IG1lc2ggbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk1lc2guJywgbWVzaCApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBtZXNoLm1hdHJpeEF1dG9VcGRhdGUgJiYgbWVzaC51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICB0aGlzLm1lcmdlKCBtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdHJpeCApO1xuXG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxuICAgICAqIER1cGxpY2F0ZWQgdmVydGljZXMgYXJlIHJlbW92ZWRcbiAgICAgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxuICAgICAqL1xuXG4gICAgbWVyZ2VWZXJ0aWNlczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZXMgYnkgcG9zaXRpb24gY29vcmRpbmF0ZXMgKGFuZCBtYWtpbmcgc3VyZSB0aGV5IGFyZSB1bmlxdWUpXG4gICAgICAgIHZhciB1bmlxdWUgPSBbXSxcbiAgICAgICAgICAgIGNoYW5nZXMgPSBbXTtcblxuICAgICAgICB2YXIgdiwga2V5O1xuICAgICAgICB2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlLmcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xuICAgICAgICB2YXIgaSwgaWwsIGZhY2U7XG4gICAgICAgIHZhciBpbmRpY2VzLCBqLCBqbDtcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgICAgICAgICBrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XG5cbiAgICAgICAgICAgIGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc01hcFsga2V5IF0gPSBpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxuICAgICAgICAvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxuICAgICAgICB2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuICAgICAgICAgICAgZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XG4gICAgICAgICAgICBmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcbiAgICAgICAgICAgIGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xuXG4gICAgICAgICAgICBpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XG5cbiAgICAgICAgICAgIHZhciBkdXBJbmRleCA9IC0xO1xuXG4gICAgICAgICAgICAvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxuICAgICAgICAgICAgZm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbisrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICBkdXBJbmRleCA9IG47XG4gICAgICAgICAgICAgICAgICAgIGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblxuICAgICAgICAgICAgdmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xuXG4gICAgICAgICAgICBmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcblxuICAgICAgICB2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG5cbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdHZW9tZXRyeScsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN0YW5kYXJkIEdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuICAgICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICAgIGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFjZXMgPSBbXTtcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICAgICAgdmFyIG5vcm1hbHNIYXNoID0ge307XG4gICAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgICAgdmFyIGNvbG9yc0hhc2ggPSB7fTtcbiAgICAgICAgdmFyIHV2cyA9IFtdO1xuICAgICAgICB2YXIgdXZzSGFzaCA9IHt9O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG4gICAgICAgICAgICB2YXIgaGFzTWF0ZXJpYWwgPSBmYWxzZTsgLy8gZmFjZS5tYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgIHZhciBoYXNGYWNlVmVydGV4VXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcbiAgICAgICAgICAgIHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB2YXIgaGFzRmFjZUNvbG9yID0gZmFjZS5jb2xvci5yICE9PSAxIHx8IGZhY2UuY29sb3IuZyAhPT0gMSB8fCBmYWNlLmNvbG9yLmIgIT09IDE7XG4gICAgICAgICAgICB2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgdmFyIGZhY2VUeXBlID0gMDtcblxuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7XG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcblxuICAgICAgICAgICAgZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcbiAgICAgICAgICAgIGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcblxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXG4gICAgICAgICAgICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDIgXSApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxuICAgICAgICAgICAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXG4gICAgICAgICAgICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXG4gICAgICAgICAgICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXG4gICAgICAgICAgICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiggMSA8PCBwb3NpdGlvbiApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XG5cbiAgICAgICAgICAgIHZhciBoYXNoID0gbm9ybWFsLngudG9TdHJpbmcoKSArIG5vcm1hbC55LnRvU3RyaW5nKCkgKyBub3JtYWwuei50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vcm1hbHNIYXNoWyBoYXNoIF0gPSBub3JtYWxzLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICBub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoIGNvbG9yICkge1xuXG4gICAgICAgICAgICB2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sb3JzSGFzaFsgaGFzaCBdID0gY29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xuXG4gICAgICAgICAgICByZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcblxuICAgICAgICAgICAgdmFyIGhhc2ggPSB1di54LnRvU3RyaW5nKCkgKyB1di55LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgdXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5kYXRhID0ge307XG5cbiAgICAgICAgZGF0YS5kYXRhLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgICAgIGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcbiAgICAgICAgaWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIGlmICggdXZzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEudXZzID0gWyB1dnMgXTsgLy8gdGVtcG9yYWwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICBkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgICAgICB0aGlzLmZhY2VzID0gW107XG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2cyA9IFtcbiAgICAgICAgICAgIFtdXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gc291cmNlLnZlcnRpY2VzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBpIF0uY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFjZXMgPSBzb3VyY2UuZmFjZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IHNvdXJjZS5mYWNlVmVydGV4VXZzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciB1dnMgPSBmYWNlVmVydGV4VXZzWyBqIF0sXG4gICAgICAgICAgICAgICAgICAgIHV2c0NvcHkgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXYgPSB1dnNbIGsgXTtcblxuICAgICAgICAgICAgICAgICAgICB1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdLnB1c2goIHV2c0NvcHkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgICB9ICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5USFJFRS5HZW9tZXRyeUlkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0RpcmVjdEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5EaXJlY3RHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQrK1xuICAgIH0gKTtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLnR5cGUgPSAnRGlyZWN0R2VvbWV0cnknO1xuXG4gICAgdGhpcy5pbmRpY2VzID0gW107XG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIHRoaXMubm9ybWFscyA9IFtdO1xuICAgIHRoaXMuY29sb3JzID0gW107XG4gICAgdGhpcy51dnMgPSBbXTtcbiAgICB0aGlzLnV2czIgPSBbXTtcblxuICAgIHRoaXMuZ3JvdXBzID0gW107XG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xuXG4gICAgdGhpcy5za2luV2VpZ2h0cyA9IFtdO1xuICAgIHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuICAgIC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbiAgICAvLyB1cGRhdGUgZmxhZ3NcblxuICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5EaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRGlyZWN0R2VvbWV0cnksXG5cbiAgICBjb21wdXRlQm91bmRpbmdCb3g6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3gsXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nU3BoZXJlLFxuXG4gICAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZUZhY2VOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlVmVydGV4Tm9ybWFscygpIGlzIG5vdCBhIG1ldGhvZCBvZiB0aGlzIHR5cGUgb2YgZ2VvbWV0cnkuJyApO1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVHcm91cHM6IGZ1bmN0aW9uKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgZ3JvdXA7XG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAgICAgdmFyIG1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICAgICAgLy8gbWF0ZXJpYWxzXG5cbiAgICAgICAgICAgIGlmICggZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcblxuICAgICAgICAgICAgICAgIGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBncm91cHMucHVzaCggZ3JvdXAgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdyb3VwID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogaSAqIDMsXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZ3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcblxuICAgIH0sXG5cbiAgICBmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cztcblxuICAgICAgICB2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgaGFzRmFjZVZlcnRleFV2MiA9IGZhY2VWZXJ0ZXhVdnNbIDEgXSAmJiBmYWNlVmVydGV4VXZzWyAxIF0ubGVuZ3RoID4gMDtcblxuICAgICAgICAvLyBtb3JwaHNcblxuICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuICAgICAgICB2YXIgbW9ycGhUYXJnZXRzTGVuZ3RoID0gbW9ycGhUYXJnZXRzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIG1vcnBoVGFyZ2V0c0xlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHNQb3NpdGlvbiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBpIF0gPSBbXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xuICAgICAgICB2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIG1vcnBoTm9ybWFsc0xlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHNOb3JtYWwgPSBbXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpbnNcblxuICAgICAgICB2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcbiAgICAgICAgdmFyIHNraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHM7XG5cbiAgICAgICAgdmFyIGhhc1NraW5JbmRpY2VzID0gc2tpbkluZGljZXMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgZmFjZS5hIF0sIHZlcnRpY2VzWyBmYWNlLmIgXSwgdmVydGljZXNbIGZhY2UuYyBdICk7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgICAgICBpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgICAgICAgICAgaWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvcnMucHVzaCggdmVydGV4Q29sb3JzWyAwIF0sIHZlcnRleENvbG9yc1sgMSBdLCB2ZXJ0ZXhDb2xvcnNbIDIgXSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGZhY2UuY29sb3I7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXZzLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2ICcsIGkgKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYyID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyICcsIGkgKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2czIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vcnBoc1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xuXG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzUG9zaXRpb25bIGogXS5wdXNoKCBtb3JwaFRhcmdldFsgZmFjZS5hIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmIgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYyBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XG5cbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2tpbnNcblxuICAgICAgICAgICAgaWYgKCBoYXNTa2luSW5kaWNlcyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGZhY2UuYSBdLCBza2luSW5kaWNlc1sgZmFjZS5iIF0sIHNraW5JbmRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaGFzU2tpbldlaWdodHMgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXB1dGVHcm91cHMoIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG4gICAgICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcbiAgICAgICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcbiAgICAgICAgdGhpcy51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcbiAgICAgICAgdGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgICB9ICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50KytcbiAgICB9ICk7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcblxuICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHRoaXMuZ3JvdXBzID0gW107XG5cbiAgICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICAgIHRoaXMuZHJhd1JhbmdlID0ge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgY291bnQ6IEluZmluaXR5XG4gICAgfTtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LFxuXG4gICAgYWRkSW5kZXg6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuXG4gICAgfSxcblxuICAgIHNldEluZGV4OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuXG4gICAgfSxcblxuICAgIGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24oIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgJiYgYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xuXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdICkgKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG5hbWUgPT09ICdpbmRleCcgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xuICAgICAgICAgICAgdGhpcy5zZXRJbmRleCggYXR0cmlidXRlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXG4gICAgfSxcblxuICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgfSxcblxuICAgIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgfSxcblxuICAgIGdldCBkcmF3Y2FsbHMoKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuZHJhd2NhbGxzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwcztcblxuICAgIH0sXG5cbiAgICBnZXQgb2Zmc2V0cygpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzO1xuXG4gICAgfSxcblxuICAgIGFkZERyYXdDYWxsOiBmdW5jdGlvbiggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicgKTtcbiAgICAgICAgdGhpcy5hZGRHcm91cCggc3RhcnQsIGNvdW50ICk7XG5cbiAgICB9LFxuXG4gICAgY2xlYXJEcmF3Q2FsbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY2xlYXJEcmF3Q2FsbHMoKSBpcyBub3cgLmNsZWFyR3JvdXBzKCkuJyApO1xuICAgICAgICB0aGlzLmNsZWFyR3JvdXBzKCk7XG5cbiAgICB9LFxuXG4gICAgYWRkR3JvdXA6IGZ1bmN0aW9uKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICAgICAgdGhpcy5ncm91cHMucHVzaCgge1xuXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICBtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMFxuXG4gICAgICAgIH0gKTtcblxuICAgIH0sXG5cbiAgICBjbGVhckdyb3VwczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5ncm91cHMgPSBbXTtcblxuICAgIH0sXG5cbiAgICBzZXREcmF3UmFuZ2U6IGZ1bmN0aW9uKCBzdGFydCwgY291bnQgKSB7XG5cbiAgICAgICAgdGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5kcmF3UmFuZ2UuY291bnQgPSBjb3VudDtcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDogZnVuY3Rpb24oIG1hdHJpeCApIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggcG9zaXRpb24uYXJyYXkgKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cbiAgICAgICAgaWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgICAgICAgICAgbm9ybWFsTWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIG5vcm1hbC5hcnJheSApO1xuICAgICAgICAgICAgbm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJvdGF0ZVg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlWTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVaOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gc2NhbGUgZ2VvbWV0cnlcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbG9va0F0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgb2JqO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcblxuICAgICAgICAgICAgaWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgICAgICAgICBvYmoubG9va0F0KCB2ZWN0b3IgKTtcblxuICAgICAgICAgICAgb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5jZW50ZXIoKS5uZWdhdGUoKTtcblxuICAgICAgICB0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbU9iamVjdDogZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnNldEZyb21PYmplY3QoKS4gQ29udmVydGluZycsIG9iamVjdCwgdGhpcyApO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucy5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVEaXN0YW5jZXMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGgsIDEgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3QgPSBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5O1xuXG4gICAgICAgICAgICBpZiAoIGRpcmVjdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpcmVjdC52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG4gICAgICAgICAgICBkaXJlY3Qubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcbiAgICAgICAgICAgIGRpcmVjdC5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcbiAgICAgICAgICAgIGRpcmVjdC51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcbiAgICAgICAgICAgIGRpcmVjdC5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcblxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGRpcmVjdDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5jb2xvcjtcblxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcblxuICAgICAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUdyb3Vwcyggb2JqZWN0Lmdlb21ldHJ5ICk7XG4gICAgICAgICAgICB0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuICAgICAgICAgICAgZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uKCBnZW9tZXRyeSApIHtcblxuICAgICAgICBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ID0gbmV3IFRIUkVFLkRpcmVjdEdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21EaXJlY3RHZW9tZXRyeSggZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSApO1xuXG4gICAgfSxcblxuICAgIGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzICk7XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoICogMyApO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIHV2czIgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMyLmxlbmd0aCAqIDIgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBUeXBlQXJyYXkgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBUeXBlQXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xuICAgICAgICAgICAgdGhpcy5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApLmNvcHlJbmRpY2VzQXJyYXkoIGdlb21ldHJ5LmluZGljZXMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBncm91cHNcblxuICAgICAgICB0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuICAgICAgICAvLyBtb3JwaHNcblxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgbmFtZSBdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG1vcnBoVGFyZ2V0Lmxlbmd0aCAqIDMsIDMgKTtcblxuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggbW9ycGhUYXJnZXQgKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpbm5pbmdcblxuICAgICAgICBpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBza2luSW5kaWNlcyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKiA0LCA0ICk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIHNraW5JbmRpY2VzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luSW5kaWNlcyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIHNraW5XZWlnaHRzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAqIDQsIDQgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbnMgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xuICAgICAgICAgICAgICAgIGJiLm1ha2VFbXB0eSgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgICAgICAgICAgICBiYi5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHBvc2l0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICBpZiAoIHBvc2l0aW9ucyApIHtcblxuICAgICAgICAgICAgICAgIGJveC5tYWtlRW1wdHkoKTtcblxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgYm94LmV4cGFuZEJ5UG9pbnQoIHZlY3RvciApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm94LmNlbnRlciggY2VudGVyICk7XG5cbiAgICAgICAgICAgICAgICAvLyBob3BpbmcgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuICAgICAgICAgICAgICAgIHZhciBtYXhSYWRpdXNTcSA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgICAgICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuICAgICAgICAgICAgICAgIGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cbiAgICAgICAgaWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSBdID0gMDtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgICAgICAgICB2YXIgdkEsIHZCLCB2QyxcblxuICAgICAgICAgICAgICAgIHBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgICAgICBwQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICAgICAgcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICAgICAgICAgICAgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgICAgIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgLy8gaW5kZXhlZCBlbGVtZW50c1xuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuICAgICAgICAgICAgICAgIGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdyb3VwKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGdyb3Vwcy5sZW5ndGg7IGogPCBqbDsgKytqICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2QSA9IGluZGljZXNbIGkgKyAwIF0gKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdkIgPSBpbmRpY2VzWyBpICsgMSBdICogMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkMgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QSBdICs9IGNiLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QSArIDEgXSArPSBjYi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkIgXSArPSBjYi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZCICsgMiBdICs9IGNiLno7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZDICsgMSBdICs9IGNiLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuICAgICAgICAgICAgICAgICAgICBwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgICAgICAgICAgICBwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDMgKTtcbiAgICAgICAgICAgICAgICAgICAgcEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG4gICAgICAgICAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuICAgICAgICAgICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpIF0gPSBjYi54O1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgMSBdID0gY2IueTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDIgXSA9IGNiLno7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDMgXSA9IGNiLng7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgNSBdID0gY2IuejtcblxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgNiBdID0gY2IueDtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICBjb21wdXRlT2Zmc2V0czogZnVuY3Rpb24oIHNpemUgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApXG5cbiAgICB9LFxuXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCBnZW9tZXRyeSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gYXR0cmlidXRlU2l6ZSAqIG9mZnNldDsgaSA8IGF0dHJpYnV0ZUFycmF5Mi5sZW5ndGg7IGkrKywgaisrICkge1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQXJyYXkxWyBqIF0gPSBhdHRyaWJ1dGVBcnJheTJbIGkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICAgICAgdmFyIHgsIHksIHosIG47XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgeCA9IG5vcm1hbHNbIGkgXTtcbiAgICAgICAgICAgIHkgPSBub3JtYWxzWyBpICsgMSBdO1xuICAgICAgICAgICAgeiA9IG5vcm1hbHNbIGkgKyAyIF07XG5cbiAgICAgICAgICAgIG4gPSAxLjAgLyBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xuXG4gICAgICAgICAgICBub3JtYWxzWyBpIF0gKj0gbjtcbiAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAxIF0gKj0gbjtcbiAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAyIF0gKj0gbjtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuICAgICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICAgIGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmRhdGEgPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XG5cbiAgICAgICAgICAgIGRhdGEuZGF0YS5pbmRleCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBpbmRleC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGFycmF5OiBhcnJheVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhdHRyaWJ1dGUuYXJyYXkgKTtcblxuICAgICAgICAgICAgZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXG4gICAgICAgICAgICAgICAgdHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJyYXk6IGFycmF5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cbiAgICAgICAgaWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG4gICAgICAgIGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IGJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG4gICAgICAgICAgICB0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICB0eXBlOiAnZGlzcG9zZSdcbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA2NTUzNTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknO1xuICAgIHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk7XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRHcm91cCA9IGZ1bmN0aW9uKCBzdGFydCwgY291bnQsIGluc3RhbmNlcyApIHtcblxuICAgIHRoaXMuZ3JvdXBzLnB1c2goIHtcblxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZXNcblxuICAgIH0gKTtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgdmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xuXG4gICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICB0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcbiAgICAgICAgdGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5pbnN0YW5jZXMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkNhbWVyYSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0NhbWVyYSc7XG5cbiAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxufTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbWVyYTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAtMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgfTtcblxufSgpO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgY2FtZXJhcyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cbiAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgbTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcblxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xuXG4gICAgfTtcblxufSgpO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0N1YmVDYW1lcmEuanNcblxuLyoqXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcbiAqXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xuXG4gICAgdmFyIGZvdiA9IDkwLFxuICAgICAgICBhc3BlY3QgPSAxO1xuXG4gICAgdmFyIGNhbWVyYVBYID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgY2FtZXJhUFgudXAuc2V0KCAwLCAtMSwgMCApO1xuICAgIGNhbWVyYVBYLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSApO1xuICAgIHRoaXMuYWRkKCBjYW1lcmFQWCApO1xuXG4gICAgdmFyIGNhbWVyYU5YID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgY2FtZXJhTlgudXAuc2V0KCAwLCAtMSwgMCApO1xuICAgIGNhbWVyYU5YLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIC0xLCAwLCAwICkgKTtcbiAgICB0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuICAgIHZhciBjYW1lcmFQWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xuICAgIGNhbWVyYVBZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuICAgIHRoaXMuYWRkKCBjYW1lcmFQWSApO1xuXG4gICAgdmFyIGNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgY2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtMSApO1xuICAgIGNhbWVyYU5ZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0xLCAwICkgKTtcbiAgICB0aGlzLmFkZCggY2FtZXJhTlkgKTtcblxuICAgIHZhciBjYW1lcmFQWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIGNhbWVyYVBaLnVwLnNldCggMCwgLTEsIDAgKTtcbiAgICBjYW1lcmFQWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICkgKTtcbiAgICB0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuICAgIHZhciBjYW1lcmFOWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIGNhbWVyYU5aLnVwLnNldCggMCwgLTEsIDAgKTtcbiAgICBjYW1lcmFOWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtMSApICk7XG4gICAgdGhpcy5hZGQoIGNhbWVyYU5aICk7XG5cbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwge1xuICAgICAgICBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCxcbiAgICAgICAgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsXG4gICAgICAgIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyXG4gICAgfSApO1xuXG4gICAgdGhpcy51cGRhdGVDdWJlTWFwID0gZnVuY3Rpb24oIHJlbmRlcmVyLCBzY2VuZSApIHtcblxuICAgICAgICBpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICAgICAgdmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHM7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDA7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAxO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDM7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA0O1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcblxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XG5cbiAgICB9O1xuXG59O1xuXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlQ2FtZXJhO1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24oIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG4gICAgVEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXG4gICAgdGhpcy56b29tID0gMTtcblxuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuXG4gICAgdGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XG4gICAgdGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xuXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhO1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XG4gICAgdmFyIGR5ID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcbiAgICB2YXIgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XG4gICAgdmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGN4IC0gZHgsIGN4ICsgZHgsIGN5ICsgZHksIGN5IC0gZHksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMubGVmdCA9IHNvdXJjZS5sZWZ0O1xuICAgIHRoaXMucmlnaHQgPSBzb3VyY2UucmlnaHQ7XG4gICAgdGhpcy50b3AgPSBzb3VyY2UudG9wO1xuICAgIHRoaXMuYm90dG9tID0gc291cmNlLmJvdHRvbTtcbiAgICB0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcbiAgICB0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cbiAgICB0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG4gICAgZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcbiAgICBkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XG4gICAgZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XG4gICAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcbiAgICBkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24oIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cbiAgICBUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcblxuICAgIHRoaXMuem9vbSA9IDE7XG5cbiAgICB0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XG4gICAgdGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XG4gICAgdGhpcy5uZWFyID0gbmVhciAhPT0gdW5kZWZpbmVkID8gbmVhciA6IDAuMTtcbiAgICB0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcblxuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtcblxuXG4vKipcbiAqIFVzZXMgRm9jYWwgTGVuZ3RoIChpbiBtbSkgdG8gZXN0aW1hdGUgYW5kIHNldCBGT1ZcbiAqIDM1bW0gKGZ1bGwtZnJhbWUpIGNhbWVyYSBpcyB1c2VkIGlmIGZyYW1lIHNpemUgaXMgbm90IHNwZWNpZmllZDtcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uKCBmb2NhbExlbmd0aCwgZnJhbWVIZWlnaHQgKSB7XG5cbiAgICBpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xuXG4gICAgdGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5cbi8qKlxuICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxuICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxuICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuICpcbiAqICAgKy0tLSstLS0rLS0tK1xuICogICB8IEEgfCBCIHwgQyB8XG4gKiAgICstLS0rLS0tKy0tLStcbiAqICAgfCBEIHwgRSB8IEYgfFxuICogICArLS0tKy0tLSstLS0rXG4gKlxuICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xuICpcbiAqICAgdmFyIHcgPSAxOTIwO1xuICogICB2YXIgaCA9IDEwODA7XG4gKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcbiAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcbiAqXG4gKiAgIC0tQS0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tQi0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tQy0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tRC0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XG4gKiAgIC0tRS0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XG4gKiAgIC0tRi0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG4gKlxuICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRWaWV3T2Zmc2V0ID0gZnVuY3Rpb24oIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgIHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuICAgIHRoaXMuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZm92ID0gVEhSRUUuTWF0aC5yYWRUb0RlZyggMiAqIE1hdGguYXRhbiggTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRoaXMuZm92ICkgKiAwLjUgKSAvIHRoaXMuem9vbSApICk7XG5cbiAgICBpZiAoIHRoaXMuZnVsbFdpZHRoICkge1xuXG4gICAgICAgIHZhciBhc3BlY3QgPSB0aGlzLmZ1bGxXaWR0aCAvIHRoaXMuZnVsbEhlaWdodDtcbiAgICAgICAgdmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApICogdGhpcy5uZWFyO1xuICAgICAgICB2YXIgYm90dG9tID0gLXRvcDtcbiAgICAgICAgdmFyIGxlZnQgPSBhc3BlY3QgKiBib3R0b207XG4gICAgICAgIHZhciByaWdodCA9IGFzcGVjdCAqIHRvcDtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoIHRvcCAtIGJvdHRvbSApO1xuXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlRnJ1c3R1bShcbiAgICAgICAgICAgIGxlZnQgKyB0aGlzLnggKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxuICAgICAgICAgICAgbGVmdCArICggdGhpcy54ICsgdGhpcy53aWR0aCApICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcbiAgICAgICAgICAgIHRvcCAtICggdGhpcy55ICsgdGhpcy5oZWlnaHQgKSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcbiAgICAgICAgICAgIHRvcCAtIHRoaXMueSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcbiAgICAgICAgICAgIHRoaXMubmVhcixcbiAgICAgICAgICAgIHRoaXMuZmFyXG4gICAgICAgICk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggZm92LCB0aGlzLmFzcGVjdCwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG4gICAgdGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xuICAgIHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuICAgIHRoaXMuZmFyID0gc291cmNlLmZhcjtcblxuICAgIHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xuICAgIGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xuICAgIGRhdGEub2JqZWN0LmFzcGVjdCA9IHRoaXMuYXNwZWN0O1xuICAgIGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG4gICAgZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0xpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGlnaHQgPSBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTGlnaHQnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcblxufTtcblxuVEhSRUUuTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaWdodDtcblxuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG4vLyBGaWxlOnNyYy9saWdodHMvQW1iaWVudExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BbWJpZW50TGlnaHQgPSBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gICAgdGhpcy50eXBlID0gJ0FtYmllbnRMaWdodCc7XG5cbn07XG5cblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BbWJpZW50TGlnaHQ7XG5cblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodCA9IGZ1bmN0aW9uKCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICAgIHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcblxuICAgIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG4gICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgIHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cbiAgICB0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgICB0aGlzLm9ubHlTaGFkb3cgPSBmYWxzZTtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IDUwO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhTGVmdCA9IC01MDA7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFSaWdodCA9IDUwMDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYVRvcCA9IDUwMDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbSA9IC01MDA7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcblxuICAgIHRoaXMuc2hhZG93QmlhcyA9IDA7XG4gICAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcblxuICAgIHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XG4gICAgdGhpcy5zaGFkb3dNYXBIZWlnaHQgPSA1MTI7XG5cbiAgICB0aGlzLnNoYWRvd01hcCA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dNYXBTaXplID0gbnVsbDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dNYXRyaXggPSBudWxsO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuICAgIHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xuXG4gICAgdGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG4gICAgdGhpcy5vbmx5U2hhZG93ID0gc291cmNlLm9ubHlTaGFkb3c7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYU5lYXIgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhTmVhcjtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFGYXI7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYUxlZnQgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhTGVmdDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYVJpZ2h0ID0gc291cmNlLnNoYWRvd0NhbWVyYVJpZ2h0O1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhVG9wID0gc291cmNlLnNoYWRvd0NhbWVyYVRvcDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbSA9IHNvdXJjZS5zaGFkb3dDYW1lcmFCb3R0b207XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhVmlzaWJsZTtcblxuICAgIHRoaXMuc2hhZG93QmlhcyA9IHNvdXJjZS5zaGFkb3dCaWFzO1xuICAgIHRoaXMuc2hhZG93RGFya25lc3MgPSBzb3VyY2Uuc2hhZG93RGFya25lc3M7XG5cbiAgICB0aGlzLnNoYWRvd01hcFdpZHRoID0gc291cmNlLnNoYWRvd01hcFdpZHRoO1xuICAgIHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gc291cmNlLnNoYWRvd01hcEhlaWdodDtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gICAgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ID0gZnVuY3Rpb24oIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IgKTtcblxuICAgIHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xuXG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgdGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3IgKTtcbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHQ7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuZ3JvdW5kQ29sb3IuY29weSggc291cmNlLmdyb3VuZENvbG9yICk7XG4gICAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICAgIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcbiAgICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRMaWdodCA9IGZ1bmN0aW9uKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xuXG4gICAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuICAgIHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcbiAgICB0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7IC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxufTtcblxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodDtcblxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcbiAgICB0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuICAgIHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICAgIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuICAgIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcbiAgICBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL1Nwb3RMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24oIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgZXhwb25lbnQsIGRlY2F5ICkge1xuXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xuXG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcbiAgICB0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG4gICAgdGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcbiAgICB0aGlzLmV4cG9uZW50ID0gKCBleHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBleHBvbmVudCA6IDEwO1xuICAgIHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTsgLy8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG4gICAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgdGhpcy5vbmx5U2hhZG93ID0gZmFsc2U7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYU5lYXIgPSA1MDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IDUwMDA7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFGb3YgPSA1MDtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5zaGFkb3dCaWFzID0gMDtcbiAgICB0aGlzLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuXG4gICAgdGhpcy5zaGFkb3dNYXBXaWR0aCA9IDUxMjtcbiAgICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcblxuICAgIHRoaXMuc2hhZG93TWFwID0gbnVsbDtcbiAgICB0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHQ7XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcbiAgICB0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuICAgIHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG4gICAgdGhpcy5leHBvbmVudCA9IHNvdXJjZS5leHBvbmVudDtcbiAgICB0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG4gICAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cbiAgICB0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcbiAgICB0aGlzLm9ubHlTaGFkb3cgPSBzb3VyY2Uub25seVNoYWRvdztcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFOZWFyO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gc291cmNlLnNoYWRvd0NhbWVyYUZhcjtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUZvdiA9IHNvdXJjZS5zaGFkb3dDYW1lcmFGb3Y7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhVmlzaWJsZTtcblxuICAgIHRoaXMuc2hhZG93QmlhcyA9IHNvdXJjZS5zaGFkb3dCaWFzO1xuICAgIHRoaXMuc2hhZG93RGFya25lc3MgPSBzb3VyY2Uuc2hhZG93RGFya25lc3M7XG5cbiAgICB0aGlzLnNoYWRvd01hcFdpZHRoID0gc291cmNlLnNoYWRvd01hcFdpZHRoO1xuICAgIHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gc291cmNlLnNoYWRvd01hcEhlaWdodDtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcbiAgICBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG4gICAgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIGRhdGEub2JqZWN0LmV4cG9uZW50ID0gdGhpcy5leHBvbmVudDtcbiAgICBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9DYWNoZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ2FjaGUgPSB7XG5cbiAgICBlbmFibGVkOiBmYWxzZSxcblxuICAgIGZpbGVzOiB7fSxcblxuICAgIGFkZDogZnVuY3Rpb24oIGtleSwgZmlsZSApIHtcblxuICAgICAgICBpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG4gICAgICAgIHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcblxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcblxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbIGtleSBdO1xuXG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmZpbGVzID0ge307XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkZXIgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbigpIHt9O1xuXG59O1xuXG5USFJFRS5Mb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcblxuICAgIGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cbiAgICBleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24oIHVybCApIHtcblxuICAgICAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xuXG4gICAgICAgIGlmICggcGFydHMubGVuZ3RoID09PSAxICkgcmV0dXJuICcuLyc7XG5cbiAgICAgICAgcGFydHMucG9wKCk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oICcvJyApICsgJy8nO1xuXG4gICAgfSxcblxuICAgIGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyArK2kgKSB7XG5cbiAgICAgICAgICAgIGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICBjcmVhdGVNYXRlcmlhbDogKCBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaW1hZ2VMb2FkZXI7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1hdGVyaWFsKCBtLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICggY3Jvc3NPcmlnaW4gPT09IHVuZGVmaW5lZCAmJiBzY29wZS5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgY3Jvc3NPcmlnaW4gPSBzY29wZS5jcm9zc09yaWdpbjtcblxuICAgICAgICAgICAgaWYgKCBpbWFnZUxvYWRlciA9PT0gdW5kZWZpbmVkICkgaW1hZ2VMb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbmVhcmVzdF9wb3cyKCBuICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBNYXRoLmxvZyggbiApIC8gTWF0aC5MTjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLnJvdW5kKCBsICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVfdGV4dHVyZSggd2hlcmUsIG5hbWUsIHNvdXJjZUZpbGUsIHJlcGVhdCwgb2Zmc2V0LCB3cmFwLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBzb3VyY2VGaWxlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbG9hZGVyID0gVEhSRUUuTG9hZGVyLkhhbmRsZXJzLmdldCggZnVsbFBhdGggKTtcblxuICAgICAgICAgICAgICAgIGlmICggbG9hZGVyICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSBsb2FkZXIubG9hZCggZnVsbFBhdGggKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBsb2FkZXIgPSBpbWFnZUxvYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApO1xuICAgICAgICAgICAgICAgICAgICBsb2FkZXIubG9hZCggZnVsbFBhdGgsIGZ1bmN0aW9uKCBpbWFnZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gbmVhcmVzdF9wb3cyKCBpbWFnZS53aWR0aCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBuZWFyZXN0X3BvdzIoIGltYWdlLmhlaWdodCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBjYW52YXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmUuc291cmNlRmlsZSA9IHNvdXJjZUZpbGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJlcGVhdCApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLnJlcGVhdC5zZXQoIHJlcGVhdFsgMCBdLCByZXBlYXRbIDEgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG9mZnNldCApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm9mZnNldC5zZXQoIG9mZnNldFsgMCBdLCBvZmZzZXRbIDEgXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB3cmFwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwTWFwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcGVhdCc6IFRIUkVFLlJlcGVhdFdyYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pcnJvcic6IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHdyYXBNYXBbIHdyYXBbIDAgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBTID0gd3JhcE1hcFsgd3JhcFsgMCBdIF07XG4gICAgICAgICAgICAgICAgICAgIGlmICggd3JhcE1hcFsgd3JhcFsgMSBdIF0gIT09IHVuZGVmaW5lZCApIHRleHR1cmUud3JhcFQgPSB3cmFwTWFwWyB3cmFwWyAxIF0gXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggYW5pc290cm9weSApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hlcmVbIG5hbWUgXSA9IHRleHR1cmU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmdiMmhleCggcmdiICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICggcmdiWyAwIF0gKiAyNTUgPDwgMTYgKSArICggcmdiWyAxIF0gKiAyNTUgPDwgOCApICsgcmdiWyAyIF0gKiAyNTU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVmYXVsdHNcblxuICAgICAgICAgICAgdmFyIG10eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xuICAgICAgICAgICAgdmFyIG1wYXJzID0ge307XG5cbiAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgZnJvbSBtb2RlbCBmaWxlXG5cbiAgICAgICAgICAgIGlmICggbS5zaGFkaW5nICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRpbmcgPSBtLnNoYWRpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICggc2hhZGluZyA9PT0gJ3Bob25nJyApIG10eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICggc2hhZGluZyA9PT0gJ2Jhc2ljJyApIG10eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiBUSFJFRVsgbS5ibGVuZGluZyBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5ibGVuZGluZyA9IFRIUkVFWyBtLmJsZW5kaW5nIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy50cmFuc3BhcmVudCA9IG0udHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBtLm9wYWNpdHkgPCAxLjAgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuZGVwdGhUZXN0ID0gbS5kZXB0aFRlc3Q7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLmRlcHRoV3JpdGUgPSBtLmRlcHRoV3JpdGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLnZpc2libGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLnZpc2libGUgPSBtLnZpc2libGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLmZsaXBTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuc2lkZSA9IFRIUkVFLkJhY2tTaWRlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5kb3VibGVTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMud2lyZWZyYW1lID0gbS53aXJlZnJhbWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtLnZlcnRleENvbG9ycyA9PT0gJ2ZhY2UnICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1wYXJzLnZlcnRleENvbG9ycyA9IFRIUkVFLkZhY2VDb2xvcnM7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIG0udmVydGV4Q29sb3JzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1wYXJzLnZlcnRleENvbG9ycyA9IFRIUkVFLlZlcnRleENvbG9ycztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb2xvcnNcblxuICAgICAgICAgICAgaWYgKCBtLmNvbG9yRGlmZnVzZSApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLmNvbG9yID0gcmdiMmhleCggbS5jb2xvckRpZmZ1c2UgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIG0uRGJnQ29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5jb2xvciA9IG0uRGJnQ29sb3I7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLmNvbG9yRW1pc3NpdmUgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5lbWlzc2l2ZSA9IHJnYjJoZXgoIG0uY29sb3JFbWlzc2l2ZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbXR5cGUgPT09ICdNZXNoUGhvbmdNYXRlcmlhbCcgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0uY29sb3JTcGVjdWxhciApIHtcblxuICAgICAgICAgICAgICAgICAgICBtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtLnNwZWN1bGFyQ29lZiApIHtcblxuICAgICAgICAgICAgICAgICAgICBtcGFycy5zaGluaW5lc3MgPSBtLnNwZWN1bGFyQ29lZjtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb2RpZmllcnNcblxuICAgICAgICAgICAgaWYgKCBtLnRyYW5zcGFyZW5jeSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xuICAgICAgICAgICAgICAgIG0ub3BhY2l0eSA9IG0udHJhbnNwYXJlbmN5O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5vcGFjaXR5ID0gbS5vcGFjaXR5O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRleHR1cmVzXG5cbiAgICAgICAgICAgIGlmICggdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0ubWFwRGlmZnVzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdtYXAnLCBtLm1hcERpZmZ1c2UsIG0ubWFwRGlmZnVzZVJlcGVhdCwgbS5tYXBEaWZmdXNlT2Zmc2V0LCBtLm1hcERpZmZ1c2VXcmFwLCBtLm1hcERpZmZ1c2VBbmlzb3Ryb3B5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0ubWFwTGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbGlnaHRNYXAnLCBtLm1hcExpZ2h0LCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbS5tYXBBTyApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdhb01hcCcsIG0ubWFwQU8sIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtLm1hcEJ1bXAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYnVtcE1hcCcsIG0ubWFwQnVtcCwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbS5tYXBOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbm9ybWFsTWFwJywgbS5tYXBOb3JtYWwsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbS5tYXBTcGVjdWxhciApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdzcGVjdWxhck1hcCcsIG0ubWFwU3BlY3VsYXIsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtLm1hcEFscGhhICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ2FscGhhTWFwJywgbS5tYXBBbHBoYSwgbS5tYXBBbHBoYVJlcGVhdCwgbS5tYXBBbHBoYU9mZnNldCwgbS5tYXBBbHBoYVdyYXAsIG0ubWFwQWxwaGFBbmlzb3Ryb3B5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgaWYgKCBtLm1hcEJ1bXBTY2FsZSApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLmJ1bXBTY2FsZSA9IG0ubWFwQnVtcFNjYWxlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5tYXBOb3JtYWxGYWN0b3IgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBtLm1hcE5vcm1hbEZhY3RvciwgbS5tYXBOb3JtYWxGYWN0b3IgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIG10eXBlIF0oIG1wYXJzICk7XG5cbiAgICAgICAgICAgIGlmICggbS5EYmdOYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gbS5EYmdOYW1lO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XG5cbiAgICAgICAgfTtcblxuICAgIH0gKSgpXG5cbn07XG5cblRIUkVFLkxvYWRlci5IYW5kbGVycyA9IHtcblxuICAgIGhhbmRsZXJzOiBbXSxcblxuICAgIGFkZDogZnVuY3Rpb24oIHJlZ2V4LCBsb2FkZXIgKSB7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiggZmlsZSApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gdGhpcy5oYW5kbGVyc1sgaSBdO1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMuaGFuZGxlcnNbIGkgKyAxIF07XG5cbiAgICAgICAgICAgIGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlcjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9YSFJMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlhIUkxvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlhIUkxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XG5cbiAgICAgICAgaWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBvbkxvYWQoIGNhY2hlZCApO1xuXG4gICAgICAgICAgICAgICAgfSwgMCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xuXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIFRIUkVFLkNhY2hlLmFkZCggdXJsLCB0aGlzLnJlc3BvbnNlICk7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzLnJlc3BvbnNlICk7XG5cbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICAgICAgfSwgZmFsc2UgKTtcblxuICAgICAgICBpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKCBldmVudCApO1xuXG4gICAgICAgICAgICB9LCBmYWxzZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG4gICAgICAgIH0sIGZhbHNlICk7XG5cbiAgICAgICAgaWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICAgICAgaWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgaWYgKCB0aGlzLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcblxuICAgICAgICByZXF1ZXN0LnNlbmQoIG51bGwgKTtcblxuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG5cbiAgICB9LFxuXG4gICAgc2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBzZXRXaXRoQ3JlZGVudGlhbHM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLkltYWdlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5JbWFnZUxvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xuXG4gICAgICAgIGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCBjYWNoZWQgKTtcblxuICAgICAgICAgICAgICAgIH0sIDAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW1nJyApO1xuXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcyApO1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGhpcyApO1xuXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgICAgIH0sIGZhbHNlICk7XG5cbiAgICAgICAgaWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIH0sIGZhbHNlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG4gICAgICAgIH0sIGZhbHNlICk7XG5cbiAgICAgICAgaWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgICAgIGltYWdlLnNyYyA9IHVybDtcblxuICAgICAgICByZXR1cm4gaW1hZ2U7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvSlNPTkxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkpTT05Mb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBzaG93U3RhdHVzIHBhcmFtZXRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gY29uc3RydWN0b3IuJyApO1xuICAgICAgICBtYW5hZ2VyID0gdW5kZWZpbmVkO1xuXG4gICAgfVxuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5KU09OTG9hZGVyLFxuXG4gICAgLy8gRGVwcmVjYXRlZFxuXG4gICAgZ2V0IHN0YXR1c0RvbUVsZW1lbnQoKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLl9zdGF0dXNEb21FbGVtZW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiAuc3RhdHVzRG9tRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQ7XG5cbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHRleHR1cmVQYXRoID0gdGhpcy50ZXh0dXJlUGF0aCAmJiAoIHR5cGVvZiB0aGlzLnRleHR1cmVQYXRoID09PSBcInN0cmluZ1wiICkgPyB0aGlzLnRleHR1cmVQYXRoIDogVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5leHRyYWN0VXJsQmFzZSggdXJsICk7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIHRleHQgKSB7XG5cbiAgICAgICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuICAgICAgICAgICAgaWYgKCBtZXRhZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtZXRhZGF0YS50eXBlID09PSAnb2JqZWN0JyApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtZXRhZGF0YS50eXBlID09PSAnc2NlbmUnICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG4gICAgICAgICAgICBvbkxvYWQoIG9iamVjdC5nZW9tZXRyeSwgb2JqZWN0Lm1hdGVyaWFscyApO1xuXG4gICAgICAgIH0gKTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24oIGpzb24sIHRleHR1cmVQYXRoICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxuICAgICAgICAgICAgc2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcblxuICAgICAgICBwYXJzZU1vZGVsKCBzY2FsZSApO1xuXG4gICAgICAgIHBhcnNlU2tpbigpO1xuICAgICAgICBwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xuXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpLCBqLCBmaSxcblxuICAgICAgICAgICAgICAgIG9mZnNldCwgekxlbmd0aCxcblxuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxuXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBpc1F1YWQsXG4gICAgICAgICAgICAgICAgaGFzTWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgaGFzRmFjZVZlcnRleFV2LFxuICAgICAgICAgICAgICAgIGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsXG4gICAgICAgICAgICAgICAgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXG5cbiAgICAgICAgICAgICAgICB1dkxheWVyLCB1diwgdSwgdixcblxuICAgICAgICAgICAgICAgIGZhY2VzID0ganNvbi5mYWNlcyxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXG4gICAgICAgICAgICAgICAgbm9ybWFscyA9IGpzb24ubm9ybWFscyxcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBqc29uLmNvbG9ycyxcblxuICAgICAgICAgICAgICAgIG5VdkxheWVycyA9IDA7XG5cbiAgICAgICAgICAgIGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycysrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgICAgIHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCsrIF0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQrKyBdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgdmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0KysgXSAqIHNjYWxlO1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgIHR5cGUgPSBmYWNlc1sgb2Zmc2V0KysgXTtcblxuXG4gICAgICAgICAgICAgICAgaXNRdWFkID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcbiAgICAgICAgICAgICAgICBoYXNNYXRlcmlhbCA9IGlzQml0U2V0KCB0eXBlLCAxICk7XG4gICAgICAgICAgICAgICAgaGFzRmFjZVZlcnRleFV2ID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcbiAgICAgICAgICAgICAgICBoYXNGYWNlTm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcbiAgICAgICAgICAgICAgICBoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcbiAgICAgICAgICAgICAgICBoYXNGYWNlQ29sb3IgPSBpc0JpdFNldCggdHlwZSwgNiApO1xuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInR5cGVcIiwgdHlwZSwgXCJiaXRzXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpc1F1YWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZUEgPSBuZXcgVEhSRUUuRmFjZTMoKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUEuYSA9IGZhY2VzWyBvZmZzZXQgXTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XG4gICAgICAgICAgICAgICAgICAgIGZhY2VBLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VCID0gbmV3IFRIUkVFLkZhY2UzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VCLmEgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUIuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUEubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlQi5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgNDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXSAqIDM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VBLm5vcm1hbC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA0OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdICogMztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgNDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VCICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMygpO1xuICAgICAgICAgICAgICAgICAgICBmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5iID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgIGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG4gICAgICAgICAgICAgICAgICAgIGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgMzsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF0gKiAzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlLm5vcm1hbC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgMzsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXSAqIDM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlU2tpbigpIHtcblxuICAgICAgICAgICAgdmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xuXG4gICAgICAgICAgICBpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGpzb24uc2tpbldlaWdodHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMiBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMyBdIDogMDtcblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBqc29uLnNraW5JbmRpY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDMgXSA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICYmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICE9PSBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggfHwgZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICE9PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1doZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCArICcpLCBhbmQgc2tpbldlaWdodHMgKCcgKyBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKyAnKSBzaG91bGQgbWF0Y2guJyApO1xuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gY291bGQgY2hhbmdlIHRoaXMgdG8ganNvbi5hbmltYXRpb25zWzBdIG9yIHJlbW92ZSBjb21wbGV0ZWx5XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmFuaW1hdGlvbiA9IGpzb24uYW5pbWF0aW9uO1xuICAgICAgICAgICAgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IGpzb24uYW5pbWF0aW9ucztcblxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xuXG4gICAgICAgICAgICBpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaSwgbCwgdiwgdmwsIGRzdFZlcnRpY2VzLCBzcmNWZXJ0aWNlcztcblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcbiAgICAgICAgICAgICAgICAgICAgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpLCBsLCBjLCBjbCwgZHN0Q29sb3JzLCBzcmNDb2xvcnMsIGNvbG9yO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhDb2xvcnNbIGkgXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLmNvbG9ycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGRzdENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzO1xuICAgICAgICAgICAgICAgICAgICBzcmNDb2xvcnMgPSBqc29uLm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGMgPSAwLCBjbCA9IHNyY0NvbG9ycy5sZW5ndGg7IGMgPCBjbDsgYyArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmFhMDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLnNldFJHQiggc3JjQ29sb3JzWyBjIF0sIHNyY0NvbG9yc1sgYyArIDEgXSwgc3JjQ29sb3JzWyBjICsgMiBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkc3RDb2xvcnMucHVzaCggY29sb3IgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmluaXRNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgdGhpcy5jcm9zc09yaWdpbiApO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHM6IG1hdGVyaWFsc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTG9hZGluZ01hbmFnZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxvYWRpbmdNYW5hZ2VyID0gZnVuY3Rpb24oIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgaXNMb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIGl0ZW1zTG9hZGVkID0gMCxcbiAgICAgICAgaXRlbXNUb3RhbCA9IDA7XG5cbiAgICB0aGlzLm9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkxvYWQgPSBvbkxvYWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuXG4gICAgdGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiggdXJsICkge1xuXG4gICAgICAgIGl0ZW1zVG90YWwrKztcblxuICAgICAgICBpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUub25TdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlzTG9hZGluZyA9IHRydWU7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5pdGVtRW5kID0gZnVuY3Rpb24oIHVybCApIHtcblxuICAgICAgICBpdGVtc0xvYWRlZCsrO1xuXG4gICAgICAgIGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaXRlbXNMb2FkZWQgPT09IGl0ZW1zVG90YWwgKSB7XG5cbiAgICAgICAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUub25Mb2FkKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiggdXJsICkge1xuXG4gICAgICAgIGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBzY29wZS5vbkVycm9yKCB1cmwgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59O1xuXG5USFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoKTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9CdWZmZXJHZW9tZXRyeUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIHRleHQgKSB7XG5cbiAgICAgICAgICAgIG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICAgICAgICB2YXIgaW5kZXggPSBqc29uLmRhdGEuaW5kZXg7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgdHlwZWRBcnJheSA9IG5ldyBzZWxmWyBpbmRleC50eXBlIF0oIGluZGV4LmFycmF5ICk7XG4gICAgICAgICAgICBnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG4gICAgICAgICAgICB2YXIgdHlwZWRBcnJheSA9IG5ldyBzZWxmWyBhdHRyaWJ1dGUudHlwZSBdKCBhdHRyaWJ1dGUuYXJyYXkgKTtcblxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cbiAgICAgICAgaWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBuID0gZ3JvdXBzLmxlbmd0aDsgaSAhPT0gbjsgKytpICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nU3BoZXJlID0ganNvbi5kYXRhLmJvdW5kaW5nU3BoZXJlO1xuXG4gICAgICAgIGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIGNlbnRlciwgYm91bmRpbmdTcGhlcmUucmFkaXVzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9NYXRlcmlhbExvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcblxufTtcblxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXG4gICAgICAgICAgICBvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBzZXRUZXh0dXJlczogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBnZXRUZXh0dXJlOiBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xuXG4gICAgICAgIGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xuXG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIGpzb24udHlwZSBdO1xuICAgICAgICBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xuXG4gICAgICAgIGlmICgganNvbi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xuICAgICAgICBpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xuICAgICAgICBpZiAoIGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleCgganNvbi5lbWlzc2l2ZSApO1xuICAgICAgICBpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xuICAgICAgICBpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcbiAgICAgICAgaWYgKCBqc29uLnVuaWZvcm1zICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51bmlmb3JtcyA9IGpzb24udW5pZm9ybXM7XG4gICAgICAgIGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuICAgICAgICBpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcbiAgICAgICAgaWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG4gICAgICAgIGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkaW5nID0ganNvbi5zaGFkaW5nO1xuICAgICAgICBpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcbiAgICAgICAgaWYgKCBqc29uLnNpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG4gICAgICAgIGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xuICAgICAgICBpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcbiAgICAgICAgaWYgKCBqc29uLmFscGhhVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XG4gICAgICAgIGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xuICAgICAgICBpZiAoIGpzb24uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGpzb24uZGVwdGhXcml0ZTtcbiAgICAgICAgaWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG4gICAgICAgIGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgICAgIC8vIGZvciBQb2ludHNNYXRlcmlhbFxuICAgICAgICBpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcbiAgICAgICAgaWYgKCBqc29uLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247XG5cbiAgICAgICAgLy8gbWFwc1xuXG4gICAgICAgIGlmICgganNvbi5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5tYXAgKTtcblxuICAgICAgICBpZiAoIGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgbWF0ZXJpYWwuYWxwaGFNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcbiAgICAgICAgICAgIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYnVtcE1hcCApO1xuICAgICAgICBpZiAoIGpzb24uYnVtcFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBqc29uLmJ1bXBTY2FsZTtcblxuICAgICAgICBpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubm9ybWFsTWFwICk7XG4gICAgICAgIGlmICgganNvbi5ub3JtYWxTY2FsZSApIG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIGpzb24ubm9ybWFsU2NhbGUsIGpzb24ubm9ybWFsU2NhbGUgKTtcblxuICAgICAgICBpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XG4gICAgICAgIGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgICAgICBpZiAoIGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50QmlhcztcblxuICAgICAgICBpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XG5cbiAgICAgICAgaWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBtYXRlcmlhbC5lbnZNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uZW52TWFwICk7XG4gICAgICAgICAgICBtYXRlcmlhbC5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgganNvbi5yZWZsZWN0aXZpdHkgKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcblxuICAgICAgICBpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmxpZ2h0TWFwICk7XG4gICAgICAgIGlmICgganNvbi5saWdodE1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgICAgIGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYW9NYXAgKTtcbiAgICAgICAgaWYgKCBqc29uLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGpzb24uYW9NYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgLy8gTWVzaEZhY2VNYXRlcmlhbFxuXG4gICAgICAgIGlmICgganNvbi5tYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRlcmlhbDtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9PYmplY3RMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk9iamVjdExvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG4gICAgdGhpcy50ZXh0dXJlUGF0aCA9ICcnO1xuXG59O1xuXG5USFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk9iamVjdExvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICBpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xuXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIHRleHQgKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCApO1xuXG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIH0sXG5cbiAgICBzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24oIGpzb24sIG9uTG9hZCApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcblxuICAgICAgICB2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygganNvbi5pbWFnZXMsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcbiAgICAgICAgdmFyIG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyApO1xuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xuXG4gICAgICAgIGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfSxcblxuICAgIHBhcnNlR2VvbWV0cmllczogZnVuY3Rpb24oIGpzb24gKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJpZXMgPSB7fTtcblxuICAgICAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkpTT05Mb2FkZXIoKTtcbiAgICAgICAgICAgIHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQbGFuZUdlb21ldHJ5JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFWyBkYXRhLnR5cGUgXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdCb3hHZW9tZXRyeSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRlcHRoU2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1c1RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1c0JvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vcGVuRW5kZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NwaGVyZUdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdEb2RlY2FoZWRyb25HZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGV0YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdJY29zYWhlZHJvbkdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnT2N0YWhlZHJvbkdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGV0YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUZXRyYWhlZHJvbkdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUmluZ0dlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUmluZ0dlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5uZXJSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG9ydXNHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hcmNcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNjYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUZXh0R2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXh0R2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0dlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcIicgKyBkYXRhLnR5cGUgKyAnXCInICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudXVpZCA9IGRhdGEudXVpZDtcblxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cmllc1sgZGF0YS51dWlkIF0gPSBnZW9tZXRyeTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2VvbWV0cmllcztcblxuICAgIH0sXG5cbiAgICBwYXJzZU1hdGVyaWFsczogZnVuY3Rpb24oIGpzb24sIHRleHR1cmVzICkge1xuXG4gICAgICAgIHZhciBtYXRlcmlhbHMgPSB7fTtcblxuICAgICAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xuICAgICAgICAgICAgbG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSgganNvblsgaSBdICk7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzWyBtYXRlcmlhbC51dWlkIF0gPSBtYXRlcmlhbDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0ZXJpYWxzO1xuXG4gICAgfSxcblxuICAgIHBhcnNlSW1hZ2VzOiBmdW5jdGlvbigganNvbiwgb25Mb2FkICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgIHZhciBpbWFnZXMgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkSW1hZ2UoIHVybCApIHtcblxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoIG9uTG9hZCApO1xuXG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCBtYW5hZ2VyICk7XG4gICAgICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBqc29uWyBpIF07XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QoIGltYWdlLnVybCApID8gaW1hZ2UudXJsIDogc2NvcGUudGV4dHVyZVBhdGggKyBpbWFnZS51cmw7XG5cbiAgICAgICAgICAgICAgICBpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbWFnZXM7XG5cbiAgICB9LFxuXG4gICAgcGFyc2VUZXh0dXJlczogZnVuY3Rpb24oIGpzb24sIGltYWdlcyApIHtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YoIHZhbHVlICkgPT09ICdudW1iZXInICkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XG5cbiAgICAgICAgICAgIHJldHVybiBUSFJFRVsgdmFsdWUgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHR1cmVzID0ge307XG5cbiAgICAgICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uWyBpIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSApO1xuICAgICAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nICk7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5vZmZzZXRbIDAgXSwgZGF0YS5vZmZzZXRbIDEgXSApO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEucmVwZWF0WyAwIF0sIGRhdGEucmVwZWF0WyAxIF0gKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyICk7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hZ0ZpbHRlciApO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XG4gICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBkYXRhLndyYXAgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS53cmFwVCA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMSBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlcztcblxuICAgIH0sXG5cbiAgICBwYXJzZU9iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmplY3Q7XG5cbiAgICAgICAgICAgIHZhciBnZXRHZW9tZXRyeSA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeScsIG5hbWUgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdTY2VuZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ0FtYmllbnRMaWdodCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggZGF0YS5jb2xvciApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdQb2ludExpZ2h0JzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ1Nwb3RMaWdodCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQsIGRhdGEuZGVjYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ01lc2gnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdMT0QnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ0xpbmUnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApLCBkYXRhLm1vZGUgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ1BvaW50Q2xvdWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1BvaW50cyc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnU3ByaXRlJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdHcm91cCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgICBpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xuICAgICAgICAgICAgICAgIG1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggZGF0YS5wb3NpdGlvbiApO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcbiAgICAgICAgICAgIGlmICggZGF0YS5yZWNlaXZlU2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcblxuICAgICAgICAgICAgaWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuICAgICAgICAgICAgaWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXG4gICAgICAgICAgICBpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBjaGlsZCBpbiBkYXRhLmNoaWxkcmVuICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGRhdGEuY2hpbGRyZW5bIGNoaWxkIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscyApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxldmVscyA9IGRhdGEubGV2ZWxzO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1sgbCBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgfVxuXG4gICAgfSgpXG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvVGV4dHVyZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmVMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggaW1hZ2UgKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlICk7XG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0JpbmFyeVRleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIE5pa29zIE0uIC8gaHR0cHM6Ly9naXRodWIuY29tL2ZvbzEyMy9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXG4gKi9cblxuVEhSRUUuRGF0YVRleHR1cmVMb2FkZXIgPSBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG4gICAgdGhpcy5fcGFyc2VyID0gbnVsbDtcblxufTtcblxuVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCk7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XG5cbiAgICAgICAgICAgIGlmICggIXRleERhdGEgKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmltYWdlICkge1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICAgICAgICAgIHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICAgICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWFnRmlsdGVyID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICAgICAgICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG4gICAgICAgICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5mb3JtYXQgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS50eXBlICkge1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pcG1hcHMgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlLCB0ZXhEYXRhICk7XG5cbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxuICovXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG4gICAgdGhpcy5fcGFyc2VyID0gbnVsbDtcblxufTtcblxuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgaW1hZ2VzID0gW107XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlcztcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgICAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uKCBpICkge1xuXG4gICAgICAgICAgICAgICAgbG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiggYnVmZmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sgaSBdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRleERhdGFzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRleERhdGFzLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQgKz0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArK2kgKSB7XG5cbiAgICAgICAgICAgICAgICBsb2FkVGV4dHVyZSggaSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXM7IGYrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlwbWFwczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgICAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTWF0ZXJpYWwgPSBmdW5jdGlvbigpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogVEhSRUUuTWF0ZXJpYWxJZENvdW50KytcbiAgICB9ICk7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy50eXBlID0gJ01hdGVyaWFsJztcblxuICAgIHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcblxuICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG4gICAgdGhpcy5ibGVuZFNyYyA9IFRIUkVFLlNyY0FscGhhRmFjdG9yO1xuICAgIHRoaXMuYmxlbmREc3QgPSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO1xuICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xuICAgIHRoaXMuYmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gICAgdGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcbiAgICB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cbiAgICB0aGlzLmRlcHRoRnVuYyA9IFRIUkVFLkxlc3NFcXVhbERlcHRoO1xuICAgIHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcbiAgICB0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG4gICAgdGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcblxuICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDsgLy8gb3ZlcnJpZGUgdGhlIHJlbmRlcmVyJ3MgZGVmYXVsdCBwcmVjaXNpb24gZm9yIHRoaXMgbWF0ZXJpYWxcblxuICAgIHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xuICAgIHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xuXG4gICAgdGhpcy5hbHBoYVRlc3QgPSAwO1xuXG4gICAgdGhpcy5vdmVyZHJhdyA9IDA7IC8vIE92ZXJkcmF3biBwaXhlbHMgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcblxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRlcmlhbCxcblxuICAgIGdldCBuZWVkc1VwZGF0ZSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbmVlZHNVcGRhdGU7XG5cbiAgICB9LFxuXG4gICAgc2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHNldFZhbHVlczogZnVuY3Rpb24oIHZhbHVlcyApIHtcblxuICAgICAgICBpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gdmFsdWVzICkge1xuXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xuXG4gICAgICAgICAgICBpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuTWF0ZXJpYWw6ICdcIiArIGtleSArIFwiJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlwiICk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xuXG4gICAgICAgICAgICBpZiAoIGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6ICdcIiArIGtleSArIFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiICk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApIHtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xuXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIG92ZXJkcmF3IGlzIGJhY2t3YXJkcy1jb21wYXRpYmxlIHdpdGggbGVnYWN5IGJvb2xlYW4gdHlwZVxuICAgICAgICAgICAgICAgIHRoaXNbIGtleSBdID0gTnVtYmVyKCBuZXdWYWx1ZSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdNYXRlcmlhbCcsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cbiAgICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgICAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgICBpZiAoIHRoaXMuY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICAgICAgICBpZiAoIHRoaXMuZW1pc3NpdmUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xuICAgICAgICBpZiAoIHRoaXMuc3BlY3VsYXIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuICAgICAgICBpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXG4gICAgICAgIGlmICggdGhpcy5tYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICBpZiAoIHRoaXMuYWxwaGFNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgaWYgKCB0aGlzLmxpZ2h0TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgIGlmICggdGhpcy5idW1wTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgICAgICBkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0aGlzLm5vcm1hbE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgICAgIGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlOyAvLyBSZW1vdmVkIGZvciBub3csIGNhdXNlcyBpc3N1ZSBpbiBlZGl0b3IgdWkuanNcblxuICAgICAgICB9XG4gICAgICAgIGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG4gICAgICAgICAgICBkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgICAgICBkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgIGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcblxuICAgICAgICB9XG4gICAgICAgIGlmICggdGhpcy5zcGVjdWxhck1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICBpZiAoIHRoaXMuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgZGF0YS5lbnZNYXAgPSB0aGlzLmVudk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICAgICAgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG4gICAgICAgIGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuICAgICAgICBpZiAoIHRoaXMuc2hhZGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2hhZGluZyAhPT0gVEhSRUUuU21vb3RoU2hhZGluZyApIGRhdGEuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcbiAgICAgICAgaWYgKCB0aGlzLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ibGVuZGluZyAhPT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcbiAgICAgICAgaWYgKCB0aGlzLnNpZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNpZGUgIT09IFRIUkVFLkZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcblxuICAgICAgICBpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xuICAgICAgICBpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG4gICAgICAgIGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICAgICAgICBpZiAoIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSApIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG4gICAgICAgIHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xuXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xuXG4gICAgICAgIHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XG5cbiAgICAgICAgdGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcbiAgICAgICAgdGhpcy5ibGVuZERzdCA9IHNvdXJjZS5ibGVuZERzdDtcbiAgICAgICAgdGhpcy5ibGVuZEVxdWF0aW9uID0gc291cmNlLmJsZW5kRXF1YXRpb247XG4gICAgICAgIHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xuICAgICAgICB0aGlzLmJsZW5kRHN0QWxwaGEgPSBzb3VyY2UuYmxlbmREc3RBbHBoYTtcbiAgICAgICAgdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBzb3VyY2UuYmxlbmRFcXVhdGlvbkFscGhhO1xuXG4gICAgICAgIHRoaXMuZGVwdGhGdW5jID0gc291cmNlLmRlcHRoRnVuYztcbiAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xuICAgICAgICB0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcblxuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHNvdXJjZS5wcmVjaXNpb247XG5cbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gc291cmNlLnBvbHlnb25PZmZzZXQ7XG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cbiAgICAgICAgdGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xuXG4gICAgICAgIHRoaXMub3ZlcmRyYXcgPSBzb3VyY2Uub3ZlcmRyYXc7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgIHR5cGU6ICd1cGRhdGUnXG4gICAgICAgIH0gKTtcblxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgICB9ICk7XG5cbiAgICB9LFxuXG4gICAgLy8gRGVwcmVjYXRlZFxuXG4gICAgZ2V0IHdyYXBBcm91bmQoKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIHNldCB3cmFwQXJvdW5kKCBib29sZWFuICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICBnZXQgd3JhcFJHQigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBSR0IgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cblRIUkVFLk1hdGVyaWFsSWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXG4gKiAgbGluZWpvaW46IFwicm91bmRcIixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cbiAgICB0aGlzLmxpbmV3aWR0aCA9IDE7XG4gICAgdGhpcy5saW5lY2FwID0gJ3JvdW5kJztcbiAgICB0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsO1xuXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICB0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG4gICAgdGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XG4gICAgdGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZURhc2hlZE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHNjYWxlOiA8ZmxvYXQ+LFxuICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxuICogIGdhcFNpemU6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cbiAgICB0aGlzLmxpbmV3aWR0aCA9IDE7XG5cbiAgICB0aGlzLnNjYWxlID0gMTtcbiAgICB0aGlzLmRhc2hTaXplID0gMztcbiAgICB0aGlzLmdhcFNpemUgPSAxO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7XG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICB0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG5cbiAgICB0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xuICAgIHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XG4gICAgdGhpcy5nYXBTaXplID0gc291cmNlLmdhcFNpemU7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hCYXNpY01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXG5cbiAgICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmFvTWFwID0gbnVsbDtcbiAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICAgIHRoaXMuZW52TWFwID0gbnVsbDtcbiAgICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gICAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gICAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsO1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgICB0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG4gICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICB0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICB0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaExhbWJlcnRNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIGVtaXNzaXZlOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuICAgIHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XG5cbiAgICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICAgIHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5lbnZNYXAgPSBudWxsO1xuICAgIHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICAgIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgICB0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuXG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cbiAgICB0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gICAgdGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxuICogIHNoaW5pbmVzczogPGZsb2F0PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcbiAqXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG4gKlxuICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcbiAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG4gICAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcbiAgICB0aGlzLnNwZWN1bGFyID0gbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApO1xuICAgIHRoaXMuc2hpbmluZXNzID0gMzA7XG5cbiAgICB0aGlzLm1ldGFsID0gZmFsc2U7XG5cbiAgICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmxpZ2h0TWFwID0gbnVsbDtcbiAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgdGhpcy5hb01hcCA9IG51bGw7XG4gICAgdGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5idW1wTWFwID0gbnVsbDtcbiAgICB0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cbiAgICB0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG4gICAgdGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cbiAgICB0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmVudk1hcCA9IG51bGw7XG4gICAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcblxuICAgIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICAgIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsO1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG4gICAgdGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcbiAgICB0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuICAgIHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcblxuICAgIHRoaXMubWV0YWwgPSBzb3VyY2UubWV0YWw7XG5cbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgICB0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuICAgIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICB0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICB0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXG4gICAgdGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG4gICAgdGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG4gICAgdGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuICAgIHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cbiAgICB0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cbiAgICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gICAgdGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuICAgIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICB0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaERlcHRoTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuICogfVxuICovXG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaE5vcm1hbE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuICogfVxuICovXG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG4gICAgdGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NdWx0aU1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NdWx0aU1hdGVyaWFsID0gZnVuY3Rpb24oIG1hdGVyaWFscyApIHtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTXVsdGlNYXRlcmlhbCc7XG5cbiAgICB0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscyBpbnN0YW5jZW9mIEFycmF5ID8gbWF0ZXJpYWxzIDogW107XG5cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5NdWx0aU1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NdWx0aU1hdGVyaWFsLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjIsXG4gICAgICAgICAgICAgICAgdHlwZTogJ21hdGVyaWFsJyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdNYXRlcmlhbEV4cG9ydGVyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHV1aWQ6IHRoaXMudXVpZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIG1hdGVyaWFsczogW11cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIG91dHB1dC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS50b0pTT04oKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubWF0ZXJpYWxzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICBtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cbiAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuXG4gICAgfVxuXG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5USFJFRS5NZXNoRmFjZU1hdGVyaWFsID0gVEhSRUUuTXVsdGlNYXRlcmlhbDtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNpemU6IDxmbG9hdD4sXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+LFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlBvaW50c01hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuICAgIHRoaXMubWFwID0gbnVsbDtcblxuICAgIHRoaXMuc2l6ZSA9IDE7XG4gICAgdGhpcy5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzTWF0ZXJpYWw7XG5cblRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xuICAgIHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gc291cmNlLnNpemVBdHRlbnVhdGlvbjtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5USFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TaGFkZXJNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBkZWZpbmVzOiB7IFwibGFiZWxcIiA6IFwidmFsdWVcIiB9LFxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHR5cGU6IFwiaVwiIHZhbHVlMjogMiB9IH0sXG4gKlxuICogIGZyYWdtZW50U2hhZGVyOiA8c3RyaW5nPixcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgbGlnaHRzOiA8Ym9vbD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuICpcbiAqXHRmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlNoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5kZWZpbmVzID0ge307XG4gICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuXG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59JztcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59JztcblxuICAgIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgICB0aGlzLmxpbmV3aWR0aCA9IDE7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuICAgIHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXG5cbiAgICB0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9yczsgLy8gc2V0IHRvIHVzZSBcImNvbG9yXCIgYXR0cmlidXRlIHN0cmVhbVxuXG4gICAgdGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcblxuICAgIHRoaXMuZGVyaXZhdGl2ZXMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xuXG4gICAgLy8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXG4gICAgLy8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcbiAgICAgICAgJ2NvbG9yJzogWyAxLCAxLCAxIF0sXG4gICAgICAgICd1dic6IFsgMCwgMCBdLFxuICAgICAgICAndXYyJzogWyAwLCAwIF1cbiAgICB9O1xuXG4gICAgdGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgZGVmaW5lZCBpbiBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcblxuICAgIHRoaXMudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzb3VyY2UudW5pZm9ybXMgKTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuICAgIHRoaXMuZGVmaW5lcyA9IHNvdXJjZS5kZWZpbmVzO1xuXG4gICAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgdGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cbiAgICB0aGlzLmRlcml2YXRpdmVzID0gc291cmNlLmRlcml2YXRpdmVzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICBkYXRhLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcbiAgICBkYXRhLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvUmF3U2hhZGVyTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5TaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xuXG59O1xuXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsO1xuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Nwcml0ZU1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKlx0dXZPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gKlx0dXZTY2FsZTogbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG4gICAgdGhpcy5tYXAgPSBudWxsO1xuXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICB0aGlzLmZvZyA9IGZhbHNlO1xuXG4gICAgLy8gc2V0IHBhcmFtZXRlcnNcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlTWF0ZXJpYWw7XG5cblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgICB0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL1RleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqL1xuXG5USFJFRS5UZXh0dXJlID0gZnVuY3Rpb24oIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IFRIUkVFLlRleHR1cmVJZENvdW50KytcbiAgICB9ICk7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy5zb3VyY2VGaWxlID0gJyc7XG5cbiAgICB0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xuICAgIHRoaXMubWlwbWFwcyA9IFtdO1xuXG4gICAgdGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xuXG4gICAgdGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgdGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cbiAgICB0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuICAgIHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgICB0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBhbmlzb3Ryb3B5IDogMTtcblxuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xuICAgIHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xuICAgIHRoaXMucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcbiAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcbiAgICB0aGlzLmZsaXBZID0gdHJ1ZTtcbiAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICB0aGlzLm9uVXBkYXRlID0gbnVsbDtcblxufTtcblxuVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFID0gdW5kZWZpbmVkO1xuVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBUSFJFRS5VVk1hcHBpbmc7XG5cblRIUkVFLlRleHR1cmUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXG5cbiAgICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24rKztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcbiAgICAgICAgdGhpcy5taXBtYXBzID0gc291cmNlLm1pcG1hcHMuc2xpY2UoIDAgKTtcblxuICAgICAgICB0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcblxuICAgICAgICB0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuICAgICAgICB0aGlzLndyYXBUID0gc291cmNlLndyYXBUO1xuXG4gICAgICAgIHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xuXG4gICAgICAgIHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xuXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcbiAgICAgICAgdGhpcy50eXBlID0gc291cmNlLnR5cGU7XG5cbiAgICAgICAgdGhpcy5vZmZzZXQuY29weSggc291cmNlLm9mZnNldCApO1xuICAgICAgICB0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xuICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgdGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcbiAgICAgICAgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSBzb3VyY2UudW5wYWNrQWxpZ25tZW50O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICAgICAgaWYgKCBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGFVUkwoIGltYWdlICkge1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzO1xuXG4gICAgICAgICAgICBpZiAoIGltYWdlLnRvRGF0YVVSTCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY2FudmFzID0gaW1hZ2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9qcGVnJywgMC42ICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdUZXh0dXJlJyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHV1aWQ6IHRoaXMudXVpZCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcblxuICAgICAgICAgICAgbWFwcGluZzogdGhpcy5tYXBwaW5nLFxuXG4gICAgICAgICAgICByZXBlYXQ6IFsgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSBdLFxuICAgICAgICAgICAgb2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcbiAgICAgICAgICAgIHdyYXA6IFsgdGhpcy53cmFwUywgdGhpcy53cmFwVCBdLFxuXG4gICAgICAgICAgICBtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcbiAgICAgICAgICAgIGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggdGhpcy5pbWFnZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXG5cbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICAgICAgICAgIGlmICggaW1hZ2UudXVpZCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgaW1hZ2UudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogaW1hZ2UudXVpZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZXREYXRhVVJMKCBpbWFnZSApXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xuXG4gICAgICAgIH1cblxuICAgICAgICBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICAgIH0gKTtcblxuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1VdjogZnVuY3Rpb24oIHV2ICkge1xuXG4gICAgICAgIGlmICggdGhpcy5tYXBwaW5nICE9PSBUSFJFRS5VVk1hcHBpbmcgKSByZXR1cm47XG5cbiAgICAgICAgdXYubXVsdGlwbHkoIHRoaXMucmVwZWF0ICk7XG4gICAgICAgIHV2LmFkZCggdGhpcy5vZmZzZXQgKTtcblxuICAgICAgICBpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5SZXBlYXRXcmFwcGluZzpcblxuICAgICAgICAgICAgICAgICAgICB1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc6XG5cbiAgICAgICAgICAgICAgICAgICAgdXYueCA9IHV2LnggPCAwID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXYueCA9IE1hdGguY2VpbCggdXYueCApIC0gdXYueDtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIHRoaXMud3JhcFQgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxuXG4gICAgICAgICAgICAgICAgICAgIHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuICAgICAgICAgICAgICAgICAgICB1di55ID0gdXYueSA8IDAgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLmZsaXBZICkge1xuXG4gICAgICAgICAgICB1di55ID0gMSAtIHV2Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG5USFJFRS5UZXh0dXJlSWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0NhbnZhc1RleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNhbnZhc1RleHR1cmUgPSBmdW5jdGlvbiggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW52YXNUZXh0dXJlO1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DdWJlVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ3ViZVRleHR1cmUgPSBmdW5jdGlvbiggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICBtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZztcblxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVUZXh0dXJlO1xuXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5pbWFnZXMgPSBzb3VyY2UuaW1hZ2VzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICAgIHRoaXMuaW1hZ2UgPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICAgIHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG5cbiAgICAvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuICAgIC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXG5cbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XG5cbiAgICAvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG4gICAgLy8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xuXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRGF0YVRleHR1cmUgPSBmdW5jdGlvbiggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICAgIHRoaXMuaW1hZ2UgPSB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuXG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRhdGFUZXh0dXJlO1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9WaWRlb1RleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlZpZGVvVGV4dHVyZSA9IGZ1bmN0aW9uKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xuXG4gICAgICAgIGlmICggdmlkZW8ucmVhZHlTdGF0ZSA9PT0gdmlkZW8uSEFWRV9FTk9VR0hfREFUQSApIHtcblxuICAgICAgICAgICAgc2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB1cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmlkZW9UZXh0dXJlO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Hcm91cCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0dyb3VwJztcblxufTtcblxuVEhSRUUuR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5Hcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Hcm91cDtcbi8vIEZpbGU6c3JjL29iamVjdHMvUG9pbnRzLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludHMgPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BvaW50cyc7XG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5Qb2ludHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzO1xuXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgICAgIHZhciBvYmplY3QgPSB0aGlzO1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG5cbiAgICAgICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcbiAgICAgICAgdmFyIGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRlc3RQb2ludCggcG9pbnQsIGluZGV4ICkge1xuXG4gICAgICAgICAgICB2YXIgcmF5UG9pbnREaXN0YW5jZVNxID0gcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xuXG4gICAgICAgICAgICBpZiAoIHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0XG5cbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbmRpY2VzWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBpICogMyApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXN0UG9pbnQoIHZlcnRpY2VzWyBpIF0sIGkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSApO1xuXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cblRIUkVFLlBvaW50cy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICAgIGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTigpO1xuXG4gICAgfVxuXG4gICAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgbWF0ZXJpYWxzIGNhY2hlXG4gICAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTigpO1xuXG4gICAgfVxuXG4gICAgZGF0YS5vYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XG4gICAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUG9pbnRDbG91ZCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbn07XG5cblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGluZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTGluZSA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XG5cbiAgICBpZiAoIG1vZGUgPT09IDEgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTGluZTogcGFyYW1ldGVyIFRIUkVFLkxpbmVQaWVjZXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gQ3JlYXRlZCBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIH1cblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdMaW5lJztcblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZcbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLkxpbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmU7XG5cblRIUkVFLkxpbmUucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XG4gICAgdmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xuICAgICAgICB2YXIgcHJlY2lzaW9uU3EgPSBwcmVjaXNpb24gKiBwcmVjaXNpb247XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cbiAgICAgICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICBpZiAoIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcbiAgICAgICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgICAgICB2YXIgdlN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHZFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgaW50ZXJTZWdtZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIGludGVyUmF5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzIGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzID8gMiA6IDE7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aCAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbmRpY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gaW5kaWNlc1sgaSArIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICB2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG4gICAgICAgICAgICAgICAgICAgIHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgdkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKyAzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgICAgICAgICB2YXIgbmJWZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbmJWZXJ0aWNlcyAtIDE7IGkgKz0gc3RlcCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgICAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSApO1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBnZW9tZXRyaWVzIGNhY2hlXG4gICAgaWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCk7XG5cbiAgICB9XG5cbiAgICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG5cbiAgICB9XG5cbiAgICBkYXRhLm9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcbiAgICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBERVBSRUNBVEVEXG5cblRIUkVFLkxpbmVTdHJpcCA9IDA7XG5USFJFRS5MaW5lUGllY2VzID0gMTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lU2VnbWVudHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxpbmVTZWdtZW50cyA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgdGhpcy50eXBlID0gJ0xpbmVTZWdtZW50cyc7XG5cbn07XG5cblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVTZWdtZW50cztcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9NZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xuICovXG5cblRIUkVFLk1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ01lc2gnO1xuXG4gICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZlxuICAgIH0gKTtcblxuICAgIHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5NZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2g7XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1vcnBoVGFyZ2V0cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgdGhpcy5tb3JwaFRhcmdldEJhc2UgPSAtMTtcbiAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuICAgICAgICBmb3IgKCB2YXIgbSA9IDAsIG1sID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtIDwgbWw7IG0rKyApIHtcblxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWUgPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgIGlmICggdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdO1xuXG4gICAgfVxuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWVzaC5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lOiBtb3JwaCB0YXJnZXQgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0LiBSZXR1cm5pbmcgMC4nICk7XG5cbiAgICByZXR1cm4gMDtcblxufTtcblxuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICB2YXIgdkEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHZDID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciB0ZW1wQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdGVtcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIHV2QSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgdmFyIHV2QiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgdmFyIHV2QyA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICB2YXIgYmFyeWNvb3JkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZnVuY3Rpb24gdXZJbnRlcnNlY3Rpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzICkge1xuXG4gICAgICAgIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHAxLCBwMiwgcDMsIGJhcnljb29yZCApO1xuXG4gICAgICAgIHV2MS5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnggKTtcbiAgICAgICAgdXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xuICAgICAgICB1djMubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC56ICk7XG5cbiAgICAgICAgdXYxLmFkZCggdXYyICkuYWRkKCB1djMgKTtcblxuICAgICAgICByZXR1cm4gdXYxLmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICAgICAgc3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIGlmICggcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cbiAgICAgICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhLCBiLCBjO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYSA9IGluZGljZXNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IGluZGljZXNbIGkgKyAxIF07XG4gICAgICAgICAgICAgICAgICAgIGMgPSBpbmRpY2VzWyBpICsgMiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuICAgICAgICAgICAgICAgICAgICB2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcbiAgICAgICAgICAgICAgICAgICAgdkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGMgKiAzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZDLCB2QiwgdkEsIHRydWUsIGludGVyc2VjdGlvblBvaW50ICkgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkEsIHZCLCB2QywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSwgaW50ZXJzZWN0aW9uUG9pbnQgKSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIGludGVyc2VjdGlvblBvaW50ICk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2LmFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXZDLmZyb21BcnJheSggdXZzLCBjICogMiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB1djogdXYsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICksXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IE1hdGguZmxvb3IoIGkgLyAzICksIC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRpY2VzIGJ1ZmZlciBzZW1hbnRpY3NcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICs9IDkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgdkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XG4gICAgICAgICAgICAgICAgICAgIHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QywgdkIsIHZBLCB0cnVlLCBpbnRlcnNlY3Rpb25Qb2ludCApID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUsIGludGVyc2VjdGlvblBvaW50ICkgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50V29ybGQgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2QS5mcm9tQXJyYXkoIHV2cywgaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXZCLmZyb21BcnJheSggdXZzLCBpICsgMiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXZDLmZyb21BcnJheSggdXZzLCBpICsgNCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYSA9IGkgLyAzO1xuICAgICAgICAgICAgICAgICAgICBiID0gYSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBhICsgMjtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2OiB1dixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2U6IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBhLCAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3NcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIHZhciBpc0ZhY2VNYXRlcmlhbCA9IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsLm1hdGVyaWFscyA6IG51bGw7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBmID0gMCwgZmwgPSBmYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgZiBdO1xuICAgICAgICAgICAgICAgIHZhciBmYWNlTWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG4gICAgICAgICAgICAgICAgYiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcbiAgICAgICAgICAgICAgICBjID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmYWNlTWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgICAgICAgICAgICAgICAgICB2QS5zZXQoIDAsIDAsIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgdkIuc2V0KCAwLCAwLCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHZDLnNldCggMCwgMCwgMCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciB0ID0gMCwgdGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyB0IDwgdGw7IHQrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2QS5hZGRTY2FsZWRWZWN0b3IoIHRlbXBBLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYSBdLCBhICksIGluZmx1ZW5jZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdkIuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQi5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmIgXSwgYiApLCBpbmZsdWVuY2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGMgKSwgaW5mbHVlbmNlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZBLmFkZCggYSApO1xuICAgICAgICAgICAgICAgICAgICB2Qi5hZGQoIGIgKTtcbiAgICAgICAgICAgICAgICAgICAgdkMuYWRkKCBjICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYSA9IHZBO1xuICAgICAgICAgICAgICAgICAgICBiID0gdkI7XG4gICAgICAgICAgICAgICAgICAgIGMgPSB2QztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggZmFjZU1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBjLCBiLCBhLCB0cnVlLCBpbnRlcnNlY3Rpb25Qb2ludCApID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIGEsIGIsIGMsIGZhY2VNYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBpbnRlcnNlY3Rpb25Qb2ludCApID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIGludGVyc2VjdGlvblBvaW50ICk7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50V29ybGQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciB1djtcblxuICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXVsgZiBdO1xuICAgICAgICAgICAgICAgICAgICB1dkEuY29weSggdXZzWyAwIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgdXZCLmNvcHkoIHV2c1sgMSBdICk7XG4gICAgICAgICAgICAgICAgICAgIHV2Qy5jb3B5KCB1dnNbIDIgXSApO1xuICAgICAgICAgICAgICAgICAgICB1diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgYSwgYiwgYywgdXZBLCB1dkIsIHV2QyApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICB1djogdXYsXG4gICAgICAgICAgICAgICAgICAgIGZhY2U6IGZhY2UsXG4gICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogZixcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkgKTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICAgIGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTiggbWV0YSApO1xuXG4gICAgfVxuXG4gICAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgbWF0ZXJpYWxzIGNhY2hlXG4gICAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xuXG4gICAgfVxuXG4gICAgZGF0YS5vYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XG4gICAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Cb25lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Cb25lID0gZnVuY3Rpb24oIHNraW4gKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQm9uZSc7XG5cbiAgICB0aGlzLnNraW4gPSBza2luO1xuXG59O1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5za2luID0gc291cmNlLnNraW47XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Ta2VsZXRvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLlNrZWxldG9uID0gZnVuY3Rpb24oIGJvbmVzLCBib25lSW52ZXJzZXMsIHVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICB0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcblxuICAgIHRoaXMuaWRlbnRpdHlNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgLy8gY29weSB0aGUgYm9uZSBhcnJheVxuXG4gICAgYm9uZXMgPSBib25lcyB8fCBbXTtcblxuICAgIHRoaXMuYm9uZXMgPSBib25lcy5zbGljZSggMCApO1xuXG4gICAgLy8gY3JlYXRlIGEgYm9uZSB0ZXh0dXJlIG9yIGFuIGFycmF5IG9mIGZsb2F0c1xuXG4gICAgaWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAgICAgLy8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuICAgICAgICAvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXG4gICAgICAgIC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXG4gICAgICAgIC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKiA0IHBpeGVscyA9ICgxNiAqIDE2KVxuICAgICAgICAvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcbiAgICAgICAgLy8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cblxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5ib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcbiAgICAgICAgc2l6ZSA9IFRIUkVFLk1hdGgubmV4dFBvd2VyT2ZUd28oIE1hdGguY2VpbCggc2l6ZSApICk7XG4gICAgICAgIHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xuXG4gICAgICAgIHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XG4gICAgICAgIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgPSBzaXplO1xuXG4gICAgICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5ib25lVGV4dHVyZVdpZHRoICogdGhpcy5ib25lVGV4dHVyZUhlaWdodCAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcbiAgICAgICAgdGhpcy5ib25lVGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgVEhSRUUuUkdCQUZvcm1hdCwgVEhSRUUuRmxvYXRUeXBlICk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgdGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHRoaXMuYm9uZXMubGVuZ3RoICk7XG5cbiAgICB9XG5cbiAgICAvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xuXG4gICAgaWYgKCBib25lSW52ZXJzZXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA9PT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbiBib25JbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLicgKTtcblxuICAgICAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIrKyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBUSFJFRS5NYXRyaXg0KCkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNhbGN1bGF0ZUludmVyc2VzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIrKyApIHtcblxuICAgICAgICB2YXIgaW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvbmVzWyBiIF0gKSB7XG5cbiAgICAgICAgICAgIGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBib25lO1xuXG4gICAgLy8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXG5cbiAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYisrICkge1xuXG4gICAgICAgIGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cbiAgICAgICAgaWYgKCBib25lICkge1xuXG4gICAgICAgICAgICBib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIrKyApIHtcblxuICAgICAgICBib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG4gICAgICAgIGlmICggYm9uZSApIHtcblxuICAgICAgICAgICAgaWYgKCBib25lLnBhcmVudCApIHtcblxuICAgICAgICAgICAgICAgIGJvbmUubWF0cml4LmdldEludmVyc2UoIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgYm9uZS5tYXRyaXgubXVsdGlwbHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG9mZnNldE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgICAgIC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG4gICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiKysgKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXG5cbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xuXG4gICAgICAgICAgICBvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG4gICAgICAgICAgICBvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn0gKSgpO1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuU2tlbGV0b24oIHRoaXMuYm9uZXMsIHRoaXMuYm9uZUludmVyc2VzLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cbiAgICB0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xuICAgIHRoaXMuYmluZE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAvLyBpbml0IGJvbmVzXG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYm9uZSBjcmVhdGlvbiBhcyB0aGVyZSBpcyBubyByZWFzb24gKG90aGVyIHRoYW5cbiAgICAvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXG5cbiAgICB2YXIgYm9uZXMgPSBbXTtcblxuICAgIGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmJvbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIGJvbmUsIGdib25lO1xuXG4gICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArK2IgKSB7XG5cbiAgICAgICAgICAgIGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG4gICAgICAgICAgICBib25lID0gbmV3IFRIUkVFLkJvbmUoIHRoaXMgKTtcbiAgICAgICAgICAgIGJvbmVzLnB1c2goIGJvbmUgKTtcblxuICAgICAgICAgICAgYm9uZS5uYW1lID0gZ2JvbmUubmFtZTtcbiAgICAgICAgICAgIGJvbmUucG9zaXRpb24uZnJvbUFycmF5KCBnYm9uZS5wb3MgKTtcbiAgICAgICAgICAgIGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcbiAgICAgICAgICAgIGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArK2IgKSB7XG5cbiAgICAgICAgICAgIGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG4gICAgICAgICAgICBpZiAoIGdib25lLnBhcmVudCAhPT0gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICBib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lc1sgYiBdICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoIGJvbmVzWyBiIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcbiAgICB0aGlzLmJpbmQoIG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApLCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbn07XG5cblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNraW5uZWRNZXNoO1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKCBza2VsZXRvbiwgYmluZE1hdHJpeCApIHtcblxuICAgIHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuICAgIGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgICB0aGlzLnNrZWxldG9uLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cbiAgICAgICAgYmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cbiAgICB9XG5cbiAgICB0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5ub3JtYWxpemVTa2luV2VpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCB0aGlzLmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xuXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxLjAgLyBzdy5sZW5ndGhNYW5oYXR0YW4oKTtcblxuICAgICAgICAgICAgaWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XG5cbiAgICAgICAgICAgICAgICBzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzdy5zZXQoIDEgKTsgLy8gdGhpcyB3aWxsIGJlIG5vcm1hbGl6ZWQgYnkgdGhlIHNoYWRlciBhbnl3YXlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICAvLyBza2lubmluZyB3ZWlnaHRzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCBmb3IgVEhSRUUuQnVmZmVyR2VvbWV0cnlcblxuICAgIH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24oIGZvcmNlICkge1xuXG4gICAgVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgdHJ1ZSApO1xuXG4gICAgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XG5cbiAgICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcblxuICAgICAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Nb3JwaEFuaW1NZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTW9ycGhBbmltTWVzaCc7XG5cbiAgICAvLyBBUElcblxuICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwOyAvLyBtaWxsaXNlY29uZHNcbiAgICB0aGlzLm1pcnJvcmVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMudGltZSA9IDA7XG5cbiAgICAvLyBpbnRlcm5hbHNcblxuICAgIHRoaXMubGFzdEtleWZyYW1lID0gMDtcbiAgICB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IDA7XG5cbiAgICB0aGlzLmRpcmVjdGlvbiA9IDE7XG4gICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0RnJhbWVSYW5nZSggMCwgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCAtIDEgKTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Nb3JwaEFuaW1NZXNoO1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRGcmFtZVJhbmdlID0gZnVuY3Rpb24oIHN0YXJ0LCBlbmQgKSB7XG5cbiAgICB0aGlzLnN0YXJ0S2V5ZnJhbWUgPSBzdGFydDtcbiAgICB0aGlzLmVuZEtleWZyYW1lID0gZW5kO1xuXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmVuZEtleWZyYW1lIC0gdGhpcy5zdGFydEtleWZyYW1lICsgMTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uRm9yd2FyZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAxO1xuICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmRpcmVjdGlvbiA9IC0xO1xuICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGFyc2VBbmltYXRpb25zID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gICAgaWYgKCAhZ2VvbWV0cnkuYW5pbWF0aW9ucyApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSB7fTtcblxuICAgIHZhciBmaXJzdEFuaW1hdGlvbiwgYW5pbWF0aW9ucyA9IGdlb21ldHJ5LmFuaW1hdGlvbnM7XG5cbiAgICB2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICB2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcbiAgICAgICAgdmFyIHBhcnRzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG4gICAgICAgIGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuICAgICAgICAgICAgdmFyIGxhYmVsID0gcGFydHNbIDEgXTtcblxuICAgICAgICAgICAgaWYgKCAhYW5pbWF0aW9uc1sgbGFiZWwgXSApIGFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGVuZDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1sgbGFiZWwgXTtcblxuICAgICAgICAgICAgaWYgKCBpIDwgYW5pbWF0aW9uLnN0YXJ0ICkgYW5pbWF0aW9uLnN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGlmICggaSA+IGFuaW1hdGlvbi5lbmQgKSBhbmltYXRpb24uZW5kID0gaTtcblxuICAgICAgICAgICAgaWYgKCAhZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IGxhYmVsO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdlb21ldHJ5LmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkxhYmVsID0gZnVuY3Rpb24oIGxhYmVsLCBzdGFydCwgZW5kICkge1xuXG4gICAgaWYgKCAhdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zICkgdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cbiAgICB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICB9O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24oIGxhYmVsLCBmcHMgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgdGhpcy5zZXRGcmFtZVJhbmdlKCBhbmltYXRpb24uc3RhcnQsIGFuaW1hdGlvbi5lbmQgKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDEwMDAgKiAoICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gZnBzICk7XG4gICAgICAgIHRoaXMudGltZSA9IDA7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTW9ycGhBbmltTWVzaDogYW5pbWF0aW9uWycgKyBsYWJlbCArICddIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpJyApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiggZGVsdGEgKSB7XG5cbiAgICB2YXIgZnJhbWVUaW1lID0gdGhpcy5kdXJhdGlvbiAvIHRoaXMubGVuZ3RoO1xuXG4gICAgdGhpcy50aW1lICs9IHRoaXMuZGlyZWN0aW9uICogZGVsdGE7XG5cbiAgICBpZiAoIHRoaXMubWlycm9yZWRMb29wICkge1xuXG4gICAgICAgIGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiB8fCB0aGlzLnRpbWUgPCAwICkge1xuXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiAqPSAtMTtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0aGlzLnRpbWUgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHRoaXMudGltZSA9IHRoaXMudGltZSAlIHRoaXMuZHVyYXRpb247XG5cbiAgICAgICAgaWYgKCB0aGlzLnRpbWUgPCAwICkgdGhpcy50aW1lICs9IHRoaXMuZHVyYXRpb247XG5cbiAgICB9XG5cbiAgICB2YXIga2V5ZnJhbWUgPSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyBUSFJFRS5NYXRoLmNsYW1wKCBNYXRoLmZsb29yKCB0aGlzLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgdGhpcy5sZW5ndGggLSAxICk7XG5cbiAgICB2YXIgaW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgaWYgKCBrZXlmcmFtZSAhPT0gdGhpcy5jdXJyZW50S2V5ZnJhbWUgKSB7XG5cbiAgICAgICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDA7XG4gICAgICAgIGluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSAxO1xuICAgICAgICBpbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcblxuICAgICAgICB0aGlzLmxhc3RLZXlmcmFtZSA9IHRoaXMuY3VycmVudEtleWZyYW1lO1xuICAgICAgICB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IGtleWZyYW1lO1xuXG4gICAgfVxuXG4gICAgdmFyIG1peCA9ICggdGhpcy50aW1lICUgZnJhbWVUaW1lICkgLyBmcmFtZVRpbWU7XG5cbiAgICBpZiAoIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzICkge1xuXG4gICAgICAgIG1peCA9IDEgLSBtaXg7XG5cbiAgICB9XG5cbiAgICBpbmZsdWVuY2VzWyB0aGlzLmN1cnJlbnRLZXlmcmFtZSBdID0gbWl4O1xuICAgIGluZmx1ZW5jZXNbIHRoaXMubGFzdEtleWZyYW1lIF0gPSAxIC0gbWl4O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVRhcmdldHMgPSBmdW5jdGlvbiggYSwgYiwgdCApIHtcblxuICAgIHZhciBpbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICBpbmZsdWVuY2VzWyBpIF0gPSAwO1xuXG4gICAgfVxuXG4gICAgaWYgKCBhID4gLTEgKSBpbmZsdWVuY2VzWyBhIF0gPSAxIC0gdDtcbiAgICBpZiAoIGIgPiAtMSApIGluZmx1ZW5jZXNbIGIgXSA9IHQ7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWVzaC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuZHVyYXRpb24gPSBzb3VyY2UuZHVyYXRpb247XG4gICAgdGhpcy5taXJyb3JlZExvb3AgPSBzb3VyY2UubWlycm9yZWRMb29wO1xuICAgIHRoaXMudGltZSA9IHNvdXJjZS50aW1lO1xuXG4gICAgdGhpcy5sYXN0S2V5ZnJhbWUgPSBzb3VyY2UubGFzdEtleWZyYW1lO1xuICAgIHRoaXMuY3VycmVudEtleWZyYW1lID0gc291cmNlLmN1cnJlbnRLZXlmcmFtZTtcblxuICAgIHRoaXMuZGlyZWN0aW9uID0gc291cmNlLmRpcmVjdGlvbjtcbiAgICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHNvdXJjZS5kaXJlY3Rpb25CYWNrd2FyZHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MT0QuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTE9EID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTE9EJztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgICAgIGxldmVsczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBvYmplY3RzOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTE9EOiAub2JqZWN0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5sZXZlbHMuJyApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxldmVscztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG59O1xuXG5cblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxPRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MT0Q7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWwgPSBmdW5jdGlvbiggb2JqZWN0LCBkaXN0YW5jZSApIHtcblxuICAgIGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcblxuICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsKysgKSB7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgbCBdLmRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBsZXZlbHMuc3BsaWNlKCBsLCAwLCB7XG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9ICk7XG5cbiAgICB0aGlzLmFkZCggb2JqZWN0ICk7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UgPSBmdW5jdGlvbiggZGlzdGFuY2UgKSB7XG5cbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsc1sgaSAtIDEgXS5vYmplY3Q7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgICAgICBtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xuXG4gICAgICAgIHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cbiAgICB9O1xuXG59KCkgKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcblxuICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICAgICAgaWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcblxuICAgICAgICAgICAgdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xuXG4gICAgICAgICAgICBsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlID49IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgbGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgZmFsc2UgKTtcblxuICAgIHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuICAgICAgICB0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0LmxldmVscyA9IFtdO1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuICAgICAgICBkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xuICAgICAgICAgICAgb2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBsZXZlbC5kaXN0YW5jZVxuICAgICAgICB9ICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9TcHJpdGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcHJpdGUgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMiwgMCwgMiwgMyBdICk7XG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtMC41LCAtMC41LCAwLCAwLjUsIC0wLjUsIDAsIDAuNSwgMC41LCAwLCAtMC41LCAwLjUsIDAgXSApO1xuICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDEgXSApO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBTcHJpdGUoIG1hdGVyaWFsICkge1xuXG4gICAgICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSAnU3ByaXRlJztcblxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XG5cbiAgICB9O1xuXG59ICkoKTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgICAgIG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZVNxID0gcmF5Y2FzdGVyLnJheS5kaXN0YW5jZVNxVG9Qb2ludCggbWF0cml4UG9zaXRpb24gKTtcbiAgICAgICAgdmFyIGd1ZXNzU2l6ZVNxID0gdGhpcy5zY2FsZS54ICogdGhpcy5zY2FsZS55O1xuXG4gICAgICAgIGlmICggZGlzdGFuY2VTcSA+IGd1ZXNzU2l6ZVNxICkge1xuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICBkaXN0YW5jZTogTWF0aC5zcXJ0KCBkaXN0YW5jZVNxICksXG4gICAgICAgICAgICBwb2ludDogdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICB9ICk7XG5cbiAgICB9O1xuXG59KCkgKTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICAgIGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oKTtcblxuICAgIH1cblxuICAgIGRhdGEub2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlID0gVEhSRUUuU3ByaXRlO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xlbnNGbGFyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxlbnNGbGFyZSA9IGZ1bmN0aW9uKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5sZW5zRmxhcmVzID0gW107XG5cbiAgICB0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy5hZGQoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxlbnNGbGFyZTtcblxuXG4vKlxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yLCBvcGFjaXR5ICkge1xuXG4gICAgaWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gLTE7XG4gICAgaWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xuICAgIGlmICggb3BhY2l0eSA9PT0gdW5kZWZpbmVkICkgb3BhY2l0eSA9IDE7XG4gICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG4gICAgaWYgKCBibGVuZGluZyA9PT0gdW5kZWZpbmVkICkgYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcblxuICAgIGRpc3RhbmNlID0gTWF0aC5taW4oIGRpc3RhbmNlLCBNYXRoLm1heCggMCwgZGlzdGFuY2UgKSApO1xuXG4gICAgdGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcbiAgICAgICAgdGV4dHVyZTogdGV4dHVyZSwgLy8gVEhSRUUuVGV4dHVyZVxuICAgICAgICBzaXplOiBzaXplLCAvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLCAvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHo6IDAsIC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgaW4gZnJvbnQgeiA9IDEgaXMgYmFja1xuICAgICAgICBzY2FsZTogMSwgLy8gc2NhbGVcbiAgICAgICAgcm90YXRpb246IDAsIC8vIHJvdGF0aW9uXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHksIC8vIG9wYWNpdHlcbiAgICAgICAgY29sb3I6IGNvbG9yLCAvLyBjb2xvclxuICAgICAgICBibGVuZGluZzogYmxlbmRpbmcgLy8gYmxlbmRpbmdcbiAgICB9ICk7XG5cbn07XG5cbi8qXG4gKiBVcGRhdGUgbGVucyBmbGFyZXMgdXBkYXRlIHBvc2l0aW9ucyBvbiBhbGwgZmxhcmVzIGJhc2VkIG9uIHRoZSBzY3JlZW4gcG9zaXRpb25cbiAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xuICAgIHZhciBmbGFyZTtcbiAgICB2YXIgdmVjWCA9IC10aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xuICAgIHZhciB2ZWNZID0gLXRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XG5cbiAgICBmb3IgKCBmID0gMDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcblxuICAgICAgICBmbGFyZS54ID0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICsgdmVjWCAqIGZsYXJlLmRpc3RhbmNlO1xuICAgICAgICBmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xuXG4gICAgICAgIGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xuICAgICAgICBmbGFyZS5yb3RhdGlvbiArPSAoIGZsYXJlLndhbnRlZFJvdGF0aW9uIC0gZmxhcmUucm90YXRpb24gKSAqIDAuMjU7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMucG9zaXRpb25TY3JlZW4uY29weSggc291cmNlLnBvc2l0aW9uU2NyZWVuICk7XG4gICAgdGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHNvdXJjZS5jdXN0b21VcGRhdGVDYWxsYmFjaztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3NjZW5lcy9TY2VuZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuU2NlbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTY2VuZSc7XG5cbiAgICB0aGlzLmZvZyA9IG51bGw7XG4gICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXG5cbn07XG5cblRIUkVFLlNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuU2NlbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2NlbmU7XG5cblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgaWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XG4gICAgaWYgKCBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cbiAgICB0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRm9nID0gZnVuY3Rpb24oIGNvbG9yLCBuZWFyLCBmYXIgKSB7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cbiAgICB0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XG4gICAgdGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAxMDAwO1xuXG59O1xuXG5USFJFRS5Gb2cucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nRXhwMi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZvZ0V4cDIgPSBmdW5jdGlvbiggY29sb3IsIGRlbnNpdHkgKSB7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG4gICAgdGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xuXG59O1xuXG5USFJFRS5Gb2dFeHAyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsuanNcblxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7fTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhbWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGF0ZXN0X2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cXG5cdGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hb21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYW9tYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG5cdHRvdGFsQW1iaWVudExpZ2h0ICo9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hb21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXG5cdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2luX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYmVnaW5fdmVydGV4JyBdID0gXCJcXG52ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYmVnaW5ub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdiZWdpbm5vcm1hbF92ZXJ0ZXgnIF0gPSBcIlxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2J1bXBtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYnVtcG1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXG5cXG5cdC8vIERlcml2YXRpdmUgbWFwcyAtIGJ1bXAgbWFwcGluZyB1bnBhcmFtZXRyaXplZCBzdXJmYWNlcyBieSBNb3J0ZW4gTWlra2Vsc2VuXFxuXHQvLyBodHRwOi8vbW1pa2tlbHNlbjNkLmJsb2dzcG90LnNrLzIwMTEvMDcvZGVyaXZhdGl2ZS1tYXBzLmh0bWxcXG5cXG5cdC8vIEV2YWx1YXRlIHRoZSBkZXJpdmF0aXZlIG9mIHRoZSBoZWlnaHQgdy5yLnQuIHNjcmVlbi1zcGFjZSB1c2luZyBmb3J3YXJkIGRpZmZlcmVuY2luZyAobGlzdGluZyAyKVxcblxcblx0dmVjMiBkSGR4eV9md2QoKSB7XFxuXFxuXHRcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cdFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcblx0XHRmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxuXHRcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblx0XHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXG5cdFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxuXFxuXHR9XFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1xcblxcblx0XHR2ZWMzIHZTaWdtYVggPSBkRmR4KCBzdXJmX3BvcyApO1xcblx0XHR2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1xcblx0XHR2ZWMzIHZOID0gc3VyZl9ub3JtO1x0XHQvLyBub3JtYWxpemVkXFxuXFxuXHRcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG5cdFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcblx0XHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblxcblx0XHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb21tb24uZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbW1vbicgXSA9IFwiI2RlZmluZSBQSSAzLjE0MTU5XFxuI2RlZmluZSBQSTIgNi4yODMxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuXFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuXFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXG5cdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggbm9ybWFsLCAwLjAgKSApLnh5eiApO1xcblxcbn1cXG5cXG4vLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0dMU0xfUHJvZ3JhbW1pbmcvQXBwbHlpbmdfTWF0cml4X1RyYW5zZm9ybWF0aW9uc1xcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBub3JtYWwsIGluIG1hdDQgbWF0cml4ICkge1xcblxcblx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBub3JtYWwsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxuXFxufVxcblxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXHRmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxuXFxuXHRyZXR1cm4gLSBkaXN0YW5jZSAqIHBsYW5lTm9ybWFsICsgcG9pbnQ7XFxuXFxufVxcblxcbmZsb2F0IHNpZGVPZlBsYW5lKCBpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG5cdHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxuXFxufVxcblxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblx0cmV0dXJuIGxpbmVEaXJlY3Rpb24gKiAoIGRvdCggcGxhbmVOb3JtYWwsIHBvaW50T25QbGFuZSAtIHBvaW50T25MaW5lICkgLyBkb3QoIHBsYW5lTm9ybWFsLCBsaW5lRGlyZWN0aW9uICkgKSArIHBvaW50T25MaW5lO1xcblxcbn1cXG5cXG5mbG9hdCBjYWxjTGlnaHRBdHRlbnVhdGlvbiggZmxvYXQgbGlnaHREaXN0YW5jZSwgZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxuXFxuXHRpZiAoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuXFxuXHQgIHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cXG5cdH1cXG5cXG5cdHJldHVybiAxLjA7XFxuXFxufVxcblxcbnZlYzMgRl9TY2hsaWNrKCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGluIGZsb2F0IGRvdExIICkge1xcblxcblx0Ly8gT3JpZ2luYWwgYXBwcm94aW1hdGlvbiBieSBDaHJpc3RvcGhlIFNjaGxpY2sgJzk0XFxuXHQvLztmbG9hdCBmcmVzbmVsID0gcG93KCAxLjAgLSBkb3RMSCwgNS4wICk7XFxuXFxuXHQvLyBPcHRpbWl6ZWQgdmFyaWFudCAocHJlc2VudGVkIGJ5IEVwaWMgYXQgU0lHR1JBUEggJzEzKVxcblx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0MzcgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XFxuXFxuXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXG5cXG59XFxuXFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCAvKiBpbiBmbG9hdCBkb3ROTCwgaW4gZmxvYXQgZG90TlYgKi8gKSB7XFxuXFxuXHQvLyBnZW9tZXRyeSB0ZXJtIGlzIChu4ouFbCkobuKLhXYpIC8gNChu4ouFbCkobuKLhXYpXFxuXFxuXHRyZXR1cm4gMC4yNTtcXG5cXG59XFxuXFxuZmxvYXQgRF9CbGlublBob25nKCBpbiBmbG9hdCBzaGluaW5lc3MsIGluIGZsb2F0IGRvdE5IICkge1xcblxcblx0Ly8gZmFjdG9yIG9mIDEvUEkgaW4gZGlzdHJpYnV0aW9uIHRlcm0gb21pdHRlZFxcblxcblx0cmV0dXJuICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG5cXG59XFxuXFxudmVjMyBCUkRGX0JsaW5uUGhvbmcoIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgc2hpbmluZXNzLCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBsaWdodERpciwgaW4gdmVjMyB2aWV3RGlyICkge1xcblxcblx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcXG5cXG5cdC8vZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cdC8vZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcblx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBsaWdodERpciwgaGFsZkRpciApICk7XFxuXFxuXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFxuXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCAvKiBkb3ROTCwgZG90TlYgKi8gKTtcXG5cXG5cdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcXG5cXG5cdHJldHVybiBGICogRyAqIEQ7XFxuXFxufVxcblxcbnZlYzMgaW5wdXRUb0xpbmVhciggaW4gdmVjMyBhICkge1xcblxcblx0I2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuXHRcdHJldHVybiBwb3coIGEsIHZlYzMoIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRyZXR1cm4gYTtcXG5cXG5cdCNlbmRpZlxcblxcbn1cXG5cXG52ZWMzIGxpbmVhclRvT3V0cHV0KCBpbiB2ZWMzIGEgKSB7XFxuXFxuXHQjaWZkZWYgR0FNTUFfT1VUUFVUXFxuXFxuXHRcdHJldHVybiBwb3coIGEsIHZlYzMoIDEuMCAvIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRyZXR1cm4gYTtcXG5cXG5cdCNlbmRpZlxcblxcbn1cXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdG5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2RlZmF1bHRub3JtYWxfdmVydGV4JyBdID0gXCIjaWZkZWYgRkxJUF9TSURFRFxcblxcblx0b2JqZWN0Tm9ybWFsID0gLW9iamVjdE5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2VtaXNzaXZlbWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFxuXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXG5cdGVtaXNzaXZlQ29sb3IucmdiID0gaW5wdXRUb0xpbmVhciggZW1pc3NpdmVDb2xvci5yZ2IgKTtcXG5cXG5cdHRvdGFsRW1pc3NpdmVMaWdodCAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG5cdFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcblx0XHQvLyBUcmFuc2Zvcm1pbmcgTm9ybWFsIFZlY3RvcnMgd2l0aCB0aGUgSW52ZXJzZSBUcmFuc2Zvcm1hdGlvblxcblx0XHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuXHRcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXHRcdCNlbHNlXFxuXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHQjZWxzZVxcblxcblx0XHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRmbG9hdCBmbGlwTm9ybWFsID0gKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcblx0I2Vsc2VcXG5cdFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcblx0XHR2ZWMyIHNhbXBsZVVWO1xcblx0XHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cdFx0c2FtcGxlVVYueCA9IGF0YW4oIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnosIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcblx0XHR2ZWMzIHJlZmxlY3RWaWV3ID0gZmxpcE5vcm1hbCAqIG5vcm1hbGl6ZSgodmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApKS54eXogKyB2ZWMzKDAuMCwwLjAsMS4wKSk7XFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG5cdCNlbmRpZlxcblxcblx0ZW52Q29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggZW52Q29sb3IueHl6ICk7XFxuXFxuXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcblx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cdCNlbHNlXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cdCNlbmRpZlxcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG5cdFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcblx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF92ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0dmVjMyB3b3JsZE5vcm1hbCA9IHRyYW5zZm9ybURpcmVjdGlvbiggb2JqZWN0Tm9ybWFsLCBtb2RlbE1hdHJpeCApO1xcblxcblx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcblx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG5cdFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBGT0dfRVhQMlxcblxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXFxuXHQjZW5kaWZcXG5cdFxcblx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZm9nX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFxuXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFxuXHQjaWZkZWYgRk9HX0VYUDJcXG5cXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXG5cdHRvdGFsQW1iaWVudExpZ2h0ICs9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXgnIF0gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGVjYXlbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfbGFtYmVydF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19sYW1iZXJ0X3ZlcnRleCcgXSA9IFwidkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHR2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHQvLyBhdHRlbnVhdGlvblxcblxcblx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHR2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHNwb3RMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHRQb3NpdGlvbiA9IHNwb3RMaWdodFBvc2l0aW9uWyBpIF07XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxpZ2h0UG9zaXRpb24gLSBtdlBvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbGlnaHREaXIgKTtcXG5cXG5cdFx0aWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5cXG5cdFx0XHRzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApICk7XFxuXFxuXHRcdFx0Ly8gYXR0ZW51YXRpb25cXG5cXG5cdFx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHRcdGF0dGVudWF0aW9uICo9IHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0XHR2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcblx0XHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHRcdHZMaWdodEJhY2sgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIC0gZG90UHJvZHVjdCApO1xcblxcblx0XHRcdCNlbmRpZlxcblxcblx0XHR9XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHRCYWNrID0gLSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblx0XHRcdHZMaWdodEJhY2sgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxudkxpZ2h0RnJvbnQgKz0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0dkxpZ2h0QmFjayArPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfZnJhZ21lbnQnIF0gPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG5cdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdG5vcm1hbCA9IG5vcm1hbCAqICggLTEuMCArIDIuMCAqIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZWxzZVxcblxcblx0dmVjMyBmZHggPSBkRmR4KCB2Vmlld1Bvc2l0aW9uICk7XFxuXHR2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTtcXG5cdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG5cXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuXFxudmVjMyB0b3RhbERpZmZ1c2VMaWdodCA9IHZlYzMoIDAuMCApO1xcbnZlYzMgdG90YWxTcGVjdWxhckxpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gcG9pbnRMaWdodFBvc2l0aW9uWyBpIF07XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxpZ2h0UG9zaXRpb24gKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHQvLyBhdHRlbnVhdGlvblxcblxcblx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblx0XHQvLyBzcGVjdWxhclxcblxcblx0XHR2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG5cdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBzcG90TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0UG9zaXRpb24gPSBzcG90TGlnaHRQb3NpdGlvblsgaSBdO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsaWdodFBvc2l0aW9uICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cdFx0ZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IHNhdHVyYXRlKCBwb3coIHNhdHVyYXRlKCBzcG90RWZmZWN0ICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSApO1xcblxcblx0XHRcdC8vIGF0dGVudWF0aW9uXFxuXFxuXHRcdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodERpc3RhbmNlWyBpIF0sIHNwb3RMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cdFx0XHRhdHRlbnVhdGlvbiAqPSBzcG90RWZmZWN0O1xcblxcblx0XHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0XHRmbG9hdCBjb3NpbmVUZXJtID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFxuXHRcdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cdFx0XHQvLyBzcGVjdWxhclxcblxcblx0XHRcdHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcblx0XHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXHRcdH1cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBjb3NpbmVUZXJtID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFxuXHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcblx0XHQvLyBzcGVjdWxhclxcblxcblx0XHR2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG5cdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGNvc2luZVRlcm07XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvcjtcXG5cXG5cdFx0Ly8gc3BlY3VsYXIgKHNreSB0ZXJtIG9ubHkpXFxuXFxuXHRcdHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcblx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgTUVUQUxcXG5cXG5cdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICogc3BlY3VsYXIgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XFxuXFxuI2Vsc2VcXG5cXG5cdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQnIF0gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGVjYXlbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG5cdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleCcgXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ192ZXJ0ZXgnIF0gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQnIF0gPSBcIlxcblx0b3V0Z29pbmdMaWdodCA9IGxpbmVhclRvT3V0cHV0KCBvdXRnb2luZ0xpZ2h0ICk7XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9mcmFnbWVudCcgXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFxuXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcblx0I2VuZGlmXFxuXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSkgKiBsb2dEZXB0aEJ1ZkZDO1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXFxuI2Vsc2VcXG5cXG5cdFx0Z2xfUG9zaXRpb24ueiA9IChnbF9Qb3NpdGlvbi56IC0gMS4wKSAqIGdsX1Bvc2l0aW9uLnc7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFxuXHR0ZXhlbENvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIHRleGVsQ29sb3IueHl6ICk7XFxuXFxuXHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdGRpZmZ1c2VDb2xvciAqPSB0ZXh0dXJlMkQoIG1hcCwgdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKSAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eSApO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaG5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBobm9ybWFsX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDEgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG5cdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXG5cXG5cdCNlbHNlXFxuXFxuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cdHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcXG5cXG5cdC8vIFBlci1QaXhlbCBUYW5nZW50IFNwYWNlIE5vcm1hbCBNYXBwaW5nXFxuXHQvLyBodHRwOi8vaGFja3NvZmxpZmUuYmxvZ3Nwb3QuY2gvMjAwOS8xMS9wZXItcGl4ZWwtdGFuZ2VudC1zcGFjZS1ub3JtYWwtbWFwcGluZy5odG1sXFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblxcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXHRcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuXHRcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cdFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cdFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG5cdFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cdFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cdFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvcHJvamVjdF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3Byb2plY3RfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1xcblxcbiNlbHNlXFxuXFxuXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuI2VuZGlmXFxuXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHQjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXHRcdHZlYzMgZnJ1c3R1bUNvbG9yc1szXTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1swXSA9IHZlYzMoIDEuMCwgMC41LCAwLjAgKTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1sxXSA9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1syXSA9IHZlYzMoIDAuMCwgMC41LCAxLjAgKTtcXG5cXG5cdCNlbmRpZlxcblxcblx0ZmxvYXQgZkRlcHRoO1xcblx0dmVjMyBzaGFkb3dDb2xvciA9IHZlYzMoIDEuMCApO1xcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBzaGFkb3dDb29yZCA9IHZTaGFkb3dDb29yZFsgaSBdLnh5eiAvIHZTaGFkb3dDb29yZFsgaSBdLnc7XFxuXFxuXHRcdFx0XHQvLyBpZiAoIHNvbWV0aGluZyAmJiBzb21ldGhpbmcgKSBicmVha3MgQVRJIE9wZW5HTCBzaGFkZXIgY29tcGlsZXJcXG5cdFx0XHRcdC8vIGlmICggYWxsKCBzb21ldGhpbmcsIHNvbWV0aGluZyApICkgdXNpbmcgdGhpcyBpbnN0ZWFkXFxuXFxuXHRcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXG5cdFx0Ym9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1xcblxcblx0XHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFxuXHRcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFxuXHRcdGlmICggZnJ1c3R1bVRlc3QgKSB7XFxuXFxuXHRcdFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzWyBpIF07XFxuXFxuXHRcdFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFxuXHRcdFx0XHRcdFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcXG5cdFx0XHRcdFx0XHQvLyAoOSBwaXhlbCBrZXJuZWwpXFxuXHRcdFx0XHRcdFx0Ly8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xcblxcblx0XHRcdFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcblx0XHQvKlxcblx0XHRcdFx0XHRcdC8vIG5lc3RlZCBsb29wcyBicmVha3Mgc2hhZGVyIGNvbXBpbGVyIC8gdmFsaWRhdG9yIG9uIHNvbWUgQVRJIGNhcmRzIHdoZW4gdXNpbmcgT3BlbkdMXFxuXHRcdFx0XHRcdFx0Ly8gbXVzdCBlbnJvbGwgbG9vcCBtYW51YWxseVxcblxcblx0XHRcdFx0Zm9yICggZmxvYXQgeSA9IC0xLjI1OyB5IDw9IDEuMjU7IHkgKz0gMS4yNSApXFxuXHRcdFx0XHRcdGZvciAoIGZsb2F0IHggPSAtMS4yNTsgeCA8PSAxLjI1OyB4ICs9IDEuMjUgKSB7XFxuXFxuXHRcdFx0XHRcdFx0dmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApO1xcblxcblx0XHRcdFx0XHRcdFx0XHQvLyBkb2Vzbid0IHNlZW0gdG8gcHJvZHVjZSBhbnkgbm90aWNlYWJsZSB2aXN1YWwgZGlmZmVyZW5jZSBjb21wYXJlZCB0byBzaW1wbGUgdGV4dHVyZTJEIGxvb2t1cFxcblx0XHRcdFx0XHRcdFx0XHQvL3ZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEUHJvaiggc2hhZG93TWFwWyBpIF0sIHZlYzQoIHZTaGFkb3dDb29yZFsgaSBdLncgKiAoIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICksIDAuMDUsIHZTaGFkb3dDb29yZFsgaSBdLncgKSApO1xcblxcblx0XHRcdFx0XHRcdGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cXG5cdFx0XHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblx0XHRcdFx0XHRcdFx0c2hhZG93ICs9IDEuMDtcXG5cXG5cdFx0XHRcdH1cXG5cXG5cdFx0XHRcdHNoYWRvdyAvPSA5LjA7XFxuXFxuXHRcdCovXFxuXFxuXHRcdFx0XHRjb25zdCBmbG9hdCBzaGFkb3dEZWx0YSA9IDEuMCAvIDkuMDtcXG5cXG5cdFx0XHRcdGZsb2F0IHhQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS54O1xcblx0XHRcdFx0ZmxvYXQgeVBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XFxuXFxuXHRcdFx0XHRmbG9hdCBkeDAgPSAtMS4yNSAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MCA9IC0xLjI1ICogeVBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHgxID0gMS4yNSAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MSA9IDEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1xcblxcblx0XHRcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXG5cdFx0XHRcdFx0XHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xcblx0XHRcdFx0XHRcdC8vICg5IHBpeGVsIGtlcm5lbClcXG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXFxuXFxuXHRcdFx0XHRmbG9hdCBzaGFkb3cgPSAwLjA7XFxuXFxuXHRcdFx0XHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cdFx0XHRcdGZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1xcblxcblx0XHRcdFx0ZmxvYXQgZHgwID0gLTEuMCAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MCA9IC0xLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeDEgPSAxLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTEgPSAxLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuXHRcdFx0XHRtYXQzIHNoYWRvd0tlcm5lbDtcXG5cdFx0XHRcdG1hdDMgZGVwdGhLZXJuZWw7XFxuXFxuXHRcdFx0XHRkZXB0aEtlcm5lbFswXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMF1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzBdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsxXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMV1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMV1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzJdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsyXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMl1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcXG5cXG5cdFx0XHRcdHZlYzMgc2hhZG93WiA9IHZlYzMoIHNoYWRvd0Nvb3JkLnogKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFswXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMF0sIHNoYWRvd1ogKSk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMF0gKj0gdmVjMygwLjI1KTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsxXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMV0sIHNoYWRvd1ogKSk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMV0gKj0gdmVjMygwLjI1KTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsyXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMl0sIHNoYWRvd1ogKSk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMl0gKj0gdmVjMygwLjI1KTtcXG5cXG5cdFx0XHRcdHZlYzIgZnJhY3Rpb25hbENvb3JkID0gMS4wIC0gZnJhY3QoIHNoYWRvd0Nvb3JkLnh5ICogc2hhZG93TWFwU2l6ZVtpXS54eSApO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWzBdID0gbWl4KCBzaGFkb3dLZXJuZWxbMV0sIHNoYWRvd0tlcm5lbFswXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsxXSA9IG1peCggc2hhZG93S2VybmVsWzJdLCBzaGFkb3dLZXJuZWxbMV0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXFxuXHRcdFx0XHR2ZWM0IHNoYWRvd1ZhbHVlcztcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy54ID0gbWl4KCBzaGFkb3dLZXJuZWxbMF1bMV0sIHNoYWRvd0tlcm5lbFswXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy55ID0gbWl4KCBzaGFkb3dLZXJuZWxbMF1bMl0sIHNoYWRvd0tlcm5lbFswXVsxXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy56ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMV0sIHNoYWRvd0tlcm5lbFsxXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy53ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMl0sIHNoYWRvd0tlcm5lbFsxXVsxXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvdyA9IGRvdCggc2hhZG93VmFsdWVzLCB2ZWM0KCAxLjAgKSApO1xcblxcblx0XHRcdFx0c2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XFxuXFxuXHRcdFx0I2Vsc2VcXG5cXG5cdFx0XHRcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKTtcXG5cdFx0XHRcdGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXFxuXHRcdC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGlzIGRhcmtlclxcblxcblx0XHRcdFx0XHRzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSApO1xcblxcblx0XHQvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBoYXMgdGhlIHNhbWUgY29sb3IgYXMgc2luZ2xlIHNoYWRvdyBzcG90XFxuXFxuXHRcdC8vIFx0XHRcdFx0XHRzaGFkb3dDb2xvciA9IG1pbiggc2hhZG93Q29sb3IsIHZlYzMoIHNoYWRvd0RhcmtuZXNzWyBpIF0gKSApO1xcblxcblx0XHRcdCNlbmRpZlxcblxcblx0XHR9XFxuXFxuXFxuXHRcdCNpZmRlZiBTSEFET1dNQVBfREVCVUdcXG5cXG5cdFx0XHRpZiAoIGluRnJ1c3R1bSApIG91dGdvaW5nTGlnaHQgKj0gZnJ1c3R1bUNvbG9yc1sgaSBdO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG5cdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogc2hhZG93Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd01hcFsgTUFYX1NIQURPV1MgXTtcXG5cdHVuaWZvcm0gdmVjMiBzaGFkb3dNYXBTaXplWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dEYXJrbmVzc1sgTUFYX1NIQURPV1MgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc2hhZG93Qmlhc1sgTUFYX1NIQURPV1MgXTtcXG5cXG5cdHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuXFxuXHRmbG9hdCB1bnBhY2tEZXB0aCggY29uc3QgaW4gdmVjNCByZ2JhX2RlcHRoICkge1xcblxcblx0XHRjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XFxuXHRcdGZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcXG5cdFx0cmV0dXJuIGRlcHRoO1xcblxcblx0fVxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuXHR1bmlmb3JtIG1hdDQgc2hhZG93TWF0cml4WyBNQVhfU0hBRE9XUyBdO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG5cdFx0dlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5iYXNlX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbmJhc2VfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5cdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXG5cdCNpZmRlZiBCT05FX1RFWFRVUkVcXG5cXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlV2lkdGg7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlSGVpZ2h0O1xcblxcblx0XHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXHRcdFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXHRcdFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblx0XHRcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXG5cdFx0XHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuXHRcdFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXG5cdFx0XHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXG5cdFx0XHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFxuXHRcdFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXG5cdFx0XHRyZXR1cm4gYm9uZTtcXG5cXG5cdFx0fVxcblxcblx0I2Vsc2VcXG5cXG5cdFx0dW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cdFx0XHRtYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1xcblx0XHRcdHJldHVybiBib25lO1xcblxcblx0XHR9XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcblx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcblx0c2tpbm5lZCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5ub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubm9ybWFsX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcblx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9mcmFnbWVudCcgXSA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG5cXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG5cdHNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxuXFxuI2Vsc2VcXG5cXG5cdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG5cdHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cdHZVdjIgPSB1djI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXZfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApXFxuXFxuXHR2VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvd29ybGRwb3NfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd3b3JsZHBvc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcblxcblx0I2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0XHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHNraW5uZWQ7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzXG5cbi8qKlxuICogVW5pZm9ybSBVdGlsaXRpZXNcbiAqL1xuXG5USFJFRS5Vbmlmb3Jtc1V0aWxzID0ge1xuXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCB1bmlmb3JtcyApIHtcblxuICAgICAgICB2YXIgbWVyZ2VkID0ge307XG5cbiAgICAgICAgZm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmNsb25lKCB1bmlmb3Jtc1sgdSBdICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBwIGluIHRtcCApIHtcblxuICAgICAgICAgICAgICAgIG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oIHVuaWZvcm1zX3NyYyApIHtcblxuICAgICAgICB2YXIgdW5pZm9ybXNfZHN0ID0ge307XG5cbiAgICAgICAgZm9yICggdmFyIHUgaW4gdW5pZm9ybXNfc3JjICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXSA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgcCBpbiB1bmlmb3Jtc19zcmNbIHUgXSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcblxuICAgICAgICAgICAgICAgIGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0IHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXgzIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0IHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHBhcmFtZXRlcl9zcmMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmlmb3Jtc19kc3Q7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zTGliLmpzXG5cbi8qKlxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcbiAqL1xuXG5USFJFRS5Vbmlmb3Jtc0xpYiA9IHtcblxuICAgIGNvbW1vbjoge1xuXG4gICAgICAgIFwiZGlmZnVzZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlIClcbiAgICAgICAgfSxcbiAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICB9LFxuXG4gICAgICAgIFwibWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJvZmZzZXRSZXBlYXRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ2NFwiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxIClcbiAgICAgICAgfSxcblxuICAgICAgICBcInNwZWN1bGFyTWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJhbHBoYU1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJlbnZNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcImZsaXBFbnZNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogLTFcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZWZsZWN0aXZpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIFwicmVmcmFjdGlvblJhdGlvXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDAuOThcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGFvbWFwOiB7XG5cbiAgICAgICAgXCJhb01hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwiYW9NYXBJbnRlbnNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICB9LFxuXG4gICAgfSxcblxuICAgIGxpZ2h0bWFwOiB7XG5cbiAgICAgICAgXCJsaWdodE1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwibGlnaHRNYXBJbnRlbnNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICB9LFxuXG4gICAgfSxcblxuICAgIGVtaXNzaXZlbWFwOiB7XG5cbiAgICAgICAgXCJlbWlzc2l2ZU1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICB9LFxuXG4gICAgYnVtcG1hcDoge1xuXG4gICAgICAgIFwiYnVtcE1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwiYnVtcFNjYWxlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG5vcm1hbG1hcDoge1xuXG4gICAgICAgIFwibm9ybWFsTWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJub3JtYWxTY2FsZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInYyXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGlzcGxhY2VtZW50bWFwOiB7XG5cbiAgICAgICAgXCJkaXNwbGFjZW1lbnRNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcImRpc3BsYWNlbWVudFNjYWxlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgfSxcbiAgICAgICAgXCJkaXNwbGFjZW1lbnRCaWFzXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGZvZzoge1xuXG4gICAgICAgIFwiZm9nRGVuc2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLjAwMDI1XG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9nTmVhclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9nRmFyXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDIwMDBcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmIClcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGxpZ2h0czoge1xuXG4gICAgICAgIFwiYW1iaWVudExpZ2h0Q29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHRDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcblxuICAgICAgICBcImhlbWlzcGhlcmVMaWdodERpcmVjdGlvblwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcblxuICAgICAgICBcInBvaW50TGlnaHRDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2ludExpZ2h0UG9zaXRpb25cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pbnRMaWdodERpc3RhbmNlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2ludExpZ2h0RGVjYXlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuXG4gICAgICAgIFwic3BvdExpZ2h0Q29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0UG9zaXRpb25cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0RGlyZWN0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodERpc3RhbmNlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHRBbmdsZUNvc1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0RXhwb25lbnRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodERlY2F5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHBvaW50czoge1xuXG4gICAgICAgIFwicHNDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlIClcbiAgICAgICAgfSxcbiAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICB9LFxuICAgICAgICBcInNpemVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIFwic2NhbGVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIFwibWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJvZmZzZXRSZXBlYXRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ2NFwiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxIClcbiAgICAgICAgfSxcblxuICAgICAgICBcImZvZ0RlbnNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMC4wMDAyNVxuICAgICAgICB9LFxuICAgICAgICBcImZvZ05lYXJcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICB9LFxuICAgICAgICBcImZvZ0ZhclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAyMDAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9nQ29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBzaGFkb3dtYXA6IHtcblxuICAgICAgICBcInNoYWRvd01hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInR2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGFkb3dNYXBTaXplXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidjJ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcblxuICAgICAgICBcInNoYWRvd0JpYXNcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNoYWRvd0RhcmtuZXNzXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcblxuICAgICAgICBcInNoYWRvd01hdHJpeFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm00dlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliLmpzXG5cbi8qKlxuICogV2ViZ2wgU2hhZGVyIExpYnJhcnkgZm9yIHRocmVlLmpzXG4gKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblxuVEhSRUUuU2hhZGVyTGliID0ge1xuXG4gICAgJ2Jhc2ljJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXVxuXG4gICAgICAgIF0gKSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9FTlZNQVBcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSB2ZWMzKCAxLjAgKTtcIiwgLy8gaGFyZHdpcmVkXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiB0b3RhbEFtYmllbnRMaWdodDtcIiwgLy8gc2ltcGxlIHNoYWRlclxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSwgLy8gVE9ETzogU2hhZG93cyBvbiBhbiBvdGhlcndpc2UgdW5saXQgc3VyZmFjZSBkb2Vzbid0IG1ha2Ugc2Vuc2UuXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgJ2xhbWJlcnQnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiZW1pc3NpdmVcIjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICBdICksXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwiI2RlZmluZSBMQU1CRVJUXCIsXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxuXG4gICAgICAgICAgICBcIiNpZmRlZiBET1VCTEVfU0lERURcIixcblxuICAgICAgICAgICAgXCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxuXG4gICAgICAgICAgICBcIiNpZmRlZiBET1VCTEVfU0lERURcIixcblxuICAgICAgICAgICAgXCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIiwgLy8gb3V0Z29pbmcgbGlnaHQgZG9lcyBub3QgaGF2ZSBhbiBhbHBoYSwgdGhlIHN1cmZhY2UgZG9lc1xuICAgICAgICAgICAgXCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdCNpZmRlZiBET1VCTEVfU0lERURcIixcblxuICAgICAgICAgICAgXCJcdFx0aWYgKCBnbF9Gcm9udEZhY2luZyApXCIsXG4gICAgICAgICAgICBcIlx0XHRcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqIHZMaWdodEZyb250ICsgZW1pc3NpdmU7XCIsXG4gICAgICAgICAgICBcIlx0XHRlbHNlXCIsXG4gICAgICAgICAgICBcIlx0XHRcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqIHZMaWdodEJhY2sgKyBlbWlzc2l2ZTtcIixcblxuICAgICAgICAgICAgXCJcdCNlbHNlXCIsXG5cbiAgICAgICAgICAgIFwiXHRcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqIHZMaWdodEZyb250ICsgZW1pc3NpdmU7XCIsXG5cbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgJ3Bob25nJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodG1hcFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJidW1wbWFwXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJkaXNwbGFjZW1lbnRtYXBcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJlbWlzc2l2ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNwZWN1bGFyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExIClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2hpbmluZXNzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAzMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICBdICksXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwiI2RlZmluZSBQSE9OR1wiLFxuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBcIiNpZm5kZWYgRkxBVF9TSEFERURcIixcblxuICAgICAgICAgICAgXCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLCAvLyBOb3JtYWwgY29tcHV0ZWQgd2l0aCBkZXJpdmF0aXZlcyB3aGVuIEZMQVRfU0hBREVEXG5cbiAgICAgICAgICAgIFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxuXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcIiNkZWZpbmUgUEhPTkdcIixcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXI7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJidW1wbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibm9ybWFsbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcbiAgICAgICAgICAgIFwiXHR2ZWMzIHRvdGFsQW1iaWVudExpZ2h0ID0gYW1iaWVudExpZ2h0Q29sb3I7XCIsXG4gICAgICAgICAgICBcIlx0dmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgICdwb2ludHMnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwicG9pbnRzXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuICAgICAgICBdICksXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBzaXplO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgICAgICAgIFwiXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlwiLFxuICAgICAgICAgICAgXCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyBsZW5ndGgoIG12UG9zaXRpb24ueHl6ICkgKTtcIixcbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxuICAgICAgICAgICAgXCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcIixcbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcblxuICAgICAgICAgICAgXCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgcHNDb2xvcjtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcIiwgLy8gc2ltcGxlIHNoYWRlclxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAnZGFzaGVkJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJzY2FsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkYXNoU2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0b3RhbFNpemVcIjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgXSApLFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG4gICAgICAgICAgICBcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcIixcblxuICAgICAgICAgICAgXCJcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcbiAgICAgICAgICAgIFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IGRhc2hTaXplO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcIixcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1wiLFxuXG4gICAgICAgICAgICBcIlx0XHRkaXNjYXJkO1wiLFxuXG4gICAgICAgICAgICBcIlx0fVwiLFxuXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgJ2RlcHRoJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiB7XG5cbiAgICAgICAgICAgIFwibU5lYXJcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1GYXJcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAyMDAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBtTmVhcjtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBtRmFyO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXG5cbiAgICAgICAgICAgIFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxuXG4gICAgICAgICAgICBcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcblxuICAgICAgICAgICAgXCJcdGZsb2F0IGNvbG9yID0gMS4wIC0gc21vb3Roc3RlcCggbU5lYXIsIG1GYXIsIGRlcHRoICk7XCIsXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgJ25vcm1hbCc6IHtcblxuICAgICAgICB1bmlmb3Jtczoge1xuXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG5cdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAnY3ViZSc6IHtcblxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgXCJ0Q3ViZVwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRGbGlwXCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxuXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcblx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICdlcXVpcmVjdCc6IHtcblxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgXCJ0RXF1aXJlY3RcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0RmxpcFwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcblxuICAgICAgICAgICAgXCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIC8vIFwiXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxuICAgICAgICAgICAgXCJ2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcIixcbiAgICAgICAgICAgIFwidmVjMiBzYW1wbGVVVjtcIixcbiAgICAgICAgICAgIFwic2FtcGxlVVYueSA9IHNhdHVyYXRlKCB0RmxpcCAqIGRpcmVjdGlvbi55ICogLTAuNSArIDAuNSApO1wiLFxuICAgICAgICAgICAgXCJzYW1wbGVVVi54ID0gYXRhbiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcIixcbiAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgIC8qIERlcHRoIGVuY29kaW5nIGludG8gUkdCQSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBiYXNlZCBvbiBTcGlkZXJHTCBzaGFkb3cgbWFwIGV4YW1wbGVcbiAgICAgKiBodHRwOi8vc3BpZGVyZ2wub3JnL2V4YW1wbGUucGhwP2lkPTZcbiAgICAgKlxuICAgICAqIG9yaWdpbmFsbHkgZnJvbVxuICAgICAqIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvNDQyMTM4LXBhY2tpbmctYS1mbG9hdC1pbnRvLWEtYThyOGc4YjgtdGV4dHVyZS1zaGFkZXIvcGFnZV9fd2hpY2hwYWdlX18xJTI1RUYlMjVCRiUyNUJEXG4gICAgICpcbiAgICAgKiBzZWUgYWxzb1xuICAgICAqIGh0dHA6Ly9hcmFzLXAuaW5mby9ibG9nLzIwMDkvMDcvMzAvZW5jb2RpbmctZmxvYXRzLXRvLXJnYmEtdGhlLWZpbmFsL1xuICAgICAqL1xuXG4gICAgJ2RlcHRoUkdCQSc6IHtcblxuICAgICAgICB1bmlmb3Jtczoge30sXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2ZWM0IHBhY2tfZGVwdGgoIGNvbnN0IGluIGZsb2F0IGRlcHRoICkge1wiLFxuXG4gICAgICAgICAgICBcIlx0Y29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcIixcbiAgICAgICAgICAgIFwiXHRjb25zdCB2ZWM0IGJpdF9tYXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXG4gICAgICAgICAgICBcIlx0dmVjNCByZXMgPSBtb2QoIGRlcHRoICogYml0X3NoaWZ0ICogdmVjNCggMjU1ICksIHZlYzQoIDI1NiApICkgLyB2ZWM0KCAyNTUgKTtcIiwgLy8gXCJcdHZlYzQgcmVzID0gZnJhY3QoIGRlcHRoICogYml0X3NoaWZ0ICk7XCIsXG4gICAgICAgICAgICBcIlx0cmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XCIsXG4gICAgICAgICAgICBcIlx0cmV0dXJuIHJlcztcIixcblxuICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFwiLFxuXG4gICAgICAgICAgICBcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXG5cbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxuXG4gICAgICAgICAgICBcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogKTtcIixcblxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxuXG4gICAgICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcbiAgICAgICAgICAgIC8vXCJmbG9hdCB6ID0gKCAoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKSAtIDMuMCApIC8gKCA0MDAwLjAgLSAzLjAgKTtcIixcbiAgICAgICAgICAgIC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggeiApO1wiLFxuICAgICAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJlci5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xuXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICB2YXIgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXG4gICAgICAgIF9jb250ZXh0ID0gcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiBudWxsLFxuXG4gICAgICAgIF93aWR0aCA9IF9jYW52YXMud2lkdGgsXG4gICAgICAgIF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcblxuICAgICAgICBwaXhlbFJhdGlvID0gMSxcblxuICAgICAgICBfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXG4gICAgICAgIF9kZXB0aCA9IHBhcmFtZXRlcnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZGVwdGggOiB0cnVlLFxuICAgICAgICBfc3RlbmNpbCA9IHBhcmFtZXRlcnMuc3RlbmNpbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdGVuY2lsIDogdHJ1ZSxcbiAgICAgICAgX2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuICAgICAgICBfcHJlbXVsdGlwbGllZEFscGhhID0gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIDogdHJ1ZSxcbiAgICAgICAgX3ByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA6IGZhbHNlLFxuXG4gICAgICAgIF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxuICAgICAgICBfY2xlYXJBbHBoYSA9IDA7XG5cbiAgICB2YXIgbGlnaHRzID0gW107XG5cbiAgICB2YXIgb3BhcXVlT2JqZWN0cyA9IFtdO1xuICAgIHZhciBvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLTE7XG4gICAgdmFyIHRyYW5zcGFyZW50T2JqZWN0cyA9IFtdO1xuICAgIHZhciB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtMTtcblxuICAgIHZhciBvcGFxdWVJbW1lZGlhdGVPYmplY3RzID0gW107XG4gICAgdmFyIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXggPSAtMTtcbiAgICB2YXIgdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzID0gW107XG4gICAgdmFyIHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuXG4gICAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKTtcblxuXG4gICAgdmFyIHNwcml0ZXMgPSBbXTtcbiAgICB2YXIgbGVuc0ZsYXJlcyA9IFtdO1xuXG4gICAgLy8gcHVibGljIHByb3BlcnRpZXNcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIC8vIGNsZWFyaW5nXG5cbiAgICB0aGlzLmF1dG9DbGVhciA9IHRydWU7XG4gICAgdGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XG4gICAgdGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG4gICAgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcblxuICAgIC8vIHNjZW5lIGdyYXBoXG5cbiAgICB0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuICAgIC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG4gICAgdGhpcy5nYW1tYUZhY3RvciA9IDIuMDsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5nYW1tYUlucHV0ID0gZmFsc2U7XG4gICAgdGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xuXG4gICAgLy8gbW9ycGhzXG5cbiAgICB0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XG4gICAgdGhpcy5tYXhNb3JwaE5vcm1hbHMgPSA0O1xuXG4gICAgLy8gZmxhZ3NcblxuICAgIHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xuXG4gICAgLy8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG4gICAgdmFyIF90aGlzID0gdGhpcyxcblxuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxuXG4gICAgICAgIF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXG4gICAgICAgIF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxuICAgICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtMSxcbiAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJyxcbiAgICAgICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsLFxuXG4gICAgICAgIF91c2VkVGV4dHVyZVVuaXRzID0gMCxcblxuICAgICAgICBfdmlld3BvcnRYID0gMCxcbiAgICAgICAgX3ZpZXdwb3J0WSA9IDAsXG4gICAgICAgIF92aWV3cG9ydFdpZHRoID0gX2NhbnZhcy53aWR0aCxcbiAgICAgICAgX3ZpZXdwb3J0SGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXG4gICAgICAgIF9jdXJyZW50V2lkdGggPSAwLFxuICAgICAgICBfY3VycmVudEhlaWdodCA9IDAsXG5cbiAgICAgICAgLy8gZnJ1c3R1bVxuXG4gICAgICAgIF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcblxuICAgICAgICAvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcblxuICAgICAgICBfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cbiAgICAgICAgX3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICAgIC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxuXG4gICAgICAgIF9kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcblxuICAgICAgICBfbGlnaHRzID0ge1xuXG4gICAgICAgICAgICBhbWJpZW50OiBbIDAsIDAsIDAgXSxcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsOiB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgIGRlY2F5czogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcG90OiB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgIGFuZ2xlc0NvczogW10sXG4gICAgICAgICAgICAgICAgZXhwb25lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBkZWNheXM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVtaToge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICAgICAgICBza3lDb2xvcnM6IFtdLFxuICAgICAgICAgICAgICAgIGdyb3VuZENvbG9yczogW10sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zOiBbXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mb1xuXG4gICAgICAgIF9pbmZvTWVtb3J5ID0ge1xuXG4gICAgICAgICAgICBnZW9tZXRyaWVzOiAwLFxuICAgICAgICAgICAgdGV4dHVyZXM6IDBcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbmZvUmVuZGVyID0ge1xuXG4gICAgICAgICAgICBjYWxsczogMCxcbiAgICAgICAgICAgIHZlcnRpY2VzOiAwLFxuICAgICAgICAgICAgZmFjZXM6IDAsXG4gICAgICAgICAgICBwb2ludHM6IDBcblxuICAgICAgICB9O1xuXG4gICAgdGhpcy5pbmZvID0ge1xuXG4gICAgICAgIHJlbmRlcjogX2luZm9SZW5kZXIsXG4gICAgICAgIG1lbW9yeTogX2luZm9NZW1vcnksXG4gICAgICAgIHByb2dyYW1zOiBudWxsXG5cbiAgICB9O1xuXG5cbiAgICAvLyBpbml0aWFsaXplXG5cbiAgICB2YXIgX2dsO1xuXG4gICAgdHJ5IHtcblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIGFscGhhOiBfYWxwaGEsXG4gICAgICAgICAgICBkZXB0aDogX2RlcHRoLFxuICAgICAgICAgICAgc3RlbmNpbDogX3N0ZW5jaWwsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICAgICAgfTtcblxuICAgICAgICBfZ2wgPSBfY29udGV4dCB8fCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcsIGF0dHJpYnV0ZXMgKSB8fCBfY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzICk7XG5cbiAgICAgICAgaWYgKCBfZ2wgPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGlmICggX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4nO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0Lic7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cbiAgICB9XG4gICAgY2F0Y2ggKCBlcnJvciApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZXh0ZW5zaW9ucyA9IG5ldyBUSFJFRS5XZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xuXG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcbiAgICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcbiAgICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKTtcbiAgICBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcbiAgICBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICBpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuICAgICAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDQyOTQ5NjcyOTY7XG5cbiAgICB9XG5cbiAgICB2YXIgY2FwYWJpbGl0aWVzID0gbmV3IFRIUkVFLldlYkdMQ2FwYWJpbGl0aWVzKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKTtcblxuICAgIHZhciBzdGF0ZSA9IG5ldyBUSFJFRS5XZWJHTFN0YXRlKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICk7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBuZXcgVEhSRUUuV2ViR0xQcm9wZXJ0aWVzKCk7XG4gICAgdmFyIG9iamVjdHMgPSBuZXcgVEhSRUUuV2ViR0xPYmplY3RzKCBfZ2wsIHByb3BlcnRpZXMsIHRoaXMuaW5mbyApO1xuICAgIHZhciBwcm9ncmFtQ2FjaGUgPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtcyggdGhpcywgY2FwYWJpbGl0aWVzICk7XG5cbiAgICB0aGlzLmluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XG5cbiAgICB2YXIgYnVmZmVyUmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuICAgIHZhciBpbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcblxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBnbENsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKSB7XG5cbiAgICAgICAgaWYgKCBfcHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICByICo9IGE7XG4gICAgICAgICAgICBnICo9IGE7XG4gICAgICAgICAgICBiICo9IGE7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF9nbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXREZWZhdWx0R0xTdGF0ZSgpIHtcblxuICAgICAgICBzdGF0ZS5pbml0KCk7XG5cbiAgICAgICAgX2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XG5cbiAgICAgICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRHTFN0YXRlKCkge1xuXG4gICAgICAgIF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcblxuICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuICAgICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcblxuICAgICAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgc3RhdGUucmVzZXQoKTtcblxuICAgIH1cblxuICAgIHNldERlZmF1bHRHTFN0YXRlKCk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBfZ2w7XG4gICAgdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICAvLyBzaGFkb3cgbWFwXG5cbiAgICB2YXIgc2hhZG93TWFwID0gbmV3IFRIUkVFLldlYkdMU2hhZG93TWFwKCB0aGlzLCBsaWdodHMsIG9iamVjdHMgKTtcblxuICAgIHRoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xuXG5cbiAgICAvLyBQbHVnaW5zXG5cbiAgICB2YXIgc3ByaXRlUGx1Z2luID0gbmV3IFRIUkVFLlNwcml0ZVBsdWdpbiggdGhpcywgc3ByaXRlcyApO1xuICAgIHZhciBsZW5zRmxhcmVQbHVnaW4gPSBuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKCB0aGlzLCBsZW5zRmxhcmVzICk7XG5cbiAgICAvLyBBUElcblxuICAgIHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBfZ2w7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBfZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKS5sb3NlQ29udGV4dCgpO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0TWF4QW5pc290cm9weSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuICAgICAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9nbC5nZXRQYXJhbWV0ZXIoIGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIH1cblxuICAgIH0gKSgpO1xuXG4gICAgdGhpcy5nZXRQcmVjaXNpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gcGl4ZWxSYXRpbztcblxuICAgIH07XG5cbiAgICB0aGlzLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcGl4ZWxSYXRpbyA9IHZhbHVlO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogX3dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG4gICAgICAgIF93aWR0aCA9IHdpZHRoO1xuICAgICAgICBfaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIF9jYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICAgIF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblxuICAgICAgICBpZiAoIHVwZGF0ZVN0eWxlICE9PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgX2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgICAgICBfdmlld3BvcnRYID0geCAqIHBpeGVsUmF0aW87XG4gICAgICAgIF92aWV3cG9ydFkgPSB5ICogcGl4ZWxSYXRpbztcblxuICAgICAgICBfdmlld3BvcnRXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgX3ZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblxuICAgICAgICBfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgICAgICBfZ2wuc2Npc3NvcihcbiAgICAgICAgICAgIHggKiBwaXhlbFJhdGlvLFxuICAgICAgICAgICAgeSAqIHBpeGVsUmF0aW8sXG4gICAgICAgICAgICB3aWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgICAgICAgICBoZWlnaHQgKiBwaXhlbFJhdGlvXG4gICAgICAgICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5lbmFibGVTY2lzc29yVGVzdCA9IGZ1bmN0aW9uKCBib29sZWFuICkge1xuXG4gICAgICAgIHN0YXRlLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XG5cbiAgICB9O1xuXG4gICAgLy8gQ2xlYXJpbmdcblxuICAgIHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBfY2xlYXJDb2xvcjtcblxuICAgIH07XG5cbiAgICB0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiggY29sb3IsIGFscGhhICkge1xuXG4gICAgICAgIF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcblxuICAgICAgICBfY2xlYXJBbHBoYSA9IGFscGhhICE9PSB1bmRlZmluZWQgPyBhbHBoYSA6IDE7XG5cbiAgICAgICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBfY2xlYXJBbHBoYTtcblxuICAgIH07XG5cbiAgICB0aGlzLnNldENsZWFyQWxwaGEgPSBmdW5jdGlvbiggYWxwaGEgKSB7XG5cbiAgICAgICAgX2NsZWFyQWxwaGEgPSBhbHBoYTtcblxuICAgICAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cbiAgICAgICAgdmFyIGJpdHMgPSAwO1xuXG4gICAgICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvciApIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG4gICAgICAgIGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG4gICAgICAgIGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cbiAgICAgICAgX2dsLmNsZWFyKCBiaXRzICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgX2dsLmNsZWFyKCBfZ2wuQ09MT1JfQlVGRkVSX0JJVCApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF9nbC5jbGVhciggX2dsLkRFUFRIX0JVRkZFUl9CSVQgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF9nbC5jbGVhciggX2dsLlNURU5DSUxfQlVGRkVSX0JJVCApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cbiAgICAgICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuICAgICAgICB0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcblxuICAgIH07XG5cbiAgICAvLyBSZXNldFxuXG4gICAgdGhpcy5yZXNldEdMU3RhdGUgPSByZXNldEdMU3RhdGU7XG5cbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcblxuICAgIH07XG5cbiAgICAvLyBFdmVudHNcblxuICAgIGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgcmVzZXRHTFN0YXRlKCk7XG4gICAgICAgIHNldERlZmF1bHRHTFN0YXRlKCk7XG5cbiAgICAgICAgcHJvcGVydGllcy5jbGVhcigpO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICAgICAgZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcy0tO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cbiAgICAgICAgZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMtLTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTWF0ZXJpYWxEaXNwb3NlKCBldmVudCApIHtcblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgbWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG4gICAgICAgIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuICAgIGZ1bmN0aW9uIGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG4gICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cbiAgICAgICAgICAgIC8vIGN1YmUgdGV4dHVyZVxuXG4gICAgICAgICAgICBfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIDJEIHRleHR1cmVcblxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXG4gICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCB0ZXh0dXJlICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgaWYgKCAhcmVuZGVyVGFyZ2V0IHx8IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgICBfZ2wuZGVsZXRlVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcbiAgICAgICAgICAgICAgICBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuICAgICAgICAgICAgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggbWF0ZXJpYWwgKTtcblxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdmFyIHByb2dyYW1JbmZvID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbTtcblxuICAgICAgICBtYXRlcmlhbC5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICggcHJvZ3JhbUluZm8gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcHJvZ3JhbUNhY2hlLnJlbGVhc2VQcm9ncmFtKCBwcm9ncmFtSW5mbyApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBCdWZmZXIgcmVuZGVyaW5nXG5cbiAgICB0aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBwcm9wZXJ0aWVzLmdldCggb2JqZWN0ICk7XG5cbiAgICAgICAgaWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICFidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhYnVmZmVycy5ub3JtYWwgKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzVXZzICYmICFidWZmZXJzLnV2ICkgYnVmZmVycy51diA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICFidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgICAgIGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcblxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMucG9zaXRpb24gKTtcbiAgICAgICAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLm5vcm1hbCApO1xuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnR5cGUgIT09ICdNZXNoUGhvbmdNYXRlcmlhbCcgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY291bnQgKiAzOyBpIDwgbDsgaSArPSA5ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbnggPSAoIGFycmF5WyBpICsgMCBdICsgYXJyYXlbIGkgKyAzIF0gKyBhcnJheVsgaSArIDYgXSApIC8gMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG55ID0gKCBhcnJheVsgaSArIDEgXSArIGFycmF5WyBpICsgNCBdICsgYXJyYXlbIGkgKyA3IF0gKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBueiA9ICggYXJyYXlbIGkgKyAyIF0gKyBhcnJheVsgaSArIDUgXSArIGFycmF5WyBpICsgOCBdICkgLyAzO1xuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgMCBdID0gbng7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgMSBdID0gbnk7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgMiBdID0gbno7XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyAzIF0gPSBueDtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA0IF0gPSBueTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA1IF0gPSBuejtcblxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDYgXSA9IG54O1xuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDcgXSA9IG55O1xuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDggXSA9IG56O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcblxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcbiAgICAgICAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcblxuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvYmplY3QuaGFzQ29sb3JzICYmIG1hdGVyaWFsLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSB7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLmNvbG9yICk7XG4gICAgICAgICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LmNvbG9yQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XG5cbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgX2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCApO1xuXG4gICAgICAgIG9iamVjdC5jb3VudCA9IDA7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiggY2FtZXJhLCBsaWdodHMsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xuXG4gICAgICAgIHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgICAgIHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2U7XG4gICAgICAgIHZhciBnZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeS5pZCArICdfJyArIHByb2dyYW0uaWQgKyAnXycgKyBtYXRlcmlhbC53aXJlZnJhbWU7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xuXG4gICAgICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcbiAgICAgICAgICAgIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3JwaCB0YXJnZXRzXG5cbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICAgICAgaWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIGFjdGl2ZUluZmx1ZW5jZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmZsdWVuY2UgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmZsdWVuY2VzLnB1c2goIFsgaW5mbHVlbmNlLCBpIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY3RpdmVJbmZsdWVuY2VzLnNvcnQoIG51bWVyaWNhbFNvcnQgKTtcblxuICAgICAgICAgICAgaWYgKCBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA+IDggKSB7XG5cbiAgICAgICAgICAgICAgICBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5mbHVlbmNlID0gYWN0aXZlSW5mbHVlbmNlc1sgaSBdO1xuICAgICAgICAgICAgICAgIG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gaW5mbHVlbmNlWyAwIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluZmx1ZW5jZVsgMCBdICE9PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluZmx1ZW5jZVsgMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGksIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvblsgaW5kZXggXSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbFsgaW5kZXggXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9PT0gdHJ1ZSApIGdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdW5pZm9ybXMgPSBwcm9ncmFtLmdldFVuaWZvcm1zKCk7XG5cbiAgICAgICAgICAgIGlmICggdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIHVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcywgbW9ycGhJbmZsdWVuY2VzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlQnVmZmVycyA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIGluZGV4ID0gb2JqZWN0cy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJlcjtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICByZW5kZXJlciA9IGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEluZGV4KCBpbmRleCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkgKTtcblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBpbmRleCApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBncm91cCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgY291bnQ7XG5cbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBpbmRleC5jb3VudDtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIHBvc2l0aW9uIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IHBvc2l0aW9uLmRhdGEuYXJyYXkubGVuZ3RoIC8gMztcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBwb3NpdGlvbi5jb3VudDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXG4gICAgICAgICAgICBncm91cCA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZHJhd1JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50OiBNYXRoLm1pbiggZHJhd1JhbmdlLmNvdW50LCBjb3VudCApXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBwaXhlbFJhdGlvICk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cbiAgICAgICAgICAgIGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxuXG4gICAgICAgICAgICBzdGF0ZS5zZXRMaW5lV2lkdGgoIGxpbmVXaWR0aCAqIHBpeGVsUmF0aW8gKTtcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgKSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlciggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XG5cbiAgICAgICAgdmFyIGV4dGVuc2lvbjtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgICAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5zZXR1cFZlcnRleEF0dHJpYnV0ZXM6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBzdGFydEluZGV4ID09PSB1bmRlZmluZWQgKSBzdGFydEluZGV4ID0gMDtcblxuICAgICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgICAgIHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xuXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIHByb2dyYW1BdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGlmICggcHJvZ3JhbUF0dHJpYnV0ZSA+PSAwICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsICggc3RhcnRJbmRleCAqIHN0cmlkZSArIG9mZnNldCApICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiBkYXRhLmNvdW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIHN0YXJ0SW5kZXggKiBzaXplICogNCApOyAvLyA0IGJ5dGVzIHBlciBGbG9hdDMyXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5zZXR1cFZlcnRleEF0dHJpYnV0ZXM6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKiBnZW9tZXRyeUF0dHJpYnV0ZS5jb3VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBuYW1lIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICB9XG5cbiAgICAvLyBTb3J0aW5nXG5cbiAgICBmdW5jdGlvbiBudW1lcmljYWxTb3J0KCBhLCBiICkge1xuXG4gICAgICAgIHJldHVybiBiWyAwIF0gLSBhWyAwIF07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuICAgICAgICBpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gYS56IC0gYi56O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cbiAgICAgICAgaWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGIueiAtIGEuejtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gUmVuZGVyaW5nXG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XG5cbiAgICAgICAgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvZyA9IHNjZW5lLmZvZztcblxuICAgICAgICAvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXG5cbiAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcbiAgICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XG4gICAgICAgIF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcbiAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG4gICAgICAgIGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG4gICAgICAgIGlmICggY2FtZXJhLnBhcmVudCA9PT0gbnVsbCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAgIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICAgICAgX2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgICAgICBsaWdodHMubGVuZ3RoID0gMDtcblxuICAgICAgICBvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLTE7XG4gICAgICAgIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuXG4gICAgICAgIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXggPSAtMTtcbiAgICAgICAgdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4ID0gLTE7XG5cbiAgICAgICAgc3ByaXRlcy5sZW5ndGggPSAwO1xuICAgICAgICBsZW5zRmxhcmVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcHJvamVjdE9iamVjdCggc2NlbmUgKTtcblxuICAgICAgICBvcGFxdWVPYmplY3RzLmxlbmd0aCA9IG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggKyAxO1xuICAgICAgICB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID0gdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ICsgMTtcblxuICAgICAgICBvcGFxdWVJbW1lZGlhdGVPYmplY3RzLmxlbmd0aCA9IG9wYXF1ZUltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXggKyAxO1xuICAgICAgICB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHMubGVuZ3RoID0gdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4ICsgMTtcblxuICAgICAgICBpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBvcGFxdWVPYmplY3RzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XG4gICAgICAgICAgICB0cmFuc3BhcmVudE9iamVjdHMuc29ydCggcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgc2hhZG93TWFwLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgX2luZm9SZW5kZXIuY2FsbHMgPSAwO1xuICAgICAgICBfaW5mb1JlbmRlci52ZXJ0aWNlcyA9IDA7XG4gICAgICAgIF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcbiAgICAgICAgX2luZm9SZW5kZXIucG9pbnRzID0gMDtcblxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgaWYgKCB0aGlzLmF1dG9DbGVhciB8fCBmb3JjZUNsZWFyICkge1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCB0aGlzLmF1dG9DbGVhckNvbG9yLCB0aGlzLmF1dG9DbGVhckRlcHRoLCB0aGlzLmF1dG9DbGVhclN0ZW5jaWwgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cblxuICAgICAgICBpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgIHZhciBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgICAgICAgICAgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuICAgICAgICAgICAgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcbiAgICAgICAgICAgIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxuXG4gICAgICAgICAgICBzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG4gICAgICAgICAgICByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG4gICAgICAgICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBvcGFxdWVJbW1lZGlhdGVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG5cbiAgICAgICAgICAgIC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXG5cbiAgICAgICAgICAgIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZyApO1xuICAgICAgICAgICAgcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxuXG4gICAgICAgIHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcbiAgICAgICAgbGVuc0ZsYXJlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSwgX2N1cnJlbnRXaWR0aCwgX2N1cnJlbnRIZWlnaHQgKTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgcmVuZGVyVGFyZ2V0Lm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXG5cbiAgICAgICAgc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG4gICAgICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIHRydWUgKTtcbiAgICAgICAgc3RhdGUuc2V0Q29sb3JXcml0ZSggdHJ1ZSApO1xuXG4gICAgICAgIC8vIF9nbC5maW5pc2goKTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwdXNoSW1tZWRpYXRlUmVuZGVySXRlbSggb2JqZWN0ICkge1xuXG4gICAgICAgIHZhciBhcnJheSwgaW5kZXg7XG5cbiAgICAgICAgLy8gYWxsb2NhdGUgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGFwcHJvcHJpYXRlIGFycmF5XG5cbiAgICAgICAgaWYgKCBvYmplY3QubWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cbiAgICAgICAgICAgIGFycmF5ID0gdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzO1xuICAgICAgICAgICAgaW5kZXggPSArK3RyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBhcnJheSA9IG9wYXF1ZUltbWVkaWF0ZU9iamVjdHM7XG4gICAgICAgICAgICBpbmRleCA9ICsrb3BhcXVlSW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleDtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjeWNsZSBleGlzdGluZyBwb3NpdGlvbiBvciBncm93IHRoZSBhcnJheVxuXG4gICAgICAgIGlmICggaW5kZXggPCBhcnJheS5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGFycmF5WyBpbmRleCBdID0gb2JqZWN0O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGFzc2VydCggaW5kZXggPT09IGFycmF5Lmxlbmd0aCApO1xuICAgICAgICAgICAgYXJyYXkucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHosIGdyb3VwICkge1xuXG4gICAgICAgIHZhciBhcnJheSwgaW5kZXg7XG5cbiAgICAgICAgLy8gYWxsb2NhdGUgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGFwcHJvcHJpYXRlIGFycmF5XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuICAgICAgICAgICAgYXJyYXkgPSB0cmFuc3BhcmVudE9iamVjdHM7XG4gICAgICAgICAgICBpbmRleCA9ICsrdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGFycmF5ID0gb3BhcXVlT2JqZWN0cztcbiAgICAgICAgICAgIGluZGV4ID0gKytvcGFxdWVPYmplY3RzTGFzdEluZGV4O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN5Y2xlIGV4aXN0aW5nIHJlbmRlciBpdGVtIG9yIGdyb3cgdGhlIGFycmF5XG5cbiAgICAgICAgdmFyIHJlbmRlckl0ZW0gPSBhcnJheVsgaW5kZXggXTtcblxuICAgICAgICBpZiAoIHJlbmRlckl0ZW0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcbiAgICAgICAgICAgIHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgcmVuZGVySXRlbS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgICAgcmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICAgICAgcmVuZGVySXRlbS56ID0gX3ZlY3RvcjMuejtcbiAgICAgICAgICAgIHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICByZW5kZXJJdGVtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBvYmplY3QuaWQsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbCxcbiAgICAgICAgICAgICAgICB6OiBfdmVjdG9yMy56LFxuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gYXNzZXJ0KCBpbmRleCA9PT0gYXJyYXkubGVuZ3RoICk7XG4gICAgICAgICAgICBhcnJheS5wdXNoKCByZW5kZXJJdGVtICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0ICkge1xuXG4gICAgICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGlnaHQgKSB7XG5cbiAgICAgICAgICAgIGxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XG5cbiAgICAgICAgICAgIHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGVuc0ZsYXJlICkge1xuXG4gICAgICAgICAgICBsZW5zRmxhcmVzLnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcblxuICAgICAgICAgICAgcHVzaEltbWVkaWF0ZVJlbmRlckl0ZW0oIG9iamVjdCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgICAgICAgICAgICBvYmplY3Quc2tlbGV0b24udXBkYXRlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxzWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgX3ZlY3RvcjMueiApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XG5cbiAgICAgICAgICAgIHZhciBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XG5cbiAgICAgICAgICAgIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICBvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xuXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcblxuICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XG5cbiAgICAgICAgICAgIGlmICggb3ZlcnJpZGVNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuICAgICAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblxuICAgICAgICAgICAgb2JqZWN0LnJlbmRlciggZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApO1xuXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcblxuICAgICAgICB2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKTtcbiAgICAgICAgdmFyIGNvZGUgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNvZGUoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XG5cbiAgICAgICAgdmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbTtcbiAgICAgICAgdmFyIHByb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAvLyBuZXcgbWF0ZXJpYWxcbiAgICAgICAgICAgIG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XG5cbiAgICAgICAgICAgIC8vIGNoYW5nZWQgZ2xzbCBvciBwYXJhbWV0ZXJzXG4gICAgICAgICAgICByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgLy8gc2FtZSBnbHNsIGFuZCB1bmlmb3JtIGxpc3RcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBvbmx5IHJlYnVpbGQgdW5pZm9ybSBsaXN0XG4gICAgICAgICAgICBwcm9ncmFtQ2hhbmdlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJvZ3JhbUNoYW5nZSApIHtcblxuICAgICAgICAgICAgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xuXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG1hdGVyaWFsLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbWF0ZXJpYWwudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXI7XG5cbiAgICAgICAgICAgIHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICk7XG5cbiAgICAgICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgICAgIG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xuXG4gICAgICAgICAgICBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaFRhcmdldHM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cysrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG4gICAgICAgICAgICBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzKys7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IFtdO1xuXG4gICAgICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblxuICAgICAgICBmb3IgKCB2YXIgdSBpbiBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcyApIHtcblxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gdW5pZm9ybUxvY2F0aW9uc1sgdSBdO1xuXG4gICAgICAgICAgICBpZiAoIGxvY2F0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdC5wdXNoKCBbIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zWyB1IF0sIGxvY2F0aW9uIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuICAgICAgICBzZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5zZXREZXB0aEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xuICAgICAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuICAgICAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG4gICAgICAgIHN0YXRlLnNldENvbG9yV3JpdGUoIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcbiAgICAgICAgc3RhdGUuc2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApIHtcblxuICAgICAgICBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlID8gc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICkgOiBzdGF0ZS5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG4gICAgICAgIHN0YXRlLnNldEZsaXBTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XG5cbiAgICAgICAgX3VzZWRUZXh0dXJlVW5pdHMgPSAwO1xuXG4gICAgICAgIHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlIHx8ICFtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSApIHtcblxuICAgICAgICAgICAgaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xuICAgICAgICAgICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG4gICAgICAgIHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlZnJlc2hMaWdodHMgPSBmYWxzZTtcblxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLFxuICAgICAgICAgICAgcF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcbiAgICAgICAgICAgIG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcztcblxuICAgICAgICBpZiAoIHByb2dyYW0uaWQgIT09IF9jdXJyZW50UHJvZ3JhbSApIHtcblxuICAgICAgICAgICAgX2dsLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApO1xuICAgICAgICAgICAgX2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbS5pZDtcblxuICAgICAgICAgICAgcmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuICAgICAgICAgICAgcmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XG5cbiAgICAgICAgICAgIGlmICggX2N1cnJlbnRNYXRlcmlhbElkID09PSAtMSApIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuICAgICAgICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XG5cbiAgICAgICAgICAgIHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgICAgICAgIGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBwX3VuaWZvcm1zLmxvZ0RlcHRoQnVmRkMsIDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmICggY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIF9jdXJyZW50Q2FtZXJhID0gY2FtZXJhO1xuXG4gICAgICAgICAgICAvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG4gICAgICAgICAgICAvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuZW52TWFwICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZiggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiwgX3ZlY3RvcjMueCwgX3ZlY3RvcjMueSwgX3ZlY3RvcjMueiApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgIC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xuICAgICAgICAvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0LmJpbmRNYXRyaXggJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4LCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZSAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCwgb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlV2lkdGggKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZUhlaWdodCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZUhlaWdodCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZUdsb2JhbE1hdHJpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYm9uZUdsb2JhbE1hdHJpY2VzLCBmYWxzZSwgb2JqZWN0LnNrZWxldG9uLmJvbmVNYXRyaWNlcyApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG4gICAgICAgICAgICBpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmxpZ2h0cyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggX2xpZ2h0c05lZWRVcGRhdGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwTGlnaHRzKCBsaWdodHMsIGNhbWVyYSApO1xuICAgICAgICAgICAgICAgICAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCByZWZyZXNoTGlnaHRzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyggbV91bmlmb3JtcywgX2xpZ2h0cyApO1xuICAgICAgICAgICAgICAgICAgICBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgdHJ1ZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCBmYWxzZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVmcmVzaCBzaW5nbGUgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNEYXNoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHNNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc1BhcnRpY2xlKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc1Bob25nKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgIG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgICAgICAgICAgICBtX3VuaWZvcm1zLm1GYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xuICAgICAgICAgICAgICAgIG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgIG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiAhbWF0ZXJpYWwuX3NoYWRvd1Bhc3MgKSB7XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNTaGFkb3coIG1fdW5pZm9ybXMsIGxpZ2h0cyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXG5cbiAgICAgICAgICAgIGxvYWRVbmlmb3Jtc0dlbmVyaWMoIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgbG9hZFVuaWZvcm1zTWF0cmljZXMoIHBfdW5pZm9ybXMsIG9iamVjdCApO1xuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcblxuICAgIH1cblxuICAgIC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgICAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgICAgICB1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICB1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuICAgICAgICB1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuYW9NYXAgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XG4gICAgICAgICAgICB1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcbiAgICAgICAgLy8gMS4gY29sb3IgbWFwXG4gICAgICAgIC8vIDIuIHNwZWN1bGFyIG1hcFxuICAgICAgICAvLyAzLiBub3JtYWwgbWFwXG4gICAgICAgIC8vIDQuIGJ1bXAgbWFwXG4gICAgICAgIC8vIDUuIGFscGhhIG1hcFxuICAgICAgICAvLyA2LiBlbWlzc2l2ZSBtYXBcblxuICAgICAgICB2YXIgdXZTY2FsZU1hcDtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcblxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XG5cbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHV2U2NhbGVNYXAub2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHV2U2NhbGVNYXAucmVwZWF0O1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XG4gICAgICAgIHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIG1hdGVyaWFsLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApID8gMSA6IC0xO1xuXG4gICAgICAgIHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcbiAgICAgICAgdW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcbiAgICAgICAgdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcbiAgICAgICAgdW5pZm9ybXMudG90YWxTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemUgKyBtYXRlcmlhbC5nYXBTaXplO1xuICAgICAgICB1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgICAgICB1bmlmb3Jtcy5wc0NvbG9yLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG4gICAgICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuICAgICAgICB1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcbiAgICAgICAgdW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfY2FudmFzLmhlaWdodCAvIDIuMDsgLy8gVE9ETzogQ2FjaGUgdGhpcy5cblxuICAgICAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IG1hdGVyaWFsLm1hcC5yZXBlYXQ7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRm9nKCB1bmlmb3JtcywgZm9nICkge1xuXG4gICAgICAgIHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xuXG4gICAgICAgIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XG4gICAgICAgICAgICB1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XG4gICAgICAgIHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IG1hdGVyaWFsLnNoaW5pbmVzcztcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuICAgICAgICAgICAgdW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcbiAgICAgICAgICAgIHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcbiAgICAgICAgICAgIHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG4gICAgICAgICAgICB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgdW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGlnaHRzKCB1bmlmb3JtcywgbGlnaHRzICkge1xuXG4gICAgICAgIHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmFtYmllbnQ7XG5cbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycztcbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnM7XG5cbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnBvaW50LmNvbG9ycztcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnBvaW50LmRpc3RhbmNlcztcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodERlY2F5LnZhbHVlID0gbGlnaHRzLnBvaW50LmRlY2F5cztcblxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zcG90LmNvbG9ycztcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0UG9zaXRpb24udmFsdWUgPSBsaWdodHMuc3BvdC5wb3NpdGlvbnM7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlzdGFuY2VzO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuc3BvdC5kaXJlY3Rpb25zO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy52YWx1ZSA9IGxpZ2h0cy5zcG90LmFuZ2xlc0NvcztcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQudmFsdWUgPSBsaWdodHMuc3BvdC5leHBvbmVudHM7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERlY2F5LnZhbHVlID0gbGlnaHRzLnNwb3QuZGVjYXlzO1xuXG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuc2t5Q29sb3JzO1xuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycztcbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmhlbWkucG9zaXRpb25zO1xuXG4gICAgfVxuXG4gICAgLy8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxuXG4gICAgZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIHVuaWZvcm1zLCB2YWx1ZSApIHtcblxuICAgICAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0UG9zaXRpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodEFuZ2xlQ29zLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3coIHVuaWZvcm1zLCBsaWdodHMgKSB7XG5cbiAgICAgICAgaWYgKCB1bmlmb3Jtcy5zaGFkb3dNYXRyaXggKSB7XG5cbiAgICAgICAgICAgIHZhciBqID0gMDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoICFsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8ICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWFwLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXA7XG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hcFNpemUudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hcFNpemU7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWF0cml4LnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXRyaXg7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93RGFya25lc3MudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dCaWFzLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dCaWFzO1xuXG4gICAgICAgICAgICAgICAgICAgIGorKztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcblxuICAgIGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc01hdHJpY2VzKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xuXG4gICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBvYmplY3QubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgICAgaWYgKCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXggKSB7XG5cbiAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXgsIGZhbHNlLCBvYmplY3Qubm9ybWFsTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dHVyZVVuaXQoKSB7XG5cbiAgICAgICAgdmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlVW5pdCA+PSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfdXNlZFRleHR1cmVVbml0cyArPSAxO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlVW5pdDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc0dlbmVyaWMoIHVuaWZvcm1zICkge1xuXG4gICAgICAgIHZhciB0ZXh0dXJlLCB0ZXh0dXJlVW5pdDtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gdW5pZm9ybXMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XG5cbiAgICAgICAgICAgIC8vIG5lZWRzVXBkYXRlIHByb3BlcnR5IGlzIG5vdCBhZGRlZCB0byBhbGwgdW5pZm9ybXMuXG4gICAgICAgICAgICBpZiAoIHVuaWZvcm0ubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gdW5pZm9ybS50eXBlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHVuaWZvcm1zWyBqIF1bIDEgXTtcblxuICAgICAgICAgICAgc3dpdGNoICggdHlwZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJzFpJzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnMWYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICcyZic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnM2YnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzRmJzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0sIHZhbHVlWyAzIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICcxaXYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnM2l2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzFmdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICcyZnYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnM2Z2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzRmdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdNYXRyaXgzZnYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ01hdHJpeDRmdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICBjYXNlICdpJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBmbG9hdFxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3YyJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yMlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndjMnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IzXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd2NCc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjRcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5Db2xvclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaXYxJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaXYnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZnYxJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2Z2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd2MnYnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMiAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGkyID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSsrLCBpMiArPSAyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTIgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTIgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3Yzdic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yM1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAzICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaTMgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpKyssIGkzICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMyArIDAgXSA9IHZhbHVlWyBpIF0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMyArIDEgXSA9IHZhbHVlWyBpIF0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMyArIDIgXSA9IHZhbHVlWyBpIF0uejtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndjR2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3I0XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDQgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpNCA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkrKywgaTQgKz0gNCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGk0ICsgMCBdID0gdmFsdWVbIGkgXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGk0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGk0ICsgMiBdID0gdmFsdWVbIGkgXS56O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGk0ICsgMyBdID0gdmFsdWVbIGkgXS53O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtMyc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLk1hdHJpeDNcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ20zdic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuTWF0cml4M1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA5ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDkgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ200JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuTWF0cml4NFxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbTR2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXg0XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDE2ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICF0ZXh0dXJlICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICggQXJyYXkuaXNBcnJheSggdGV4dHVyZS5pbWFnZSApICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3R2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5UZXh0dXJlICgyZClcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpIF0gPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVVbml0ID0gdW5pZm9ybS5fYXJyYXlbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhdGV4dHVyZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5rbm93biB1bmlmb3JtIHR5cGU6ICcgKyB0eXBlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDb2xvckxpbmVhciggYXJyYXksIG9mZnNldCwgY29sb3IsIGludGVuc2l0eSApIHtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMCBdID0gY29sb3IuciAqIGludGVuc2l0eTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogaW50ZW5zaXR5O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBMaWdodHMoIGxpZ2h0cywgY2FtZXJhICkge1xuXG4gICAgICAgIHZhciBsLCBsbCwgbGlnaHQsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIGcgPSAwLFxuICAgICAgICAgICAgYiA9IDAsXG4gICAgICAgICAgICBjb2xvciwgc2t5Q29sb3IsIGdyb3VuZENvbG9yLFxuICAgICAgICAgICAgaW50ZW5zaXR5LFxuICAgICAgICAgICAgZGlzdGFuY2UsXG5cbiAgICAgICAgICAgIHpsaWdodHMgPSBfbGlnaHRzLFxuXG4gICAgICAgICAgICB2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSxcblxuICAgICAgICAgICAgZGlyQ29sb3JzID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnMsXG4gICAgICAgICAgICBkaXJQb3NpdGlvbnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucyxcblxuICAgICAgICAgICAgcG9pbnRDb2xvcnMgPSB6bGlnaHRzLnBvaW50LmNvbG9ycyxcbiAgICAgICAgICAgIHBvaW50UG9zaXRpb25zID0gemxpZ2h0cy5wb2ludC5wb3NpdGlvbnMsXG4gICAgICAgICAgICBwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxuICAgICAgICAgICAgcG9pbnREZWNheXMgPSB6bGlnaHRzLnBvaW50LmRlY2F5cyxcblxuICAgICAgICAgICAgc3BvdENvbG9ycyA9IHpsaWdodHMuc3BvdC5jb2xvcnMsXG4gICAgICAgICAgICBzcG90UG9zaXRpb25zID0gemxpZ2h0cy5zcG90LnBvc2l0aW9ucyxcbiAgICAgICAgICAgIHNwb3REaXN0YW5jZXMgPSB6bGlnaHRzLnNwb3QuZGlzdGFuY2VzLFxuICAgICAgICAgICAgc3BvdERpcmVjdGlvbnMgPSB6bGlnaHRzLnNwb3QuZGlyZWN0aW9ucyxcbiAgICAgICAgICAgIHNwb3RBbmdsZXNDb3MgPSB6bGlnaHRzLnNwb3QuYW5nbGVzQ29zLFxuICAgICAgICAgICAgc3BvdEV4cG9uZW50cyA9IHpsaWdodHMuc3BvdC5leHBvbmVudHMsXG4gICAgICAgICAgICBzcG90RGVjYXlzID0gemxpZ2h0cy5zcG90LmRlY2F5cyxcblxuICAgICAgICAgICAgaGVtaVNreUNvbG9ycyA9IHpsaWdodHMuaGVtaS5za3lDb2xvcnMsXG4gICAgICAgICAgICBoZW1pR3JvdW5kQ29sb3JzID0gemxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycyxcbiAgICAgICAgICAgIGhlbWlQb3NpdGlvbnMgPSB6bGlnaHRzLmhlbWkucG9zaXRpb25zLFxuXG4gICAgICAgICAgICBkaXJMZW5ndGggPSAwLFxuICAgICAgICAgICAgcG9pbnRMZW5ndGggPSAwLFxuICAgICAgICAgICAgc3BvdExlbmd0aCA9IDAsXG4gICAgICAgICAgICBoZW1pTGVuZ3RoID0gMCxcblxuICAgICAgICAgICAgZGlyQ291bnQgPSAwLFxuICAgICAgICAgICAgcG9pbnRDb3VudCA9IDAsXG4gICAgICAgICAgICBzcG90Q291bnQgPSAwLFxuICAgICAgICAgICAgaGVtaUNvdW50ID0gMCxcblxuICAgICAgICAgICAgZGlyT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHBvaW50T2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHNwb3RPZmZzZXQgPSAwLFxuICAgICAgICAgICAgaGVtaU9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsKysgKSB7XG5cbiAgICAgICAgICAgIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cbiAgICAgICAgICAgIGlmICggbGlnaHQub25seVNoYWRvdyApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xvciA9IGxpZ2h0LmNvbG9yO1xuICAgICAgICAgICAgaW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggIWxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHIgKz0gY29sb3IucjtcbiAgICAgICAgICAgICAgICBnICs9IGNvbG9yLmc7XG4gICAgICAgICAgICAgICAgYiArPSBjb2xvci5iO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgZGlyQ291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmICggIWxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuICAgICAgICAgICAgICAgIGRpck9mZnNldCA9IGRpckxlbmd0aCAqIDM7XG5cbiAgICAgICAgICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcbiAgICAgICAgICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcbiAgICAgICAgICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgICAgICAgICAgZGlyTGVuZ3RoICs9IDE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICBwb2ludENvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBwb2ludE9mZnNldCA9IHBvaW50TGVuZ3RoICogMztcblxuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBwb2ludENvbG9ycywgcG9pbnRPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICBfdmVjdG9yMy5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuICAgICAgICAgICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDAgXSA9IF92ZWN0b3IzLng7XG4gICAgICAgICAgICAgICAgcG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMSBdID0gX3ZlY3RvcjMueTtcbiAgICAgICAgICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAyIF0gPSBfdmVjdG9yMy56O1xuXG4gICAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgaXMgMCBpZiBkZWNheSBpcyAwLCBiZWNhdXNlIHRoZXJlIGlzIG5vIGF0dGVudWF0aW9uIGF0IGFsbC5cbiAgICAgICAgICAgICAgICBwb2ludERpc3RhbmNlc1sgcG9pbnRMZW5ndGggXSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHBvaW50RGVjYXlzWyBwb2ludExlbmd0aCBdID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cbiAgICAgICAgICAgICAgICBwb2ludExlbmd0aCArPSAxO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICBzcG90Q291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmICggIWxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHNwb3RPZmZzZXQgPSBzcG90TGVuZ3RoICogMztcblxuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBzcG90Q29sb3JzLCBzcG90T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICBfdmVjdG9yMy5jb3B5KCBfZGlyZWN0aW9uICkuYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX3ZlY3RvcjMueDtcbiAgICAgICAgICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX3ZlY3RvcjMueTtcbiAgICAgICAgICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcblxuICAgICAgICAgICAgICAgIHNwb3REaXN0YW5jZXNbIHNwb3RMZW5ndGggXSA9IGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XG4gICAgICAgICAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgICAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgICAgICAgICBzcG90QW5nbGVzQ29zWyBzcG90TGVuZ3RoIF0gPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcbiAgICAgICAgICAgICAgICBzcG90RXhwb25lbnRzWyBzcG90TGVuZ3RoIF0gPSBsaWdodC5leHBvbmVudDtcbiAgICAgICAgICAgICAgICBzcG90RGVjYXlzWyBzcG90TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuICAgICAgICAgICAgICAgIHNwb3RMZW5ndGggKz0gMTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgaGVtaUNvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgaGVtaU9mZnNldCA9IGhlbWlMZW5ndGggKiAzO1xuXG4gICAgICAgICAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcbiAgICAgICAgICAgICAgICBoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuICAgICAgICAgICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgICAgICAgICBza3lDb2xvciA9IGxpZ2h0LmNvbG9yO1xuICAgICAgICAgICAgICAgIGdyb3VuZENvbG9yID0gbGlnaHQuZ3JvdW5kQ29sb3I7XG5cbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eSApO1xuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICAgICAgICBoZW1pTGVuZ3RoICs9IDE7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbnVsbCBldmVudHVhbCByZW1haW5zIGZyb20gcmVtb3ZlZCBsaWdodHNcbiAgICAgICAgLy8gKHRoaXMgaXMgdG8gYXZvaWQgaWYgaW4gc2hhZGVyKVxuXG4gICAgICAgIGZvciAoIGwgPSBkaXJMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBkaXJDb2xvcnMubGVuZ3RoLCBkaXJDb3VudCAqIDMgKTsgbCA8IGxsOyBsKysgKSBkaXJDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICAgICAgZm9yICggbCA9IHBvaW50TGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggcG9pbnRDb2xvcnMubGVuZ3RoLCBwb2ludENvdW50ICogMyApOyBsIDwgbGw7IGwrKyApIHBvaW50Q29sb3JzWyBsIF0gPSAwLjA7XG4gICAgICAgIGZvciAoIGwgPSBzcG90TGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggc3BvdENvbG9ycy5sZW5ndGgsIHNwb3RDb3VudCAqIDMgKTsgbCA8IGxsOyBsKysgKSBzcG90Q29sb3JzWyBsIF0gPSAwLjA7XG4gICAgICAgIGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaVNreUNvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsKysgKSBoZW1pU2t5Q29sb3JzWyBsIF0gPSAwLjA7XG4gICAgICAgIGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaUdyb3VuZENvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsKysgKSBoZW1pR3JvdW5kQ29sb3JzWyBsIF0gPSAwLjA7XG5cbiAgICAgICAgemxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJMZW5ndGg7XG4gICAgICAgIHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG4gICAgICAgIHpsaWdodHMuc3BvdC5sZW5ndGggPSBzcG90TGVuZ3RoO1xuICAgICAgICB6bGlnaHRzLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcblxuICAgICAgICB6bGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XG4gICAgICAgIHpsaWdodHMuYW1iaWVudFsgMSBdID0gZztcbiAgICAgICAgemxpZ2h0cy5hbWJpZW50WyAyIF0gPSBiO1xuXG4gICAgfVxuXG4gICAgLy8gR0wgc3RhdGUgc2V0dGluZ1xuXG4gICAgdGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uKCBjdWxsRmFjZSwgZnJvbnRGYWNlRGlyZWN0aW9uICkge1xuXG4gICAgICAgIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlTm9uZSApIHtcblxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICggZnJvbnRGYWNlRGlyZWN0aW9uID09PSBUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DVyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUJhY2sgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gVGV4dHVyZXNcblxuICAgIGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgdmFyIGV4dGVuc2lvbjtcblxuICAgICAgICBpZiAoIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBUICkgKTtcblxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XG5cbiAgICAgICAgICAgIGlmICggdGV4dHVyZS53cmFwUyAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4gKCAnICsgdGV4dHVyZS5zb3VyY2VGaWxlICsgJyApJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLiAoICcgKyB0ZXh0dXJlLnNvdXJjZUZpbGUgKyAnICknICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gKSB7XG5cbiAgICAgICAgICAgIGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5GbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIHRleHR1cmUudHlwZSA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApID09PSBudWxsICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIF90aGlzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRleHR1cmUuX193ZWJnbEluaXQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzKys7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblxuICAgICAgICB0ZXh0dXJlLmltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xuXG4gICAgICAgIHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2UsXG4gICAgICAgICAgICBpc0ltYWdlUG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcbiAgICAgICAgICAgIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG4gICAgICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XG5cbiAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xuXG4gICAgICAgIHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcbiAgICAgICAgICAgIC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG4gICAgICAgICAgICBpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcblxuICAgICAgICAgICAgLy8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuICAgICAgICAgICAgLy8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cbiAgICAgICAgICAgIGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5pbWFnZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cbiAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXG4gICAgICAgIGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuICAgIH1cblxuICAgIHRoaXMuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG4gICAgICAgICAgICBpZiAoIGltYWdlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWQnLCB0ZXh0dXJlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScsIHRleHR1cmUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xhbXBUb01heFNpemUoIGltYWdlLCBtYXhTaXplICkge1xuXG4gICAgICAgIGlmICggaW1hZ2Uud2lkdGggPiBtYXhTaXplIHx8IGltYWdlLmhlaWdodCA+IG1heFNpemUgKSB7XG5cbiAgICAgICAgICAgIC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXG4gICAgICAgICAgICAvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxuXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIHNjYWxlICk7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaW1hZ2UuaGVpZ2h0ICogc2NhbGUgKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQsIGltYWdlICk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbWFnZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcblxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzKys7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICAgICAgICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNDb21wcmVzc2VkID0gdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xuICAgICAgICAgICAgICAgIHZhciBpc0RhdGFUZXh0dXJlID0gdGV4dHVyZS5pbWFnZVsgMCBdIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3ViZUltYWdlID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfdGhpcy5hdXRvU2NhbGVDdWJlbWFwcyAmJiAhaXNDb21wcmVzc2VkICYmICFpc0RhdGFUZXh0dXJlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgaXNJbWFnZVBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXG4gICAgICAgICAgICAgICAgICAgIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG4gICAgICAgICAgICAgICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuICAgICAgICAgICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0NvbXByZXNzZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNEYXRhVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgY3ViZUltYWdlWyBpIF0ud2lkdGgsIGN1YmVJbWFnZVsgaSBdLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0uZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gbWlwbWFwcy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0xICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRDdWJlVGV4dHVyZSgpXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIH1cblxuICAgIC8vIFJlbmRlciB0YXJnZXRzXG5cbiAgICBmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlVGFyZ2V0ICkge1xuXG4gICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcbiAgICAgICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xUZXh0dXJlLCAwICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlciggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICAgICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICFyZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgICAgICAvKiBGb3Igc29tZSByZWFzb24gdGhpcyBpcyBub3Qgd29ya2luZy4gRGVmYXVsdGluZyB0byBSR0JBNC5cblx0XHR9IGVsc2UgaWYgKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5TVEVOQ0lMX0lOREVYOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLlNURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cdFx0Ki9cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5SR0JBNCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0ICYmIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICByZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcblxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzKys7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIHRleHR1cmUsIGNyZWF0ZSByZW5kZXIgYW5kIGZyYW1lIGJ1ZmZlcnNcblxuICAgICAgICAgICAgdmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LmhlaWdodCApLFxuICAgICAgICAgICAgICAgIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC5mb3JtYXQgKSxcbiAgICAgICAgICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnR5cGUgKTtcblxuICAgICAgICAgICAgaWYgKCBpc0N1YmUgKSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgICAgICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbS5fX3dlYmdsUmVuZGVyYnVmZmVyO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuICAgICAgICAgICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cbiAgICAgICAgICAgICAgICBzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgIXJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVsZWFzZSBldmVyeXRoaW5nXG5cbiAgICAgICAgICAgIGlmICggaXNDdWJlICkge1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcbiAgICAgICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJhbWVidWZmZXIsIHdpZHRoLCBoZWlnaHQsIHZ4LCB2eTtcblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgICAgICAgdmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIGlmICggaXNDdWJlICkge1xuXG4gICAgICAgICAgICAgICAgZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZ4ID0gMDtcbiAgICAgICAgICAgIHZ5ID0gMDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cbiAgICAgICAgICAgIHdpZHRoID0gX3ZpZXdwb3J0V2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBfdmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZ4ID0gX3ZpZXdwb3J0WDtcbiAgICAgICAgICAgIHZ5ID0gX3ZpZXdwb3J0WTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcblxuICAgICAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuICAgICAgICAgICAgX2dsLnZpZXdwb3J0KCB2eCwgdnksIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgICAgICAgICAgX2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfY3VycmVudFdpZHRoID0gd2lkdGg7XG4gICAgICAgIF9jdXJyZW50SGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgfTtcblxuICAgIHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciApIHtcblxuICAgICAgICBpZiAoICEoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgKSB7XG5cbiAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBmb3JtYXQuIHJlYWRQaXhlbHMgY2FuIHJlYWQgb25seSBSR0JBIGZvcm1hdC4nICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN0b3JlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICggcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuXG4gICAgICAgICAgICAgICAgcmVzdG9yZSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZ2wuUkdCQSwgX2dsLlVOU0lHTkVEX0JZVEUsIGJ1ZmZlciApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggcmVzdG9yZSApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2N1cnJlbnRGcmFtZWJ1ZmZlciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG4gICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsVGV4dHVyZSApO1xuICAgICAgICAgICAgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbFRleHR1cmUgKTtcbiAgICAgICAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcbiAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayggZiApIHtcblxuICAgICAgICBpZiAoIGYgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcblxuICAgICAgICAgICAgcmV0dXJuIF9nbC5ORUFSRVNUO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2dsLkxJTkVBUjtcblxuICAgIH1cblxuICAgIC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCggcCApIHtcblxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLlJFUEVBVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1Q7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVI7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9CWVRFO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuQnl0ZVR5cGUgKSByZXR1cm4gX2dsLkJZVEU7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuSW50VHlwZSApIHJldHVybiBfZ2wuSU5UO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkZsb2F0VHlwZSApIHJldHVybiBfZ2wuRkxPQVQ7XG5cbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgKSByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5BTFBIQTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5BZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuWmVyb0ZhY3RvciApIHJldHVybiBfZ2wuWkVSTztcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5TcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuU1JDX0NPTE9SO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQ09MT1I7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkRzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQUxQSEE7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkRzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEFfU0FUVVJBVEU7XG5cbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcblxuICAgIH1cblxuICAgIC8vIERFUFJFQ0FURURcblxuICAgIHRoaXMuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyApO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRcXCcgKS4nICk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnICkuJyApO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyApO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcXCcgKS4nICk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRzQmxlbmRNaW5NYXggPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0VYVF9ibGVuZF9taW5tYXhcXCcgKS4nICk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcblxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xcJyApLicgKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgIH07XG5cbiAgICAvL1xuXG4gICAgdGhpcy5pbml0TWF0ZXJpYWwgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5hZGRQcmVQbHVnaW4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5hZGRQb3N0UGx1Z2luID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVNoYWRvd01hcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuICAgICAgICBzaGFkb3dNYXBFbmFibGVkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5lbmFibGVkO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLicgKTtcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAuZW5hYmxlZCA9IHZhbHVlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNoYWRvd01hcFR5cGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLnR5cGU7XG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBUeXBlIGlzIG5vdyAuc2hhZG93TWFwLnR5cGUuJyApO1xuICAgICAgICAgICAgICAgIHNoYWRvd01hcC50eXBlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93TWFwQ3VsbEZhY2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLmN1bGxGYWNlO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaXMgbm93IC5zaGFkb3dNYXAuY3VsbEZhY2UuJyApO1xuICAgICAgICAgICAgICAgIHNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNoYWRvd01hcERlYnVnOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5kZWJ1ZztcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcERlYnVnIGlzIG5vdyAuc2hhZG93TWFwLmRlYnVnLicgKTtcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAuZGVidWcgPSB2YWx1ZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXQuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLndyYXBTID0gb3B0aW9ucy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgdGhpcy53cmFwVCA9IG9wdGlvbnMud3JhcFQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBvcHRpb25zLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgICB0aGlzLmFuaXNvdHJvcHkgPSBvcHRpb25zLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5pc290cm9weSA6IDE7XG5cbiAgICB0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XG4gICAgdGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50eXBlIDogVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcblxuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcbiAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XG5cbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG5cbiAgICB0aGlzLnNoYXJlRGVwdGhGcm9tID0gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSA6IG51bGw7XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCxcblxuICAgIHNldFNpemU6IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgICAgIGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCApIHtcblxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMud3JhcFMgPSBzb3VyY2Uud3JhcFM7XG4gICAgICAgIHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cbiAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xuICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG5cbiAgICAgICAgdGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cbiAgICAgICAgdGhpcy5vZmZzZXQuY29weSggc291cmNlLm9mZnNldCApO1xuICAgICAgICB0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XG5cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xuICAgICAgICB0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblxuICAgICAgICB0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuICAgICAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcblxuICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG5cbiAgICAgICAgdGhpcy5zaGFyZURlcHRoRnJvbSA9IHNvdXJjZS5zaGFyZURlcHRoRnJvbTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgICB9ICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXRDdWJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxuICovXG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG4gICAgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG4gICAgdGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQnVmZmVyUmVuZGVyZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcblxuICAgIHZhciBtb2RlO1xuXG4gICAgZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cbiAgICAgICAgbW9kZSA9IHZhbHVlO1xuXG4gICAgfVxuXG4gICAgdmFyIHRyYWNlQ291bnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG4gICAgICAgIGlmICggdHJhY2VDb3VudCA9PT0gMCApIHtcbiAgICAgICAgICAgIHRyYWNlQ291bnQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgX2dsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xuXG4gICAgICAgIF9pbmZvUmVuZGVyLmNhbGxzKys7XG4gICAgICAgIF9pbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xuICAgICAgICBpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgaWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICBleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBwb3NpdGlvbi5kYXRhLmNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIHBvc2l0aW9uLmNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG4gICAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XG4gICAgdGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcblxuICAgIHZhciBtb2RlO1xuXG4gICAgZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cbiAgICAgICAgbW9kZSA9IHZhbHVlO1xuXG4gICAgfVxuXG4gICAgdmFyIHR5cGUsIHNpemU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbmRleCggaW5kZXggKSB7XG5cbiAgICAgICAgaWYgKCBpbmRleC5hcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuICAgICAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9JTlQ7XG4gICAgICAgICAgICBzaXplID0gNDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICAgICAgc2l6ZSA9IDI7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cbiAgICAgICAgX2dsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSApO1xuXG4gICAgICAgIF9pbmZvUmVuZGVyLmNhbGxzKys7XG4gICAgICAgIF9pbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xuICAgICAgICBpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXG4gICAgICAgIGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwLCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcbiAgICB0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XG4gICAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XG4gICAgdGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEV4dGVuc2lvbnMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uKCBnbCApIHtcblxuICAgIHZhciBleHRlbnNpb25zID0ge307XG5cbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRlbnNpb247XG5cbiAgICAgICAgc3dpdGNoICggbmFtZSApIHtcblxuICAgICAgICAgICAgY2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBuYW1lICsgJyBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcblxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuXG4gICAgfTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQ2FwYWJpbGl0aWVzLmpzXG5cblRIUkVFLldlYkdMQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24oIGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICkge1xuXG4gICAgZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKSB7XG5cbiAgICAgICAgaWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XG5cbiAgICAgICAgICAgIGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxuICAgICAgICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlnaHAnO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZWNpc2lvbiA9ICdtZWRpdW1wJztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcblxuICAgICAgICAgICAgaWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcbiAgICAgICAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiAnbWVkaXVtcCc7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdsb3dwJztcblxuICAgIH1cblxuICAgIHRoaXMuZ2V0TWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uO1xuXG4gICAgdGhpcy5wcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnLFxuICAgIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyIDogZmFsc2U7XG5cbiAgICB0aGlzLm1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuICAgIHRoaXMubWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuICAgIHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX1NJWkUgKTtcbiAgICB0aGlzLm1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICk7XG5cbiAgICB0aGlzLm1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xuICAgIHRoaXMubWF4VmVydGV4VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XG4gICAgdGhpcy5tYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xuICAgIHRoaXMubWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xuXG4gICAgdGhpcy52ZXJ0ZXhUZXh0dXJlcyA9IHRoaXMubWF4VmVydGV4VGV4dHVyZXMgPiAwO1xuICAgIHRoaXMuZmxvYXRGcmFnbWVudFRleHR1cmVzID0gISFleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuICAgIHRoaXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IHRoaXMudmVydGV4VGV4dHVyZXMgJiYgdGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXM7XG5cbiAgICB2YXIgX21heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbiggdGhpcy5wcmVjaXNpb24gKTtcblxuICAgIGlmICggX21heFByZWNpc2lvbiAhPT0gdGhpcy5wcmVjaXNpb24gKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCB0aGlzLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgX21heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IF9tYXhQcmVjaXNpb247XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuICAgICAgICB0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSAhIWV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEdlb21ldHJpZXMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldlYkdMR2VvbWV0cmllcyA9IGZ1bmN0aW9uKCBnbCwgcHJvcGVydGllcywgaW5mbyApIHtcblxuICAgIHZhciBnZW9tZXRyaWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXQoIG9iamVjdCApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cbiAgICAgICAgdmFyIGJ1ZmZlcmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gPSBidWZmZXJnZW9tZXRyeTtcblxuICAgICAgICBpbmZvLm1lbW9yeS5nZW9tZXRyaWVzKys7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25HZW9tZXRyeURpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgICAgICBkZWxldGVBdHRyaWJ1dGVzKCBidWZmZXJnZW9tZXRyeS5hdHRyaWJ1dGVzICk7XG5cbiAgICAgICAgZ2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG4gICAgICAgIGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xuICAgICAgICBpZiAoIHByb3BlcnR5LndpcmVmcmFtZSApIGRlbGV0ZUF0dHJpYnV0ZSggcHJvcGVydHkud2lyZWZyYW1lICk7XG5cbiAgICAgICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcy0tO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG4gICAgICAgIHZhciBidWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xuXG4gICAgICAgIGlmICggYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlciggYnVmZmVyICk7XG4gICAgICAgICAgICByZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlLmRhdGEgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5nZXQgPSBnZXQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTE9iamVjdHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldlYkdMT2JqZWN0cyA9IGZ1bmN0aW9uKCBnbCwgcHJvcGVydGllcywgaW5mbyApIHtcblxuICAgIHZhciBnZW9tZXRyaWVzID0gbmV3IFRIUkVFLldlYkdMR2VvbWV0cmllcyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKTtcblxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCApIHtcblxuICAgICAgICAvLyBUT0RPOiBBdm9pZCB1cGRhdGluZyB0d2ljZSAod2hlbiB1c2luZyBzaGFkb3dNYXApLiBNYXliZSBhZGQgZnJhbWUgY291bnRlci5cblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldCggb2JqZWN0ICk7XG5cbiAgICAgICAgaWYgKCBvYmplY3QuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgZ2VvbWV0cnkudXBkYXRlRnJvbU9iamVjdCggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3JwaCB0YXJnZXRzXG5cbiAgICAgICAgdmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoIGFycmF5WyBpIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xuXG4gICAgICAgIHZhciBkYXRhID0gKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggZGF0YSApO1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gIT09IGRhdGEudmVyc2lvbiApIHtcblxuICAgICAgICAgICAgdXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xuXG4gICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcblxuICAgICAgICB2YXIgdXNhZ2UgPSBkYXRhLmR5bmFtaWMgPyBnbC5EWU5BTUlDX0RSQVcgOiBnbC5TVEFUSUNfRFJBVztcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgZGF0YS5hcnJheSwgdXNhZ2UgKTtcblxuICAgICAgICBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XG5cbiAgICAgICAgaWYgKCBkYXRhLmR5bmFtaWMgPT09IGZhbHNlIHx8IGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IC0xICkge1xuXG4gICAgICAgICAgICAvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgZGF0YS5hcnJheSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IDAgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAgICAgICAgIGRhdGEuYXJyYXkuc3ViYXJyYXkoIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0LCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCArIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgKSApO1xuXG4gICAgICAgICAgICBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID0gMDsgLy8gcmVzZXQgcmFuZ2VcblxuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgaWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5LndpcmVmcmFtZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGNvbnNvbGUudGltZSggJ3dpcmVmcmFtZScgKTtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGluZGV4LmFycmF5O1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYSA9IGFycmF5WyBpICsgMCBdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gYXJyYXlbIGkgKyAxIF07XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBhcnJheVsgaSArIDIgXTtcblxuICAgICAgICAgICAgICAgIGlmICggY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApICkgaW5kaWNlcy5wdXNoKCBhLCBiICk7XG4gICAgICAgICAgICAgICAgaWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBiLCBjICkgKSBpbmRpY2VzLnB1c2goIGIsIGMgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGMsIGEgKSApIGluZGljZXMucHVzaCggYywgYSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIGFycmF5ID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gKCBhcnJheS5sZW5ndGggLyAzICkgLSAxOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBpICsgMDtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHZhciBjID0gaSArIDI7XG5cbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLnRpbWVFbmQoICd3aXJlZnJhbWUnICk7XG5cbiAgICAgICAgdmFyIFR5cGVBcnJheSA9IHBvc2l0aW9uLmNvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFR5cGVBcnJheSggaW5kaWNlcyApLCAxICk7XG5cbiAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XG5cbiAgICAgICAgcHJvcGVydHkud2lyZWZyYW1lID0gYXR0cmlidXRlO1xuXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0VkZ2UoIGVkZ2VzLCBhLCBiICkge1xuXG4gICAgICAgIGlmICggYSA+IGIgKSB7XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBhO1xuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICBiID0gdG1wO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGlzdCA9IGVkZ2VzWyBhIF07XG5cbiAgICAgICAgaWYgKCBsaXN0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGVkZ2VzWyBhIF0gPSBbIGIgXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGxpc3QuaW5kZXhPZiggYiApID09PSAtMSApIHtcblxuICAgICAgICAgICAgbGlzdC5wdXNoKCBiICk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgdGhpcy5nZXRBdHRyaWJ1dGVCdWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXI7XG4gICAgdGhpcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUgPSBnZXRXaXJlZnJhbWVBdHRyaWJ1dGU7XG5cbiAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbS5qc1xuXG5USFJFRS5XZWJHTFByb2dyYW0gPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHByb2dyYW1JZENvdW50ID0gMDtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcblxuICAgICAgICB2YXIgY2h1bmtzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gZGVmaW5lcyApIHtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGVmaW5lc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICBpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjaHVua3MucHVzaCggJyNkZWZpbmUgJyArIG5hbWUgKyAnICcgKyB2YWx1ZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oICdcXG4nICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7fTtcblxuICAgICAgICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKCBwcm9ncmFtLCBpICk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFVOSUZPUk06XCIsIG5hbWUpO1xuXG4gICAgICAgICAgICB2YXIgc3VmZml4UG9zID0gbmFtZS5sYXN0SW5kZXhPZiggJ1swXScgKTtcbiAgICAgICAgICAgIGlmICggc3VmZml4UG9zICE9PSAtMSAmJiBzdWZmaXhQb3MgPT09IG5hbWUubGVuZ3RoIC0gMyApIHtcblxuICAgICAgICAgICAgICAgIHVuaWZvcm1zWyBuYW1lLnN1YnN0ciggMCwgc3VmZml4UG9zICkgXSA9IGxvY2F0aW9uO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVuaWZvcm1zWyBuYW1lIF0gPSBsb2NhdGlvbjtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuaWZvcm1zO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgICAgIHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtLCBpICk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOlwiLCBuYW1lLCBpICk7XG5cbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbIG5hbWUgXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZyAhPT0gJyc7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgICAgICB2YXIgZGVmaW5lcyA9IG1hdGVyaWFsLmRlZmluZXM7XG5cbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIudmVydGV4U2hhZGVyO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xuXG4gICAgICAgIHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX0JBU0lDJztcblxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU2hhZG93TWFwICkge1xuXG4gICAgICAgICAgICBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRic7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG4gICAgICAgICAgICBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG4gICAgICAgIHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuICAgICAgICB2YXIgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9FUVVJUkVDJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOlxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX1NQSEVSRSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZSQUNUSU9OJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTXVsdGlwbHlPcGVyYXRpb246XG4gICAgICAgICAgICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5NaXhPcGVyYXRpb246XG4gICAgICAgICAgICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQWRkT3BlcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdhbW1hRmFjdG9yRGVmaW5lID0gKCByZW5kZXJlci5nYW1tYUZhY3RvciA+IDAgKSA/IHJlbmRlcmVyLmdhbW1hRmFjdG9yIDogMS4wO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdmFyIGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKTtcblxuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgICAgIHZhciBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgcHJlZml4VmVydGV4ID0gJyc7XG4gICAgICAgICAgICBwcmVmaXhGcmFnbWVudCA9ICcnO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHByZWZpeFZlcnRleCA9IFtcblxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcblxuICAgICAgICAgICAgICAgICcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXG5cbiAgICAgICAgICAgICAgICBjdXN0b21EZWZpbmVzLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmdhbW1hT3V0cHV0ID8gJyNkZWZpbmUgR0FNTUFfT1VUUFVUJyA6ICcnLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfRElSX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhEaXJMaWdodHMsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfSEVNSV9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4SGVtaUxpZ2h0cyxcblxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfQk9ORVMgJyArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgJiYgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNraW5uaW5nID8gJyNkZWZpbmUgVVNFX1NLSU5OSU5HJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcmVuZGVyZXIuZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXG5cblxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIG5vcm1hbDsnLFxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG4gICAgICAgICAgICAgICAgJyNpZmRlZiBVU0VfQ09MT1InLFxuXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcblxuICAgICAgICAgICAgICAgICcjZW5kaWYnLFxuXG4gICAgICAgICAgICAgICAgJyNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTJyxcblxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLFxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxuXG4gICAgICAgICAgICAgICAgJ1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxuXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JyxcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLFxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JyxcblxuICAgICAgICAgICAgICAgICdcdCNlbHNlJyxcblxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7JyxcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjsnLFxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXG5cbiAgICAgICAgICAgICAgICAnXHQjZW5kaWYnLFxuXG4gICAgICAgICAgICAgICAgJyNlbmRpZicsXG5cbiAgICAgICAgICAgICAgICAnI2lmZGVmIFVTRV9TS0lOTklORycsXG5cbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7JyxcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsXG5cbiAgICAgICAgICAgICAgICAnI2VuZGlmJyxcblxuICAgICAgICAgICAgICAgICdcXG4nXG5cbiAgICAgICAgICAgIF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgICAgICAgICBwcmVmaXhGcmFnbWVudCA9IFtcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nIHx8IG1hdGVyaWFsLmRlcml2YXRpdmVzID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsXG5cbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXG5cbiAgICAgICAgICAgICAgICAnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5uYW1lLFxuXG4gICAgICAgICAgICAgICAgY3VzdG9tRGVmaW5lcyxcblxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfUE9JTlRfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1NIQURPV1MgJyArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmdhbW1hT3V0cHV0ID8gJyNkZWZpbmUgR0FNTUFfT1VUUFVUJyA6ICcnLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cbiAgICAgICAgICAgICAgICAoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLCAoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1ldGFsID8gJyNkZWZpbmUgTUVUQUwnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcmVuZGVyZXIuZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXG5cbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICAgICAnXFxuJ1xuXG4gICAgICAgICAgICBdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRleEdsc2wgPSBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xuXG4gICAgICAgIHZhciBnbFZlcnRleFNoYWRlciA9IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4R2xzbCApO1xuICAgICAgICB2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcblxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgICAgIC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIC8vIHByb2dyYW1zIHdpdGggbW9ycGhUYXJnZXRzIGRpc3BsYWNlIHBvc2l0aW9uIG91dCBvZiBhdHRyaWJ1dGUgMFxuICAgICAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCAncG9zaXRpb24nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICAgICAgdmFyIHByb2dyYW1Mb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApO1xuICAgICAgICB2YXIgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgICAgICAgdmFyIGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgICAgIHZhciBydW5uYWJsZSA9IHRydWU7XG4gICAgICAgIHZhciBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG4gICAgICAgIGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIHJ1bm5hYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIHByb2dyYW1Mb2cgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB2ZXJ0ZXhMb2cgPT09ICcnIHx8IGZyYWdtZW50TG9nID09PSAnJyApIHtcblxuICAgICAgICAgICAgaGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaGF2ZURpYWdub3N0aWNzICkge1xuXG4gICAgICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0ge1xuXG4gICAgICAgICAgICAgICAgcnVubmFibGU6IHJ1bm5hYmxlLFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbCxcblxuICAgICAgICAgICAgICAgIHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHtcblxuICAgICAgICAgICAgICAgICAgICBsb2c6IHZlcnRleExvZyxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhWZXJ0ZXhcblxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjoge1xuXG4gICAgICAgICAgICAgICAgICAgIGxvZzogZnJhZ21lbnRMb2csXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4RnJhZ21lbnRcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW4gdXBcblxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgICAgIC8vIHNldCB1cCBjYWNoaW5nIGZvciB1bmlmb3JtIGxvY2F0aW9uc1xuXG4gICAgICAgIHZhciBjYWNoZWRVbmlmb3JtcztcblxuICAgICAgICB0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNhY2hlZFVuaWZvcm1zID0gZmV0Y2hVbmlmb3JtTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRVbmlmb3JtcztcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXG5cbiAgICAgICAgdmFyIGNhY2hlZEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmICggY2FjaGVkQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZnJlZSByZXNvdXJjZVxuXG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBERVBSRUNBVEVEXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblxuICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVuaWZvcm1zKCk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gKTtcblxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdGhpcy5pZCA9IHByb2dyYW1JZENvdW50Kys7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMudXNlZFRpbWVzID0gMTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbXMuanNcblxuVEhSRUUuV2ViR0xQcm9ncmFtcyA9IGZ1bmN0aW9uKCByZW5kZXJlciwgY2FwYWJpbGl0aWVzICkge1xuXG4gICAgdmFyIHByb2dyYW1zID0gW107XG5cbiAgICB2YXIgc2hhZGVySURzID0ge1xuICAgICAgICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgICAgICAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgICAgICAgTWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgICAgIE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcbiAgICAgICAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gICAgICAgIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgICAgICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICAgICAgICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cydcbiAgICB9O1xuXG4gICAgdmFyIHBhcmFtZXRlck5hbWVzID0gW1xuICAgICAgICBcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJlbnZNYXBcIiwgXCJlbnZNYXBNb2RlXCIsXG4gICAgICAgIFwibGlnaHRNYXBcIiwgXCJhb01hcFwiLCBcImVtaXNzaXZlTWFwXCIsIFwiYnVtcE1hcFwiLCBcIm5vcm1hbE1hcFwiLCBcInNwZWN1bGFyTWFwXCIsXG4gICAgICAgIFwiYWxwaGFNYXBcIiwgXCJjb21iaW5lXCIsIFwidmVydGV4Q29sb3JzXCIsIFwiZm9nXCIsIFwidXNlRm9nXCIsIFwiZm9nRXhwXCIsXG4gICAgICAgIFwiZmxhdFNoYWRpbmdcIiwgXCJzaXplQXR0ZW51YXRpb25cIiwgXCJsb2dhcml0aG1pY0RlcHRoQnVmZmVyXCIsIFwic2tpbm5pbmdcIixcbiAgICAgICAgXCJtYXhCb25lc1wiLCBcInVzZVZlcnRleFRleHR1cmVcIiwgXCJtb3JwaFRhcmdldHNcIiwgXCJtb3JwaE5vcm1hbHNcIixcbiAgICAgICAgXCJtYXhNb3JwaFRhcmdldHNcIiwgXCJtYXhNb3JwaE5vcm1hbHNcIiwgXCJtYXhEaXJMaWdodHNcIiwgXCJtYXhQb2ludExpZ2h0c1wiLFxuICAgICAgICBcIm1heFNwb3RMaWdodHNcIiwgXCJtYXhIZW1pTGlnaHRzXCIsIFwibWF4U2hhZG93c1wiLCBcInNoYWRvd01hcEVuYWJsZWRcIixcbiAgICAgICAgXCJzaGFkb3dNYXBUeXBlXCIsIFwic2hhZG93TWFwRGVidWdcIiwgXCJhbHBoYVRlc3RcIiwgXCJtZXRhbFwiLCBcImRvdWJsZVNpZGVkXCIsXG4gICAgICAgIFwiZmxpcFNpZGVkXCJcbiAgICBdO1xuXG5cbiAgICBmdW5jdGlvbiBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKSB7XG5cbiAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gMTAyNDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgLSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xuICAgICAgICAgICAgLy8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXG4gICAgICAgICAgICAvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXG5cbiAgICAgICAgICAgIHZhciBuVmVydGV4VW5pZm9ybXMgPSBjYXBhYmlsaXRpZXMubWF4VmVydGV4VW5pZm9ybXM7XG4gICAgICAgICAgICB2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xuXG4gICAgICAgICAgICB2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgICAgICAgICAgICBtYXhCb25lcyA9IE1hdGgubWluKCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoLCBtYXhCb25lcyApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXhCb25lcyA8IG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdG9vIG1hbnkgYm9uZXMgLSAnICsgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCArICcsIHRoaXMgR1BVIHN1cHBvcnRzIGp1c3QgJyArIG1heEJvbmVzICsgJyAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKScgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF4Qm9uZXM7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApIHtcblxuICAgICAgICB2YXIgZGlyTGlnaHRzID0gMDtcbiAgICAgICAgdmFyIHBvaW50TGlnaHRzID0gMDtcbiAgICAgICAgdmFyIHNwb3RMaWdodHMgPSAwO1xuICAgICAgICB2YXIgaGVtaUxpZ2h0cyA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCsrICkge1xuXG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuICAgICAgICAgICAgaWYgKCBsaWdodC5vbmx5U2hhZG93IHx8IGxpZ2h0LnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgZGlyTGlnaHRzKys7XG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHBvaW50TGlnaHRzKys7XG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgc3BvdExpZ2h0cysrO1xuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIGhlbWlMaWdodHMrKztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdkaXJlY3Rpb25hbCc6IGRpckxpZ2h0cyxcbiAgICAgICAgICAgICdwb2ludCc6IHBvaW50TGlnaHRzLFxuICAgICAgICAgICAgJ3Nwb3QnOiBzcG90TGlnaHRzLFxuICAgICAgICAgICAgJ2hlbWknOiBoZW1pTGlnaHRzXG4gICAgICAgIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxvY2F0ZVNoYWRvd3MoIGxpZ2h0cyApIHtcblxuICAgICAgICB2YXIgbWF4U2hhZG93cyA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCsrICkge1xuXG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuICAgICAgICAgICAgaWYgKCAhbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgbWF4U2hhZG93cysrO1xuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBtYXhTaGFkb3dzKys7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXhTaGFkb3dzO1xuXG4gICAgfVxuXG4gICAgdGhpcy5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24oIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xuXG4gICAgICAgIHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xuICAgICAgICAvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxuICAgICAgICAvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxuXG4gICAgICAgIHZhciBtYXhMaWdodENvdW50ID0gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApO1xuICAgICAgICB2YXIgbWF4U2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XG4gICAgICAgIHZhciBtYXhCb25lcyA9IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApO1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCk7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5wcmVjaXNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5nZXRNYXhQcmVjaXNpb24oIG1hdGVyaWFsLnByZWNpc2lvbiApO1xuXG4gICAgICAgICAgICBpZiAoIHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5pbml0TWF0ZXJpYWw6JywgbWF0ZXJpYWwucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBwcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHtcblxuICAgICAgICAgICAgc2hhZGVySUQ6IHNoYWRlcklELFxuXG4gICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgIHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcblxuICAgICAgICAgICAgbWFwOiAhIW1hdGVyaWFsLm1hcCxcbiAgICAgICAgICAgIGVudk1hcDogISFtYXRlcmlhbC5lbnZNYXAsXG4gICAgICAgICAgICBlbnZNYXBNb2RlOiBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcsXG4gICAgICAgICAgICBsaWdodE1hcDogISFtYXRlcmlhbC5saWdodE1hcCxcbiAgICAgICAgICAgIGFvTWFwOiAhIW1hdGVyaWFsLmFvTWFwLFxuICAgICAgICAgICAgZW1pc3NpdmVNYXA6ICEhbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXG4gICAgICAgICAgICBidW1wTWFwOiAhIW1hdGVyaWFsLmJ1bXBNYXAsXG4gICAgICAgICAgICBub3JtYWxNYXA6ICEhbWF0ZXJpYWwubm9ybWFsTWFwLFxuICAgICAgICAgICAgZGlzcGxhY2VtZW50TWFwOiAhIW1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCxcbiAgICAgICAgICAgIHNwZWN1bGFyTWFwOiAhIW1hdGVyaWFsLnNwZWN1bGFyTWFwLFxuICAgICAgICAgICAgYWxwaGFNYXA6ICEhbWF0ZXJpYWwuYWxwaGFNYXAsXG5cbiAgICAgICAgICAgIGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXG5cbiAgICAgICAgICAgIHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxuXG4gICAgICAgICAgICBmb2c6IGZvZyxcbiAgICAgICAgICAgIHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuICAgICAgICAgICAgZm9nRXhwOiBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyLFxuXG4gICAgICAgICAgICBmbGF0U2hhZGluZzogbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcsXG5cbiAgICAgICAgICAgIHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxuICAgICAgICAgICAgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogcmVuZGVyZXIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblxuICAgICAgICAgICAgc2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nLFxuICAgICAgICAgICAgbWF4Qm9uZXM6IG1heEJvbmVzLFxuICAgICAgICAgICAgdXNlVmVydGV4VGV4dHVyZTogY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcblxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbHM6IG1hdGVyaWFsLm1vcnBoTm9ybWFscyxcbiAgICAgICAgICAgIG1heE1vcnBoVGFyZ2V0czogcmVuZGVyZXIubWF4TW9ycGhUYXJnZXRzLFxuICAgICAgICAgICAgbWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXG5cbiAgICAgICAgICAgIG1heERpckxpZ2h0czogbWF4TGlnaHRDb3VudC5kaXJlY3Rpb25hbCxcbiAgICAgICAgICAgIG1heFBvaW50TGlnaHRzOiBtYXhMaWdodENvdW50LnBvaW50LFxuICAgICAgICAgICAgbWF4U3BvdExpZ2h0czogbWF4TGlnaHRDb3VudC5zcG90LFxuICAgICAgICAgICAgbWF4SGVtaUxpZ2h0czogbWF4TGlnaHRDb3VudC5oZW1pLFxuXG4gICAgICAgICAgICBtYXhTaGFkb3dzOiBtYXhTaGFkb3dzLFxuICAgICAgICAgICAgc2hhZG93TWFwRW5hYmxlZDogcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgJiYgb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgbWF4U2hhZG93cyA+IDAsXG4gICAgICAgICAgICBzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcbiAgICAgICAgICAgIHNoYWRvd01hcERlYnVnOiByZW5kZXJlci5zaGFkb3dNYXAuZGVidWcsXG5cbiAgICAgICAgICAgIGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxuICAgICAgICAgICAgbWV0YWw6IG1hdGVyaWFsLm1ldGFsLFxuICAgICAgICAgICAgZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUsXG4gICAgICAgICAgICBmbGlwU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlXG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcblxuICAgIH07XG5cbiAgICB0aGlzLmdldFByb2dyYW1Db2RlID0gZnVuY3Rpb24oIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG4gICAgICAgIHZhciBjaHVua3MgPSBbXTtcblxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgY2h1bmtzLnB1c2goIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyICk7XG4gICAgICAgICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwudmVydGV4U2hhZGVyICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5kZWZpbmVzICkge1xuXG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goIG5hbWUgKTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwuZGVmaW5lc1sgbmFtZSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZXNbIGkgXTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJOYW1lICk7XG4gICAgICAgICAgICBjaHVua3MucHVzaCggcGFyYW1ldGVyc1sgcGFyYW1ldGVyTmFtZSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaHVua3Muam9pbigpO1xuXG4gICAgfTtcblxuICAgIHRoaXMuYWNxdWlyZVByb2dyYW0gPSBmdW5jdGlvbiggbWF0ZXJpYWwsIHBhcmFtZXRlcnMsIGNvZGUgKSB7XG5cbiAgICAgICAgdmFyIHByb2dyYW07XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXG4gICAgICAgIGZvciAoIHZhciBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCsrICkge1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbUluZm8gPSBwcm9ncmFtc1sgcCBdO1xuXG4gICAgICAgICAgICBpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUluZm87XG4gICAgICAgICAgICAgICAgKytwcm9ncmFtLnVzZWRUaW1lcztcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBwcm9ncmFtID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XG4gICAgICAgICAgICBwcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuXG4gICAgfTtcblxuICAgIHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiggcHJvZ3JhbSApIHtcblxuICAgICAgICBpZiAoIC0tcHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHVub3JkZXJlZCBzZXRcbiAgICAgICAgICAgIHZhciBpID0gcHJvZ3JhbXMuaW5kZXhPZiggcHJvZ3JhbSApO1xuICAgICAgICAgICAgcHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XG4gICAgICAgICAgICBwcm9ncmFtcy5wb3AoKTtcblxuICAgICAgICAgICAgLy8gRnJlZSBXZWJHTCByZXNvdXJjZXNcbiAgICAgICAgICAgIHByb2dyYW0uZGVzdHJveSgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XG4gICAgdGhpcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9wZXJ0aWVzLmpzXG5cbi8qKlxuICogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cbiAqL1xuXG5USFJFRS5XZWJHTFByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG5cbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgdmFyIHV1aWQgPSBvYmplY3QudXVpZDtcbiAgICAgICAgdmFyIG1hcCA9IHByb3BlcnRpZXNbIHV1aWQgXTtcblxuICAgICAgICBpZiAoIG1hcCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBtYXAgPSB7fTtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbIHV1aWQgXSA9IG1hcDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcblxuICAgIH07XG5cbiAgICB0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XG5cbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcblxuICAgIH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRlci5qc1xuXG5USFJFRS5XZWJHTFNoYWRlciA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgYWRkTGluZU51bWJlcnMgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuXG4gICAgICAgIHZhciBsaW5lcyA9IHN0cmluZy5zcGxpdCggJ1xcbicgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgbGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXMuam9pbiggJ1xcbicgKTtcblxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cbiAgICAgICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xuXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cbiAgICAgICAgaWYgKCBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFNoYWRlcjogU2hhZGVyIGNvdWxkblxcJ3QgY29tcGlsZS4nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggdHlwZSwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG5cbiAgICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZG93TWFwLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xTaGFkb3dNYXAgPSBmdW5jdGlvbiggX3JlbmRlcmVyLCBfbGlnaHRzLCBfb2JqZWN0cyApIHtcblxuICAgIHZhciBfZ2wgPSBfcmVuZGVyZXIuY29udGV4dCxcbiAgICAgICAgX3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlLFxuICAgICAgICBfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXG4gICAgICAgIF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuICAgICAgICBfbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgX21heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgICAgX21hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgICAgICBfcmVuZGVyTGlzdCA9IFtdO1xuXG4gICAgLy8gaW5pdFxuXG4gICAgdmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XG4gICAgdmFyIGRlcHRoVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkZXB0aFNoYWRlci51bmlmb3JtcyApO1xuXG4gICAgdmFyIF9kZXB0aE1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyXG4gICAgfSApO1xuXG4gICAgdmFyIF9kZXB0aE1hdGVyaWFsTW9ycGggPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICAgICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgIG1vcnBoVGFyZ2V0czogdHJ1ZVxuICAgIH0gKTtcblxuICAgIHZhciBfZGVwdGhNYXRlcmlhbFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICAgICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgIHNraW5uaW5nOiB0cnVlXG4gICAgfSApO1xuXG4gICAgdmFyIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICBtb3JwaFRhcmdldHM6IHRydWUsXG4gICAgICAgIHNraW5uaW5nOiB0cnVlXG4gICAgfSApO1xuXG4gICAgX2RlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xuICAgIF9kZXB0aE1hdGVyaWFsTW9ycGguX3NoYWRvd1Bhc3MgPSB0cnVlO1xuICAgIF9kZXB0aE1hdGVyaWFsU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XG4gICAgX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXG4gICAgLy9cblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy50eXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xuICAgIHRoaXMuY3VsbEZhY2UgPSBUSFJFRS5DdWxsRmFjZUZyb250O1xuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiggc2NlbmUsIGNhbWVyYSApIHtcblxuICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuICAgICAgICBpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICAvLyBzZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcFxuXG4gICAgICAgIF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XG4gICAgICAgIF9zdGF0ZS5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcblxuICAgICAgICBfc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG4gICAgICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcblxuICAgICAgICBpZiAoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG4gICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgX3N0YXRlLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuXG4gICAgICAgIC8vIHJlbmRlciBkZXB0aCBtYXBcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gX2xpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBfbGlnaHRzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggIWxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKCAhbGlnaHQuc2hhZG93TWFwICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvd0ZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuICAgICAgICAgICAgICAgIGlmICggc2NvcGUudHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcblxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkZpbHRlcjogc2hhZG93RmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBtYWdGaWx0ZXI6IHNoYWRvd0ZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxpZ2h0LnNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggbGlnaHQuc2hhZG93TWFwV2lkdGgsIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgcGFycyApO1xuICAgICAgICAgICAgICAgIGxpZ2h0LnNoYWRvd01hcFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGlnaHQuc2hhZG93TWFwV2lkdGgsIGxpZ2h0LnNoYWRvd01hcEhlaWdodCApO1xuXG4gICAgICAgICAgICAgICAgbGlnaHQuc2hhZG93TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICFsaWdodC5zaGFkb3dDYW1lcmEgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhRm92LCBsaWdodC5zaGFkb3dNYXBXaWR0aCAvIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuICAgICAgICAgICAgICAgICAgICBsaWdodC5zaGFkb3dDYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBsaWdodC5zaGFkb3dDYW1lcmFMZWZ0LCBsaWdodC5zaGFkb3dDYW1lcmFSaWdodCwgbGlnaHQuc2hhZG93Q2FtZXJhVG9wLCBsaWdodC5zaGFkb3dDYW1lcmFCb3R0b20sIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuU2hhZG93TWFwUGx1Z2luOiBVbnN1cHBvcnRlZCBsaWdodCB0eXBlIGZvciBzaGFkb3dcIiwgbGlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY2VuZS5hZGQoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgJiYgIWxpZ2h0LmNhbWVyYUhlbHBlciApIHtcblxuICAgICAgICAgICAgICAgIGxpZ2h0LmNhbWVyYUhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xuICAgICAgICAgICAgICAgIHNjZW5lLmFkZCggbGlnaHQuY2FtZXJhSGVscGVyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNoYWRvd01hcCA9IGxpZ2h0LnNoYWRvd01hcDtcbiAgICAgICAgICAgIHZhciBzaGFkb3dNYXRyaXggPSBsaWdodC5zaGFkb3dNYXRyaXg7XG4gICAgICAgICAgICB2YXIgc2hhZG93Q2FtZXJhID0gbGlnaHQuc2hhZG93Q2FtZXJhO1xuXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBzaGFkb3dDYW1lcmEucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgX21hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICBzaGFkb3dDYW1lcmEubG9va0F0KCBfbWF0cml4UG9zaXRpb24gKTtcbiAgICAgICAgICAgIHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAgICAgICBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBpZiAoIGxpZ2h0LmNhbWVyYUhlbHBlciApIGxpZ2h0LmNhbWVyYUhlbHBlci52aXNpYmxlID0gbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZTtcbiAgICAgICAgICAgIGlmICggbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSApIGxpZ2h0LmNhbWVyYUhlbHBlci51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XG5cbiAgICAgICAgICAgIHNoYWRvd01hdHJpeC5zZXQoXG4gICAgICAgICAgICAgICAgMC41LCAwLjAsIDAuMCwgMC41LFxuICAgICAgICAgICAgICAgIDAuMCwgMC41LCAwLjAsIDAuNSxcbiAgICAgICAgICAgICAgICAwLjAsIDAuMCwgMC41LCAwLjUsXG4gICAgICAgICAgICAgICAgMC4wLCAwLjAsIDAuMCwgMS4wXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG4gICAgICAgICAgICBzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG4gICAgICAgICAgICBfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgICAgICAgICAgX2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgICAgICAgICAgLy8gcmVuZGVyIHNoYWRvdyBtYXBcblxuICAgICAgICAgICAgX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XG4gICAgICAgICAgICBfcmVuZGVyZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgLy8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xuXG4gICAgICAgICAgICBfcmVuZGVyTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICBwcm9qZWN0T2JqZWN0KCBzY2VuZSwgc2hhZG93Q2FtZXJhICk7XG5cblxuICAgICAgICAgICAgLy8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gX3JlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IF9vYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgayBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBncm91cE1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIG51bGwsIGdlb21ldHJ5LCBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwgKSwgb2JqZWN0LCBncm91cCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgbnVsbCwgZ2VvbWV0cnksIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwgKSwgb2JqZWN0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSBHTCBzdGF0ZVxuXG4gICAgICAgIHZhciBjbGVhckNvbG9yID0gX3JlbmRlcmVyLmdldENsZWFyQ29sb3IoKSxcbiAgICAgICAgICAgIGNsZWFyQWxwaGEgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xuXG4gICAgICAgIF9yZW5kZXJlci5zZXRDbGVhckNvbG9yKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XG4gICAgICAgIF9zdGF0ZS5lbmFibGUoIF9nbC5CTEVORCApO1xuXG4gICAgICAgIGlmICggc2NvcGUuY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cbiAgICAgICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgX3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG4gICAgICAgIHNjb3BlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgICAgdmFyIHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgJiYgbWF0ZXJpYWwubW9ycGhUYXJnZXRzO1xuICAgICAgICB2YXIgdXNlU2tpbm5pbmcgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCAmJiBtYXRlcmlhbC5za2lubmluZztcblxuICAgICAgICB2YXIgZGVwdGhNYXRlcmlhbDtcblxuICAgICAgICBpZiAoIG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdXNlU2tpbm5pbmcgKSB7XG5cbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSB1c2VNb3JwaGluZyA/IF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luIDogX2RlcHRoTWF0ZXJpYWxTa2luO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHVzZU1vcnBoaW5nICkge1xuXG4gICAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWxNb3JwaDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWw7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGRlcHRoTWF0ZXJpYWwudmlzaWJsZSA9IG1hdGVyaWFsLnZpc2libGU7XG4gICAgICAgIGRlcHRoTWF0ZXJpYWwud2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lO1xuICAgICAgICBkZXB0aE1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgICAgICByZXR1cm4gZGVwdGhNYXRlcmlhbDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhICkge1xuXG4gICAgICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QuY2FzdFNoYWRvdyAmJiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgICAgIF9yZW5kZXJMaXN0LnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU3RhdGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldlYkdMU3RhdGUgPSBmdW5jdGlvbiggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICkge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBuZXdBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG4gICAgdmFyIGVuYWJsZWRBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG5cbiAgICB2YXIgY2FwYWJpbGl0aWVzID0ge307XG5cbiAgICB2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcblxuICAgIHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblxuICAgIHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcbiAgICB2YXIgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xuXG4gICAgdmFyIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcblxuICAgIHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblxuICAgIHZhciBjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcblxuICAgIHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xuXG4gICAgdmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuXG4gICAgdmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoIDAsIDAsIDAsIDEgKTtcbiAgICAgICAgZ2wuY2xlYXJEZXB0aCggMSApO1xuICAgICAgICBnbC5jbGVhclN0ZW5jaWwoIDAgKTtcblxuICAgICAgICB0aGlzLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgICAgIGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XG4gICAgICAgIGdsLmN1bGxGYWNlKCBnbC5CQUNLICk7XG4gICAgICAgIHRoaXMuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmluaXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuZW5hYmxlQXR0cmlidXRlID0gZnVuY3Rpb24oIGF0dHJpYnV0ZSApIHtcblxuICAgICAgICBuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cbiAgICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XG5cbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcbiAgICAgICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSAhPT0gbmV3QXR0cmlidXRlc1sgaSBdICkge1xuXG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG4gICAgICAgICAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiggaWQgKSB7XG5cbiAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIGdsLmVuYWJsZSggaWQgKTtcbiAgICAgICAgICAgIGNhcGFiaWxpdGllc1sgaWQgXSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uKCBpZCApIHtcblxuICAgICAgICBpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGdsLmRpc2FibGUoIGlkICk7XG4gICAgICAgICAgICBjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gW107XG5cbiAgICAgICAgICAgIGlmICggZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHxcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBmb3JtYXRzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0QmxlbmRpbmcgPSBmdW5jdGlvbiggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhICkge1xuXG4gICAgICAgIGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyApIHtcblxuICAgICAgICAgICAgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZSggZ2wuQkxFTkQgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5NdWx0aXBseUJsZW5kaW5nICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXG5cbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcblxuICAgICAgICAgICAgYmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XG4gICAgICAgICAgICBibGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYSB8fCBibGVuZFNyYztcbiAgICAgICAgICAgIGJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhIHx8IGJsZW5kRHN0O1xuXG4gICAgICAgICAgICBpZiAoIGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSApIHtcblxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb24gKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb25BbHBoYSApICk7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSApIHtcblxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmMgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0ICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyY0FscGhhICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdEFscGhhICkgKTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZERzdCA9IGJsZW5kRHN0O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldERlcHRoRnVuYyA9IGZ1bmN0aW9uKCBkZXB0aEZ1bmMgKSB7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XG5cbiAgICAgICAgICAgIGlmICggZGVwdGhGdW5jICkge1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICggZGVwdGhGdW5jICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTmV2ZXJEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5BbHdheXNEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTGVzc0RlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTGVzc0VxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuR3JlYXRlckVxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkdyZWF0ZXJEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk5vdEVxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldERlcHRoVGVzdCA9IGZ1bmN0aW9uKCBkZXB0aFRlc3QgKSB7XG5cbiAgICAgICAgaWYgKCBkZXB0aFRlc3QgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uKCBkZXB0aFdyaXRlICkge1xuXG4gICAgICAgIGlmICggY3VycmVudERlcHRoV3JpdGUgIT09IGRlcHRoV3JpdGUgKSB7XG5cbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayggZGVwdGhXcml0ZSApO1xuICAgICAgICAgICAgY3VycmVudERlcHRoV3JpdGUgPSBkZXB0aFdyaXRlO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldENvbG9yV3JpdGUgPSBmdW5jdGlvbiggY29sb3JXcml0ZSApIHtcblxuICAgICAgICBpZiAoIGN1cnJlbnRDb2xvcldyaXRlICE9PSBjb2xvcldyaXRlICkge1xuXG4gICAgICAgICAgICBnbC5jb2xvck1hc2soIGNvbG9yV3JpdGUsIGNvbG9yV3JpdGUsIGNvbG9yV3JpdGUsIGNvbG9yV3JpdGUgKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb2xvcldyaXRlID0gY29sb3JXcml0ZTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRGbGlwU2lkZWQgPSBmdW5jdGlvbiggZmxpcFNpZGVkICkge1xuXG4gICAgICAgIGlmICggY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xuXG4gICAgICAgICAgICBpZiAoIGZsaXBTaWRlZCApIHtcblxuICAgICAgICAgICAgICAgIGdsLmZyb250RmFjZSggZ2wuQ1cgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0TGluZVdpZHRoID0gZnVuY3Rpb24oIHdpZHRoICkge1xuXG4gICAgICAgIGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XG5cbiAgICAgICAgICAgIGdsLmxpbmVXaWR0aCggd2lkdGggKTtcblxuICAgICAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldFBvbHlnb25PZmZzZXQgPSBmdW5jdGlvbiggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcblxuICAgICAgICBpZiAoIHBvbHlnb25PZmZzZXQgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcG9seWdvbk9mZnNldCAmJiAoIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSApIHtcblxuICAgICAgICAgICAgZ2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xuXG4gICAgICAgICAgICBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3RvcjtcbiAgICAgICAgICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uKCBzY2lzc29yVGVzdCApIHtcblxuICAgICAgICBpZiAoIHNjaXNzb3JUZXN0ICkge1xuXG4gICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gdGV4dHVyZVxuXG4gICAgdGhpcy5hY3RpdmVUZXh0dXJlID0gZnVuY3Rpb24oIHdlYmdsU2xvdCApIHtcblxuICAgICAgICBpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcblxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG4gICAgICAgICAgICBjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5iaW5kVGV4dHVyZSA9IGZ1bmN0aW9uKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApIHtcblxuICAgICAgICBpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBfdGhpcy5hY3RpdmVUZXh0dXJlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF07XG5cbiAgICAgICAgaWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgYm91bmRUZXh0dXJlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xuXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKTtcblxuICAgICAgICAgICAgYm91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XG4gICAgICAgICAgICBib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5jb21wcmVzc2VkVGV4SW1hZ2UyRCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnRleEltYWdlMkQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvL1xuXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcbiAgICAgICAgICAgICAgICBlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjYXBhYmlsaXRpZXMgPSB7fTtcblxuICAgICAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG4gICAgICAgIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG5cbiAgICAgICAgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xuICAgICAgICBjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XG5cbiAgICAgICAgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cbiAgICB9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmVQbHVnaW4gPSBmdW5jdGlvbiggcmVuZGVyZXIsIGZsYXJlcyApIHtcblxuICAgIHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG4gICAgdmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cbiAgICB2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuICAgIHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcbiAgICB2YXIgaGFzVmVydGV4VGV4dHVyZTtcblxuICAgIHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcblxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtMSwgLTEsIDAsIDAsXG4gICAgICAgICAgICAxLCAtMSwgMSwgMCxcbiAgICAgICAgICAgIDEsIDEsIDEsIDEsIC0xLCAxLCAwLCAxXG4gICAgICAgIF0gKTtcblxuICAgICAgICB2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcbiAgICAgICAgICAgIDAsIDEsIDIsXG4gICAgICAgICAgICAwLCAyLCAzXG4gICAgICAgIF0gKTtcblxuICAgICAgICAvLyBidWZmZXJzXG5cbiAgICAgICAgdmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgICAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgICAgICAvLyB0ZXh0dXJlc1xuXG4gICAgICAgIHRlbXBUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBvY2NsdXNpb25UZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG4gICAgICAgIGhhc1ZlcnRleFRleHR1cmUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApID4gMDtcblxuICAgICAgICB2YXIgc2hhZGVyO1xuXG4gICAgICAgIGlmICggaGFzVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgICAgICAgc2hhZGVyID0ge1xuXG4gICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZVViA9IHV2O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSA9ICAgICAgICB2aXNpYmlsaXR5LnIgLyA5LjA7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9ICAgICAgIHZpc2liaWxpdHkuYiAvIDkuMDtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmEgLyA5LjA7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuICAgICAgICAgICAgICAgICAgICBcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgICAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcGluayBzcXVhcmVcblxuICAgICAgICAgICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICAvLyBmbGFyZVxuXG4gICAgICAgICAgICAgICAgICAgIFwifSBlbHNlIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgICAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBzaGFkZXIgPSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZVViA9IHV2O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuICAgICAgICAgICAgICAgICAgICBcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgICAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICAgICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHBpbmsgc3F1YXJlXG5cbiAgICAgICAgICAgICAgICAgICAgXCJpZiggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKCBtYXAsIHZVViApLnJnYiwgMC4wICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZVxuXG4gICAgICAgICAgICAgICAgICAgIFwifSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhcmVcblxuICAgICAgICAgICAgICAgICAgICBcIn0gZWxzZSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKS5hO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKS5hO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgPSAoIDEuMCAtIHZpc2liaWxpdHkgLyA0LjAgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZpc2liaWxpdHk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICk7XG5cbiAgICAgICAgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIHZlcnRleDogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIFwicG9zaXRpb25cIiApLFxuICAgICAgICAgICAgdXY6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBcInV2XCIgKVxuICAgICAgICB9O1xuXG4gICAgICAgIHVuaWZvcm1zID0ge1xuICAgICAgICAgICAgcmVuZGVyVHlwZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJlbmRlclR5cGVcIiApLFxuICAgICAgICAgICAgbWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwibWFwXCIgKSxcbiAgICAgICAgICAgIG9jY2x1c2lvbk1hcDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXG4gICAgICAgICAgICBvcGFjaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXG4gICAgICAgICAgICBjb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcImNvbG9yXCIgKSxcbiAgICAgICAgICAgIHNjYWxlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NhbGVcIiApLFxuICAgICAgICAgICAgcm90YXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKVxuICAgICAgICB9O1xuXG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUmVuZGVyIGxlbnMgZmxhcmVzXG4gICAgICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcbiAgICAgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxuICAgICAqL1xuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQgKSB7XG5cbiAgICAgICAgaWYgKCBmbGFyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydEhlaWdodCAvIHZpZXdwb3J0V2lkdGgsXG4gICAgICAgICAgICBoYWxmVmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0V2lkdGggKiAwLjUsXG4gICAgICAgICAgICBoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodCAqIDAuNTtcblxuICAgICAgICB2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQsXG4gICAgICAgICAgICBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cbiAgICAgICAgdmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDAgKSxcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuICAgICAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICAgICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnZlcnRleCApO1xuICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcbiAgICAgICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xuICAgICAgICAvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmlmb3Jtc1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cbiAgICAgICAgc3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgICAgIGdsLmRlcHRoTWFzayggZmFsc2UgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcbiAgICAgICAgICAgIHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG4gICAgICAgICAgICAvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cblxuICAgICAgICAgICAgdmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XG5cbiAgICAgICAgICAgIHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcblxuICAgICAgICAgICAgdGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgICAgICAgICAgdGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgICAgICAgICAgLy8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xuXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi5jb3B5KCB0ZW1wUG9zaXRpb24gKTtcblxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCArIGhhbGZWaWV3cG9ydFdpZHRoO1xuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueSA9IHNjcmVlblBvc2l0aW9uLnkgKiBoYWxmVmlld3BvcnRIZWlnaHQgKyBoYWxmVmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIHNjcmVlbiBjdWxsXG5cbiAgICAgICAgICAgIGlmICggaGFzVmVydGV4VGV4dHVyZSB8fCAoXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54IDwgdmlld3BvcnRXaWR0aCAmJlxuICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPiAwICYmXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG4gICAgICAgICAgICAgICAgZ2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHBpbmsgcXVhZFxuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG4gICAgICAgICAgICAgICAgLy8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XG4gICAgICAgICAgICAgICAgZ2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XG5cblxuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgZ3JhcGhpY3NcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG4gICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXG5cbiAgICAgICAgICAgICAgICBmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcblxuICAgICAgICAgICAgICAgICAgICBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBmbGFyZS51cGRhdGVMZW5zRmxhcmVzKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgZmxhcmVzXG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDIgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi54ID0gc3ByaXRlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBzcHJpdGUuc2l6ZSAqIHNwcml0ZS5zY2FsZSAvIHZpZXdwb3J0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZS54ID0gc2l6ZSAqIGludkFzcGVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlLnkgPSBzaXplO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgc3ByaXRlLmNvbG9yLnIsIHNwcml0ZS5jb2xvci5nLCBzcHJpdGUuY29sb3IuYiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoIHNwcml0ZS50ZXh0dXJlLCAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIGdsXG5cbiAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG4gICAgICAgIGdsLmRlcHRoTWFzayggdHJ1ZSApO1xuXG4gICAgICAgIHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oIHNoYWRlciApIHtcblxuICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cbiAgICAgICAgdmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcblxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcblxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcblxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cbiAgICAgICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU3ByaXRlUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24oIHJlbmRlcmVyLCBzcHJpdGVzICkge1xuXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICB2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcblxuICAgIHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG4gICAgdmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xuXG4gICAgdmFyIHRleHR1cmU7XG5cbiAgICAvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcblxuICAgIHZhciBzcHJpdGVQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHNwcml0ZVJvdGF0aW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICB2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIC0wLjUsIC0wLjUsIDAsIDAsXG4gICAgICAgICAgICAwLjUsIC0wLjUsIDEsIDAsXG4gICAgICAgICAgICAwLjUsIDAuNSwgMSwgMSwgLTAuNSwgMC41LCAwLCAxXG4gICAgICAgIF0gKTtcblxuICAgICAgICB2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcbiAgICAgICAgICAgIDAsIDEsIDIsXG4gICAgICAgICAgICAwLCAyLCAzXG4gICAgICAgIF0gKTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgICAgIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCk7XG5cbiAgICAgICAgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxuICAgICAgICAgICAgdXY6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAndXYnIClcbiAgICAgICAgfTtcblxuICAgICAgICB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIHV2T2Zmc2V0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dk9mZnNldCcgKSxcbiAgICAgICAgICAgIHV2U2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXG5cbiAgICAgICAgICAgIHJvdGF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcbiAgICAgICAgICAgIHNjYWxlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcblxuICAgICAgICAgICAgY29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxuICAgICAgICAgICAgbWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtYXAnICksXG4gICAgICAgICAgICBvcGFjaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxuXG4gICAgICAgICAgICBtb2RlbFZpZXdNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXG5cbiAgICAgICAgICAgIGZvZ1R5cGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXG4gICAgICAgICAgICBmb2dEZW5zaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dEZW5zaXR5JyApLFxuICAgICAgICAgICAgZm9nTmVhcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcbiAgICAgICAgICAgIGZvZ0ZhcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRmFyJyApLFxuICAgICAgICAgICAgZm9nQ29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0NvbG9yJyApLFxuXG4gICAgICAgICAgICBhbHBoYVRlc3Q6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICBjYW52YXMud2lkdGggPSA4O1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gODtcblxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xuXG4gICAgICAgIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggY2FudmFzICk7XG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgfTtcblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oIHNjZW5lLCBjYW1lcmEgKSB7XG5cbiAgICAgICAgaWYgKCBzcHJpdGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuICAgICAgICAvLyBzZXR1cCBnbFxuXG4gICAgICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuICAgICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcbiAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG4gICAgICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgc3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XG5cbiAgICAgICAgdmFyIG9sZEZvZ1R5cGUgPSAwO1xuICAgICAgICB2YXIgc2NlbmVGb2dUeXBlID0gMDtcbiAgICAgICAgdmFyIGZvZyA9IHNjZW5lLmZvZztcblxuICAgICAgICBpZiAoIGZvZyApIHtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xuXG4gICAgICAgICAgICBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0ZhciwgZm9nLmZhciApO1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAxICk7XG4gICAgICAgICAgICAgICAgb2xkRm9nVHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgc2NlbmVGb2dUeXBlID0gMTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0RlbnNpdHksIGZvZy5kZW5zaXR5ICk7XG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDIgKTtcbiAgICAgICAgICAgICAgICBvbGRGb2dUeXBlID0gMjtcbiAgICAgICAgICAgICAgICBzY2VuZUZvZ1R5cGUgPSAyO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG4gICAgICAgICAgICBvbGRGb2dUeXBlID0gMDtcbiAgICAgICAgICAgIHNjZW5lRm9nVHlwZSA9IDA7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9ucyBhbmQgc29ydFxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuXG4gICAgICAgICAgICBzcHJpdGUubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgc3ByaXRlLnogPSAtc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG4gICAgICAgIC8vIHJlbmRlciBhbGwgc3ByaXRlc1xuXG4gICAgICAgIHZhciBzY2FsZSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmFscGhhVGVzdCwgbWF0ZXJpYWwuYWxwaGFUZXN0ICk7XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgICAgICAgIHNwcml0ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHNwcml0ZVBvc2l0aW9uLCBzcHJpdGVSb3RhdGlvbiwgc3ByaXRlU2NhbGUgKTtcblxuICAgICAgICAgICAgc2NhbGVbIDAgXSA9IHNwcml0ZVNjYWxlLng7XG4gICAgICAgICAgICBzY2FsZVsgMSBdID0gc3ByaXRlU2NhbGUueTtcblxuICAgICAgICAgICAgdmFyIGZvZ1R5cGUgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cbiAgICAgICAgICAgICAgICBmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xuICAgICAgICAgICAgICAgIG9sZEZvZ1R5cGUgPSBmb2dUeXBlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgMSwgMSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgbWF0ZXJpYWwub3BhY2l0eSApO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgbWF0ZXJpYWwuY29sb3IuciwgbWF0ZXJpYWwuY29sb3IuZywgbWF0ZXJpYWwuY29sb3IuYiApO1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBtYXRlcmlhbC5yb3RhdGlvbiApO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlICk7XG5cbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0ICk7XG4gICAgICAgICAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuICAgICAgICAgICAgc3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuaW1hZ2UgJiYgbWF0ZXJpYWwubWFwLmltYWdlLndpZHRoICkge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZSggdGV4dHVyZSwgMCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIGdsXG5cbiAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgICAgICByZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKCkge1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcblxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xuXG4gICAgICAgICAgICAncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxuXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG5cbiAgICAgICAgICAgICd2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxuXG4gICAgICAgICAgICAndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXG5cbiAgICAgICAgICAgICd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxuICAgICAgICAgICAgJ3JvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuICAgICAgICAgICAgJ3JvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuXG4gICAgICAgICAgICAndmVjNCBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICdmaW5hbFBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7JyxcbiAgICAgICAgICAgICdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxuICAgICAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICd9J1xuXG4gICAgICAgIF0uam9pbiggJ1xcbicgKSApO1xuXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIFtcblxuICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgY29sb3I7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgZm9nQ29sb3I7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXG5cbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcblxuICAgICAgICAgICAgJ3ZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxuXG4gICAgICAgICAgICAnaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXG5cbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcblxuICAgICAgICAgICAgJ2lmICggZm9nVHlwZSA+IDAgKSB7JyxcblxuICAgICAgICAgICAgJ2Zsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudzsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxuXG4gICAgICAgICAgICAnaWYgKCBmb2dUeXBlID09IDEgKSB7JyxcblxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTsnLFxuXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxuXG4gICAgICAgICAgICAnY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1OycsXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7JyxcbiAgICAgICAgICAgICdmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXG5cbiAgICAgICAgICAgICd9JyxcblxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7JyxcblxuICAgICAgICAgICAgJ30nLFxuXG4gICAgICAgICAgICAnfSdcblxuICAgICAgICBdLmpvaW4oICdcXG4nICkgKTtcblxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcblxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICAgICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG4gICAgICAgIGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBiLnogLSBhLno7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL0dlb21ldHJ5VXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkdlb21ldHJ5VXRpbHMgPSB7XG5cbiAgICBtZXJnZTogZnVuY3Rpb24oIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XG5cbiAgICAgICAgdmFyIG1hdHJpeDtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5Mi5tYXRyaXhBdXRvVXBkYXRlICYmIGdlb21ldHJ5Mi51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICAgICAgbWF0cml4ID0gZ2VvbWV0cnkyLm1hdHJpeDtcbiAgICAgICAgICAgIGdlb21ldHJ5MiA9IGdlb21ldHJ5Mi5nZW9tZXRyeTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2VvbWV0cnkxLm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApO1xuXG4gICAgfSxcblxuICAgIGNlbnRlcjogZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9JbWFnZVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIERhb3NoZW5nIE11IC8gaHR0cHM6Ly9naXRodWIuY29tL0Rhb3NoZW5nTXUvXG4gKi9cblxuVEhSRUUuSW1hZ2VVdGlscyA9IHtcblxuICAgIGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cbiAgICBsb2FkVGV4dHVyZTogZnVuY3Rpb24oIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcbiAgICAgICAgbG9hZGVyLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCB1bmRlZmluZWQsIG1hcHBpbmcgKTtcblxuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggaW1hZ2UgKSB7XG5cbiAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICAgIH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG4gICAgICAgIH0gKTtcblxuICAgICAgICB0ZXh0dXJlLnNvdXJjZUZpbGUgPSB1cmw7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgICB9LFxuXG4gICAgbG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiggYXJyYXksIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgaW1hZ2VzID0gW107XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuICAgICAgICBsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcgKTtcblxuICAgICAgICB2YXIgbG9hZGVkID0gMDtcblxuICAgICAgICB2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiggaSApIHtcblxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoIGFycmF5WyBpIF0sIGZ1bmN0aW9uKCBpbWFnZSApIHtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcblxuICAgICAgICAgICAgICAgIGxvYWRlZCArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSApIHtcblxuICAgICAgICAgICAgbG9hZFRleHR1cmUoIGkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgICB9LFxuXG4gICAgbG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxuXG4gICAgfSxcblxuICAgIGxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxuXG4gICAgfSxcblxuICAgIGdldE5vcm1hbE1hcDogZnVuY3Rpb24oIGltYWdlLCBkZXB0aCApIHtcblxuICAgICAgICAvLyBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvbGFiL2hlaWdodG5vcm1hbC9cblxuICAgICAgICB2YXIgY3Jvc3MgPSBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICAgICAgcmV0dXJuIFsgYVsgMSBdICogYlsgMiBdIC0gYVsgMiBdICogYlsgMSBdLCBhWyAyIF0gKiBiWyAwIF0gLSBhWyAwIF0gKiBiWyAyIF0sIGFbIDAgXSAqIGJbIDEgXSAtIGFbIDEgXSAqIGJbIDAgXSBdO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN1YnRyYWN0ID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBbIGFbIDAgXSAtIGJbIDAgXSwgYVsgMSBdIC0gYlsgMSBdLCBhWyAyIF0gLSBiWyAyIF0gXTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiggYSApIHtcblxuICAgICAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoIGFbIDAgXSAqIGFbIDAgXSArIGFbIDEgXSAqIGFbIDEgXSArIGFbIDIgXSAqIGFbIDIgXSApO1xuICAgICAgICAgICAgcmV0dXJuIFsgYVsgMCBdIC8gbCwgYVsgMSBdIC8gbCwgYVsgMiBdIC8gbCBdO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgZGVwdGggPSBkZXB0aCB8IDE7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwICk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgd2lkdGgsIGhlaWdodCApLmRhdGE7XG4gICAgICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggd2lkdGgsIGhlaWdodCApO1xuICAgICAgICB2YXIgb3V0cHV0ID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICAgICAgZm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKyApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbHkgPSB5IC0gMSA8IDAgPyAwIDogeSAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHV5ID0geSArIDEgPiBoZWlnaHQgLSAxID8gaGVpZ2h0IC0gMSA6IHkgKyAxO1xuICAgICAgICAgICAgICAgIHZhciBseCA9IHggLSAxIDwgMCA/IDAgOiB4IC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgdXggPSB4ICsgMSA+IHdpZHRoIC0gMSA/IHdpZHRoIC0gMSA6IHggKyAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBbIDAsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAtMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIC0xLCAtMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAwLCAtMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIDEsIC0xLCBkYXRhWyAoIGx5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIDEsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAxLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIDAsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAtMSwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblxuICAgICAgICAgICAgICAgIHZhciBub3JtYWxzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbnVtX3BvaW50czsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2MSA9IHBvaW50c1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSBwb2ludHNbICggaSArIDEgKSAlIG51bV9wb2ludHMgXTtcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBzdWJ0cmFjdCggdjEsIG9yaWdpbiApO1xuICAgICAgICAgICAgICAgICAgICB2MiA9IHN1YnRyYWN0KCB2Miwgb3JpZ2luICk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHMucHVzaCggbm9ybWFsaXplKCBjcm9zcyggdjEsIHYyICkgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFsgMCwgMCwgMCBdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBub3JtYWxbIDAgXSArPSBub3JtYWxzWyBpIF1bIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsWyAxIF0gKz0gbm9ybWFsc1sgaSBdWyAxIF07XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFsgMiBdICs9IG5vcm1hbHNbIGkgXVsgMiBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9ybWFsWyAwIF0gLz0gbm9ybWFscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbm9ybWFsWyAxIF0gLz0gbm9ybWFscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbm9ybWFsWyAyIF0gLz0gbm9ybWFscy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKCB5ICogd2lkdGggKyB4ICkgKiA0O1xuXG4gICAgICAgICAgICAgICAgb3V0cHV0WyBpZHggXSA9ICggKCBub3JtYWxbIDAgXSArIDEuMCApIC8gMi4wICogMjU1ICkgfCAwO1xuICAgICAgICAgICAgICAgIG91dHB1dFsgaWR4ICsgMSBdID0gKCAoIG5vcm1hbFsgMSBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XG4gICAgICAgICAgICAgICAgb3V0cHV0WyBpZHggKyAyIF0gPSAoIG5vcm1hbFsgMiBdICogMjU1ICkgfCAwO1xuICAgICAgICAgICAgICAgIG91dHB1dFsgaWR4ICsgMyBdID0gMjU1O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzO1xuXG4gICAgfSxcblxuICAgIGdlbmVyYXRlRGF0YVRleHR1cmU6IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCBjb2xvciApIHtcblxuICAgICAgICB2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCAzICogc2l6ZSApO1xuXG4gICAgICAgIHZhciByID0gTWF0aC5mbG9vciggY29sb3IuciAqIDI1NSApO1xuICAgICAgICB2YXIgZyA9IE1hdGguZmxvb3IoIGNvbG9yLmcgKiAyNTUgKTtcbiAgICAgICAgdmFyIGIgPSBNYXRoLmZsb29yKCBjb2xvci5iICogMjU1ICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrICkge1xuXG4gICAgICAgICAgICBkYXRhWyBpICogMyBdID0gcjtcbiAgICAgICAgICAgIGRhdGFbIGkgKiAzICsgMSBdID0gZztcbiAgICAgICAgICAgIGRhdGFbIGkgKiAzICsgMiBdID0gYjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIFRIUkVFLlJHQkZvcm1hdCApO1xuICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL1NjZW5lVXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNjZW5lVXRpbHMgPSB7XG5cbiAgICBjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcblxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG5cbiAgICB9LFxuXG4gICAgZGV0YWNoOiBmdW5jdGlvbiggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XG5cbiAgICAgICAgY2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgICAgICBwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xuICAgICAgICBzY2VuZS5hZGQoIGNoaWxkICk7XG5cbiAgICB9LFxuXG4gICAgYXR0YWNoOiBmdW5jdGlvbiggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XG5cbiAgICAgICAgdmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICAgIG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICAgICAgY2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG4gICAgICAgIHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcbiAgICAgICAgcGFyZW50LmFkZCggY2hpbGQgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL0ZvbnRVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRm9yIFRleHQgb3BlcmF0aW9ucyBpbiB0aHJlZS5qcyAoU2VlIFRleHRHZW9tZXRyeSlcbiAqXG4gKiBJdCB1c2VzIHRlY2huaXF1ZXMgdXNlZCBpbjpcbiAqXG4gKlx0VHJpYW5ndWxhdGlvbiBwb3J0ZWQgZnJvbSBBUzNcbiAqXHRcdFNpbXBsZSBQb2x5Z29uIFRyaWFuZ3VsYXRpb25cbiAqXHRcdGh0dHA6Ly9hY3Rpb25zbmlwcGV0LmNvbS8/cD0xNDYyXG4gKlxuICogXHRBIE1ldGhvZCB0byB0cmlhbmd1bGF0ZSBzaGFwZXMgd2l0aCBob2xlc1xuICpcdFx0aHR0cDovL3d3dy5zYWtyaS5uZXQvYmxvZy8yMDA5LzA2LzEyL2FuLWFwcHJvYWNoLXRvLXRyaWFuZ3VsYXRpbmctcG9seWdvbnMtd2l0aC1ob2xlcy9cbiAqXG4gKi9cblxuVEhSRUUuRm9udFV0aWxzID0ge1xuXG4gICAgZmFjZXM6IHt9LFxuXG4gICAgLy8gSnVzdCBmb3Igbm93LiBmYWNlW3dlaWdodF1bc3R5bGVdXG5cbiAgICBmYWNlOiAnaGVsdmV0aWtlcicsXG4gICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgc2l6ZTogMTUwLFxuICAgIGRpdmlzaW9uczogMTAsXG5cbiAgICBnZXRGYWNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWNlc1sgdGhpcy5mYWNlLnRvTG93ZXJDYXNlKCkgXVsgdGhpcy53ZWlnaHQgXVsgdGhpcy5zdHlsZSBdO1xuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKCBlICkge1xuXG4gICAgICAgICAgICB0aHJvdyBcIlRoZSBmb250IFwiICsgdGhpcy5mYWNlICsgXCIgd2l0aCBcIiArIHRoaXMud2VpZ2h0ICsgXCIgd2VpZ2h0IGFuZCBcIiArIHRoaXMuc3R5bGUgKyBcIiBzdHlsZSBpcyBtaXNzaW5nLlwiXG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGxvYWRGYWNlOiBmdW5jdGlvbiggZGF0YSApIHtcblxuICAgICAgICB2YXIgZmFtaWx5ID0gZGF0YS5mYW1pbHlOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgdmFyIFRocmVlRm9udCA9IHRoaXM7XG5cbiAgICAgICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gfHwge307XG5cbiAgICAgICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSB8fCB7fTtcbiAgICAgICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF1bIGRhdGEuY3NzRm9udFN0eWxlIF0gPSBkYXRhO1xuXG4gICAgICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH0sXG5cbiAgICBkcmF3VGV4dDogZnVuY3Rpb24oIHRleHQgKSB7XG5cbiAgICAgICAgLy8gUmVuZGVyVGV4dFxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZ2V0RmFjZSgpLFxuICAgICAgICAgICAgc2NhbGUgPSB0aGlzLnNpemUgLyBmYWNlLnJlc29sdXRpb24sXG4gICAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgICAgY2hhcnMgPSBTdHJpbmcoIHRleHQgKS5zcGxpdCggJycgKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcblxuICAgICAgICB2YXIgZm9udFBhdGhzID0gW107XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5leHRyYWN0R2x5cGhQb2ludHMoIGNoYXJzWyBpIF0sIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKTtcbiAgICAgICAgICAgIG9mZnNldCArPSByZXQub2Zmc2V0O1xuXG4gICAgICAgICAgICBmb250UGF0aHMucHVzaCggcmV0LnBhdGggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB3aWR0aFxuXG4gICAgICAgIHZhciB3aWR0aCA9IG9mZnNldCAvIDI7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZvciAoIHAgPSAwOyBwIDwgYWxsUHRzLmxlbmd0aDsgcCsrICkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBcdGFsbFB0c1sgcCBdLnggLT0gd2lkdGg7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvL3ZhciBleHRyYWN0ID0gdGhpcy5leHRyYWN0UG9pbnRzKCBhbGxQdHMsIGNoYXJhY3RlclB0cyApO1xuICAgICAgICAvL2V4dHJhY3QuY29udG91ciA9IGFsbFB0cztcblxuICAgICAgICAvL2V4dHJhY3QucGF0aHMgPSBmb250UGF0aHM7XG4gICAgICAgIC8vZXh0cmFjdC5vZmZzZXQgPSB3aWR0aDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aHM6IGZvbnRQYXRocyxcbiAgICAgICAgICAgIG9mZnNldDogd2lkdGhcbiAgICAgICAgfTtcblxuICAgIH0sXG5cblxuXG5cbiAgICBleHRyYWN0R2x5cGhQb2ludHM6IGZ1bmN0aW9uKCBjLCBmYWNlLCBzY2FsZSwgb2Zmc2V0LCBwYXRoICkge1xuXG4gICAgICAgIHZhciBwdHMgPSBbXTtcblxuICAgICAgICB2YXIgaSwgaTIsIGRpdmlzaW9ucyxcbiAgICAgICAgICAgIG91dGxpbmUsIGFjdGlvbiwgbGVuZ3RoLFxuICAgICAgICAgICAgc2NhbGVYLCBzY2FsZVksXG4gICAgICAgICAgICB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MixcbiAgICAgICAgICAgIGxhc3RlLFxuICAgICAgICAgICAgZ2x5cGggPSBmYWNlLmdseXBoc1sgYyBdIHx8IGZhY2UuZ2x5cGhzWyAnPycgXTtcblxuICAgICAgICBpZiAoICFnbHlwaCApIHJldHVybjtcblxuICAgICAgICBpZiAoIGdseXBoLm8gKSB7XG5cbiAgICAgICAgICAgIG91dGxpbmUgPSBnbHlwaC5fY2FjaGVkT3V0bGluZSB8fCAoIGdseXBoLl9jYWNoZWRPdXRsaW5lID0gZ2x5cGguby5zcGxpdCggJyAnICkgKTtcbiAgICAgICAgICAgIGxlbmd0aCA9IG91dGxpbmUubGVuZ3RoO1xuXG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZTtcbiAgICAgICAgICAgIHNjYWxlWSA9IHNjYWxlO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgKSB7XG5cbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBvdXRsaW5lWyBpKysgXTtcblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coIGFjdGlvbiApO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICggYWN0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIFRvXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5tb3ZlVG8oIHgsIHkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIFRvXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKCB4LCB5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVhZHJhdGljQ3VydmVUb1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGNweDEsIGNweTEsIGNweCwgY3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxhc3RlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1YmljIEJlemllciBDdXJ2ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4MiA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5MiA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGNweCwgY3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxhc3RlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXQ6IGdseXBoLmhhICogc2NhbGUsXG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH07XG5cbiAgICB9XG5cbn07XG5cblxuVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzID0gZnVuY3Rpb24oIHRleHQsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAvLyBQYXJhbWV0ZXJzXG5cbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgIHZhciBzaXplID0gcGFyYW1ldGVycy5zaXplICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNpemUgOiAxMDA7XG4gICAgdmFyIGN1cnZlU2VnbWVudHMgPSBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyA6IDQ7XG5cbiAgICB2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5mb250IDogJ2hlbHZldGlrZXInO1xuICAgIHZhciB3ZWlnaHQgPSBwYXJhbWV0ZXJzLndlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53ZWlnaHQgOiAnbm9ybWFsJztcbiAgICB2YXIgc3R5bGUgPSBwYXJhbWV0ZXJzLnN0eWxlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0eWxlIDogJ25vcm1hbCc7XG5cbiAgICBUSFJFRS5Gb250VXRpbHMuc2l6ZSA9IHNpemU7XG4gICAgVEhSRUUuRm9udFV0aWxzLmRpdmlzaW9ucyA9IGN1cnZlU2VnbWVudHM7XG5cbiAgICBUSFJFRS5Gb250VXRpbHMuZmFjZSA9IGZvbnQ7XG4gICAgVEhSRUUuRm9udFV0aWxzLndlaWdodCA9IHdlaWdodDtcbiAgICBUSFJFRS5Gb250VXRpbHMuc3R5bGUgPSBzdHlsZTtcblxuICAgIC8vIEdldCBhIEZvbnQgZGF0YSBqc29uIG9iamVjdFxuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5Gb250VXRpbHMuZHJhd1RleHQoIHRleHQgKTtcblxuICAgIHZhciBwYXRocyA9IGRhdGEucGF0aHM7XG4gICAgdmFyIHNoYXBlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIHAgPSAwLCBwbCA9IHBhdGhzLmxlbmd0aDsgcCA8IHBsOyBwKysgKSB7XG5cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGVzO1xuXG59O1xuXG5cbi8qKlxuICogVGhpcyBjb2RlIGlzIGEgcXVpY2sgcG9ydCBvZiBjb2RlIHdyaXR0ZW4gaW4gQysrIHdoaWNoIHdhcyBzdWJtaXR0ZWQgdG9cbiAqIGZsaXBjb2RlLmNvbSBieSBKb2huIFcuIFJhdGNsaWZmICAvLyBKdWx5IDIyLCAyMDAwXG4gKiBTZWUgb3JpZ2luYWwgY29kZSBhbmQgbW9yZSBpbmZvcm1hdGlvbiBoZXJlOlxuICogaHR0cDovL3d3dy5mbGlwY29kZS5jb20vYXJjaGl2ZXMvRWZmaWNpZW50X1BvbHlnb25fVHJpYW5ndWxhdGlvbi5zaHRtbFxuICpcbiAqIHBvcnRlZCB0byBhY3Rpb25zY3JpcHQgYnkgWmV2YW4gUm9zc2VyXG4gKiB3d3cuYWN0aW9uc25pcHBldC5jb21cbiAqXG4gKiBwb3J0ZWQgdG8gamF2YXNjcmlwdCBieSBKb3NodWEgS29vXG4gKiBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICovXG5cblxuKCBmdW5jdGlvbiggbmFtZXNwYWNlICkge1xuXG4gICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAvLyB0YWtlcyBpbiBhbiBjb250b3VyIGFycmF5IGFuZCByZXR1cm5zXG5cbiAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uKCBjb250b3VyLCBpbmRpY2VzICkge1xuXG4gICAgICAgIHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCBuIDwgMyApIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHZlcnRzID0gW10sXG4gICAgICAgICAgICB2ZXJ0SW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIC8qIHdlIHdhbnQgYSBjb3VudGVyLWNsb2Nrd2lzZSBwb2x5Z29uIGluIHZlcnRzICovXG5cbiAgICAgICAgdmFyIHUsIHYsIHc7XG5cbiAgICAgICAgaWYgKCBhcmVhKCBjb250b3VyICkgPiAwLjAgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHYgPSAwOyB2IDwgbjsgdisrICkgdmVydHNbIHYgXSA9IHY7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZm9yICggdiA9IDA7IHYgPCBuOyB2KysgKSB2ZXJ0c1sgdiBdID0gKCBuIC0gMSApIC0gdjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG52ID0gbjtcblxuICAgICAgICAvKiAgcmVtb3ZlIG52IC0gMiB2ZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lICovXG5cbiAgICAgICAgdmFyIGNvdW50ID0gMiAqIG52OyAvKiBlcnJvciBkZXRlY3Rpb24gKi9cblxuICAgICAgICBmb3IgKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xuXG4gICAgICAgICAgICAvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xuXG4gICAgICAgICAgICBpZiAoICggY291bnQtLSApIDw9IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyoqIFRyaWFuZ3VsYXRlOiBFUlJPUiAtIHByb2JhYmxlIGJhZCBwb2x5Z29uIVxuXG4gICAgICAgICAgICAgICAgLy90aHJvdyAoIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcbiAgICAgICAgICAgICAgICAvL3JldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkZvbnRVdGlsczogV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hIGluIFRyaWFuZ3VsYXRlLnByb2Nlc3MoKScgKTtcblxuICAgICAgICAgICAgICAgIGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIHRocmVlIGNvbnNlY3V0aXZlIHZlcnRpY2VzIGluIGN1cnJlbnQgcG9seWdvbiwgPHUsdix3PiAqL1xuXG4gICAgICAgICAgICB1ID0gdjtcbiAgICAgICAgICAgIGlmICggbnYgPD0gdSApIHUgPSAwOyAvKiBwcmV2aW91cyAqL1xuICAgICAgICAgICAgdiA9IHUgKyAxO1xuICAgICAgICAgICAgaWYgKCBudiA8PSB2ICkgdiA9IDA7IC8qIG5ldyB2ICAgICovXG4gICAgICAgICAgICB3ID0gdiArIDE7XG4gICAgICAgICAgICBpZiAoIG52IDw9IHcgKSB3ID0gMDsgLyogbmV4dCAgICAgKi9cblxuICAgICAgICAgICAgaWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBjLCBzLCB0O1xuXG4gICAgICAgICAgICAgICAgLyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cblxuICAgICAgICAgICAgICAgIGEgPSB2ZXJ0c1sgdSBdO1xuICAgICAgICAgICAgICAgIGIgPSB2ZXJ0c1sgdiBdO1xuICAgICAgICAgICAgICAgIGMgPSB2ZXJ0c1sgdyBdO1xuXG4gICAgICAgICAgICAgICAgLyogb3V0cHV0IFRyaWFuZ2xlICovXG5cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCggWyBjb250b3VyWyBhIF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRvdXJbIGIgXSxcbiAgICAgICAgICAgICAgICAgICAgY29udG91clsgYyBdXG4gICAgICAgICAgICAgICAgXSApO1xuXG5cbiAgICAgICAgICAgICAgICB2ZXJ0SW5kaWNlcy5wdXNoKCBbIHZlcnRzWyB1IF0sIHZlcnRzWyB2IF0sIHZlcnRzWyB3IF0gXSApO1xuXG4gICAgICAgICAgICAgICAgLyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cblxuICAgICAgICAgICAgICAgIGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcysrLCB0KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmVydHNbIHMgXSA9IHZlcnRzWyB0IF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBudi0tO1xuXG4gICAgICAgICAgICAgICAgLyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cblxuICAgICAgICAgICAgICAgIGNvdW50ID0gMiAqIG52O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH07XG5cbiAgICAvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cbiAgICB2YXIgYXJlYSA9IGZ1bmN0aW9uKCBjb250b3VyICkge1xuXG4gICAgICAgIHZhciBuID0gY29udG91ci5sZW5ndGg7XG4gICAgICAgIHZhciBhID0gMC4wO1xuXG4gICAgICAgIGZvciAoIHZhciBwID0gbiAtIDEsIHEgPSAwOyBxIDwgbjsgcCA9IHErKyApIHtcblxuICAgICAgICAgICAgYSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgKiAwLjU7XG5cbiAgICB9O1xuXG4gICAgdmFyIHNuaXAgPSBmdW5jdGlvbiggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XG5cbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHZhciBheCwgYXksIGJ4LCBieTtcbiAgICAgICAgdmFyIGN4LCBjeSwgcHgsIHB5O1xuXG4gICAgICAgIGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XG4gICAgICAgIGF5ID0gY29udG91clsgdmVydHNbIHUgXSBdLnk7XG5cbiAgICAgICAgYnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcbiAgICAgICAgYnkgPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueTtcblxuICAgICAgICBjeCA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS54O1xuICAgICAgICBjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xuXG4gICAgICAgIGlmICggRVBTSUxPTiA+ICggKCAoIGJ4IC0gYXggKSAqICggY3kgLSBheSApICkgLSAoICggYnkgLSBheSApICogKCBjeCAtIGF4ICkgKSApICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xuICAgICAgICB2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcbiAgICAgICAgdmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XG5cbiAgICAgICAgYVggPSBjeCAtIGJ4O1xuICAgICAgICBhWSA9IGN5IC0gYnk7XG4gICAgICAgIGJYID0gYXggLSBjeDtcbiAgICAgICAgYlkgPSBheSAtIGN5O1xuICAgICAgICBjWCA9IGJ4IC0gYXg7XG4gICAgICAgIGNZID0gYnkgLSBheTtcblxuICAgICAgICBmb3IgKCBwID0gMDsgcCA8IG47IHArKyApIHtcblxuICAgICAgICAgICAgcHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueDtcbiAgICAgICAgICAgIHB5ID0gY29udG91clsgdmVydHNbIHAgXSBdLnk7XG5cbiAgICAgICAgICAgIGlmICggKCAoIHB4ID09PSBheCApICYmICggcHkgPT09IGF5ICkgKSB8fFxuICAgICAgICAgICAgICAgICggKCBweCA9PT0gYnggKSAmJiAoIHB5ID09PSBieSApICkgfHxcbiAgICAgICAgICAgICAgICAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGFweCA9IHB4IC0gYXg7XG4gICAgICAgICAgICBhcHkgPSBweSAtIGF5O1xuICAgICAgICAgICAgYnB4ID0gcHggLSBieDtcbiAgICAgICAgICAgIGJweSA9IHB5IC0gYnk7XG4gICAgICAgICAgICBjcHggPSBweCAtIGN4O1xuICAgICAgICAgICAgY3B5ID0gcHkgLSBjeTtcblxuICAgICAgICAgICAgLy8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG4gICAgICAgICAgICBhQ1JPU1NicCA9IGFYICogYnB5IC0gYVkgKiBicHg7XG4gICAgICAgICAgICBjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XG4gICAgICAgICAgICBiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cbiAgICAgICAgICAgIGlmICggKCBhQ1JPU1NicCA+PSAtRVBTSUxPTiApICYmICggYkNST1NTY3AgPj0gLUVQU0lMT04gKSAmJiAoIGNDUk9TU2FwID49IC1FUFNJTE9OICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfTtcblxuXG4gICAgbmFtZXNwYWNlLlRyaWFuZ3VsYXRlID0gcHJvY2VzcztcbiAgICBuYW1lc3BhY2UuVHJpYW5ndWxhdGUuYXJlYSA9IGFyZWE7XG5cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuXG59ICkoIFRIUkVFLkZvbnRVdGlscyApO1xuXG4vLyBUbyB1c2UgdGhlIHR5cGVmYWNlLmpzIGZhY2UgZmlsZXMsIGhvb2sgdXAgdGhlIEFQSVxuXG5USFJFRS50eXBlZmFjZV9qcyA9IHtcbiAgICBmYWNlczogVEhSRUUuRm9udFV0aWxzLmZhY2VzLFxuICAgIGxvYWRGYWNlOiBUSFJFRS5Gb250VXRpbHMubG9hZEZhY2Vcbn07XG5pZiAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApIHNlbGYuX3R5cGVmYWNlX2pzID0gVEhSRUUudHlwZWZhY2VfanM7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpby5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW8gPSBmdW5jdGlvbiggbGlzdGVuZXIgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQXVkaW8nO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcbiAgICB0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICB0aGlzLnNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcblxuICAgIHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG4gICAgdGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG4gICAgdGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XG5cbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG5cbiAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXVkaW87XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oIGZpbGUgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oICdHRVQnLCBmaWxlLCB0cnVlICk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oIGUgKSB7XG5cbiAgICAgICAgc2NvcGUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIHRoaXMucmVzcG9uc2UsIGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLnNvdXJjZS5idWZmZXIgPSBidWZmZXI7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuYXV0b3BsYXkgKSBzY29wZS5wbGF5KCk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblxuICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLnNvdXJjZS5idWZmZXI7XG4gICAgc291cmNlLmxvb3AgPSB0aGlzLnNvdXJjZS5sb29wO1xuICAgIHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcbiAgICBzb3VyY2Uuc3RhcnQoIDAsIHRoaXMuc3RhcnRUaW1lICk7XG4gICAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICB0aGlzLmNvbm5lY3QoKTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLnNvdXJjZS5zdG9wKCk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLnNvdXJjZS5zdG9wKCk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCB0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG4gICAgICAgIHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmICggdGhpcy5maWx0ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuICAgICAgICB0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLnBhbm5lciApO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmZpbHRlciA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICB0aGlzLmZpbHRlciA9IHZhbHVlO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xuXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLnBsYXliYWNrUmF0ZTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUub25FbmRlZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICB0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRMb29wID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubG9vcDtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgdGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0Um9sbG9mZkZhY3RvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0Vm9sdW1lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuICAgICAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuICAgICAgICBwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICB0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXG4gICAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpb0xpc3RlbmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BdWRpb0xpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBuZXcoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvTGlzdGVuZXI7XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgb3JpZW50YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuICAgICAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XG4gICAgICAgIHZhciB1cCA9IHRoaXMudXA7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG4gICAgICAgIG9yaWVudGF0aW9uLnNldCggMCwgMCwgLTEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgICBsaXN0ZW5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuICAgICAgICBsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xuXG4gICAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3RcbiAqXG4gKiBTb21lIGNvbW1vbiBvZiBDdXJ2ZSBtZXRob2RzXG4gKiAuZ2V0UG9pbnQodCksIGdldFRhbmdlbnQodClcbiAqIC5nZXRQb2ludEF0KHUpLCBnZXRUYWdlbnRBdCh1KVxuICogLmdldFBvaW50cygpLCAuZ2V0U3BhY2VkUG9pbnRzKClcbiAqIC5nZXRMZW5ndGgoKVxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxuICpcbiAqIFRoaXMgZm9sbG93aW5nIGNsYXNzZXMgc3ViY2xhc3NlcyBUSFJFRS5DdXJ2ZTpcbiAqXG4gKiAtLSAyZCBjbGFzc2VzIC0tXG4gKiBUSFJFRS5MaW5lQ3VydmVcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZVxuICogVEhSRUUuQXJjQ3VydmVcbiAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxuICpcbiAqIC0tIDNkIGNsYXNzZXMgLS1cbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLlNwbGluZUN1cnZlM1xuICogVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzXG4gKlxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aFxuICpcbiAqKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZSA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG4vLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcbi8vXHQtIHQgWzAgLi4gMV1cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuQ3VydmU6IFdhcm5pbmcsIGdldFBvaW50KCkgbm90IGltcGxlbWVudGVkIVwiICk7XG4gICAgcmV0dXJuIG51bGw7XG5cbn07XG5cbi8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuLy8gLSB1IFswIC4uIDFdXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24oIHUgKSB7XG5cbiAgICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xuXG59O1xuXG4vLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG4gICAgdmFyIGQsIHB0cyA9IFtdO1xuXG4gICAgZm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkKysgKSB7XG5cbiAgICAgICAgcHRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHB0cztcblxufTtcblxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG4gICAgdmFyIGQsIHB0cyA9IFtdO1xuXG4gICAgZm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkKysgKSB7XG5cbiAgICAgICAgcHRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcHRzO1xuXG59O1xuXG4vLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuICAgIHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcblxufTtcblxuLy8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aHMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgaWYgKCAhZGl2aXNpb25zICkgZGl2aXNpb25zID0gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgPyAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA6IDIwMDtcblxuICAgIGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMgJiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKSAmJiAhdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XG5cbiAgICB9XG5cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgY2FjaGUgPSBbXTtcbiAgICB2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcbiAgICB2YXIgcCwgc3VtID0gMDtcblxuICAgIGNhY2hlLnB1c2goIDAgKTtcblxuICAgIGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCsrICkge1xuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldFBvaW50KCBwIC8gZGl2aXNpb25zICk7XG4gICAgICAgIHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcbiAgICAgICAgY2FjaGUucHVzaCggc3VtICk7XG4gICAgICAgIGxhc3QgPSBjdXJyZW50O1xuXG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcblxuICAgIHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblxufTtcblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUudXBkYXRlQXJjTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5nZXRMZW5ndGhzKCk7XG5cbn07XG5cbi8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFV0b1RtYXBwaW5nID0gZnVuY3Rpb24oIHUsIGRpc3RhbmNlICkge1xuXG4gICAgdmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblxuICAgIHZhciBpID0gMCxcbiAgICAgICAgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcblxuICAgIHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG4gICAgaWYgKCBkaXN0YW5jZSApIHtcblxuICAgICAgICB0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICB0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cbiAgICB9XG5cbiAgICAvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXG5cbiAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgaGlnaCA9IGlsIC0gMSxcbiAgICAgICAgY29tcGFyaXNvbjtcblxuICAgIHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XG5cbiAgICAgICAgaSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cbiAgICAgICAgY29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuICAgICAgICBpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG4gICAgICAgICAgICBsb3cgPSBpICsgMTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcblxuICAgICAgICAgICAgaGlnaCA9IGkgLSAxO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGhpZ2ggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIERPTkVcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpID0gaGlnaDtcblxuICAgIC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcblxuICAgIGlmICggYXJjTGVuZ3Roc1sgaSBdID09PSB0YXJnZXRBcmNMZW5ndGggKSB7XG5cbiAgICAgICAgdmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcbiAgICAgICAgcmV0dXJuIHQ7XG5cbiAgICB9XG5cbiAgICAvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuXG4gICAgdmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcbiAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcblxuICAgIC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cbiAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cbiAgICB2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcblxuICAgIHJldHVybiB0O1xuXG59O1xuXG4vLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG4vLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG4vLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuLy8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIGRlbHRhID0gMC4wMDAxO1xuICAgIHZhciB0MSA9IHQgLSBkZWx0YTtcbiAgICB2YXIgdDIgPSB0ICsgZGVsdGE7XG5cbiAgICAvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cbiAgICBpZiAoIHQxIDwgMCApIHQxID0gMDtcbiAgICBpZiAoIHQyID4gMSApIHQyID0gMTtcblxuICAgIHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuICAgIHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xuXG4gICAgdmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YiggcHQxICk7XG4gICAgcmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcblxufTtcblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudEF0ID0gZnVuY3Rpb24oIHUgKSB7XG5cbiAgICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XG5cbn07XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0VXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmUuVXRpbHMgPSB7XG5cbiAgICB0YW5nZW50UXVhZHJhdGljQmV6aWVyOiBmdW5jdGlvbiggdCwgcDAsIHAxLCBwMiApIHtcblxuICAgICAgICByZXR1cm4gMiAqICggMSAtIHQgKSAqICggcDEgLSBwMCApICsgMiAqIHQgKiAoIHAyIC0gcDEgKTtcblxuICAgIH0sXG5cbiAgICAvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcblxuICAgIHRhbmdlbnRDdWJpY0JlemllcjogZnVuY3Rpb24oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgICAgIHJldHVybiAtMyAqIHAwICogKCAxIC0gdCApICogKCAxIC0gdCApICtcbiAgICAgICAgICAgIDMgKiBwMSAqICggMSAtIHQgKSAqICggMSAtIHQgKSAtIDYgKiB0ICogcDEgKiAoIDEgLSB0ICkgK1xuICAgICAgICAgICAgNiAqIHQgKiBwMiAqICggMSAtIHQgKSAtIDMgKiB0ICogdCAqIHAyICtcbiAgICAgICAgICAgIDMgKiB0ICogdCAqIHAzO1xuXG4gICAgfSxcblxuICAgIHRhbmdlbnRTcGxpbmU6IGZ1bmN0aW9uKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgICAgICAvLyBUbyBjaGVjayBpZiBteSBmb3JtdWxhcyBhcmUgY29ycmVjdFxuXG4gICAgICAgIHZhciBoMDAgPSA2ICogdCAqIHQgLSA2ICogdDsgLy8gZGVyaXZlZCBmcm9tIDJ0XjMg4oiSIDN0XjIgKyAxXG4gICAgICAgIHZhciBoMTAgPSAzICogdCAqIHQgLSA0ICogdCArIDE7IC8vIHReMyDiiJIgMnReMiArIHRcbiAgICAgICAgdmFyIGgwMSA9IC02ICogdCAqIHQgKyA2ICogdDsgLy8g4oiSIDJ0MyArIDN0MlxuICAgICAgICB2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7IC8vIHQzIOKIkiB0MlxuXG4gICAgICAgIHJldHVybiBoMDAgKyBoMTAgKyBoMDEgKyBoMTE7XG5cbiAgICB9LFxuXG4gICAgLy8gQ2F0bXVsbC1Sb21cblxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cbiAgICAgICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XG4gICAgICAgIHZhciB2MSA9ICggcDMgLSBwMSApICogMC41O1xuICAgICAgICB2YXIgdDIgPSB0ICogdDtcbiAgICAgICAgdmFyIHQzID0gdCAqIHQyO1xuICAgICAgICByZXR1cm4gKCAyICogcDEgLSAyICogcDIgKyB2MCArIHYxICkgKiB0MyArICggLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gICAgfVxuXG59O1xuXG5cbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdDNEIEN1cnZlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xuXG5USFJFRS5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiggY29uc3RydWN0b3IsIGdldFBvaW50RnVuYyApIHtcblxuICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcblxuICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXG4gKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmVQYXRoID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmN1cnZlcyA9IFtdO1xuICAgIHRoaXMuYmVuZHMgPSBbXTtcblxuICAgIHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdXJ2ZVBhdGg7XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oIGN1cnZlICkge1xuXG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPXG4gICAgLy8gSWYgdGhlIGVuZGluZyBvZiBjdXJ2ZSBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBzdGFydGluZ1xuICAgIC8vIG9yIHRoZSBuZXh0IGN1cnZlLCB0aGVuLCB0aGlzIGlzIG5vdCBhIHJlYWwgcGF0aFxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblxuICAgIC8vIFRPRE8gVGVzdFxuICAgIC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXG4gICAgLy8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XG4gICAgdmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG4gICAgaWYgKCAhc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XG5cbiAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaCggbmV3IFRIUkVFLkxpbmVDdXJ2ZSggZW5kUG9pbnQsIHN0YXJ0UG9pbnQgKSApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cbi8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcbi8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuLy8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuLy8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG4vLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG4vLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcbiAgICB2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGRpZmYsIGN1cnZlO1xuXG4gICAgLy8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXG5cbiAgICB3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xuXG4gICAgICAgIGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcblxuICAgICAgICAgICAgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcbiAgICAgICAgICAgIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcblxuICAgICAgICAgICAgdmFyIHUgPSAxIC0gZGlmZiAvIGN1cnZlLmdldExlbmd0aCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcblxuICAgIC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG59O1xuXG4vKlxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG59OyovXG5cblxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG4gICAgcmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xuXG59O1xuXG4vLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cbi8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Q3VydmVMZW5ndGhzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cbiAgICBpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuICAgIH1cblxuICAgIC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG4gICAgLy8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cbiAgICB2YXIgbGVuZ3RocyA9IFtdLFxuICAgICAgICBzdW1zID0gMDtcbiAgICB2YXIgaSwgaWwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgc3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xuICAgICAgICBsZW5ndGhzLnB1c2goIHN1bXMgKTtcblxuICAgIH1cblxuICAgIHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcblxuICAgIHJldHVybiBsZW5ndGhzO1xuXG59O1xuXG5cblxuLy8gUmV0dXJucyBtaW4gYW5kIG1heCBjb29yZGluYXRlc1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcblxuICAgIHZhciBtYXhYLCBtYXhZLCBtYXhaO1xuICAgIHZhciBtaW5YLCBtaW5ZLCBtaW5aO1xuXG4gICAgbWF4WCA9IG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbWluWCA9IG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICB2YXIgcCwgaSwgaWwsIHN1bTtcblxuICAgIHZhciB2MyA9IHBvaW50c1sgMCBdIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMztcblxuICAgIHN1bSA9IHYzID8gbmV3IFRIUkVFLlZlY3RvcjMoKSA6IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBwID0gcG9pbnRzWyBpIF07XG5cbiAgICAgICAgaWYgKCBwLnggPiBtYXhYICkgbWF4WCA9IHAueDtcbiAgICAgICAgZWxzZSBpZiAoIHAueCA8IG1pblggKSBtaW5YID0gcC54O1xuXG4gICAgICAgIGlmICggcC55ID4gbWF4WSApIG1heFkgPSBwLnk7XG4gICAgICAgIGVsc2UgaWYgKCBwLnkgPCBtaW5ZICkgbWluWSA9IHAueTtcblxuICAgICAgICBpZiAoIHYzICkge1xuXG4gICAgICAgICAgICBpZiAoIHAueiA+IG1heFogKSBtYXhaID0gcC56O1xuICAgICAgICAgICAgZWxzZSBpZiAoIHAueiA8IG1pblogKSBtaW5aID0gcC56O1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdW0uYWRkKCBwICk7XG5cbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuXG4gICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgIG1pblk6IG1pblksXG4gICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgIG1heFk6IG1heFlcblxuICAgIH07XG5cbiAgICBpZiAoIHYzICkge1xuXG4gICAgICAgIHJldC5tYXhaID0gbWF4WjtcbiAgICAgICAgcmV0Lm1pblogPSBtaW5aO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3JlYXRlIEdlb21ldHJpZXMgSGVscGVyc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgdmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cbi8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbnQgc2FtcGxpbmcgYWxvbmcgdGhlIHBhdGhcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICB2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSwgcG9pbnRzWyBpIF0ueiB8fCAwICkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRCZW5kIC8gV3JhcCBIZWxwZXIgTWV0aG9kc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBXcmFwIHBhdGggLyBCZW5kIG1vZGlmaWVycz9cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGRXcmFwUGF0aCA9IGZ1bmN0aW9uKCBiZW5kcGF0aCApIHtcblxuICAgIHRoaXMuYmVuZHMucHVzaCggYmVuZHBhdGggKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cbiAgICB2YXIgb2xkUHRzID0gdGhpcy5nZXRQb2ludHMoIHNlZ21lbnRzICk7IC8vIGdldFBvaW50cyBnZXRTcGFjZWRQb2ludHNcbiAgICB2YXIgaSwgaWw7XG5cbiAgICBpZiAoICFiZW5kcyApIHtcblxuICAgICAgICBiZW5kcyA9IHRoaXMuYmVuZHM7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBiZW5kcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIG9sZFB0cyA9IHRoaXMuZ2V0V3JhcFBvaW50cyggb2xkUHRzLCBiZW5kc1sgaSBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2xkUHRzO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzID0gZnVuY3Rpb24oIHNlZ21lbnRzLCBiZW5kcyApIHtcblxuICAgIHZhciBvbGRQdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggc2VnbWVudHMgKTtcblxuICAgIHZhciBpLCBpbDtcblxuICAgIGlmICggIWJlbmRzICkge1xuXG4gICAgICAgIGJlbmRzID0gdGhpcy5iZW5kcztcblxuICAgIH1cblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgb2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvbGRQdHM7XG5cbn07XG5cbi8vIFRoaXMgcmV0dXJucyBnZXRQb2ludHMoKSBiZW5kL3dyYXBwZWQgYXJvdW5kIHRoZSBjb250b3VyIG9mIGEgcGF0aC5cbi8vIFJlYWQgaHR0cDovL3d3dy5wbGFuZXRjbGVnZy5jb20vcHJvamVjdHMvV2FycGluZ1RleHRUb1NwbGluZXMuaHRtbFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFdyYXBQb2ludHMgPSBmdW5jdGlvbiggb2xkUHRzLCBwYXRoICkge1xuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgIHZhciBpLCBpbCwgcCwgb2xkWCwgb2xkWSwgeE5vcm07XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBvbGRQdHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBwID0gb2xkUHRzWyBpIF07XG5cbiAgICAgICAgb2xkWCA9IHAueDtcbiAgICAgICAgb2xkWSA9IHAueTtcblxuICAgICAgICB4Tm9ybSA9IG9sZFggLyBib3VuZHMubWF4WDtcblxuICAgICAgICAvLyBJZiB1c2luZyBhY3R1YWwgZGlzdGFuY2UsIGZvciBsZW5ndGggPiBwYXRoLCByZXF1aXJlcyBsaW5lIGV4dHJ1c2lvbnNcbiAgICAgICAgLy94Tm9ybSA9IHBhdGguZ2V0VXRvVG1hcHBpbmcoeE5vcm0sIG9sZFgpOyAvLyAzIHN0eWxlcy4gMSkgd3JhcCBzdHJldGNoZWQuIDIpIHdyYXAgc3RyZXRjaCBieSBhcmMgbGVuZ3RoIDMpIHdhcnAgYnkgYWN0dWFsIGRpc3RhbmNlXG5cbiAgICAgICAgeE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKCB4Tm9ybSwgb2xkWCApO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBvdXQgb2YgYm91bmRzP1xuXG4gICAgICAgIHZhciBwYXRoUHQgPSBwYXRoLmdldFBvaW50KCB4Tm9ybSApO1xuICAgICAgICB2YXIgbm9ybWFsID0gcGF0aC5nZXRUYW5nZW50KCB4Tm9ybSApO1xuICAgICAgICBub3JtYWwuc2V0KCAtbm9ybWFsLnksIG5vcm1hbC54ICkubXVsdGlwbHlTY2FsYXIoIG9sZFkgKTtcblxuICAgICAgICBwLnggPSBwYXRoUHQueCArIG5vcm1hbC54O1xuICAgICAgICBwLnkgPSBwYXRoUHQueSArIG5vcm1hbC55O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvUGF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxuICpcbiAqKi9cblxuVEhSRUUuUGF0aCA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cbiAgICBUSFJFRS5DdXJ2ZVBhdGguY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5hY3Rpb25zID0gW107XG5cbiAgICBpZiAoIHBvaW50cyApIHtcblxuICAgICAgICB0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgKTtcblRIUkVFLlBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGF0aDtcblxuVEhSRUUuUGF0aEFjdGlvbnMgPSB7XG5cbiAgICBNT1ZFX1RPOiAnbW92ZVRvJyxcbiAgICBMSU5FX1RPOiAnbGluZVRvJyxcbiAgICBRVUFEUkFUSUNfQ1VSVkVfVE86ICdxdWFkcmF0aWNDdXJ2ZVRvJywgLy8gQmV6aWVyIHF1YWRyYXRpYyBjdXJ2ZVxuICAgIEJFWklFUl9DVVJWRV9UTzogJ2JlemllckN1cnZlVG8nLCAvLyBCZXppZXIgY3ViaWMgY3VydmVcbiAgICBDU1BMSU5FX1RIUlU6ICdzcGxpbmVUaHJ1JywgLy8gQ2F0bXVsbC1Sb20gc3BsaW5lXG4gICAgQVJDOiAnYXJjJywgLy8gQ2lyY2xlXG4gICAgRUxMSVBTRTogJ2VsbGlwc2UnXG59O1xuXG4vLyBUT0RPIENsZWFuIHVwIFBBVEggQVBJXG5cbi8vIENyZWF0ZSBwYXRoIHVzaW5nIHN0cmFpZ2h0IGxpbmVzIHRvIGNvbm5lY3QgYWxsIHBvaW50c1xuLy8gLSB2ZWN0b3JzOiBhcnJheSBvZiBWZWN0b3IyXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmZyb21Qb2ludHMgPSBmdW5jdGlvbiggdmVjdG9ycyApIHtcblxuICAgIHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcblxuICAgIGZvciAoIHZhciB2ID0gMSwgdmxlbiA9IHZlY3RvcnMubGVuZ3RoOyB2IDwgdmxlbjsgdisrICkge1xuXG4gICAgICAgIHRoaXMubGluZVRvKCB2ZWN0b3JzWyB2IF0ueCwgdmVjdG9yc1sgdiBdLnkgKTtcblxuICAgIH1cblxufTtcblxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7XG4gICAgICAgIGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTyxcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24oIHgsIHkgKSB7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkxpbmVDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7XG4gICAgICAgIGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTElORV9UTyxcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICB0aGlzLmFjdGlvbnMucHVzaCgge1xuICAgICAgICBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTyxcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1AxeCwgYUNQMXksXG4gICAgYUNQMngsIGFDUDJ5LFxuICAgIGFYLCBhWSApIHtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApICk7XG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7XG4gICAgICAgIGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5zcGxpbmVUaHJ1ID0gZnVuY3Rpb24oIHB0cyAvKkFycmF5IG9mIFZlY3RvciovICkge1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG4gICAgLy8tLS1cbiAgICB2YXIgbnB0cyA9IFsgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApIF07XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xuXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBucHRzICk7XG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7XG4gICAgICAgIGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSApO1xuXG59O1xuXG4vLyBGVVRVUkU6IENoYW5nZSB0aGUgQVBJIG9yIGZvbGxvdyBjYW52YXMgQVBJP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbiggYVgsIGFZLCBhUmFkaXVzLFxuICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgICB0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcbiAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiggYVgsIGFZLCBhUmFkaXVzLFxuICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgICB0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5lbGxpcHNlID0gZnVuY3Rpb24oIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgICB0aGlzLmFic2VsbGlwc2UoIGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xuXG59O1xuXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2VsbGlwc2UgPSBmdW5jdGlvbiggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuICAgIHZhciBhcmdzID0gW1xuICAgICAgICBhWCwgYVksXG4gICAgICAgIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsXG4gICAgICAgIGFDbG9ja3dpc2UsXG4gICAgICAgIGFSb3RhdGlvbiB8fCAwIC8vIGFSb3RhdGlvbiBpcyBvcHRpb25hbC5cbiAgICBdO1xuICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICAgIHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xuICAgIGFyZ3MucHVzaCggbGFzdFBvaW50LnggKTtcbiAgICBhcmdzLnB1c2goIGxhc3RQb2ludC55ICk7XG5cbiAgICB0aGlzLmFjdGlvbnMucHVzaCgge1xuICAgICAgICBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkVMTElQU0UsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XG5cbiAgICBpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcblxuICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGRpdmlzaW9uczsgaSsrICkge1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcblxuICAgICAgICAvL2lmKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcblxuICAgIH1cblxuICAgIC8vIGlmICggY2xvc2VkUGF0aCApIHtcbiAgICAvL1xuICAgIC8vIFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG4gICAgLy9cbiAgICAvLyB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuXG59O1xuXG4vKiBSZXR1cm4gYW4gYXJyYXkgb2YgdmVjdG9ycyBiYXNlZCBvbiBjb250b3VyIG9mIHRoZSBwYXRoICovXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XG5cbiAgICBpZiAoIHRoaXMudXNlU3BhY2VkUG9pbnRzICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCBjbG9zZWRQYXRoICk7XG5cbiAgICB9XG5cbiAgICBkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICB2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcbiAgICB2YXIgY3B4LCBjcHksIGNweDIsIGNweTIsIGNweDEsIGNweTEsIGNweDAsIGNweTAsXG4gICAgICAgIGxhc3RlLCBqLFxuICAgICAgICB0LCB0eCwgdHk7XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XG5cbiAgICAgICAgYWN0aW9uID0gaXRlbS5hY3Rpb247XG4gICAgICAgIGFyZ3MgPSBpdGVtLmFyZ3M7XG5cbiAgICAgICAgc3dpdGNoICggYWN0aW9uICkge1xuXG4gICAgICAgICAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLk1PVkVfVE86XG5cbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE86XG5cbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcblxuICAgICAgICAgICAgICAgIGNweCA9IGFyZ3NbIDIgXTtcbiAgICAgICAgICAgICAgICBjcHkgPSBhcmdzWyAzIF07XG5cbiAgICAgICAgICAgICAgICBjcHgxID0gYXJnc1sgMCBdO1xuICAgICAgICAgICAgICAgIGNweTEgPSBhcmdzWyAxIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICAgICAgICAgICAgICBjcHkwID0gbGFzdGUueTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuICAgICAgICAgICAgICAgICAgICBjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHQgPSBqIC8gZGl2aXNpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xuICAgICAgICAgICAgICAgICAgICB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE86XG5cbiAgICAgICAgICAgICAgICBjcHggPSBhcmdzWyA0IF07XG4gICAgICAgICAgICAgICAgY3B5ID0gYXJnc1sgNSBdO1xuXG4gICAgICAgICAgICAgICAgY3B4MSA9IGFyZ3NbIDAgXTtcbiAgICAgICAgICAgICAgICBjcHkxID0gYXJnc1sgMSBdO1xuXG4gICAgICAgICAgICAgICAgY3B4MiA9IGFyZ3NbIDIgXTtcbiAgICAgICAgICAgICAgICBjcHkyID0gYXJnc1sgMyBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuICAgICAgICAgICAgICAgICAgICBjcHgwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHQgPSBqIC8gZGl2aXNpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuICAgICAgICAgICAgICAgICAgICB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlU6XG5cbiAgICAgICAgICAgICAgICBsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXSwgbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXSApO1xuICAgICAgICAgICAgICAgIHZhciBzcHRzID0gWyBsYXN0IF07XG5cbiAgICAgICAgICAgICAgICB2YXIgbiA9IGRpdmlzaW9ucyAqIGFyZ3NbIDAgXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDE7IGogPD0gbjsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQVJDOlxuXG4gICAgICAgICAgICAgICAgdmFyIGFYID0gYXJnc1sgMCBdLFxuICAgICAgICAgICAgICAgICAgICBhWSA9IGFyZ3NbIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgYVJhZGl1cyA9IGFyZ3NbIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUgPSBhcmdzWyAzIF0sXG4gICAgICAgICAgICAgICAgICAgIGFFbmRBbmdsZSA9IGFyZ3NbIDQgXSxcbiAgICAgICAgICAgICAgICAgICAgYUNsb2Nrd2lzZSA9ICEhYXJnc1sgNSBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGU7XG4gICAgICAgICAgICAgICAgdmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDE7IGogPD0gdGRpdmlzaW9uczsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHQgPSBqIC8gdGRpdmlzaW9ucztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFhQ2xvY2t3aXNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gMSAtIHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblxuICAgICAgICAgICAgICAgICAgICB0eCA9IGFYICsgYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICAgICAgICAgICAgICAgICAgICB0eSA9IGFZICsgYVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBvaW50cyk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFOlxuXG4gICAgICAgICAgICAgICAgdmFyIGFYID0gYXJnc1sgMCBdLFxuICAgICAgICAgICAgICAgICAgICBhWSA9IGFyZ3NbIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgeFJhZGl1cyA9IGFyZ3NbIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgeVJhZGl1cyA9IGFyZ3NbIDMgXSxcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUgPSBhcmdzWyA0IF0sXG4gICAgICAgICAgICAgICAgICAgIGFFbmRBbmdsZSA9IGFyZ3NbIDUgXSxcbiAgICAgICAgICAgICAgICAgICAgYUNsb2Nrd2lzZSA9ICEhYXJnc1sgNiBdLFxuICAgICAgICAgICAgICAgICAgICBhUm90YXRpb24gPSBhcmdzWyA3IF07XG5cblxuICAgICAgICAgICAgICAgIHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlO1xuICAgICAgICAgICAgICAgIHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcblxuICAgICAgICAgICAgICAgIHZhciBjb3MsIHNpbjtcbiAgICAgICAgICAgICAgICBpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyggYVJvdGF0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKCBhUm90YXRpb24gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ID0gaiAvIHRkaXZpc2lvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhYUNsb2Nrd2lzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDEgLSB0O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHggPSBhWCArIHhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gKCB4IC0gYVggKSAqIGNvcyAtICggeSAtIGFZICkgKiBzaW4gKyBhWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5ID0gKCB4IC0gYVggKSAqIHNpbiArICggeSAtIGFZICkgKiBjb3MgKyBhWTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH0gLy8gZW5kIHN3aXRjaFxuXG4gICAgfVxuXG5cblxuICAgIC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cbiAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuICAgIGlmICggTWF0aC5hYnMoIGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCApIDwgRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyggbGFzdFBvaW50LnkgLSBwb2ludHNbIDAgXS55ICkgPCBFUFNJTE9OIClcbiAgICAgICAgcG9pbnRzLnNwbGljZSggcG9pbnRzLmxlbmd0aCAtIDEsIDEgKTtcbiAgICBpZiAoIGNsb3NlZFBhdGggKSB7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuXG59O1xuXG4vL1xuLy8gQnJlYWtzIHBhdGggaW50byBzaGFwZXNcbi8vXG4vL1x0QXNzdW1wdGlvbnMgKGlmIHBhcmFtZXRlciBpc0NDVz09dHJ1ZSB0aGUgb3Bwb3NpdGUgaG9sZHMpOlxuLy9cdC0gc29saWQgc2hhcGVzIGFyZSBkZWZpbmVkIGNsb2Nrd2lzZSAoQ1cpXG4vL1x0LSBob2xlcyBhcmUgZGVmaW5lZCBjb3VudGVyY2xvY2t3aXNlIChDQ1cpXG4vL1xuLy9cdElmIHBhcmFtZXRlciBub0hvbGVzPT10cnVlOlxuLy8gIC0gYWxsIHN1YlBhdGhzIGFyZSByZWdhcmRlZCBhcyBzb2xpZCBzaGFwZXNcbi8vICAtIGRlZmluaXRpb24gb3JkZXIgQ1cvQ0NXIGhhcyBubyByZWxldmFuY2Vcbi8vXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oIGlzQ0NXLCBub0hvbGVzICkge1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdFN1YnBhdGhzKCBpbkFjdGlvbnMgKSB7XG5cbiAgICAgICAgdmFyIGksIGlsLCBpdGVtLCBhY3Rpb24sIGFyZ3M7XG5cbiAgICAgICAgdmFyIHN1YlBhdGhzID0gW10sXG4gICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gaW5BY3Rpb25zLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcblxuICAgICAgICAgICAgYXJncyA9IGl0ZW0uYXJncztcbiAgICAgICAgICAgIGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAoIGFjdGlvbiA9PT0gVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RQYXRoWyBhY3Rpb24gXS5hcHBseSggbGFzdFBhdGgsIGFyZ3MgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcblxuICAgICAgICAgICAgc3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coc3ViUGF0aHMpO1xuXG4gICAgICAgIHJldHVybiBzdWJQYXRocztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvU2hhcGVzTm9Ib2xlcyggaW5TdWJwYXRocyApIHtcblxuICAgICAgICB2YXIgc2hhcGVzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHRtcFBhdGggPSBpblN1YnBhdGhzWyBpIF07XG5cbiAgICAgICAgICAgIHZhciB0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuICAgICAgICAgICAgdG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcbiAgICAgICAgICAgIHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG4gICAgICAgICAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cbiAgICAgICAgcmV0dXJuIHNoYXBlcztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XG5cbiAgICAgICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAgICAgdmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xuXG4gICAgICAgIC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXG4gICAgICAgIC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2VcbiAgICAgICAgLy8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuICAgICAgICAvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHErKyApIHtcblxuICAgICAgICAgICAgdmFyIGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcCBdO1xuICAgICAgICAgICAgdmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcblxuICAgICAgICAgICAgdmFyIGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xuICAgICAgICAgICAgdmFyIGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBub3QgcGFyYWxsZWxcbiAgICAgICAgICAgICAgICBpZiAoIGVkZ2VEeSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBxIF07XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VEeCA9IC1lZGdlRHg7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHAgXTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZUR5ID0gLWVkZ2VEeTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblB0LnggPT09IGVkZ2VMb3dQdC54ICkgcmV0dXJuIHRydWU7IC8vIGluUHQgaXMgb24gY29udG91ciA/XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwZXJwRWRnZSA9PT0gMCApIHJldHVybiB0cnVlOyAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHBlcnBFZGdlIDwgMCApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlOyAvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcbiAgICAgICAgICAgICAgICBpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBjb250aW51ZTsgLy8gcGFyYWxsZWxcbiAgICAgICAgICAgICAgICAvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcbiAgICAgICAgICAgICAgICBpZiAoICggKCBlZGdlSGlnaFB0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUxvd1B0LnggKSApIHx8XG4gICAgICAgICAgICAgICAgICAgICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApICkgcmV0dXJuIHRydWU7IC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG5cbiAgICB9XG5cblxuICAgIHZhciBzdWJQYXRocyA9IGV4dHJhY3RTdWJwYXRocyggdGhpcy5hY3Rpb25zICk7XG4gICAgaWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cbiAgICBpZiAoIG5vSG9sZXMgPT09IHRydWUgKSByZXR1cm4gdG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cbiAgICB2YXIgc29saWQsIHRtcFBhdGgsIHRtcFNoYXBlLCBzaGFwZXMgPSBbXTtcblxuICAgIGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAxICkge1xuXG4gICAgICAgIHRtcFBhdGggPSBzdWJQYXRoc1sgMCBdO1xuICAgICAgICB0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuICAgICAgICB0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuICAgICAgICB0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcbiAgICAgICAgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG4gICAgICAgIHJldHVybiBzaGFwZXM7XG5cbiAgICB9XG5cbiAgICB2YXIgaG9sZXNGaXJzdCA9ICFUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggc3ViUGF0aHNbIDAgXS5nZXRQb2ludHMoKSApO1xuICAgIGhvbGVzRmlyc3QgPSBpc0NDVyA/ICFob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcblxuICAgIC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cbiAgICB2YXIgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xuICAgIHZhciBuZXdTaGFwZXMgPSBbXTtcbiAgICB2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuICAgIHZhciBtYWluSWR4ID0gMDtcbiAgICB2YXIgdG1wUG9pbnRzO1xuXG4gICAgbmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XG4gICAgbmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cbiAgICB2YXIgaSwgaWw7XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xuICAgICAgICB0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xuICAgICAgICBzb2xpZCA9IFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcbiAgICAgICAgc29saWQgPSBpc0NDVyA/ICFzb2xpZCA6IHNvbGlkO1xuXG4gICAgICAgIGlmICggc29saWQgKSB7XG5cbiAgICAgICAgICAgIGlmICggKCAhaG9sZXNGaXJzdCApICYmICggbmV3U2hhcGVzWyBtYWluSWR4IF0gKSApIG1haW5JZHgrKztcblxuICAgICAgICAgICAgbmV3U2hhcGVzWyBtYWluSWR4IF0gPSB7XG4gICAgICAgICAgICAgICAgczogbmV3IFRIUkVFLlNoYXBlKCksXG4gICAgICAgICAgICAgICAgcDogdG1wUG9pbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3U2hhcGVzWyBtYWluSWR4IF0ucy5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuICAgICAgICAgICAgbmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuICAgICAgICAgICAgaWYgKCBob2xlc0ZpcnN0ICkgbWFpbklkeCsrO1xuICAgICAgICAgICAgbmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgbmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdLnB1c2goIHtcbiAgICAgICAgICAgICAgICBoOiB0bXBQYXRoLFxuICAgICAgICAgICAgICAgIHA6IHRtcFBvaW50c1sgMCBdXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuICAgIGlmICggIW5ld1NoYXBlc1sgMCBdICkgcmV0dXJuIHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG4gICAgaWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblxuICAgICAgICB2YXIgYW1iaWd1b3VzID0gZmFsc2U7XG4gICAgICAgIHZhciB0b0NoYW5nZSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4KysgKSB7XG5cbiAgICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xuXG4gICAgICAgIH1cbiAgICAgICAgZm9yICggdmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHgrKyApIHtcblxuICAgICAgICAgICAgdmFyIHNobyA9IG5ld1NoYXBlSG9sZXNbIHNJZHggXTtcbiAgICAgICAgICAgIGZvciAoIHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHgrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBobyA9IHNob1sgaElkeCBdO1xuICAgICAgICAgICAgICAgIHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoIHZhciBzMklkeCA9IDA7IHMySWR4IDwgbmV3U2hhcGVzLmxlbmd0aDsgczJJZHgrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNJZHggIT09IHMySWR4ICkgdG9DaGFuZ2UucHVzaCgge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21zOiBzSWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvczogczJJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZTogaElkeFxuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXR0ZXJTaGFwZUhvbGVzWyBzMklkeCBdLnB1c2goIGhvICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0ucHVzaCggaG8gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJhbWJpZ3VvdXM6IFwiLCBhbWJpZ3VvdXMpO1xuICAgICAgICBpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidG8gY2hhbmdlOiBcIiwgdG9DaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKCAhYW1iaWd1b3VzICkgbmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIHRtcEhvbGVzLCBqLCBqbDtcbiAgICBmb3IgKCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICB0bXBTaGFwZSA9IG5ld1NoYXBlc1sgaSBdLnM7XG4gICAgICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuICAgICAgICB0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbIGkgXTtcbiAgICAgICAgZm9yICggaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgdG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cbiAgICByZXR1cm4gc2hhcGVzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9TaGFwZS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIERlZmluZXMgYSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocy5cbiAqKi9cblxuLy8gU1RFUCAxIENyZWF0ZSBhIHBhdGguXG4vLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXG4vLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xuLy8gU1RFUCAzYSAtIEV4dHJhY3QgcG9pbnRzIGZyb20gZWFjaCBzaGFwZSwgdHVybiB0byB2ZXJ0aWNlc1xuLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cblxuVEhSRUUuU2hhcGUgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgIHRoaXMuaG9sZXMgPSBbXTtcblxufTtcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUGF0aC5wcm90b3R5cGUgKTtcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIEV4dHJ1ZGVHZW9tZXRyeVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cnVkZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgdmFyIGV4dHJ1ZGVkID0gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuICAgIHJldHVybiBleHRydWRlZDtcblxufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBTaGFwZUdlb21ldHJ5XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5tYWtlR2VvbWV0cnkgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICB2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCxcbiAgICAgICAgaG9sZXNQdHMgPSBbXTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBob2xlc1B0cztcblxufTtcblxuLy8gR2V0IHBvaW50cyBvZiBob2xlcyAoc3BhY2VkIGJ5IHJlZ3VsYXIgZGlzdGFuY2UpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICB2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCxcbiAgICAgICAgaG9sZXNQdHMgPSBbXTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBob2xlc1B0cztcblxufTtcblxuXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgICBzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zICksXG4gICAgICAgIGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG4gICAgfTtcblxufTtcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgaWYgKCB0aGlzLnVzZVNwYWNlZFBvaW50cyApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QWxsU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV4dHJhY3RBbGxQb2ludHMoIGRpdmlzaW9ucyApO1xuXG59O1xuXG4vL1xuLy8gVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHNXaXRoQmVuZCA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBiZW5kICkge1xuLy9cbi8vIFx0cmV0dXJuIHtcbi8vXG4vLyBcdFx0c2hhcGU6IHRoaXMudHJhbnNmb3JtKCBiZW5kLCBkaXZpc2lvbnMgKSxcbi8vIFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zLCBiZW5kIClcbi8vXG4vLyBcdH07XG4vL1xuLy8gfTtcblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIHNoYXBlOiB0aGlzLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgKSxcbiAgICAgICAgaG9sZXM6IHRoaXMuZ2V0U3BhY2VkUG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cbiAgICB9O1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5TaGFwZS5VdGlscyA9IHtcblxuICAgIHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uKCBjb250b3VyLCBob2xlcyApIHtcblxuICAgICAgICBmdW5jdGlvbiBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZ1B0MSwgaW5TZWdQdDIsIGluT3RoZXJQdCApIHtcblxuICAgICAgICAgICAgLy8gaW5PdGhlclB0IG5lZWRzIHRvIGJlIGNvbGxpbmVhciB0byB0aGUgaW5TZWdtZW50XG4gICAgICAgICAgICBpZiAoIGluU2VnUHQxLnggIT09IGluU2VnUHQyLnggKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICggaW5TZWdQdDEueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDIueCApICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKCBpblNlZ1B0Mi54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0MS54ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICggaW5TZWdQdDEueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDIueSApICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKCBpblNlZ1B0Mi55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0MS55ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xuXG4gICAgICAgICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgICAgICAgdmFyIHNlZzFkeCA9IGluU2VnMVB0Mi54IC0gaW5TZWcxUHQxLngsXG4gICAgICAgICAgICAgICAgc2VnMWR5ID0gaW5TZWcxUHQyLnkgLSBpblNlZzFQdDEueTtcbiAgICAgICAgICAgIHZhciBzZWcyZHggPSBpblNlZzJQdDIueCAtIGluU2VnMlB0MS54LFxuICAgICAgICAgICAgICAgIHNlZzJkeSA9IGluU2VnMlB0Mi55IC0gaW5TZWcyUHQxLnk7XG5cbiAgICAgICAgICAgIHZhciBzZWcxc2VnMmR4ID0gaW5TZWcxUHQxLnggLSBpblNlZzJQdDEueDtcbiAgICAgICAgICAgIHZhciBzZWcxc2VnMmR5ID0gaW5TZWcxUHQxLnkgLSBpblNlZzJQdDEueTtcblxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gc2VnMWR5ICogc2VnMmR4IC0gc2VnMWR4ICogc2VnMmR5O1xuICAgICAgICAgICAgdmFyIHBlcnBTZWcxID0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIGxpbWl0ICkgPiBFUFNJTE9OICkge1xuXG4gICAgICAgICAgICAgICAgLy8gbm90IHBhcmFsbGVsXG5cbiAgICAgICAgICAgICAgICB2YXIgcGVycFNlZzI7XG4gICAgICAgICAgICAgICAgaWYgKCBsaW1pdCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHBlcnBTZWcxIDwgMCApIHx8ICggcGVycFNlZzEgPiBsaW1pdCApICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICBwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzIgPCAwICkgfHwgKCBwZXJwU2VnMiA+IGxpbWl0ICkgKSByZXR1cm4gW107XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHBlcnBTZWcxID4gMCApIHx8ICggcGVycFNlZzEgPCBsaW1pdCApICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICBwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSByZXR1cm4gW107XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpLmUuIHRvIHJlZHVjZSByb3VuZGluZyBlcnJvcnNcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMxP1xuICAgICAgICAgICAgICAgIGlmICggcGVycFNlZzIgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggcGVycFNlZzIgPT09IGxpbWl0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDIgXTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMyP1xuICAgICAgICAgICAgICAgIGlmICggcGVycFNlZzEgPT09IDAgKSByZXR1cm4gWyBpblNlZzJQdDEgXTtcbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcxID09PSBsaW1pdCApIHJldHVybiBbIGluU2VnMlB0MiBdO1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvclNlZzEgPSBwZXJwU2VnMiAvIGxpbWl0O1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHtcbiAgICAgICAgICAgICAgICAgICAgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxuICAgICAgICAgICAgICAgICAgICB5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHlcbiAgICAgICAgICAgICAgICB9IF07XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG4gICAgICAgICAgICAgICAgaWYgKCAoIHBlcnBTZWcxICE9PSAwICkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCBzZWcyZHkgKiBzZWcxc2VnMmR4ICE9PSBzZWcyZHggKiBzZWcxc2VnMmR5ICkgKSByZXR1cm4gW107XG5cbiAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSBjb2xsaW5lYXIgb3IgZGVnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIHZhciBzZWcxUHQgPSAoICggc2VnMWR4ID09PSAwICkgJiYgKCBzZWcxZHkgPT09IDAgKSApOyAvLyBzZWdtZW50MSBpcyBqdXN0IGEgcG9pbnQ/XG4gICAgICAgICAgICAgICAgdmFyIHNlZzJQdCA9ICggKCBzZWcyZHggPT09IDAgKSAmJiAoIHNlZzJkeSA9PT0gMCApICk7IC8vIHNlZ21lbnQyIGlzIGp1c3QgYSBwb2ludD9cbiAgICAgICAgICAgICAgICAvLyBib3RoIHNlZ21lbnRzIGFyZSBwb2ludHNcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzFQdCAmJiBzZWcyUHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGluU2VnMVB0MS54ICE9PSBpblNlZzJQdDEueCApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIGluU2VnMVB0MS55ICE9PSBpblNlZzJQdDEueSApICkgcmV0dXJuIFtdOyAvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdOyAvLyB0aGV5IGFyZSB0aGUgc2FtZSBwb2ludFxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQjMSAgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzFQdCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5TZWcxUHQxICkgKSByZXR1cm4gW107IC8vIGJ1dCBub3QgaW4gc2VnbWVudCMyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQjMiAgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzJQdCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxICkgKSByZXR1cm4gW107IC8vIGJ1dCBub3QgaW4gc2VnbWVudCMxXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMlB0MSBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXG4gICAgICAgICAgICAgICAgdmFyIHNlZzFtaW4sIHNlZzFtYXgsIHNlZzFtaW5WYWwsIHNlZzFtYXhWYWw7XG4gICAgICAgICAgICAgICAgdmFyIHNlZzJtaW4sIHNlZzJtYXgsIHNlZzJtaW5WYWwsIHNlZzJtYXhWYWw7XG4gICAgICAgICAgICAgICAgaWYgKCBzZWcxZHggIT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlZ21lbnRzIGFyZSBOT1Qgb24gYSB2ZXJ0aWNhbCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLng7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLng7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi54O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluVmFsID0gaW5TZWcyUHQyLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heFZhbCA9IGluU2VnMlB0MS54O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluU2VnMVB0MS55IDwgaW5TZWcxUHQyLnkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi55O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluVmFsID0gaW5TZWcxUHQyLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pblZhbCA9IGluU2VnMlB0MS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWF4VmFsIDwgc2VnMm1pblZhbCApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWF4VmFsID09PSBzZWcybWluVmFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHNlZzJtaW4gXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsICkgcmV0dXJuIFsgc2VnMm1pbiwgc2VnMW1heCBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBzZWcybWluLCBzZWcybWF4IF07XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWluVmFsID4gc2VnMm1heFZhbCApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWluVmFsID09PSBzZWcybWF4VmFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHNlZzFtaW4gXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsICkgcmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBzZWcxbWluLCBzZWcybWF4IF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZUFuZ2xlKCBpblZlcnRleCwgaW5MZWdGcm9tUHQsIGluTGVnVG9QdCwgaW5PdGhlclB0ICkge1xuXG4gICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2YgbGVncyBpcyBpbXBvcnRhbnRcblxuICAgICAgICAgICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAgICAgICAgIC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXG4gICAgICAgICAgICB2YXIgbGVnRnJvbVB0WCA9IGluTGVnRnJvbVB0LnggLSBpblZlcnRleC54LFxuICAgICAgICAgICAgICAgIGxlZ0Zyb21QdFkgPSBpbkxlZ0Zyb21QdC55IC0gaW5WZXJ0ZXgueTtcbiAgICAgICAgICAgIHZhciBsZWdUb1B0WCA9IGluTGVnVG9QdC54IC0gaW5WZXJ0ZXgueCxcbiAgICAgICAgICAgICAgICBsZWdUb1B0WSA9IGluTGVnVG9QdC55IC0gaW5WZXJ0ZXgueTtcbiAgICAgICAgICAgIHZhciBvdGhlclB0WCA9IGluT3RoZXJQdC54IC0gaW5WZXJ0ZXgueCxcbiAgICAgICAgICAgICAgICBvdGhlclB0WSA9IGluT3RoZXJQdC55IC0gaW5WZXJ0ZXgueTtcblxuICAgICAgICAgICAgLy8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXG4gICAgICAgICAgICB2YXIgZnJvbTJ0b0FuZ2xlID0gbGVnRnJvbVB0WCAqIGxlZ1RvUHRZIC0gbGVnRnJvbVB0WSAqIGxlZ1RvUHRYO1xuICAgICAgICAgICAgdmFyIGZyb20yb3RoZXJBbmdsZSA9IGxlZ0Zyb21QdFggKiBvdGhlclB0WSAtIGxlZ0Zyb21QdFkgKiBvdGhlclB0WDtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggZnJvbTJ0b0FuZ2xlICkgPiBFUFNJTE9OICkge1xuXG4gICAgICAgICAgICAgICAgLy8gYW5nbGUgIT0gMTgwIGRlZy5cblxuICAgICAgICAgICAgICAgIHZhciBvdGhlcjJ0b0FuZ2xlID0gb3RoZXJQdFggKiBsZWdUb1B0WSAtIG90aGVyUHRZICogbGVnVG9QdFg7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmcm9tMnRvQW5nbGUgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1haW4gYW5nbGUgPiAxODAgZGVnLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIGFuZ2xlID09IDE4MCBkZWcuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoIGZyb20yb3RoZXJBbmdsZSA+IDAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcblxuICAgICAgICAgICAgdmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXG4gICAgICAgICAgICB2YXIgaG9sZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBob2xlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBzaGFwZSBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGVJZHggPSBzaGFwZS5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZTaGFwZUlkeCA9IGluU2hhcGVJZHggLSAxO1xuICAgICAgICAgICAgICAgIGlmICggcHJldlNoYXBlSWR4IDwgMCApIHByZXZTaGFwZUlkeCA9IGxhc3RTaGFwZUlkeDtcblxuICAgICAgICAgICAgICAgIHZhciBuZXh0U2hhcGVJZHggPSBpblNoYXBlSWR4ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoIG5leHRTaGFwZUlkeCA+IGxhc3RTaGFwZUlkeCApIG5leHRTaGFwZUlkeCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIHNoYXBlWyBpblNoYXBlSWR4IF0sIHNoYXBlWyBwcmV2U2hhcGVJZHggXSwgc2hhcGVbIG5leHRTaGFwZUlkeCBdLCBob2xlWyBpbkhvbGVJZHggXSApO1xuICAgICAgICAgICAgICAgIGlmICggIWluc2lkZUFuZ2xlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoU2hhcGUpOiBcIiArIGluU2hhcGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgaG9sZVtpbkhvbGVJZHhdLnggKyBcIi9cIiArIGhvbGVbaW5Ib2xlSWR4XS55ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RIb2xlSWR4ID0gaG9sZS5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZIb2xlSWR4ID0gaW5Ib2xlSWR4IC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIHByZXZIb2xlSWR4IDwgMCApIHByZXZIb2xlSWR4ID0gbGFzdEhvbGVJZHg7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xuICAgICAgICAgICAgICAgIGlmICggbmV4dEhvbGVJZHggPiBsYXN0SG9sZUlkeCApIG5leHRIb2xlSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlWyBpbkhvbGVJZHggXSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbIGluU2hhcGVJZHggXSApO1xuICAgICAgICAgICAgICAgIGlmICggIWluc2lkZUFuZ2xlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoSG9sZSk6IFwiICsgaW5Ib2xlSWR4ICsgXCIsIFBvaW50OiBcIiArIHNoYXBlW2luU2hhcGVJZHhdLnggKyBcIi9cIiArIHNoYXBlW2luU2hhcGVJZHhdLnkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0c1NoYXBlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXG4gICAgICAgICAgICAgICAgdmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKCBzSWR4ID0gMDsgc0lkeCA8IHNoYXBlLmxlbmd0aDsgc0lkeCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZHggPSBzSWR4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkeCAlPSBzaGFwZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbIHNJZHggXSwgc2hhcGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwICkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGVwSG9sZXMgPSBbXTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggaG9sZSBlZGdlc1xuICAgICAgICAgICAgICAgIHZhciBpaElkeCwgY2hrSG9sZSxcbiAgICAgICAgICAgICAgICAgICAgaElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAoIGloSWR4ID0gMDsgaWhJZHggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaWhJZHgrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBjaGtIb2xlID0gaG9sZXNbIGluZGVwSG9sZXNbIGloSWR4IF0gXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWR4ID0gaElkeCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWR4ICU9IGNoa0hvbGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBjaGtIb2xlWyBoSWR4IF0sIGNoa0hvbGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhvbGVJbmRleCwgc2hhcGVJbmRleCxcbiAgICAgICAgICAgICAgICBzaGFwZVB0LCBob2xlUHQsXG4gICAgICAgICAgICAgICAgaG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXG4gICAgICAgICAgICAgICAgdG1wU2hhcGUxLCB0bXBTaGFwZTIsXG4gICAgICAgICAgICAgICAgdG1wSG9sZTEsIHRtcEhvbGUyO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgICAgIGluZGVwSG9sZXMucHVzaCggaCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtaW5TaGFwZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gaW5kZXBIb2xlcy5sZW5ndGggKiAyO1xuICAgICAgICAgICAgd2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgICAgICAgICAgaWYgKCBjb3VudGVyIDwgMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJJbmZpbml0ZSBMb29wISBIb2xlcyBsZWZ0OlwiICsgaW5kZXBIb2xlcy5sZW5ndGggKyBcIiwgUHJvYmFibHkgSG9sZSBvdXRzaWRlIFNoYXBlIVwiICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgZm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXgrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBzaGFwZVB0ID0gc2hhcGVbIHNoYXBlSW5kZXggXTtcbiAgICAgICAgICAgICAgICAgICAgaG9sZUluZGV4ID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBob2xlIHdoaWNoIGNhbiBiZSByZWFjaGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xlSWR4ID0gaW5kZXBIb2xlc1sgaCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IG11bHRpcGxlIGNoZWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0S2V5ID0gc2hhcGVQdC54ICsgXCI6XCIgKyBzaGFwZVB0LnkgKyBcIjpcIiArIGhvbGVJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZhaWxlZEN1dHNbIGN1dEtleSBdICE9PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZSA9IGhvbGVzWyBob2xlSWR4IF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZVB0ID0gaG9sZVsgaDIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdHNTaGFwZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApICkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlSW5kZXggPSBoMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlcEhvbGVzLnNwbGljZSggaCwgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wU2hhcGUxID0gc2hhcGUuc2xpY2UoIDAsIHNoYXBlSW5kZXggKyAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wU2hhcGUyID0gc2hhcGUuc2xpY2UoIHNoYXBlSW5kZXggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEhvbGUyID0gaG9sZS5zbGljZSggMCwgaG9sZUluZGV4ICsgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluU2hhcGVJbmRleCA9IHNoYXBlSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWJ1ZyBvbmx5LCB0byBzaG93IHRoZSBzZWxlY3RlZCBjdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBob2xlSW5kZXggPj0gMCApIGJyZWFrOyAvLyBob2xlLXZlcnRleCBmb3VuZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRDdXRzWyBjdXRLZXkgXSA9IHRydWU7IC8vIHJlbWVtYmVyIGZhaWx1cmVcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggaG9sZUluZGV4ID49IDAgKSBicmVhazsgLy8gaG9sZS12ZXJ0ZXggZm91bmRcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7IC8qIHNoYXBlIHdpdGggbm8gaG9sZXMgKi9cblxuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgaSwgaWwsIGYsIGZhY2UsXG4gICAgICAgICAgICBrZXksIGluZGV4LFxuICAgICAgICAgICAgYWxsUG9pbnRzTWFwID0ge307XG5cbiAgICAgICAgLy8gVG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9sZCBzaGFwZSwgb25lIG11c3QgbWF0Y2ggY29vcmRpbmF0ZXMsIG9yIG9mZnNldCB0aGUgaW5kaWNlcyBmcm9tIG9yaWdpbmFsIGFycmF5cy4gSXQncyBwcm9iYWJseSBlYXNpZXIgdG8gZG8gdGhlIGZpcnN0LlxuXG4gICAgICAgIHZhciBhbGxwb2ludHMgPSBjb250b3VyLmNvbmNhdCgpO1xuXG4gICAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1sgaCBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XG5cbiAgICAgICAgLy8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICBrZXkgPSBhbGxwb2ludHNbIGkgXS54ICsgXCI6XCIgKyBhbGxwb2ludHNbIGkgXS55O1xuXG4gICAgICAgICAgICBpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5TaGFwZTogRHVwbGljYXRlIHBvaW50XCIsIGtleSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgaG9sZXMgYnkgY3V0dGluZyBwYXRocyB0byBob2xlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIHNoYXBlXG4gICAgICAgIHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xuXG4gICAgICAgIHZhciB0cmlhbmdsZXMgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUoIHNoYXBlV2l0aG91dEhvbGVzLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcbiAgICAgICAgLy9jb25zb2xlLmxvZyggXCJ0cmlhbmdsZXNcIix0cmlhbmdsZXMsIHRyaWFuZ2xlcy5sZW5ndGggKTtcblxuICAgICAgICAvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcblxuICAgICAgICAgICAgZm9yICggZiA9IDA7IGYgPCAzOyBmKysgKSB7XG5cbiAgICAgICAgICAgICAgICBrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZVsgZiBdID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcblxuICAgIH0sXG5cbiAgICBpc0Nsb2NrV2lzZTogZnVuY3Rpb24oIHB0cyApIHtcblxuICAgICAgICByZXR1cm4gVEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlLmFyZWEoIHB0cyApIDwgMDtcblxuICAgIH0sXG5cbiAgICAvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG5cbiAgICAvLyBRdWFkIEJlemllciBGdW5jdGlvbnNcblxuICAgIGIycDA6IGZ1bmN0aW9uKCB0LCBwICkge1xuXG4gICAgICAgIHZhciBrID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiBrICogayAqIHA7XG5cbiAgICB9LFxuXG4gICAgYjJwMTogZnVuY3Rpb24oIHQsIHAgKSB7XG5cbiAgICAgICAgcmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcblxuICAgIH0sXG5cbiAgICBiMnAyOiBmdW5jdGlvbiggdCwgcCApIHtcblxuICAgICAgICByZXR1cm4gdCAqIHQgKiBwO1xuXG4gICAgfSxcblxuICAgIGIyOiBmdW5jdGlvbiggdCwgcDAsIHAxLCBwMiApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5iMnAwKCB0LCBwMCApICsgdGhpcy5iMnAxKCB0LCBwMSApICsgdGhpcy5iMnAyKCB0LCBwMiApO1xuXG4gICAgfSxcblxuICAgIC8vIEN1YmljIEJlemllciBGdW5jdGlvbnNcblxuICAgIGIzcDA6IGZ1bmN0aW9uKCB0LCBwICkge1xuXG4gICAgICAgIHZhciBrID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiBrICogayAqIGsgKiBwO1xuXG4gICAgfSxcblxuICAgIGIzcDE6IGZ1bmN0aW9uKCB0LCBwICkge1xuXG4gICAgICAgIHZhciBrID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxuICAgIH0sXG5cbiAgICBiM3AyOiBmdW5jdGlvbiggdCwgcCApIHtcblxuICAgICAgICB2YXIgayA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XG5cbiAgICB9LFxuXG4gICAgYjNwMzogZnVuY3Rpb24oIHQsIHAgKSB7XG5cbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cbiAgICB9LFxuXG4gICAgYjM6IGZ1bmN0aW9uKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5iM3AwKCB0LCBwMCApICsgdGhpcy5iM3AxKCB0LCBwMSApICsgdGhpcy5iM3AyKCB0LCBwMiApICsgdGhpcy5iM3AzKCB0LCBwMyApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRMaW5lXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uKCB2MSwgdjIgKSB7XG5cbiAgICB0aGlzLnYxID0gdjE7XG4gICAgdGhpcy52MiA9IHYyO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZUN1cnZlO1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XG4gICAgcG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuICAgIHJldHVybiBwb2ludDtcblxufTtcblxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uKCB1ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUgKTtcblxufTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcblxuICAgIHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFF1YWRyYXRpYyBCZXppZXIgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKCB2MCwgdjEsIHYyICkge1xuXG4gICAgdGhpcy52MCA9IHYwO1xuICAgIHRoaXMudjEgPSB2MTtcbiAgICB0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmU7XG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIHZlY3Rvci54ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcbiAgICB2ZWN0b3IueSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuXG59O1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuICAgIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG4gICAgLy8gcmV0dXJucyB1bml0IHZlY3RvclxuXG4gICAgcmV0dXJuIHZlY3Rvci5ub3JtYWxpemUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1YmljIEJlemllciBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlID0gZnVuY3Rpb24oIHYwLCB2MSwgdjIsIHYzICkge1xuXG4gICAgdGhpcy52MCA9IHYwO1xuICAgIHRoaXMudjEgPSB2MTtcbiAgICB0aGlzLnYyID0gdjI7XG4gICAgdGhpcy52MyA9IHYzO1xuXG59O1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJpY0JlemllckN1cnZlO1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHR4LCB0eTtcblxuICAgIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuICAgIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHR4LCB0eTtcblxuICAgIHR4ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcbiAgICB0eSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cbiAgICB2YXIgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcbiAgICB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRhbmdlbnQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0U3BsaW5lIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlNwbGluZUN1cnZlID0gZnVuY3Rpb24oIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xuXG4gICAgdGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG59O1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwbGluZUN1cnZlO1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG4gICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgIHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcbiAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuICAgIHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuICAgIHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICk7XG4gICAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApO1xuXG4gICAgcmV0dXJuIHZlY3RvcjtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9FbGxpcHNlQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0RWxsaXBzZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5FbGxpcHNlQ3VydmUgPSBmdW5jdGlvbiggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cbiAgICB0aGlzLmFYID0gYVg7XG4gICAgdGhpcy5hWSA9IGFZO1xuXG4gICAgdGhpcy54UmFkaXVzID0geFJhZGl1cztcbiAgICB0aGlzLnlSYWRpdXMgPSB5UmFkaXVzO1xuXG4gICAgdGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuICAgIHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xuXG4gICAgdGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZTtcblxuICAgIHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XG5cbn07XG5cblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FbGxpcHNlQ3VydmU7XG5cblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXG4gICAgaWYgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgaWYgKCBkZWx0YUFuZ2xlID4gTWF0aC5QSSAqIDIgKSBkZWx0YUFuZ2xlIC09IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIGFuZ2xlO1xuXG4gICAgaWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgKSB7XG5cbiAgICAgICAgYW5nbGUgPSB0aGlzLmFFbmRBbmdsZSArICggMSAtIHQgKSAqICggTWF0aC5QSSAqIDIgLSBkZWx0YUFuZ2xlICk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgICB9XG5cbiAgICB2YXIgeCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICB2YXIgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgIGlmICggdGhpcy5hUm90YXRpb24gIT09IDAgKSB7XG5cbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oIHRoaXMuYVJvdGF0aW9uICk7XG5cbiAgICAgICAgdmFyIHR4ID0geCxcbiAgICAgICAgICAgIHR5ID0geTtcblxuICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAgICAgIHggPSAoIHR4IC0gdGhpcy5hWCApICogY29zIC0gKCB0eSAtIHRoaXMuYVkgKSAqIHNpbiArIHRoaXMuYVg7XG4gICAgICAgIHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9BcmNDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRBcmMgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gICAgVEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG59O1xuXG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BcmNDdXJ2ZTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmUzRFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gICAgZnVuY3Rpb24oIHYxLCB2MiApIHtcblxuICAgICAgICB0aGlzLnYxID0gdjE7XG4gICAgICAgIHRoaXMudjIgPSB2MjtcblxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2ZWN0b3Iuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApOyAvLyBkaWZmXG4gICAgICAgIHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xuICAgICAgICB2ZWN0b3IuYWRkKCB0aGlzLnYxICk7XG5cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcblxuICAgIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0UXVhZHJhdGljIEJlemllciAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICBmdW5jdGlvbiggdjAsIHYxLCB2MiApIHtcblxuICAgICAgICB0aGlzLnYwID0gdjA7XG4gICAgICAgIHRoaXMudjEgPSB2MTtcbiAgICAgICAgdGhpcy52MiA9IHYyO1xuXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZlY3Rvci54ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcbiAgICAgICAgdmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuICAgICAgICB2ZWN0b3IueiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56ICk7XG5cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcblxuICAgIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdWJpYyBCZXppZXIgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICBmdW5jdGlvbiggdjAsIHYxLCB2MiwgdjMgKSB7XG5cbiAgICAgICAgdGhpcy52MCA9IHYwO1xuICAgICAgICB0aGlzLnYxID0gdjE7XG4gICAgICAgIHRoaXMudjIgPSB2MjtcbiAgICAgICAgdGhpcy52MyA9IHYzO1xuXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZlY3Rvci54ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuICAgICAgICB2ZWN0b3IueSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcbiAgICAgICAgdmVjdG9yLnogPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56ICk7XG5cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcblxuICAgIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0U3BsaW5lIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gICAgZnVuY3Rpb24oIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZUN1cnZlMyB3aWxsIGJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMycgKTtcbiAgICAgICAgdGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuICAgICAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgICAgICB2YXIgcG9pbnQwID0gcG9pbnRzWyBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcbiAgICAgICAgdmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcbiAgICAgICAgdmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG4gICAgICAgIHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcbiAgICAgICAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApO1xuICAgICAgICB2ZWN0b3IueiA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueiwgcG9pbnQxLnosIHBvaW50Mi56LCBwb2ludDMueiwgd2VpZ2h0ICk7XG5cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcblxuICAgIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DYXRtdWxsUm9tQ3VydmUzLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKlxuICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcbiAqIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMgaW4gbm9uLXVuaWZvcm0gY2F0bXVsbCByb20gY3VydmVzLlxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcbiAqXG4gKiBjdXJ2ZS50eXBlIGFjY2VwdHMgY2VudHJpcGV0YWwoZGVmYXVsdCksIGNob3JkYWwgYW5kIGNhdG11bGxyb21cbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcbiAqL1xuXG5USFJFRS5DYXRtdWxsUm9tQ3VydmUzID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhclxuICAgICAgICB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBweCA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICAgICAgcHkgPSBuZXcgQ3ViaWNQb2x5KCksXG4gICAgICAgIHB6ID0gbmV3IEN1YmljUG9seSgpO1xuXG4gICAgLypcblx0QmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxuXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuXHQgLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cblxuXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXG5cdGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxuXHR3aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXG5cdCovXG5cbiAgICBmdW5jdGlvbiBDdWJpY1BvbHkoKSB7XG5cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcbiAgICAgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcbiAgICAgKiBzdWNoIHRoYXRcbiAgICAgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXG4gICAgICogIGFuZFxuICAgICAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cbiAgICAgKi9cbiAgICBDdWJpY1BvbHkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggeDAsIHgxLCB0MCwgdDEgKSB7XG5cbiAgICAgICAgdGhpcy5jMCA9IHgwO1xuICAgICAgICB0aGlzLmMxID0gdDA7XG4gICAgICAgIHRoaXMuYzIgPSAtMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XG4gICAgICAgIHRoaXMuYzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xuXG4gICAgfTtcblxuICAgIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xuXG4gICAgICAgIC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cbiAgICAgICAgdmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcbiAgICAgICAgdmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcblxuICAgICAgICAvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cbiAgICAgICAgdDEgKj0gZHQxO1xuICAgICAgICB0MiAqPSBkdDE7XG5cbiAgICAgICAgLy8gaW5pdEN1YmljUG9seVxuICAgICAgICB0aGlzLmluaXQoIHgxLCB4MiwgdDEsIHQyICk7XG5cbiAgICB9O1xuXG4gICAgLy8gc3RhbmRhcmQgQ2F0bXVsbC1Sb20gc3BsaW5lOiBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHgxIGFuZCB4MiB3aXRoIHByZXZpb3VzL2ZvbGxvd2luZyBwb2ludHMgeDEveDRcbiAgICBDdWJpY1BvbHkucHJvdG90eXBlLmluaXRDYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xuXG4gICAgICAgIHRoaXMuaW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xuXG4gICAgfTtcblxuICAgIEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgIHZhciB0MiA9IHQgKiB0O1xuICAgICAgICB2YXIgdDMgPSB0MiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmMwICsgdGhpcy5jMSAqIHQgKyB0aGlzLmMyICogdDIgKyB0aGlzLmMzICogdDM7XG5cbiAgICB9O1xuXG4gICAgLy8gU3ViY2xhc3MgVGhyZWUuanMgY3VydmVcbiAgICByZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gICAgICAgIGZ1bmN0aW9uKCBwIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gcCB8fCBbXTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIGw7XG5cbiAgICAgICAgICAgIGwgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIGwgPCAyICkgY29uc29sZS5sb2coICdkdWgsIHlvdSBuZWVkIGF0IGxlYXN0IDIgcG9pbnRzJyApO1xuXG4gICAgICAgICAgICBwb2ludCA9ICggbCAtIDEgKSAqIHQ7XG4gICAgICAgICAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgICAgICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgICAgICAgICBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cbiAgICAgICAgICAgICAgICBpbnRQb2ludCA9IGwgLSAyO1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IDE7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHAwLCBwMSwgcDIsIHAzO1xuXG4gICAgICAgICAgICBpZiAoIGludFBvaW50ID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgLy8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcbiAgICAgICAgICAgICAgICB0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuICAgICAgICAgICAgICAgIHAwID0gdG1wO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzWyBpbnRQb2ludCAtIDEgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwMSA9IHBvaW50c1sgaW50UG9pbnQgXTtcbiAgICAgICAgICAgIHAyID0gcG9pbnRzWyBpbnRQb2ludCArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCBpbnRQb2ludCArIDIgPCBsICkge1xuXG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbIGludFBvaW50ICsgMiBdXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxuICAgICAgICAgICAgICAgIHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIGwgLSAxIF0sIHBvaW50c1sgbCAtIDIgXSApLmFkZCggcG9pbnRzWyBsIC0gMiBdICk7XG4gICAgICAgICAgICAgICAgcDMgPSB0bXA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0aGlzLnR5cGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnR5cGUgPT09ICdjZW50cmlwZXRhbCcgfHwgdGhpcy50eXBlID09PSAnY2hvcmRhbCcgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuICAgICAgICAgICAgICAgIHZhciBwb3cgPSB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG4gICAgICAgICAgICAgICAgdmFyIGR0MCA9IE1hdGgucG93KCBwMC5kaXN0YW5jZVRvU3F1YXJlZCggcDEgKSwgcG93ICk7XG4gICAgICAgICAgICAgICAgdmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XG4gICAgICAgICAgICAgICAgdmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xuICAgICAgICAgICAgICAgIGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcbiAgICAgICAgICAgICAgICBpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG4gICAgICAgICAgICAgICAgaWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xuXG4gICAgICAgICAgICAgICAgcHguaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyICk7XG4gICAgICAgICAgICAgICAgcHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG4gICAgICAgICAgICAgICAgcHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcblxuICAgICAgICAgICAgICAgIHZhciB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLnRlbnNpb24gOiAwLjU7XG4gICAgICAgICAgICAgICAgcHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRlbnNpb24gKTtcbiAgICAgICAgICAgICAgICBweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGVuc2lvbiApO1xuICAgICAgICAgICAgICAgIHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0ZW5zaW9uICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgICBweC5jYWxjKCB3ZWlnaHQgKSxcbiAgICAgICAgICAgICAgICBweS5jYWxjKCB3ZWlnaHQgKSxcbiAgICAgICAgICAgICAgICBwei5jYWxjKCB3ZWlnaHQgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHY7XG5cbiAgICAgICAgfVxuXG4gICAgKTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2xvc2VkU3BsaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICBmdW5jdGlvbiggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cbiAgICAgICAgdGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMCApICogdDsgLy8gVGhpcyBuZWVkcyB0byBiZSBmcm9tIDAtbGVuZ3RoICsxXG5cbiAgICAgICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgICAgaW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBwb2ludDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBwb2ludHMubGVuZ3RoIF07XG4gICAgICAgIHZhciBwb2ludDEgPSBwb2ludHNbICggaW50UG9pbnQgKSAlIHBvaW50cy5sZW5ndGggXTtcbiAgICAgICAgdmFyIHBvaW50MiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcbiAgICAgICAgdmFyIHBvaW50MyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIHBvaW50cy5sZW5ndGggXTtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICk7XG4gICAgICAgIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKTtcbiAgICAgICAgdmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vQW5pbWF0aW9uSGFuZGxlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxuVEhSRUUuQW5pbWF0aW9uSGFuZGxlciA9IHtcblxuICAgIExJTkVBUjogMCxcbiAgICBDQVRNVUxMUk9NOiAxLFxuICAgIENBVE1VTExST01fRk9SV0FSRDogMixcblxuICAgIC8vXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7XG5cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTtcblxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIC8vXG5cbiAgICBhbmltYXRpb25zOiBbXSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gICAgICAgIGlmICggZGF0YS5pbml0aWFsaXplZCA9PT0gdHJ1ZSApIHJldHVybiBkYXRhO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwga2V5c1xuXG4gICAgICAgIGZvciAoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCsrICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrKysgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbWludXMgdGltZXNcblxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0udGltZSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0udGltZSA9IDA7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcXVhdGVybmlvbnNcblxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgISggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90IGluc3RhbmNlb2YgVEhSRUUuUXVhdGVybmlvbiApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWF0ID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90O1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLmZyb21BcnJheSggcXVhdCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgbW9ycGggdGFyZ2V0IGtleXNcblxuICAgICAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoICYmIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCB1c2VkXG5cbiAgICAgICAgICAgICAgICB2YXIgdXNlZE1vcnBoVGFyZ2V0cyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgaysrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0rKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0TmFtZSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlZE1vcnBoVGFyZ2V0c1sgbW9ycGhUYXJnZXROYW1lIF0gPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLnVzZWRNb3JwaFRhcmdldHMgPSB1c2VkTW9ycGhUYXJnZXRzO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgYWxsIHVzZWQgb24gYWxsIGZyYW1lc1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgaysrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsdWVuY2VzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIG1vcnBoVGFyZ2V0TmFtZSBpbiB1c2VkTW9ycGhUYXJnZXRzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbSA9IDA7IG0gPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdID09PSBtb3JwaFRhcmdldE5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbHVlbmNlc1sgbW9ycGhUYXJnZXROYW1lIF0gPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNJbmZsdWVuY2VzWyBtIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbSA9PT0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNJbmZsdWVuY2VzID0gaW5mbHVlbmNlcztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwga2V5cyB0aGF0IGFyZSBvbiB0aGUgc2FtZSB0aW1lXG5cbiAgICAgICAgICAgIGZvciAoIHZhciBrID0gMTsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0udGltZSA9PT0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIC0gMSBdLnRpbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLnNwbGljZSggaywgMSApO1xuICAgICAgICAgICAgICAgICAgICBrLS07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBzZXQgaW5kZXhcblxuICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgaysrICkge1xuXG4gICAgICAgICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0uaW5kZXggPSBrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbiggcm9vdCApIHtcblxuICAgICAgICB2YXIgcGFyc2VSZWN1cnNlSGllcmFyY2h5ID0gZnVuY3Rpb24oIHJvb3QsIGhpZXJhcmNoeSApIHtcblxuICAgICAgICAgICAgaGllcmFyY2h5LnB1c2goIHJvb3QgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGMgPSAwOyBjIDwgcm9vdC5jaGlsZHJlbi5sZW5ndGg7IGMrKyApXG4gICAgICAgICAgICAgICAgcGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LmNoaWxkcmVuWyBjIF0sIGhpZXJhcmNoeSApO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0dXAgaGllcmFyY2h5XG5cbiAgICAgICAgdmFyIGhpZXJhcmNoeSA9IFtdO1xuXG4gICAgICAgIGlmICggcm9vdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgYiA9IDA7IGIgPCByb290LnNrZWxldG9uLmJvbmVzLmxlbmd0aDsgYisrICkge1xuXG4gICAgICAgICAgICAgICAgaGllcmFyY2h5LnB1c2goIHJvb3Quc2tlbGV0b24uYm9uZXNbIGIgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LCBoaWVyYXJjaHkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcblxuICAgIH0sXG5cbiAgICBwbGF5OiBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGlmICggdGhpcy5hbmltYXRpb25zLmluZGV4T2YoIGFuaW1hdGlvbiApID09PSAtMSApIHtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbiApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYW5pbWF0aW9ucy5pbmRleE9mKCBhbmltYXRpb24gKTtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSAtMSApIHtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiggZGVsdGFUaW1lTVMgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbIGkgXS5yZXNldEJsZW5kV2VpZ2h0cygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1sgaSBdLnVwZGF0ZSggZGVsdGFUaW1lTVMgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkFuaW1hdGlvbiA9IGZ1bmN0aW9uKCByb290LCBkYXRhICkge1xuXG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoIGRhdGEgKTtcbiAgICB0aGlzLmhpZXJhcmNoeSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGFyc2UoIHJvb3QgKTtcblxuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMudGltZVNjYWxlID0gMTtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLndlaWdodCA9IDA7XG5cbiAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVI7XG5cbn07XG5cblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uLFxuXG4gICAga2V5VHlwZXM6IFsgXCJwb3NcIiwgXCJyb3RcIiwgXCJzY2xcIiBdLFxuXG4gICAgcGxheTogZnVuY3Rpb24oIHN0YXJ0VGltZSwgd2VpZ2h0ICkge1xuXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG4gICAgICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0ICE9PSB1bmRlZmluZWQgPyB3ZWlnaHQgOiAxO1xuXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wbGF5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgICAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnN0b3AoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5hbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgb2JqZWN0LmFuaW1hdGlvbkNhY2hlID0ge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uV2VpZ2h0OiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWF0ZXJuaW9uV2VpZ2h0OiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVdlaWdodDogMC4wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5kYXRhLm5hbWU7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5hbmltYXRpb25zO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkNhY2hlID0gYW5pbWF0aW9uc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICBpZiAoIGFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldktleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm90OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NsOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG5leHRLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjbDogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE1hdHJpeDogb2JqZWN0Lm1hdHJpeFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb25zWyBuYW1lIF0gPSBhbmltYXRpb25DYWNoZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQga2V5cyB0byBtYXRjaCBvdXIgY3VycmVudCB0aW1lXG5cbiAgICAgICAgICAgIGZvciAoIHZhciB0ID0gMDsgdCA8IDM7IHQrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5rZXlUeXBlc1sgdCBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgMSApO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZLZXkgPSBuZXh0S2V5O1xuICAgICAgICAgICAgICAgICAgICBuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgbmV4dEtleS5pbmRleCArIDEgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXSA9IHByZXZLZXk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdID0gbmV4dEtleTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICByZXNldEJsZW5kV2VpZ2h0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkNhY2hlID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlO1xuXG4gICAgICAgICAgICBpZiAoIGFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmxlbmRpbmcgPSBhbmltYXRpb25DYWNoZS5ibGVuZGluZztcblxuICAgICAgICAgICAgICAgIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ID0gMC4wO1xuICAgICAgICAgICAgICAgIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPSAwLjA7XG4gICAgICAgICAgICAgICAgYmxlbmRpbmcuc2NhbGVXZWlnaHQgPSAwLjA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlOiAoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBuZXdWZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgbmV3UXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgLy8gQ2F0bXVsbC1Sb20gc3BsaW5lXG5cbiAgICAgICAgdmFyIGludGVycG9sYXRlQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCBwb2ludHMsIHNjYWxlICkge1xuXG4gICAgICAgICAgICB2YXIgYyA9IFtdLFxuICAgICAgICAgICAgICAgIHYzID0gW10sXG4gICAgICAgICAgICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcbiAgICAgICAgICAgICAgICBwYSwgcGIsIHBjLCBwZDtcblxuICAgICAgICAgICAgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiBzY2FsZTtcbiAgICAgICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgICAgICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgICAgICAgIGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG4gICAgICAgICAgICBjWyAxIF0gPSBpbnRQb2ludDtcbiAgICAgICAgICAgIGNbIDIgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMTtcbiAgICAgICAgICAgIGNbIDMgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcblxuICAgICAgICAgICAgcGEgPSBwb2ludHNbIGNbIDAgXSBdO1xuICAgICAgICAgICAgcGIgPSBwb2ludHNbIGNbIDEgXSBdO1xuICAgICAgICAgICAgcGMgPSBwb2ludHNbIGNbIDIgXSBdO1xuICAgICAgICAgICAgcGQgPSBwb2ludHNbIGNbIDMgXSBdO1xuXG4gICAgICAgICAgICB3MiA9IHdlaWdodCAqIHdlaWdodDtcbiAgICAgICAgICAgIHczID0gd2VpZ2h0ICogdzI7XG5cbiAgICAgICAgICAgIHYzWyAwIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDAgXSwgcGJbIDAgXSwgcGNbIDAgXSwgcGRbIDAgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICAgICAgICAgIHYzWyAxIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDEgXSwgcGJbIDEgXSwgcGNbIDEgXSwgcGRbIDEgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICAgICAgICAgIHYzWyAyIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDIgXSwgcGJbIDIgXSwgcGNbIDIgXSwgcGRbIDIgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHYzO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cbiAgICAgICAgICAgIHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LFxuICAgICAgICAgICAgICAgIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cbiAgICAgICAgICAgIHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRlbHRhICkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkZWx0YSAqIHRoaXMudGltZVNjYWxlO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMud2VpZ2h0ID09PSAwIClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5jdXJyZW50VGltZSA+IGR1cmF0aW9uIHx8IHRoaXMuY3VycmVudFRpbWUgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmxvb3AgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSAlPSBkdXJhdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY3VycmVudFRpbWUgPCAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZHVyYXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkNhY2hlID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbIHRoaXMuZGF0YS5uYW1lIF07XG4gICAgICAgICAgICAgICAgdmFyIGJsZW5kaW5nID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHBvcy9yb3Qvc2NsXG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGtleXNcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMua2V5VHlwZXNbIHQgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCB0aGlzLnRpbWVTY2FsZSA+IDAgJiYgbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzLnRpbWVTY2FsZSA8IDAgJiYgcHJldktleS50aW1lID49IHRoaXMuY3VycmVudFRpbWUgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldktleSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIG5leHRLZXkudGltZSA8IHRoaXMuY3VycmVudFRpbWUgJiYgbmV4dEtleS5pbmRleCA+IHByZXZLZXkuaW5kZXggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2S2V5ID0gbmV4dEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgbmV4dEtleS5pbmRleCArIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF0gPSBwcmV2S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdID0gbmV4dEtleTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gKCB0aGlzLmN1cnJlbnRUaW1lIC0gcHJldktleS50aW1lICkgLyAoIG5leHRLZXkudGltZSAtIHByZXZLZXkudGltZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2WFlaID0gcHJldktleVsgdHlwZSBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFhZWiA9IG5leHRLZXlbIHR5cGUgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjYWxlIDwgMCApIHNjYWxlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY2FsZSA+IDEgKSBzY2FsZSA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJwb2xhdGVcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwicG9zXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJsZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnBvc2l0aW9uLmxlcnAoIG5ld1ZlY3RvciwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sgMCBdID0gdGhpcy5nZXRQcmV2S2V5V2l0aCggXCJwb3NcIiwgaCwgcHJldktleS5pbmRleCAtIDEgKVsgXCJwb3NcIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sgMSBdID0gcHJldlhZWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbIDIgXSA9IG5leHRYWVo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWyAzIF0gPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInBvc1wiLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApWyBcInBvc1wiIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHNjYWxlICogMC4zMyArIDAuMzM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBvaW50ID0gaW50ZXJwb2xhdGVDYXRtdWxsUm9tKCBwb2ludHMsIHNjYWxlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibGVuZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IG9iamVjdC5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlY3Rvci54ID0gdmVjdG9yLnggKyAoIGN1cnJlbnRQb2ludFsgMCBdIC0gdmVjdG9yLnggKSAqIHByb3BvcnRpb25hbFdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWN0b3IueSA9IHZlY3Rvci55ICsgKCBjdXJyZW50UG9pbnRbIDEgXSAtIHZlY3Rvci55ICkgKiBwcm9wb3J0aW9uYWxXZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjdG9yLnogPSB2ZWN0b3IueiArICggY3VycmVudFBvaW50WyAyIF0gLSB2ZWN0b3IueiApICogcHJvcG9ydGlvbmFsV2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9yd2FyZFBvaW50ID0gaW50ZXJwb2xhdGVDYXRtdWxsUm9tKCBwb2ludHMsIHNjYWxlICogMS4wMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXQoIGZvcndhcmRQb2ludFsgMCBdLCBmb3J3YXJkUG9pbnRbIDEgXSwgZm9yd2FyZFBvaW50WyAyIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnN1YiggdmVjdG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC55ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoIHRhcmdldC54LCB0YXJnZXQueiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qucm90YXRpb24uc2V0KCAwLCBhbmdsZSwgMCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdHlwZSA9PT0gXCJyb3RcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuUXVhdGVybmlvbi5zbGVycCggcHJldlhZWiwgbmV4dFhZWiwgbmV3UXVhdCwgc2NhbGUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcGF5aW5nIHRoZSBjb3N0IG9mIGFuIGFkZGl0aW9uYWwgc2xlcnAgaWYgd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnF1YXRlcm5pb24uY29weSggbmV3UXVhdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIG9iamVjdC5xdWF0ZXJuaW9uLCBuZXdRdWF0LCBvYmplY3QucXVhdGVybmlvbiwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHR5cGUgPT09IFwic2NsXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmVjdG9yLnkgPSBwcmV2WFlaWyAxIF0gKyAoIG5leHRYWVpbIDEgXSAtIHByZXZYWVpbIDEgXSApICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnNjYWxlV2VpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Quc2NhbGUubGVycCggbmV3VmVjdG9yLCBwcm9wb3J0aW9uYWxXZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nLnNjYWxlV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9O1xuXG4gICAgfSApKCksXG5cbiAgICBnZXROZXh0S2V5V2l0aDogZnVuY3Rpb24oIHR5cGUsIGgsIGtleSApIHtcblxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgICAgIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAgICAgICAga2V5ID0ga2V5IDwga2V5cy5sZW5ndGggLSAxID8ga2V5IDoga2V5cy5sZW5ndGggLSAxO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGtleSA9IGtleSAlIGtleXMubGVuZ3RoO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkrKyApIHtcblxuICAgICAgICAgICAgaWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1sga2V5IF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG5cbiAgICB9LFxuXG4gICAgZ2V0UHJldktleVdpdGg6IGZ1bmN0aW9uKCB0eXBlLCBoLCBrZXkgKSB7XG5cbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcblxuICAgICAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cbiAgICAgICAgICAgIGtleSA9IGtleSA+IDAgPyBrZXkgOiAwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgZm9yICggOyBrZXkgPj0gMDsga2V5LS0gKSB7XG5cbiAgICAgICAgICAgIGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vS2V5RnJhbWVBbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGtoYW5nIGR1b25nXG4gKiBAYXV0aG9yIGVyaWsga2l0c29uXG4gKi9cblxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24gPSBmdW5jdGlvbiggZGF0YSApIHtcblxuICAgIHRoaXMucm9vdCA9IGRhdGEubm9kZTtcbiAgICB0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoIGRhdGEgKTtcbiAgICB0aGlzLmhpZXJhcmNoeSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGFyc2UoIHRoaXMucm9vdCApO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMudGltZVNjYWxlID0gMC4wMDE7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmxvb3AgPSB0cnVlO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0byBmaXJzdCBrZXlmcmFtZXNcblxuICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMsXG4gICAgICAgICAgICBzaWRzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLnNpZHMsXG4gICAgICAgICAgICBvYmogPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICAgIGlmICgga2V5cy5sZW5ndGggJiYgc2lkcyApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIHMgPSAwOyBzIDwgc2lkcy5sZW5ndGg7IHMrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBzaWQgPSBzaWRzWyBzIF0sXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBzaWQsIGgsIDAgKTtcblxuICAgICAgICAgICAgICAgIGlmICggbmV4dCApIHtcblxuICAgICAgICAgICAgICAgICAgICBuZXh0LmFwcGx5KCBzaWQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmoubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLm5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgICAgICBvYmoubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuS2V5RnJhbWVBbmltYXRpb24sXG5cbiAgICBwbGF5OiBmdW5jdGlvbiggc3RhcnRUaW1lICkge1xuXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG5cbiAgICAgICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gcmVzZXQga2V5IGNhY2hlXG5cbiAgICAgICAgICAgIHZhciBoLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICAgICAgZm9yICggaCA9IDA7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4ID0gb2JqZWN0Lm1hdHJpeDtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGtleXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUucHJldktleSA9IGtleXNbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5uZXh0S2V5ID0ga2V5c1sgMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gTWF0aC5taW4oIGtleXNbIDAgXS50aW1lLCB0aGlzLnN0YXJ0VGltZSApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFRpbWUgPSBNYXRoLm1heCgga2V5c1sga2V5cy5sZW5ndGggLSAxIF0udGltZSwgdGhpcy5lbmRUaW1lICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51cGRhdGUoIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGxheSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnN0b3AoIHRoaXMgKTtcblxuICAgICAgICAvLyByZXNldCBKSVQgbWF0cml4IGFuZCByZW1vdmUgY2FjaGVcblxuICAgICAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCB0aGlzLmRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCsrICkge1xuXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICAgICAgICBpZiAoIG5vZGUuYW5pbWF0aW9uQ2FjaGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XG5cbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5jb3B5KCBvYmoubWF0cml4ICk7XG4gICAgICAgICAgICAgICAgb2JqLm1hdHJpeCA9IG9yaWdpbmFsO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuYW5pbWF0aW9uQ2FjaGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiggZGVsdGEgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkZWx0YSAqIHRoaXMudGltZVNjYWxlO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoIHRoaXMubG9vcCA9PT0gdHJ1ZSAmJiB0aGlzLmN1cnJlbnRUaW1lID4gZHVyYXRpb24gKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1pbiggdGhpcy5jdXJyZW50VGltZSwgZHVyYXRpb24gKTtcblxuICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBub2RlLmtleXMsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUgPSBub2RlLmFuaW1hdGlvbkNhY2hlO1xuXG5cbiAgICAgICAgICAgIGlmICgga2V5cy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRLZXkgPSBhbmltYXRpb25DYWNoZS5uZXh0S2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBuZXh0S2V5LnRpbWUgPD0gdGhpcy5jdXJyZW50VGltZSApIHtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIG5leHRLZXkudGltZSA8IHRoaXMuY3VycmVudFRpbWUgJiYgbmV4dEtleS5pbmRleCA+IHByZXZLZXkuaW5kZXggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZLZXkgPSBuZXh0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEtleSA9IGtleXNbIHByZXZLZXkuaW5kZXggKyAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBwcmV2S2V5O1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZS5uZXh0S2V5ID0gbmV4dEtleTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbmV4dEtleS50aW1lID49IHRoaXMuY3VycmVudFRpbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldktleS5pbnRlcnBvbGF0ZSggbmV4dEtleSwgdGhpcy5jdXJyZW50VGltZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIG5leHRLZXkudGltZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLm5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldE5leHRLZXlXaXRoOiBmdW5jdGlvbiggc2lkLCBoLCBrZXkgKSB7XG5cbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcbiAgICAgICAga2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBrZXkgPCBrZXlzLmxlbmd0aDsga2V5KysgKSB7XG5cbiAgICAgICAgICAgIGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5c1sgMCBdO1xuXG4gICAgfSxcblxuICAgIGdldFByZXZLZXlXaXRoOiBmdW5jdGlvbiggc2lkLCBoLCBrZXkgKSB7XG5cbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcbiAgICAgICAga2V5ID0ga2V5ID49IDAgPyBrZXkgOiBrZXkgKyBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKCA7IGtleSA+PSAwOyBrZXktLSApIHtcblxuICAgICAgICAgICAgaWYgKCBrZXlzWyBrZXkgXS5oYXNUYXJnZXQoIHNpZCApICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9Nb3JwaEFuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3Igd2lsbHktdnZ1IC8gaHR0cDovL3dpbGx5LXZ2dS5naXRodWIuaW9cbiAqL1xuXG5USFJFRS5Nb3JwaEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBtZXNoICkge1xuXG4gICAgdGhpcy5tZXNoID0gbWVzaDtcbiAgICB0aGlzLmZyYW1lcyA9IG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMTAwMDtcbiAgICB0aGlzLmxvb3AgPSB0cnVlO1xuICAgIHRoaXMubGFzdEZyYW1lID0gMDtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTW9ycGhBbmltYXRpb24sXG5cbiAgICBwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICB9LFxuXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiggZGVsdGEgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkZWx0YTtcblxuICAgICAgICBpZiAoIHRoaXMubG9vcCA9PT0gdHJ1ZSAmJiB0aGlzLmN1cnJlbnRUaW1lID4gdGhpcy5kdXJhdGlvbiApIHtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSAlPSB0aGlzLmR1cmF0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuZHVyYXRpb24gKTtcblxuICAgICAgICB2YXIgZnJhbWVUaW1lID0gdGhpcy5kdXJhdGlvbiAvIHRoaXMuZnJhbWVzO1xuICAgICAgICB2YXIgZnJhbWUgPSBNYXRoLmZsb29yKCB0aGlzLmN1cnJlbnRUaW1lIC8gZnJhbWVUaW1lICk7XG5cbiAgICAgICAgdmFyIGluZmx1ZW5jZXMgPSB0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgICAgIGlmICggZnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lICkge1xuXG4gICAgICAgICAgICBpbmZsdWVuY2VzWyB0aGlzLmxhc3RGcmFtZSBdID0gMDtcbiAgICAgICAgICAgIGluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEZyYW1lIF0gPSAxO1xuICAgICAgICAgICAgaW5mbHVlbmNlc1sgZnJhbWUgXSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMubGFzdEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWl4ID0gKCB0aGlzLmN1cnJlbnRUaW1lICUgZnJhbWVUaW1lICkgLyBmcmFtZVRpbWU7XG5cbiAgICAgICAgaW5mbHVlbmNlc1sgZnJhbWUgXSA9IG1peDtcbiAgICAgICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0RnJhbWUgXSA9IDEgLSBtaXg7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXG4gKi9cblxuVEhSRUUuQm94R2VvbWV0cnkgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcbiAgICB9O1xuXG4gICAgdGhpcy53aWR0aFNlZ21lbnRzID0gd2lkdGhTZWdtZW50cyB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xuICAgIHRoaXMuZGVwdGhTZWdtZW50cyA9IGRlcHRoU2VnbWVudHMgfHwgMTtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBkZXB0aF9oYWxmID0gZGVwdGggLyAyO1xuXG4gICAgYnVpbGRQbGFuZSggJ3onLCAneScsIC0xLCAtMSwgZGVwdGgsIGhlaWdodCwgd2lkdGhfaGFsZiwgMCApOyAvLyBweFxuICAgIGJ1aWxkUGxhbmUoICd6JywgJ3knLCAxLCAtMSwgZGVwdGgsIGhlaWdodCwgLXdpZHRoX2hhbGYsIDEgKTsgLy8gbnhcbiAgICBidWlsZFBsYW5lKCAneCcsICd6JywgMSwgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHRfaGFsZiwgMiApOyAvLyBweVxuICAgIGJ1aWxkUGxhbmUoICd4JywgJ3onLCAxLCAtMSwgd2lkdGgsIGRlcHRoLCAtaGVpZ2h0X2hhbGYsIDMgKTsgLy8gbnlcbiAgICBidWlsZFBsYW5lKCAneCcsICd5JywgMSwgLTEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoX2hhbGYsIDQgKTsgLy8gcHpcbiAgICBidWlsZFBsYW5lKCAneCcsICd5JywgLTEsIC0xLCB3aWR0aCwgaGVpZ2h0LCAtZGVwdGhfaGFsZiwgNSApOyAvLyBuelxuXG4gICAgZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICAgICAgdmFyIHcsIGl4LCBpeSxcbiAgICAgICAgICAgIGdyaWRYID0gc2NvcGUud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgIGdyaWRZID0gc2NvcGUuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICB3aWR0aF9oYWxmID0gd2lkdGggLyAyLFxuICAgICAgICAgICAgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgb2Zmc2V0ID0gc2NvcGUudmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3gnICkgKSB7XG5cbiAgICAgICAgICAgIHcgPSAneic7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XG5cbiAgICAgICAgICAgIHcgPSAneSc7XG4gICAgICAgICAgICBncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggKCB1ID09PSAneicgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3onICkgKSB7XG5cbiAgICAgICAgICAgIHcgPSAneCc7XG4gICAgICAgICAgICBncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncmlkWDEgPSBncmlkWCArIDEsXG4gICAgICAgICAgICBncmlkWTEgPSBncmlkWSArIDEsXG4gICAgICAgICAgICBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWCxcbiAgICAgICAgICAgIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXG4gICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0xO1xuXG4gICAgICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5KysgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4KysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgICAgICB2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcbiAgICAgICAgICAgICAgICB2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xuICAgICAgICAgICAgICAgIHZlY3RvclsgdyBdID0gZGVwdGg7XG5cbiAgICAgICAgICAgICAgICBzY29wZS52ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5KysgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXgrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgICAgICAgICAgIHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG4gICAgICAgICAgICAgICAgdmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xuICAgICAgICAgICAgICAgIHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xuICAgICAgICAgICAgICAgIHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XG4gICAgICAgICAgICAgICAgdmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSArIG9mZnNldCwgYiArIG9mZnNldCwgZCArIG9mZnNldCApO1xuICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG4gICAgICAgICAgICAgICAgZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIgKyBvZmZzZXQsIGMgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcbiAgICAgICAgICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICAgICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xuICAgICAgICAgICAgICAgIGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbn07XG5cblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94R2VvbWV0cnk7XG5cblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGgsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5kZXB0aCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRlcHRoU2VnbWVudHNcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG5USFJFRS5DdWJlR2VvbWV0cnkgPSBUSFJFRS5Cb3hHZW9tZXRyeTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ2lyY2xlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGh1Z2hlc1xuICovXG5cblRIUkVFLkNpcmNsZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcblxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XG5cbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICAgIHZhciBpLCB1dnMgPSBbXSxcbiAgICAgICAgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgY2VudGVyVVYgPSBuZXcgVEhSRUUuVmVjdG9yMiggMC41LCAwLjUgKTtcblxuICAgIHRoaXMudmVydGljZXMucHVzaCggY2VudGVyICk7XG4gICAgdXZzLnB1c2goIGNlbnRlclVWICk7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSsrICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBpIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuICAgICAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG4gICAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuICAgICAgICB1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyByYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gcmFkaXVzICsgMSApIC8gMiApICk7XG5cbiAgICB9XG5cbiAgICB2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICBmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSsrICkge1xuXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBpLCBpICsgMSwgMCwgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgaSBdLmNsb25lKCksIHV2c1sgaSArIDEgXS5jbG9uZSgpLCBjZW50ZXJVVi5jbG9uZSgpIF0gKTtcblxuICAgIH1cblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2lyY2xlR2VvbWV0cnk7XG5cblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuc2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVCdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcblxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XG5cbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHNlZ21lbnRzICsgMjtcblxuICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcbiAgICB2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xuICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcblxuICAgIC8vIGNlbnRlciBkYXRhIGlzIGFscmVhZHkgemVybywgYnV0IG5lZWQgdG8gc2V0IGEgZmV3IGV4dHJhc1xuICAgIG5vcm1hbHNbIDMgXSA9IDEuMDtcbiAgICB1dnNbIDAgXSA9IDAuNTtcbiAgICB1dnNbIDEgXSA9IDAuNTtcblxuICAgIGZvciAoIHZhciBzID0gMCwgaSA9IDMsIGlpID0gMjsgcyA8PSBzZWdtZW50czsgcysrLCBpICs9IDMsIGlpICs9IDIgKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cbiAgICAgICAgcG9zaXRpb25zWyBpIF0gPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuICAgICAgICBwb3NpdGlvbnNbIGkgKyAxIF0gPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG4gICAgICAgIG5vcm1hbHNbIGkgKyAyIF0gPSAxOyAvLyBub3JtYWwgelxuXG4gICAgICAgIHV2c1sgaWkgXSA9ICggcG9zaXRpb25zWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuICAgICAgICB1dnNbIGlpICsgMSBdID0gKCBwb3NpdGlvbnNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG4gICAgfVxuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSBzZWdtZW50czsgaSsrICkge1xuXG4gICAgICAgIGluZGljZXMucHVzaCggaSApO1xuICAgICAgICBpbmRpY2VzLnB1c2goIGkgKyAxICk7XG4gICAgICAgIGluZGljZXMucHVzaCggMCApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBpbmRpY2VzICksIDEgKSApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG5cblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuc2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DeWxpbmRlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzVG9wOiByYWRpdXNUb3AsXG4gICAgICAgIHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuXG4gICAgcmFkaXVzVG9wID0gcmFkaXVzVG9wICE9PSB1bmRlZmluZWQgPyByYWRpdXNUb3AgOiAyMDtcbiAgICByYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gIT09IHVuZGVmaW5lZCA/IHJhZGl1c0JvdHRvbSA6IDIwO1xuICAgIGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogMTAwO1xuXG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICAgIGhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcblxuICAgIG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogMiAqIE1hdGguUEk7XG5cbiAgICB2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XG5cbiAgICB2YXIgeCwgeSwgdmVydGljZXMgPSBbXSxcbiAgICAgICAgdXZzID0gW107XG5cbiAgICBmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSsrICkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuICAgICAgICB2YXIgdXZzUm93ID0gW107XG5cbiAgICAgICAgdmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG4gICAgICAgIHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XG4gICAgICAgICAgICB2ZXJ0ZXgueSA9IC12ICogaGVpZ2h0ICsgaGVpZ2h0SGFsZjtcbiAgICAgICAgICAgIHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgICAgICAgdmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG4gICAgICAgICAgICB1dnNSb3cucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcbiAgICAgICAgdXZzLnB1c2goIHV2c1JvdyApO1xuXG4gICAgfVxuXG4gICAgdmFyIHRhblRoZXRhID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcbiAgICB2YXIgbmEsIG5iO1xuXG4gICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCsrICkge1xuXG4gICAgICAgIGlmICggcmFkaXVzVG9wICE9PSAwICkge1xuXG4gICAgICAgICAgICBuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggXSBdLmNsb25lKCk7XG4gICAgICAgICAgICBuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCBdIF0uY2xvbmUoKTtcbiAgICAgICAgICAgIG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCArIDEgXSBdLmNsb25lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgbmIuc2V0WSggTWF0aC5zcXJ0KCBuYi54ICogbmIueCArIG5iLnogKiBuYi56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xuICAgICAgICAgICAgdmFyIHYyID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcbiAgICAgICAgICAgIHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xuICAgICAgICAgICAgdmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblxuICAgICAgICAgICAgdmFyIG4xID0gbmEuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBuMiA9IG5hLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbjMgPSBuYi5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIG40ID0gbmIuY2xvbmUoKTtcblxuICAgICAgICAgICAgdmFyIHV2MSA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciB1djIgPSB1dnNbIHkgKyAxIF1bIHggXS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHV2NCA9IHV2c1sgeSBdWyB4ICsgMSBdLmNsb25lKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHY0LCBbIG4xLCBuMiwgbjQgXSApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djQgXSApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYyLmNsb25lKCksIHV2MywgdXY0LmNsb25lKCkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHRvcCBjYXBcblxuICAgIGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNUb3AgPiAwICkge1xuXG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xuXG4gICAgICAgIGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHgrKyApIHtcblxuICAgICAgICAgICAgdmFyIHYxID0gdmVydGljZXNbIDAgXVsgeCBdO1xuICAgICAgICAgICAgdmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcbiAgICAgICAgICAgIHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgdmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcbiAgICAgICAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG4gICAgICAgICAgICB2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgICAgICAgICB2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHV2MiA9IHV2c1sgMCBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSwgdW5kZWZpbmVkLCAxICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gYm90dG9tIGNhcFxuXG4gICAgaWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLWhlaWdodEhhbGYsIDAgKSApO1xuXG4gICAgICAgIGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHgrKyApIHtcblxuICAgICAgICAgICAgdmFyIHYxID0gdmVydGljZXNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF07XG4gICAgICAgICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdO1xuICAgICAgICAgICAgdmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICB2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTEsIDAgKTtcbiAgICAgICAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtMSwgMCApO1xuICAgICAgICAgICAgdmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0xLCAwICk7XG5cbiAgICAgICAgICAgIHZhciB1djEgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciB1djIgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggXS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMSApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMiApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN5bGluZGVyR2VvbWV0cnk7XG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1c1RvcCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1c0JvdHRvbSxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5vcGVuRW5kZWQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9FZGdlc0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRWRnZXNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xuXG4gICAgdmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aHJlc2hvbGRBbmdsZSApICk7XG5cbiAgICB2YXIgZWRnZSA9IFsgMCwgMCBdLFxuICAgICAgICBoYXNoID0ge307XG4gICAgdmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHJldHVybiBhIC0gYjtcblxuICAgIH07XG5cbiAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG4gICAgdmFyIGdlb21ldHJ5MjtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICBnZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgZ2VvbWV0cnkyLmZyb21CdWZmZXJHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBnZW9tZXRyeTIgPSBnZW9tZXRyeS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgZ2VvbWV0cnkyLm1lcmdlVmVydGljZXMoKTtcbiAgICBnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG4gICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkyLmZhY2VzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqKysgKSB7XG5cbiAgICAgICAgICAgIGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuICAgICAgICAgICAgZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG4gICAgICAgICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgICAgICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmVydDE6IGVkZ2VbIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydDI6IGVkZ2VbIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgZmFjZTE6IGksXG4gICAgICAgICAgICAgICAgICAgIGZhY2UyOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGhhc2hbIGtleSBdLmZhY2UyID0gaTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBbXTtcblxuICAgIGZvciAoIHZhciBrZXkgaW4gaGFzaCApIHtcblxuICAgICAgICB2YXIgaCA9IGhhc2hbIGtleSBdO1xuXG4gICAgICAgIGlmICggaC5mYWNlMiA9PT0gdW5kZWZpbmVkIHx8IGZhY2VzWyBoLmZhY2UxIF0ubm9ybWFsLmRvdCggZmFjZXNbIGguZmFjZTIgXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaC52ZXJ0MSBdO1xuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC54ICk7XG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnkgKTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueiApO1xuXG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaC52ZXJ0MiBdO1xuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC54ICk7XG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnkgKTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueiApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBjb29yZHMgKSwgMyApICk7XG5cbn07XG5cblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5FZGdlc0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcbiAqXG4gKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcbiAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xuICpcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlUGF0aD4gLy8gM2Qgc3BsaW5lIHBhdGggdG8gZXh0cnVkZSBzaGFwZSBhbG9uZy4gKGNyZWF0ZXMgRnJhbWVzIGlmIC5mcmFtZXMgYXJlbid0IGRlZmluZWQpXG4gKiAgZnJhbWVzOiA8VEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcz4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xuICpcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqKi9cblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICAgIGlmICggdHlwZW9mKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblxuICAgICAgICBzaGFwZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XG5cbiAgICBzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XG5cbiAgICB0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgLy8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcbiAgICAvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cbiAgICAvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXG5cbiAgICAvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgIC8vY29uc29sZS5sb2coIFwidG9va1wiLCAoIERhdGUubm93KCkgLSBzdGFydFRpbWUgKSApO1xuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xuXG4gICAgZm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMrKyApIHtcblxuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcbiAgICAgICAgdGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKCBzaGFwZSwgb3B0aW9ucyApIHtcblxuICAgIHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XG5cbiAgICB2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcbiAgICB2YXIgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAyOyAvLyA4XG4gICAgdmFyIGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cbiAgICB2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcblxuICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuICAgIHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXG4gICAgdmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcbiAgICB2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXG4gICAgdmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xuXG4gICAgdmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcbiAgICBpZiAoIGV4dHJ1ZGVQYXRoICkge1xuXG4gICAgICAgIGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XG5cbiAgICAgICAgZXh0cnVkZUJ5UGF0aCA9IHRydWU7XG4gICAgICAgIGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuICAgICAgICAvLyBTRVRVUCBUTkIgdmFyaWFibGVzXG5cbiAgICAgICAgLy8gUmV1c2UgVE5CIGZyb20gVHViZUdlb210cnkgZm9yIG5vdy5cbiAgICAgICAgLy8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuICAgICAgICBzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIGV4dHJ1ZGVQYXRoLCBzdGVwcywgZmFsc2UgKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuICAgICAgICBiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHBvc2l0aW9uMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB9XG5cbiAgICAvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcblxuICAgIGlmICggIWJldmVsRW5hYmxlZCApIHtcblxuICAgICAgICBiZXZlbFNlZ21lbnRzID0gMDtcbiAgICAgICAgYmV2ZWxUaGlja25lc3MgPSAwO1xuICAgICAgICBiZXZlbFNpemUgPSAwO1xuXG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXG5cbiAgICB2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgIHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuICAgIHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG4gICAgdmFyIHJldmVyc2UgPSAhVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XG5cbiAgICBpZiAoIHJldmVyc2UgKSB7XG5cbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cbiAgICAgICAgLy8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cblxuICAgICAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG5cbiAgICAgICAgICAgIGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XG5cbiAgICAgICAgICAgICAgICBob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldmVyc2UgPSBmYWxzZTsgLy8gSWYgdmVydGljZXMgYXJlIGluIG9yZGVyIG5vdywgd2Ugc2hvdWxkbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlbSBhZ2FpbiAoaG9wZWZ1bGx5KSFcblxuICAgIH1cblxuXG4gICAgdmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cbiAgICAvKiBWZXJ0aWNlcyAqL1xuXG4gICAgdmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzY2FsZVB0MiggcHQsIHZlYywgc2l6ZSApIHtcblxuICAgICAgICBpZiAoICF2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcblxuICAgICAgICByZXR1cm4gdmVjLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIHNpemUgKS5hZGQoIHB0ICk7XG5cbiAgICB9XG5cbiAgICB2YXIgYiwgYnMsIHQsIHosXG4gICAgICAgIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XG5cblxuICAgIC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG4gICAgZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG4gICAgICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgICAgIC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcbiAgICAgICAgLy8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuICAgICAgICAvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cbiAgICAgICAgLy8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuICAgICAgICB2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7IC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuICAgICAgICAvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG4gICAgICAgIC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cbiAgICAgICAgdmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsXG4gICAgICAgICAgICB2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xuICAgICAgICB2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcbiAgICAgICAgICAgIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cbiAgICAgICAgdmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXG4gICAgICAgIHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG4gICAgICAgIGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgIC8vIG5vdCBjb2xsaW5lYXJcblxuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cbiAgICAgICAgICAgIHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcbiAgICAgICAgICAgIHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG4gICAgICAgICAgICAvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cbiAgICAgICAgICAgIHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xuICAgICAgICAgICAgdmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XG5cbiAgICAgICAgICAgIHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xuICAgICAgICAgICAgdmFyIHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XG5cbiAgICAgICAgICAgIC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICAgICAgICAgIHZhciBzZiA9ICggKCBwdE5leHRTaGlmdF94IC0gcHRQcmV2U2hpZnRfeCApICogdl9uZXh0X3kgLVxuICAgICAgICAgICAgICAgICAgICAoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCApIC9cbiAgICAgICAgICAgICAgICAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cbiAgICAgICAgICAgIC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICAgICAgICAgIHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcbiAgICAgICAgICAgIHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcblxuICAgICAgICAgICAgLy8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcbiAgICAgICAgICAgIC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcbiAgICAgICAgICAgIHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcbiAgICAgICAgICAgIGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTsgLy8gYXNzdW1lczogb3Bwb3NpdGVcbiAgICAgICAgICAgIGlmICggdl9wcmV2X3ggPiBFUFNJTE9OICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2X25leHRfeCA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZfcHJldl94IDwgLUVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2X25leHRfeCA8IC1FUFNJTE9OICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGRpcmVjdGlvbl9lcSApIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG4gICAgICAgICAgICAgICAgdl90cmFuc194ID0gLXZfcHJldl95O1xuICAgICAgICAgICAgICAgIHZfdHJhbnNfeSA9IHZfcHJldl94O1xuICAgICAgICAgICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVwiKTtcbiAgICAgICAgICAgICAgICB2X3RyYW5zX3ggPSB2X3ByZXZfeDtcbiAgICAgICAgICAgICAgICB2X3RyYW5zX3kgPSB2X3ByZXZfeTtcbiAgICAgICAgICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSAvIDIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XG5cbiAgICB9XG5cblxuICAgIHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpKyssIGorKywgaysrICkge1xuXG4gICAgICAgIGlmICggaiA9PT0gaWwgKSBqID0gMDtcbiAgICAgICAgaWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG4gICAgICAgIC8vICAoaiktLS0oaSktLS0oaylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cbiAgICAgICAgY29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcblxuICAgIH1cblxuICAgIHZhciBob2xlc01vdmVtZW50cyA9IFtdLFxuICAgICAgICBvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XG5cbiAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgICAgICBvbmVIb2xlTW92ZW1lbnRzID0gW107XG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSsrLCBqKyssIGsrKyApIHtcblxuICAgICAgICAgICAgaWYgKCBqID09PSBpbCApIGogPSAwO1xuICAgICAgICAgICAgaWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG4gICAgICAgICAgICAvLyAgKGopLS0tKGkpLS0tKGspXG4gICAgICAgICAgICBvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XG4gICAgICAgIHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cbiAgICB9XG5cblxuICAgIC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xuXG4gICAgZm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiKysgKSB7XG5cbiAgICAgICAgLy9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cbiAgICAgICAgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuICAgICAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cbiAgICAgICAgLy96ID0gYmV2ZWxUaGlja25lc3MgKiB0O1xuICAgICAgICBicyA9IGJldmVsU2l6ZSAqICggTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApICk7IC8vIGN1cnZlZFxuICAgICAgICAvL2JzID0gYmV2ZWxTaXplICogdDsgLy8gbGluZWFyXG5cbiAgICAgICAgLy8gY29udHJhY3Qgc2hhcGVcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCAteiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHBhbmQgaG9sZXNcblxuICAgICAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICAgICAgICBvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG4gICAgICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksIC16ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBicyA9IGJldmVsU2l6ZTtcblxuICAgIC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkrKyApIHtcblxuICAgICAgICB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgICAgIGlmICggIWV4dHJ1ZGVCeVBhdGggKSB7XG5cbiAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCAwICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcblxuICAgICAgICAgICAgbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuICAgICAgICAgICAgYmlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuICAgICAgICAgICAgcG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xuXG4gICAgICAgICAgICB2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cbiAgICAvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXG5cbiAgICB2YXIgcztcblxuICAgIGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzKysgKSB7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCB2bGVuOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggIWV4dHJ1ZGVCeVBhdGggKSB7XG5cbiAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXG4gICAgICAgICAgICAgICAgbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuICAgICAgICAgICAgICAgIGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cbiAgICAgICAgICAgICAgICB2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcblxuICAgIC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcbiAgICBmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYi0tICkge1xuXG4gICAgICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICAgICAgeiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuICAgICAgICAvL2JzID0gYmV2ZWxTaXplICogKCAxLU1hdGguc2luICggKCAxIC0gdCApICogTWF0aC5QSS8yICkgKTtcbiAgICAgICAgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XG5cbiAgICAgICAgLy8gY29udHJhY3Qgc2hhcGVcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG4gICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50ICsgeiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHBhbmQgaG9sZXNcblxuICAgICAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICAgICAgICBvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50ICsgeiApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qIEZhY2VzICovXG5cbiAgICAvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xuXG4gICAgYnVpbGRMaWRGYWNlcygpO1xuXG4gICAgLy8gU2lkZXMgZmFjZXNcblxuICAgIGJ1aWxkU2lkZUZhY2VzKCk7XG5cblxuICAgIC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcblxuICAgIGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cbiAgICAgICAgaWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuICAgICAgICAgICAgLy8gQm90dG9tIGZhY2VzXG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG4gICAgICAgICAgICBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cbiAgICAgICAgICAgIC8vIFRvcCBmYWNlc1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICAgICAgICAgIGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBCb3R0b20gZmFjZXNcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRvcCBmYWNlc1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICAgICAgICAgIGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxuXG4gICAgZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cbiAgICAgICAgdmFyIGxheWVyb2Zmc2V0ID0gMDtcbiAgICAgICAgc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xuICAgICAgICBsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICAgICAgICBzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xuXG4gICAgICAgICAgICAvLywgdHJ1ZVxuICAgICAgICAgICAgbGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XG5cbiAgICAgICAgdmFyIGosIGs7XG4gICAgICAgIGkgPSBjb250b3VyLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoIC0taSA+PSAwICkge1xuXG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIGsgPSBpIC0gMTtcbiAgICAgICAgICAgIGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIHMgPSAwLFxuICAgICAgICAgICAgICAgIHNsID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcblxuICAgICAgICAgICAgZm9yICggcyA9IDA7IHMgPCBzbDsgcysrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNsZW4xID0gdmxlbiAqIHM7XG4gICAgICAgICAgICAgICAgdmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcblxuICAgICAgICAgICAgICAgIHZhciBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXG4gICAgICAgICAgICAgICAgICAgIGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcbiAgICAgICAgICAgICAgICAgICAgYyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuICAgICAgICAgICAgICAgICAgICBkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XG5cbiAgICAgICAgICAgICAgICBmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcblxuICAgICAgICBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuICAgICAgICBhICs9IHNoYXBlc09mZnNldDtcbiAgICAgICAgYiArPSBzaGFwZXNPZmZzZXQ7XG4gICAgICAgIGMgKz0gc2hhcGVzT2Zmc2V0O1xuXG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYyApICk7XG5cbiAgICAgICAgdmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCBhLCBiLCBjICk7XG5cbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2cyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQsIHdhbGxDb250b3VyLCBzdGVwSW5kZXgsIHN0ZXBzTGVuZ3RoLCBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xuXG4gICAgICAgIGEgKz0gc2hhcGVzT2Zmc2V0O1xuICAgICAgICBiICs9IHNoYXBlc09mZnNldDtcbiAgICAgICAgYyArPSBzaGFwZXNPZmZzZXQ7XG4gICAgICAgIGQgKz0gc2hhcGVzT2Zmc2V0O1xuXG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cbiAgICAgICAgdmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcblxuICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAxIF0sIHV2c1sgMiBdLCB1dnNbIDMgXSBdICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xuXG4gICAgZ2VuZXJhdGVUb3BVVjogZnVuY3Rpb24oIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICAgIHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuICAgICAgICB2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcbiAgICAgICAgdmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIGEueSApLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGIueCwgYi55ICksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYy54LCBjLnkgKVxuICAgICAgICBdO1xuXG4gICAgfSxcblxuICAgIGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24oIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgdmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XG4gICAgICAgIHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuICAgICAgICB2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcbiAgICAgICAgdmFyIGQgPSB2ZXJ0aWNlc1sgaW5kZXhEIF07XG5cbiAgICAgICAgaWYgKCBNYXRoLmFicyggYS55IC0gYi55ICkgPCAwLjAxICkge1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIDEgLSBhLnogKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi54LCAxIC0gYi56ICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgMSAtIGMueiApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBkLngsIDEgLSBkLnogKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLnksIDEgLSBhLnogKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi55LCAxIC0gYi56ICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueSwgMSAtIGMueiApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBkLnksIDEgLSBkLnogKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXG4gKlxuICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxuICpcbiAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXG4gKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKiovXG5cblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG4gICAgaWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA9PT0gZmFsc2UgKSBzaGFwZXMgPSBbIHNoYXBlcyBdO1xuXG4gICAgdGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhcGVHZW9tZXRyeTtcblxuLyoqXG4gKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXG4gKi9cblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHRoaXMuYWRkU2hhcGUoIHNoYXBlc1sgaSBdLCBvcHRpb25zICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBBZGRzIGEgc2hhcGUgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeSwgYmFzZWQgb24gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LlxuICovXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKCBzaGFwZSwgb3B0aW9ucyApIHtcblxuICAgIGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuICAgIHZhciBtYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWw7XG4gICAgdmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xuXG4gICAgLy9cblxuICAgIHZhciBpLCBsLCBob2xlO1xuXG4gICAgdmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgIHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuICAgIHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG4gICAgdmFyIHJldmVyc2UgPSAhVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XG5cbiAgICBpZiAoIHJldmVyc2UgKSB7XG5cbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cbiAgICAgICAgLy8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZS4uLlxuXG4gICAgICAgIGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBob2xlID0gaG9sZXNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggaG9sZSApICkge1xuXG4gICAgICAgICAgICAgICAgaG9sZXNbIGkgXSA9IGhvbGUucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldmVyc2UgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIHZhciBmYWNlcyA9IFRIUkVFLlNoYXBlLlV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG4gICAgLy8gVmVydGljZXNcblxuICAgIGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIGhvbGUgPSBob2xlc1sgaSBdO1xuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggaG9sZSApO1xuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIHZhciB2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCB2bGVuOyBpKysgKSB7XG5cbiAgICAgICAgdmVydCA9IHZlcnRpY2VzWyBpIF07XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xuXG4gICAgfVxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XG5cbiAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgICAgdmFyIGEgPSBmYWNlWyAwIF0gKyBzaGFwZXNPZmZzZXQ7XG4gICAgICAgIHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xuICAgICAgICB2YXIgYyA9IGZhY2VbIDIgXSArIHNoYXBlc09mZnNldDtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgbWF0ZXJpYWwgKSApO1xuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZVRvcFVWKCB0aGlzLCBhLCBiLCBjICkgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYXN0cm9kdWQgLyBodHRwOi8vYXN0cm9kdWQuaXNncmVhdC5vcmcvXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzXG4vLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXG4vLyBzZWdtZW50cyAtIHRoZSBudW1iZXIgb2YgY2lyY3VtZmVyZW5jZSBzZWdtZW50cyB0byBjcmVhdGVcbi8vIHBoaVN0YXJ0IC0gdGhlIHN0YXJ0aW5nIHJhZGlhblxuLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyKlBJKSByYW5nZSBvZiB0aGUgbGF0aGVkIHNlY3Rpb25cbi8vICAgIDIqcGkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxuXG5USFJFRS5MYXRoZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgIHBoaVN0YXJ0OiBwaGlTdGFydCxcbiAgICAgICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGhcbiAgICB9O1xuXG4gICAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCAxMjtcbiAgICBwaGlTdGFydCA9IHBoaVN0YXJ0IHx8IDA7XG4gICAgcGhpTGVuZ3RoID0gcGhpTGVuZ3RoIHx8IDIgKiBNYXRoLlBJO1xuXG4gICAgdmFyIGludmVyc2VQb2ludExlbmd0aCA9IDEuMCAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgaW52ZXJzZVNlZ21lbnRzID0gMS4wIC8gc2VnbWVudHM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkrKyApIHtcblxuICAgICAgICB2YXIgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHBoaSApLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKCBwaGkgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1sgaiBdO1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdmVydGV4LnggPSBjICogcHQueCAtIHMgKiBwdC55O1xuICAgICAgICAgICAgdmVydGV4LnkgPSBzICogcHQueCArIGMgKiBwdC55O1xuICAgICAgICAgICAgdmVydGV4LnogPSBwdC56O1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBucCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoIC0gMTsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBiYXNlID0gaiArIG5wICogaTtcbiAgICAgICAgICAgIHZhciBhID0gYmFzZTtcbiAgICAgICAgICAgIHZhciBiID0gYmFzZSArIG5wO1xuICAgICAgICAgICAgdmFyIGMgPSBiYXNlICsgMSArIG5wO1xuICAgICAgICAgICAgdmFyIGQgPSBiYXNlICsgMTtcblxuICAgICAgICAgICAgdmFyIHUwID0gaSAqIGludmVyc2VTZWdtZW50cztcbiAgICAgICAgICAgIHZhciB2MCA9IGogKiBpbnZlcnNlUG9pbnRMZW5ndGg7XG4gICAgICAgICAgICB2YXIgdTEgPSB1MCArIGludmVyc2VTZWdtZW50cztcbiAgICAgICAgICAgIHZhciB2MSA9IHYwICsgaW52ZXJzZVBvaW50TGVuZ3RoO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjAgKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXG5cbiAgICAgICAgICAgIF0gKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxuXG4gICAgICAgICAgICBdICk7XG5cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLm1lcmdlVmVydGljZXMoKTtcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGF0aGVHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAqL1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgICB9O1xuXG4gICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XG5cbn07XG5cblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lR2VvbWV0cnk7XG5cblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVCdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAqL1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BsYW5lQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgICB9O1xuXG4gICAgdmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuICAgIHZhciBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xuICAgIHZhciBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcblxuICAgIHZhciBncmlkWDEgPSBncmlkWCArIDE7XG4gICAgdmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcblxuICAgIHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcbiAgICB2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcbiAgICB2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcbiAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMiApO1xuXG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIG9mZnNldDIgPSAwO1xuXG4gICAgZm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5KysgKSB7XG5cbiAgICAgICAgdmFyIHkgPSBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XG5cbiAgICAgICAgZm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblxuICAgICAgICAgICAgdmVydGljZXNbIG9mZnNldCBdID0geDtcbiAgICAgICAgICAgIHZlcnRpY2VzWyBvZmZzZXQgKyAxIF0gPSAteTtcblxuICAgICAgICAgICAgbm9ybWFsc1sgb2Zmc2V0ICsgMiBdID0gMTtcblxuICAgICAgICAgICAgdXZzWyBvZmZzZXQyIF0gPSBpeCAvIGdyaWRYO1xuICAgICAgICAgICAgdXZzWyBvZmZzZXQyICsgMSBdID0gMSAtICggaXkgLyBncmlkWSApO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICAgIG9mZnNldDIgKz0gMjtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBvZmZzZXQgPSAwO1xuXG4gICAgdmFyIGluZGljZXMgPSBuZXcoICggdmVydGljZXMubGVuZ3RoIC8gMyApID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGdyaWRYICogZ3JpZFkgKiA2ICk7XG5cbiAgICBmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSsrICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcbiAgICAgICAgICAgIHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgICAgICAgdmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgICAgIHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgXSA9IGE7XG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgKyAxIF0gPSBiO1xuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMiBdID0gZDtcblxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMyBdID0gYjtcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDQgXSA9IGM7XG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgKyA1IF0gPSBkO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gNjtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbn07XG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnk7XG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzXG4gICAgKTtcblxuICAgIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUmluZ0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBLYWxlYiBNdXJwaHlcbiAqL1xuXG5USFJFRS5SaW5nR2VvbWV0cnkgPSBmdW5jdGlvbiggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgICAgIHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG4gICAgICAgIHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcblxuICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgMDtcbiAgICBvdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIHx8IDUwO1xuXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgICB0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XG4gICAgcGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiA4O1xuXG4gICAgdmFyIGksIG8sIHV2cyA9IFtdLFxuICAgICAgICByYWRpdXMgPSBpbm5lclJhZGl1cyxcbiAgICAgICAgcmFkaXVzU3RlcCA9ICggKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgLyBwaGlTZWdtZW50cyApO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50cyArIDE7IGkrKyApIHtcblxuICAgICAgICAvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcblxuICAgICAgICBmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgKyAxOyBvKysgKSB7XG5cbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgbyAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcbiAgICAgICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICAgICAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcbiAgICAgICAgICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMiwgKCB2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSApIC8gMiApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXG4gICAgfVxuXG4gICAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50czsgaSsrICkge1xuXG4gICAgICAgIC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xuXG4gICAgICAgIHZhciB0aGV0YVNlZ21lbnQgPSBpICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xuXG4gICAgICAgIGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50czsgbysrICkge1xuXG4gICAgICAgICAgICAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IG8gKyB0aGV0YVNlZ21lbnQ7XG5cbiAgICAgICAgICAgIHZhciB2MSA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB2YXIgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XG4gICAgICAgICAgICB2YXIgdjMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSApO1xuXG4gICAgICAgICAgICB2MSA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcbiAgICAgICAgICAgIHYzID0gc2VnbWVudCArIDE7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaW5nR2VvbWV0cnk7XG5cblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5pbm5lclJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLm91dGVyUmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBoaVNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICAgICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgICAgICBwaGlMZW5ndGg6IHBoaUxlbmd0aCxcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcblxuICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcblxufTtcblxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGhlcmVHZW9tZXRyeTtcblxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5waGlTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBoaUxlbmd0aCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NwaGVyZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKiBiYXNlZCBvbiBUSFJFRS5TcGhlcmVHZW9tZXRyeVxuICovXG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICAgICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgICAgICBwaGlMZW5ndGg6IHBoaUxlbmd0aCxcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcblxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblxuICAgIHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcbiAgICBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcblxuICAgIHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcbiAgICBwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcblxuICAgIHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcblxuICAgIHZhciB2ZXJ0ZXhDb3VudCA9ICggKCB3aWR0aFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKSApO1xuXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gICAgdmFyIG5vcm1hbHMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIHZhciB1dnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKSwgMiApO1xuXG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgdmVydGljZXMgPSBbXSxcbiAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGZvciAoIHZhciB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSsrICkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXG4gICAgICAgIHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXG4gICAgICAgIGZvciAoIHZhciB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB1ID0geCAvIHdpZHRoU2VnbWVudHM7XG5cbiAgICAgICAgICAgIHZhciBweCA9IC1yYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgICAgICAgICAgdmFyIHB5ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcbiAgICAgICAgICAgIHZhciBweiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cbiAgICAgICAgICAgIG5vcm1hbC5zZXQoIHB4LCBweSwgcHogKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgcG9zaXRpb25zLnNldFhZWiggaW5kZXgsIHB4LCBweSwgcHogKTtcbiAgICAgICAgICAgIG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuICAgICAgICAgICAgdXZzLnNldFhZKCBpbmRleCwgdSwgMSAtIHYgKTtcblxuICAgICAgICAgICAgdmVydGljZXNSb3cucHVzaCggaW5kZXggKTtcblxuICAgICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICB9XG5cbiAgICAgICAgdmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcblxuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICBmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSsrICkge1xuXG4gICAgICAgIGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoU2VnbWVudHM7IHgrKyApIHtcblxuICAgICAgICAgICAgdmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcbiAgICAgICAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcbiAgICAgICAgICAgIHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG4gICAgICAgICAgICB2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCB5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCB2MSwgdjIsIHY0ICk7XG4gICAgICAgICAgICBpZiAoIHkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkgKSBpbmRpY2VzLnB1c2goIHYyLCB2MywgdjQgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFscyApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcblxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeTtcblxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5waGlTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBoaUxlbmd0aCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICAgICk7XG5cbiAgICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RleHRHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRm9yIGNyZWF0aW5nIDNEIHRleHQgZ2VvbWV0cnkgaW4gdGhyZWUuanNcbiAqXG4gKiBUZXh0ID0gM0QgVGV4dFxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgc2l6ZTogXHRcdFx0PGZsb2F0PiwgXHQvLyBzaXplIG9mIHRoZSB0ZXh0XG4gKiAgaGVpZ2h0OiBcdFx0PGZsb2F0PiwgXHQvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XG4gKiAgY3VydmVTZWdtZW50czogXHQ8aW50PixcdFx0Ly8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG4gKlxuICogIGZvbnQ6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IG5hbWVcbiAqICB3ZWlnaHQ6IFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCB3ZWlnaHQgKG5vcm1hbCwgYm9sZClcbiAqICBzdHlsZTogXHRcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgc3R5bGUgIChub3JtYWwsIGl0YWxpY3MpXG4gKlxuICogIGJldmVsRW5hYmxlZDpcdDxib29sPixcdFx0XHQvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIFx0XHQvLyBob3cgZGVlcCBpbnRvIHRleHQgYmV2ZWwgZ29lc1xuICogIGJldmVsU2l6ZTpcdFx0PGZsb2F0PiwgXHRcdC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcbiAqICB9XG4gKlxuICovXG5cbi8qXHRVc2FnZSBFeGFtcGxlc1xuXG5cdC8vIFRleHRHZW9tZXRyeSB3cmFwcGVyXG5cblx0dmFyIHRleHQzZCA9IG5ldyBUZXh0R2VvbWV0cnkoIHRleHQsIG9wdGlvbnMgKTtcblxuXHQvLyBDb21wbGV0ZSBtYW5uZXJcblxuXHR2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgb3B0aW9ucyApO1xuXHR2YXIgdGV4dDNkID0gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGV4dFNoYXBlcywgb3B0aW9ucyApO1xuXG4qL1xuXG5cblRIUkVFLlRleHRHZW9tZXRyeSA9IGZ1bmN0aW9uKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICB2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgcGFyYW1ldGVycyApO1xuXG4gICAgLy8gdHJhbnNsYXRlIHBhcmFtZXRlcnMgdG8gRXh0cnVkZUdlb21ldHJ5IEFQSVxuXG4gICAgcGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcblxuICAgIC8vIGRlZmF1bHRzXG5cbiAgICBpZiAoIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPSAxMDtcbiAgICBpZiAoIHBhcmFtZXRlcnMuYmV2ZWxTaXplID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XG4gICAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5jYWxsKCB0aGlzLCB0ZXh0U2hhcGVzLCBwYXJhbWV0ZXJzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnVGV4dEdlb21ldHJ5JztcblxufTtcblxuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UZXh0R2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRExpdGUvc3JjL2F3YXkzZGxpdGUvcHJpbWl0aXZlcy9Ub3J1cy5hcz9yPTI4ODhcbiAqL1xuXG5USFJFRS5Ub3J1c0dlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgdHViZTogdHViZSxcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgICB0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICAgICAgYXJjOiBhcmNcbiAgICB9O1xuXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcbiAgICB0dWJlID0gdHViZSB8fCA0MDtcbiAgICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XG4gICAgdHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XG4gICAgYXJjID0gYXJjIHx8IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIHV2cyA9IFtdLFxuICAgICAgICBub3JtYWxzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcbiAgICAgICAgICAgIHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cbiAgICAgICAgICAgIGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcbiAgICAgICAgICAgIGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKTtcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICB2ZXJ0ZXgueCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XG4gICAgICAgICAgICB2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XG4gICAgICAgICAgICB2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICAgICAgICB1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyB0dWJ1bGFyU2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApICk7XG4gICAgICAgICAgICBub3JtYWxzLnB1c2goIHZlcnRleC5jbG9uZSgpLnN1YiggY2VudGVyICkubm9ybWFsaXplKCkgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XG4gICAgICAgICAgICB2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG4gICAgICAgICAgICB2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcbiAgICAgICAgICAgIHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQsIFsgbm9ybWFsc1sgYSBdLmNsb25lKCksIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIFsgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGMgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNHZW9tZXRyeTtcblxuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudHViZSxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudHVidWxhclNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuYXJjXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNLbm90R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNEL3NyYy9hd2F5M2QvcHJpbWl0aXZlcy9Ub3J1c0tub3QuYXM/c3BlYz1zdm4yNDczJnI9MjQ3M1xuICovXG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgcCwgcSwgaGVpZ2h0U2NhbGUgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgdHViZTogdHViZSxcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgICB0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICAgICAgcDogcCxcbiAgICAgICAgcTogcSxcbiAgICAgICAgaGVpZ2h0U2NhbGU6IGhlaWdodFNjYWxlXG4gICAgfTtcblxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG4gICAgdHViZSA9IHR1YmUgfHwgNDA7XG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA2NDtcbiAgICB0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgODtcbiAgICBwID0gcCB8fCAyO1xuICAgIHEgPSBxIHx8IDM7XG4gICAgaGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xuXG4gICAgdmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgdmFyIHRhbmcgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsraSApIHtcblxuICAgICAgICBncmlkWyBpIF0gPSBuZXcgQXJyYXkoIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgICB2YXIgdSA9IGkgLyByYWRpYWxTZWdtZW50cyAqIDIgKiBwICogTWF0aC5QSTtcbiAgICAgICAgdmFyIHAxID0gZ2V0UG9zKCB1LCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XG4gICAgICAgIHZhciBwMiA9IGdldFBvcyggdSArIDAuMDEsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcbiAgICAgICAgdGFuZy5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcbiAgICAgICAgbi5hZGRWZWN0b3JzKCBwMiwgcDEgKTtcblxuICAgICAgICBiaXRhbi5jcm9zc1ZlY3RvcnMoIHRhbmcsIG4gKTtcbiAgICAgICAgbi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XG4gICAgICAgIGJpdGFuLm5vcm1hbGl6ZSgpO1xuICAgICAgICBuLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKytqICkge1xuXG4gICAgICAgICAgICB2YXIgdiA9IGogLyB0dWJ1bGFyU2VnbWVudHMgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICAgIHZhciBjeCA9IC10dWJlICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cbiAgICAgICAgICAgIHZhciBjeSA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgICAgICAgICB2YXIgcG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIHBvcy54ID0gcDEueCArIGN4ICogbi54ICsgY3kgKiBiaXRhbi54O1xuICAgICAgICAgICAgcG9zLnkgPSBwMS55ICsgY3ggKiBuLnkgKyBjeSAqIGJpdGFuLnk7XG4gICAgICAgICAgICBwb3MueiA9IHAxLnogKyBjeCAqIG4ueiArIGN5ICogYml0YW4uejtcblxuICAgICAgICAgICAgZ3JpZFsgaSBdWyBqIF0gPSB0aGlzLnZlcnRpY2VzLnB1c2goIHBvcyApIC0gMTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKytpICkge1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKytqICkge1xuXG4gICAgICAgICAgICB2YXIgaXAgPSAoIGkgKyAxICkgJSByYWRpYWxTZWdtZW50cztcbiAgICAgICAgICAgIHZhciBqcCA9ICggaiArIDEgKSAlIHR1YnVsYXJTZWdtZW50cztcblxuICAgICAgICAgICAgdmFyIGEgPSBncmlkWyBpIF1bIGogXTtcbiAgICAgICAgICAgIHZhciBiID0gZ3JpZFsgaXAgXVsgaiBdO1xuICAgICAgICAgICAgdmFyIGMgPSBncmlkWyBpcCBdWyBqcCBdO1xuICAgICAgICAgICAgdmFyIGQgPSBncmlkWyBpIF1bIGpwIF07XG5cbiAgICAgICAgICAgIHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHJhZGlhbFNlZ21lbnRzLCBqIC8gdHVidWxhclNlZ21lbnRzICk7XG4gICAgICAgICAgICB2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCBqIC8gdHVidWxhclNlZ21lbnRzICk7XG4gICAgICAgICAgICB2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICAgICAgICAgIHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRQb3MoIHUsIGluX3EsIGluX3AsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKSB7XG5cbiAgICAgICAgdmFyIGN1ID0gTWF0aC5jb3MoIHUgKTtcbiAgICAgICAgdmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcbiAgICAgICAgdmFyIHF1T3ZlclAgPSBpbl9xIC8gaW5fcCAqIHU7XG4gICAgICAgIHZhciBjcyA9IE1hdGguY29zKCBxdU92ZXJQICk7XG5cbiAgICAgICAgdmFyIHR4ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuICAgICAgICB2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XG4gICAgICAgIHZhciB0eiA9IGhlaWdodFNjYWxlICogcmFkaXVzICogTWF0aC5zaW4oIHF1T3ZlclAgKSAqIDAuNTtcblxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeTtcblxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50dWJlLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5wLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucSxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNjYWxlXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVHViZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjFcbiAqXG4gKiBNb2RpZmllZCBmcm9tIHRoZSBUb3J1c0tub3RHZW9tZXRyeSBieSBAb29zbW94aWVjb2RlXG4gKlxuICogQ3JlYXRlcyBhIHR1YmUgd2hpY2ggZXh0cnVkZXMgYWxvbmcgYSAzZCBzcGxpbmVcbiAqXG4gKiBVc2VzIHBhcmFsbGVsIHRyYW5zcG9ydCBmcmFtZXMgYXMgZGVzY3JpYmVkIGluXG4gKiBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcbiAqL1xuXG5USFJFRS5UdWJlR2VvbWV0cnkgPSBmdW5jdGlvbiggcGF0aCwgc2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCwgdGFwZXIgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgICBjbG9zZWQ6IGNsb3NlZFxuICAgIH07XG5cbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgICBjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XG4gICAgdGFwZXIgPSB0YXBlciB8fCBUSFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlcjtcblxuICAgIHZhciBncmlkID0gW107XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzLFxuXG4gICAgICAgIHRhbmdlbnQsXG4gICAgICAgIG5vcm1hbCxcbiAgICAgICAgYmlub3JtYWwsXG5cbiAgICAgICAgbnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuXG4gICAgICAgIHUsIHYsIHIsXG5cbiAgICAgICAgY3gsIGN5LFxuICAgICAgICBwb3MsIHBvczIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBpLCBqLFxuICAgICAgICBpcCwganAsXG4gICAgICAgIGEsIGIsIGMsIGQsXG4gICAgICAgIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuICAgIHZhciBmcmFtZXMgPSBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApLFxuICAgICAgICB0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcbiAgICAgICAgbm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxuICAgICAgICBiaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xuXG4gICAgLy8gcHJveHkgaW50ZXJuYWxzXG4gICAgdGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuICAgIHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XG4gICAgdGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XG5cbiAgICBmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xuXG4gICAgICAgIHJldHVybiBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgLSAxO1xuXG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0IHRoZSBncmlkXG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSsrICkge1xuXG4gICAgICAgIGdyaWRbIGkgXSA9IFtdO1xuXG4gICAgICAgIHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICAgICAgcG9zID0gcGF0aC5nZXRQb2ludEF0KCB1ICk7XG5cbiAgICAgICAgdGFuZ2VudCA9IHRhbmdlbnRzWyBpIF07XG4gICAgICAgIG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcbiAgICAgICAgYmlub3JtYWwgPSBiaW5vcm1hbHNbIGkgXTtcblxuICAgICAgICByID0gcmFkaXVzICogdGFwZXIoIHUgKTtcblxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqKysgKSB7XG5cbiAgICAgICAgICAgIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiAyICogTWF0aC5QSTtcblxuICAgICAgICAgICAgY3ggPSAtciAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXG4gICAgICAgICAgICBjeSA9IHIgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgICAgICAgICBwb3MyLmNvcHkoIHBvcyApO1xuICAgICAgICAgICAgcG9zMi54ICs9IGN4ICogbm9ybWFsLnggKyBjeSAqIGJpbm9ybWFsLng7XG4gICAgICAgICAgICBwb3MyLnkgKz0gY3ggKiBub3JtYWwueSArIGN5ICogYmlub3JtYWwueTtcbiAgICAgICAgICAgIHBvczIueiArPSBjeCAqIG5vcm1hbC56ICsgY3kgKiBiaW5vcm1hbC56O1xuXG4gICAgICAgICAgICBncmlkWyBpIF1bIGogXSA9IHZlcnQoIHBvczIueCwgcG9zMi55LCBwb3MyLnogKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8vIGNvbnN0cnVjdCB0aGUgbWVzaFxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrICkge1xuXG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGorKyApIHtcblxuICAgICAgICAgICAgaXAgPSAoIGNsb3NlZCApID8gKCBpICsgMSApICUgc2VnbWVudHMgOiBpICsgMTtcbiAgICAgICAgICAgIGpwID0gKCBqICsgMSApICUgcmFkaWFsU2VnbWVudHM7XG5cbiAgICAgICAgICAgIGEgPSBncmlkWyBpIF1bIGogXTsgLy8gKioqIE5PVCBORUNFU1NBUklMWSBQTEFOQVIgISAqKipcbiAgICAgICAgICAgIGIgPSBncmlkWyBpcCBdWyBqIF07XG4gICAgICAgICAgICBjID0gZ3JpZFsgaXAgXVsganAgXTtcbiAgICAgICAgICAgIGQgPSBncmlkWyBpIF1bIGpwIF07XG5cbiAgICAgICAgICAgIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xuICAgICAgICAgICAgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcbiAgICAgICAgICAgIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgKCBqICsgMSApIC8gcmFkaWFsU2VnbWVudHMgKTtcbiAgICAgICAgICAgIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVHViZUdlb21ldHJ5O1xuXG5USFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlciA9IGZ1bmN0aW9uKCB1ICkge1xuXG4gICAgcmV0dXJuIDE7XG5cbn07XG5cblRIUkVFLlR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiggdSApIHtcblxuICAgIHJldHVybiBNYXRoLnNpbiggTWF0aC5QSSAqIHUgKTtcblxufTtcblxuLy8gRm9yIGNvbXB1dGluZyBvZiBGcmVuZXQgZnJhbWVzLCBleHBvc2luZyB0aGUgdGFuZ2VudHMsIG5vcm1hbHMgYW5kIGJpbm9ybWFscyB0aGUgc3BsaW5lXG5USFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzID0gZnVuY3Rpb24oIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSB7XG5cbiAgICB2YXIgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgICAgICB0YW5nZW50cyA9IFtdLFxuICAgICAgICBub3JtYWxzID0gW10sXG4gICAgICAgIGJpbm9ybWFscyA9IFtdLFxuXG4gICAgICAgIHZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cbiAgICAgICAgbnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuICAgICAgICB0aGV0YSxcbiAgICAgICAgZXBzaWxvbiA9IDAuMDAwMSxcbiAgICAgICAgc21hbGxlc3QsXG5cbiAgICAgICAgdHgsIHR5LCB0eixcbiAgICAgICAgaSwgdTtcblxuXG4gICAgLy8gZXhwb3NlIGludGVybmFsc1xuICAgIHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcbiAgICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuICAgIHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XG5cbiAgICAgICAgdSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcblxuICAgICAgICB0YW5nZW50c1sgaSBdID0gcGF0aC5nZXRUYW5nZW50QXQoIHUgKTtcbiAgICAgICAgdGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcblxuICAgIH1cblxuICAgIGluaXRpYWxOb3JtYWwzKCk7XG5cbiAgICAvKlxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMShsYXN0Qmlub3JtYWwpIHtcblx0XHQvLyBmaXhlZCBzdGFydCBiaW5vcm1hbC4gSGFzIGRhbmdlcnMgb2YgMCB2ZWN0b3JzXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0aWYgKGxhc3RCaW5vcm1hbD09PXVuZGVmaW5lZCkgbGFzdEJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBsYXN0Qmlub3JtYWwsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDIoKSB7XG5cblx0XHQvLyBUaGlzIHVzZXMgdGhlIEZyZW5ldC1TZXJyZXQgZm9ybXVsYSBmb3IgZGVyaXZpbmcgYmlub3JtYWxcblx0XHR2YXIgdDIgPSBwYXRoLmdldFRhbmdlbnRBdCggZXBzaWxvbiApO1xuXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zdWJWZWN0b3JzKCB0MiwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggYmlub3JtYWxzWyAwIF0sIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTsgLy8gbGFzdCBiaW5vcm1hbCB4IHRhbmdlbnRcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblx0Ki9cblxuICAgIGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xuXG4gICAgICAgIC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG4gICAgICAgIC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzbWFsbGVzdCB0YW5nZW50IHh5eiBjb21wb25lbnRcblxuICAgICAgICBub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHNtYWxsZXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG4gICAgICAgIHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xuICAgICAgICB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuICAgICAgICBpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xuXG4gICAgICAgICAgICBzbWFsbGVzdCA9IHR4O1xuICAgICAgICAgICAgbm9ybWFsLnNldCggMSwgMCwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHR5IDw9IHNtYWxsZXN0ICkge1xuXG4gICAgICAgICAgICBzbWFsbGVzdCA9IHR5O1xuICAgICAgICAgICAgbm9ybWFsLnNldCggMCwgMSwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHR6IDw9IHNtYWxsZXN0ICkge1xuXG4gICAgICAgICAgICBub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuICAgICAgICBiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG4gICAgZm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcblxuICAgICAgICBub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cbiAgICAgICAgYmlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuICAgICAgICB2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xuXG4gICAgICAgIGlmICggdmVjLmxlbmd0aCgpID4gZXBzaWxvbiApIHtcblxuICAgICAgICAgICAgdmVjLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0xLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG4gICAgICAgICAgICBub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgICB9XG5cblxuICAgIC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuICAgIGlmICggY2xvc2VkICkge1xuXG4gICAgICAgIHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSwgLTEsIDEgKSApO1xuICAgICAgICB0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcblxuICAgICAgICBpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApICkgPiAwICkge1xuXG4gICAgICAgICAgICB0aGV0YSA9IC10aGV0YTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcblxuICAgICAgICAgICAgLy8gdHdpc3QgYSBsaXR0bGUuLi5cbiAgICAgICAgICAgIG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xuICAgICAgICAgICAgYmlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BvbHloZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgY2xvY2t3b3JrZ2VlayAvIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG9ja3dvcmtnZWVrXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcbiAgICAgICAgaW5kaWNlczogaW5kaWNlcyxcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgfTtcblxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuICAgIGRldGFpbCA9IGRldGFpbCB8fCAwO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgICAgIHByZXBhcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xuXG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgdmFyIGZhY2VzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMsIGorKyApIHtcblxuICAgICAgICB2YXIgdjEgPSBwWyBpbmRpY2VzWyBpIF0gXTtcbiAgICAgICAgdmFyIHYyID0gcFsgaW5kaWNlc1sgaSArIDEgXSBdO1xuICAgICAgICB2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XG5cbiAgICAgICAgZmFjZXNbIGogXSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgaiApO1xuXG4gICAgfVxuXG4gICAgdmFyIGNlbnRyb2lkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICBzdWJkaXZpZGUoIGZhY2VzWyBpIF0sIGRldGFpbCApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cbiAgICAgICAgdmFyIHgwID0gdXZzWyAwIF0ueDtcbiAgICAgICAgdmFyIHgxID0gdXZzWyAxIF0ueDtcbiAgICAgICAgdmFyIHgyID0gdXZzWyAyIF0ueDtcblxuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoIHgwLCBNYXRoLm1heCggeDEsIHgyICkgKTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKCB4MCwgTWF0aC5taW4oIHgxLCB4MiApICk7XG5cbiAgICAgICAgaWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xuXG4gICAgICAgICAgICAvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cbiAgICAgICAgICAgIGlmICggeDAgPCAwLjIgKSB1dnNbIDAgXS54ICs9IDE7XG4gICAgICAgICAgICBpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xuICAgICAgICAgICAgaWYgKCB4MiA8IDAuMiApIHV2c1sgMiBdLnggKz0gMTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8vIEFwcGx5IHJhZGl1c1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlc1sgaSBdLm11bHRpcGx5U2NhbGFyKCByYWRpdXMgKTtcblxuICAgIH1cblxuXG4gICAgLy8gTWVyZ2UgdmVydGljZXNcblxuICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxuXG4gICAgLy8gUHJvamVjdCB2ZWN0b3Igb250byBzcGhlcmUncyBzdXJmYWNlXG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleCA9IHZlY3Rvci5ub3JtYWxpemUoKS5jbG9uZSgpO1xuICAgICAgICB2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcblxuICAgICAgICAvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXG5cbiAgICAgICAgdmFyIHUgPSBhemltdXRoKCB2ZWN0b3IgKSAvIDIgLyBNYXRoLlBJICsgMC41O1xuICAgICAgICB2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XG4gICAgICAgIHZlcnRleC51diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApO1xuXG4gICAgICAgIHJldHVybiB2ZXJ0ZXg7XG5cbiAgICB9XG5cblxuICAgIC8vIEFwcHJveGltYXRlIGEgY3VydmVkIGZhY2Ugd2l0aCByZWN1cnNpdmVseSBzdWItZGl2aWRlZCB0cmlhbmdsZXMuXG5cbiAgICBmdW5jdGlvbiBtYWtlKCB2MSwgdjIsIHYzLCBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBtYXRlcmlhbEluZGV4ICk7XG4gICAgICAgIHRoYXQuZmFjZXMucHVzaCggZmFjZSApO1xuXG4gICAgICAgIGNlbnRyb2lkLmNvcHkoIHYxICkuYWRkKCB2MiApLmFkZCggdjMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcblxuICAgICAgICB2YXIgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcblxuICAgICAgICB0aGF0LmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG4gICAgICAgICAgICBjb3JyZWN0VVYoIHYxLnV2LCB2MSwgYXppICksXG4gICAgICAgICAgICBjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXG4gICAgICAgICAgICBjb3JyZWN0VVYoIHYzLnV2LCB2MywgYXppIClcbiAgICAgICAgXSApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBBbmFseXRpY2FsbHkgc3ViZGl2aWRlIGEgZmFjZSB0byB0aGUgcmVxdWlyZWQgZGV0YWlsIGxldmVsLlxuXG4gICAgZnVuY3Rpb24gc3ViZGl2aWRlKCBmYWNlLCBkZXRhaWwgKSB7XG5cbiAgICAgICAgdmFyIGNvbHMgPSBNYXRoLnBvdyggMiwgZGV0YWlsICk7XG4gICAgICAgIHZhciBhID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcbiAgICAgICAgdmFyIGIgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmIgXSApO1xuICAgICAgICB2YXIgYyA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYyBdICk7XG4gICAgICAgIHZhciB2ID0gW107XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDw9IGNvbHM7IGkrKyApIHtcblxuICAgICAgICAgICAgdlsgaSBdID0gW107XG5cbiAgICAgICAgICAgIHZhciBhaiA9IHByZXBhcmUoIGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XG4gICAgICAgICAgICB2YXIgYmogPSBwcmVwYXJlKCBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSBjb2xzIC0gaTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJvd3M7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgaiBdID0gYWo7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXMuXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgY29sczsgaSsrICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBqICUgMiA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBtYWtlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBrICsgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSArIDEgXVsgayBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFrZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgayArIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgKyAxIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpICsgMSBdWyBrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuICAgIGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC12ZWN0b3IueCApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXG5cbiAgICBmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKCAtdmVjdG9yLnksIE1hdGguc3FydCggKCB2ZWN0b3IueCAqIHZlY3Rvci54ICkgKyAoIHZlY3Rvci56ICogdmVjdG9yLnogKSApICk7XG5cbiAgICB9XG5cblxuICAgIC8vIFRleHR1cmUgZml4aW5nIGhlbHBlci4gU3BoZXJlcyBoYXZlIHNvbWUgb2RkIGJlaGF2aW91cnMuXG5cbiAgICBmdW5jdGlvbiBjb3JyZWN0VVYoIHV2LCB2ZWN0b3IsIGF6aW11dGggKSB7XG5cbiAgICAgICAgaWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1di54IC0gMSwgdXYueSApO1xuICAgICAgICBpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcbiAgICAgICAgcmV0dXJuIHV2LmNsb25lKCk7XG5cbiAgICB9XG5cblxufTtcblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeTtcblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnZlcnRpY2VzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaW5kaWNlcyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0RvZGVjYWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBBYmUgUGF6b3MgLyBodHRwczovL2hhbW9pZC5jb21cbiAqL1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG4gICAgdmFyIHIgPSAxIC8gdDtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcblxuICAgICAgICAvLyAowrExLCDCsTEsIMKxMSlcbiAgICAgICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAxLCAtMSwgMSwgLTEsIC0xLCAxLCAxLFxuICAgICAgICAxLCAtMSwgLTEsIDEsIC0xLCAxLFxuICAgICAgICAxLCAxLCAtMSwgMSwgMSwgMSxcblxuICAgICAgICAvLyAoMCwgwrExL8+GLCDCsc+GKVxuICAgICAgICAwLCAtciwgLXQsIDAsIC1yLCB0LFxuICAgICAgICAwLCByLCAtdCwgMCwgciwgdCxcblxuICAgICAgICAvLyAowrExL8+GLCDCsc+GLCAwKVxuICAgICAgICAtciwgLXQsIDAsIC1yLCB0LCAwLFxuICAgICAgICByLCAtdCwgMCwgciwgdCwgMCxcblxuICAgICAgICAvLyAowrHPhiwgMCwgwrExL8+GKVxuICAgICAgICAtdCwgMCwgLXIsIHQsIDAsIC1yLCAtdCwgMCwgciwgdCwgMCwgclxuICAgIF07XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgICAgMywgMTEsIDcsIDMsIDcsIDE1LCAzLCAxNSwgMTMsXG4gICAgICAgIDcsIDE5LCAxNywgNywgMTcsIDYsIDcsIDYsIDE1LFxuICAgICAgICAxNywgNCwgOCwgMTcsIDgsIDEwLCAxNywgMTAsIDYsXG4gICAgICAgIDgsIDAsIDE2LCA4LCAxNiwgMiwgOCwgMiwgMTAsXG4gICAgICAgIDAsIDEyLCAxLCAwLCAxLCAxOCwgMCwgMTgsIDE2LFxuICAgICAgICA2LCAxMCwgMiwgNiwgMiwgMTMsIDYsIDEzLCAxNSxcbiAgICAgICAgMiwgMTYsIDE4LCAyLCAxOCwgMywgMiwgMywgMTMsXG4gICAgICAgIDE4LCAxLCA5LCAxOCwgOSwgMTEsIDE4LCAxMSwgMyxcbiAgICAgICAgNCwgMTQsIDEyLCA0LCAxMiwgMCwgNCwgMCwgOCxcbiAgICAgICAgMTEsIDksIDUsIDExLCA1LCAxOSwgMTEsIDE5LCA3LFxuICAgICAgICAxOSwgNSwgMTQsIDE5LCAxNCwgNCwgMTksIDQsIDE3LFxuICAgICAgICAxLCAxMiwgMTQsIDEsIDE0LCA1LCAxLCA1LCA5XG4gICAgXTtcblxuICAgIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICAgIHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07XG5cbn07XG5cblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5O1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICAgICk7XG5cbiAgICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0ljb3NhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbIC0xLCB0LCAwLCAxLCB0LCAwLCAtMSwgLXQsIDAsIDEsIC10LCAwLFxuICAgICAgICAwLCAtMSwgdCwgMCwgMSwgdCwgMCwgLTEsIC10LCAwLCAxLCAtdCxcbiAgICAgICAgdCwgMCwgLTEsIHQsIDAsIDEsIC10LCAwLCAtMSwgLXQsIDAsIDFcbiAgICBdO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIDAsIDExLCA1LCAwLCA1LCAxLCAwLCAxLCA3LCAwLCA3LCAxMCwgMCwgMTAsIDExLFxuICAgICAgICAxLCA1LCA5LCA1LCAxMSwgNCwgMTEsIDEwLCAyLCAxMCwgNywgNiwgNywgMSwgOCxcbiAgICAgICAgMywgOSwgNCwgMywgNCwgMiwgMywgMiwgNiwgMywgNiwgOCwgMywgOCwgOSxcbiAgICAgICAgNCwgOSwgNSwgMiwgNCwgMTEsIDYsIDIsIDEwLCA4LCA2LCA3LCA5LCA4LCAxXG4gICAgXTtcblxuICAgIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICAgIHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgfTtcblxufTtcblxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnk7XG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICAgICk7XG5cbiAgICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL09jdGFoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIDEsIDAsIDAsIC0xLCAwLCAwLCAwLCAxLCAwLCAwLCAtMSwgMCwgMCwgMCwgMSwgMCwgMCwgLTFcbiAgICBdO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIDAsIDIsIDQsIDAsIDQsIDMsIDAsIDMsIDUsIDAsIDUsIDIsIDEsIDIsIDUsIDEsIDUsIDMsIDEsIDMsIDQsIDEsIDQsIDJcbiAgICBdO1xuXG4gICAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gICAgdGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07XG5cbn07XG5cblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5O1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGV0YWlsXG4gICAgKTtcblxuICAgIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVGV0cmFoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAgICAxLCAxLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAtMSwgMSwgLTEsIC0xXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAyLCAxLCAwLCAwLCAzLCAyLCAxLCAzLCAwLCAyLCAzLCAxXG4gICAgXTtcblxuICAgIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICAgIHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgfTtcblxufTtcblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk7XG5cblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICAgICk7XG5cbiAgICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XG4gKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxuICpcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzICk7XG4gKlxuICovXG5cblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICBzbGljZXM6IHNsaWNlcyxcbiAgICAgICAgc3RhY2tzOiBzdGFja3NcbiAgICB9O1xuXG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICAgIHZhciB1dnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblxuICAgIHZhciBpLCBqLCBwO1xuICAgIHZhciB1LCB2O1xuXG4gICAgdmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpKysgKSB7XG5cbiAgICAgICAgdiA9IGkgLyBzdGFja3M7XG5cbiAgICAgICAgZm9yICggaiA9IDA7IGogPD0gc2xpY2VzOyBqKysgKSB7XG5cbiAgICAgICAgICAgIHUgPSBqIC8gc2xpY2VzO1xuXG4gICAgICAgICAgICBwID0gZnVuYyggdSwgdiApO1xuICAgICAgICAgICAgdmVydHMucHVzaCggcCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBhLCBiLCBjLCBkO1xuICAgIHZhciB1dmEsIHV2YiwgdXZjLCB1dmQ7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSsrICkge1xuXG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqKysgKSB7XG5cbiAgICAgICAgICAgIGEgPSBpICogc2xpY2VDb3VudCArIGo7XG4gICAgICAgICAgICBiID0gaSAqIHNsaWNlQ291bnQgKyBqICsgMTtcbiAgICAgICAgICAgIGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XG4gICAgICAgICAgICBkID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGo7XG5cbiAgICAgICAgICAgIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG4gICAgICAgICAgICB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG4gICAgICAgICAgICB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcbiAgICAgICAgICAgIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblxuICAgICAgICAgICAgZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICAgICAgICAgIHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICAgICAgICBmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuICAgICAgICAgICAgdXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpO1xuXG4gICAgLy8gbWFnaWMgYnVsbGV0XG4gICAgLy8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcbiAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlZCAnLCBkaWZmLCAnIHZlcnRpY2VzIGJ5IG1lcmdpbmcnKTtcblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9XaXJlZnJhbWVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkgPSBmdW5jdGlvbiggZ2VvbWV0cnkgKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB2YXIgZWRnZSA9IFsgMCwgMCBdLFxuICAgICAgICBoYXNoID0ge307XG4gICAgdmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHJldHVybiBhIC0gYjtcblxuICAgIH07XG5cbiAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcbiAgICAgICAgdmFyIG51bUVkZ2VzID0gMDtcblxuICAgICAgICAvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcbiAgICAgICAgdmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCA2ICogZmFjZXMubGVuZ3RoICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuICAgICAgICAgICAgICAgIGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xuICAgICAgICAgICAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgXSA9IGVkZ2VbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFsga2V5IF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBudW1FZGdlcysrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZWRnZXNbIDIgKiBpICsgaiBdIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XG4gICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIC8vIEluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleC5hcnJheTtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICAgICAgICB2YXIgZHJhd2NhbGxzID0gZ2VvbWV0cnkuZHJhd2NhbGxzO1xuICAgICAgICAgICAgdmFyIG51bUVkZ2VzID0gMDtcblxuICAgICAgICAgICAgaWYgKCBkcmF3Y2FsbHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuYWRkRHJhd0NhbGwoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgbyA9IDAsIG9sID0gZHJhd2NhbGxzLmxlbmd0aDsgbyA8IG9sOyArK28gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJhd2NhbGwgPSBkcmF3Y2FsbHNbIG8gXTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGRyYXdjYWxsLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGRyYXdjYWxsLmNvdW50O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VbIDAgXSA9IGluZGljZXNbIGkgKyBqIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlWyAxIF0gPSBpbmRpY2VzWyBpICsgKCBqICsgMSApICUgMyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFsga2V5IF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUVkZ2VzKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IGVkZ2VzWyAyICogaSArIGogXTtcblxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGljZXMuZ2V0WCggaW5kZXgyICk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlcy5nZXRZKCBpbmRleDIgKTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzLmdldFooIGluZGV4MiApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgICAgICB2YXIgbnVtRWRnZXMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgICAgICAgICAgdmFyIG51bVRyaXMgPSBudW1FZGdlcyAvIDM7XG5cbiAgICAgICAgICAgIHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bVRyaXM7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMTggKiBpICsgNiAqIGo7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4MSA9IDkgKiBpICsgMyAqIGo7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MSArIDIgXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgyID0gOSAqIGkgKyAzICogKCAoIGogKyAxICkgJSAzICk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAzIF0gPSB2ZXJ0aWNlc1sgaW5kZXgyIF07XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA0IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgNSBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiggc2l6ZSApIHtcblxuICAgIHNpemUgPSBzaXplIHx8IDE7XG5cbiAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgICAgIDAsIDAsIDAsIHNpemUsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDAsIHNpemUsIDAsXG4gICAgICAgIDAsIDAsIDAsIDAsIDAsIHNpemVcbiAgICBdICk7XG5cbiAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuICAgICAgICAxLCAwLCAwLCAxLCAwLjYsIDAsXG4gICAgICAgIDAsIDEsIDAsIDAuNiwgMSwgMCxcbiAgICAgICAgMCwgMCwgMSwgMCwgMC42LCAxXG4gICAgXSApO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzXG4gICAgfSApO1xuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXhpc0hlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXJyb3dIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICpcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcbiAqXG4gKiBQYXJhbWV0ZXJzOlxuICogIGRpciAtIFZlY3RvcjNcbiAqICBvcmlnaW4gLSBWZWN0b3IzXG4gKiAgbGVuZ3RoIC0gTnVtYmVyXG4gKiAgY29sb3IgLSBjb2xvciBpbiBoZXggdmFsdWVcbiAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXG4gKiAgaGVhZFdpZHRoIC0gTnVtYmVyXG4gKi9cblxuVEhSRUUuQXJyb3dIZWxwZXIgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XG5cbiAgICB2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xuICAgIGNvbmVHZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0wLjUsIDAgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBBcnJvd0hlbHBlciggZGlyLCBvcmlnaW4sIGxlbmd0aCwgY29sb3IsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuICAgICAgICAvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICAgICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XG4gICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xuICAgICAgICBpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG4gICAgICAgIGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XG5cbiAgICAgICAgaWYgKCBoZWFkTGVuZ3RoIDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgdGhpcy5saW5lID0gbmV3IFRIUkVFLkxpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICAgIHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFkZCggdGhpcy5saW5lICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9ICkgKTtcbiAgICAgICAgdGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcbiAgICAgICAgdGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cbiAgICB9XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFycm93SGVscGVyO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgcmFkaWFucztcblxuICAgIHJldHVybiBmdW5jdGlvbiBzZXREaXJlY3Rpb24oIGRpciApIHtcblxuICAgICAgICAvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICAgICAgaWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBkaXIueSA8IC0wLjk5OTk5ICkge1xuXG4gICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0KCAxLCAwLCAwLCAwICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgYXhpcy5zZXQoIGRpci56LCAwLCAtZGlyLnggKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgcmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcblxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkgKTtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuICAgIGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcbiAgICBpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcblxuICAgIGlmICggaGVhZExlbmd0aCA8IGxlbmd0aCApIHtcbiAgICAgICAgdGhpcy5saW5lLnNjYWxlLnNldCggMSwgbGVuZ3RoIC0gaGVhZExlbmd0aCwgMSApO1xuICAgICAgICB0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcbiAgICB0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcbiAgICB0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cbn07XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgIGlmICggdGhpcy5saW5lICE9PSB1bmRlZmluZWQgKSB0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuICAgIHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JveEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQm94SGVscGVyID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xuICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICogMyApO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiAweGZmZmYwMFxuICAgIH0gKSApO1xuXG4gICAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZSggb2JqZWN0ICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94SGVscGVyO1xuXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIGJveC5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgICAgICBpZiAoIGJveC5lbXB0eSgpICkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBtaW4gPSBib3gubWluO1xuICAgICAgICB2YXIgbWF4ID0gYm94Lm1heDtcblxuICAgICAgICAvKlxuXHRcdCAgNV9fX180XG5cdFx0MS9fX18wL3xcblx0XHR8IDZfX3xfN1xuXHRcdDIvX19fMy9cblxuXHRcdDA6IG1heC54LCBtYXgueSwgbWF4Lnpcblx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG5cdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4Lnpcblx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG5cdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcblx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG5cdFx0Ki9cblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICAgIHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgIGFycmF5WyAwIF0gPSBtYXgueDtcbiAgICAgICAgYXJyYXlbIDEgXSA9IG1heC55O1xuICAgICAgICBhcnJheVsgMiBdID0gbWF4Lno7XG4gICAgICAgIGFycmF5WyAzIF0gPSBtaW4ueDtcbiAgICAgICAgYXJyYXlbIDQgXSA9IG1heC55O1xuICAgICAgICBhcnJheVsgNSBdID0gbWF4Lno7XG4gICAgICAgIGFycmF5WyA2IF0gPSBtaW4ueDtcbiAgICAgICAgYXJyYXlbIDcgXSA9IG1pbi55O1xuICAgICAgICBhcnJheVsgOCBdID0gbWF4Lno7XG4gICAgICAgIGFycmF5WyA5IF0gPSBtYXgueDtcbiAgICAgICAgYXJyYXlbIDEwIF0gPSBtaW4ueTtcbiAgICAgICAgYXJyYXlbIDExIF0gPSBtYXguejtcbiAgICAgICAgYXJyYXlbIDEyIF0gPSBtYXgueDtcbiAgICAgICAgYXJyYXlbIDEzIF0gPSBtYXgueTtcbiAgICAgICAgYXJyYXlbIDE0IF0gPSBtaW4uejtcbiAgICAgICAgYXJyYXlbIDE1IF0gPSBtaW4ueDtcbiAgICAgICAgYXJyYXlbIDE2IF0gPSBtYXgueTtcbiAgICAgICAgYXJyYXlbIDE3IF0gPSBtaW4uejtcbiAgICAgICAgYXJyYXlbIDE4IF0gPSBtaW4ueDtcbiAgICAgICAgYXJyYXlbIDE5IF0gPSBtaW4ueTtcbiAgICAgICAgYXJyYXlbIDIwIF0gPSBtaW4uejtcbiAgICAgICAgYXJyYXlbIDIxIF0gPSBtYXgueDtcbiAgICAgICAgYXJyYXlbIDIyIF0gPSBtaW4ueTtcbiAgICAgICAgYXJyYXlbIDIzIF0gPSBtaW4uejtcblxuICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIH1cblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JvdW5kaW5nQm94SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuLy8gYSBoZWxwZXIgdG8gc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYW4gb2JqZWN0XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyID0gZnVuY3Rpb24oIG9iamVjdCwgaGV4ICkge1xuXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHg4ODg4ODg7XG5cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIHRoaXMuYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgbmV3IFRIUkVFLkJveEdlb21ldHJ5KCAxLCAxLCAxICksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZVxuICAgIH0gKSApO1xuXG59O1xuXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm91bmRpbmdCb3hIZWxwZXI7XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuYm94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XG5cbiAgICB0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XG5cbiAgICB0aGlzLmJveC5jZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKlx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXG4gKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcbiAqXHRcdGh0dHA6Ly9ldmFudy5naXRodWIuY29tL2xpZ2h0Z2wuanMvdGVzdHMvc2hhZG93bWFwLmh0bWxcbiAqL1xuXG5USFJFRS5DYW1lcmFIZWxwZXIgPSBmdW5jdGlvbiggY2FtZXJhICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICAgICAgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzXG4gICAgfSApO1xuXG4gICAgdmFyIHBvaW50TWFwID0ge307XG5cbiAgICAvLyBjb2xvcnNcblxuICAgIHZhciBoZXhGcnVzdHVtID0gMHhmZmFhMDA7XG4gICAgdmFyIGhleENvbmUgPSAweGZmMDAwMDtcbiAgICB2YXIgaGV4VXAgPSAweDAwYWFmZjtcbiAgICB2YXIgaGV4VGFyZ2V0ID0gMHhmZmZmZmY7XG4gICAgdmFyIGhleENyb3NzID0gMHgzMzMzMzM7XG5cbiAgICAvLyBuZWFyXG5cbiAgICBhZGRMaW5lKCBcIm4xXCIsIFwibjJcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcIm4zXCIsIFwibjFcIiwgaGV4RnJ1c3R1bSApO1xuXG4gICAgLy8gZmFyXG5cbiAgICBhZGRMaW5lKCBcImYxXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwiZjJcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJmNFwiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcImYzXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xuXG4gICAgLy8gc2lkZXNcblxuICAgIGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJuMlwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcIm4zXCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XG5cbiAgICAvLyBjb25lXG5cbiAgICBhZGRMaW5lKCBcInBcIiwgXCJuMVwiLCBoZXhDb25lICk7XG4gICAgYWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xuICAgIGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcbiAgICBhZGRMaW5lKCBcInBcIiwgXCJuNFwiLCBoZXhDb25lICk7XG5cbiAgICAvLyB1cFxuXG4gICAgYWRkTGluZSggXCJ1MVwiLCBcInUyXCIsIGhleFVwICk7XG4gICAgYWRkTGluZSggXCJ1MlwiLCBcInUzXCIsIGhleFVwICk7XG4gICAgYWRkTGluZSggXCJ1M1wiLCBcInUxXCIsIGhleFVwICk7XG5cbiAgICAvLyB0YXJnZXRcblxuICAgIGFkZExpbmUoIFwiY1wiLCBcInRcIiwgaGV4VGFyZ2V0ICk7XG4gICAgYWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xuXG4gICAgLy8gY3Jvc3NcblxuICAgIGFkZExpbmUoIFwiY24xXCIsIFwiY24yXCIsIGhleENyb3NzICk7XG4gICAgYWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcblxuICAgIGFkZExpbmUoIFwiY2YxXCIsIFwiY2YyXCIsIGhleENyb3NzICk7XG4gICAgYWRkTGluZSggXCJjZjNcIiwgXCJjZjRcIiwgaGV4Q3Jvc3MgKTtcblxuICAgIGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIsIGhleCApIHtcblxuICAgICAgICBhZGRQb2ludCggYSwgaGV4ICk7XG4gICAgICAgIGFkZFBvaW50KCBiLCBoZXggKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xuXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblxuICAgICAgICBpZiAoIHBvaW50TWFwWyBpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHBvaW50TWFwWyBpZCBdID0gW107XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBvaW50TWFwWyBpZCBdLnB1c2goIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcblxuICAgIH1cblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmFIZWxwZXI7XG5cblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnksIHBvaW50TWFwO1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuICAgIHZhciBzZXRQb2ludCA9IGZ1bmN0aW9uKCBwb2ludCwgeCwgeSwgeiApIHtcblxuICAgICAgICB2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XG5cbiAgICAgICAgaWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNbIHBvaW50c1sgaSBdIF0uY29weSggdmVjdG9yICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgcG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xuXG4gICAgICAgIHZhciB3ID0gMSxcbiAgICAgICAgICAgIGggPSAxO1xuXG4gICAgICAgIC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgLy8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcblxuICAgICAgICBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICAgICAgLy8gY2VudGVyIC8gdGFyZ2V0XG5cbiAgICAgICAgc2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJ0XCIsIDAsIDAsIDEgKTtcblxuICAgICAgICAvLyBuZWFyXG5cbiAgICAgICAgc2V0UG9pbnQoIFwibjFcIiwgLXcsIC1oLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJuMlwiLCB3LCAtaCwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwibjNcIiwgLXcsIGgsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcIm40XCIsIHcsIGgsIC0xICk7XG5cbiAgICAgICAgLy8gZmFyXG5cbiAgICAgICAgc2V0UG9pbnQoIFwiZjFcIiwgLXcsIC1oLCAxICk7XG4gICAgICAgIHNldFBvaW50KCBcImYyXCIsIHcsIC1oLCAxICk7XG4gICAgICAgIHNldFBvaW50KCBcImYzXCIsIC13LCBoLCAxICk7XG4gICAgICAgIHNldFBvaW50KCBcImY0XCIsIHcsIGgsIDEgKTtcblxuICAgICAgICAvLyB1cFxuXG4gICAgICAgIHNldFBvaW50KCBcInUxXCIsIHcgKiAwLjcsIGggKiAxLjEsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcInUyXCIsIC13ICogMC43LCBoICogMS4xLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJ1M1wiLCAwLCBoICogMiwgLTEgKTtcblxuICAgICAgICAvLyBjcm9zc1xuXG4gICAgICAgIHNldFBvaW50KCBcImNmMVwiLCAtdywgMCwgMSApO1xuICAgICAgICBzZXRQb2ludCggXCJjZjJcIiwgdywgMCwgMSApO1xuICAgICAgICBzZXRQb2ludCggXCJjZjNcIiwgMCwgLWgsIDEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiY2Y0XCIsIDAsIGgsIDEgKTtcblxuICAgICAgICBzZXRQb2ludCggXCJjbjFcIiwgLXcsIDAsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcImNuMlwiLCB3LCAwLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJjbjNcIiwgMCwgLWgsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcImNuNFwiLCAwLCBoLCAtMSApO1xuXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICB9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0RpcmVjdGlvbmFsTGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiggbGlnaHQsIHNpemUgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIHNpemUgPSBzaXplIHx8IDE7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLXNpemUsIHNpemUsIDAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIHNpemUsIDAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIC1zaXplLCAwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtc2l6ZSwgLXNpemUsIDAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC1zaXplLCBzaXplLCAwIClcbiAgICApO1xuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGZvZzogZmFsc2VcbiAgICB9ICk7XG4gICAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgdGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcblxuICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgICk7XG5cbiAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBmb2c6IGZhbHNlXG4gICAgfSApO1xuICAgIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICB0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xuXG4gICAgICAgIHRoaXMubGlnaHRQbGFuZS5sb29rQXQoIHYzICk7XG4gICAgICAgIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdjMgKTtcbiAgICAgICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IgKTtcblxuICAgIH07XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRWRnZXNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBwYXJhbSBvYmplY3QgVEhSRUUuTWVzaCB3aG9zZSBnZW9tZXRyeSB3aWxsIGJlIHVzZWRcbiAqIEBwYXJhbSBoZXggbGluZSBjb2xvclxuICogQHBhcmFtIHRocmVzaG9sZEFuZ2xlIHRoZSBtaW5pbXVtIGFuZ2xlIChpbiBkZWdyZWVzKSxcbiAqIGJldHdlZW4gdGhlIGZhY2Ugbm9ybWFscyBvZiBhZGphY2VudCBmYWNlcyxcbiAqIHRoYXQgaXMgcmVxdWlyZWQgdG8gcmVuZGVyIGFuIGVkZ2UuIEEgdmFsdWUgb2YgMTAgbWVhbnNcbiAqIGFuIGVkZ2UgaXMgb25seSByZW5kZXJlZCBpZiB0aGUgYW5nbGUgaXMgYXQgbGVhc3QgMTAgZGVncmVlcy5cbiAqL1xuXG5USFJFRS5FZGdlc0hlbHBlciA9IGZ1bmN0aW9uKCBvYmplY3QsIGhleCwgdGhyZXNob2xkQW5nbGUgKSB7XG5cbiAgICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuRWRnZXNHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSApICk7XG5cbiAgICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNIZWxwZXI7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0ZhY2VOb3JtYWxzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24oIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cbiAgICAvLyBGYWNlTm9ybWFsc0hlbHBlciBvbmx5IHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5XG5cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xuXG4gICAgdmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuICAgIC8vXG5cbiAgICB2YXIgbk5vcm1hbHMgPSAwO1xuXG4gICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgbk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI6IG9ubHkgVEhSRUUuR2VvbWV0cnkgaXMgc3VwcG9ydGVkLiBVc2UgVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciwgaW5zdGVhZC4nICk7XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcblxuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGxpbmV3aWR0aDogd2lkdGhcbiAgICB9ICkgKTtcblxuICAgIC8vXG5cbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjtcblxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgICAgbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgICAgICB2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgLy9cblxuICAgICAgICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgICB2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcblxuICAgICAgICB2YXIgaWR4ID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG4gICAgICAgICAgICB2MS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKVxuICAgICAgICAgICAgICAgIC5hZGQoIHZlcnRpY2VzWyBmYWNlLmIgXSApXG4gICAgICAgICAgICAgICAgLmFkZCggdmVydGljZXNbIGZhY2UuYyBdIClcbiAgICAgICAgICAgICAgICAuZGl2aWRlU2NhbGFyKCAzIClcbiAgICAgICAgICAgICAgICAuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICB2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufSgpICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0dyaWRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkdyaWRIZWxwZXIgPSBmdW5jdGlvbiggc2l6ZSwgc3RlcCApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9yc1xuICAgIH0gKTtcblxuICAgIHRoaXMuY29sb3IxID0gbmV3IFRIUkVFLkNvbG9yKCAweDQ0NDQ0NCApO1xuICAgIHRoaXMuY29sb3IyID0gbmV3IFRIUkVFLkNvbG9yKCAweDg4ODg4OCApO1xuXG4gICAgZm9yICggdmFyIGkgPSAtc2l6ZTsgaSA8PSBzaXplOyBpICs9IHN0ZXAgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtc2l6ZSwgMCwgaSApLCBuZXcgVEhSRUUuVmVjdG9yMyggc2l6ZSwgMCwgaSApLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIC1zaXplICksIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCBzaXplIClcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgY29sb3IgPSBpID09PSAwID8gdGhpcy5jb2xvcjEgOiB0aGlzLmNvbG9yMjtcblxuICAgICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcblxuICAgIH1cblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkdyaWRIZWxwZXI7XG5cblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uKCBjb2xvckNlbnRlckxpbmUsIGNvbG9yR3JpZCApIHtcblxuICAgIHRoaXMuY29sb3IxLnNldCggY29sb3JDZW50ZXJMaW5lICk7XG4gICAgdGhpcy5jb2xvcjIuc2V0KCBjb2xvckdyaWQgKTtcblxuICAgIHRoaXMuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0hlbWlzcGhlcmVMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlciA9IGZ1bmN0aW9uKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcbiAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5jb2xvcnMgPSBbIG5ldyBUSFJFRS5Db2xvcigpLCBuZXcgVEhSRUUuQ29sb3IoKSBdO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG4gICAgZ2VvbWV0cnkucm90YXRlWCggLU1hdGguUEkgLyAyICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gODsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkuZmFjZXNbIGkgXS5jb2xvciA9IHRoaXMuY29sb3JzWyBpIDwgNCA/IDAgOiAxIF07XG5cbiAgICB9XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzLFxuICAgICAgICB3aXJlZnJhbWU6IHRydWVcbiAgICB9ICk7XG5cbiAgICB0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jb2xvcnNbIDAgXS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG4gICAgICAgIHRoaXMuY29sb3JzWyAxIF0uY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgICAgIHRoaXMubGlnaHRTcGhlcmUubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcbiAgICAgICAgdGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Qb2ludExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlciA9IGZ1bmN0aW9uKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcbiAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICBmb2c6IGZhbHNlXG4gICAgfSApO1xuICAgIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICAvKlxuXHR2YXIgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XG5cdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XG5cdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XG5cblx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuXHR9XG5cblx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuXHQqL1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50TGlnaHRIZWxwZXI7XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgLypcblx0dmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xuXG5cdGlmICggZCA9PT0gMC4wICkge1xuXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuXHR9XG5cdCovXG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcbiAqIEBhdXRob3IgTWljaGFlbCBHdWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tlbGV0b25IZWxwZXIgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgdGhpcy5ib25lcyA9IHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgIHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG4gICAgICAgIGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAwLCAxICkgKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDEsIDAgKSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdlb21ldHJ5LmR5bmFtaWMgPSB0cnVlO1xuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLFxuICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICB9ICk7XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB0aGlzLnJvb3QgPSBvYmplY3Q7XG5cbiAgICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tlbGV0b25IZWxwZXI7XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5nZXRCb25lTGlzdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICB2YXIgYm9uZUxpc3QgPSBbXTtcblxuICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuICAgICAgICBib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICBib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGJvbmVMaXN0O1xuXG59O1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gICAgdmFyIG1hdHJpeFdvcmxkSW52ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcblxuICAgIHZhciBib25lTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHZhciBqID0gMDtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cbiAgICAgICAgaWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cbiAgICAgICAgICAgIGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBqIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cbiAgICAgICAgICAgIGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgaiArIDEgXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcblxuICAgICAgICAgICAgaiArPSAyO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU3BvdExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiggbGlnaHQgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAxLCAxLCA4LCAxLCB0cnVlICk7XG5cbiAgICBnZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0wLjUsIDAgKTtcbiAgICBnZW9tZXRyeS5yb3RhdGVYKCAtTWF0aC5QSSAvIDIgKTtcblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICB3aXJlZnJhbWU6IHRydWUsXG4gICAgICAgIGZvZzogZmFsc2VcbiAgICB9ICk7XG5cbiAgICB0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgdGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodEhlbHBlcjtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdmVjdG9yMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xuICAgICAgICB2YXIgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XG5cbiAgICAgICAgdGhpcy5jb25lLnNjYWxlLnNldCggY29uZVdpZHRoLCBjb25lV2lkdGgsIGNvbmVMZW5ndGggKTtcblxuICAgICAgICB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHZlY3RvcjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xuXG4gICAgICAgIHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICB9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1ZlcnRleE5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICB0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cbiAgICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcblxuICAgIHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cbiAgICAvL1xuXG4gICAgdmFyIG5Ob3JtYWxzID0gMDtcblxuICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgIG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcblxuICAgIH1cbiAgICBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICBuTm9ybWFscyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmNvdW50XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcblxuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGxpbmV3aWR0aDogd2lkdGhcbiAgICB9ICkgKTtcblxuICAgIC8vXG5cbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyO1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgICAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgICAgbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgICAgICB2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgLy9cblxuICAgICAgICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICAgICAgICB2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcblxuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGZhY2VbIGtleXNbIGogXSBdIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgICAgICB2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmpQb3MgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICB2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcblxuICAgICAgICAgICAgLy8gZm9yIHNpbXBsaWNpdHksIGlnbm9yZSBpbmRleCBhbmQgZHJhd2NhbGxzLCBhbmQgcmVuZGVyIGV2ZXJ5IG5vcm1hbFxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgIHYyLnNldCggb2JqTm9ybS5nZXRYKCBqICksIG9iak5vcm0uZ2V0WSggaiApLCBvYmpOb3JtLmdldFooIGogKSApO1xuXG4gICAgICAgICAgICAgICAgdjIuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn0oKSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9XaXJlZnJhbWVIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldpcmVmcmFtZUhlbHBlciA9IGZ1bmN0aW9uKCBvYmplY3QsIGhleCApIHtcblxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogY29sb3JcbiAgICB9ICkgKTtcblxuICAgIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldpcmVmcmFtZUhlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvSW1tZWRpYXRlUmVuZGVyT2JqZWN0LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oIHJlbmRlckNhbGxiYWNrICkge307XG5cbn07XG5cblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3Q7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL01vcnBoQmxlbmRNZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgdGhpcy5hbmltYXRpb25zTWFwID0ge307XG4gICAgdGhpcy5hbmltYXRpb25zTGlzdCA9IFtdO1xuXG4gICAgLy8gcHJlcGFyZSBkZWZhdWx0IGFuaW1hdGlvblxuICAgIC8vIChhbGwgZnJhbWVzIHBsYXllZCB0b2dldGhlciBpbiAxIHNlY29uZClcblxuICAgIHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB2YXIgbmFtZSA9IFwiX19kZWZhdWx0XCI7XG5cbiAgICB2YXIgc3RhcnRGcmFtZSA9IDA7XG4gICAgdmFyIGVuZEZyYW1lID0gbnVtRnJhbWVzIC0gMTtcblxuICAgIHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xuXG4gICAgdGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgKTtcbiAgICB0aGlzLnNldEFuaW1hdGlvbldlaWdodCggbmFtZSwgMSApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhCbGVuZE1lc2g7XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jcmVhdGVBbmltYXRpb24gPSBmdW5jdGlvbiggbmFtZSwgc3RhcnQsIGVuZCwgZnBzICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHtcblxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuXG4gICAgICAgIGxlbmd0aDogZW5kIC0gc3RhcnQgKyAxLFxuXG4gICAgICAgIGZwczogZnBzLFxuICAgICAgICBkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxuXG4gICAgICAgIGxhc3RGcmFtZTogMCxcbiAgICAgICAgY3VycmVudEZyYW1lOiAwLFxuXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG5cbiAgICAgICAgdGltZTogMCxcbiAgICAgICAgZGlyZWN0aW9uOiAxLFxuICAgICAgICB3ZWlnaHQ6IDEsXG5cbiAgICAgICAgZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcbiAgICAgICAgbWlycm9yZWRMb29wOiBmYWxzZVxuXG4gICAgfTtcblxuICAgIHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdID0gYW5pbWF0aW9uO1xuICAgIHRoaXMuYW5pbWF0aW9uc0xpc3QucHVzaCggYW5pbWF0aW9uICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5hdXRvQ3JlYXRlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCBmcHMgKSB7XG5cbiAgICB2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuICAgIHZhciBmaXJzdEFuaW1hdGlvbiwgZnJhbWVSYW5nZXMgPSB7fTtcblxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG4gICAgICAgIHZhciBjaHVua3MgPSBtb3JwaC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XG5cbiAgICAgICAgaWYgKCBjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgICAgIHZhciBuYW1lID0gY2h1bmtzWyAxIF07XG5cbiAgICAgICAgICAgIGlmICggIWZyYW1lUmFuZ2VzWyBuYW1lIF0gKSBmcmFtZVJhbmdlc1sgbmFtZSBdID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBlbmQ6IC1JbmZpbml0eVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcblxuICAgICAgICAgICAgaWYgKCBpIDwgcmFuZ2Uuc3RhcnQgKSByYW5nZS5zdGFydCA9IGk7XG4gICAgICAgICAgICBpZiAoIGkgPiByYW5nZS5lbmQgKSByYW5nZS5lbmQgPSBpO1xuXG4gICAgICAgICAgICBpZiAoICFmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbmFtZTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBmcmFtZVJhbmdlcyApIHtcblxuICAgICAgICB2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xuICAgICAgICB0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgZnBzICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uID0gMTtcbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25GUFMgPSBmdW5jdGlvbiggbmFtZSwgZnBzICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLmZwcyA9IGZwcztcbiAgICAgICAgYW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiggbmFtZSwgZHVyYXRpb24gKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgYW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24oIG5hbWUsIHdlaWdodCApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi53ZWlnaHQgPSB3ZWlnaHQ7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24oIG5hbWUsIHRpbWUgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24udGltZSA9IHRpbWU7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICB2YXIgdGltZSA9IDA7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICB0aW1lID0gYW5pbWF0aW9uLnRpbWU7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGltZTtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICB2YXIgZHVyYXRpb24gPSAtMTtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSAwO1xuICAgICAgICBhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuTW9ycGhCbGVuZE1lc2g6IGFuaW1hdGlvbltcIiArIG5hbWUgKyBcIl0gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKClcIiApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oIGRlbHRhICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTGlzdFsgaSBdO1xuXG4gICAgICAgIGlmICggIWFuaW1hdGlvbi5hY3RpdmUgKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcblxuICAgICAgICBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZGlyZWN0aW9uICogZGVsdGE7XG5cbiAgICAgICAgaWYgKCBhbmltYXRpb24ubWlycm9yZWRMb29wICkge1xuXG4gICAgICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gKj0gLTE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24udGltZSAlIGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA8IDAgKSBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydCArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XG4gICAgICAgIHZhciB3ZWlnaHQgPSBhbmltYXRpb24ud2VpZ2h0O1xuXG4gICAgICAgIGlmICgga2V5ZnJhbWUgIT09IGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgKSB7XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAwO1xuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IDEgKiB3ZWlnaHQ7XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcblxuICAgICAgICAgICAgYW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XG4gICAgICAgICAgICBhbmltYXRpb24uY3VycmVudEZyYW1lID0ga2V5ZnJhbWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaXggPSAoIGFuaW1hdGlvbi50aW1lICUgZnJhbWVUaW1lICkgLyBmcmFtZVRpbWU7XG5cbiAgICAgICAgaWYgKCBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzICkgbWl4ID0gMSAtIG1peDtcblxuICAgICAgICBpZiAoIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgIT09IGFuaW1hdGlvbi5sYXN0RnJhbWUgKSB7XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gKCAxIC0gbWl4ICkgKiB3ZWlnaHQ7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IHdlaWdodDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07IiwiLyogc2hhZGVyLXBhcnRpY2xlLWVuZ2luZSAxLjAuMFxuICogXG4gKiAoYykgMjAxNSBMdWtlIE1vb2R5IChodHRwOi8vd3d3LmdpdGh1Yi5jb20vc3F1YXJlZmVldClcbiAqICAgICBPcmlnaW5hbGx5IGJhc2VkIG9uIExlZSBTdGVta29za2kncyBvcmlnaW5hbCB3b3JrIChodHRwczovL2dpdGh1Yi5jb20vc3RlbWtvc2tpL3N0ZW1rb3NraS5naXRodWIuY29tL2Jsb2IvbWFzdGVyL1RocmVlLmpzL2pzL1BhcnRpY2xlRW5naW5lLmpzKS5cbiAqXG4gKiBzaGFkZXItcGFydGljbGUtZW5naW5lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIChTZWUgTElDRU5TRSBhdCByb290IG9mIHRoaXMgcmVwb3NpdG9yeS4pXG4gKi9cbnZhciBTUEUgPSB7XG4gICAgZGlzdHJpYnV0aW9uczoge1xuICAgICAgICBCT1g6IDEsXG4gICAgICAgIFNQSEVSRTogMixcbiAgICAgICAgRElTQzogM1xuICAgIH0sXG4gICAgdmFsdWVPdmVyTGlmZXRpbWVMZW5ndGg6IDRcbn07XG5cImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFwic3BlXCIsIFNQRSkgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBleHBvcnRzICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG1vZHVsZSAmJiAobW9kdWxlLmV4cG9ydHMgPSBTUEUpLCBTUEUuVHlwZWRBcnJheUhlbHBlciA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLmNvbXBvbmVudFNpemUgPSBjIHx8IDEsIHRoaXMuc2l6ZSA9IGIgfHwgMSwgdGhpcy5UeXBlZEFycmF5Q29uc3RydWN0b3IgPSBhIHx8IEZsb2F0MzJBcnJheSwgdGhpcy5hcnJheSA9IG5ldyBhKGIgKiB0aGlzLmNvbXBvbmVudFNpemUpLCB0aGlzLmluZGV4T2Zmc2V0ID0gZCB8fCAwXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5jb25zdHJ1Y3RvciA9IFNQRS5UeXBlZEFycmF5SGVscGVyLCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYyA9IHRoaXMuYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBiIHx8IChhICo9IHRoaXMuY29tcG9uZW50U2l6ZSksIGMgPiBhID8gdGhpcy5zaHJpbmsoYSkgOiBhID4gYyA/IHRoaXMuZ3JvdyhhKSA6IHZvaWQgY29uc29sZS5pbmZvKFwiVHlwZWRBcnJheSBpcyBhbHJlYWR5IG9mIHNpemU6XCIsIGEgKyBcIi5cIiwgXCJXaWxsIG5vdCByZXNpemUuXCIpXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2hyaW5rID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5zdWJhcnJheSgwLCBhKSwgdGhpcy5zaXplID0gYSwgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLmdyb3cgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIgPSB0aGlzLmFycmF5LFxuICAgICAgICBjID0gbmV3IHRoaXMuVHlwZWRBcnJheUNvbnN0cnVjdG9yKGEpO1xuICAgIHJldHVybiBjLnNldChiKSwgdGhpcy5hcnJheSA9IGMsIHRoaXMuc2l6ZSA9IGEsIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgYSAqPSB0aGlzLmNvbXBvbmVudFNpemUsIGIgKj0gdGhpcy5jb21wb25lbnRTaXplO1xuICAgIGZvciAodmFyIGMgPSBbXSwgZCA9IHRoaXMuYXJyYXksIGUgPSBkLmxlbmd0aCwgZiA9IDA7IGUgPiBmOyArK2YpXG4gICAgICAgIChhID4gZiB8fCBmID49IGIpICYmIGMucHVzaChkW2ZdKTtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tQXJyYXkoMCwgYyksIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRGcm9tQXJyYXkgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGMgPSBiLmxlbmd0aCxcbiAgICAgICAgZCA9IGEgKyBjO1xuICAgIHJldHVybiBkID4gdGhpcy5hcnJheS5sZW5ndGggPyB0aGlzLmdyb3coZCkgOiBkIDwgdGhpcy5hcnJheS5sZW5ndGggJiYgdGhpcy5zaHJpbmsoZCksIHRoaXMuYXJyYXkuc2V0KGIsIHRoaXMuaW5kZXhPZmZzZXQgKyBhKSwgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVjMkNvbXBvbmVudHMoYSwgYi54LCBiLnkpXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjMkNvbXBvbmVudHMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGQgPSB0aGlzLmFycmF5LFxuICAgICAgICBlID0gdGhpcy5pbmRleE9mZnNldCArIGEgKiB0aGlzLmNvbXBvbmVudFNpemU7XG4gICAgcmV0dXJuIGRbZV0gPSBiLCBkW2UgKyAxXSA9IGMsIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWMzID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLnNldFZlYzNDb21wb25lbnRzKGEsIGIueCwgYi55LCBiLnopXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjM0NvbXBvbmVudHMgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGUgPSB0aGlzLmFycmF5LFxuICAgICAgICBmID0gdGhpcy5pbmRleE9mZnNldCArIGEgKiB0aGlzLmNvbXBvbmVudFNpemU7XG4gICAgcmV0dXJuIGVbZl0gPSBiLCBlW2YgKyAxXSA9IGMsIGVbZiArIDJdID0gZCwgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVjNENvbXBvbmVudHMoYSwgYi54LCBiLnksIGIueiwgYi53KVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzRDb21wb25lbnRzID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmID0gdGhpcy5hcnJheSxcbiAgICAgICAgZyA9IHRoaXMuaW5kZXhPZmZzZXQgKyBhICogdGhpcy5jb21wb25lbnRTaXplO1xuICAgIHJldHVybiBmW2ddID0gYiwgZltnICsgMV0gPSBjLCBmW2cgKyAyXSA9IGQsIGZbZyArIDNdID0gZSwgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldE1hdDMgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbUFycmF5KHRoaXMuaW5kZXhPZmZzZXQgKyBhICogdGhpcy5jb21wb25lbnRTaXplLCBiLmVsZW1lbnRzKVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldE1hdDQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbUFycmF5KHRoaXMuaW5kZXhPZmZzZXQgKyBhICogdGhpcy5jb21wb25lbnRTaXplLCBiLmVsZW1lbnRzKVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLnNldFZlYzNDb21wb25lbnRzKGEsIGIuciwgYi5nLCBiLmIpXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0TnVtYmVyID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLmFycmF5W3RoaXMuaW5kZXhPZmZzZXQgKyBhICogdGhpcy5jb21wb25lbnRTaXplXSA9IGIsIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5nZXRWYWx1ZUF0SW5kZXggPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbdGhpcy5pbmRleE9mZnNldCArIGFdXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50VmFsdWVBdEluZGV4ID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLmFycmF5LnN1YmFycmF5KHRoaXMuaW5kZXhPZmZzZXQgKyBhICogdGhpcy5jb21wb25lbnRTaXplKTtcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGQgPSBTUEUuU2hhZGVyQXR0cmlidXRlLnR5cGVTaXplTWFwO1xuICAgIHRoaXMudHlwZSA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGEgJiYgZC5oYXNPd25Qcm9wZXJ0eShhKSA/IGEgOiBcImZcIiwgdGhpcy5jb21wb25lbnRTaXplID0gZFt0aGlzLnR5cGVdLCB0aGlzLmFycmF5VHlwZSA9IGMgfHwgRmxvYXQzMkFycmF5LCB0aGlzLnR5cGVkQXJyYXkgPSBudWxsLCB0aGlzLmJ1ZmZlckF0dHJpYnV0ZSA9IG51bGwsIHRoaXMuZHluYW1pY0J1ZmZlciA9ICEhYiwgdGhpcy51cGRhdGVNaW4gPSAwLCB0aGlzLnVwZGF0ZU1heCA9IDBcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUuY29uc3RydWN0b3IgPSBTUEUuU2hhZGVyQXR0cmlidXRlLCBTUEUuU2hhZGVyQXR0cmlidXRlLnR5cGVTaXplTWFwID0ge1xuICAgIGY6IDEsXG4gICAgdjI6IDIsXG4gICAgdjM6IDMsXG4gICAgdjQ6IDQsXG4gICAgYzogMyxcbiAgICBtMzogOSxcbiAgICBtNDogMTZcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLnNldFVwZGF0ZVJhbmdlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMudXBkYXRlTWluID0gTWF0aC5taW4oYSAqIHRoaXMuY29tcG9uZW50U2l6ZSwgdGhpcy51cGRhdGVNaW4gKiB0aGlzLmNvbXBvbmVudFNpemUpLCB0aGlzLnVwZGF0ZU1heCA9IE1hdGgubWF4KGIgKiB0aGlzLmNvbXBvbmVudFNpemUsIHRoaXMudXBkYXRlTWF4ICogdGhpcy5jb21wb25lbnRTaXplKVxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuZmxhZ1VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhID0gdGhpcy5idWZmZXJBdHRyaWJ1dGUsXG4gICAgICAgIGIgPSBhLnVwZGF0ZVJhbmdlO1xuICAgIGIub2Zmc2V0ID0gdGhpcy51cGRhdGVNaW4sIGIuY291bnQgPSBNYXRoLm1pbih0aGlzLnVwZGF0ZU1heCAtIHRoaXMudXBkYXRlTWluICsgdGhpcy5jb21wb25lbnRTaXplLCB0aGlzLnR5cGVkQXJyYXkuYXJyYXkubGVuZ3RoKSwgYS5uZWVkc1VwZGF0ZSA9ICEwXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5yZXNldFVwZGF0ZVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy51cGRhdGVNaW4gPSAwLCB0aGlzLnVwZGF0ZU1heCA9IDA7XG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5yZXNldER5bmFtaWMgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5keW5hbWljID0gdGhpcy5keW5hbWljQnVmZmVyXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy50eXBlZEFycmF5LnNwbGljZShhLCBiKSwgdGhpcy5mb3JjZVVwZGF0ZUFsbCgpXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5mb3JjZVVwZGF0ZUFsbCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMuYnVmZmVyQXR0cmlidXRlLmFycmF5ID0gdGhpcy50eXBlZEFycmF5LmFycmF5LCB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZS5vZmZzZXQgPSAwLCB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZS5jb3VudCA9IC0xLCB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5keW5hbWljID0gITEsIHRoaXMuYnVmZmVyQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gITBcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLl9lbnN1cmVUeXBlZEFycmF5ID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIChudWxsID09PSB0aGlzLnR5cGVkQXJyYXkgfHwgdGhpcy50eXBlZEFycmF5LnNpemUgIT09IGEgKiB0aGlzLmNvbXBvbmVudFNpemUpICYmIChudWxsICE9PSB0aGlzLnR5cGVkQXJyYXkgJiYgdGhpcy50eXBlZEFycmF5LnNpemUgIT09IGEgPyB0aGlzLnR5cGVkQXJyYXkuc2V0U2l6ZShhKSA6IG51bGwgPT09IHRoaXMudHlwZWRBcnJheSAmJiAodGhpcy50eXBlZEFycmF5ID0gbmV3IFNQRS5UeXBlZEFycmF5SGVscGVyKHRoaXMuYXJyYXlUeXBlLCBhLCB0aGlzLmNvbXBvbmVudFNpemUpKSlcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLl9jcmVhdGVCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVR5cGVkQXJyYXkoYSksIG51bGwgIT09IHRoaXMuYnVmZmVyQXR0cmlidXRlID8gKHRoaXMuYnVmZmVyQXR0cmlidXRlLmFycmF5ID0gdGhpcy50eXBlZEFycmF5LmFycmF5LFxuICAgIHZvaWQgKHRoaXMuYnVmZmVyQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gITApKSA6ICh0aGlzLmJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy50eXBlZEFycmF5LmFycmF5LCB0aGlzLmNvbXBvbmVudFNpemUpLCB2b2lkICh0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5keW5hbWljID0gdGhpcy5keW5hbWljQnVmZmVyKSlcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiBudWxsID09PSB0aGlzLnR5cGVkQXJyYXkgPyAwIDogdGhpcy50eXBlZEFycmF5LmFycmF5Lmxlbmd0aFxufSwgU1BFLnNoYWRlckNodW5rcyA9IHtcbiAgICBkZWZpbmVzOiBbXCIjZGVmaW5lIFBBQ0tFRF9DT0xPUl9TSVpFIDI1Ni4wXCIsIFwiI2RlZmluZSBQQUNLRURfQ09MT1JfRElWSVNPUiAyNTUuMFwiXS5qb2luKFwiXFxuXCIpLFxuICAgIHVuaWZvcm1zOiBbXCJ1bmlmb3JtIGZsb2F0IGRlbHRhVGltZTtcIiwgXCJ1bmlmb3JtIGZsb2F0IHJ1blRpbWU7XCIsIFwidW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcIiwgXCJ1bmlmb3JtIHZlYzQgdGV4dHVyZUFuaW1hdGlvbjtcIiwgXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiXS5qb2luKFwiXFxuXCIpLFxuICAgIGF0dHJpYnV0ZXM6IFtcImF0dHJpYnV0ZSB2ZWM0IGFjY2VsZXJhdGlvbjtcIiwgXCJhdHRyaWJ1dGUgdmVjMyB2ZWxvY2l0eTtcIiwgXCJhdHRyaWJ1dGUgdmVjNCByb3RhdGlvbjtcIiwgXCJhdHRyaWJ1dGUgdmVjMyByb3RhdGlvbkNlbnRlcjtcIiwgXCJhdHRyaWJ1dGUgdmVjNCBwYXJhbXM7XCIsIFwiYXR0cmlidXRlIHZlYzQgc2l6ZTtcIiwgXCJhdHRyaWJ1dGUgdmVjNCBhbmdsZTtcIiwgXCJhdHRyaWJ1dGUgdmVjNCBjb2xvcjtcIiwgXCJhdHRyaWJ1dGUgdmVjNCBvcGFjaXR5O1wiXS5qb2luKFwiXFxuXCIpLFxuICAgIHZhcnlpbmdzOiBbXCJ2YXJ5aW5nIHZlYzQgdkNvbG9yO1wiLCBcIiNpZmRlZiBTSE9VTERfUk9UQVRFX1RFWFRVUkVcIiwgXCIgICAgdmFyeWluZyBmbG9hdCB2QW5nbGU7XCIsIFwiI2VuZGlmXCIsIFwiI2lmZGVmIFNIT1VMRF9DQUxDVUxBVEVfU1BSSVRFXCIsIFwiICAgIHZhcnlpbmcgdmVjNCB2U3ByaXRlU2hlZXQ7XCIsIFwiI2VuZGlmXCJdLmpvaW4oXCJcXG5cIiksXG4gICAgYnJhbmNoQXZvaWRhbmNlRnVuY3Rpb25zOiBbXCJmbG9hdCB3aGVuX2d0KGZsb2F0IHgsIGZsb2F0IHkpIHtcIiwgXCIgICAgcmV0dXJuIG1heChzaWduKHggLSB5KSwgMC4wKTtcIiwgXCJ9XCIsIFwiZmxvYXQgd2hlbl9sdChmbG9hdCB4LCBmbG9hdCB5KSB7XCIsIFwiICAgIHJldHVybiBtaW4oIG1heCgxLjAgLSBzaWduKHggLSB5KSwgMC4wKSwgMS4wICk7XCIsIFwifVwiLCBcImZsb2F0IHdoZW5fZXEoIGZsb2F0IHgsIGZsb2F0IHkgKSB7XCIsIFwiICAgIHJldHVybiAxLjAgLSBhYnMoIHNpZ24oIHggLSB5ICkgKTtcIiwgXCJ9XCIsIFwiZmxvYXQgd2hlbl9nZShmbG9hdCB4LCBmbG9hdCB5KSB7XCIsIFwiICByZXR1cm4gMS4wIC0gd2hlbl9sdCh4LCB5KTtcIiwgXCJ9XCIsIFwiZmxvYXQgd2hlbl9sZShmbG9hdCB4LCBmbG9hdCB5KSB7XCIsIFwiICByZXR1cm4gMS4wIC0gd2hlbl9ndCh4LCB5KTtcIiwgXCJ9XCIsIFwiZmxvYXQgYW5kKGZsb2F0IGEsIGZsb2F0IGIpIHtcIiwgXCIgICAgcmV0dXJuIGEgKiBiO1wiLCBcIn1cIiwgXCJmbG9hdCBvcihmbG9hdCBhLCBmbG9hdCBiKSB7XCIsIFwiICAgIHJldHVybiBtaW4oYSArIGIsIDEuMCk7XCIsIFwifVwiXS5qb2luKFwiXFxuXCIpLFxuICAgIHVucGFja0NvbG9yOiBbXCJ2ZWMzIHVucGFja0NvbG9yKCBpbiBmbG9hdCBoZXggKSB7XCIsIFwiICAgdmVjMyBjID0gdmVjMyggMC4wICk7XCIsIFwiICAgZmxvYXQgciA9IG1vZCggKGhleCAvIFBBQ0tFRF9DT0xPUl9TSVpFIC8gUEFDS0VEX0NPTE9SX1NJWkUpLCBQQUNLRURfQ09MT1JfU0laRSApO1wiLCBcIiAgIGZsb2F0IGcgPSBtb2QoIChoZXggLyBQQUNLRURfQ09MT1JfU0laRSksIFBBQ0tFRF9DT0xPUl9TSVpFICk7XCIsIFwiICAgZmxvYXQgYiA9IG1vZCggaGV4LCBQQUNLRURfQ09MT1JfU0laRSApO1wiLCBcIiAgIGMuciA9IHIgLyBQQUNLRURfQ09MT1JfRElWSVNPUjtcIiwgXCIgICBjLmcgPSBnIC8gUEFDS0VEX0NPTE9SX0RJVklTT1I7XCIsIFwiICAgYy5iID0gYiAvIFBBQ0tFRF9DT0xPUl9ESVZJU09SO1wiLCBcIiAgIHJldHVybiBjO1wiLCBcIn1cIl0uam9pbihcIlxcblwiKSxcbiAgICBmbG9hdE92ZXJMaWZldGltZTogW1wiZmxvYXQgZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIGluIGZsb2F0IHBvc2l0aW9uSW5UaW1lLCBpbiB2ZWM0IGF0dHIgKSB7XCIsIFwiICAgIGhpZ2hwIGZsb2F0IHZhbHVlID0gMC4wO1wiLCBcIiAgICBmbG9hdCBkZWx0YUFnZSA9IHBvc2l0aW9uSW5UaW1lICogZmxvYXQoIFZBTFVFX09WRVJfTElGRVRJTUVfTEVOR1RIIC0gMSApO1wiLCBcIiAgICBmbG9hdCBmSW5kZXggPSAwLjA7XCIsIFwiICAgIGZsb2F0IHNob3VsZEFwcGx5VmFsdWUgPSAwLjA7XCIsIFwiICAgIHZhbHVlICs9IGF0dHJbIDAgXSAqIHdoZW5fZXEoIGRlbHRhQWdlLCAwLjAgKTtcIiwgXCJcIiwgXCIgICAgZm9yKCBpbnQgaSA9IDA7IGkgPCBWQUxVRV9PVkVSX0xJRkVUSU1FX0xFTkdUSCAtIDE7ICsraSApIHtcIiwgXCIgICAgICAgZkluZGV4ID0gZmxvYXQoIGkgKTtcIiwgXCIgICAgICAgc2hvdWxkQXBwbHlWYWx1ZSA9IGFuZCggd2hlbl9ndCggZGVsdGFBZ2UsIGZJbmRleCApLCB3aGVuX2xlKCBkZWx0YUFnZSwgZkluZGV4ICsgMS4wICkgKTtcIiwgXCIgICAgICAgdmFsdWUgKz0gc2hvdWxkQXBwbHlWYWx1ZSAqIG1peCggYXR0clsgaSBdLCBhdHRyWyBpICsgMSBdLCBkZWx0YUFnZSAtIGZJbmRleCApO1wiLCBcIiAgICB9XCIsIFwiXCIsIFwiICAgIHJldHVybiB2YWx1ZTtcIiwgXCJ9XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgY29sb3JPdmVyTGlmZXRpbWU6IFtcInZlYzMgZ2V0Q29sb3JPdmVyTGlmZXRpbWUoIGluIGZsb2F0IHBvc2l0aW9uSW5UaW1lLCBpbiB2ZWMzIGNvbG9yMSwgaW4gdmVjMyBjb2xvcjIsIGluIHZlYzMgY29sb3IzLCBpbiB2ZWMzIGNvbG9yNCApIHtcIiwgXCIgICAgdmVjMyB2YWx1ZSA9IHZlYzMoIDAuMCApO1wiLCBcIiAgICB2YWx1ZS54ID0gZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIHBvc2l0aW9uSW5UaW1lLCB2ZWM0KCBjb2xvcjEueCwgY29sb3IyLngsIGNvbG9yMy54LCBjb2xvcjQueCApICk7XCIsIFwiICAgIHZhbHVlLnkgPSBnZXRGbG9hdE92ZXJMaWZldGltZSggcG9zaXRpb25JblRpbWUsIHZlYzQoIGNvbG9yMS55LCBjb2xvcjIueSwgY29sb3IzLnksIGNvbG9yNC55ICkgKTtcIiwgXCIgICAgdmFsdWUueiA9IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgdmVjNCggY29sb3IxLnosIGNvbG9yMi56LCBjb2xvcjMueiwgY29sb3I0LnogKSApO1wiLCBcIiAgICByZXR1cm4gdmFsdWU7XCIsIFwifVwiXS5qb2luKFwiXFxuXCIpLFxuICAgIHBhcmFtRmV0Y2hpbmdGdW5jdGlvbnM6IFtcImZsb2F0IGdldEFsaXZlKCkge1wiLCBcIiAgIHJldHVybiBwYXJhbXMueDtcIiwgXCJ9XCIsIFwiZmxvYXQgZ2V0QWdlKCkge1wiLCBcIiAgIHJldHVybiBwYXJhbXMueTtcIiwgXCJ9XCIsIFwiZmxvYXQgZ2V0TWF4QWdlKCkge1wiLCBcIiAgIHJldHVybiBwYXJhbXMuejtcIiwgXCJ9XCIsIFwiZmxvYXQgZ2V0V2lnZ2xlKCkge1wiLCBcIiAgIHJldHVybiBwYXJhbXMudztcIiwgXCJ9XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgZm9yY2VGZXRjaGluZ0Z1bmN0aW9uczogW1widmVjNCBnZXRQb3NpdGlvbiggaW4gZmxvYXQgYWdlICkge1wiLCBcIiAgIHJldHVybiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsIFwifVwiLCBcInZlYzMgZ2V0VmVsb2NpdHkoIGluIGZsb2F0IGFnZSApIHtcIiwgXCIgICByZXR1cm4gdmVsb2NpdHkgKiBhZ2U7XCIsIFwifVwiLCBcInZlYzMgZ2V0QWNjZWxlcmF0aW9uKCBpbiBmbG9hdCBhZ2UgKSB7XCIsIFwiICAgcmV0dXJuIGFjY2VsZXJhdGlvbi54eXogKiBhZ2U7XCIsIFwifVwiXS5qb2luKFwiXFxuXCIpLFxuICAgIHJvdGF0aW9uRnVuY3Rpb25zOiBbXCIjaWZkZWYgU0hPVUxEX1JPVEFURV9QQVJUSUNMRVNcIiwgXCIgICBtYXQ0IGdldFJvdGF0aW9uTWF0cml4KCBpbiB2ZWMzIGF4aXMsIGluIGZsb2F0IGFuZ2xlKSB7XCIsIFwiICAgICAgIGF4aXMgPSBub3JtYWxpemUoYXhpcyk7XCIsIFwiICAgICAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpO1wiLCBcIiAgICAgICBmbG9hdCBjID0gY29zKGFuZ2xlKTtcIiwgXCIgICAgICAgZmxvYXQgb2MgPSAxLjAgLSBjO1wiLCBcIiAgICAgICByZXR1cm4gbWF0NChvYyAqIGF4aXMueCAqIGF4aXMueCArIGMsICAgICAgICAgICBvYyAqIGF4aXMueCAqIGF4aXMueSAtIGF4aXMueiAqIHMsICBvYyAqIGF4aXMueiAqIGF4aXMueCArIGF4aXMueSAqIHMsICAwLjAsXCIsIFwiICAgICAgICAgICAgICAgICAgIG9jICogYXhpcy54ICogYXhpcy55ICsgYXhpcy56ICogcywgIG9jICogYXhpcy55ICogYXhpcy55ICsgYywgICAgICAgICAgIG9jICogYXhpcy55ICogYXhpcy56IC0gYXhpcy54ICogcywgIDAuMCxcIiwgXCIgICAgICAgICAgICAgICAgICAgb2MgKiBheGlzLnogKiBheGlzLnggLSBheGlzLnkgKiBzLCAgb2MgKiBheGlzLnkgKiBheGlzLnogKyBheGlzLnggKiBzLCAgb2MgKiBheGlzLnogKiBheGlzLnogKyBjLCAgICAgICAgICAgMC4wLFwiLCBcIiAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjApO1wiLCBcIiAgIH1cIiwgXCIgICB2ZWMzIGdldFJvdGF0aW9uKCBpbiB2ZWMzIHBvcywgaW4gZmxvYXQgcG9zaXRpb25JblRpbWUgKSB7XCIsIFwiICAgICAgdmVjMyBheGlzID0gdW5wYWNrQ29sb3IoIHJvdGF0aW9uLnggKTtcIiwgXCIgICAgICB2ZWMzIGNlbnRlciA9IHJvdGF0aW9uQ2VudGVyO1wiLCBcIiAgICAgIHZlYzMgdHJhbnNsYXRlZDtcIiwgXCIgICAgICBtYXQ0IHJvdGF0aW9uTWF0cml4O1wiLCBcIiAgICAgIGZsb2F0IGFuZ2xlID0gMC4wO1wiLCBcIiAgICAgIGFuZ2xlICs9IHdoZW5fZXEoIHJvdGF0aW9uLnosIDAuMCApICogcm90YXRpb24ueTtcIiwgXCIgICAgICBhbmdsZSArPSB3aGVuX2d0KCByb3RhdGlvbi56LCAwLjAgKSAqIG1peCggMC4wLCByb3RhdGlvbi55LCBwb3NpdGlvbkluVGltZSApO1wiLCBcIiAgICAgIHRyYW5zbGF0ZWQgPSBwb3MgLSByb3RhdGlvbkNlbnRlcjtcIiwgXCIgICAgICByb3RhdGlvbk1hdHJpeCA9IGdldFJvdGF0aW9uTWF0cml4KCBheGlzLCBhbmdsZSApO1wiLCBcIiAgICAgIHJldHVybiB2ZWMzKCByb3RhdGlvbk1hdHJpeCAqIHZlYzQoIHRyYW5zbGF0ZWQsIDAuMCApICkgLSBjZW50ZXI7XCIsIFwiICAgfVwiLCBcIiNlbmRpZlwiXS5qb2luKFwiXFxuXCIpLFxuICAgIHJvdGF0ZVRleHR1cmU6IFtcIiAgICB2ZWMyIHZVdiA9IHZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICk7XCIsIFwiXCIsIFwiICAgICNpZmRlZiBTSE9VTERfUk9UQVRFX1RFWFRVUkVcIiwgXCIgICAgICAgZmxvYXQgeCA9IGdsX1BvaW50Q29vcmQueCAtIDAuNTtcIiwgXCIgICAgICAgZmxvYXQgeSA9IDEuMCAtIGdsX1BvaW50Q29vcmQueSAtIDAuNTtcIiwgXCIgICAgICAgZmxvYXQgYyA9IGNvcyggLXZBbmdsZSApO1wiLCBcIiAgICAgICBmbG9hdCBzID0gc2luKCAtdkFuZ2xlICk7XCIsIFwiICAgICAgIHZVdiA9IHZlYzIoIGMgKiB4ICsgcyAqIHkgKyAwLjUsIGMgKiB5IC0gcyAqIHggKyAwLjUgKTtcIiwgXCIgICAgI2VuZGlmXCIsIFwiXCIsIFwiICAgICNpZmRlZiBTSE9VTERfQ0FMQ1VMQVRFX1NQUklURVwiLCBcIiAgICAgICAgZmxvYXQgZnJhbWVzWCA9IHZTcHJpdGVTaGVldC54O1wiLCBcIiAgICAgICAgZmxvYXQgZnJhbWVzWSA9IHZTcHJpdGVTaGVldC55O1wiLCBcIiAgICAgICAgZmxvYXQgY29sdW1uTm9ybSA9IHZTcHJpdGVTaGVldC56O1wiLCBcIiAgICAgICAgZmxvYXQgcm93Tm9ybSA9IHZTcHJpdGVTaGVldC53O1wiLCBcIiAgICAgICAgdlV2LnggPSBnbF9Qb2ludENvb3JkLnggKiBmcmFtZXNYICsgY29sdW1uTm9ybTtcIiwgXCIgICAgICAgIHZVdi55ID0gMS4wIC0gKGdsX1BvaW50Q29vcmQueSAqIGZyYW1lc1kgKyByb3dOb3JtKTtcIiwgXCIgICAgI2VuZGlmXCIsIFwiXCIsIFwiICAgIHZlYzQgcm90YXRlZFRleHR1cmUgPSB0ZXh0dXJlMkQoIHRleHR1cmUsIHZVdiApO1wiXS5qb2luKFwiXFxuXCIpXG59LCBTUEUuc2hhZGVycyA9IHtcbiAgICB2ZXJ0ZXg6IFtTUEUuc2hhZGVyQ2h1bmtzLmRlZmluZXMsIFNQRS5zaGFkZXJDaHVua3MudW5pZm9ybXMsIFNQRS5zaGFkZXJDaHVua3MuYXR0cmlidXRlcywgU1BFLnNoYWRlckNodW5rcy52YXJ5aW5ncywgVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLCBUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCwgU1BFLnNoYWRlckNodW5rcy5icmFuY2hBdm9pZGFuY2VGdW5jdGlvbnMsIFNQRS5zaGFkZXJDaHVua3MudW5wYWNrQ29sb3IsIFNQRS5zaGFkZXJDaHVua3MuZmxvYXRPdmVyTGlmZXRpbWUsIFNQRS5zaGFkZXJDaHVua3MuY29sb3JPdmVyTGlmZXRpbWUsIFNQRS5zaGFkZXJDaHVua3MucGFyYW1GZXRjaGluZ0Z1bmN0aW9ucywgU1BFLnNoYWRlckNodW5rcy5mb3JjZUZldGNoaW5nRnVuY3Rpb25zLCBTUEUuc2hhZGVyQ2h1bmtzLnJvdGF0aW9uRnVuY3Rpb25zLCBcInZvaWQgbWFpbigpIHtcIiwgXCIgICAgaGlnaHAgZmxvYXQgYWdlID0gZ2V0QWdlKCk7XCIsIFwiICAgIGhpZ2hwIGZsb2F0IGFsaXZlID0gZ2V0QWxpdmUoKTtcIiwgXCIgICAgaGlnaHAgZmxvYXQgbWF4QWdlID0gZ2V0TWF4QWdlKCk7XCIsIFwiICAgIGhpZ2hwIGZsb2F0IHBvc2l0aW9uSW5UaW1lID0gKGFnZSAvIG1heEFnZSk7XCIsIFwiICAgIGhpZ2hwIGZsb2F0IGlzQWxpdmUgPSB3aGVuX2d0KCBhbGl2ZSwgMC4wICk7XCIsIFwiICAgICNpZmRlZiBTSE9VTERfV0lHR0xFX1BBUlRJQ0xFU1wiLCBcIiAgICAgICAgZmxvYXQgd2lnZ2xlQW1vdW50ID0gcG9zaXRpb25JblRpbWUgKiBnZXRXaWdnbGUoKTtcIiwgXCIgICAgICAgIGZsb2F0IHdpZ2dsZVNpbiA9IGlzQWxpdmUgKiBzaW4oIHdpZ2dsZUFtb3VudCApO1wiLCBcIiAgICAgICAgZmxvYXQgd2lnZ2xlQ29zID0gaXNBbGl2ZSAqIGNvcyggd2lnZ2xlQW1vdW50ICk7XCIsIFwiICAgICNlbmRpZlwiLCBcIiAgICB2ZWMzIHZlbCA9IGdldFZlbG9jaXR5KCBhZ2UgKTtcIiwgXCIgICAgdmVjMyBhY2NlbCA9IGdldEFjY2VsZXJhdGlvbiggYWdlICk7XCIsIFwiICAgIHZlYzMgZm9yY2UgPSB2ZWMzKCAwLjAgKTtcIiwgXCIgICAgdmVjMyBwb3MgPSB2ZWMzKCBwb3NpdGlvbiApO1wiLCBcIiAgICBmbG9hdCBkcmFnID0gMS4wIC0gKHBvc2l0aW9uSW5UaW1lICogMC41KSAqIGFjY2VsZXJhdGlvbi53O1wiLCBcIiAgICBmb3JjZSArPSB2ZWw7XCIsIFwiICAgIGZvcmNlICo9IGRyYWc7XCIsIFwiICAgIGZvcmNlICs9IGFjY2VsICogYWdlO1wiLCBcIiAgICBwb3MgKz0gZm9yY2U7XCIsIFwiICAgICNpZmRlZiBTSE9VTERfV0lHR0xFX1BBUlRJQ0xFU1wiLCBcIiAgICAgICAgcG9zLnggKz0gd2lnZ2xlU2luO1wiLCBcIiAgICAgICAgcG9zLnkgKz0gd2lnZ2xlQ29zO1wiLCBcIiAgICAgICAgcG9zLnogKz0gd2lnZ2xlU2luO1wiLCBcIiAgICAjZW5kaWZcIiwgXCIgICAgI2lmZGVmIFNIT1VMRF9ST1RBVEVfUEFSVElDTEVTXCIsIFwiICAgICAgICBwb3MgPSBnZXRSb3RhdGlvbiggcG9zLCBwb3NpdGlvbkluVGltZSApO1wiLCBcIiAgICAjZW5kaWZcIiwgXCIgICAgdmVjNCBtdlBvcyA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvcywgMS4wICk7XCIsIFwiICAgIGhpZ2hwIGZsb2F0IHBvaW50U2l6ZSA9IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgc2l6ZSApICogaXNBbGl2ZTtcIiwgXCIgICAgI2lmZGVmIEhBU19QRVJTUEVDVElWRVwiLCBcIiAgICAgICAgZmxvYXQgcGVyc3BlY3RpdmUgPSBzY2FsZSAvIGxlbmd0aCggbXZQb3MueHl6ICk7XCIsIFwiICAgICNlbHNlXCIsIFwiICAgICAgICBmbG9hdCBwZXJzcGVjdGl2ZSA9IDEuMDtcIiwgXCIgICAgI2VuZGlmXCIsIFwiICAgIGZsb2F0IHBvaW50U2l6ZVBlcnNwZWN0aXZlID0gcG9pbnRTaXplICogcGVyc3BlY3RpdmU7XCIsIFwiICAgICNpZmRlZiBDT0xPUklaRVwiLCBcIiAgICAgICB2ZWMzIGMgPSBpc0FsaXZlICogZ2V0Q29sb3JPdmVyTGlmZXRpbWUoXCIsIFwiICAgICAgICAgICBwb3NpdGlvbkluVGltZSxcIiwgXCIgICAgICAgICAgIHVucGFja0NvbG9yKCBjb2xvci54ICksXCIsIFwiICAgICAgICAgICB1bnBhY2tDb2xvciggY29sb3IueSApLFwiLCBcIiAgICAgICAgICAgdW5wYWNrQ29sb3IoIGNvbG9yLnogKSxcIiwgXCIgICAgICAgICAgIHVucGFja0NvbG9yKCBjb2xvci53IClcIiwgXCIgICAgICAgKTtcIiwgXCIgICAgI2Vsc2VcIiwgXCIgICAgICAgdmVjMyBjID0gdmVjMygxLjApO1wiLCBcIiAgICAjZW5kaWZcIiwgXCIgICAgZmxvYXQgbyA9IGlzQWxpdmUgKiBnZXRGbG9hdE92ZXJMaWZldGltZSggcG9zaXRpb25JblRpbWUsIG9wYWNpdHkgKTtcIiwgXCIgICAgdkNvbG9yID0gdmVjNCggYywgbyApO1wiLCBcIiAgICAjaWZkZWYgU0hPVUxEX1JPVEFURV9URVhUVVJFXCIsIFwiICAgICAgICB2QW5nbGUgPSBpc0FsaXZlICogZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIHBvc2l0aW9uSW5UaW1lLCBhbmdsZSApO1wiLCBcIiAgICAjZW5kaWZcIiwgXCIgICAgI2lmZGVmIFNIT1VMRF9DQUxDVUxBVEVfU1BSSVRFXCIsIFwiICAgICAgICBmbG9hdCBmcmFtZXNYID0gdGV4dHVyZUFuaW1hdGlvbi54O1wiLCBcIiAgICAgICAgZmxvYXQgZnJhbWVzWSA9IHRleHR1cmVBbmltYXRpb24ueTtcIiwgXCIgICAgICAgIGZsb2F0IGxvb3BDb3VudCA9IHRleHR1cmVBbmltYXRpb24udztcIiwgXCIgICAgICAgIGZsb2F0IHRvdGFsRnJhbWVzID0gdGV4dHVyZUFuaW1hdGlvbi56O1wiLCBcIiAgICAgICAgZmxvYXQgZnJhbWVOdW1iZXIgPSBtb2QoIChwb3NpdGlvbkluVGltZSAqIGxvb3BDb3VudCkgKiB0b3RhbEZyYW1lcywgdG90YWxGcmFtZXMgKTtcIiwgXCIgICAgICAgIGZsb2F0IGNvbHVtbiA9IGZsb29yKG1vZCggZnJhbWVOdW1iZXIsIGZyYW1lc1ggKSk7XCIsIFwiICAgICAgICBmbG9hdCByb3cgPSBmbG9vciggKGZyYW1lTnVtYmVyIC0gY29sdW1uKSAvIGZyYW1lc1ggKTtcIiwgXCIgICAgICAgIGZsb2F0IGNvbHVtbk5vcm0gPSBjb2x1bW4gLyBmcmFtZXNYO1wiLCBcIiAgICAgICAgZmxvYXQgcm93Tm9ybSA9IHJvdyAvIGZyYW1lc1k7XCIsIFwiICAgICAgICB2U3ByaXRlU2hlZXQueCA9IDEuMCAvIGZyYW1lc1g7XCIsIFwiICAgICAgICB2U3ByaXRlU2hlZXQueSA9IDEuMCAvIGZyYW1lc1k7XCIsIFwiICAgICAgICB2U3ByaXRlU2hlZXQueiA9IGNvbHVtbk5vcm07XCIsIFwiICAgICAgICB2U3ByaXRlU2hlZXQudyA9IHJvd05vcm07XCIsIFwiICAgICNlbmRpZlwiLCBcIiAgICBnbF9Qb2ludFNpemUgPSBwb2ludFNpemVQZXJzcGVjdGl2ZTtcIiwgXCIgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3M7XCIsIFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3ZlcnRleCwgXCJ9XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgZnJhZ21lbnQ6IFtTUEUuc2hhZGVyQ2h1bmtzLnVuaWZvcm1zLCBUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sIFRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50LCBUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50LCBTUEUuc2hhZGVyQ2h1bmtzLnZhcnlpbmdzLCBTUEUuc2hhZGVyQ2h1bmtzLmJyYW5jaEF2b2lkYW5jZUZ1bmN0aW9ucywgXCJ2b2lkIG1haW4oKSB7XCIsIFwiICAgIHZlYzMgb3V0Z29pbmdMaWdodCA9IHZDb2xvci54eXo7XCIsIFwiICAgIFwiLCBcIiAgICAjaWZkZWYgQUxQSEFURVNUXCIsIFwiICAgICAgIGlmICggdkNvbG9yLncgPCBmbG9hdChBTFBIQVRFU1QpICkgZGlzY2FyZDtcIiwgXCIgICAgI2VuZGlmXCIsIFNQRS5zaGFkZXJDaHVua3Mucm90YXRlVGV4dHVyZSwgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfZnJhZ21lbnQsIFwiICAgIG91dGdvaW5nTGlnaHQgPSB2Q29sb3IueHl6ICogcm90YXRlZFRleHR1cmUueHl6O1wiLCBUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQueHl6LCByb3RhdGVkVGV4dHVyZS53ICogdkNvbG9yLncgKTtcIiwgXCJ9XCJdLmpvaW4oXCJcXG5cIilcbn0sIFNQRS51dGlscyA9IHtcbiAgICB0eXBlczoge1xuICAgICAgICBCT09MRUFOOiBcImJvb2xlYW5cIixcbiAgICAgICAgU1RSSU5HOiBcInN0cmluZ1wiLFxuICAgICAgICBOVU1CRVI6IFwibnVtYmVyXCIsXG4gICAgICAgIE9CSkVDVDogXCJvYmplY3RcIlxuICAgIH0sXG4gICAgZW5zdXJlVHlwZWRBcmc6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gYiA/IGEgOiBjXG4gICAgfSxcbiAgICBlbnN1cmVBcnJheVR5cGVkQXJnOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IGEubGVuZ3RoIC0gMTsgZCA+PSAwOyAtLWQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhW2RdICE9PSBiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlVHlwZWRBcmcoYSwgYiwgYylcbiAgICB9LFxuICAgIGVuc3VyZUluc3RhbmNlT2Y6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiB2b2lkIDAgIT09IGIgJiYgYSBpbnN0YW5jZW9mIGIgPyBhIDogYztcbiAgICB9LFxuICAgIGVuc3VyZUFycmF5SW5zdGFuY2VPZjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSBhLmxlbmd0aCAtIDE7IGQgPj0gMDsgLS1kKVxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGIgJiYgYVtkXSBpbnN0YW5jZW9mIGIgPT0gITEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbnN0YW5jZU9mKGEsIGIsIGMpXG4gICAgfSxcbiAgICBlbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2U6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGIgPSBiIHx8IDMsIGMgPSBjIHx8IDMsIEFycmF5LmlzQXJyYXkoYS5fdmFsdWUpID09PSAhMSAmJiAoYS5fdmFsdWUgPSBbYS5fdmFsdWVdKSwgQXJyYXkuaXNBcnJheShhLl9zcHJlYWQpID09PSAhMSAmJiAoYS5fc3ByZWFkID0gW2EuX3NwcmVhZF0pO1xuICAgICAgICB2YXIgZCA9IHRoaXMuY2xhbXAoYS5fdmFsdWUubGVuZ3RoLCBiLCBjKSxcbiAgICAgICAgICAgIGUgPSB0aGlzLmNsYW1wKGEuX3NwcmVhZC5sZW5ndGgsIGIsIGMpLFxuICAgICAgICAgICAgZiA9IE1hdGgubWF4KGQsIGUpO1xuICAgICAgICBhLl92YWx1ZS5sZW5ndGggIT09IGYgJiYgKGEuX3ZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZUFycmF5KGEuX3ZhbHVlLCBmKSksIGEuX3NwcmVhZC5sZW5ndGggIT09IGYgJiYgKGEuX3NwcmVhZCA9IHRoaXMuaW50ZXJwb2xhdGVBcnJheShhLl9zcHJlYWQsIGYpKVxuICAgIH0sXG4gICAgaW50ZXJwb2xhdGVBcnJheTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgZm9yICh2YXIgYyA9IGEubGVuZ3RoLCBkID0gW1wiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYVswXS5jbG9uZSA/IGFbMF0uY2xvbmUoKSA6IGFbMF1dLCBlID0gKGMgLSAxKSAvIChiIC0gMSksIGYgPSAxOyBiIC0gMSA+IGY7ICsrZikge1xuICAgICAgICAgICAgdmFyIGcgPSBmICogZSxcbiAgICAgICAgICAgICAgICBoID0gTWF0aC5mbG9vcihnKSxcbiAgICAgICAgICAgICAgICBpID0gTWF0aC5jZWlsKGcpLFxuICAgICAgICAgICAgICAgIGogPSBnIC0gaDtcbiAgICAgICAgICAgIGRbZl0gPSB0aGlzLmxlcnBUeXBlQWdub3N0aWMoYVtoXSwgYVtpXSwgailcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZC5wdXNoKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYVtjIC0gMV0uY2xvbmUgPyBhW2MgLSAxXS5jbG9uZSgpIDogYVtjIC0gMV0pLCBkXG4gICAgfSxcbiAgICBjbGFtcDogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGIsIE1hdGgubWluKGEsIGMpKVxuICAgIH0sXG4gICAgemVyb1RvRXBzaWxvbjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGMgPSAxZS01LFxuICAgICAgICAgICAgZCA9IGE7XG4gICAgICAgIHJldHVybiBkID0gYiA/IE1hdGgucmFuZG9tKCkgKiBjICogMTAgOiBjLCAwID4gYSAmJiBhID4gLWMgJiYgKGQgPSAtZCksIGRcbiAgICB9LFxuICAgIGxlcnBUeXBlQWdub3N0aWM6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBkLFxuICAgICAgICAgICAgZSA9IHRoaXMudHlwZXM7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gZS5OVU1CRVIgJiYgdHlwZW9mIGIgPT09IGUuTlVNQkVSID8gYSArIChiIC0gYSkgKiBjIDogYSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgJiYgYiBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgPyAoZCA9IGEuY2xvbmUoKSwgZC54ID0gdGhpcy5sZXJwKGEueCwgYi54LCBjKSwgZC55ID0gdGhpcy5sZXJwKGEueSwgYi55LCBjKSwgZCkgOiBhIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBiIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IChkID0gYS5jbG9uZSgpLCBkLnggPSB0aGlzLmxlcnAoYS54LCBiLngsIGMpLCBkLnkgPSB0aGlzLmxlcnAoYS55LCBiLnksIGMpLCBkLnogPSB0aGlzLmxlcnAoYS56LCBiLnosIGMpLCBkKSA6IGEgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0ICYmIGIgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0ID8gKGQgPSBhLmNsb25lKCksIGQueCA9IHRoaXMubGVycChhLngsIGIueCwgYyksIGQueSA9IHRoaXMubGVycChhLnksIGIueSwgYyksIGQueiA9IHRoaXMubGVycChhLnosIGIueiwgYyksIGQudyA9IHRoaXMubGVycChhLncsIGIudywgYyksIGQpIDogYSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICYmIGIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciA/IChkID0gYS5jbG9uZSgpLCBkLnIgPSB0aGlzLmxlcnAoYS5yLCBiLnIsIGMpLCBkLmcgPSB0aGlzLmxlcnAoYS5nLCBiLmcsIGMpLCBkLmIgPSB0aGlzLmxlcnAoYS5iLCBiLmIsIGMpLCBkKSA6IHZvaWQgY29uc29sZS53YXJuKFwiSW52YWxpZCBhcmd1bWVudCB0eXBlcywgb3IgYXJndW1lbnQgdHlwZXMgZG8gbm90IG1hdGNoOlwiLCBhLCBiKVxuICAgIH0sXG4gICAgbGVycDogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuIGEgKyAoYiAtIGEpICogY1xuICAgIH0sXG4gICAgcm91bmRUb05lYXJlc3RNdWx0aXBsZTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICByZXR1cm4gMCA9PT0gYiA/IGEgOiAoYyA9IE1hdGguYWJzKGEpICUgYixcbiAgICAgICAgMCA9PT0gYyA/IGEgOiAwID4gYSA/IC0oTWF0aC5hYnMoYSkgLSBjKSA6IGEgKyBiIC0gYylcbiAgICB9LFxuICAgIGFycmF5VmFsdWVzQXJlRXF1YWw6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYS5sZW5ndGggLSAxOyArK2IpXG4gICAgICAgICAgICBpZiAoYVtiXSAhPT0gYVtiICsgMV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICByZXR1cm4gITBcbiAgICB9LFxuICAgIHJhbmRvbUZsb2F0OiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4gYSArIGIgKiAoTWF0aC5yYW5kb20oKSAtIC41KVxuICAgIH0sXG4gICAgcmFuZG9tVmVjdG9yMzogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGYgPSBjLnggKyAoTWF0aC5yYW5kb20oKSAqIGQueCAtIC41ICogZC54KSxcbiAgICAgICAgICAgIGcgPSBjLnkgKyAoTWF0aC5yYW5kb20oKSAqIGQueSAtIC41ICogZC55KSxcbiAgICAgICAgICAgIGggPSBjLnogKyAoTWF0aC5yYW5kb20oKSAqIGQueiAtIC41ICogZC56KTtcbiAgICAgICAgZSAmJiAoZiA9IC41ICogLWUueCArIHRoaXMucm91bmRUb05lYXJlc3RNdWx0aXBsZShmLCBlLngpLCBnID0gLjUgKiAtZS55ICsgdGhpcy5yb3VuZFRvTmVhcmVzdE11bHRpcGxlKGcsIGUueSksIGggPSAuNSAqIC1lLnogKyB0aGlzLnJvdW5kVG9OZWFyZXN0TXVsdGlwbGUoaCwgZS56KSksIGEudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyhiLCBmLCBnLCBoKVxuICAgIH0sXG4gICAgcmFuZG9tQ29sb3I6IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBlID0gYy5yICsgTWF0aC5yYW5kb20oKSAqIGQueCxcbiAgICAgICAgICAgIGYgPSBjLmcgKyBNYXRoLnJhbmRvbSgpICogZC55LFxuICAgICAgICAgICAgZyA9IGMuYiArIE1hdGgucmFuZG9tKCkgKiBkLno7XG4gICAgICAgIGUgPSB0aGlzLmNsYW1wKGUsIDAsIDEpLCBmID0gdGhpcy5jbGFtcChmLCAwLCAxKSwgZyA9IHRoaXMuY2xhbXAoZywgMCwgMSksIGEudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyhiLCBlLCBmLCBnKVxuICAgIH0sXG4gICAgcmFuZG9tQ29sb3JBc0hleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgYSA9IG5ldyBUSFJFRS5Db2xvcjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGIsIGMsIGQsIGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSBkLmxlbmd0aCwgZyA9IFtdLCBoID0gMDsgZiA+IGg7ICsraCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gZVtoXTtcbiAgICAgICAgICAgICAgICBhLmNvcHkoZFtoXSksIGEuciArPSBNYXRoLnJhbmRvbSgpICogaS54IC0gLjUgKiBpLngsIGEuZyArPSBNYXRoLnJhbmRvbSgpICogaS55IC0gLjUgKiBpLnksIGEuYiArPSBNYXRoLnJhbmRvbSgpICogaS56IC0gLjUgKiBpLnosXG4gICAgICAgICAgICAgICAgYS5yID0gdGhpcy5jbGFtcChhLnIsIDAsIDEpLCBhLmcgPSB0aGlzLmNsYW1wKGEuZywgMCwgMSksIGEuYiA9IHRoaXMuY2xhbXAoYS5iLCAwLCAxKSwgZy5wdXNoKGEuZ2V0SGV4KCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLnR5cGVkQXJyYXkuc2V0VmVjNENvbXBvbmVudHMoYywgZ1swXSwgZ1sxXSwgZ1syXSwgZ1szXSlcbiAgICAgICAgfVxuICAgIH0oKSxcbiAgICByYW5kb21WZWN0b3IzT25TcGhlcmU6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBpID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxLFxuICAgICAgICAgICAgaiA9IDYuMjgzMiAqIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICBrID0gTWF0aC5zcXJ0KDEgLSBpICogaSksXG4gICAgICAgICAgICBsID0gdGhpcy5yYW5kb21GbG9hdChkLCBlKSxcbiAgICAgICAgICAgIG0gPSAwLFxuICAgICAgICAgICAgbiA9IDAsXG4gICAgICAgICAgICBvID0gMDtcbiAgICAgICAgZyAmJiAobCA9IE1hdGgucm91bmQobCAvIGcpICogZyksIG0gPSBrICogTWF0aC5jb3MoaikgKiBsLCBuID0gayAqIE1hdGguc2luKGopICogbCwgbyA9IGkgKiBsLCBtICo9IGYueCwgbiAqPSBmLnksIG8gKj0gZi56LCBtICs9IGMueCwgbiArPSBjLnksIG8gKz0gYy56LCBhLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoYiwgbSwgbiwgbylcbiAgICB9LFxuICAgIHNlZWRlZFJhbmRvbTogZnVuY3Rpb24oYSkge1xuICAgICAgICB2YXIgYiA9IDFlNCAqIE1hdGguc2luKGEpO1xuICAgICAgICByZXR1cm4gYiAtICgwIHwgYilcbiAgICB9LFxuICAgIHJhbmRvbVZlY3RvcjNPbkRpc2M6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBoID0gNi4yODMyICogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgIGkgPSBNYXRoLmFicyh0aGlzLnJhbmRvbUZsb2F0KGQsIGUpKSxcbiAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgayA9IDAsXG4gICAgICAgICAgICBsID0gMDtcbiAgICAgICAgZyAmJiAoaSA9IE1hdGgucm91bmQoaSAvIGcpICogZyksIGogPSBNYXRoLmNvcyhoKSAqIGksIGsgPSBNYXRoLnNpbihoKSAqIGksIGogKj0gZi54LCBrICo9IGYueSwgaiArPSBjLngsIGsgKz0gYy55LCBsICs9IGMueiwgYS50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKGIsIGosIGssIGwpXG4gICAgfSxcbiAgICByYW5kb21EaXJlY3Rpb25WZWN0b3IzT25TcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGEgPSBuZXcgVEhSRUUuVmVjdG9yMztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGIsIGMsIGQsIGUsIGYsIGcsIGgsIGkpIHtcbiAgICAgICAgICAgIGEuY29weShnKSwgYS54IC09IGQsIGEueSAtPSBlLCBhLnogLT0gZiwgYS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigtdGhpcy5yYW5kb21GbG9hdChoLCBpKSksIGIudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyhjLCBhLngsIGEueSwgYS56KTtcbiAgICAgICAgfVxuICAgIH0oKSxcbiAgICByYW5kb21EaXJlY3Rpb25WZWN0b3IzT25EaXNjOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBhID0gbmV3IFRIUkVFLlZlY3RvcjM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKSB7XG4gICAgICAgICAgICBhLmNvcHkoZyksIGEueCAtPSBkLCBhLnkgLT0gZSwgYS56IC09IGYsIGEubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoLXRoaXMucmFuZG9tRmxvYXQoaCwgaSkpLCBiLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoYywgYS54LCBhLnksIDApXG4gICAgICAgIH1cbiAgICB9KCksXG4gICAgZ2V0UGFja2VkUm90YXRpb25BeGlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBhID0gbmV3IFRIUkVFLlZlY3RvcjMsXG4gICAgICAgICAgICBiID0gbmV3IFRIUkVFLlZlY3RvcjMsXG4gICAgICAgICAgICBjID0gbmV3IFRIUkVFLkNvbG9yO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29weShkKS5ub3JtYWxpemUoKSwgYi5jb3B5KGUpLm5vcm1hbGl6ZSgpLCBhLnggKz0gLjUgKiAtZS54ICsgTWF0aC5yYW5kb20oKSAqIGUueCwgYS55ICs9IC41ICogLWUueSArIE1hdGgucmFuZG9tKCkgKiBlLnksIGEueiArPSAuNSAqIC1lLnogKyBNYXRoLnJhbmRvbSgpICogZS56LCBhLnggPSBNYXRoLmFicyhhLngpLCBhLnkgPSBNYXRoLmFicyhhLnkpLCBhLnogPSBNYXRoLmFicyhhLnopLCBhLm5vcm1hbGl6ZSgpLCBjLnNldFJHQihhLngsIGEueSwgYS56KSwgYy5nZXRIZXgoKVxuICAgICAgICB9XG4gICAgfSgpXG59LCBTUEUuR3JvdXAgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIgPSBTUEUudXRpbHMsXG4gICAgICAgIGMgPSBiLnR5cGVzO1xuICAgIGEgPSBiLmVuc3VyZVR5cGVkQXJnKGEsIGMuT0JKRUNULCB7fSksIGEudGV4dHVyZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS50ZXh0dXJlLCBjLk9CSkVDVCwge30pLCB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpLCB0aGlzLmZpeGVkVGltZVN0ZXAgPSBiLmVuc3VyZVR5cGVkQXJnKGEuZml4ZWRUaW1lU3RlcCwgYy5OVU1CRVIsIC4wMTYpLCB0aGlzLnRleHR1cmUgPSBiLmVuc3VyZUluc3RhbmNlT2YoYS50ZXh0dXJlLnZhbHVlLCBUSFJFRS5UZXh0dXJlLCBudWxsKSwgdGhpcy50ZXh0dXJlRnJhbWVzID0gYi5lbnN1cmVJbnN0YW5jZU9mKGEudGV4dHVyZS5mcmFtZXMsIFRIUkVFLlZlY3RvcjIsIG5ldyBUSFJFRS5WZWN0b3IyKDEsIDEpKSxcbiAgICB0aGlzLnRleHR1cmVGcmFtZUNvdW50ID0gYi5lbnN1cmVUeXBlZEFyZyhhLnRleHR1cmUuZnJhbWVDb3VudCwgYy5OVU1CRVIsIHRoaXMudGV4dHVyZUZyYW1lcy54ICogdGhpcy50ZXh0dXJlRnJhbWVzLnkpLCB0aGlzLnRleHR1cmVMb29wID0gYi5lbnN1cmVUeXBlZEFyZyhhLnRleHR1cmUubG9vcCwgYy5OVU1CRVIsIDEpLCB0aGlzLnRleHR1cmVGcmFtZXMubWF4KG5ldyBUSFJFRS5WZWN0b3IyKDEsIDEpKSwgdGhpcy5oYXNQZXJzcGVjdGl2ZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5oYXNQZXJzcGVjdGl2ZSwgYy5CT09MRUFOLCAhMCksIHRoaXMuY29sb3JpemUgPSBiLmVuc3VyZVR5cGVkQXJnKGEuY29sb3JpemUsIGMuQk9PTEVBTiwgITApLCB0aGlzLm1heFBhcnRpY2xlQ291bnQgPSBiLmVuc3VyZVR5cGVkQXJnKGEubWF4UGFydGljbGVDb3VudCwgYy5OVU1CRVIsIG51bGwpLCB0aGlzLmJsZW5kaW5nID0gYi5lbnN1cmVUeXBlZEFyZyhhLmJsZW5kaW5nLCBjLk5VTUJFUiwgVEhSRUUuQWRkaXRpdmVCbGVuZGluZyksIHRoaXMudHJhbnNwYXJlbnQgPSBiLmVuc3VyZVR5cGVkQXJnKGEudHJhbnNwYXJlbnQsIGMuQk9PTEVBTiwgITApLCB0aGlzLmFscGhhVGVzdCA9IHBhcnNlRmxvYXQoYi5lbnN1cmVUeXBlZEFyZyhhLmFscGhhVGVzdCwgYy5OVU1CRVIsIDApKSwgdGhpcy5kZXB0aFdyaXRlID0gYi5lbnN1cmVUeXBlZEFyZyhhLmRlcHRoV3JpdGUsIGMuQk9PTEVBTiwgITEpLCB0aGlzLmRlcHRoVGVzdCA9IGIuZW5zdXJlVHlwZWRBcmcoYS5kZXB0aFRlc3QsIGMuQk9PTEVBTiwgITApLCB0aGlzLmZvZyA9IGIuZW5zdXJlVHlwZWRBcmcoYS5mb2csIGMuQk9PTEVBTiwgITApLCB0aGlzLnNjYWxlID0gYi5lbnN1cmVUeXBlZEFyZyhhLnNjYWxlLCBjLk5VTUJFUiwgMzAwKSwgdGhpcy5lbWl0dGVycyA9IFtdLCB0aGlzLmVtaXR0ZXJJRHMgPSBbXSwgdGhpcy5fcG9vbCA9IFtdLCB0aGlzLl9wb29sQ3JlYXRpb25TZXR0aW5ncyA9IG51bGwsIHRoaXMuX2NyZWF0ZU5ld1doZW5Qb29sRW1wdHkgPSAwLCB0aGlzLl9hdHRyaWJ1dGVzTmVlZFJlZnJlc2ggPSAhMSwgdGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgPSAhMSxcbiAgICB0aGlzLnBhcnRpY2xlQ291bnQgPSAwLCB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICB0ZXh0dXJlOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnRleHR1cmVcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dHVyZUFuaW1hdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJ2NFwiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KHRoaXMudGV4dHVyZUZyYW1lcy54LCB0aGlzLnRleHR1cmVGcmFtZXMueSwgdGhpcy50ZXh0dXJlRnJhbWVDb3VudCwgTWF0aC5tYXgoTWF0aC5hYnModGhpcy50ZXh0dXJlTG9vcCksIDEpKVxuICAgICAgICB9LFxuICAgICAgICBmb2dDb2xvcjoge1xuICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBmb2dOZWFyOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxMFxuICAgICAgICB9LFxuICAgICAgICBmb2dGYXI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDIwMFxuICAgICAgICB9LFxuICAgICAgICBmb2dEZW5zaXR5OiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAuNVxuICAgICAgICB9LFxuICAgICAgICBkZWx0YVRpbWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcnVuVGltZToge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FsZVxuICAgICAgICB9XG4gICAgfSwgdGhpcy5kZWZpbmVzID0ge1xuICAgICAgICBIQVNfUEVSU1BFQ1RJVkU6IHRoaXMuaGFzUGVyc3BlY3RpdmUsXG4gICAgICAgIENPTE9SSVpFOiB0aGlzLmNvbG9yaXplLFxuICAgICAgICBWQUxVRV9PVkVSX0xJRkVUSU1FX0xFTkdUSDogU1BFLnZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoLFxuICAgICAgICBTSE9VTERfUk9UQVRFX1RFWFRVUkU6ICExLFxuICAgICAgICBTSE9VTERfUk9UQVRFX1BBUlRJQ0xFUzogITEsXG4gICAgICAgIFNIT1VMRF9XSUdHTEVfUEFSVElDTEVTOiAhMSxcbiAgICAgICAgU0hPVUxEX0NBTENVTEFURV9TUFJJVEU6IHRoaXMudGV4dHVyZUZyYW1lcy54ID4gMSB8fCB0aGlzLnRleHR1cmVGcmFtZXMueSA+IDFcbiAgICB9LCB0aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInYzXCIsICEwKSxcbiAgICAgICAgYWNjZWxlcmF0aW9uOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInY0XCIsICEwKSxcbiAgICAgICAgdmVsb2NpdHk6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjNcIiwgITApLFxuICAgICAgICByb3RhdGlvbjogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2NFwiLCAhMCksXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInYzXCIsICEwKSxcbiAgICAgICAgcGFyYW1zOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInY0XCIsICEwKSxcbiAgICAgICAgc2l6ZTogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2NFwiLCAhMCksXG4gICAgICAgIGFuZ2xlOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInY0XCIsICEwKSxcbiAgICAgICAgY29sb3I6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjRcIiwgITApLFxuICAgICAgICBvcGFjaXR5OiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInY0XCIsICEwKVxuICAgIH0sIHRoaXMuYXR0cmlidXRlS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcyksIHRoaXMuYXR0cmlidXRlQ291bnQgPSB0aGlzLmF0dHJpYnV0ZUtleXMubGVuZ3RoLCB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICAgIHZlcnRleFNoYWRlcjogU1BFLnNoYWRlcnMudmVydGV4LFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogU1BFLnNoYWRlcnMuZnJhZ21lbnQsXG4gICAgICAgIGJsZW5kaW5nOiB0aGlzLmJsZW5kaW5nLFxuICAgICAgICB0cmFuc3BhcmVudDogdGhpcy50cmFuc3BhcmVudCxcbiAgICAgICAgYWxwaGFUZXN0OiB0aGlzLmFscGhhVGVzdCxcbiAgICAgICAgZGVwdGhXcml0ZTogdGhpcy5kZXB0aFdyaXRlLFxuICAgICAgICBkZXB0aFRlc3Q6IHRoaXMuZGVwdGhUZXN0LFxuICAgICAgICBkZWZpbmVzOiB0aGlzLmRlZmluZXMsXG4gICAgICAgIGZvZzogdGhpcy5mb2dcbiAgICB9KSwgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSwgdGhpcy5tZXNoID0gbmV3IFRIUkVFLlBvaW50cyh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKSwgbnVsbCA9PT0gdGhpcy5tYXhQYXJ0aWNsZUNvdW50ICYmIGNvbnNvbGUud2FybihcIlNQRS5Hcm91cDogTm8gbWF4UGFydGljbGVDb3VudCBzcGVjaWZpZWQuIEFkZGluZyBlbWl0dGVycyBhZnRlciByZW5kZXJpbmcgd2lsbCBwcm9iYWJseSBjYXVzZSBlcnJvcnMuXCIpXG59LCBTUEUuR3JvdXAuY29uc3RydWN0b3IgPSBTUEUuR3JvdXAsIFNQRS5Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZURlZmluZXMgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYSxcbiAgICAgICAgYiA9IHRoaXMuZW1pdHRlcnMsXG4gICAgICAgIGMgPSBiLmxlbmd0aCAtIDEsXG4gICAgICAgIGQgPSB0aGlzLmRlZmluZXM7XG4gICAgZm9yIChjOyBjID49IDA7IC0tYylcbiAgICAgICAgYSA9IGJbY10sIGQuU0hPVUxEX0NBTENVTEFURV9TUFJJVEUgfHwgKGQuU0hPVUxEX1JPVEFURV9URVhUVVJFID0gZC5TSE9VTERfUk9UQVRFX1RFWFRVUkUgfHwgISFNYXRoLm1heChNYXRoLm1heC5hcHBseShudWxsLCBhLmFuZ2xlLnZhbHVlKSwgTWF0aC5tYXguYXBwbHkobnVsbCwgYS5hbmdsZS5zcHJlYWQpKSksXG4gICAgICAgIGQuU0hPVUxEX1JPVEFURV9QQVJUSUNMRVMgPSBkLlNIT1VMRF9ST1RBVEVfUEFSVElDTEVTIHx8ICEhTWF0aC5tYXgoYS5yb3RhdGlvbi5hbmdsZSwgYS5yb3RhdGlvbi5hbmdsZVNwcmVhZCksIGQuU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVMgPSBkLlNIT1VMRF9XSUdHTEVfUEFSVElDTEVTIHx8ICEhTWF0aC5tYXgoYS53aWdnbGUudmFsdWUsIGEud2lnZ2xlLnNwcmVhZCk7XG4gICAgdGhpcy5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9ICEwXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLl9hcHBseUF0dHJpYnV0ZXNUb0dlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMgPSB0aGlzLmF0dHJpYnV0ZXMsXG4gICAgICAgIGQgPSB0aGlzLmdlb21ldHJ5LFxuICAgICAgICBlID0gZC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGYgaW4gYylcbiAgICAgICAgYy5oYXNPd25Qcm9wZXJ0eShmKSAmJiAoYSA9IGNbZl0sIGIgPSBlW2ZdLCBiID8gYi5hcnJheSA9IGEudHlwZWRBcnJheS5hcnJheSA6IGQuYWRkQXR0cmlidXRlKGYsIGEuYnVmZmVyQXR0cmlidXRlKSwgYS5idWZmZXJBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSAhMCk7XG4gICAgdGhpcy5nZW9tZXRyeS5zZXREcmF3UmFuZ2UoMCwgdGhpcy5wYXJ0aWNsZUNvdW50KVxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5hZGRFbWl0dGVyID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmIChhIGluc3RhbmNlb2YgU1BFLkVtaXR0ZXIgPT0gITEpXG4gICAgICAgIHJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJgZW1pdHRlcmAgYXJndW1lbnQgbXVzdCBiZSBpbnN0YW5jZSBvZiBTUEUuRW1pdHRlci4gV2FzIHByb3ZpZGVkIHdpdGg6XCIsIGEpO1xuICAgIGlmICh0aGlzLmVtaXR0ZXJJRHMuaW5kZXhPZihhLnV1aWQpID4gLTEpXG4gICAgICAgIHJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJFbWl0dGVyIGFscmVhZHkgZXhpc3RzIGluIHRoaXMgZ3JvdXAuIFdpbGwgbm90IGFkZCBhZ2Fpbi5cIik7XG4gICAgaWYgKG51bGwgIT09IGEuZ3JvdXApXG4gICAgICAgIHJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJFbWl0dGVyIGFscmVhZHkgYmVsb25ncyB0byBhbm90aGVyIGdyb3VwLiBXaWxsIG5vdCBhZGQgdG8gcmVxdWVzdGVkIGdyb3VwLlwiKTtcbiAgICB2YXIgYiA9IHRoaXMuYXR0cmlidXRlcyxcbiAgICAgICAgYyA9IHRoaXMucGFydGljbGVDb3VudCxcbiAgICAgICAgZCA9IGMgKyBhLnBhcnRpY2xlQ291bnQ7XG4gICAgdGhpcy5wYXJ0aWNsZUNvdW50ID0gZCwgbnVsbCAhPT0gdGhpcy5tYXhQYXJ0aWNsZUNvdW50ICYmIHRoaXMucGFydGljbGVDb3VudCA+IHRoaXMubWF4UGFydGljbGVDb3VudCAmJiBjb25zb2xlLndhcm4oXCJTUEUuR3JvdXA6IG1heFBhcnRpY2xlQ291bnQgZXhjZWVkZWQuIFJlcXVlc3RpbmdcIiwgdGhpcy5wYXJ0aWNsZUNvdW50LCBcInBhcnRpY2xlcywgY2FuIHN1cHBvcnQgb25seVwiLCB0aGlzLm1heFBhcnRpY2xlQ291bnQpLCBhLl9jYWxjdWxhdGVQUFNWYWx1ZShhLm1heEFnZS5fdmFsdWUgKyBhLm1heEFnZS5fc3ByZWFkKSwgYS5fc2V0QnVmZmVyVXBkYXRlUmFuZ2VzKHRoaXMuYXR0cmlidXRlS2V5cyksIGEuX3NldEF0dHJpYnV0ZU9mZnNldChjKSwgYS5ncm91cCA9IHRoaXMsIGEuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBlIGluIGIpXG4gICAgICAgIGIuaGFzT3duUHJvcGVydHkoZSkgJiYgYltlXS5fY3JlYXRlQnVmZmVyQXR0cmlidXRlKG51bGwgIT09IHRoaXMubWF4UGFydGljbGVDb3VudCA/IHRoaXMubWF4UGFydGljbGVDb3VudCA6IHRoaXMucGFydGljbGVDb3VudCk7XG4gICAgZm9yICh2YXIgZiA9IGM7IGQgPiBmOyArK2YpXG4gICAgICAgIGEuX2Fzc2lnblBvc2l0aW9uVmFsdWUoZiksIGEuX2Fzc2lnbkZvcmNlVmFsdWUoZiwgXCJ2ZWxvY2l0eVwiKSwgYS5fYXNzaWduRm9yY2VWYWx1ZShmLCBcImFjY2VsZXJhdGlvblwiKSwgYS5fYXNzaWduQWJzTGlmZXRpbWVWYWx1ZShmLCBcIm9wYWNpdHlcIiksIGEuX2Fzc2lnbkFic0xpZmV0aW1lVmFsdWUoZiwgXCJzaXplXCIpLCBhLl9hc3NpZ25BbmdsZVZhbHVlKGYpLCBhLl9hc3NpZ25Sb3RhdGlvblZhbHVlKGYpLCBhLl9hc3NpZ25QYXJhbXNWYWx1ZShmKSwgYS5fYXNzaWduQ29sb3JWYWx1ZShmKTtcbiAgICByZXR1cm4gdGhpcy5fYXBwbHlBdHRyaWJ1dGVzVG9HZW9tZXRyeSgpLCB0aGlzLmVtaXR0ZXJzLnB1c2goYSksIHRoaXMuZW1pdHRlcklEcy5wdXNoKGEudXVpZCksIHRoaXMuX3VwZGF0ZURlZmluZXMoYSksIHRoaXMubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSAhMCwgdGhpcy5nZW9tZXRyeS5uZWVkc1VwZGF0ZSA9ICEwLCB0aGlzLl9hdHRyaWJ1dGVzTmVlZFJlZnJlc2ggPSAhMCxcbiAgICB0aGlzXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLnJlbW92ZUVtaXR0ZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIgPSB0aGlzLmVtaXR0ZXJJRHMuaW5kZXhPZihhLnV1aWQpO1xuICAgIGlmIChhIGluc3RhbmNlb2YgU1BFLkVtaXR0ZXIgPT0gITEpXG4gICAgICAgIHJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJgZW1pdHRlcmAgYXJndW1lbnQgbXVzdCBiZSBpbnN0YW5jZSBvZiBTUEUuRW1pdHRlci4gV2FzIHByb3ZpZGVkIHdpdGg6XCIsIGEpO1xuICAgIGlmICgtMSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIkVtaXR0ZXIgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBncm91cC4gV2lsbCBub3QgcmVtb3ZlLlwiKTtcbiAgICBmb3IgKHZhciBjID0gYS5hdHRyaWJ1dGVPZmZzZXQsIGQgPSBjICsgYS5wYXJ0aWNsZUNvdW50LCBlID0gdGhpcy5hdHRyaWJ1dGVzLnBhcmFtcy50eXBlZEFycmF5LCBmID0gYzsgZCA+IGY7ICsrZilcbiAgICAgICAgZS5hcnJheVs0ICogZl0gPSAwLCBlLmFycmF5WzQgKiBmICsgMV0gPSAwO1xuICAgIHRoaXMuZW1pdHRlcnMuc3BsaWNlKGIsIDEpLCB0aGlzLmVtaXR0ZXJJRHMuc3BsaWNlKGIsIDEpO1xuICAgIGZvciAodmFyIGcgaW4gdGhpcy5hdHRyaWJ1dGVzKVxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoZykgJiYgdGhpcy5hdHRyaWJ1dGVzW2ddLnNwbGljZShjLCBkKTtcbiAgICB0aGlzLnBhcnRpY2xlQ291bnQgLT0gYS5wYXJ0aWNsZUNvdW50LCBhLl9vblJlbW92ZSgpLCB0aGlzLl9hdHRyaWJ1dGVzTmVlZFJlZnJlc2ggPSAhMFxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5nZXRGcm9tUG9vbCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhID0gdGhpcy5fcG9vbCxcbiAgICAgICAgYiA9IHRoaXMuX2NyZWF0ZU5ld1doZW5Qb29sRW1wdHk7XG4gICAgcmV0dXJuIGEubGVuZ3RoID8gYS5wb3AoKSA6IGIgPyBuZXcgU1BFLkVtaXR0ZXIodGhpcy5fcG9vbENyZWF0aW9uU2V0dGluZ3MpIDogbnVsbFxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5yZWxlYXNlSW50b1Bvb2wgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBTUEUuRW1pdHRlciA9PSAhMSA/IHZvaWQgY29uc29sZS5lcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBpbnN0YW5jZW9mIFNQRS5FbWl0dGVyOlwiLCBhKSA6IChhLnJlc2V0KCksXG4gICAgdGhpcy5fcG9vbC51bnNoaWZ0KGEpLCB0aGlzKVxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5nZXRQb29sID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuX3Bvb2xcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuYWRkUG9vbCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZDtcbiAgICB0aGlzLl9wb29sQ3JlYXRpb25TZXR0aW5ncyA9IGIsIHRoaXMuX2NyZWF0ZU5ld1doZW5Qb29sRW1wdHkgPSAhIWM7XG4gICAgZm9yICh2YXIgZSA9IDA7IGEgPiBlOyArK2UpXG4gICAgICAgIGQgPSBBcnJheS5pc0FycmF5KGIpID8gbmV3IFNQRS5FbWl0dGVyKGJbZV0pIDogbmV3IFNQRS5FbWl0dGVyKGIpLCB0aGlzLmFkZEVtaXR0ZXIoZCksIHRoaXMucmVsZWFzZUludG9Qb29sKGQpO1xuICAgIHJldHVybiB0aGlzXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLl90cmlnZ2VyU2luZ2xlRW1pdHRlciA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYiA9IHRoaXMuZ2V0RnJvbVBvb2woKSxcbiAgICAgICAgYyA9IHRoaXM7XG4gICAgcmV0dXJuIG51bGwgPT09IGIgPyB2b2lkIGNvbnNvbGUubG9nKFwiU1BFLkdyb3VwIHBvb2wgcmFuIG91dC5cIikgOiAoYSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgJiYgKGIucG9zaXRpb24udmFsdWUuY29weShhKSwgYi5wb3NpdGlvbi52YWx1ZSA9IGIucG9zaXRpb24udmFsdWUpLCBiLmVuYWJsZSgpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBiLmRpc2FibGUoKSwgYy5yZWxlYXNlSW50b1Bvb2woYilcbiAgICB9LCAxZTMgKiAoYi5tYXhBZ2UudmFsdWUgKyBiLm1heEFnZS5zcHJlYWQpKSwgdGhpcylcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUudHJpZ2dlclBvb2xFbWl0dGVyID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBhICYmIGEgPiAxKVxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYSA+IGM7ICsrYylcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJTaW5nbGVFbWl0dGVyKGIpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fdHJpZ2dlclNpbmdsZUVtaXR0ZXIoYik7XG4gICAgcmV0dXJuIHRoaXNcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVVuaWZvcm1zID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMudW5pZm9ybXMucnVuVGltZS52YWx1ZSArPSBhLFxuICAgIHRoaXMudW5pZm9ybXMuZGVsdGFUaW1lLnZhbHVlID0gYVxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5fcmVzZXRCdWZmZXJSYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYSA9IHRoaXMuYXR0cmlidXRlS2V5cyxcbiAgICAgICAgYiA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxLFxuICAgICAgICBjID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIGZvciAoYjsgYiA+PSAwOyAtLWIpXG4gICAgICAgIGNbYVtiXV0ucmVzZXRVcGRhdGVSYW5nZSgpXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLl91cGRhdGVCdWZmZXJzID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiLFxuICAgICAgICBjLFxuICAgICAgICBkLFxuICAgICAgICBlID0gdGhpcy5hdHRyaWJ1dGVLZXlzLFxuICAgICAgICBmID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDEsXG4gICAgICAgIGcgPSB0aGlzLmF0dHJpYnV0ZXMsXG4gICAgICAgIGggPSBhLmJ1ZmZlclVwZGF0ZVJhbmdlcztcbiAgICBmb3IgKGY7IGYgPj0gMDsgLS1mKVxuICAgICAgICBiID0gZVtmXSwgYyA9IGhbYl0sIGQgPSBnW2JdLCBkLnNldFVwZGF0ZVJhbmdlKGMubWluLCBjLm1heCksIGQuZmxhZ1VwZGF0ZSgpXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIsXG4gICAgICAgIGMgPSB0aGlzLmVtaXR0ZXJzLFxuICAgICAgICBkID0gYy5sZW5ndGgsXG4gICAgICAgIGUgPSBhIHx8IHRoaXMuZml4ZWRUaW1lU3RlcCxcbiAgICAgICAgZiA9IHRoaXMuYXR0cmlidXRlS2V5cyxcbiAgICAgICAgZyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBpZiAodGhpcy5fdXBkYXRlVW5pZm9ybXMoZSksIHRoaXMuX3Jlc2V0QnVmZmVyUmFuZ2VzKCksIDAgIT09IGQgfHwgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoICE9PSAhMSB8fCB0aGlzLl9hdHRyaWJ1dGVzTmVlZER5bmFtaWNSZXNldCAhPT0gITEpIHtcbiAgICAgICAgZm9yICh2YXIgaCwgYiA9IDA7IGQgPiBiOyArK2IpXG4gICAgICAgICAgICBoID0gY1tiXSwgaC50aWNrKGUpLCB0aGlzLl91cGRhdGVCdWZmZXJzKGgpO1xuICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgPT09ICEwKSB7XG4gICAgICAgICAgICBmb3IgKGIgPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMTsgYiA+PSAwOyAtLWIpXG4gICAgICAgICAgICAgICAgZ1tmW2JdXS5yZXNldER5bmFtaWMoKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNOZWVkRHluYW1pY1Jlc2V0ID0gITFcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID09PSAhMCkge1xuICAgICAgICAgICAgZm9yIChiID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDE7IGIgPj0gMDsgLS1iKVxuICAgICAgICAgICAgICAgIGdbZltiXV0uZm9yY2VVcGRhdGVBbGwoKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCA9ICExLCB0aGlzLl9hdHRyaWJ1dGVzTmVlZER5bmFtaWNSZXNldCA9ICEwXG4gICAgICAgIH1cbiAgICB9XG59LCBTUEUuR3JvdXAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCksIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpLCB0aGlzXG59LCBTUEUuRW1pdHRlciA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYiA9IFNQRS51dGlscyxcbiAgICAgICAgYyA9IGIudHlwZXMsXG4gICAgICAgIGQgPSBTUEUudmFsdWVPdmVyTGlmZXRpbWVMZW5ndGg7XG4gICAgYSA9IGIuZW5zdXJlVHlwZWRBcmcoYSwgYy5PQkpFQ1QsIHt9KSwgYS5wb3NpdGlvbiA9IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbiwgYy5PQkpFQ1QsIHt9KSwgYS52ZWxvY2l0eSA9IGIuZW5zdXJlVHlwZWRBcmcoYS52ZWxvY2l0eSwgYy5PQkpFQ1QsIHt9KSwgYS5hY2NlbGVyYXRpb24gPSBiLmVuc3VyZVR5cGVkQXJnKGEuYWNjZWxlcmF0aW9uLCBjLk9CSkVDVCwge30pLCBhLnJhZGl1cyA9IGIuZW5zdXJlVHlwZWRBcmcoYS5yYWRpdXMsIGMuT0JKRUNULCB7fSksIGEuZHJhZyA9IGIuZW5zdXJlVHlwZWRBcmcoYS5kcmFnLCBjLk9CSkVDVCwge30pLCBhLnJvdGF0aW9uID0gYi5lbnN1cmVUeXBlZEFyZyhhLnJvdGF0aW9uLCBjLk9CSkVDVCwge30pLCBhLmNvbG9yID0gYi5lbnN1cmVUeXBlZEFyZyhhLmNvbG9yLCBjLk9CSkVDVCwge30pLCBhLm9wYWNpdHkgPSBiLmVuc3VyZVR5cGVkQXJnKGEub3BhY2l0eSwgYy5PQkpFQ1QsIHt9KSwgYS5zaXplID0gYi5lbnN1cmVUeXBlZEFyZyhhLnNpemUsIGMuT0JKRUNULCB7fSksIGEuYW5nbGUgPSBiLmVuc3VyZVR5cGVkQXJnKGEuYW5nbGUsIGMuT0JKRUNULCB7fSksIGEud2lnZ2xlID0gYi5lbnN1cmVUeXBlZEFyZyhhLndpZ2dsZSwgYy5PQkpFQ1QsIHt9KSwgYS5tYXhBZ2UgPSBiLmVuc3VyZVR5cGVkQXJnKGEubWF4QWdlLCBjLk9CSkVDVCwge30pLCBhLm9uUGFydGljbGVTcGF3biAmJiBjb25zb2xlLndhcm4oXCJvblBhcnRpY2xlU3Bhd24gaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHNldCBwcm9wZXJ0aWVzIGRpcmVjdGx5IHRvIGFsdGVyIHZhbHVlcyBhdCBydW50aW1lLlwiKSxcbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpLCB0aGlzLnR5cGUgPSBiLmVuc3VyZVR5cGVkQXJnKGEudHlwZSwgYy5OVU1CRVIsIFNQRS5kaXN0cmlidXRpb25zLkJPWCksIHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVJbnN0YW5jZU9mKGEucG9zaXRpb24udmFsdWUsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVJbnN0YW5jZU9mKGEucG9zaXRpb24uc3ByZWFkLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9zcHJlYWRDbGFtcDogYi5lbnN1cmVJbnN0YW5jZU9mKGEucG9zaXRpb24uc3ByZWFkQ2xhbXAsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX2Rpc3RyaWJ1dGlvbjogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLmRpc3RyaWJ1dGlvbiwgYy5OVU1CRVIsIHRoaXMudHlwZSksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICBfcmFkaXVzOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFkaXVzLCBjLk5VTUJFUiwgMTApLFxuICAgICAgICBfcmFkaXVzU2NhbGU6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnBvc2l0aW9uLnNjYWxlLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMygxLCAxLCAxKSksXG4gICAgICAgIF9kaXN0cmlidXRpb25DbGFtcDogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLmRpc3RyaWJ1dGlvbkNsYW1wLCBjLk5VTUJFUiwgMClcbiAgICB9LCB0aGlzLnZlbG9jaXR5ID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnZlbG9jaXR5LnZhbHVlLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnZlbG9jaXR5LnNwcmVhZCwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfZGlzdHJpYnV0aW9uOiBiLmVuc3VyZVR5cGVkQXJnKGEudmVsb2NpdHkuZGlzdHJpYnV0aW9uLCBjLk5VTUJFUiwgdGhpcy50eXBlKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLmFjY2VsZXJhdGlvbiA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5hY2NlbGVyYXRpb24udmFsdWUsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVJbnN0YW5jZU9mKGEuYWNjZWxlcmF0aW9uLnNwcmVhZCwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfZGlzdHJpYnV0aW9uOiBiLmVuc3VyZVR5cGVkQXJnKGEuYWNjZWxlcmF0aW9uLmRpc3RyaWJ1dGlvbiwgYy5OVU1CRVIsIHRoaXMudHlwZSksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy5kcmFnID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlVHlwZWRBcmcoYS5kcmFnLnZhbHVlLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlVHlwZWRBcmcoYS5kcmFnLnNwcmVhZCwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMud2lnZ2xlID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlVHlwZWRBcmcoYS53aWdnbGUudmFsdWUsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVUeXBlZEFyZyhhLndpZ2dsZS5zcHJlYWQsIGMuTlVNQkVSLCAwKVxuICAgIH0sIHRoaXMucm90YXRpb24gPSB7XG4gICAgICAgIF9heGlzOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5yb3RhdGlvbi5heGlzLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSksXG4gICAgICAgIF9heGlzU3ByZWFkOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5yb3RhdGlvbi5heGlzU3ByZWFkLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9hbmdsZTogYi5lbnN1cmVUeXBlZEFyZyhhLnJvdGF0aW9uLmFuZ2xlLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9hbmdsZVNwcmVhZDogYi5lbnN1cmVUeXBlZEFyZyhhLnJvdGF0aW9uLmFuZ2xlU3ByZWFkLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9zdGF0aWM6IGIuZW5zdXJlVHlwZWRBcmcoYS5yb3RhdGlvbltcInN0YXRpY1wiXSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIF9jZW50ZXI6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnJvdGF0aW9uLmNlbnRlciwgVEhSRUUuVmVjdG9yMywgdGhpcy5wb3NpdGlvbi5fdmFsdWUuY2xvbmUoKSksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy5tYXhBZ2UgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVUeXBlZEFyZyhhLm1heEFnZS52YWx1ZSwgYy5OVU1CRVIsIDIpLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZVR5cGVkQXJnKGEubWF4QWdlLnNwcmVhZCwgYy5OVU1CRVIsIDApXG4gICAgfSwgdGhpcy5jb2xvciA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZUFycmF5SW5zdGFuY2VPZihhLmNvbG9yLnZhbHVlLCBUSFJFRS5Db2xvciwgbmV3IFRIUkVFLkNvbG9yKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVBcnJheUluc3RhbmNlT2YoYS5jb2xvci5zcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLm9wYWNpdHkgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVBcnJheVR5cGVkQXJnKGEub3BhY2l0eS52YWx1ZSwgYy5OVU1CRVIsIDEpLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZUFycmF5VHlwZWRBcmcoYS5vcGFjaXR5LnNwcmVhZCwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZUFycmF5VHlwZWRBcmcoYS5zaXplLnZhbHVlLCBjLk5VTUJFUiwgMSksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlQXJyYXlUeXBlZEFyZyhhLnNpemUuc3ByZWFkLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy5hbmdsZSA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZUFycmF5VHlwZWRBcmcoYS5hbmdsZS52YWx1ZSwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZUFycmF5VHlwZWRBcmcoYS5hbmdsZS5zcHJlYWQsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLnBhcnRpY2xlQ291bnQgPSBiLmVuc3VyZVR5cGVkQXJnKGEucGFydGljbGVDb3VudCwgYy5OVU1CRVIsIDEwMCksXG4gICAgdGhpcy5kdXJhdGlvbiA9IGIuZW5zdXJlVHlwZWRBcmcoYS5kdXJhdGlvbiwgYy5OVU1CRVIsIG51bGwpLCB0aGlzLmlzU3RhdGljID0gYi5lbnN1cmVUeXBlZEFyZyhhLmlzU3RhdGljLCBjLkJPT0xFQU4sICExKSwgdGhpcy5hY3RpdmVNdWx0aXBsaWVyID0gYi5lbnN1cmVUeXBlZEFyZyhhLmFjdGl2ZU11bHRpcGxpZXIsIGMuTlVNQkVSLCAxKSwgdGhpcy5kaXJlY3Rpb24gPSBiLmVuc3VyZVR5cGVkQXJnKGEuZGlyZWN0aW9uLCBjLk5VTUJFUiwgMSksIHRoaXMuYWxpdmUgPSBiLmVuc3VyZVR5cGVkQXJnKGEuYWxpdmUsIGMuQk9PTEVBTiwgITApLCB0aGlzLnBhcnRpY2xlc1BlclNlY29uZCA9IDAsIHRoaXMuYWN0aXZhdGlvbkluZGV4ID0gMCwgdGhpcy5hdHRyaWJ1dGVPZmZzZXQgPSAwLCB0aGlzLmF0dHJpYnV0ZUVuZCA9IDAsIHRoaXMuYWdlID0gMCwgdGhpcy5hY3RpdmVQYXJ0aWNsZUNvdW50ID0gMCwgdGhpcy5ncm91cCA9IG51bGwsIHRoaXMuYXR0cmlidXRlcyA9IG51bGwsIHRoaXMucGFyYW1zQXJyYXkgPSBudWxsLCB0aGlzLnJlc2V0RmxhZ3MgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSB8fCBiLmVuc3VyZVR5cGVkQXJnKGEucmFkaXVzLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIHZlbG9jaXR5OiBiLmVuc3VyZVR5cGVkQXJnKGEudmVsb2NpdHkucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgYWNjZWxlcmF0aW9uOiBiLmVuc3VyZVR5cGVkQXJnKGEuYWNjZWxlcmF0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSkgfHwgYi5lbnN1cmVUeXBlZEFyZyhhLmRyYWcucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgcm90YXRpb246IGIuZW5zdXJlVHlwZWRBcmcoYS5yb3RhdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICByb3RhdGlvbkNlbnRlcjogYi5lbnN1cmVUeXBlZEFyZyhhLnJvdGF0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIHNpemU6IGIuZW5zdXJlVHlwZWRBcmcoYS5zaXplLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIGNvbG9yOiBiLmVuc3VyZVR5cGVkQXJnKGEuY29sb3IucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgb3BhY2l0eTogYi5lbnN1cmVUeXBlZEFyZyhhLm9wYWNpdHkucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgYW5nbGU6IGIuZW5zdXJlVHlwZWRBcmcoYS5hbmdsZS5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy51cGRhdGVGbGFncyA9IHt9LCB0aGlzLnVwZGF0ZUNvdW50cyA9IHt9LCB0aGlzLnVwZGF0ZU1hcCA9IHtcbiAgICAgICAgbWF4QWdlOiBcInBhcmFtc1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJwb3NpdGlvblwiLFxuICAgICAgICB2ZWxvY2l0eTogXCJ2ZWxvY2l0eVwiLFxuICAgICAgICBhY2NlbGVyYXRpb246IFwiYWNjZWxlcmF0aW9uXCIsXG4gICAgICAgIGRyYWc6IFwiYWNjZWxlcmF0aW9uXCIsXG4gICAgICAgIHdpZ2dsZTogXCJwYXJhbXNcIixcbiAgICAgICAgcm90YXRpb246IFwicm90YXRpb25cIixcbiAgICAgICAgc2l6ZTogXCJzaXplXCIsXG4gICAgICAgIGNvbG9yOiBcImNvbG9yXCIsXG4gICAgICAgIG9wYWNpdHk6IFwib3BhY2l0eVwiLFxuICAgICAgICBhbmdsZTogXCJhbmdsZVwiXG4gICAgfTtcbiAgICBmb3IgKHZhciBlIGluIHRoaXMudXBkYXRlTWFwKVxuICAgICAgICB0aGlzLnVwZGF0ZU1hcC5oYXNPd25Qcm9wZXJ0eShlKSAmJiAodGhpcy51cGRhdGVDb3VudHNbdGhpcy51cGRhdGVNYXBbZV1dID0gMCwgdGhpcy51cGRhdGVGbGFnc1t0aGlzLnVwZGF0ZU1hcFtlXV0gPSAhMSwgdGhpcy5fY3JlYXRlR2V0dGVyU2V0dGVycyh0aGlzW2VdLCBlKSk7XG4gICAgdGhpcy5idWZmZXJVcGRhdGVSYW5nZXMgPSB7fSwgdGhpcy5hdHRyaWJ1dGVLZXlzID0gbnVsbCwgdGhpcy5hdHRyaWJ1dGVDb3VudCA9IDAsIGIuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKHRoaXMuY29sb3IsIGQsIGQpLCBiLmVuc3VyZVZhbHVlT3ZlckxpZmV0aW1lQ29tcGxpYW5jZSh0aGlzLm9wYWNpdHksIGQsIGQpLCBiLmVuc3VyZVZhbHVlT3ZlckxpZmV0aW1lQ29tcGxpYW5jZSh0aGlzLnNpemUsIGQsIGQpLCBiLmVuc3VyZVZhbHVlT3ZlckxpZmV0aW1lQ29tcGxpYW5jZSh0aGlzLmFuZ2xlLCBkLCBkKVxufSwgU1BFLkVtaXR0ZXIuY29uc3RydWN0b3IgPSBTUEUuRW1pdHRlciwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9jcmVhdGVHZXR0ZXJTZXR0ZXJzID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjID0gdGhpcztcbiAgICBmb3IgKHZhciBkIGluIGEpXG4gICAgICAgIGlmIChhLmhhc093blByb3BlcnR5KGQpKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGQucmVwbGFjZShcIl9cIiwgXCJcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgZSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1thXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfShkKSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gYy51cGRhdGVNYXBbYl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHRoaXNbYV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IFNQRS52YWx1ZU92ZXJMaWZldGltZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiX3JvdGF0aW9uQ2VudGVyXCIgPT09IGEgPyAoYy51cGRhdGVGbGFncy5yb3RhdGlvbkNlbnRlciA9ICEwLCBjLnVwZGF0ZUNvdW50cy5yb3RhdGlvbkNlbnRlciA9IDApIDogXCJfcmFuZG9taXNlXCIgPT09IGEgPyBjLnJlc2V0RmxhZ3NbZV0gPSBkIDogKGMudXBkYXRlRmxhZ3NbZV0gPSAhMCwgYy51cGRhdGVDb3VudHNbZV0gPSAwKSwgYy5ncm91cC5fdXBkYXRlRGVmaW5lcygpLCB0aGlzW2FdID0gZCwgQXJyYXkuaXNBcnJheShmKSAmJiBTUEUudXRpbHMuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKGNbYl0sIGcsIGcpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KGQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX3NldEJ1ZmZlclVwZGF0ZVJhbmdlcyA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLmF0dHJpYnV0ZUtleXMgPSBhLCB0aGlzLmF0dHJpYnV0ZUNvdW50ID0gYS5sZW5ndGg7XG4gICAgZm9yICh2YXIgYiA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxOyBiID49IDA7IC0tYilcbiAgICAgICAgdGhpcy5idWZmZXJVcGRhdGVSYW5nZXNbYVtiXV0gPSB7XG4gICAgICAgICAgICBtaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgIH1cbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlUFBTVmFsdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIgPSB0aGlzLnBhcnRpY2xlQ291bnQ7XG4gICAgdGhpcy5kdXJhdGlvbiA/IHRoaXMucGFydGljbGVzUGVyU2Vjb25kID0gYiAvIChhIDwgdGhpcy5kdXJhdGlvbiA/IGEgOiB0aGlzLmR1cmF0aW9uKSA6IHRoaXMucGFydGljbGVzUGVyU2Vjb25kID0gYiAvIGFcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fc2V0QXR0cmlidXRlT2Zmc2V0ID0gZnVuY3Rpb24oYSkge1xuICAgIHRoaXMuYXR0cmlidXRlT2Zmc2V0ID0gYSwgdGhpcy5hY3RpdmF0aW9uSW5kZXggPSBhLFxuICAgIHRoaXMuYWN0aXZhdGlvbkVuZCA9IGEgKyB0aGlzLnBhcnRpY2xlQ291bnRcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduVmFsdWUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgc3dpdGNoIChhKSB7XG4gICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgIHRoaXMuX2Fzc2lnblBvc2l0aW9uVmFsdWUoYik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ2ZWxvY2l0eVwiOlxuICAgIGNhc2UgXCJhY2NlbGVyYXRpb25cIjpcbiAgICAgICAgdGhpcy5fYXNzaWduRm9yY2VWYWx1ZShiLCBhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInNpemVcIjpcbiAgICBjYXNlIFwib3BhY2l0eVwiOlxuICAgICAgICB0aGlzLl9hc3NpZ25BYnNMaWZldGltZVZhbHVlKGIsIGEpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwiYW5nbGVcIjpcbiAgICAgICAgdGhpcy5fYXNzaWduQW5nbGVWYWx1ZShiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBhcmFtc1wiOlxuICAgICAgICB0aGlzLl9hc3NpZ25QYXJhbXNWYWx1ZShiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJvdGF0aW9uXCI6XG4gICAgICAgIHRoaXMuX2Fzc2lnblJvdGF0aW9uVmFsdWUoYik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICB0aGlzLl9hc3NpZ25Db2xvclZhbHVlKGIpXG4gICAgfVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25Qb3NpdGlvblZhbHVlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiID0gU1BFLmRpc3RyaWJ1dGlvbnMsXG4gICAgICAgIGMgPSBTUEUudXRpbHMsXG4gICAgICAgIGQgPSB0aGlzLnBvc2l0aW9uLFxuICAgICAgICBlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLFxuICAgICAgICBmID0gZC5fdmFsdWUsXG4gICAgICAgIGcgPSBkLl9zcHJlYWQsXG4gICAgICAgIGggPSBkLl9kaXN0cmlidXRpb247XG4gICAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSBiLkJPWDpcbiAgICAgICAgYy5yYW5kb21WZWN0b3IzKGUsIGEsIGYsIGcsIGQuX3NwcmVhZENsYW1wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBiLlNQSEVSRTpcbiAgICAgICAgYy5yYW5kb21WZWN0b3IzT25TcGhlcmUoZSwgYSwgZiwgZC5fcmFkaXVzLCBkLl9zcHJlYWQueCwgZC5fcmFkaXVzU2NhbGUsIGQuX3NwcmVhZENsYW1wLngsIGQuX2Rpc3RyaWJ1dGlvbkNsYW1wIHx8IHRoaXMucGFydGljbGVDb3VudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgYi5ESVNDOlxuICAgICAgICBjLnJhbmRvbVZlY3RvcjNPbkRpc2MoZSwgYSwgZiwgZC5fcmFkaXVzLCBkLl9zcHJlYWQueCwgZC5fcmFkaXVzU2NhbGUsIGQuX3NwcmVhZENsYW1wLngpXG4gICAgfVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25Gb3JjZVZhbHVlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjLFxuICAgICAgICBkLFxuICAgICAgICBlLFxuICAgICAgICBmLFxuICAgICAgICBnLFxuICAgICAgICBoID0gU1BFLmRpc3RyaWJ1dGlvbnMsXG4gICAgICAgIGkgPSBTUEUudXRpbHMsXG4gICAgICAgIGogPSB0aGlzW2JdLFxuICAgICAgICBrID0gai5fdmFsdWUsXG4gICAgICAgIGwgPSBqLl9zcHJlYWQsXG4gICAgICAgIG0gPSBqLl9kaXN0cmlidXRpb247XG4gICAgc3dpdGNoIChtKSB7XG4gICAgY2FzZSBoLkJPWDpcbiAgICAgICAgaS5yYW5kb21WZWN0b3IzKHRoaXMuYXR0cmlidXRlc1tiXSwgYSwgaywgbCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgaC5TUEhFUkU6XG4gICAgICAgIGMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24udHlwZWRBcnJheS5hcnJheSwgZyA9IDMgKiBhLCBkID0gY1tnXSwgZSA9IGNbZyArIDFdLCBmID0gY1tnICsgMl0sIGkucmFuZG9tRGlyZWN0aW9uVmVjdG9yM09uU3BoZXJlKHRoaXMuYXR0cmlidXRlc1tiXSwgYSwgZCwgZSwgZiwgdGhpcy5wb3NpdGlvbi5fdmFsdWUsIGouX3ZhbHVlLngsIGouX3NwcmVhZC54KTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBoLkRJU0M6XG4gICAgICAgIGMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24udHlwZWRBcnJheS5hcnJheSwgZyA9IDMgKiBhLCBkID0gY1tnXSwgZSA9IGNbZyArIDFdLCBmID0gY1tnICsgMl0sIGkucmFuZG9tRGlyZWN0aW9uVmVjdG9yM09uRGlzYyh0aGlzLmF0dHJpYnV0ZXNbYl0sIGEsIGQsIGUsIGYsIHRoaXMucG9zaXRpb24uX3ZhbHVlLCBqLl92YWx1ZS54LCBqLl9zcHJlYWQueClcbiAgICB9XG4gICAgaWYgKFwiYWNjZWxlcmF0aW9uXCIgPT09IGIpIHtcbiAgICAgICAgdmFyIG4gPSBpLmNsYW1wKGkucmFuZG9tRmxvYXQodGhpcy5kcmFnLl92YWx1ZSwgdGhpcy5kcmFnLl9zcHJlYWQpLCAwLCAxKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmFjY2VsZXJhdGlvbi50eXBlZEFycmF5LmFycmF5WzQgKiBhICsgM10gPSBuXG4gICAgfVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25BYnNMaWZldGltZVZhbHVlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjLFxuICAgICAgICBkID0gdGhpcy5hdHRyaWJ1dGVzW2JdLnR5cGVkQXJyYXksXG4gICAgICAgIGUgPSB0aGlzW2JdLFxuICAgICAgICBmID0gU1BFLnV0aWxzO1xuICAgIGYuYXJyYXlWYWx1ZXNBcmVFcXVhbChlLl92YWx1ZSkgJiYgZi5hcnJheVZhbHVlc0FyZUVxdWFsKGUuX3NwcmVhZCkgPyAoYyA9IE1hdGguYWJzKGYucmFuZG9tRmxvYXQoZS5fdmFsdWVbMF0sIGUuX3NwcmVhZFswXSkpLCBkLnNldFZlYzRDb21wb25lbnRzKGEsIGMsIGMsIGMsIGMpKSA6IGQuc2V0VmVjNENvbXBvbmVudHMoYSwgTWF0aC5hYnMoZi5yYW5kb21GbG9hdChlLl92YWx1ZVswXSwgZS5fc3ByZWFkWzBdKSksIE1hdGguYWJzKGYucmFuZG9tRmxvYXQoZS5fdmFsdWVbMV0sIGUuX3NwcmVhZFsxXSkpLCBNYXRoLmFicyhmLnJhbmRvbUZsb2F0KGUuX3ZhbHVlWzJdLCBlLl9zcHJlYWRbMl0pKSwgTWF0aC5hYnMoZi5yYW5kb21GbG9hdChlLl92YWx1ZVszXSwgZS5fc3ByZWFkWzNdKSkpO1xufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25BbmdsZVZhbHVlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiLFxuICAgICAgICBjID0gdGhpcy5hdHRyaWJ1dGVzLmFuZ2xlLnR5cGVkQXJyYXksXG4gICAgICAgIGQgPSB0aGlzLmFuZ2xlLFxuICAgICAgICBlID0gU1BFLnV0aWxzO1xuICAgIGUuYXJyYXlWYWx1ZXNBcmVFcXVhbChkLl92YWx1ZSkgJiYgZS5hcnJheVZhbHVlc0FyZUVxdWFsKGQuX3NwcmVhZCkgPyAoYiA9IGUucmFuZG9tRmxvYXQoZC5fdmFsdWVbMF0sIGQuX3NwcmVhZFswXSksIGMuc2V0VmVjNENvbXBvbmVudHMoYSwgYiwgYiwgYiwgYikpIDogYy5zZXRWZWM0Q29tcG9uZW50cyhhLCBlLnJhbmRvbUZsb2F0KGQuX3ZhbHVlWzBdLCBkLl9zcHJlYWRbMF0pLCBlLnJhbmRvbUZsb2F0KGQuX3ZhbHVlWzFdLCBkLl9zcHJlYWRbMV0pLCBlLnJhbmRvbUZsb2F0KGQuX3ZhbHVlWzJdLCBkLl9zcHJlYWRbMl0pLCBlLnJhbmRvbUZsb2F0KGQuX3ZhbHVlWzNdLCBkLl9zcHJlYWRbM10pKVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25QYXJhbXNWYWx1ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLmF0dHJpYnV0ZXMucGFyYW1zLnR5cGVkQXJyYXkuc2V0VmVjNENvbXBvbmVudHMoYSwgdGhpcy5pc1N0YXRpYyA/IDEgOiAwLCAwLCBNYXRoLmFicyhTUEUudXRpbHMucmFuZG9tRmxvYXQodGhpcy5tYXhBZ2UuX3ZhbHVlLCB0aGlzLm1heEFnZS5fc3ByZWFkKSksIFNQRS51dGlscy5yYW5kb21GbG9hdCh0aGlzLndpZ2dsZS5fdmFsdWUsIHRoaXMud2lnZ2xlLl9zcHJlYWQpKVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25Sb3RhdGlvblZhbHVlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMuYXR0cmlidXRlcy5yb3RhdGlvbi50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKGEsIFNQRS51dGlscy5nZXRQYWNrZWRSb3RhdGlvbkF4aXModGhpcy5yb3RhdGlvbi5fYXhpcywgdGhpcy5yb3RhdGlvbi5fYXhpc1NwcmVhZCksIFNQRS51dGlscy5yYW5kb21GbG9hdCh0aGlzLnJvdGF0aW9uLl9hbmdsZSwgdGhpcy5yb3RhdGlvbi5fYW5nbGVTcHJlYWQpLCB0aGlzLnJvdGF0aW9uLl9zdGF0aWMgPyAwIDogMSksXG4gICAgdGhpcy5hdHRyaWJ1dGVzLnJvdGF0aW9uQ2VudGVyLnR5cGVkQXJyYXkuc2V0VmVjMyhhLCB0aGlzLnJvdGF0aW9uLl9jZW50ZXIpXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnbkNvbG9yVmFsdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgU1BFLnV0aWxzLnJhbmRvbUNvbG9yQXNIZXgodGhpcy5hdHRyaWJ1dGVzLmNvbG9yLCBhLCB0aGlzLmNvbG9yLl92YWx1ZSwgdGhpcy5jb2xvci5fc3ByZWFkKVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9yZXNldFBhcnRpY2xlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZvciAodmFyIGIsIGMsIGQgPSB0aGlzLnJlc2V0RmxhZ3MsIGUgPSB0aGlzLnVwZGF0ZUZsYWdzLCBmID0gdGhpcy51cGRhdGVDb3VudHMsIGcgPSB0aGlzLmF0dHJpYnV0ZUtleXMsIGggPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMTsgaCA+PSAwOyAtLWgpXG4gICAgICAgIGIgPSBnW2hdLCBjID0gZVtiXSwgKGRbYl0gPT09ICEwIHx8IGMgPT09ICEwKSAmJiAodGhpcy5fYXNzaWduVmFsdWUoYiwgYSksIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZVVwZGF0ZVJhbmdlKGIsIGEpLCBjID09PSAhMCAmJiBmW2JdID09PSB0aGlzLnBhcnRpY2xlQ291bnQgPyAoZVtiXSA9ICExLCBmW2JdID0gMCkgOiAxID09IGMgJiYgKytmW2JdKVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl91cGRhdGVBdHRyaWJ1dGVVcGRhdGVSYW5nZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYyA9IHRoaXMuYnVmZmVyVXBkYXRlUmFuZ2VzW2FdO1xuICAgIGMubWluID0gTWF0aC5taW4oYiwgYy5taW4pLCBjLm1heCA9IE1hdGgubWF4KGIsIGMubWF4KVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9yZXNldEJ1ZmZlclJhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhLFxuICAgICAgICBiID0gdGhpcy5idWZmZXJVcGRhdGVSYW5nZXMsXG4gICAgICAgIGMgPSB0aGlzLmJ1ZmZlclVwZGF0ZUtleXMsXG4gICAgICAgIGQgPSB0aGlzLmJ1ZmZlclVwZGF0ZUNvdW50IC0gMTtcbiAgICBmb3IgKGQ7IGQgPj0gMDsgLS1kKVxuICAgICAgICBhID0gY1tkXSwgYlthXS5taW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGJbYV0ubWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX29uUmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5wYXJ0aWNsZXNQZXJTZWNvbmQgPSAwLCB0aGlzLmF0dHJpYnV0ZU9mZnNldCA9IDAsIHRoaXMuYWN0aXZhdGlvbkluZGV4ID0gMCwgdGhpcy5hY3RpdmVQYXJ0aWNsZUNvdW50ID0gMCwgdGhpcy5ncm91cCA9IG51bGwsIHRoaXMuYXR0cmlidXRlcyA9IG51bGwsIHRoaXMucGFyYW1zQXJyYXkgPSBudWxsLCB0aGlzLmFnZSA9IDBcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fZGVjcmVtZW50UGFydGljbGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC0tdGhpcy5hY3RpdmVQYXJ0aWNsZUNvdW50XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2luY3JlbWVudFBhcnRpY2xlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICArK3RoaXMuYWN0aXZlUGFydGljbGVDb3VudFxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9jaGVja1BhcnRpY2xlQWdlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmb3IgKHZhciBlLCBmLCBnLCBoLCBpID0gYiAtIDE7IGkgPj0gYTsgLS1pKVxuICAgICAgICBlID0gNCAqIGksIGggPSBjW2VdLCAwICE9PSBoICYmIChnID0gY1tlICsgMV0sIGYgPSBjW2UgKyAyXSwgMSA9PT0gdGhpcy5kaXJlY3Rpb24gPyAoZyArPSBkLCBnID49IGYgJiYgKGcgPSAwLCBoID0gMCwgdGhpcy5fZGVjcmVtZW50UGFydGljbGVDb3VudCgpKSkgOiAoZyAtPSBkLCAwID49IGcgJiYgKGcgPSBmLCBoID0gMCwgdGhpcy5fZGVjcmVtZW50UGFydGljbGVDb3VudCgpKSksIGNbZV0gPSBoLCBjW2UgKyAxXSA9IGcsIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZVVwZGF0ZVJhbmdlKFwicGFyYW1zXCIsIGkpKVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hY3RpdmF0ZVBhcnRpY2xlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmb3IgKHZhciBlLCBmLCBnID0gdGhpcy5kaXJlY3Rpb24sIGggPSBhOyBiID4gaDsgKytoKVxuICAgICAgICBlID0gNCAqIGgsICgwID09IGNbZV0gfHwgMSA9PT0gdGhpcy5wYXJ0aWNsZUNvdW50KSAmJiAodGhpcy5faW5jcmVtZW50UGFydGljbGVDb3VudCgpLCBjW2VdID0gMSwgdGhpcy5fcmVzZXRQYXJ0aWNsZShoKSwgZiA9IGQgKiAoaCAtIGEpLCBjW2UgKyAxXSA9IC0xID09PSBnID8gY1tlICsgMl0gLSBmIDogZiwgdGhpcy5fdXBkYXRlQXR0cmlidXRlVXBkYXRlUmFuZ2UoXCJwYXJhbXNcIiwgaCkpO1xufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKCF0aGlzLmlzU3RhdGljKSB7XG4gICAgICAgIG51bGwgPT09IHRoaXMucGFyYW1zQXJyYXkgJiYgKHRoaXMucGFyYW1zQXJyYXkgPSB0aGlzLmF0dHJpYnV0ZXMucGFyYW1zLnR5cGVkQXJyYXkuYXJyYXkpO1xuICAgICAgICB2YXIgYiA9IHRoaXMuYXR0cmlidXRlT2Zmc2V0LFxuICAgICAgICAgICAgYyA9IGIgKyB0aGlzLnBhcnRpY2xlQ291bnQsXG4gICAgICAgICAgICBkID0gdGhpcy5wYXJhbXNBcnJheSxcbiAgICAgICAgICAgIGUgPSB0aGlzLnBhcnRpY2xlc1BlclNlY29uZCAqIHRoaXMuYWN0aXZlTXVsdGlwbGllciAqIGEsXG4gICAgICAgICAgICBmID0gdGhpcy5hY3RpdmF0aW9uSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLl9yZXNldEJ1ZmZlclJhbmdlcygpLCB0aGlzLl9jaGVja1BhcnRpY2xlQWdlcyhiLCBjLCBkLCBhKSwgdGhpcy5hbGl2ZSA9PT0gITEpXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAodGhpcy5hZ2UgPSAwKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHRoaXMuZHVyYXRpb24gJiYgdGhpcy5hZ2UgPiB0aGlzLmR1cmF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpdmUgPSAhMSwgdm9pZCAodGhpcy5hZ2UgPSAwKTtcbiAgICAgICAgdmFyIGcgPSAxID09PSB0aGlzLnBhcnRpY2xlQ291bnQgPyBmIDogMCB8IGYsXG4gICAgICAgICAgICBoID0gTWF0aC5taW4oZyArIGUsIHRoaXMuYWN0aXZhdGlvbkVuZCksXG4gICAgICAgICAgICBpID0gaCAtIHRoaXMuYWN0aXZhdGlvbkluZGV4IHwgMCxcbiAgICAgICAgICAgIGogPSBpID4gMCA/IGEgLyBpIDogMDtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGVQYXJ0aWNsZXMoZywgaCwgZCwgaiksIHRoaXMuYWN0aXZhdGlvbkluZGV4ICs9IGUsIHRoaXMuYWN0aXZhdGlvbkluZGV4ID4gYyAmJiAodGhpcy5hY3RpdmF0aW9uSW5kZXggPSBiKSwgdGhpcy5hZ2UgKz0gYVxuICAgIH1cbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodGhpcy5hZ2UgPSAwLCB0aGlzLmFsaXZlID0gITEsIGEgPT09ICEwKSB7XG4gICAgICAgIGZvciAodmFyIGIsIGMgPSB0aGlzLmF0dHJpYnV0ZU9mZnNldCwgZCA9IGMgKyB0aGlzLnBhcnRpY2xlQ291bnQsIGUgPSB0aGlzLnBhcmFtc0FycmF5LCBmID0gdGhpcy5hdHRyaWJ1dGVzLnBhcmFtcy5idWZmZXJBdHRyaWJ1dGUsIGcgPSBkIC0gMTsgZyA+PSBjOyAtLWcpXG4gICAgICAgICAgICBiID0gNCAqIGcsIGVbYl0gPSAwLCBlW2IgKyAxXSA9IDA7XG4gICAgICAgIGYudXBkYXRlUmFuZ2Uub2Zmc2V0ID0gMCwgZi51cGRhdGVSYW5nZS5jb3VudCA9IC0xLFxuICAgICAgICBmLm5lZWRzVXBkYXRlID0gITBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5hbGl2ZSA9ICEwLCB0aGlzXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLmFsaXZlID0gITEsIHRoaXNcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gbnVsbCAhPT0gdGhpcy5ncm91cCA/IHRoaXMuZ3JvdXAucmVtb3ZlRW1pdHRlcih0aGlzKSA6IGNvbnNvbGUuZXJyb3IoXCJFbWl0dGVyIGRvZXMgbm90IGJlbG9uZyB0byBhIGdyb3VwLCBjYW5ub3QgcmVtb3ZlLlwiKSwgdGhpc1xufTtcbiIsIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBS0FBO0FEQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FEanlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBRDMyb0NBLElBQUEsZ0RBQUE7RUFBQTs7O0FBQU07OztFQUVRLG1CQUFDLE9BQUQ7O01BQUMsVUFBUTs7SUFDckIsSUFBQyxDQUFBLFVBQUQsR0FBYztJQUNkLElBQUMsQ0FBQSxnQkFBRCxHQUFvQjs7TUFDcEIsT0FBTyxDQUFDLGtCQUFzQixPQUFPLENBQUMsS0FBWCxHQUFzQix3QkFBdEIsR0FBb0Q7OztNQUMvRSxPQUFPLENBQUMsUUFBUzs7O01BQ2pCLE9BQU8sQ0FBQyxhQUFjOzs7TUFDdEIsT0FBTyxDQUFDLGFBQWM7OztNQUN0QixPQUFPLENBQUMsV0FBWTs7O01BQ3BCLE9BQU8sQ0FBQyxPQUFROztJQUNoQiwyQ0FBTSxPQUFOO0lBQ0EsSUFBQyxDQUFBLEtBQUssQ0FBQyxVQUFQLEdBQW9CO0lBQ3BCLElBQUMsQ0FBQSxLQUFLLENBQUMsT0FBUCxHQUFpQjtFQVhMOztzQkFhYixRQUFBLEdBQVUsU0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixRQUFsQjs7TUFBa0IsV0FBVzs7SUFDdEMsSUFBQyxDQUFBLEtBQU0sQ0FBQSxRQUFBLENBQVAsR0FBc0IsUUFBSCxHQUFpQixLQUFBLEdBQU0sSUFBdkIsR0FBaUM7SUFDcEQsSUFBQyxDQUFBLElBQUQsQ0FBTSxTQUFBLEdBQVUsUUFBaEIsRUFBNEIsS0FBNUI7SUFDQSxJQUFHLElBQUMsQ0FBQSxVQUFKO2FBQW9CLElBQUMsQ0FBQSxRQUFELENBQUEsRUFBcEI7O0VBSFM7O3NCQUtWLFFBQUEsR0FBVSxTQUFBO0FBQ1QsUUFBQTtJQUFBLG1CQUFBLEdBQ0M7TUFBQSxVQUFBLEVBQVksSUFBQyxDQUFBLEtBQU0sQ0FBQSxhQUFBLENBQW5CO01BQ0EsUUFBQSxFQUFVLElBQUMsQ0FBQSxLQUFNLENBQUEsV0FBQSxDQURqQjtNQUVBLFVBQUEsRUFBWSxJQUFDLENBQUEsS0FBTSxDQUFBLGFBQUEsQ0FGbkI7TUFHQSxVQUFBLEVBQVksSUFBQyxDQUFBLEtBQU0sQ0FBQSxhQUFBLENBSG5CO01BSUEsWUFBQSxFQUFjLElBQUMsQ0FBQSxLQUFNLENBQUEsZUFBQSxDQUpyQjtNQUtBLGFBQUEsRUFBZSxJQUFDLENBQUEsS0FBTSxDQUFBLGdCQUFBLENBTHRCO01BTUEsV0FBQSxFQUFhLElBQUMsQ0FBQSxLQUFNLENBQUEsY0FBQSxDQU5wQjtNQU9BLGFBQUEsRUFBZSxJQUFDLENBQUEsS0FBTSxDQUFBLGdCQUFBLENBUHRCO01BUUEsV0FBQSxFQUFhLElBQUMsQ0FBQSxLQUFNLENBQUEsY0FBQSxDQVJwQjtNQVNBLGFBQUEsRUFBZSxJQUFDLENBQUEsS0FBTSxDQUFBLGdCQUFBLENBVHRCO01BVUEsVUFBQSxFQUFZLElBQUMsQ0FBQSxLQUFNLENBQUEsYUFBQSxDQVZuQjtNQVdBLFNBQUEsRUFBVyxJQUFDLENBQUEsS0FBTSxDQUFBLFlBQUEsQ0FYbEI7TUFZQSxXQUFBLEVBQWEsSUFBQyxDQUFBLEtBQU0sQ0FBQSxjQUFBLENBWnBCOztJQWFELFdBQUEsR0FBYztJQUNkLElBQUcsSUFBQyxDQUFBLGdCQUFKO01BQTBCLFdBQVcsQ0FBQyxLQUFaLEdBQW9CLElBQUMsQ0FBQSxNQUEvQzs7SUFDQSxJQUFBLEdBQU8sS0FBSyxDQUFDLFFBQU4sQ0FBZSxJQUFDLENBQUEsSUFBaEIsRUFBc0IsbUJBQXRCLEVBQTJDLFdBQTNDO0lBQ1AsSUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDLFNBQVAsS0FBb0IsT0FBdkI7TUFDQyxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUksQ0FBQztNQUNkLElBQUMsQ0FBQSxDQUFELEdBQUssSUFBQyxDQUFBLENBQUQsR0FBRyxJQUFDLENBQUEsTUFGVjtLQUFBLE1BQUE7TUFJQyxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUksQ0FBQyxNQUpmOztXQUtBLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBSSxDQUFDO0VBdkJOOztFQXlCVixTQUFDLENBQUEsTUFBRCxDQUFRLFVBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBO0lBQUosQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7TUFDSixJQUFDLENBQUEsVUFBRCxHQUFjO01BQ2QsSUFBRyxJQUFDLENBQUEsVUFBSjtlQUFvQixJQUFDLENBQUEsUUFBRCxDQUFBLEVBQXBCOztJQUZJLENBREw7R0FERDs7RUFLQSxTQUFDLENBQUEsTUFBRCxDQUFRLGdCQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQyxLQUFEO01BQ0osSUFBQyxDQUFBLFVBQUQsR0FBYztNQUNkLElBQUMsQ0FBQSxnQkFBRCxHQUFvQjtNQUNwQixJQUFHLElBQUMsQ0FBQSxVQUFKO2VBQW9CLElBQUMsQ0FBQSxRQUFELENBQUEsRUFBcEI7O0lBSEksQ0FBTDtHQUREOztFQUtBLFNBQUMsQ0FBQSxNQUFELENBQVEsaUJBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFDLE9BQUQ7TUFDSixJQUFDLENBQUEsUUFBUSxDQUFDLGVBQVYsR0FBNEI7TUFDNUIsSUFBQyxDQUFBLFlBQUQsR0FBZ0IsQ0FBQzthQUNqQixJQUFDLENBQUEsRUFBRCxDQUFJLE9BQUosRUFBYSxTQUFBO1FBQUcsSUFBZSxJQUFDLENBQUEsVUFBaEI7aUJBQUEsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQUFBOztNQUFILENBQWI7SUFISSxDQUFMO0dBREQ7O0VBS0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxNQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxRQUFRLENBQUM7SUFBYixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDtNQUNKLElBQUMsQ0FBQSxRQUFRLENBQUMsV0FBVixHQUF3QjtNQUN4QixJQUFDLENBQUEsSUFBRCxDQUFNLGFBQU4sRUFBcUIsS0FBckI7TUFDQSxJQUFHLElBQUMsQ0FBQSxVQUFKO2VBQW9CLElBQUMsQ0FBQSxRQUFELENBQUEsRUFBcEI7O0lBSEksQ0FETDtHQUREOztFQU1BLFNBQUMsQ0FBQSxNQUFELENBQVEsWUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDO0lBQVYsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLFlBQVYsRUFBd0IsS0FBeEI7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxVQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQWhCLENBQXdCLElBQXhCLEVBQTZCLEVBQTdCO0lBQUgsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLFVBQVYsRUFBc0IsS0FBdEIsRUFBNkIsSUFBN0I7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxZQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFBVixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsWUFBVixFQUF3QixLQUF4QjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLFlBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQztJQUFWLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxZQUFWLEVBQXdCLEtBQXhCO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsV0FBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDO0lBQVYsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLFdBQVYsRUFBdUIsS0FBdkI7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxhQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFBVixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsYUFBVixFQUF5QixLQUF6QjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLFNBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7TUFDSixJQUFDLENBQUEsUUFBRCxDQUFVLFlBQVYsRUFBd0IsS0FBeEIsRUFBK0IsSUFBL0I7TUFDQSxJQUFDLENBQUEsUUFBRCxDQUFVLGNBQVYsRUFBMEIsS0FBMUIsRUFBaUMsSUFBakM7TUFDQSxJQUFDLENBQUEsUUFBRCxDQUFVLGVBQVYsRUFBMkIsS0FBM0IsRUFBa0MsSUFBbEM7YUFDQSxJQUFDLENBQUEsUUFBRCxDQUFVLGFBQVYsRUFBeUIsS0FBekIsRUFBZ0MsSUFBaEM7SUFKSSxDQUFMO0dBREQ7O0VBTUEsU0FBQyxDQUFBLE1BQUQsQ0FBUSxZQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQWxCLENBQTBCLElBQTFCLEVBQStCLEVBQS9CO0lBQUgsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLFlBQVYsRUFBd0IsS0FBeEIsRUFBK0IsSUFBL0I7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxjQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsWUFBWSxDQUFDLE9BQXBCLENBQTRCLElBQTVCLEVBQWlDLEVBQWpDO0lBQUgsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLGNBQVYsRUFBMEIsS0FBMUIsRUFBaUMsSUFBakM7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxlQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQXJCLENBQTZCLElBQTdCLEVBQWtDLEVBQWxDO0lBQUgsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLGVBQVYsRUFBMkIsS0FBM0IsRUFBa0MsSUFBbEM7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxhQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsV0FBVyxDQUFDLE9BQW5CLENBQTJCLElBQTNCLEVBQWdDLEVBQWhDO0lBQUgsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLGFBQVYsRUFBeUIsS0FBekIsRUFBZ0MsSUFBaEM7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxXQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxXQUFWLEVBQXVCLEtBQXZCO0lBQVgsQ0FBTDtHQUREOztFQUVBLFNBQUMsQ0FBQSxNQUFELENBQVEsZUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDO0lBQVYsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLGVBQVYsRUFBMkIsS0FBM0I7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxlQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQXJCLENBQTZCLElBQTdCLEVBQWtDLEVBQWxDO0lBQUgsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLGVBQVYsRUFBMkIsS0FBM0IsRUFBa0MsSUFBbEM7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxRQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxJQUFJLENBQUM7SUFBVCxDQUFMO0dBREQ7Ozs7R0E5R3VCOztBQWlIeEIsa0JBQUEsR0FBcUIsU0FBQyxLQUFELEVBQVEsS0FBUjtBQUdwQixNQUFBO0VBQUEsQ0FBQSxHQUFRLElBQUEsU0FBQSxDQUNQO0lBQUEsSUFBQSxFQUFNLEtBQUssQ0FBQyxJQUFaO0lBQ0EsS0FBQSxFQUFPLEtBQUssQ0FBQyxLQURiO0lBRUEsTUFBQSxFQUFRLEtBQUssQ0FBQyxNQUZkO0lBR0EsSUFBQSxFQUFNLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BSDNCO0dBRE87RUFPUixRQUFBLEdBQVc7RUFHWCxHQUFBLEdBQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUM7RUFHM0IsR0FBRyxDQUFDLE9BQUosQ0FBWSxTQUFDLElBQUQ7QUFHWCxRQUFBO0lBQUEsSUFBVSxDQUFDLENBQUMsUUFBRixDQUFXLElBQVgsRUFBaUIsSUFBakIsQ0FBVjtBQUFBLGFBQUE7O0lBR0EsR0FBQSxHQUFNLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBWDtJQUdOLElBQUEsR0FBTyxDQUFDLENBQUMsU0FBRixDQUFZLEdBQUksQ0FBQSxDQUFBLENBQWhCO0lBQ1AsS0FBQSxHQUFRLEdBQUksQ0FBQSxDQUFBLENBQUUsQ0FBQyxPQUFQLENBQWUsR0FBZixFQUFtQixFQUFuQjtJQUdSLElBQUcsQ0FBQyxVQUFELEVBQVksZUFBWixFQUE0QixZQUE1QixDQUF5QyxDQUFDLE9BQTFDLENBQWtELElBQWxELENBQUEsR0FBMEQsQ0FBQyxDQUE5RDtNQUNDLEtBQUEsR0FBUSxRQUFBLENBQVMsS0FBVCxFQURUOztXQUlBLFFBQVMsQ0FBQSxJQUFBLENBQVQsR0FBaUI7RUFqQk4sQ0FBWjtFQW9CQSxJQUFHLFFBQVEsQ0FBQyxjQUFULENBQXdCLFlBQXhCLENBQUg7SUFDQyxRQUFTLENBQUEsWUFBQSxDQUFULEdBQTBCLFFBQVEsQ0FBQyxVQUFULEdBQXNCLFFBQVEsQ0FBQyxTQUQxRDtHQUFBLE1BQUE7SUFHQyxRQUFTLENBQUEsWUFBQSxDQUFULEdBQXlCLElBSDFCOztBQVNBLE9BQUEsZUFBQTs7SUFDQyxDQUFFLENBQUEsR0FBQSxDQUFGLEdBQVM7QUFEVjtFQUlBLENBQUMsQ0FBQyxDQUFGLElBQU8sQ0FBQyxDQUFDLENBQUMsUUFBRixHQUFhLENBQUMsQ0FBQyxVQUFoQixDQUFBLEdBQThCLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQyxVQUFQO0VBQ3JDLENBQUMsQ0FBQyxDQUFGLElBQU8sQ0FBQyxDQUFDLFFBQUYsR0FBYTtFQUNwQixDQUFDLENBQUMsS0FBRixJQUFXLENBQUMsQ0FBQyxRQUFGLEdBQWE7RUFJeEIsSUFBRyxLQUFIO0lBQWMsS0FBSyxDQUFDLE9BQU4sR0FBZ0IsR0FBOUI7R0FBQSxNQUFBO0lBQXNDLEtBQUssQ0FBQyxPQUFOLENBQUEsRUFBdEM7O0FBRUEsU0FBTztBQXpEYTs7QUEyRHJCLEtBQUssQ0FBQSxTQUFFLENBQUEsa0JBQVAsR0FBNEIsU0FBQyxLQUFEO1NBQVcsa0JBQUEsQ0FBbUIsSUFBbkIsRUFBc0IsS0FBdEI7QUFBWDs7QUFFNUIsaUJBQUEsR0FBb0IsU0FBQyxHQUFELEVBQU0sS0FBTjtBQUNuQixNQUFBO0FBQUE7T0FBQSxXQUFBOztJQUNDLElBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFaLEtBQW9CLE1BQXZCO21CQUNDLEdBQUksQ0FBQSxJQUFBLENBQUosR0FBWSxrQkFBQSxDQUFtQixLQUFuQixFQUEwQixLQUExQixHQURiO0tBQUEsTUFBQTsyQkFBQTs7QUFERDs7QUFEbUI7O0FBT3BCLEtBQUssQ0FBQSxTQUFFLENBQUEsZ0JBQVAsR0FBMEIsU0FBQyxVQUFEO0FBQ3RCLE1BQUE7RUFBQSxDQUFBLEdBQUksSUFBSTtFQUNSLENBQUMsQ0FBQyxLQUFGLEdBQVUsSUFBQyxDQUFBO0VBQ1gsQ0FBQyxDQUFDLFVBQUYsR0FBZSxJQUFDLENBQUE7RUFDaEIsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxDQUFULEVBQVcsVUFBWDtFQUNBLElBQUMsQ0FBQSxPQUFELENBQUE7U0FDQTtBQU5zQjs7QUFRMUIsT0FBTyxDQUFDLFNBQVIsR0FBb0I7O0FBQ3BCLE9BQU8sQ0FBQyxpQkFBUixHQUE0Qjs7OztBRC9MNUI7QUFDQTs7QURHQSxPQUFPLENBQUMsS0FBUixHQUFnQjs7QUFFaEIsT0FBTyxDQUFDLFVBQVIsR0FBcUIsU0FBQTtTQUNwQixLQUFBLENBQU0sdUJBQU47QUFEb0I7O0FBR3JCLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQIn0=
