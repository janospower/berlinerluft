require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"SPE-min":[function(require,module,exports){
/* shader-particle-engine 1.0.0
 * 
 * (c) 2015 Luke Moody (http://www.github.com/squarefeet)
 *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).
 *
 * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)
 */
var SPE = {
    distributions: {
        BOX: 1,
        SPHERE: 2,
        DISC: 3
    },
    valueOverLifetimeLength: 4
};
"function" == typeof define && define.amd ? define("spe", SPE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = SPE), SPE.TypedArrayHelper = function(a, b, c, d) {
    "use strict";
    this.componentSize = c || 1, this.size = b || 1, this.TypedArrayConstructor = a || Float32Array, this.array = new a(b * this.componentSize), this.indexOffset = d || 0
}, SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper, SPE.TypedArrayHelper.prototype.setSize = function(a, b) {
    "use strict";
    var c = this.array.length;
    return b || (a *= this.componentSize), c > a ? this.shrink(a) : a > c ? this.grow(a) : void console.info("TypedArray is already of size:", a + ".", "Will not resize.")
}, SPE.TypedArrayHelper.prototype.shrink = function(a) {
    "use strict";
    return this.array = this.array.subarray(0, a), this.size = a, this
}, SPE.TypedArrayHelper.prototype.grow = function(a) {
    "use strict";
    var b = this.array,
        c = new this.TypedArrayConstructor(a);
    return c.set(b), this.array = c, this.size = a, this
}, SPE.TypedArrayHelper.prototype.splice = function(a, b) {
    "use strict";
    a *= this.componentSize, b *= this.componentSize;
    for (var c = [], d = this.array, e = d.length, f = 0; e > f; ++f)
        (a > f || f >= b) && c.push(d[f]);
    return this.setFromArray(0, c), this
}, SPE.TypedArrayHelper.prototype.setFromArray = function(a, b) {
    "use strict";
    var c = b.length,
        d = a + c;
    return d > this.array.length ? this.grow(d) : d < this.array.length && this.shrink(d), this.array.set(b, this.indexOffset + a), this
}, SPE.TypedArrayHelper.prototype.setVec2 = function(a, b) {
    "use strict";
    return this.setVec2Components(a, b.x, b.y)
}, SPE.TypedArrayHelper.prototype.setVec2Components = function(a, b, c) {
    "use strict";
    var d = this.array,
        e = this.indexOffset + a * this.componentSize;
    return d[e] = b, d[e + 1] = c, this
}, SPE.TypedArrayHelper.prototype.setVec3 = function(a, b) {
    "use strict";
    return this.setVec3Components(a, b.x, b.y, b.z)
}, SPE.TypedArrayHelper.prototype.setVec3Components = function(a, b, c, d) {
    "use strict";
    var e = this.array,
        f = this.indexOffset + a * this.componentSize;
    return e[f] = b, e[f + 1] = c, e[f + 2] = d, this
}, SPE.TypedArrayHelper.prototype.setVec4 = function(a, b) {
    "use strict";
    return this.setVec4Components(a, b.x, b.y, b.z, b.w)
}, SPE.TypedArrayHelper.prototype.setVec4Components = function(a, b, c, d, e) {
    "use strict";
    var f = this.array,
        g = this.indexOffset + a * this.componentSize;
    return f[g] = b, f[g + 1] = c, f[g + 2] = d, f[g + 3] = e, this
}, SPE.TypedArrayHelper.prototype.setMat3 = function(a, b) {
    "use strict";
    return this.setFromArray(this.indexOffset + a * this.componentSize, b.elements)
}, SPE.TypedArrayHelper.prototype.setMat4 = function(a, b) {
    "use strict";
    return this.setFromArray(this.indexOffset + a * this.componentSize, b.elements)
}, SPE.TypedArrayHelper.prototype.setColor = function(a, b) {
    "use strict";
    return this.setVec3Components(a, b.r, b.g, b.b)
}, SPE.TypedArrayHelper.prototype.setNumber = function(a, b) {
    "use strict";
    return this.array[this.indexOffset + a * this.componentSize] = b, this
}, SPE.TypedArrayHelper.prototype.getValueAtIndex = function(a) {
    "use strict";
    return this.array[this.indexOffset + a]
}, SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(a) {
    "use strict";
    return this.array.subarray(this.indexOffset + a * this.componentSize);
}, SPE.ShaderAttribute = function(a, b, c) {
    "use strict";
    var d = SPE.ShaderAttribute.typeSizeMap;
    this.type = "string" == typeof a && d.hasOwnProperty(a) ? a : "f", this.componentSize = d[this.type], this.arrayType = c || Float32Array, this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!b, this.updateMin = 0, this.updateMax = 0
}, SPE.ShaderAttribute.constructor = SPE.ShaderAttribute, SPE.ShaderAttribute.typeSizeMap = {
    f: 1,
    v2: 2,
    v3: 3,
    v4: 4,
    c: 3,
    m3: 9,
    m4: 16
}, SPE.ShaderAttribute.prototype.setUpdateRange = function(a, b) {
    "use strict";
    this.updateMin = Math.min(a * this.componentSize, this.updateMin * this.componentSize), this.updateMax = Math.max(b * this.componentSize, this.updateMax * this.componentSize)
}, SPE.ShaderAttribute.prototype.flagUpdate = function() {
    "use strict";
    var a = this.bufferAttribute,
        b = a.updateRange;
    b.offset = this.updateMin, b.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), a.needsUpdate = !0
}, SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
    "use strict";
    this.updateMin = 0, this.updateMax = 0;
}, SPE.ShaderAttribute.prototype.resetDynamic = function() {
    "use strict";
    this.bufferAttribute.dynamic = this.dynamicBuffer
}, SPE.ShaderAttribute.prototype.splice = function(a, b) {
    "use strict";
    this.typedArray.splice(a, b), this.forceUpdateAll()
}, SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
    "use strict";
    this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.dynamic = !1, this.bufferAttribute.needsUpdate = !0
}, SPE.ShaderAttribute.prototype._ensureTypedArray = function(a) {
    "use strict";
    (null === this.typedArray || this.typedArray.size !== a * this.componentSize) && (null !== this.typedArray && this.typedArray.size !== a ? this.typedArray.setSize(a) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, a, this.componentSize)))
}, SPE.ShaderAttribute.prototype._createBufferAttribute = function(a) {
    "use strict";
    return this._ensureTypedArray(a), null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array,
    void (this.bufferAttribute.needsUpdate = !0)) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), void (this.bufferAttribute.dynamic = this.dynamicBuffer))
}, SPE.ShaderAttribute.prototype.getLength = function() {
    "use strict";
    return null === this.typedArray ? 0 : this.typedArray.array.length
}, SPE.shaderChunks = {
    defines: ["#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0"].join("\n"),
    uniforms: ["uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D texture;", "uniform vec4 textureAnimation;", "uniform float scale;"].join("\n"),
    attributes: ["attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;"].join("\n"),
    varyings: ["varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif"].join("\n"),
    branchAvoidanceFunctions: ["float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}"].join("\n"),
    unpackColor: ["vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}"].join("\n"),
    floatOverLifetime: ["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}"].join("\n"),
    colorOverLifetime: ["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}"].join("\n"),
    paramFetchingFunctions: ["float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}"].join("\n"),
    forceFetchingFunctions: ["vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}"].join("\n"),
    rotationFunctions: ["#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      vec3 axis = unpackColor( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = pos - rotationCenter;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return vec3( rotationMatrix * vec4( translated, 0.0 ) ) - center;", "   }", "#endif"].join("\n"),
    rotateTexture: ["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( texture, vUv );"].join("\n")
}, SPE.shaders = {
    vertex: [SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPos.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPos;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragment: [SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", THREE.ShaderChunk.fog_fragment, "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", "}"].join("\n")
}, SPE.utils = {
    types: {
        BOOLEAN: "boolean",
        STRING: "string",
        NUMBER: "number",
        OBJECT: "object"
    },
    ensureTypedArg: function(a, b, c) {
        "use strict";
        return typeof a === b ? a : c
    },
    ensureArrayTypedArg: function(a, b, c) {
        "use strict";
        if (Array.isArray(a)) {
            for (var d = a.length - 1; d >= 0; --d)
                if (typeof a[d] !== b)
                    return c;
            return a
        }
        return this.ensureTypedArg(a, b, c)
    },
    ensureInstanceOf: function(a, b, c) {
        "use strict";
        return void 0 !== b && a instanceof b ? a : c;
    },
    ensureArrayInstanceOf: function(a, b, c) {
        "use strict";
        if (Array.isArray(a)) {
            for (var d = a.length - 1; d >= 0; --d)
                if (void 0 !== b && a[d] instanceof b == !1)
                    return c;
            return a
        }
        return this.ensureInstanceOf(a, b, c)
    },
    ensureValueOverLifetimeCompliance: function(a, b, c) {
        "use strict";
        b = b || 3, c = c || 3, Array.isArray(a._value) === !1 && (a._value = [a._value]), Array.isArray(a._spread) === !1 && (a._spread = [a._spread]);
        var d = this.clamp(a._value.length, b, c),
            e = this.clamp(a._spread.length, b, c),
            f = Math.max(d, e);
        a._value.length !== f && (a._value = this.interpolateArray(a._value, f)), a._spread.length !== f && (a._spread = this.interpolateArray(a._spread, f))
    },
    interpolateArray: function(a, b) {
        "use strict";
        for (var c = a.length, d = ["function" == typeof a[0].clone ? a[0].clone() : a[0]], e = (c - 1) / (b - 1), f = 1; b - 1 > f; ++f) {
            var g = f * e,
                h = Math.floor(g),
                i = Math.ceil(g),
                j = g - h;
            d[f] = this.lerpTypeAgnostic(a[h], a[i], j)
        }
        return d.push("function" == typeof a[c - 1].clone ? a[c - 1].clone() : a[c - 1]), d
    },
    clamp: function(a, b, c) {
        "use strict";
        return Math.max(b, Math.min(a, c))
    },
    zeroToEpsilon: function(a, b) {
        "use strict";
        var c = 1e-5,
            d = a;
        return d = b ? Math.random() * c * 10 : c, 0 > a && a > -c && (d = -d), d
    },
    lerpTypeAgnostic: function(a, b, c) {
        "use strict";
        var d,
            e = this.types;
        return typeof a === e.NUMBER && typeof b === e.NUMBER ? a + (b - a) * c : a instanceof THREE.Vector2 && b instanceof THREE.Vector2 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d) : a instanceof THREE.Vector3 && b instanceof THREE.Vector3 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d.z = this.lerp(a.z, b.z, c), d) : a instanceof THREE.Vector4 && b instanceof THREE.Vector4 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d.z = this.lerp(a.z, b.z, c), d.w = this.lerp(a.w, b.w, c), d) : a instanceof THREE.Color && b instanceof THREE.Color ? (d = a.clone(), d.r = this.lerp(a.r, b.r, c), d.g = this.lerp(a.g, b.g, c), d.b = this.lerp(a.b, b.b, c), d) : void console.warn("Invalid argument types, or argument types do not match:", a, b)
    },
    lerp: function(a, b, c) {
        "use strict";
        return a + (b - a) * c
    },
    roundToNearestMultiple: function(a, b) {
        "use strict";
        var c = 0;
        return 0 === b ? a : (c = Math.abs(a) % b,
        0 === c ? a : 0 > a ? -(Math.abs(a) - c) : a + b - c)
    },
    arrayValuesAreEqual: function(a) {
        "use strict";
        for (var b = 0; b < a.length - 1; ++b)
            if (a[b] !== a[b + 1])
                return !1;
        return !0
    },
    randomFloat: function(a, b) {
        "use strict";
        return a + b * (Math.random() - .5)
    },
    randomVector3: function(a, b, c, d, e) {
        "use strict";
        var f = c.x + (Math.random() * d.x - .5 * d.x),
            g = c.y + (Math.random() * d.y - .5 * d.y),
            h = c.z + (Math.random() * d.z - .5 * d.z);
        e && (f = .5 * -e.x + this.roundToNearestMultiple(f, e.x), g = .5 * -e.y + this.roundToNearestMultiple(g, e.y), h = .5 * -e.z + this.roundToNearestMultiple(h, e.z)), a.typedArray.setVec3Components(b, f, g, h)
    },
    randomColor: function(a, b, c, d) {
        "use strict";
        var e = c.r + Math.random() * d.x,
            f = c.g + Math.random() * d.y,
            g = c.b + Math.random() * d.z;
        e = this.clamp(e, 0, 1), f = this.clamp(f, 0, 1), g = this.clamp(g, 0, 1), a.typedArray.setVec3Components(b, e, f, g)
    },
    randomColorAsHex: function() {
        "use strict";
        var a = new THREE.Color;
        return function(b, c, d, e) {
            for (var f = d.length, g = [], h = 0; f > h; ++h) {
                var i = e[h];
                a.copy(d[h]), a.r += Math.random() * i.x - .5 * i.x, a.g += Math.random() * i.y - .5 * i.y, a.b += Math.random() * i.z - .5 * i.z,
                a.r = this.clamp(a.r, 0, 1), a.g = this.clamp(a.g, 0, 1), a.b = this.clamp(a.b, 0, 1), g.push(a.getHex())
            }
            b.typedArray.setVec4Components(c, g[0], g[1], g[2], g[3])
        }
    }(),
    randomVector3OnSphere: function(a, b, c, d, e, f, g, h) {
        "use strict";
        var i = 2 * Math.random() - 1,
            j = 6.2832 * Math.random(),
            k = Math.sqrt(1 - i * i),
            l = this.randomFloat(d, e),
            m = 0,
            n = 0,
            o = 0;
        g && (l = Math.round(l / g) * g), m = k * Math.cos(j) * l, n = k * Math.sin(j) * l, o = i * l, m *= f.x, n *= f.y, o *= f.z, m += c.x, n += c.y, o += c.z, a.typedArray.setVec3Components(b, m, n, o)
    },
    seededRandom: function(a) {
        var b = 1e4 * Math.sin(a);
        return b - (0 | b)
    },
    randomVector3OnDisc: function(a, b, c, d, e, f, g) {
        "use strict";
        var h = 6.2832 * Math.random(),
            i = Math.abs(this.randomFloat(d, e)),
            j = 0,
            k = 0,
            l = 0;
        g && (i = Math.round(i / g) * g), j = Math.cos(h) * i, k = Math.sin(h) * i, j *= f.x, k *= f.y, j += c.x, k += c.y, l += c.z, a.typedArray.setVec3Components(b, j, k, l)
    },
    randomDirectionVector3OnSphere: function() {
        "use strict";
        var a = new THREE.Vector3;
        return function(b, c, d, e, f, g, h, i) {
            a.copy(g), a.x -= d, a.y -= e, a.z -= f, a.normalize().multiplyScalar(-this.randomFloat(h, i)), b.typedArray.setVec3Components(c, a.x, a.y, a.z);
        }
    }(),
    randomDirectionVector3OnDisc: function() {
        "use strict";
        var a = new THREE.Vector3;
        return function(b, c, d, e, f, g, h, i) {
            a.copy(g), a.x -= d, a.y -= e, a.z -= f, a.normalize().multiplyScalar(-this.randomFloat(h, i)), b.typedArray.setVec3Components(c, a.x, a.y, 0)
        }
    }(),
    getPackedRotationAxis: function() {
        "use strict";
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Color;
        return function(d, e) {
            return a.copy(d).normalize(), b.copy(e).normalize(), a.x += .5 * -e.x + Math.random() * e.x, a.y += .5 * -e.y + Math.random() * e.y, a.z += .5 * -e.z + Math.random() * e.z, a.x = Math.abs(a.x), a.y = Math.abs(a.y), a.z = Math.abs(a.z), a.normalize(), c.setRGB(a.x, a.y, a.z), c.getHex()
        }
    }()
}, SPE.Group = function(a) {
    "use strict";
    var b = SPE.utils,
        c = b.types;
    a = b.ensureTypedArg(a, c.OBJECT, {}), a.texture = b.ensureTypedArg(a.texture, c.OBJECT, {}), this.uuid = THREE.Math.generateUUID(), this.fixedTimeStep = b.ensureTypedArg(a.fixedTimeStep, c.NUMBER, .016), this.texture = b.ensureInstanceOf(a.texture.value, THREE.Texture, null), this.textureFrames = b.ensureInstanceOf(a.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1)),
    this.textureFrameCount = b.ensureTypedArg(a.texture.frameCount, c.NUMBER, this.textureFrames.x * this.textureFrames.y), this.textureLoop = b.ensureTypedArg(a.texture.loop, c.NUMBER, 1), this.textureFrames.max(new THREE.Vector2(1, 1)), this.hasPerspective = b.ensureTypedArg(a.hasPerspective, c.BOOLEAN, !0), this.colorize = b.ensureTypedArg(a.colorize, c.BOOLEAN, !0), this.maxParticleCount = b.ensureTypedArg(a.maxParticleCount, c.NUMBER, null), this.blending = b.ensureTypedArg(a.blending, c.NUMBER, THREE.AdditiveBlending), this.transparent = b.ensureTypedArg(a.transparent, c.BOOLEAN, !0), this.alphaTest = parseFloat(b.ensureTypedArg(a.alphaTest, c.NUMBER, 0)), this.depthWrite = b.ensureTypedArg(a.depthWrite, c.BOOLEAN, !1), this.depthTest = b.ensureTypedArg(a.depthTest, c.BOOLEAN, !0), this.fog = b.ensureTypedArg(a.fog, c.BOOLEAN, !0), this.scale = b.ensureTypedArg(a.scale, c.NUMBER, 300), this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !1,
    this.particleCount = 0, this.uniforms = {
        texture: {
            type: "t",
            value: this.texture
        },
        textureAnimation: {
            type: "v4",
            value: new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))
        },
        fogColor: {
            type: "c",
            value: null
        },
        fogNear: {
            type: "f",
            value: 10
        },
        fogFar: {
            type: "f",
            value: 200
        },
        fogDensity: {
            type: "f",
            value: .5
        },
        deltaTime: {
            type: "f",
            value: 0
        },
        runTime: {
            type: "f",
            value: 0
        },
        scale: {
            type: "f",
            value: this.scale
        }
    }, this.defines = {
        HAS_PERSPECTIVE: this.hasPerspective,
        COLORIZE: this.colorize,
        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,
        SHOULD_ROTATE_TEXTURE: !1,
        SHOULD_ROTATE_PARTICLES: !1,
        SHOULD_WIGGLE_PARTICLES: !1,
        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
    }, this.attributes = {
        position: new SPE.ShaderAttribute("v3", !0),
        acceleration: new SPE.ShaderAttribute("v4", !0),
        velocity: new SPE.ShaderAttribute("v3", !0),
        rotation: new SPE.ShaderAttribute("v4", !0),
        rotationCenter: new SPE.ShaderAttribute("v3", !0),
        params: new SPE.ShaderAttribute("v4", !0),
        size: new SPE.ShaderAttribute("v4", !0),
        angle: new SPE.ShaderAttribute("v4", !0),
        color: new SPE.ShaderAttribute("v4", !0),
        opacity: new SPE.ShaderAttribute("v4", !0)
    }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: SPE.shaders.vertex,
        fragmentShader: SPE.shaders.fragment,
        blending: this.blending,
        transparent: this.transparent,
        alphaTest: this.alphaTest,
        depthWrite: this.depthWrite,
        depthTest: this.depthTest,
        defines: this.defines,
        fog: this.fog
    }), this.geometry = new THREE.BufferGeometry, this.mesh = new THREE.Points(this.geometry, this.material), null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.")
}, SPE.Group.constructor = SPE.Group, SPE.Group.prototype._updateDefines = function() {
    "use strict";
    var a,
        b = this.emitters,
        c = b.length - 1,
        d = this.defines;
    for (c; c >= 0; --c)
        a = b[c], d.SHOULD_CALCULATE_SPRITE || (d.SHOULD_ROTATE_TEXTURE = d.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, a.angle.value), Math.max.apply(null, a.angle.spread))),
        d.SHOULD_ROTATE_PARTICLES = d.SHOULD_ROTATE_PARTICLES || !!Math.max(a.rotation.angle, a.rotation.angleSpread), d.SHOULD_WIGGLE_PARTICLES = d.SHOULD_WIGGLE_PARTICLES || !!Math.max(a.wiggle.value, a.wiggle.spread);
    this.material.needsUpdate = !0
}, SPE.Group.prototype._applyAttributesToGeometry = function() {
    "use strict";
    var a,
        b,
        c = this.attributes,
        d = this.geometry,
        e = d.attributes;
    for (var f in c)
        c.hasOwnProperty(f) && (a = c[f], b = e[f], b ? b.array = a.typedArray.array : d.addAttribute(f, a.bufferAttribute), a.bufferAttribute.needsUpdate = !0);
    this.geometry.setDrawRange(0, this.particleCount)
}, SPE.Group.prototype.addEmitter = function(a) {
    "use strict";
    if (a instanceof SPE.Emitter == !1)
        return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
    if (this.emitterIDs.indexOf(a.uuid) > -1)
        return void console.error("Emitter already exists in this group. Will not add again.");
    if (null !== a.group)
        return void console.error("Emitter already belongs to another group. Will not add to requested group.");
    var b = this.attributes,
        c = this.particleCount,
        d = c + a.particleCount;
    this.particleCount = d, null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), a._calculatePPSValue(a.maxAge._value + a.maxAge._spread), a._setBufferUpdateRanges(this.attributeKeys), a._setAttributeOffset(c), a.group = this, a.attributes = this.attributes;
    for (var e in b)
        b.hasOwnProperty(e) && b[e]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
    for (var f = c; d > f; ++f)
        a._assignPositionValue(f), a._assignForceValue(f, "velocity"), a._assignForceValue(f, "acceleration"), a._assignAbsLifetimeValue(f, "opacity"), a._assignAbsLifetimeValue(f, "size"), a._assignAngleValue(f), a._assignRotationValue(f), a._assignParamsValue(f), a._assignColorValue(f);
    return this._applyAttributesToGeometry(), this.emitters.push(a), this.emitterIDs.push(a.uuid), this._updateDefines(a), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0,
    this
}, SPE.Group.prototype.removeEmitter = function(a) {
    "use strict";
    var b = this.emitterIDs.indexOf(a.uuid);
    if (a instanceof SPE.Emitter == !1)
        return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
    if (-1 === b)
        return void console.error("Emitter does not exist in this group. Will not remove.");
    for (var c = a.attributeOffset, d = c + a.particleCount, e = this.attributes.params.typedArray, f = c; d > f; ++f)
        e.array[4 * f] = 0, e.array[4 * f + 1] = 0;
    this.emitters.splice(b, 1), this.emitterIDs.splice(b, 1);
    for (var g in this.attributes)
        this.attributes.hasOwnProperty(g) && this.attributes[g].splice(c, d);
    this.particleCount -= a.particleCount, a._onRemove(), this._attributesNeedRefresh = !0
}, SPE.Group.prototype.getFromPool = function() {
    "use strict";
    var a = this._pool,
        b = this._createNewWhenPoolEmpty;
    return a.length ? a.pop() : b ? new SPE.Emitter(this._poolCreationSettings) : null
}, SPE.Group.prototype.releaseIntoPool = function(a) {
    "use strict";
    return a instanceof SPE.Emitter == !1 ? void console.error("Argument is not instanceof SPE.Emitter:", a) : (a.reset(),
    this._pool.unshift(a), this)
}, SPE.Group.prototype.getPool = function() {
    "use strict";
    return this._pool
}, SPE.Group.prototype.addPool = function(a, b, c) {
    "use strict";
    var d;
    this._poolCreationSettings = b, this._createNewWhenPoolEmpty = !!c;
    for (var e = 0; a > e; ++e)
        d = Array.isArray(b) ? new SPE.Emitter(b[e]) : new SPE.Emitter(b), this.addEmitter(d), this.releaseIntoPool(d);
    return this
}, SPE.Group.prototype._triggerSingleEmitter = function(a) {
    "use strict";
    var b = this.getFromPool(),
        c = this;
    return null === b ? void console.log("SPE.Group pool ran out.") : (a instanceof THREE.Vector3 && (b.position.value.copy(a), b.position.value = b.position.value), b.enable(), setTimeout(function() {
        b.disable(), c.releaseIntoPool(b)
    }, 1e3 * (b.maxAge.value + b.maxAge.spread)), this)
}, SPE.Group.prototype.triggerPoolEmitter = function(a, b) {
    "use strict";
    if ("number" == typeof a && a > 1)
        for (var c = 0; a > c; ++c)
            this._triggerSingleEmitter(b);
    else
        this._triggerSingleEmitter(b);
    return this
}, SPE.Group.prototype._updateUniforms = function(a) {
    "use strict";
    this.uniforms.runTime.value += a,
    this.uniforms.deltaTime.value = a
}, SPE.Group.prototype._resetBufferRanges = function() {
    "use strict";
    var a = this.attributeKeys,
        b = this.attributeCount - 1,
        c = this.attributes;
    for (b; b >= 0; --b)
        c[a[b]].resetUpdateRange()
}, SPE.Group.prototype._updateBuffers = function(a) {
    "use strict";
    var b,
        c,
        d,
        e = this.attributeKeys,
        f = this.attributeCount - 1,
        g = this.attributes,
        h = a.bufferUpdateRanges;
    for (f; f >= 0; --f)
        b = e[f], c = h[b], d = g[b], d.setUpdateRange(c.min, c.max), d.flagUpdate()
}, SPE.Group.prototype.tick = function(a) {
    "use strict";
    var b,
        c = this.emitters,
        d = c.length,
        e = a || this.fixedTimeStep,
        f = this.attributeKeys,
        g = this.attributes;
    if (this._updateUniforms(e), this._resetBufferRanges(), 0 !== d || this._attributesNeedRefresh !== !1 || this._attributesNeedDynamicReset !== !1) {
        for (var h, b = 0; d > b; ++b)
            h = c[b], h.tick(e), this._updateBuffers(h);
        if (this._attributesNeedDynamicReset === !0) {
            for (b = this.attributeCount - 1; b >= 0; --b)
                g[f[b]].resetDynamic();
            this._attributesNeedDynamicReset = !1
        }
        if (this._attributesNeedRefresh === !0) {
            for (b = this.attributeCount - 1; b >= 0; --b)
                g[f[b]].forceUpdateAll();
            this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !0
        }
    }
}, SPE.Group.prototype.dispose = function() {
    "use strict";
    return this.geometry.dispose(), this.material.dispose(), this
}, SPE.Emitter = function(a) {
    "use strict";
    var b = SPE.utils,
        c = b.types,
        d = SPE.valueOverLifetimeLength;
    a = b.ensureTypedArg(a, c.OBJECT, {}), a.position = b.ensureTypedArg(a.position, c.OBJECT, {}), a.velocity = b.ensureTypedArg(a.velocity, c.OBJECT, {}), a.acceleration = b.ensureTypedArg(a.acceleration, c.OBJECT, {}), a.radius = b.ensureTypedArg(a.radius, c.OBJECT, {}), a.drag = b.ensureTypedArg(a.drag, c.OBJECT, {}), a.rotation = b.ensureTypedArg(a.rotation, c.OBJECT, {}), a.color = b.ensureTypedArg(a.color, c.OBJECT, {}), a.opacity = b.ensureTypedArg(a.opacity, c.OBJECT, {}), a.size = b.ensureTypedArg(a.size, c.OBJECT, {}), a.angle = b.ensureTypedArg(a.angle, c.OBJECT, {}), a.wiggle = b.ensureTypedArg(a.wiggle, c.OBJECT, {}), a.maxAge = b.ensureTypedArg(a.maxAge, c.OBJECT, {}), a.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."),
    this.uuid = THREE.Math.generateUUID(), this.type = b.ensureTypedArg(a.type, c.NUMBER, SPE.distributions.BOX), this.position = {
        _value: b.ensureInstanceOf(a.position.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.position.spread, THREE.Vector3, new THREE.Vector3),
        _spreadClamp: b.ensureInstanceOf(a.position.spreadClamp, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.position.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1),
        _radius: b.ensureTypedArg(a.position.radius, c.NUMBER, 10),
        _radiusScale: b.ensureInstanceOf(a.position.scale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),
        _distributionClamp: b.ensureTypedArg(a.position.distributionClamp, c.NUMBER, 0)
    }, this.velocity = {
        _value: b.ensureInstanceOf(a.velocity.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.velocity.spread, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.velocity.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.acceleration = {
        _value: b.ensureInstanceOf(a.acceleration.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.acceleration.spread, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.acceleration.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.drag = {
        _value: b.ensureTypedArg(a.drag.value, c.NUMBER, 0),
        _spread: b.ensureTypedArg(a.drag.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.wiggle = {
        _value: b.ensureTypedArg(a.wiggle.value, c.NUMBER, 0),
        _spread: b.ensureTypedArg(a.wiggle.spread, c.NUMBER, 0)
    }, this.rotation = {
        _axis: b.ensureInstanceOf(a.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)),
        _axisSpread: b.ensureInstanceOf(a.rotation.axisSpread, THREE.Vector3, new THREE.Vector3),
        _angle: b.ensureTypedArg(a.rotation.angle, c.NUMBER, 0),
        _angleSpread: b.ensureTypedArg(a.rotation.angleSpread, c.NUMBER, 0),
        _static: b.ensureTypedArg(a.rotation["static"], c.BOOLEAN, !1),
        _center: b.ensureInstanceOf(a.rotation.center, THREE.Vector3, this.position._value.clone()),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.maxAge = {
        _value: b.ensureTypedArg(a.maxAge.value, c.NUMBER, 2),
        _spread: b.ensureTypedArg(a.maxAge.spread, c.NUMBER, 0)
    }, this.color = {
        _value: b.ensureArrayInstanceOf(a.color.value, THREE.Color, new THREE.Color),
        _spread: b.ensureArrayInstanceOf(a.color.spread, THREE.Vector3, new THREE.Vector3),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.opacity = {
        _value: b.ensureArrayTypedArg(a.opacity.value, c.NUMBER, 1),
        _spread: b.ensureArrayTypedArg(a.opacity.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.size = {
        _value: b.ensureArrayTypedArg(a.size.value, c.NUMBER, 1),
        _spread: b.ensureArrayTypedArg(a.size.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.angle = {
        _value: b.ensureArrayTypedArg(a.angle.value, c.NUMBER, 0),
        _spread: b.ensureArrayTypedArg(a.angle.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.particleCount = b.ensureTypedArg(a.particleCount, c.NUMBER, 100),
    this.duration = b.ensureTypedArg(a.duration, c.NUMBER, null), this.isStatic = b.ensureTypedArg(a.isStatic, c.BOOLEAN, !1), this.activeMultiplier = b.ensureTypedArg(a.activeMultiplier, c.NUMBER, 1), this.direction = b.ensureTypedArg(a.direction, c.NUMBER, 1), this.alive = b.ensureTypedArg(a.alive, c.BOOLEAN, !0), this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.resetFlags = {
        position: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1) || b.ensureTypedArg(a.radius.randomise, c.BOOLEAN, !1),
        velocity: b.ensureTypedArg(a.velocity.randomise, c.BOOLEAN, !1),
        acceleration: b.ensureTypedArg(a.acceleration.randomise, c.BOOLEAN, !1) || b.ensureTypedArg(a.drag.randomise, c.BOOLEAN, !1),
        rotation: b.ensureTypedArg(a.rotation.randomise, c.BOOLEAN, !1),
        rotationCenter: b.ensureTypedArg(a.rotation.randomise, c.BOOLEAN, !1),
        size: b.ensureTypedArg(a.size.randomise, c.BOOLEAN, !1),
        color: b.ensureTypedArg(a.color.randomise, c.BOOLEAN, !1),
        opacity: b.ensureTypedArg(a.opacity.randomise, c.BOOLEAN, !1),
        angle: b.ensureTypedArg(a.angle.randomise, c.BOOLEAN, !1)
    }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = {
        maxAge: "params",
        position: "position",
        velocity: "velocity",
        acceleration: "acceleration",
        drag: "acceleration",
        wiggle: "params",
        rotation: "rotation",
        size: "size",
        color: "color",
        opacity: "opacity",
        angle: "angle"
    };
    for (var e in this.updateMap)
        this.updateMap.hasOwnProperty(e) && (this.updateCounts[this.updateMap[e]] = 0, this.updateFlags[this.updateMap[e]] = !1, this._createGetterSetters(this[e], e));
    this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, b.ensureValueOverLifetimeCompliance(this.color, d, d), b.ensureValueOverLifetimeCompliance(this.opacity, d, d), b.ensureValueOverLifetimeCompliance(this.size, d, d), b.ensureValueOverLifetimeCompliance(this.angle, d, d)
}, SPE.Emitter.constructor = SPE.Emitter, SPE.Emitter.prototype._createGetterSetters = function(a, b) {
    "use strict";
    var c = this;
    for (var d in a)
        if (a.hasOwnProperty(d)) {
            var e = d.replace("_", "");
            Object.defineProperty(a, e, {
                get: function(a) {
                    return function() {
                        return this[a]
                    }
                }(d),
                set: function(a) {
                    return function(d) {
                        var e = c.updateMap[b],
                            f = this[a],
                            g = SPE.valueOverLifetimeLength;
                        "_rotationCenter" === a ? (c.updateFlags.rotationCenter = !0, c.updateCounts.rotationCenter = 0) : "_randomise" === a ? c.resetFlags[e] = d : (c.updateFlags[e] = !0, c.updateCounts[e] = 0), c.group._updateDefines(), this[a] = d, Array.isArray(f) && SPE.utils.ensureValueOverLifetimeCompliance(c[b], g, g)
                    }
                }(d)
            })
        }
}, SPE.Emitter.prototype._setBufferUpdateRanges = function(a) {
    "use strict";
    this.attributeKeys = a, this.attributeCount = a.length;
    for (var b = this.attributeCount - 1; b >= 0; --b)
        this.bufferUpdateRanges[a[b]] = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        }
}, SPE.Emitter.prototype._calculatePPSValue = function(a) {
    "use strict";
    var b = this.particleCount;
    this.duration ? this.particlesPerSecond = b / (a < this.duration ? a : this.duration) : this.particlesPerSecond = b / a
}, SPE.Emitter.prototype._setAttributeOffset = function(a) {
    this.attributeOffset = a, this.activationIndex = a,
    this.activationEnd = a + this.particleCount
}, SPE.Emitter.prototype._assignValue = function(a, b) {
    "use strict";
    switch (a) {
    case "position":
        this._assignPositionValue(b);
        break;
    case "velocity":
    case "acceleration":
        this._assignForceValue(b, a);
        break;
    case "size":
    case "opacity":
        this._assignAbsLifetimeValue(b, a);
        break;
    case "angle":
        this._assignAngleValue(b);
        break;
    case "params":
        this._assignParamsValue(b);
        break;
    case "rotation":
        this._assignRotationValue(b);
        break;
    case "color":
        this._assignColorValue(b)
    }
}, SPE.Emitter.prototype._assignPositionValue = function(a) {
    "use strict";
    var b = SPE.distributions,
        c = SPE.utils,
        d = this.position,
        e = this.attributes.position,
        f = d._value,
        g = d._spread,
        h = d._distribution;
    switch (h) {
    case b.BOX:
        c.randomVector3(e, a, f, g, d._spreadClamp);
        break;
    case b.SPHERE:
        c.randomVector3OnSphere(e, a, f, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x, d._distributionClamp || this.particleCount);
        break;
    case b.DISC:
        c.randomVector3OnDisc(e, a, f, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x)
    }
}, SPE.Emitter.prototype._assignForceValue = function(a, b) {
    "use strict";
    var c,
        d,
        e,
        f,
        g,
        h = SPE.distributions,
        i = SPE.utils,
        j = this[b],
        k = j._value,
        l = j._spread,
        m = j._distribution;
    switch (m) {
    case h.BOX:
        i.randomVector3(this.attributes[b], a, k, l);
        break;
    case h.SPHERE:
        c = this.attributes.position.typedArray.array, g = 3 * a, d = c[g], e = c[g + 1], f = c[g + 2], i.randomDirectionVector3OnSphere(this.attributes[b], a, d, e, f, this.position._value, j._value.x, j._spread.x);
        break;
    case h.DISC:
        c = this.attributes.position.typedArray.array, g = 3 * a, d = c[g], e = c[g + 1], f = c[g + 2], i.randomDirectionVector3OnDisc(this.attributes[b], a, d, e, f, this.position._value, j._value.x, j._spread.x)
    }
    if ("acceleration" === b) {
        var n = i.clamp(i.randomFloat(this.drag._value, this.drag._spread), 0, 1);
        this.attributes.acceleration.typedArray.array[4 * a + 3] = n
    }
}, SPE.Emitter.prototype._assignAbsLifetimeValue = function(a, b) {
    "use strict";
    var c,
        d = this.attributes[b].typedArray,
        e = this[b],
        f = SPE.utils;
    f.arrayValuesAreEqual(e._value) && f.arrayValuesAreEqual(e._spread) ? (c = Math.abs(f.randomFloat(e._value[0], e._spread[0])), d.setVec4Components(a, c, c, c, c)) : d.setVec4Components(a, Math.abs(f.randomFloat(e._value[0], e._spread[0])), Math.abs(f.randomFloat(e._value[1], e._spread[1])), Math.abs(f.randomFloat(e._value[2], e._spread[2])), Math.abs(f.randomFloat(e._value[3], e._spread[3])));
}, SPE.Emitter.prototype._assignAngleValue = function(a) {
    "use strict";
    var b,
        c = this.attributes.angle.typedArray,
        d = this.angle,
        e = SPE.utils;
    e.arrayValuesAreEqual(d._value) && e.arrayValuesAreEqual(d._spread) ? (b = e.randomFloat(d._value[0], d._spread[0]), c.setVec4Components(a, b, b, b, b)) : c.setVec4Components(a, e.randomFloat(d._value[0], d._spread[0]), e.randomFloat(d._value[1], d._spread[1]), e.randomFloat(d._value[2], d._spread[2]), e.randomFloat(d._value[3], d._spread[3]))
}, SPE.Emitter.prototype._assignParamsValue = function(a) {
    "use strict";
    this.attributes.params.typedArray.setVec4Components(a, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread))
}, SPE.Emitter.prototype._assignRotationValue = function(a) {
    "use strict";
    this.attributes.rotation.typedArray.setVec3Components(a, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1),
    this.attributes.rotationCenter.typedArray.setVec3(a, this.rotation._center)
}, SPE.Emitter.prototype._assignColorValue = function(a) {
    "use strict";
    SPE.utils.randomColorAsHex(this.attributes.color, a, this.color._value, this.color._spread)
}, SPE.Emitter.prototype._resetParticle = function(a) {
    "use strict";
    for (var b, c, d = this.resetFlags, e = this.updateFlags, f = this.updateCounts, g = this.attributeKeys, h = this.attributeCount - 1; h >= 0; --h)
        b = g[h], c = e[b], (d[b] === !0 || c === !0) && (this._assignValue(b, a), this._updateAttributeUpdateRange(b, a), c === !0 && f[b] === this.particleCount ? (e[b] = !1, f[b] = 0) : 1 == c && ++f[b])
}, SPE.Emitter.prototype._updateAttributeUpdateRange = function(a, b) {
    "use strict";
    var c = this.bufferUpdateRanges[a];
    c.min = Math.min(b, c.min), c.max = Math.max(b, c.max)
}, SPE.Emitter.prototype._resetBufferRanges = function() {
    "use strict";
    var a,
        b = this.bufferUpdateRanges,
        c = this.bufferUpdateKeys,
        d = this.bufferUpdateCount - 1;
    for (d; d >= 0; --d)
        a = c[d], b[a].min = Number.POSITIVE_INFINITY, b[a].max = Number.NEGATIVE_INFINITY
}, SPE.Emitter.prototype._onRemove = function() {
    "use strict";
    this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.age = 0
}, SPE.Emitter.prototype._decrementParticleCount = function() {
    "use strict";
    --this.activeParticleCount
}, SPE.Emitter.prototype._incrementParticleCount = function() {
    "use strict";
    ++this.activeParticleCount
}, SPE.Emitter.prototype._checkParticleAges = function(a, b, c, d) {
    "use strict";
    for (var e, f, g, h, i = b - 1; i >= a; --i)
        e = 4 * i, h = c[e], 0 !== h && (g = c[e + 1], f = c[e + 2], 1 === this.direction ? (g += d, g >= f && (g = 0, h = 0, this._decrementParticleCount())) : (g -= d, 0 >= g && (g = f, h = 0, this._decrementParticleCount())), c[e] = h, c[e + 1] = g, this._updateAttributeUpdateRange("params", i))
}, SPE.Emitter.prototype._activateParticles = function(a, b, c, d) {
    "use strict";
    for (var e, f, g = this.direction, h = a; b > h; ++h)
        e = 4 * h, (0 == c[e] || 1 === this.particleCount) && (this._incrementParticleCount(), c[e] = 1, this._resetParticle(h), f = d * (h - a), c[e + 1] = -1 === g ? c[e + 2] - f : f, this._updateAttributeUpdateRange("params", h));
}, SPE.Emitter.prototype.tick = function(a) {
    "use strict";
    if (!this.isStatic) {
        null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
        var b = this.attributeOffset,
            c = b + this.particleCount,
            d = this.paramsArray,
            e = this.particlesPerSecond * this.activeMultiplier * a,
            f = this.activationIndex;
        if (this._resetBufferRanges(), this._checkParticleAges(b, c, d, a), this.alive === !1)
            return void (this.age = 0);
        if (null !== this.duration && this.age > this.duration)
            return this.alive = !1, void (this.age = 0);
        var g = 1 === this.particleCount ? f : 0 | f,
            h = Math.min(g + e, this.activationEnd),
            i = h - this.activationIndex | 0,
            j = i > 0 ? a / i : 0;
        this._activateParticles(g, h, d, j), this.activationIndex += e, this.activationIndex > c && (this.activationIndex = b), this.age += a
    }
}, SPE.Emitter.prototype.reset = function(a) {
    "use strict";
    if (this.age = 0, this.alive = !1, a === !0) {
        for (var b, c = this.attributeOffset, d = c + this.particleCount, e = this.paramsArray, f = this.attributes.params.bufferAttribute, g = d - 1; g >= c; --g)
            b = 4 * g, e[b] = 0, e[b + 1] = 0;
        f.updateRange.offset = 0, f.updateRange.count = -1,
        f.needsUpdate = !0
    }
    return this
}, SPE.Emitter.prototype.enable = function() {
    "use strict";
    return this.alive = !0, this
}, SPE.Emitter.prototype.disable = function() {
    "use strict";
    return this.alive = !1, this
}, SPE.Emitter.prototype.remove = function() {
    "use strict";
    return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this
};

},{}],"THREE-r72":[function(require,module,exports){
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = {
    REVISION: '72'
};

//

if ( typeof define === 'function' && define.amd ) {

    define( 'three', THREE );

}
else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

    module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

    // Missing in Android stock browser.

    ( function() {

        var lastTime = 0;
        var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

        for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x ) {

            self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
            self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

        }

        if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

            self.requestAnimationFrame = function( callback ) {

                var currTime = Date.now(),
                    timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
                var id = self.setTimeout( function() {

                    callback( currTime + timeToCall );

                }, timeToCall );
                lastTime = currTime + timeToCall;
                return id;

            };

        }

        if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

            self.cancelAnimationFrame = function( id ) {

                self.clearTimeout( id );

            };

        }

    }() );

}

if ( Math.sign === undefined ) {

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    Math.sign = function( x ) {

        return ( x < 0 ) ? -1 : ( x > 0 ) ? 1 : +x;

    };

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    Object.defineProperty( Function.prototype, 'name', {

        get: function() {

            return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

        }

    } );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// DEPRECATED

THREE.Projector = function() {

    console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    this.projectVector = function( vector, camera ) {

        console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
        vector.project( camera );

    };

    this.unprojectVector = function( vector, camera ) {

        console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
        vector.unproject( camera );

    };

    this.pickingRay = function( vector, camera ) {

        console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    };

};

THREE.CanvasRenderer = function() {

    console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    this.domElement = document.createElement( 'canvas' );
    this.clear = function() {};
    this.render = function() {};
    this.setClearColor = function() {};
    this.setSize = function() {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function( color ) {

    if ( arguments.length === 3 ) {

        return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

    }

    return this.set( color );

};

THREE.Color.prototype = {

    constructor: THREE.Color,

    r: 1,
    g: 1,
    b: 1,

    set: function( value ) {

        if ( value instanceof THREE.Color ) {

            this.copy( value );

        }
        else if ( typeof value === 'number' ) {

            this.setHex( value );

        }
        else if ( typeof value === 'string' ) {

            this.setStyle( value );

        }

        return this;

    },

    setHex: function( hex ) {

        hex = Math.floor( hex );

        this.r = ( hex >> 16 & 255 ) / 255;
        this.g = ( hex >> 8 & 255 ) / 255;
        this.b = ( hex & 255 ) / 255;

        return this;

    },

    setRGB: function( r, g, b ) {

        this.r = r;
        this.g = g;
        this.b = b;

        return this;

    },

    setHSL: function() {

        function hue2rgb( p, q, t ) {

            if ( t < 0 ) t += 1;
            if ( t > 1 ) t -= 1;
            if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
            if ( t < 1 / 2 ) return q;
            if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
            return p;

        }

        return function( h, s, l ) {

            // h,s,l ranges are in 0.0 - 1.0
            h = THREE.Math.euclideanModulo( h, 1 );
            s = THREE.Math.clamp( s, 0, 1 );
            l = THREE.Math.clamp( l, 0, 1 );

            if ( s === 0 ) {

                this.r = this.g = this.b = l;

            }
            else {

                var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
                var q = ( 2 * l ) - p;

                this.r = hue2rgb( q, p, h + 1 / 3 );
                this.g = hue2rgb( q, p, h );
                this.b = hue2rgb( q, p, h - 1 / 3 );

            }

            return this;

        };

    }(),

    setStyle: function( style ) {

        var parseAlpha = function( strAlpha ) {

            var alpha = parseFloat( strAlpha );

            if ( alpha < 1 ) {

                console.warn( 'THREE.Color: Alpha component of color ' + style + ' will be ignored.' );

            }

            return alpha;

        }


        var m;

        if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

            // rgb / hsl

            var color;
            var name = m[ 1 ];
            var components = m[ 2 ];

            switch ( name ) {

                case 'rgb':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*$/.exec( components ) ) {

                        // rgb(255,0,0)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

                        // rgb(100%,0%,0%)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

                        return this;

                    }

                    break;

                case 'rgba':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // rgba(255,0,0,0.5)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
                        parseAlpha( color[ 4 ] );

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // rgba(100%,0%,0%,0.5)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
                        parseAlpha( color[ 4 ] );

                        return this;

                    }

                    break;

                case 'hsl':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

                        // hsl(120,50%,50%)
                        var h = parseFloat( color[ 1 ] );
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;

                        return this.setHSL( h, s, l );

                    }

                    break;

                case 'hsla':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // hsla(120,50%,50%,0.5)
                        var h = parseFloat( color[ 1 ] );
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;
                        parseAlpha( color[ 4 ] );

                        return this.setHSL( h, s, l );

                    }

                    break;

            }

        }
        else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

            // hex color

            var hex = m[ 1 ];
            var size = hex.length;

            if ( size === 3 ) {

                // #ff0
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

                return this;

            }
            else if ( size === 6 ) {

                // #ff0000
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

                return this;

            }

        }

        if ( style && style.length > 0 ) {

            // color keywords
            var hex = THREE.ColorKeywords[ style ];

            if ( hex !== undefined ) {

                // red
                this.setHex( hex );

            }
            else {

                // unknown color
                console.warn( 'THREE.Color: Unknown color ' + style );

            }

        }

        return this;

    },

    clone: function() {

        return new this.constructor( this.r, this.g, this.b );

    },

    copy: function( color ) {

        this.r = color.r;
        this.g = color.g;
        this.b = color.b;

        return this;

    },

    copyGammaToLinear: function( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        this.r = Math.pow( color.r, gammaFactor );
        this.g = Math.pow( color.g, gammaFactor );
        this.b = Math.pow( color.b, gammaFactor );

        return this;

    },

    copyLinearToGamma: function( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

        this.r = Math.pow( color.r, safeInverse );
        this.g = Math.pow( color.g, safeInverse );
        this.b = Math.pow( color.b, safeInverse );

        return this;

    },

    convertGammaToLinear: function() {

        var r = this.r,
            g = this.g,
            b = this.b;

        this.r = r * r;
        this.g = g * g;
        this.b = b * b;

        return this;

    },

    convertLinearToGamma: function() {

        this.r = Math.sqrt( this.r );
        this.g = Math.sqrt( this.g );
        this.b = Math.sqrt( this.b );

        return this;

    },

    getHex: function() {

        return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    },

    getHexString: function() {

        return ( '000000' + this.getHex().toString( 16 ) ).slice( -6 );

    },

    getHSL: function( optionalTarget ) {

        // h,s,l ranges are in 0.0 - 1.0

        var hsl = optionalTarget || {
            h: 0,
            s: 0,
            l: 0
        };

        var r = this.r,
            g = this.g,
            b = this.b;

        var max = Math.max( r, g, b );
        var min = Math.min( r, g, b );

        var hue, saturation;
        var lightness = ( min + max ) / 2.0;

        if ( min === max ) {

            hue = 0;
            saturation = 0;

        }
        else {

            var delta = max - min;

            saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

            switch ( max ) {

                case r:
                    hue = ( g - b ) / delta + ( g < b ? 6 : 0 );
                    break;
                case g:
                    hue = ( b - r ) / delta + 2;
                    break;
                case b:
                    hue = ( r - g ) / delta + 4;
                    break;

            }

            hue /= 6;

        }

        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;

        return hsl;

    },

    getStyle: function() {

        return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    },

    offsetHSL: function( h, s, l ) {

        var hsl = this.getHSL();

        hsl.h += h;
        hsl.s += s;
        hsl.l += l;

        this.setHSL( hsl.h, hsl.s, hsl.l );

        return this;

    },

    add: function( color ) {

        this.r += color.r;
        this.g += color.g;
        this.b += color.b;

        return this;

    },

    addColors: function( color1, color2 ) {

        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;

        return this;

    },

    addScalar: function( s ) {

        this.r += s;
        this.g += s;
        this.b += s;

        return this;

    },

    multiply: function( color ) {

        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;

        return this;

    },

    multiplyScalar: function( s ) {

        this.r *= s;
        this.g *= s;
        this.b *= s;

        return this;

    },

    lerp: function( color, alpha ) {

        this.r += ( color.r - this.r ) * alpha;
        this.g += ( color.g - this.g ) * alpha;
        this.b += ( color.b - this.b ) * alpha;

        return this;

    },

    equals: function( c ) {

        return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    },

    fromArray: function( array ) {

        this.r = array[ 0 ];
        this.g = array[ 1 ];
        this.b = array[ 2 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.r;
        array[ offset + 1 ] = this.g;
        array[ offset + 2 ] = this.b;

        return array;

    }

};

THREE.ColorKeywords = {
    'aliceblue': 0xF0F8FF,
    'antiquewhite': 0xFAEBD7,
    'aqua': 0x00FFFF,
    'aquamarine': 0x7FFFD4,
    'azure': 0xF0FFFF,
    'beige': 0xF5F5DC,
    'bisque': 0xFFE4C4,
    'black': 0x000000,
    'blanchedalmond': 0xFFEBCD,
    'blue': 0x0000FF,
    'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A,
    'burlywood': 0xDEB887,
    'cadetblue': 0x5F9EA0,
    'chartreuse': 0x7FFF00,
    'chocolate': 0xD2691E,
    'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED,
    'cornsilk': 0xFFF8DC,
    'crimson': 0xDC143C,
    'cyan': 0x00FFFF,
    'darkblue': 0x00008B,
    'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B,
    'darkgray': 0xA9A9A9,
    'darkgreen': 0x006400,
    'darkgrey': 0xA9A9A9,
    'darkkhaki': 0xBDB76B,
    'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F,
    'darkorange': 0xFF8C00,
    'darkorchid': 0x9932CC,
    'darkred': 0x8B0000,
    'darksalmon': 0xE9967A,
    'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B,
    'darkslategray': 0x2F4F4F,
    'darkslategrey': 0x2F4F4F,
    'darkturquoise': 0x00CED1,
    'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493,
    'deepskyblue': 0x00BFFF,
    'dimgray': 0x696969,
    'dimgrey': 0x696969,
    'dodgerblue': 0x1E90FF,
    'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0,
    'forestgreen': 0x228B22,
    'fuchsia': 0xFF00FF,
    'gainsboro': 0xDCDCDC,
    'ghostwhite': 0xF8F8FF,
    'gold': 0xFFD700,
    'goldenrod': 0xDAA520,
    'gray': 0x808080,
    'green': 0x008000,
    'greenyellow': 0xADFF2F,
    'grey': 0x808080,
    'honeydew': 0xF0FFF0,
    'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C,
    'indigo': 0x4B0082,
    'ivory': 0xFFFFF0,
    'khaki': 0xF0E68C,
    'lavender': 0xE6E6FA,
    'lavenderblush': 0xFFF0F5,
    'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD,
    'lightblue': 0xADD8E6,
    'lightcoral': 0xF08080,
    'lightcyan': 0xE0FFFF,
    'lightgoldenrodyellow': 0xFAFAD2,
    'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90,
    'lightgrey': 0xD3D3D3,
    'lightpink': 0xFFB6C1,
    'lightsalmon': 0xFFA07A,
    'lightseagreen': 0x20B2AA,
    'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899,
    'lightslategrey': 0x778899,
    'lightsteelblue': 0xB0C4DE,
    'lightyellow': 0xFFFFE0,
    'lime': 0x00FF00,
    'limegreen': 0x32CD32,
    'linen': 0xFAF0E6,
    'magenta': 0xFF00FF,
    'maroon': 0x800000,
    'mediumaquamarine': 0x66CDAA,
    'mediumblue': 0x0000CD,
    'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB,
    'mediumseagreen': 0x3CB371,
    'mediumslateblue': 0x7B68EE,
    'mediumspringgreen': 0x00FA9A,
    'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585,
    'midnightblue': 0x191970,
    'mintcream': 0xF5FFFA,
    'mistyrose': 0xFFE4E1,
    'moccasin': 0xFFE4B5,
    'navajowhite': 0xFFDEAD,
    'navy': 0x000080,
    'oldlace': 0xFDF5E6,
    'olive': 0x808000,
    'olivedrab': 0x6B8E23,
    'orange': 0xFFA500,
    'orangered': 0xFF4500,
    'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA,
    'palegreen': 0x98FB98,
    'paleturquoise': 0xAFEEEE,
    'palevioletred': 0xDB7093,
    'papayawhip': 0xFFEFD5,
    'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F,
    'pink': 0xFFC0CB,
    'plum': 0xDDA0DD,
    'powderblue': 0xB0E0E6,
    'purple': 0x800080,
    'red': 0xFF0000,
    'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1,
    'saddlebrown': 0x8B4513,
    'salmon': 0xFA8072,
    'sandybrown': 0xF4A460,
    'seagreen': 0x2E8B57,
    'seashell': 0xFFF5EE,
    'sienna': 0xA0522D,
    'silver': 0xC0C0C0,
    'skyblue': 0x87CEEB,
    'slateblue': 0x6A5ACD,
    'slategray': 0x708090,
    'slategrey': 0x708090,
    'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F,
    'steelblue': 0x4682B4,
    'tan': 0xD2B48C,
    'teal': 0x008080,
    'thistle': 0xD8BFD8,
    'tomato': 0xFF6347,
    'turquoise': 0x40E0D0,
    'violet': 0xEE82EE,
    'wheat': 0xF5DEB3,
    'white': 0xFFFFFF,
    'whitesmoke': 0xF5F5F5,
    'yellow': 0xFFFF00,
    'yellowgreen': 0x9ACD32
};

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function( x, y, z, w ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

    constructor: THREE.Quaternion,

    get x() {

        return this._x;

    },

    set x( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y() {

        return this._y;

    },

    set y( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z() {

        return this._z;

    },

    set z( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get w() {

        return this._w;

    },

    set w( value ) {

        this._w = value;
        this.onChangeCallback();

    },

    set: function( x, y, z, w ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;

        this.onChangeCallback();

        return this;

    },

    clone: function() {

        return new this.constructor( this._x, this._y, this._z, this._w );

    },

    copy: function( quaternion ) {

        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;

        this.onChangeCallback();

        return this;

    },

    setFromEuler: function( euler, update ) {

        if ( euler instanceof THREE.Euler === false ) {

            throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m

        var c1 = Math.cos( euler._x / 2 );
        var c2 = Math.cos( euler._y / 2 );
        var c3 = Math.cos( euler._z / 2 );
        var s1 = Math.sin( euler._x / 2 );
        var s2 = Math.sin( euler._y / 2 );
        var s3 = Math.sin( euler._z / 2 );

        var order = euler.order;

        if ( order === 'XYZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'YXZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }
        else if ( order === 'ZXY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'ZYX' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }
        else if ( order === 'YZX' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'XZY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromAxisAngle: function( axis, angle ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

        // assumes axis is normalized

        var halfAngle = angle / 2,
            s = Math.sin( halfAngle );

        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos( halfAngle );

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements,

            m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ],
            m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ],
            m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {

            s = 0.5 / Math.sqrt( trace + 1.0 );

            this._w = 0.25 / s;
            this._x = ( m32 - m23 ) * s;
            this._y = ( m13 - m31 ) * s;
            this._z = ( m21 - m12 ) * s;

        }
        else if ( m11 > m22 && m11 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            this._w = ( m32 - m23 ) / s;
            this._x = 0.25 * s;
            this._y = ( m12 + m21 ) / s;
            this._z = ( m13 + m31 ) / s;

        }
        else if ( m22 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            this._w = ( m13 - m31 ) / s;
            this._x = ( m12 + m21 ) / s;
            this._y = 0.25 * s;
            this._z = ( m23 + m32 ) / s;

        }
        else {

            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            this._w = ( m21 - m12 ) / s;
            this._x = ( m13 + m31 ) / s;
            this._y = ( m23 + m32 ) / s;
            this._z = 0.25 * s;

        }

        this.onChangeCallback();

        return this;

    },

    setFromUnitVectors: function() {

        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

        // assumes direction vectors vFrom and vTo are normalized

        var v1, r;

        var EPS = 0.000001;

        return function( vFrom, vTo ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            r = vFrom.dot( vTo ) + 1;

            if ( r < EPS ) {

                r = 0;

                if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

                    v1.set( -vFrom.y, vFrom.x, 0 );

                }
                else {

                    v1.set( 0, -vFrom.z, vFrom.y );

                }

            }
            else {

                v1.crossVectors( vFrom, vTo );

            }

            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;

            this.normalize();

            return this;

        }

    }(),

    inverse: function() {

        this.conjugate().normalize();

        return this;

    },

    conjugate: function() {

        this._x *= -1;
        this._y *= -1;
        this._z *= -1;

        this.onChangeCallback();

        return this;

    },

    dot: function( v ) {

        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    },

    lengthSq: function() {

        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    },

    length: function() {

        return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    },

    normalize: function() {

        var l = this.length();

        if ( l === 0 ) {

            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;

        }
        else {

            l = 1 / l;

            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;

        }

        this.onChangeCallback();

        return this;

    },

    multiply: function( q, p ) {

        if ( p !== undefined ) {

            console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
            return this.multiplyQuaternions( q, p );

        }

        return this.multiplyQuaternions( this, q );

    },

    multiplyQuaternions: function( a, b ) {

        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

        var qax = a._x,
            qay = a._y,
            qaz = a._z,
            qaw = a._w;
        var qbx = b._x,
            qby = b._y,
            qbz = b._z,
            qbw = b._w;

        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        this.onChangeCallback();

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
        return vector.applyQuaternion( this );

    },

    slerp: function( qb, t ) {

        if ( t === 0 ) return this;
        if ( t === 1 ) return this.copy( qb );

        var x = this._x,
            y = this._y,
            z = this._z,
            w = this._w;

        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

        if ( cosHalfTheta < 0 ) {

            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;

            cosHalfTheta = -cosHalfTheta;

        }
        else {

            this.copy( qb );

        }

        if ( cosHalfTheta >= 1.0 ) {

            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;

            return this;

        }

        var halfTheta = Math.acos( cosHalfTheta );
        var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

        if ( Math.abs( sinHalfTheta ) < 0.001 ) {

            this._w = 0.5 * ( w + this._w );
            this._x = 0.5 * ( x + this._x );
            this._y = 0.5 * ( y + this._y );
            this._z = 0.5 * ( z + this._z );

            return this;

        }

        var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
            ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        this._w = ( w * ratioA + this._w * ratioB );
        this._x = ( x * ratioA + this._x * ratioB );
        this._y = ( y * ratioA + this._y * ratioB );
        this._z = ( z * ratioA + this._z * ratioB );

        this.onChangeCallback();

        return this;

    },

    equals: function( quaternion ) {

        return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this._x = array[ offset ];
        this._y = array[ offset + 1 ];
        this._z = array[ offset + 2 ];
        this._w = array[ offset + 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._w;

        return array;

    },

    onChange: function( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function() {}

};

THREE.Quaternion.slerp = function( qa, qb, qm, t ) {

    return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function( x, y ) {

    this.x = x || 0;
    this.y = y || 0;

};

THREE.Vector2.prototype = {

    constructor: THREE.Vector2,

    set: function( x, y ) {

        this.x = x;
        this.y = y;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;

        return this;

    },

    multiply: function( v ) {

        this.x *= v.x;
        this.y *= v.y;

        return this;

    },

    multiplyScalar: function( s ) {

        this.x *= s;
        this.y *= s;

        return this;

    },

    divide: function( v ) {

        this.x /= v.x;
        this.y /= v.y;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;

        }

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector2();
                max = new THREE.Vector2();

            }

            min.set( minVal, minVal );
            max.set( maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    distanceTo: function( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function( v ) {

        var dx = this.x - v.x,
            dy = this.y - v.y;
        return dx * dx + dy * dy;

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];

        return this;

    }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function( x, y, z ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

};

THREE.Vector3.prototype = {

    constructor: THREE.Vector3,

    set: function( x, y, z ) {

        this.x = x;
        this.y = y;
        this.z = z;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setZ: function( z ) {

        this.z = z;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y, this.z );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;
        this.z += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;

        return this;

    },

    multiply: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
            return this.multiplyVectors( v, w );

        }

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;

        return this;

    },

    multiplyScalar: function( scalar ) {

        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;

        return this;

    },

    multiplyVectors: function( a, b ) {

        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;

        return this;

    },

    applyEuler: function() {

        var quaternion;

        return function applyEuler( euler ) {

            if ( euler instanceof THREE.Euler === false ) {

                console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

            }

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromEuler( euler ) );

            return this;

        };

    }(),

    applyAxisAngle: function() {

        var quaternion;

        return function applyAxisAngle( axis, angle ) {

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

            return this;

        };

    }(),

    applyMatrix3: function( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
        this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
        this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

        return this;

    },

    applyMatrix4: function( m ) {

        // input: THREE.Matrix4 affine matrix

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ];
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ];
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

        return this;

    },

    applyProjection: function( m ) {

        // input: THREE.Matrix4 projection matrix

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;
        var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

        this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * d;
        this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * d;
        this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

        return this;

    },

    applyQuaternion: function( q ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vector

        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return this;

    },

    project: function() {

        var matrix;

        return function project( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
            return this.applyProjection( matrix );

        };

    }(),

    unproject: function() {

        var matrix;

        return function unproject( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
            return this.applyProjection( matrix );

        };

    }(),

    transformDirection: function( m ) {

        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

        this.normalize();

        return this;

    },

    divide: function( v ) {

        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;
            this.z = 0;

        }

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        if ( this.z > v.z ) {

            this.z = v.z;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        if ( this.z < v.z ) {

            this.z = v.z;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        if ( this.z < min.z ) {

            this.z = min.z;

        }
        else if ( this.z > max.z ) {

            this.z = max.z;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector3();
                max = new THREE.Vector3();

            }

            min.set( minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y + this.z * this.z;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    cross: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
            return this.crossVectors( v, w );

        }

        var x = this.x,
            y = this.y,
            z = this.z;

        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;

        return this;

    },

    crossVectors: function( a, b ) {

        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;

    },

    projectOnVector: function() {

        var v1, dot;

        return function projectOnVector( vector ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( vector ).normalize();

            dot = this.dot( v1 );

            return this.copy( v1 ).multiplyScalar( dot );

        };

    }(),

    projectOnPlane: function() {

        var v1;

        return function projectOnPlane( planeNormal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( this ).projectOnVector( planeNormal );

            return this.sub( v1 );

        }

    }(),

    reflect: function() {

        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length

        var v1;

        return function reflect( normal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

        }

    }(),

    angleTo: function( v ) {

        var theta = this.dot( v ) / ( this.length() * v.length() );

        // clamp, to handle numerical problems

        return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

    },

    distanceTo: function( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function( v ) {

        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;

        return dx * dx + dy * dy + dz * dz;

    },

    setEulerFromRotationMatrix: function( m, order ) {

        console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

    },

    setEulerFromQuaternion: function( q, order ) {

        console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

    },

    getPositionFromMatrix: function( m ) {

        console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

        return this.setFromMatrixPosition( m );

    },

    getScaleFromMatrix: function( m ) {

        console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

        return this.setFromMatrixScale( m );

    },

    getColumnFromMatrix: function( index, matrix ) {

        console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

        return this.setFromMatrixColumn( index, matrix );

    },

    setFromMatrixPosition: function( m ) {

        this.x = m.elements[ 12 ];
        this.y = m.elements[ 13 ];
        this.z = m.elements[ 14 ];

        return this;

    },

    setFromMatrixScale: function( m ) {

        var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
        var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
        var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

        this.x = sx;
        this.y = sy;
        this.z = sz;

        return this;

    },

    setFromMatrixColumn: function( index, matrix ) {

        var offset = index * 4;

        var me = matrix.elements;

        this.x = me[ offset ];
        this.y = me[ offset + 1 ];
        this.z = me[ offset + 2 ];

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];

        return this;

    }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function( x, y, z, w ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

    constructor: THREE.Vector4,

    set: function( x, y, z, w ) {

        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setZ: function( z ) {

        this.z = z;

        return this;

    },

    setW: function( w ) {

        this.w = w;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y, this.z, this.w );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = ( v.w !== undefined ) ? v.w : 1;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;

        return this;

    },

    multiplyScalar: function( scalar ) {

        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;

        return this;

    },

    applyMatrix4: function( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
        this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;
            this.w *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;

        }

        return this;

    },

    setAxisAngleFromQuaternion: function( q ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

        // q is assumed to be normalized

        this.w = 2 * Math.acos( q.w );

        var s = Math.sqrt( 1 - q.w * q.w );

        if ( s < 0.0001 ) {

            this.x = 1;
            this.y = 0;
            this.z = 0;

        }
        else {

            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;

        }

        return this;

    },

    setAxisAngleFromRotationMatrix: function( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var angle, x, y, z, // variables for result
            epsilon = 0.01, // margin to allow for rounding errors
            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees

            te = m.elements,

            m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ],
            m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ],
            m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ];

        if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) {

            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms

            if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

                // this singularity is identity matrix so angle = 0

                this.set( 1, 0, 0, 0 );

                return this; // zero angle, arbitrary axis

            }

            // otherwise this singularity is angle = 180

            angle = Math.PI;

            var xx = ( m11 + 1 ) / 2;
            var yy = ( m22 + 1 ) / 2;
            var zz = ( m33 + 1 ) / 2;
            var xy = ( m12 + m21 ) / 4;
            var xz = ( m13 + m31 ) / 4;
            var yz = ( m23 + m32 ) / 4;

            if ( ( xx > yy ) && ( xx > zz ) ) {

                // m11 is the largest diagonal term

                if ( xx < epsilon ) {

                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;

                }
                else {

                    x = Math.sqrt( xx );
                    y = xy / x;
                    z = xz / x;

                }

            }
            else if ( yy > zz ) {

                // m22 is the largest diagonal term

                if ( yy < epsilon ) {

                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;

                }
                else {

                    y = Math.sqrt( yy );
                    x = xy / y;
                    z = yz / y;

                }

            }
            else {

                // m33 is the largest diagonal term so base result on this

                if ( zz < epsilon ) {

                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;

                }
                else {

                    z = Math.sqrt( zz );
                    x = xz / z;
                    y = yz / z;

                }

            }

            this.set( x, y, z, angle );

            return this; // return 180 deg rotation

        }

        // as we have reached here there are no singularities so we can handle normally

        var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

        if ( Math.abs( s ) < 0.001 ) s = 1;

        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case

        this.x = ( m32 - m23 ) / s;
        this.y = ( m13 - m31 ) / s;
        this.z = ( m21 - m12 ) / s;
        this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        if ( this.z > v.z ) {

            this.z = v.z;

        }

        if ( this.w > v.w ) {

            this.w = v.w;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        if ( this.z < v.z ) {

            this.z = v.z;

        }

        if ( this.w < v.w ) {

            this.w = v.w;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        if ( this.z < min.z ) {

            this.z = min.z;

        }
        else if ( this.z > max.z ) {

            this.z = max.z;

        }

        if ( this.w < min.w ) {

            this.w = min.w;

        }
        else if ( this.w > max.w ) {

            this.w = max.w;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector4();
                max = new THREE.Vector4();

            }

            min.set( minVal, minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;
        this.w += ( v.w - this.w ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];
        this.w = array[ offset + 3 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;
        array[ offset + 3 ] = this.w;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];
        this.w = attribute.array[ index + 3 ];

        return this;

    }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function( x, y, z, order ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

    constructor: THREE.Euler,

    get x() {

        return this._x;

    },

    set x( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y() {

        return this._y;

    },

    set y( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z() {

        return this._z;

    },

    set z( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get order() {

        return this._order;

    },

    set order( value ) {

        this._order = value;
        this.onChangeCallback();

    },

    set: function( x, y, z, order ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;

        this.onChangeCallback();

        return this;

    },

    clone: function() {

        return new this.constructor( this._x, this._y, this._z, this._order );

    },

    copy: function( euler ) {

        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function( m, order, update ) {

        var clamp = THREE.Math.clamp;

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements;
        var m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ];
        var m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ];
        var m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ];

        order = order || this._order;

        if ( order === 'XYZ' ) {

            this._y = Math.asin( clamp( m13, -1, 1 ) );

            if ( Math.abs( m13 ) < 0.99999 ) {

                this._x = Math.atan2( -m23, m33 );
                this._z = Math.atan2( -m12, m11 );

            }
            else {

                this._x = Math.atan2( m32, m22 );
                this._z = 0;

            }

        }
        else if ( order === 'YXZ' ) {

            this._x = Math.asin( -clamp( m23, -1, 1 ) );

            if ( Math.abs( m23 ) < 0.99999 ) {

                this._y = Math.atan2( m13, m33 );
                this._z = Math.atan2( m21, m22 );

            }
            else {

                this._y = Math.atan2( -m31, m11 );
                this._z = 0;

            }

        }
        else if ( order === 'ZXY' ) {

            this._x = Math.asin( clamp( m32, -1, 1 ) );

            if ( Math.abs( m32 ) < 0.99999 ) {

                this._y = Math.atan2( -m31, m33 );
                this._z = Math.atan2( -m12, m22 );

            }
            else {

                this._y = 0;
                this._z = Math.atan2( m21, m11 );

            }

        }
        else if ( order === 'ZYX' ) {

            this._y = Math.asin( -clamp( m31, -1, 1 ) );

            if ( Math.abs( m31 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m33 );
                this._z = Math.atan2( m21, m11 );

            }
            else {

                this._x = 0;
                this._z = Math.atan2( -m12, m22 );

            }

        }
        else if ( order === 'YZX' ) {

            this._z = Math.asin( clamp( m21, -1, 1 ) );

            if ( Math.abs( m21 ) < 0.99999 ) {

                this._x = Math.atan2( -m23, m22 );
                this._y = Math.atan2( -m31, m11 );

            }
            else {

                this._x = 0;
                this._y = Math.atan2( m13, m33 );

            }

        }
        else if ( order === 'XZY' ) {

            this._z = Math.asin( -clamp( m12, -1, 1 ) );

            if ( Math.abs( m12 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m22 );
                this._y = Math.atan2( m13, m11 );

            }
            else {

                this._x = Math.atan2( -m23, m33 );
                this._y = 0;

            }

        }
        else {

            console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

        }

        this._order = order;

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromQuaternion: function() {

        var matrix;

        return function( q, order, update ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();
            matrix.makeRotationFromQuaternion( q );
            this.setFromRotationMatrix( matrix, order, update );

            return this;

        };

    }(),

    setFromVector3: function( v, order ) {

        return this.set( v.x, v.y, v.z, order || this._order );

    },

    reorder: function() {

        // WARNING: this discards revolution information -bhouston

        var q = new THREE.Quaternion();

        return function( newOrder ) {

            q.setFromEuler( this );
            this.setFromQuaternion( q, newOrder );

        };

    }(),

    equals: function( euler ) {

        return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    },

    fromArray: function( array ) {

        this._x = array[ 0 ];
        this._y = array[ 1 ];
        this._z = array[ 2 ];
        if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._order;

        return array;

    },

    toVector3: function( optionalResult ) {

        if ( optionalResult ) {

            return optionalResult.set( this._x, this._y, this._z );

        }
        else {

            return new THREE.Vector3( this._x, this._y, this._z );

        }

    },

    onChange: function( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function() {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function( start, end ) {

    this.start = ( start !== undefined ) ? start : new THREE.Vector3();
    this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

    constructor: THREE.Line3,

    set: function( start, end ) {

        this.start.copy( start );
        this.end.copy( end );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( line ) {

        this.start.copy( line.start );
        this.end.copy( line.end );

        return this;

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    },

    delta: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.end, this.start );

    },

    distanceSq: function() {

        return this.start.distanceToSquared( this.end );

    },

    distance: function() {

        return this.start.distanceTo( this.end );

    },

    at: function( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    closestPointToPointParameter: function() {

        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();

        return function( point, clampToLine ) {

            startP.subVectors( point, this.start );
            startEnd.subVectors( this.end, this.start );

            var startEnd2 = startEnd.dot( startEnd );
            var startEnd_startP = startEnd.dot( startP );

            var t = startEnd_startP / startEnd2;

            if ( clampToLine ) {

                t = THREE.Math.clamp( t, 0, 1 );

            }

            return t;

        };

    }(),

    closestPointToPoint: function( point, clampToLine, optionalTarget ) {

        var t = this.closestPointToPointParameter( point, clampToLine );

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    applyMatrix4: function( matrix ) {

        this.start.applyMatrix4( matrix );
        this.end.applyMatrix4( matrix );

        return this;

    },

    equals: function( line ) {

        return line.start.equals( this.start ) && line.end.equals( this.end );

    }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.Box2.prototype = {

    constructor: THREE.Box2,

    set: function( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i++ ) {

            this.expandByPoint( points[ i ] )

        }

        return this;

    },

    setFromCenterAndSize: function() {

        var v1 = new THREE.Vector2();

        return function( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function() {

        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;

        return this;

    },

    empty: function() {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function( scalar ) {

        this.min.addScalar( -scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ) {

            return false;

        }

        return true;

    },

    containsBox: function( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

            return true;

        }

        return false;

    },

    getParameter: function( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector2();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ), ( point.y - this.min.y ) / ( this.max.y - this.min.y )
        );

    },

    isIntersectionBox: function( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ) {

            return false;

        }

        return true;

    },

    clampPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function() {

        var v1 = new THREE.Vector2();

        return function( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    intersect: function( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    translate: function( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.Box3.prototype = {

    constructor: THREE.Box3,

    set: function( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i++ ) {

            this.expandByPoint( points[ i ] );

        }

        return this;

    },

    setFromCenterAndSize: function() {

        var v1 = new THREE.Vector3();

        return function( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    setFromObject: function() {

        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms

        var v1 = new THREE.Vector3();

        return function( object ) {

            var scope = this;

            object.updateMatrixWorld( true );

            this.makeEmpty();

            object.traverse( function( node ) {

                var geometry = node.geometry;

                if ( geometry !== undefined ) {

                    if ( geometry instanceof THREE.Geometry ) {

                        var vertices = geometry.vertices;

                        for ( var i = 0, il = vertices.length; i < il; i++ ) {

                            v1.copy( vertices[ i ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }
                    else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

                        var positions = geometry.attributes[ 'position' ].array;

                        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                            v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }

                }

            } );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function() {

        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;

        return this;

    },

    empty: function() {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function( scalar ) {

        this.min.addScalar( -scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ||
            point.z < this.min.z || point.z > this.max.z ) {

            return false;

        }

        return true;

    },

    containsBox: function( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
            ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

            return true;

        }

        return false;

    },

    getParameter: function( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector3();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ), ( point.y - this.min.y ) / ( this.max.y - this.min.y ), ( point.z - this.min.z ) / ( this.max.z - this.min.z )
        );

    },

    isIntersectionBox: function( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ||
            box.max.z < this.min.z || box.min.z > this.max.z ) {

            return false;

        }

        return true;

    },

    clampPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function() {

        var v1 = new THREE.Vector3();

        return function( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    getBoundingSphere: function() {

        var v1 = new THREE.Vector3();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Sphere();

            result.center = this.center();
            result.radius = this.size( v1 ).length() * 0.5;

            return result;

        };

    }(),

    intersect: function( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    applyMatrix4: function() {

        var points = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];

        return function( matrix ) {

            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
            points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
            points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
            points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
            points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
            points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
            points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
            points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

            this.makeEmpty();
            this.setFromPoints( points );

            return this;

        };

    }(),

    translate: function( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function() {

    this.elements = new Float32Array( [

        1, 0, 0,
        0, 1, 0,
        0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix3.prototype = {

    constructor: THREE.Matrix3,

    set: function( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

        var te = this.elements;

        te[ 0 ] = n11;
        te[ 3 ] = n12;
        te[ 6 ] = n13;
        te[ 1 ] = n21;
        te[ 4 ] = n22;
        te[ 7 ] = n23;
        te[ 2 ] = n31;
        te[ 5 ] = n32;
        te[ 8 ] = n33;

        return this;

    },

    identity: function() {

        this.set(

            1, 0, 0,
            0, 1, 0,
            0, 0, 1

        );

        return this;

    },

    clone: function() {

        return new this.constructor().fromArray( this.elements );

    },

    copy: function( m ) {

        var me = m.elements;

        this.set(

            me[ 0 ], me[ 3 ], me[ 6 ],
            me[ 1 ], me[ 4 ], me[ 7 ],
            me[ 2 ], me[ 5 ], me[ 8 ]

        );

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
        return vector.applyMatrix3( this );

    },

    multiplyVector3Array: function( a ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function() {

        var v1;

        return function( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix3( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function() {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i++, j++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix3( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    multiplyScalar: function( s ) {

        var te = this.elements;

        te[ 0 ] *= s;
        te[ 3 ] *= s;
        te[ 6 ] *= s;
        te[ 1 ] *= s;
        te[ 4 ] *= s;
        te[ 7 ] *= s;
        te[ 2 ] *= s;
        te[ 5 ] *= s;
        te[ 8 ] *= s;

        return this;

    },

    determinant: function() {

        var te = this.elements;

        var a = te[ 0 ],
            b = te[ 1 ],
            c = te[ 2 ],
            d = te[ 3 ],
            e = te[ 4 ],
            f = te[ 5 ],
            g = te[ 6 ],
            h = te[ 7 ],
            i = te[ 8 ];

        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    },

    getInverse: function( matrix, throwOnInvertible ) {

        // input: THREE.Matrix4
        // ( based on http://code.google.com/p/webgl-mjs/ )

        var me = matrix.elements;
        var te = this.elements;

        te[ 0 ] = me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
        te[ 1 ] = -me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
        te[ 2 ] = me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
        te[ 3 ] = -me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
        te[ 4 ] = me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
        te[ 5 ] = -me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
        te[ 6 ] = me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
        te[ 7 ] = -me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
        te[ 8 ] = me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

        // no inverse

        if ( det === 0 ) {

            var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            }
            else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1.0 / det );

        return this;

    },

    transpose: function() {

        var tmp, m = this.elements;

        tmp = m[ 1 ];
        m[ 1 ] = m[ 3 ];
        m[ 3 ] = tmp;
        tmp = m[ 2 ];
        m[ 2 ] = m[ 6 ];
        m[ 6 ] = tmp;
        tmp = m[ 5 ];
        m[ 5 ] = m[ 7 ];
        m[ 7 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ] = te[ 8 ];

        return array;

    },

    getNormalMatrix: function( m ) {

        // input: THREE.Matrix4

        this.getInverse( m ).transpose();

        return this;

    },

    transposeIntoArray: function( r ) {

        var m = this.elements;

        r[ 0 ] = m[ 0 ];
        r[ 1 ] = m[ 3 ];
        r[ 2 ] = m[ 6 ];
        r[ 3 ] = m[ 1 ];
        r[ 4 ] = m[ 4 ];
        r[ 5 ] = m[ 7 ];
        r[ 6 ] = m[ 2 ];
        r[ 7 ] = m[ 5 ];
        r[ 8 ] = m[ 8 ];

        return this;

    },

    fromArray: function( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function() {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ],
            te[ 3 ], te[ 4 ], te[ 5 ],
            te[ 6 ], te[ 7 ], te[ 8 ]
        ];

    }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function() {

    this.elements = new Float32Array( [

        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix4.prototype = {

    constructor: THREE.Matrix4,

    set: function( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

        var te = this.elements;

        te[ 0 ] = n11;
        te[ 4 ] = n12;
        te[ 8 ] = n13;
        te[ 12 ] = n14;
        te[ 1 ] = n21;
        te[ 5 ] = n22;
        te[ 9 ] = n23;
        te[ 13 ] = n24;
        te[ 2 ] = n31;
        te[ 6 ] = n32;
        te[ 10 ] = n33;
        te[ 14 ] = n34;
        te[ 3 ] = n41;
        te[ 7 ] = n42;
        te[ 11 ] = n43;
        te[ 15 ] = n44;

        return this;

    },

    identity: function() {

        this.set(

            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    clone: function() {

        return new THREE.Matrix4().fromArray( this.elements );

    },

    copy: function( m ) {

        this.elements.set( m.elements );

        return this;

    },

    extractPosition: function( m ) {

        console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
        return this.copyPosition( m );

    },

    copyPosition: function( m ) {

        var te = this.elements;
        var me = m.elements;

        te[ 12 ] = me[ 12 ];
        te[ 13 ] = me[ 13 ];
        te[ 14 ] = me[ 14 ];

        return this;

    },

    extractBasis: function( xAxis, yAxis, zAxis ) {

        var te = this.elements;

        xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
        yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
        zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

        return this;

    },

    makeBasis: function( xAxis, yAxis, zAxis ) {

        this.set(
            xAxis.x, yAxis.x, zAxis.x, 0,
            xAxis.y, yAxis.y, zAxis.y, 0,
            xAxis.z, yAxis.z, zAxis.z, 0,
            0, 0, 0, 1
        );

        return this;

    },

    extractRotation: function() {

        var v1;

        return function( m ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            var te = this.elements;
            var me = m.elements;

            var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
            var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
            var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

            te[ 0 ] = me[ 0 ] * scaleX;
            te[ 1 ] = me[ 1 ] * scaleX;
            te[ 2 ] = me[ 2 ] * scaleX;

            te[ 4 ] = me[ 4 ] * scaleY;
            te[ 5 ] = me[ 5 ] * scaleY;
            te[ 6 ] = me[ 6 ] * scaleY;

            te[ 8 ] = me[ 8 ] * scaleZ;
            te[ 9 ] = me[ 9 ] * scaleZ;
            te[ 10 ] = me[ 10 ] * scaleZ;

            return this;

        };

    }(),

    makeRotationFromEuler: function( euler ) {

        if ( euler instanceof THREE.Euler === false ) {

            console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        var te = this.elements;

        var x = euler.x,
            y = euler.y,
            z = euler.z;
        var a = Math.cos( x ),
            b = Math.sin( x );
        var c = Math.cos( y ),
            d = Math.sin( y );
        var e = Math.cos( z ),
            f = Math.sin( z );

        if ( euler.order === 'XYZ' ) {

            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = -c * f;
            te[ 8 ] = d;

            te[ 1 ] = af + be * d;
            te[ 5 ] = ae - bf * d;
            te[ 9 ] = -b * c;

            te[ 2 ] = bf - ae * d;
            te[ 6 ] = be + af * d;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'YXZ' ) {

            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;

            te[ 0 ] = ce + df * b;
            te[ 4 ] = de * b - cf;
            te[ 8 ] = a * d;

            te[ 1 ] = a * f;
            te[ 5 ] = a * e;
            te[ 9 ] = -b;

            te[ 2 ] = cf * b - de;
            te[ 6 ] = df + ce * b;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'ZXY' ) {

            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;

            te[ 0 ] = ce - df * b;
            te[ 4 ] = -a * f;
            te[ 8 ] = de + cf * b;

            te[ 1 ] = cf + de * b;
            te[ 5 ] = a * e;
            te[ 9 ] = df - ce * b;

            te[ 2 ] = -a * d;
            te[ 6 ] = b;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'ZYX' ) {

            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = be * d - af;
            te[ 8 ] = ae * d + bf;

            te[ 1 ] = c * f;
            te[ 5 ] = bf * d + ae;
            te[ 9 ] = af * d - be;

            te[ 2 ] = -d;
            te[ 6 ] = b * c;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'YZX' ) {

            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = bd - ac * f;
            te[ 8 ] = bc * f + ad;

            te[ 1 ] = f;
            te[ 5 ] = a * e;
            te[ 9 ] = -b * e;

            te[ 2 ] = -d * e;
            te[ 6 ] = ad * f + bc;
            te[ 10 ] = ac - bd * f;

        }
        else if ( euler.order === 'XZY' ) {

            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = -f;
            te[ 8 ] = d * e;

            te[ 1 ] = ac * f + bd;
            te[ 5 ] = a * e;
            te[ 9 ] = ad * f - bc;

            te[ 2 ] = bc * f - ad;
            te[ 6 ] = b * e;
            te[ 10 ] = bd * f + ac;

        }

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    setRotationFromQuaternion: function( q ) {

        console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

        return this.makeRotationFromQuaternion( q );

    },

    makeRotationFromQuaternion: function( q ) {

        var te = this.elements;

        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        te[ 0 ] = 1 - ( yy + zz );
        te[ 4 ] = xy - wz;
        te[ 8 ] = xz + wy;

        te[ 1 ] = xy + wz;
        te[ 5 ] = 1 - ( xx + zz );
        te[ 9 ] = yz - wx;

        te[ 2 ] = xz - wy;
        te[ 6 ] = yz + wx;
        te[ 10 ] = 1 - ( xx + yy );

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    lookAt: function() {

        var x, y, z;

        return function( eye, target, up ) {

            if ( x === undefined ) x = new THREE.Vector3();
            if ( y === undefined ) y = new THREE.Vector3();
            if ( z === undefined ) z = new THREE.Vector3();

            var te = this.elements;

            z.subVectors( eye, target ).normalize();

            if ( z.length() === 0 ) {

                z.z = 1;

            }

            x.crossVectors( up, z ).normalize();

            if ( x.length() === 0 ) {

                z.x += 0.0001;
                x.crossVectors( up, z ).normalize();

            }

            y.crossVectors( z, x );


            te[ 0 ] = x.x;
            te[ 4 ] = y.x;
            te[ 8 ] = z.x;
            te[ 1 ] = x.y;
            te[ 5 ] = y.y;
            te[ 9 ] = z.y;
            te[ 2 ] = x.z;
            te[ 6 ] = y.z;
            te[ 10 ] = z.z;

            return this;

        };

    }(),

    multiply: function( m, n ) {

        if ( n !== undefined ) {

            console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
            return this.multiplyMatrices( m, n );

        }

        return this.multiplyMatrices( this, m );

    },

    multiplyMatrices: function( a, b ) {

        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;

        var a11 = ae[ 0 ],
            a12 = ae[ 4 ],
            a13 = ae[ 8 ],
            a14 = ae[ 12 ];
        var a21 = ae[ 1 ],
            a22 = ae[ 5 ],
            a23 = ae[ 9 ],
            a24 = ae[ 13 ];
        var a31 = ae[ 2 ],
            a32 = ae[ 6 ],
            a33 = ae[ 10 ],
            a34 = ae[ 14 ];
        var a41 = ae[ 3 ],
            a42 = ae[ 7 ],
            a43 = ae[ 11 ],
            a44 = ae[ 15 ];

        var b11 = be[ 0 ],
            b12 = be[ 4 ],
            b13 = be[ 8 ],
            b14 = be[ 12 ];
        var b21 = be[ 1 ],
            b22 = be[ 5 ],
            b23 = be[ 9 ],
            b24 = be[ 13 ];
        var b31 = be[ 2 ],
            b32 = be[ 6 ],
            b33 = be[ 10 ],
            b34 = be[ 14 ];
        var b41 = be[ 3 ],
            b42 = be[ 7 ],
            b43 = be[ 11 ],
            b44 = be[ 15 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

        te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

        return this;

    },

    multiplyToArray: function( a, b, r ) {

        var te = this.elements;

        this.multiplyMatrices( a, b );

        r[ 0 ] = te[ 0 ];
        r[ 1 ] = te[ 1 ];
        r[ 2 ] = te[ 2 ];
        r[ 3 ] = te[ 3 ];
        r[ 4 ] = te[ 4 ];
        r[ 5 ] = te[ 5 ];
        r[ 6 ] = te[ 6 ];
        r[ 7 ] = te[ 7 ];
        r[ 8 ] = te[ 8 ];
        r[ 9 ] = te[ 9 ];
        r[ 10 ] = te[ 10 ];
        r[ 11 ] = te[ 11 ];
        r[ 12 ] = te[ 12 ];
        r[ 13 ] = te[ 13 ];
        r[ 14 ] = te[ 14 ];
        r[ 15 ] = te[ 15 ];

        return this;

    },

    multiplyScalar: function( s ) {

        var te = this.elements;

        te[ 0 ] *= s;
        te[ 4 ] *= s;
        te[ 8 ] *= s;
        te[ 12 ] *= s;
        te[ 1 ] *= s;
        te[ 5 ] *= s;
        te[ 9 ] *= s;
        te[ 13 ] *= s;
        te[ 2 ] *= s;
        te[ 6 ] *= s;
        te[ 10 ] *= s;
        te[ 14 ] *= s;
        te[ 3 ] *= s;
        te[ 7 ] *= s;
        te[ 11 ] *= s;
        te[ 15 ] *= s;

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
        return vector.applyProjection( this );

    },

    multiplyVector4: function( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    multiplyVector3Array: function( a ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function() {

        var v1;

        return function( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix4( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function() {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i++, j++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix4( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    rotateAxis: function( v ) {

        console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

        v.transformDirection( this );

    },

    crossVector: function( vector ) {

        console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    determinant: function() {

        var te = this.elements;

        var n11 = te[ 0 ],
            n12 = te[ 4 ],
            n13 = te[ 8 ],
            n14 = te[ 12 ];
        var n21 = te[ 1 ],
            n22 = te[ 5 ],
            n23 = te[ 9 ],
            n24 = te[ 13 ];
        var n31 = te[ 2 ],
            n32 = te[ 6 ],
            n33 = te[ 10 ],
            n34 = te[ 14 ];
        var n41 = te[ 3 ],
            n42 = te[ 7 ],
            n43 = te[ 11 ],
            n44 = te[ 15 ];

        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

        return (
            n41 * ( +n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34 ) +
            n42 * ( +n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31 ) +
            n43 * ( +n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31 ) +
            n44 * ( -n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31 )

        );

    },

    transpose: function() {

        var te = this.elements;
        var tmp;

        tmp = te[ 1 ];
        te[ 1 ] = te[ 4 ];
        te[ 4 ] = tmp;
        tmp = te[ 2 ];
        te[ 2 ] = te[ 8 ];
        te[ 8 ] = tmp;
        tmp = te[ 6 ];
        te[ 6 ] = te[ 9 ];
        te[ 9 ] = tmp;

        tmp = te[ 3 ];
        te[ 3 ] = te[ 12 ];
        te[ 12 ] = tmp;
        tmp = te[ 7 ];
        te[ 7 ] = te[ 13 ];
        te[ 13 ] = tmp;
        tmp = te[ 11 ];
        te[ 11 ] = te[ 14 ];
        te[ 14 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];
        array[ offset + 3 ] = te[ 3 ];

        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];
        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];

        array[ offset + 8 ] = te[ 8 ];
        array[ offset + 9 ] = te[ 9 ];
        array[ offset + 10 ] = te[ 10 ];
        array[ offset + 11 ] = te[ 11 ];

        array[ offset + 12 ] = te[ 12 ];
        array[ offset + 13 ] = te[ 13 ];
        array[ offset + 14 ] = te[ 14 ];
        array[ offset + 15 ] = te[ 15 ];

        return array;

    },

    getPosition: function() {

        var v1;

        return function() {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

            var te = this.elements;
            return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

        };

    }(),

    setPosition: function( v ) {

        var te = this.elements;

        te[ 12 ] = v.x;
        te[ 13 ] = v.y;
        te[ 14 ] = v.z;

        return this;

    },

    getInverse: function( m, throwOnInvertible ) {

        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements;
        var me = m.elements;

        var n11 = me[ 0 ],
            n12 = me[ 4 ],
            n13 = me[ 8 ],
            n14 = me[ 12 ];
        var n21 = me[ 1 ],
            n22 = me[ 5 ],
            n23 = me[ 9 ],
            n24 = me[ 13 ];
        var n31 = me[ 2 ],
            n32 = me[ 6 ],
            n33 = me[ 10 ],
            n34 = me[ 14 ];
        var n41 = me[ 3 ],
            n42 = me[ 7 ],
            n43 = me[ 11 ],
            n44 = me[ 15 ];

        te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

        var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

        if ( det === 0 ) {

            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            }
            else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1 / det );

        return this;

    },

    translate: function( v ) {

        console.error( 'THREE.Matrix4: .translate() has been removed.' );

    },

    rotateX: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

    },

    rotateY: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

    },

    rotateZ: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

    },

    rotateByAxis: function( axis, angle ) {

        console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

    },

    scale: function( v ) {

        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;

        te[ 0 ] *= x;
        te[ 4 ] *= y;
        te[ 8 ] *= z;
        te[ 1 ] *= x;
        te[ 5 ] *= y;
        te[ 9 ] *= z;
        te[ 2 ] *= x;
        te[ 6 ] *= y;
        te[ 10 ] *= z;
        te[ 3 ] *= x;
        te[ 7 ] *= y;
        te[ 11 ] *= z;

        return this;

    },

    getMaxScaleOnAxis: function() {

        var te = this.elements;

        var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
        var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
        var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

        return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

    },

    makeTranslation: function( x, y, z ) {

        this.set(

            1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationX: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            1, 0, 0, 0,
            0, c, -s, 0,
            0, s, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationY: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            c, 0, s, 0,
            0, 1, 0, 0, -s, 0, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationZ: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            c, -s, 0, 0,
            s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationAxis: function( axis, angle ) {

        // Based on http://www.gamedev.net/reference/articles/article1199.asp

        var c = Math.cos( angle );
        var s = Math.sin( angle );
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;

        this.set(

            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeScale: function( x, y, z ) {

        this.set(

            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1

        );

        return this;

    },

    compose: function( position, quaternion, scale ) {

        this.makeRotationFromQuaternion( quaternion );
        this.scale( scale );
        this.setPosition( position );

        return this;

    },

    decompose: function() {

        var vector, matrix;

        return function( position, quaternion, scale ) {

            if ( vector === undefined ) vector = new THREE.Vector3();
            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            var te = this.elements;

            var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
            var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
            var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if ( det < 0 ) {

                sx = -sx;

            }

            position.x = te[ 12 ];
            position.y = te[ 13 ];
            position.z = te[ 14 ];

            // scale the rotation part

            matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;

            matrix.elements[ 0 ] *= invSX;
            matrix.elements[ 1 ] *= invSX;
            matrix.elements[ 2 ] *= invSX;

            matrix.elements[ 4 ] *= invSY;
            matrix.elements[ 5 ] *= invSY;
            matrix.elements[ 6 ] *= invSY;

            matrix.elements[ 8 ] *= invSZ;
            matrix.elements[ 9 ] *= invSZ;
            matrix.elements[ 10 ] *= invSZ;

            quaternion.setFromRotationMatrix( matrix );

            scale.x = sx;
            scale.y = sy;
            scale.z = sz;

            return this;

        };

    }(),

    makeFrustum: function( left, right, bottom, top, near, far ) {

        var te = this.elements;
        var x = 2 * near / ( right - left );
        var y = 2 * near / ( top - bottom );

        var a = ( right + left ) / ( right - left );
        var b = ( top + bottom ) / ( top - bottom );
        var c = -( far + near ) / ( far - near );
        var d = -2 * far * near / ( far - near );

        te[ 0 ] = x;
        te[ 4 ] = 0;
        te[ 8 ] = a;
        te[ 12 ] = 0;
        te[ 1 ] = 0;
        te[ 5 ] = y;
        te[ 9 ] = b;
        te[ 13 ] = 0;
        te[ 2 ] = 0;
        te[ 6 ] = 0;
        te[ 10 ] = c;
        te[ 14 ] = d;
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = -1;
        te[ 15 ] = 0;

        return this;

    },

    makePerspective: function( fov, aspect, near, far ) {

        var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;

        return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    },

    makeOrthographic: function( left, right, top, bottom, near, far ) {

        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;

        var x = ( right + left ) / w;
        var y = ( top + bottom ) / h;
        var z = ( far + near ) / p;

        te[ 0 ] = 2 / w;
        te[ 4 ] = 0;
        te[ 8 ] = 0;
        te[ 12 ] = -x;
        te[ 1 ] = 0;
        te[ 5 ] = 2 / h;
        te[ 9 ] = 0;
        te[ 13 ] = -y;
        te[ 2 ] = 0;
        te[ 6 ] = 0;
        te[ 10 ] = -2 / p;
        te[ 14 ] = -z;
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    equals: function( matrix ) {

        var te = this.elements;
        var me = matrix.elements;

        for ( var i = 0; i < 16; i++ ) {

            if ( te[ i ] !== me[ i ] ) return false;

        }

        return true;

    },

    fromArray: function( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function() {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
            te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
            te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
            te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
        ];

    }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function( origin, direction ) {

    this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
    this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

    constructor: THREE.Ray,

    set: function( origin, direction ) {

        this.origin.copy( origin );
        this.direction.copy( direction );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( ray ) {

        this.origin.copy( ray.origin );
        this.direction.copy( ray.direction );

        return this;

    },

    at: function( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    },

    recast: function() {

        var v1 = new THREE.Vector3();

        return function( t ) {

            this.origin.copy( this.at( t, v1 ) );

            return this;

        };

    }(),

    closestPointToPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        result.subVectors( point, this.origin );
        var directionDistance = result.dot( this.direction );

        if ( directionDistance < 0 ) {

            return result.copy( this.origin );

        }

        return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    },

    distanceToPoint: function( point ) {

        return Math.sqrt( this.distanceSqToPoint( point ) );

    },

    distanceSqToPoint: function() {

        var v1 = new THREE.Vector3();

        return function( point ) {

            var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

            // point behind the ray

            if ( directionDistance < 0 ) {

                return this.origin.distanceToSquared( point );

            }

            v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

            return v1.distanceToSquared( point );

        };

    }(),

    distanceSqToSegment: function() {

        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();

        return function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

            // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment

            segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
            segDir.copy( v1 ).sub( v0 ).normalize();
            diff.copy( this.origin ).sub( segCenter );

            var segExtent = v0.distanceTo( v1 ) * 0.5;
            var a01 = -this.direction.dot( segDir );
            var b0 = diff.dot( this.direction );
            var b1 = -diff.dot( segDir );
            var c = diff.lengthSq();
            var det = Math.abs( 1 - a01 * a01 );
            var s0, s1, sqrDist, extDet;

            if ( det > 0 ) {

                // The ray and segment are not parallel.

                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;

                if ( s0 >= 0 ) {

                    if ( s1 >= -extDet ) {

                        if ( s1 <= extDet ) {

                            // region 0
                            // Minimum at interior points of ray and segment.

                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

                        }
                        else {

                            // region 1

                            s1 = segExtent;
                            s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                            sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                        }

                    }
                    else {

                        // region 5

                        s1 = -segExtent;
                        s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }
                else {

                    if ( s1 <= -extDet ) {

                        // region 4

                        s0 = Math.max( 0, -( -a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? -segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }
                    else if ( s1 <= extDet ) {

                        // region 3

                        s0 = 0;
                        s1 = Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = s1 * ( s1 + 2 * b1 ) + c;

                    }
                    else {

                        // region 2

                        s0 = Math.max( 0, -( a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }

            }
            else {

                // Ray and segment are parallel.

                s1 = ( a01 > 0 ) ? -segExtent : segExtent;
                s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

            if ( optionalPointOnRay ) {

                optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

            }

            if ( optionalPointOnSegment ) {

                optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

            }

            return sqrDist;

        };

    }(),


    isIntersectionSphere: function( sphere ) {

        return this.distanceToPoint( sphere.center ) <= sphere.radius;

    },

    intersectSphere: function() {

        // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

        var v1 = new THREE.Vector3();

        return function( sphere, optionalTarget ) {

            v1.subVectors( sphere.center, this.origin );

            var tca = v1.dot( this.direction );

            var d2 = v1.dot( v1 ) - tca * tca;

            var radius2 = sphere.radius * sphere.radius;

            if ( d2 > radius2 ) return null;

            var thc = Math.sqrt( radius2 - d2 );

            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;

            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;

            // test to see if both t0 and t1 are behind the ray - if so, return null
            if ( t0 < 0 && t1 < 0 ) return null;

            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if ( t0 < 0 ) return this.at( t1, optionalTarget );

            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at( t0, optionalTarget );

        }

    }(),

    isIntersectionPlane: function( plane ) {

        // check if the ray lies on the plane first

        var distToPoint = plane.distanceToPoint( this.origin );

        if ( distToPoint === 0 ) {

            return true;

        }

        var denominator = plane.normal.dot( this.direction );

        if ( denominator * distToPoint < 0 ) {

            return true;

        }

        // ray origin is behind the plane (and is pointing behind it)

        return false;

    },

    distanceToPlane: function( plane ) {

        var denominator = plane.normal.dot( this.direction );
        if ( denominator === 0 ) {

            // line is coplanar, return origin
            if ( plane.distanceToPoint( this.origin ) === 0 ) {

                return 0;

            }

            // Null is preferable to undefined since undefined means.... it is undefined

            return null;

        }

        var t = -( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

        // Return if the ray never intersects the plane

        return t >= 0 ? t : null;

    },

    intersectPlane: function( plane, optionalTarget ) {

        var t = this.distanceToPlane( plane );

        if ( t === null ) {

            return null;

        }

        return this.at( t, optionalTarget );

    },

    isIntersectionBox: function() {

        var v = new THREE.Vector3();

        return function( box ) {

            return this.intersectBox( box, v ) !== null;

        };

    }(),

    intersectBox: function( box, optionalTarget ) {

        // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

        var tmin, tmax, tymin, tymax, tzmin, tzmax;

        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;

        var origin = this.origin;

        if ( invdirx >= 0 ) {

            tmin = ( box.min.x - origin.x ) * invdirx;
            tmax = ( box.max.x - origin.x ) * invdirx;

        }
        else {

            tmin = ( box.max.x - origin.x ) * invdirx;
            tmax = ( box.min.x - origin.x ) * invdirx;

        }

        if ( invdiry >= 0 ) {

            tymin = ( box.min.y - origin.y ) * invdiry;
            tymax = ( box.max.y - origin.y ) * invdiry;

        }
        else {

            tymin = ( box.max.y - origin.y ) * invdiry;
            tymax = ( box.min.y - origin.y ) * invdiry;

        }

        if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

        if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

        if ( invdirz >= 0 ) {

            tzmin = ( box.min.z - origin.z ) * invdirz;
            tzmax = ( box.max.z - origin.z ) * invdirz;

        }
        else {

            tzmin = ( box.max.z - origin.z ) * invdirz;
            tzmax = ( box.min.z - origin.z ) * invdirz;

        }

        if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

        if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

        if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

        //return point closest to the ray (positive side)

        if ( tmax < 0 ) return null;

        return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    },

    intersectTriangle: function() {

        // Compute the offset origin, edges, and normal.
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();

        return function( a, b, c, backfaceCulling, optionalTarget ) {

            // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

            edge1.subVectors( b, a );
            edge2.subVectors( c, a );
            normal.crossVectors( edge1, edge2 );

            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot( normal );
            var sign;

            if ( DdN > 0 ) {

                if ( backfaceCulling ) return null;
                sign = 1;

            }
            else if ( DdN < 0 ) {

                sign = -1;
                DdN = -DdN;

            }
            else {

                return null;

            }

            diff.subVectors( this.origin, a );
            var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

            // b1 < 0, no intersection
            if ( DdQxE2 < 0 ) {

                return null;

            }

            var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

            // b2 < 0, no intersection
            if ( DdE1xQ < 0 ) {

                return null;

            }

            // b1+b2 > 1, no intersection
            if ( DdQxE2 + DdE1xQ > DdN ) {

                return null;

            }

            // Line intersects triangle, check if ray does.
            var QdN = -sign * diff.dot( normal );

            // t < 0, no intersection
            if ( QdN < 0 ) {

                return null;

            }

            // Ray intersects triangle.
            return this.at( QdN / DdN, optionalTarget );

        };

    }(),

    applyMatrix4: function( matrix4 ) {

        this.direction.add( this.origin ).applyMatrix4( matrix4 );
        this.origin.applyMatrix4( matrix4 );
        this.direction.sub( this.origin );
        this.direction.normalize();

        return this;

    },

    equals: function( ray ) {

        return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function( center, radius ) {

    this.center = ( center !== undefined ) ? center : new THREE.Vector3();
    this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

    constructor: THREE.Sphere,

    set: function( center, radius ) {

        this.center.copy( center );
        this.radius = radius;

        return this;

    },

    setFromPoints: function() {

        var box = new THREE.Box3();

        return function( points, optionalCenter ) {

            var center = this.center;

            if ( optionalCenter !== undefined ) {

                center.copy( optionalCenter );

            }
            else {

                box.setFromPoints( points ).center( center );

            }

            var maxRadiusSq = 0;

            for ( var i = 0, il = points.length; i < il; i++ ) {

                maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

            }

            this.radius = Math.sqrt( maxRadiusSq );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( sphere ) {

        this.center.copy( sphere.center );
        this.radius = sphere.radius;

        return this;

    },

    empty: function() {

        return ( this.radius <= 0 );

    },

    containsPoint: function( point ) {

        return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    },

    distanceToPoint: function( point ) {

        return ( point.distanceTo( this.center ) - this.radius );

    },

    intersectsSphere: function( sphere ) {

        var radiusSum = this.radius + sphere.radius;

        return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    },

    clampPoint: function( point, optionalTarget ) {

        var deltaLengthSq = this.center.distanceToSquared( point );

        var result = optionalTarget || new THREE.Vector3();
        result.copy( point );

        if ( deltaLengthSq > ( this.radius * this.radius ) ) {

            result.sub( this.center ).normalize();
            result.multiplyScalar( this.radius ).add( this.center );

        }

        return result;

    },

    getBoundingBox: function( optionalTarget ) {

        var box = optionalTarget || new THREE.Box3();

        box.set( this.center, this.center );
        box.expandByScalar( this.radius );

        return box;

    },

    applyMatrix4: function( matrix ) {

        this.center.applyMatrix4( matrix );
        this.radius = this.radius * matrix.getMaxScaleOnAxis();

        return this;

    },

    translate: function( offset ) {

        this.center.add( offset );

        return this;

    },

    equals: function( sphere ) {

        return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function( p0, p1, p2, p3, p4, p5 ) {

    this.planes = [

        ( p0 !== undefined ) ? p0 : new THREE.Plane(), ( p1 !== undefined ) ? p1 : new THREE.Plane(), ( p2 !== undefined ) ? p2 : new THREE.Plane(), ( p3 !== undefined ) ? p3 : new THREE.Plane(), ( p4 !== undefined ) ? p4 : new THREE.Plane(), ( p5 !== undefined ) ? p5 : new THREE.Plane()

    ];

};

THREE.Frustum.prototype = {

    constructor: THREE.Frustum,

    set: function( p0, p1, p2, p3, p4, p5 ) {

        var planes = this.planes;

        planes[ 0 ].copy( p0 );
        planes[ 1 ].copy( p1 );
        planes[ 2 ].copy( p2 );
        planes[ 3 ].copy( p3 );
        planes[ 4 ].copy( p4 );
        planes[ 5 ].copy( p5 );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( frustum ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i++ ) {

            planes[ i ].copy( frustum.planes[ i ] );

        }

        return this;

    },

    setFromMatrix: function( m ) {

        var planes = this.planes;
        var me = m.elements;
        var me0 = me[ 0 ],
            me1 = me[ 1 ],
            me2 = me[ 2 ],
            me3 = me[ 3 ];
        var me4 = me[ 4 ],
            me5 = me[ 5 ],
            me6 = me[ 6 ],
            me7 = me[ 7 ];
        var me8 = me[ 8 ],
            me9 = me[ 9 ],
            me10 = me[ 10 ],
            me11 = me[ 11 ];
        var me12 = me[ 12 ],
            me13 = me[ 13 ],
            me14 = me[ 14 ],
            me15 = me[ 15 ];

        planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
        planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
        planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
        planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
        planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
        planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

        return this;

    },

    intersectsObject: function() {

        var sphere = new THREE.Sphere();

        return function( object ) {

            var geometry = object.geometry;

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( object.matrixWorld );

            return this.intersectsSphere( sphere );

        };

    }(),

    intersectsSphere: function( sphere ) {

        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;

        for ( var i = 0; i < 6; i++ ) {

            var distance = planes[ i ].distanceToPoint( center );

            if ( distance < negRadius ) {

                return false;

            }

        }

        return true;

    },

    intersectsBox: function() {

        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();

        return function( box ) {

            var planes = this.planes;

            for ( var i = 0; i < 6; i++ ) {

                var plane = planes[ i ];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint( p1 );
                var d2 = plane.distanceToPoint( p2 );

                // if both outside plane, no intersection

                if ( d1 < 0 && d2 < 0 ) {

                    return false;

                }

            }

            return true;

        };

    }(),


    containsPoint: function( point ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i++ ) {

            if ( planes[ i ].distanceToPoint( point ) < 0 ) {

                return false;

            }

        }

        return true;

    }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function( normal, constant ) {

    this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
    this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

    constructor: THREE.Plane,

    set: function( normal, constant ) {

        this.normal.copy( normal );
        this.constant = constant;

        return this;

    },

    setComponents: function( x, y, z, w ) {

        this.normal.set( x, y, z );
        this.constant = w;

        return this;

    },

    setFromNormalAndCoplanarPoint: function( normal, point ) {

        this.normal.copy( normal );
        this.constant = -point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

        return this;

    },

    setFromCoplanarPoints: function() {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();

        return function( a, b, c ) {

            var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

            this.setFromNormalAndCoplanarPoint( normal, a );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( plane ) {

        this.normal.copy( plane.normal );
        this.constant = plane.constant;

        return this;

    },

    normalize: function() {

        // Note: will lead to a divide by zero if the plane is invalid.

        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar( inverseNormalLength );
        this.constant *= inverseNormalLength;

        return this;

    },

    negate: function() {

        this.constant *= -1;
        this.normal.negate();

        return this;

    },

    distanceToPoint: function( point ) {

        return this.normal.dot( point ) + this.constant;

    },

    distanceToSphere: function( sphere ) {

        return this.distanceToPoint( sphere.center ) - sphere.radius;

    },

    projectPoint: function( point, optionalTarget ) {

        return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    },

    orthoPoint: function( point, optionalTarget ) {

        var perpendicularMagnitude = this.distanceToPoint( point );

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    },

    isIntersectionLine: function( line ) {

        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

        var startSign = this.distanceToPoint( line.start );
        var endSign = this.distanceToPoint( line.end );

        return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    },

    intersectLine: function() {

        var v1 = new THREE.Vector3();

        return function( line, optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            var direction = line.delta( v1 );

            var denominator = this.normal.dot( direction );

            if ( denominator === 0 ) {

                // line is coplanar, return origin
                if ( this.distanceToPoint( line.start ) === 0 ) {

                    return result.copy( line.start );

                }

                // Unsure if this is the correct method to handle this case.
                return undefined;

            }

            var t = -( line.start.dot( this.normal ) + this.constant ) / denominator;

            if ( t < 0 || t > 1 ) {

                return undefined;

            }

            return result.copy( direction ).multiplyScalar( t ).add( line.start );

        };

    }(),


    coplanarPoint: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( -this.constant );

    },

    applyMatrix4: function() {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();

        return function( matrix, optionalNormalMatrix ) {

            // compute new normal based on theory here:
            // http://www.songho.ca/opengl/gl_normaltransform.html
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
            var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

            var newCoplanarPoint = this.coplanarPoint( v2 );
            newCoplanarPoint.applyMatrix4( matrix );

            this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

            return this;

        };

    }(),

    translate: function( offset ) {

        this.constant = this.constant - offset.dot( this.normal );

        return this;

    },

    equals: function( plane ) {

        return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

    generateUUID: function() {

        // http://www.broofa.com/Tools/Math.uuid.htm

        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
        var uuid = new Array( 36 );
        var rnd = 0,
            r;

        return function() {

            for ( var i = 0; i < 36; i++ ) {

                if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

                    uuid[ i ] = '-';

                }
                else if ( i === 14 ) {

                    uuid[ i ] = '4';

                }
                else {

                    if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

                }

            }

            return uuid.join( '' );

        };

    }(),

    // Clamp value to range <a, b>

    clamp: function( x, a, b ) {

        return ( x < a ) ? a : ( ( x > b ) ? b : x );

    },

    // Clamp value to range <a, inf)

    clampBottom: function( x, a ) {

        return x < a ? a : x;

    },

    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation

    euclideanModulo: function( n, m ) {

        return ( ( n % m ) + m ) % m;

    },

    // Linear mapping from range <a1, a2> to range <b1, b2>

    mapLinear: function( x, a1, a2, b1, b2 ) {

        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    },

    // http://en.wikipedia.org/wiki/Smoothstep

    smoothstep: function( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * ( 3 - 2 * x );

    },

    smootherstep: function( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    },

    // Random float from <0, 1> with 16 bits of randomness
    // (standard Math.random() creates repetitive patterns when applied over larger space)

    random16: function() {

        return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

    },

    // Random integer from <low, high> interval

    randInt: function( low, high ) {

        return low + Math.floor( Math.random() * ( high - low + 1 ) );

    },

    // Random float from <low, high> interval

    randFloat: function( low, high ) {

        return low + Math.random() * ( high - low );

    },

    // Random float from <-range/2, range/2> interval

    randFloatSpread: function( range ) {

        return range * ( 0.5 - Math.random() );

    },

    degToRad: function() {

        var degreeToRadiansFactor = Math.PI / 180;

        return function( degrees ) {

            return degrees * degreeToRadiansFactor;

        };

    }(),

    radToDeg: function() {

        var radianToDegreesFactor = 180 / Math.PI;

        return function( radians ) {

            return radians * radianToDegreesFactor;

        };

    }(),

    isPowerOfTwo: function( value ) {

        return ( value & ( value - 1 ) ) === 0 && value !== 0;

    },

    nextPowerOfTwo: function( value ) {

        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;

        return value;

    }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function( points ) {

    this.points = points;

    var c = [],
        v3 = {
            x: 0,
            y: 0,
            z: 0
        },
        point, intPoint, weight, w2, w3,
        pa, pb, pc, pd;

    this.initFromArray = function( a ) {

        this.points = [];

        for ( var i = 0; i < a.length; i++ ) {

            this.points[ i ] = {
                x: a[ i ][ 0 ],
                y: a[ i ][ 1 ],
                z: a[ i ][ 2 ]
            };

        }

    };

    this.getPoint = function( k ) {

        point = ( this.points.length - 1 ) * k;
        intPoint = Math.floor( point );
        weight = point - intPoint;

        c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
        c[ 1 ] = intPoint;
        c[ 2 ] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[ 3 ] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

        pa = this.points[ c[ 0 ] ];
        pb = this.points[ c[ 1 ] ];
        pc = this.points[ c[ 2 ] ];
        pd = this.points[ c[ 3 ] ];

        w2 = weight * weight;
        w3 = weight * w2;

        v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
        v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
        v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

        return v3;

    };

    this.getControlPointsArray = function() {

        var i, p, l = this.points.length,
            coords = [];

        for ( i = 0; i < l; i++ ) {

            p = this.points[ i ];
            coords[ i ] = [ p.x, p.y, p.z ];

        }

        return coords;

    };

    // approximate length by summing linear segments

    this.getLength = function( nSubDivisions ) {

        var i, index, nSamples, position,
            point = 0,
            intPoint = 0,
            oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;

        // first point has 0 length

        chunkLengths[ 0 ] = 0;

        if ( !nSubDivisions ) nSubDivisions = 100;

        nSamples = this.points.length * nSubDivisions;

        oldPosition.copy( this.points[ 0 ] );

        for ( i = 1; i < nSamples; i++ ) {

            index = i / nSamples;

            position = this.getPoint( index );
            tmpVec.copy( position );

            totalLength += tmpVec.distanceTo( oldPosition );

            oldPosition.copy( position );

            point = ( this.points.length - 1 ) * index;
            intPoint = Math.floor( point );

            if ( intPoint !== oldIntPoint ) {

                chunkLengths[ intPoint ] = totalLength;
                oldIntPoint = intPoint;

            }

        }

        // last point ends with total length

        chunkLengths[ chunkLengths.length ] = totalLength;

        return {
            chunks: chunkLengths,
            total: totalLength
        };

    };

    this.reparametrizeByArcLength = function( samplingCoef ) {

        var i, j,
            index, indexCurrent, indexNext,
            realDistance,
            sampling, position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();

        newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

        for ( i = 1; i < this.points.length; i++ ) {

            //tmpVec.copy( this.points[ i - 1 ] );
            //linearDistance = tmpVec.distanceTo( this.points[ i ] );

            realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

            sampling = Math.ceil( samplingCoef * realDistance / sl.total );

            indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
            indexNext = i / ( this.points.length - 1 );

            for ( j = 1; j < sampling - 1; j++ ) {

                index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

                position = this.getPoint( index );
                newpoints.push( tmpVec.copy( position ).clone() );

            }

            newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

        }

        this.points = newpoints;

    };

    // Catmull-Rom

    function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

        var v0 = ( p2 - p0 ) * 0.5,
            v1 = ( p3 - p1 ) * 0.5;

        return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( -3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function( a, b, c ) {

    this.a = ( a !== undefined ) ? a : new THREE.Vector3();
    this.b = ( b !== undefined ) ? b : new THREE.Vector3();
    this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

    var v0 = new THREE.Vector3();

    return function( a, b, c, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        result.subVectors( c, b );
        v0.subVectors( a, b );
        result.cross( v0 );

        var resultLengthSq = result.lengthSq();
        if ( resultLengthSq > 0 ) {

            return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

        }

        return result.set( 0, 0, 0 );

    };

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function( point, a, b, c, optionalTarget ) {

        v0.subVectors( c, a );
        v1.subVectors( b, a );
        v2.subVectors( point, a );

        var dot00 = v0.dot( v0 );
        var dot01 = v0.dot( v1 );
        var dot02 = v0.dot( v2 );
        var dot11 = v1.dot( v1 );
        var dot12 = v1.dot( v2 );

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        var result = optionalTarget || new THREE.Vector3();

        // collinear or singular triangle
        if ( denom === 0 ) {

            // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return result.set( -2, -1, -1 );

        }

        var invDenom = 1 / denom;
        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        // barycentric coordinates must always sum to 1
        return result.set( 1 - u - v, v, u );

    };

}();

THREE.Triangle.containsPoint = function() {

    var v1 = new THREE.Vector3();

    return function( point, a, b, c ) {

        var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

        return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    };

}();

THREE.Triangle.prototype = {

    constructor: THREE.Triangle,

    set: function( a, b, c ) {

        this.a.copy( a );
        this.b.copy( b );
        this.c.copy( c );

        return this;

    },

    setFromPointsAndIndices: function( points, i0, i1, i2 ) {

        this.a.copy( points[ i0 ] );
        this.b.copy( points[ i1 ] );
        this.c.copy( points[ i2 ] );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( triangle ) {

        this.a.copy( triangle.a );
        this.b.copy( triangle.b );
        this.c.copy( triangle.c );

        return this;

    },

    area: function() {

        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();

        return function() {

            v0.subVectors( this.c, this.b );
            v1.subVectors( this.a, this.b );

            return v0.cross( v1 ).length() * 0.5;

        };

    }(),

    midpoint: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    },

    normal: function( optionalTarget ) {

        return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

    },

    plane: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Plane();

        return result.setFromCoplanarPoints( this.a, this.b, this.c );

    },

    barycoordFromPoint: function( point, optionalTarget ) {

        return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    },

    containsPoint: function( point ) {

        return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

    },

    equals: function( triangle ) {

        return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function( autoStart ) {

    this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;

    this.running = false;

};

THREE.Clock.prototype = {

    constructor: THREE.Clock,

    start: function() {

        this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();

        this.oldTime = this.startTime;
        this.running = true;

    },

    stop: function() {

        this.getElapsedTime();
        this.running = false;

    },

    getElapsedTime: function() {

        this.getDelta();
        return this.elapsedTime;

    },

    getDelta: function() {

        var diff = 0;

        if ( this.autoStart && !this.running ) {

            this.start();

        }

        if ( this.running ) {

            var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();

            diff = 0.001 * ( newTime - this.oldTime );
            this.oldTime = newTime;

            this.elapsedTime += diff;

        }

        return diff;

    }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function() {};

THREE.EventDispatcher.prototype = {

    constructor: THREE.EventDispatcher,

    apply: function( object ) {

        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

    },

    addEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) this._listeners = {};

        var listeners = this._listeners;

        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === -1 ) {

            listeners[ type ].push( listener );

        }

    },

    hasEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) return false;

        var listeners = this._listeners;

        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1 ) {

            return true;

        }

        return false;

    },

    removeEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ type ];

        if ( listenerArray !== undefined ) {

            var index = listenerArray.indexOf( listener );

            if ( index !== -1 ) {

                listenerArray.splice( index, 1 );

            }

        }

    },

    dispatchEvent: function( event ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];

        if ( listenerArray !== undefined ) {

            event.target = this;

            var array = [];
            var length = listenerArray.length;

            for ( var i = 0; i < length; i++ ) {

                array[ i ] = listenerArray[ i ];

            }

            for ( var i = 0; i < length; i++ ) {

                array[ i ].call( this, event );

            }

        }

    }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function( THREE ) {

    THREE.Raycaster = function( origin, direction, near, far ) {

        this.ray = new THREE.Ray( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)

        this.near = near || 0;
        this.far = far || Infinity;

        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };

        Object.defineProperties( this.params, {
            PointCloud: {
                get: function() {
                    console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
                    return this.Points;
                }
            }
        } );

    };

    function descSort( a, b ) {

        return a.distance - b.distance;

    }

    var intersectObject = function( object, raycaster, intersects, recursive ) {

        if ( object.visible === false ) return;

        object.raycast( raycaster, intersects );

        if ( recursive === true ) {

            var children = object.children;

            for ( var i = 0, l = children.length; i < l; i++ ) {

                intersectObject( children[ i ], raycaster, intersects, true );

            }

        }

    };

    //

    THREE.Raycaster.prototype = {

        constructor: THREE.Raycaster,

        linePrecision: 1,

        set: function( origin, direction ) {

            // direction is assumed to be normalized (for accurate distance calculations)

            this.ray.set( origin, direction );

        },

        setFromCamera: function( coords, camera ) {

            if ( camera instanceof THREE.PerspectiveCamera ) {

                this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
                this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

            }
            else if ( camera instanceof THREE.OrthographicCamera ) {

                this.ray.origin.set( coords.x, coords.y, -1 ).unproject( camera );
                this.ray.direction.set( 0, 0, -1 ).transformDirection( camera.matrixWorld );

            }
            else {

                console.error( 'THREE.Raycaster: Unsupported camera type.' );

            }

        },

        intersectObject: function( object, recursive ) {

            var intersects = [];

            intersectObject( object, this, intersects, recursive );

            intersects.sort( descSort );

            return intersects;

        },

        intersectObjects: function( objects, recursive ) {

            var intersects = [];

            if ( Array.isArray( objects ) === false ) {

                console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
                return intersects;

            }

            for ( var i = 0, l = objects.length; i < l; i++ ) {

                intersectObject( objects[ i ], this, intersects, recursive );

            }

            intersects.sort( descSort );

            return intersects;

        }

    };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.Object3DIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Object3D';

    this.parent = null;
    this.children = [];

    this.up = THREE.Object3D.DefaultUp.clone();

    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3( 1, 1, 1 );

    var onRotationChange = function() {

        quaternion.setFromEuler( rotation, false );

    };

    var onQuaternionChange = function() {

        rotation.setFromQuaternion( quaternion, undefined, false );

    };

    rotation.onChange( onRotationChange );
    quaternion.onChange( onQuaternionChange );

    Object.defineProperties( this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new THREE.Matrix4()
        },
        normalMatrix: {
            value: new THREE.Matrix3()
        }
    } );

    this.rotationAutoUpdate = true;

    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();

    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;

    this.visible = true;

    this.castShadow = false;
    this.receiveShadow = false;

    this.frustumCulled = true;
    this.renderOrder = 0;

    this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

    constructor: THREE.Object3D,

    get eulerOrder() {

        console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

        return this.rotation.order;

    },

    set eulerOrder( value ) {

        console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

        this.rotation.order = value;

    },

    get useQuaternion() {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set useQuaternion( value ) {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set renderDepth( value ) {

        console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

    },

    applyMatrix: function( matrix ) {

        this.matrix.multiplyMatrices( matrix, this.matrix );

        this.matrix.decompose( this.position, this.quaternion, this.scale );

    },

    setRotationFromAxisAngle: function( axis, angle ) {

        // assumes axis is normalized

        this.quaternion.setFromAxisAngle( axis, angle );

    },

    setRotationFromEuler: function( euler ) {

        this.quaternion.setFromEuler( euler, true );

    },

    setRotationFromMatrix: function( m ) {

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        this.quaternion.setFromRotationMatrix( m );

    },

    setRotationFromQuaternion: function( q ) {

        // assumes q is normalized

        this.quaternion.copy( q );

    },

    rotateOnAxis: function() {

        // rotate object on axis in object space
        // axis is assumed to be normalized

        var q1 = new THREE.Quaternion();

        return function( axis, angle ) {

            q1.setFromAxisAngle( axis, angle );

            this.quaternion.multiply( q1 );

            return this;

        };

    }(),

    rotateX: function() {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateY: function() {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateZ: function() {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    translateOnAxis: function() {

        // translate object by distance along axis in object space
        // axis is assumed to be normalized

        var v1 = new THREE.Vector3();

        return function( axis, distance ) {

            v1.copy( axis ).applyQuaternion( this.quaternion );

            this.position.add( v1.multiplyScalar( distance ) );

            return this;

        };

    }(),

    translate: function( distance, axis ) {

        console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
        return this.translateOnAxis( axis, distance );

    },

    translateX: function() {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateY: function() {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateZ: function() {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    localToWorld: function( vector ) {

        return vector.applyMatrix4( this.matrixWorld );

    },

    worldToLocal: function() {

        var m1 = new THREE.Matrix4();

        return function( vector ) {

            return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

        };

    }(),

    lookAt: function() {

        // This routine does not support objects with rotated and/or translated parent(s)

        var m1 = new THREE.Matrix4();

        return function( vector ) {

            m1.lookAt( vector, this.position, this.up );

            this.quaternion.setFromRotationMatrix( m1 );

        };

    }(),

    add: function( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i++ ) {

                this.add( arguments[ i ] );

            }

            return this;

        }

        if ( object === this ) {

            console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
            return this;

        }

        if ( object instanceof THREE.Object3D ) {

            if ( object.parent !== null ) {

                object.parent.remove( object );

            }

            object.parent = this;
            object.dispatchEvent( {
                type: 'added'
            } );

            this.children.push( object );

        }
        else {

            console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

        }

        return this;

    },

    remove: function( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i++ ) {

                this.remove( arguments[ i ] );

            }

        }

        var index = this.children.indexOf( object );

        if ( index !== -1 ) {

            object.parent = null;

            object.dispatchEvent( {
                type: 'removed'
            } );

            this.children.splice( index, 1 );

        }

    },

    getChildByName: function( name ) {

        console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
        return this.getObjectByName( name );

    },

    getObjectById: function( id ) {

        return this.getObjectByProperty( 'id', id );

    },

    getObjectByName: function( name ) {

        return this.getObjectByProperty( 'name', name );

    },

    getObjectByProperty: function( name, value ) {

        if ( this[ name ] === value ) return this;

        for ( var i = 0, l = this.children.length; i < l; i++ ) {

            var child = this.children[ i ];
            var object = child.getObjectByProperty( name, value );

            if ( object !== undefined ) {

                return object;

            }

        }

        return undefined;

    },

    getWorldPosition: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.updateMatrixWorld( true );

        return result.setFromMatrixPosition( this.matrixWorld );

    },

    getWorldQuaternion: function() {

        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Quaternion();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, result, scale );

            return result;

        };

    }(),

    getWorldRotation: function() {

        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Euler();

            this.getWorldQuaternion( quaternion );

            return result.setFromQuaternion( quaternion, this.rotation.order, false );

        };

    }(),

    getWorldScale: function() {

        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, quaternion, result );

            return result;

        };

    }(),

    getWorldDirection: function() {

        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.getWorldQuaternion( quaternion );

            return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

        };

    }(),

    raycast: function() {},

    traverse: function( callback ) {

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            children[ i ].traverse( callback );

        }

    },

    traverseVisible: function( callback ) {

        if ( this.visible === false ) return;

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            children[ i ].traverseVisible( callback );

        }

    },

    traverseAncestors: function( callback ) {

        var parent = this.parent;

        if ( parent !== null ) {

            callback( parent );

            parent.traverseAncestors( callback );

        }

    },

    updateMatrix: function() {

        this.matrix.compose( this.position, this.quaternion, this.scale );

        this.matrixWorldNeedsUpdate = true;

    },

    updateMatrixWorld: function( force ) {

        if ( this.matrixAutoUpdate === true ) this.updateMatrix();

        if ( this.matrixWorldNeedsUpdate === true || force === true ) {

            if ( this.parent === null ) {

                this.matrixWorld.copy( this.matrix );

            }
            else {

                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

            }

            this.matrixWorldNeedsUpdate = false;

            force = true;

        }

        // update children

        for ( var i = 0, l = this.children.length; i < l; i++ ) {

            this.children[ i ].updateMatrixWorld( force );

        }

    },

    toJSON: function( meta ) {

        var isRootObject = ( meta === undefined );

        var data = {};

        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if ( isRootObject ) {

            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            };

            data.metadata = {
                version: 4.4,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };

        }

        // standard Object3D serialization

        data.uuid = this.uuid;
        data.type = this.type;

        if ( this.name !== '' ) data.name = this.name;
        if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
        if ( this.visible !== true ) data.visible = this.visible;

        data.matrix = this.matrix.toArray();

        if ( this.children.length > 0 ) {

            data.children = [];

            for ( var i = 0; i < this.children.length; i++ ) {

                data.children.push( this.children[ i ].toJSON( meta ).object );

            }

        }

        var output = {};

        if ( isRootObject ) {

            var geometries = extractFromCache( meta.geometries );
            var materials = extractFromCache( meta.materials );
            var textures = extractFromCache( meta.textures );
            var images = extractFromCache( meta.images );

            if ( geometries.length > 0 ) output.geometries = geometries;
            if ( materials.length > 0 ) output.materials = materials;
            if ( textures.length > 0 ) output.textures = textures;
            if ( images.length > 0 ) output.images = images;

        }

        output.object = data;

        return output;

        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache( cache ) {

            var values = [];
            for ( var key in cache ) {

                var data = cache[ key ];
                delete data.metadata;
                values.push( data );

            }
            return values;

        }

    },

    clone: function( recursive ) {

        return new this.constructor().copy( this, recursive );

    },

    copy: function( source, recursive ) {

        if ( recursive === undefined ) recursive = true;

        this.name = source.name;

        this.up.copy( source.up );

        this.position.copy( source.position );
        this.quaternion.copy( source.quaternion );
        this.scale.copy( source.scale );

        this.rotationAutoUpdate = source.rotationAutoUpdate;

        this.matrix.copy( source.matrix );
        this.matrixWorld.copy( source.matrixWorld );

        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

        this.visible = source.visible;

        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;

        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;

        this.userData = JSON.parse( JSON.stringify( source.userData ) );

        if ( recursive === true ) {

            for ( var i = 0; i < source.children.length; i++ ) {

                var child = source.children[ i ];
                this.add( child.clone() );

            }

        }

        return this;

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function( a, b, c, normal, color, materialIndex ) {

    this.a = a;
    this.b = b;
    this.c = c;

    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
    this.vertexNormals = Array.isArray( normal ) ? normal : [];

    this.color = color instanceof THREE.Color ? color : new THREE.Color();
    this.vertexColors = Array.isArray( color ) ? color : [];

    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

    constructor: THREE.Face3,

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.a = source.a;
        this.b = source.b;
        this.c = source.c;

        this.normal.copy( source.normal );
        this.color.copy( source.color );

        this.materialIndex = source.materialIndex;

        for ( var i = 0, il = source.vertexNormals.length; i < il; i++ ) {

            this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

        }

        for ( var i = 0, il = source.vertexColors.length; i < il; i++ ) {

            this.vertexColors[ i ] = source.vertexColors[ i ].clone();

        }

        return this;

    }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function( a, b, c, d, normal, color, materialIndex ) {

    console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function( array, itemSize ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.itemSize = itemSize;

    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };

    this.version = 0;

};

THREE.BufferAttribute.prototype = {

    constructor: THREE.BufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.array.length / this.itemSize;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    setDynamic: function( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function( source ) {

        this.array = new source.array.constructor( source.array );
        this.itemSize = source.itemSize;

        this.dynamic = source.dynamic;

        return this;

    },

    copyAt: function( index1, attribute, index2 ) {

        index1 *= this.itemSize;
        index2 *= attribute.itemSize;

        for ( var i = 0, l = this.itemSize; i < l; i++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    copyArray: function( array ) {

        this.array.set( array );

        return this;

    },

    copyColorsArray: function( colors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = colors.length; i < l; i++ ) {

            var color = colors[ i ];

            if ( color === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
                color = new THREE.Color();

            }

            array[ offset++ ] = color.r;
            array[ offset++ ] = color.g;
            array[ offset++ ] = color.b;

        }

        return this;

    },

    copyIndicesArray: function( indices ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = indices.length; i < l; i++ ) {

            var index = indices[ i ];

            array[ offset++ ] = index.a;
            array[ offset++ ] = index.b;
            array[ offset++ ] = index.c;

        }

        return this;

    },

    copyVector2sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
                vector = new THREE.Vector2();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;

        }

        return this;

    },

    copyVector3sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
                vector = new THREE.Vector3();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;
            array[ offset++ ] = vector.z;

        }

        return this;

    },

    copyVector4sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
                vector = new THREE.Vector4();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;
            array[ offset++ ] = vector.z;
            array[ offset++ ] = vector.w;

        }

        return this;

    },

    set: function( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    getX: function( index ) {

        return this.array[ index * this.itemSize ];

    },

    setX: function( index, x ) {

        this.array[ index * this.itemSize ] = x;

        return this;

    },

    getY: function( index ) {

        return this.array[ index * this.itemSize + 1 ];

    },

    setY: function( index, y ) {

        this.array[ index * this.itemSize + 1 ] = y;

        return this;

    },

    getZ: function( index ) {

        return this.array[ index * this.itemSize + 2 ];

    },

    setZ: function( index, z ) {

        this.array[ index * this.itemSize + 2 ] = z;

        return this;

    },

    getW: function( index ) {

        return this.array[ index * this.itemSize + 3 ];

    },

    setW: function( index, w ) {

        this.array[ index * this.itemSize + 3 ] = w;

        return this;

    },

    setXY: function( index, x, y ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function( index, x, y, z ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function( index, x, y, z, w ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;
        this.array[ index + 3 ] = w;

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    }

};

//

THREE.Int8Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function( array, itemSize ) {

    console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function( array, itemSize, meshPerAttribute ) {

    THREE.BufferAttribute.call( this, array, itemSize );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function( source ) {

    THREE.BufferAttribute.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function( array, stride ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.stride = stride;

    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };

    this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

    constructor: THREE.InterleavedBuffer,

    get length() {

        return this.array.length;

    },

    get count() {

        return this.array.length / this.stride;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    setDynamic: function( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function( source ) {

        this.array = new source.array.constructor( source.array );
        this.stride = source.stride;
        this.dynamic = source.dynamic;

    },

    copyAt: function( index1, attribute, index2 ) {

        index1 *= this.stride;
        index2 *= attribute.stride;

        for ( var i = 0, l = this.stride; i < l; i++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    set: function( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function( array, stride, meshPerAttribute ) {

    THREE.InterleavedBuffer.call( this, array, stride );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function( source ) {

    THREE.InterleavedBuffer.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function( interleavedBuffer, itemSize, offset ) {

    this.uuid = THREE.Math.generateUUID();

    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

    constructor: THREE.InterleavedBufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.data.array.length / this.data.stride;

    },

    setX: function( index, x ) {

        this.data.array[ index * this.data.stride + this.offset ] = x;

        return this;

    },

    setY: function( index, y ) {

        this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

        return this;

    },

    setZ: function( index, z ) {

        this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

        return this;

    },

    setW: function( index, w ) {

        this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

        return this;

    },

    getX: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset ];

    },

    getY: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 1 ];

    },

    getZ: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 2 ];

    },

    getW: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 3 ];

    },

    setXY: function( index, x, y ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function( index, x, y, z ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function( index, x, y, z, w ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;
        this.data.array[ index + 3 ] = w;

        return this;

    }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Geometry';

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];

    this.morphTargets = [];
    this.morphColors = [];
    this.morphNormals = [];

    this.skinWeights = [];
    this.skinIndices = [];

    this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.elementsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

    constructor: THREE.Geometry,

    applyMatrix: function( matrix ) {

        var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        for ( var i = 0, il = this.vertices.length; i < il; i++ ) {

            var vertex = this.vertices[ i ];
            vertex.applyMatrix4( matrix );

        }

        for ( var i = 0, il = this.faces.length; i < il; i++ ) {

            var face = this.faces[ i ];
            face.normal.applyMatrix3( normalMatrix ).normalize();

            for ( var j = 0, jl = face.vertexNormals.length; j < jl; j++ ) {

                face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

            }

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;

    },

    rotateX: function() {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function() {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function() {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function() {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function() {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function() {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    fromBufferGeometry: function( geometry ) {

        var scope = this;

        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;

        var vertices = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

        if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];

        for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

            scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

            if ( normals !== undefined ) {

                tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

            }

            if ( colors !== undefined ) {

                scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

            }

            if ( uvs !== undefined ) {

                tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

            }

            if ( uvs2 !== undefined ) {

                tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

            }

        }

        var addFace = function( a, b, c ) {

            var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
            var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

            var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

            scope.faces.push( face );

            if ( uvs !== undefined ) {

                scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

            }

            if ( uvs2 !== undefined ) {

                scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

            }

        };

        if ( indices !== undefined ) {

            var groups = geometry.groups;

            if ( groups.length > 0 ) {

                for ( var i = 0; i < groups.length; i++ ) {

                    var group = groups[ i ];

                    var start = group.start;
                    var count = group.count;

                    for ( var j = start, jl = start + count; j < jl; j += 3 ) {

                        addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

                    }

                }

            }
            else {

                for ( var i = 0; i < indices.length; i += 3 ) {

                    addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                }

            }

        }
        else {

            for ( var i = 0; i < vertices.length / 3; i += 3 ) {

                addFace( i, i + 1, i + 2 );

            }

        }

        this.computeFaceNormals();

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        return this;

    },

    center: function() {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    normalize: function() {

        this.computeBoundingSphere();

        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;

        var s = radius === 0 ? 1 : 1.0 / radius;

        var matrix = new THREE.Matrix4();
        matrix.set(
            s, 0, 0, -s * center.x,
            0, s, 0, -s * center.y,
            0, 0, s, -s * center.z,
            0, 0, 0, 1
        );

        this.applyMatrix( matrix );

        return this;

    },

    computeFaceNormals: function() {

        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();

        for ( var f = 0, fl = this.faces.length; f < fl; f++ ) {

            var face = this.faces[ f ];

            var vA = this.vertices[ face.a ];
            var vB = this.vertices[ face.b ];
            var vC = this.vertices[ face.c ];

            cb.subVectors( vC, vB );
            ab.subVectors( vA, vB );
            cb.cross( ab );

            cb.normalize();

            face.normal.copy( cb );

        }

    },

    computeVertexNormals: function( areaWeighted ) {

        var v, vl, f, fl, face, vertices;

        vertices = new Array( this.vertices.length );

        for ( v = 0, vl = this.vertices.length; v < vl; v++ ) {

            vertices[ v ] = new THREE.Vector3();

        }

        if ( areaWeighted ) {

            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm

            var vA, vB, vC;
            var cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                vA = this.vertices[ face.a ];
                vB = this.vertices[ face.b ];
                vC = this.vertices[ face.c ];

                cb.subVectors( vC, vB );
                ab.subVectors( vA, vB );
                cb.cross( ab );

                vertices[ face.a ].add( cb );
                vertices[ face.b ].add( cb );
                vertices[ face.c ].add( cb );

            }

        }
        else {

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                vertices[ face.a ].add( face.normal );
                vertices[ face.b ].add( face.normal );
                vertices[ face.c ].add( face.normal );

            }

        }

        for ( v = 0, vl = this.vertices.length; v < vl; v++ ) {

            vertices[ v ].normalize();

        }

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                vertexNormals[ 0 ].copy( vertices[ face.a ] );
                vertexNormals[ 1 ].copy( vertices[ face.b ] );
                vertexNormals[ 2 ].copy( vertices[ face.c ] );

            }
            else {

                vertexNormals[ 0 ] = vertices[ face.a ].clone();
                vertexNormals[ 1 ] = vertices[ face.b ].clone();
                vertexNormals[ 2 ] = vertices[ face.c ].clone();

            }

        }

    },

    computeMorphNormals: function() {

        var i, il, f, fl, face;

        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            if ( !face.__originalFaceNormal ) {

                face.__originalFaceNormal = face.normal.clone();

            }
            else {

                face.__originalFaceNormal.copy( face.normal );

            }

            if ( !face.__originalVertexNormals ) face.__originalVertexNormals = [];

            for ( i = 0, il = face.vertexNormals.length; i < il; i++ ) {

                if ( !face.__originalVertexNormals[ i ] ) {

                    face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

                }
                else {

                    face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

                }

            }

        }

        // use temp geometry to compute face and vertex normals for each morph

        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;

        for ( i = 0, il = this.morphTargets.length; i < il; i++ ) {

            // create on first access

            if ( !this.morphNormals[ i ] ) {

                this.morphNormals[ i ] = {};
                this.morphNormals[ i ].faceNormals = [];
                this.morphNormals[ i ].vertexNormals = [];

                var dstNormalsFace = this.morphNormals[ i ].faceNormals;
                var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

                var faceNormal, vertexNormals;

                for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                    faceNormal = new THREE.Vector3();
                    vertexNormals = {
                        a: new THREE.Vector3(),
                        b: new THREE.Vector3(),
                        c: new THREE.Vector3()
                    };

                    dstNormalsFace.push( faceNormal );
                    dstNormalsVertex.push( vertexNormals );

                }

            }

            var morphNormals = this.morphNormals[ i ];

            // set vertices to morph target

            tmpGeo.vertices = this.morphTargets[ i ].vertices;

            // compute morph normals

            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();

            // store morph normals

            var faceNormal, vertexNormals;

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                faceNormal = morphNormals.faceNormals[ f ];
                vertexNormals = morphNormals.vertexNormals[ f ];

                faceNormal.copy( face.normal );

                vertexNormals.a.copy( face.vertexNormals[ 0 ] );
                vertexNormals.b.copy( face.vertexNormals[ 1 ] );
                vertexNormals.c.copy( face.vertexNormals[ 2 ] );

            }

        }

        // restore original normals

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;

        }

    },

    computeTangents: function() {

        console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    },

    computeLineDistances: function() {

        var d = 0;
        var vertices = this.vertices;

        for ( var i = 0, il = vertices.length; i < il; i++ ) {

            if ( i > 0 ) {

                d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

            }

            this.lineDistances[ i ] = d;

        }

    },

    computeBoundingBox: function() {

        if ( this.boundingBox === null ) {

            this.boundingBox = new THREE.Box3();

        }

        this.boundingBox.setFromPoints( this.vertices );

    },

    computeBoundingSphere: function() {

        if ( this.boundingSphere === null ) {

            this.boundingSphere = new THREE.Sphere();

        }

        this.boundingSphere.setFromPoints( this.vertices );

    },

    merge: function( geometry, matrix, materialIndexOffset ) {

        if ( geometry instanceof THREE.Geometry === false ) {

            console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
            return;

        }

        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[ 0 ],
            uvs2 = geometry.faceVertexUvs[ 0 ];

        if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

        if ( matrix !== undefined ) {

            normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        }

        // vertices

        for ( var i = 0, il = vertices2.length; i < il; i++ ) {

            var vertex = vertices2[ i ];

            var vertexCopy = vertex.clone();

            if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

            vertices1.push( vertexCopy );

        }

        // faces

        for ( i = 0, il = faces2.length; i < il; i++ ) {

            var face = faces2[ i ],
                faceCopy, normal, color,
                faceVertexNormals = face.vertexNormals,
                faceVertexColors = face.vertexColors;

            faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
            faceCopy.normal.copy( face.normal );

            if ( normalMatrix !== undefined ) {

                faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

            }

            for ( var j = 0, jl = faceVertexNormals.length; j < jl; j++ ) {

                normal = faceVertexNormals[ j ].clone();

                if ( normalMatrix !== undefined ) {

                    normal.applyMatrix3( normalMatrix ).normalize();

                }

                faceCopy.vertexNormals.push( normal );

            }

            faceCopy.color.copy( face.color );

            for ( var j = 0, jl = faceVertexColors.length; j < jl; j++ ) {

                color = faceVertexColors[ j ];
                faceCopy.vertexColors.push( color.clone() );

            }

            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

            faces1.push( faceCopy );

        }

        // uvs

        for ( i = 0, il = uvs2.length; i < il; i++ ) {

            var uv = uvs2[ i ],
                uvCopy = [];

            if ( uv === undefined ) {

                continue;

            }

            for ( var j = 0, jl = uv.length; j < jl; j++ ) {

                uvCopy.push( uv[ j ].clone() );

            }

            uvs1.push( uvCopy );

        }

    },

    mergeMesh: function( mesh ) {

        if ( mesh instanceof THREE.Mesh === false ) {

            console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
            return;

        }

        mesh.matrixAutoUpdate && mesh.updateMatrix();

        this.merge( mesh.geometry, mesh.matrix );

    },

    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */

    mergeVertices: function() {

        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [],
            changes = [];

        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow( 10, precisionPoints );
        var i, il, face;
        var indices, j, jl;

        for ( i = 0, il = this.vertices.length; i < il; i++ ) {

            v = this.vertices[ i ];
            key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

            if ( verticesMap[ key ] === undefined ) {

                verticesMap[ key ] = i;
                unique.push( this.vertices[ i ] );
                changes[ i ] = unique.length - 1;

            }
            else {

                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                changes[ i ] = changes[ verticesMap[ key ] ];

            }

        }


        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];

        for ( i = 0, il = this.faces.length; i < il; i++ ) {

            face = this.faces[ i ];

            face.a = changes[ face.a ];
            face.b = changes[ face.b ];
            face.c = changes[ face.c ];

            indices = [ face.a, face.b, face.c ];

            var dupIndex = -1;

            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for ( var n = 0; n < 3; n++ ) {

                if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

                    dupIndex = n;
                    faceIndicesToRemove.push( i );
                    break;

                }

            }

        }

        for ( i = faceIndicesToRemove.length - 1; i >= 0; i-- ) {

            var idx = faceIndicesToRemove[ i ];

            this.faces.splice( idx, 1 );

            for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j++ ) {

                this.faceVertexUvs[ j ].splice( idx, 1 );

            }

        }

        // Use unique set of vertices

        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;

    },

    toJSON: function() {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };

        // standard Geometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        var vertices = [];

        for ( var i = 0; i < this.vertices.length; i++ ) {

            var vertex = this.vertices[ i ];
            vertices.push( vertex.x, vertex.y, vertex.z );

        }

        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};

        for ( var i = 0; i < this.faces.length; i++ ) {

            var face = this.faces[ i ];

            var hasMaterial = false; // face.materialIndex !== undefined;
            var hasFaceUv = false; // deprecated
            var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;

            var faceType = 0;

            faceType = setBit( faceType, 0, 0 );
            faceType = setBit( faceType, 1, hasMaterial );
            faceType = setBit( faceType, 2, hasFaceUv );
            faceType = setBit( faceType, 3, hasFaceVertexUv );
            faceType = setBit( faceType, 4, hasFaceNormal );
            faceType = setBit( faceType, 5, hasFaceVertexNormal );
            faceType = setBit( faceType, 6, hasFaceColor );
            faceType = setBit( faceType, 7, hasFaceVertexColor );

            faces.push( faceType );
            faces.push( face.a, face.b, face.c );

            if ( hasFaceVertexUv ) {

                var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

                faces.push(
                    getUvIndex( faceVertexUvs[ 0 ] ),
                    getUvIndex( faceVertexUvs[ 1 ] ),
                    getUvIndex( faceVertexUvs[ 2 ] )
                );

            }

            if ( hasFaceNormal ) {

                faces.push( getNormalIndex( face.normal ) );

            }

            if ( hasFaceVertexNormal ) {

                var vertexNormals = face.vertexNormals;

                faces.push(
                    getNormalIndex( vertexNormals[ 0 ] ),
                    getNormalIndex( vertexNormals[ 1 ] ),
                    getNormalIndex( vertexNormals[ 2 ] )
                );

            }

            if ( hasFaceColor ) {

                faces.push( getColorIndex( face.color ) );

            }

            if ( hasFaceVertexColor ) {

                var vertexColors = face.vertexColors;

                faces.push(
                    getColorIndex( vertexColors[ 0 ] ),
                    getColorIndex( vertexColors[ 1 ] ),
                    getColorIndex( vertexColors[ 2 ] )
                );

            }

        }

        function setBit( value, position, enabled ) {

            return enabled ? value | ( 1 << position ) : value & ( ~( 1 << position ) );

        }

        function getNormalIndex( normal ) {

            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

            if ( normalsHash[ hash ] !== undefined ) {

                return normalsHash[ hash ];

            }

            normalsHash[ hash ] = normals.length / 3;
            normals.push( normal.x, normal.y, normal.z );

            return normalsHash[ hash ];

        }

        function getColorIndex( color ) {

            var hash = color.r.toString() + color.g.toString() + color.b.toString();

            if ( colorsHash[ hash ] !== undefined ) {

                return colorsHash[ hash ];

            }

            colorsHash[ hash ] = colors.length;
            colors.push( color.getHex() );

            return colorsHash[ hash ];

        }

        function getUvIndex( uv ) {

            var hash = uv.x.toString() + uv.y.toString();

            if ( uvsHash[ hash ] !== undefined ) {

                return uvsHash[ hash ];

            }

            uvsHash[ hash ] = uvs.length / 2;
            uvs.push( uv.x, uv.y );

            return uvsHash[ hash ];

        }

        data.data = {};

        data.data.vertices = vertices;
        data.data.normals = normals;
        if ( colors.length > 0 ) data.data.colors = colors;
        if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
        data.data.faces = faces;

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];

        var vertices = source.vertices;

        for ( var i = 0, il = vertices.length; i < il; i++ ) {

            this.vertices.push( vertices[ i ].clone() );

        }

        var faces = source.faces;

        for ( var i = 0, il = faces.length; i < il; i++ ) {

            this.faces.push( faces[ i ].clone() );

        }

        for ( var i = 0, il = source.faceVertexUvs.length; i < il; i++ ) {

            var faceVertexUvs = source.faceVertexUvs[ i ];

            if ( this.faceVertexUvs[ i ] === undefined ) {

                this.faceVertexUvs[ i ] = [];

            }

            for ( var j = 0, jl = faceVertexUvs.length; j < jl; j++ ) {

                var uvs = faceVertexUvs[ j ],
                    uvsCopy = [];

                for ( var k = 0, kl = uvs.length; k < kl; k++ ) {

                    var uv = uvs[ k ];

                    uvsCopy.push( uv.clone() );

                }

                this.faceVertexUvs[ i ].push( uvsCopy );

            }

        }

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'DirectGeometry';

    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];

    this.groups = [];

    this.morphTargets = {};

    this.skinWeights = [];
    this.skinIndices = [];

    // this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

    constructor: THREE.DirectGeometry,

    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

    computeFaceNormals: function() {

        console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    },

    computeVertexNormals: function() {

        console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    },

    computeGroups: function( geometry ) {

        var group;
        var groups = [];
        var materialIndex;

        var faces = geometry.faces;

        for ( var i = 0; i < faces.length; i++ ) {

            var face = faces[ i ];

            // materials

            if ( face.materialIndex !== materialIndex ) {

                materialIndex = face.materialIndex;

                if ( group !== undefined ) {

                    group.count = ( i * 3 ) - group.start;
                    groups.push( group );

                }

                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };

            }

        }

        if ( group !== undefined ) {

            group.count = ( i * 3 ) - group.start;
            groups.push( group );

        }

        this.groups = groups;

    },

    fromGeometry: function( geometry ) {

        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;

        var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

        // morphs

        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;

        if ( morphTargetsLength > 0 ) {

            var morphTargetsPosition = [];

            for ( var i = 0; i < morphTargetsLength; i++ ) {

                morphTargetsPosition[ i ] = [];

            }

            this.morphTargets.position = morphTargetsPosition;

        }

        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;

        if ( morphNormalsLength > 0 ) {

            var morphTargetsNormal = [];

            for ( var i = 0; i < morphNormalsLength; i++ ) {

                morphTargetsNormal[ i ] = [];

            }

            this.morphTargets.normal = morphTargetsNormal;

        }

        // skins

        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;

        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;

        //

        for ( var i = 0; i < faces.length; i++ ) {

            var face = faces[ i ];

            this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

            }
            else {

                var normal = face.normal;

                this.normals.push( normal, normal, normal );

            }

            var vertexColors = face.vertexColors;

            if ( vertexColors.length === 3 ) {

                this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

            }
            else {

                var color = face.color;

                this.colors.push( color, color, color );

            }

            if ( hasFaceVertexUv === true ) {

                var vertexUvs = faceVertexUvs[ 0 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                }
                else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

                    this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            if ( hasFaceVertexUv2 === true ) {

                var vertexUvs = faceVertexUvs[ 1 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                }
                else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

                    this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            // morphs

            for ( var j = 0; j < morphTargetsLength; j++ ) {

                var morphTarget = morphTargets[ j ].vertices;

                morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

            }

            for ( var j = 0; j < morphNormalsLength; j++ ) {

                var morphNormal = morphNormals[ j ].vertexNormals[ i ];

                morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

            }

            // skins

            if ( hasSkinIndices ) {

                this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

            }

            if ( hasSkinWeights ) {

                this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

            }

        }

        this.computeGroups( geometry );

        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'BufferGeometry';

    this.index = null;
    this.attributes = {};

    this.morphAttributes = {};

    this.groups = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    this.drawRange = {
        start: 0,
        count: Infinity
    };

};

THREE.BufferGeometry.prototype = {

    constructor: THREE.BufferGeometry,

    addIndex: function( index ) {

        console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
        this.setIndex( index );

    },

    getIndex: function() {

        return this.index;

    },

    setIndex: function( index ) {

        this.index = index;

    },

    addAttribute: function( name, attribute ) {

        if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

            console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

            this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

            return;

        }

        if ( name === 'index' ) {

            console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
            this.setIndex( attribute );

        }

        this.attributes[ name ] = attribute;

    },

    getAttribute: function( name ) {

        return this.attributes[ name ];

    },

    removeAttribute: function( name ) {

        delete this.attributes[ name ];

    },

    get drawcalls() {

        console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
        return this.groups;

    },

    get offsets() {

        console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
        return this.groups;

    },

    addDrawCall: function( start, count, indexOffset ) {

        if ( indexOffset !== undefined ) {

            console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

        }

        console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
        this.addGroup( start, count );

    },

    clearDrawCalls: function() {

        console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
        this.clearGroups();

    },

    addGroup: function( start, count, materialIndex ) {

        this.groups.push( {

            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0

        } );

    },

    clearGroups: function() {

        this.groups = [];

    },

    setDrawRange: function( start, count ) {

        this.drawRange.start = start;
        this.drawRange.count = count;

    },

    applyMatrix: function( matrix ) {

        var position = this.attributes.position;

        if ( position !== undefined ) {

            matrix.applyToVector3Array( position.array );
            position.needsUpdate = true;

        }

        var normal = this.attributes.normal;

        if ( normal !== undefined ) {

            var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

            normalMatrix.applyToVector3Array( normal.array );
            normal.needsUpdate = true;

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

    },

    rotateX: function() {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function() {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function() {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function() {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function() {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function() {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    center: function() {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    setFromObject: function( object ) {

        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

        var geometry = object.geometry;

        if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

            var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
            var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

            this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
            this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

            if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

                var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

                this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

            }

            if ( geometry.boundingSphere !== null ) {

                this.boundingSphere = geometry.boundingSphere.clone();

            }

            if ( geometry.boundingBox !== null ) {

                this.boundingBox = geometry.boundingBox.clone();

            }

        }
        else if ( object instanceof THREE.Mesh ) {

            if ( geometry instanceof THREE.Geometry ) {

                this.fromGeometry( geometry );

            }

        }

        return this;

    },

    updateFromObject: function( object ) {

        var geometry = object.geometry;

        if ( object instanceof THREE.Mesh ) {

            var direct = geometry.__directGeometry;

            if ( direct === undefined ) {

                return this.fromGeometry( geometry );

            }

            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;

            geometry = direct;

        }

        if ( geometry.verticesNeedUpdate === true ) {

            var attribute = this.attributes.position;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.vertices );
                attribute.needsUpdate = true;

            }

            geometry.verticesNeedUpdate = false;

        }

        if ( geometry.normalsNeedUpdate === true ) {

            var attribute = this.attributes.normal;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.normals );
                attribute.needsUpdate = true;

            }

            geometry.normalsNeedUpdate = false;

        }

        if ( geometry.colorsNeedUpdate === true ) {

            var attribute = this.attributes.color;

            if ( attribute !== undefined ) {

                attribute.copyColorsArray( geometry.colors );
                attribute.needsUpdate = true;

            }

            geometry.colorsNeedUpdate = false;

        }

        if ( geometry.lineDistancesNeedUpdate ) {

            var attribute = this.attributes.lineDistance;

            if ( attribute !== undefined ) {

                attribute.copyArray( geometry.lineDistances );
                attribute.needsUpdate = true;

            }

            geometry.lineDistancesNeedUpdate = false;

        }

        if ( geometry.groupsNeedUpdate ) {

            geometry.computeGroups( object.geometry );
            this.groups = geometry.groups;

            geometry.groupsNeedUpdate = false;

        }

        return this;

    },

    fromGeometry: function( geometry ) {

        geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

        return this.fromDirectGeometry( geometry.__directGeometry );

    },

    fromDirectGeometry: function( geometry ) {

        var positions = new Float32Array( geometry.vertices.length * 3 );
        this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

        if ( geometry.normals.length > 0 ) {

            var normals = new Float32Array( geometry.normals.length * 3 );
            this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

        }

        if ( geometry.colors.length > 0 ) {

            var colors = new Float32Array( geometry.colors.length * 3 );
            this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

        }

        if ( geometry.uvs.length > 0 ) {

            var uvs = new Float32Array( geometry.uvs.length * 2 );
            this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

        }

        if ( geometry.uvs2.length > 0 ) {

            var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
            this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

        }

        if ( geometry.indices.length > 0 ) {

            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
            var indices = new TypeArray( geometry.indices.length * 3 );
            this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

        }

        // groups

        this.groups = geometry.groups;

        // morphs

        for ( var name in geometry.morphTargets ) {

            var array = [];
            var morphTargets = geometry.morphTargets[ name ];

            for ( var i = 0, l = morphTargets.length; i < l; i++ ) {

                var morphTarget = morphTargets[ i ];

                var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

                array.push( attribute.copyVector3sArray( morphTarget ) );

            }

            this.morphAttributes[ name ] = array;

        }

        // skinning

        if ( geometry.skinIndices.length > 0 ) {

            var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
            this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

        }

        if ( geometry.skinWeights.length > 0 ) {

            var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
            this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

        }

        //

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        return this;

    },

    computeBoundingBox: function() {

        var vector = new THREE.Vector3();

        return function() {

            if ( this.boundingBox === null ) {

                this.boundingBox = new THREE.Box3();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                var bb = this.boundingBox;
                bb.makeEmpty();

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    bb.expandByPoint( vector );

                }

            }

            if ( positions === undefined || positions.length === 0 ) {

                this.boundingBox.min.set( 0, 0, 0 );
                this.boundingBox.max.set( 0, 0, 0 );

            }

            if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

                console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

            }

        };

    }(),

    computeBoundingSphere: function() {

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();

        return function() {

            if ( this.boundingSphere === null ) {

                this.boundingSphere = new THREE.Sphere();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                box.makeEmpty();

                var center = this.boundingSphere.center;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    box.expandByPoint( vector );

                }

                box.center( center );

                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                var maxRadiusSq = 0;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

                }

                this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

                if ( isNaN( this.boundingSphere.radius ) ) {

                    console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

                }

            }

        };

    }(),

    computeFaceNormals: function() {

        // backwards compatibility

    },

    computeVertexNormals: function() {

        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;

        if ( attributes.position ) {

            var positions = attributes.position.array;

            if ( attributes.normal === undefined ) {

                this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

            }
            else {

                // reset existing normals to zero

                var normals = attributes.normal.array;

                for ( var i = 0, il = normals.length; i < il; i++ ) {

                    normals[ i ] = 0;

                }

            }

            var normals = attributes.normal.array;

            var vA, vB, vC,

                pA = new THREE.Vector3(),
                pB = new THREE.Vector3(),
                pC = new THREE.Vector3(),

                cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            // indexed elements

            if ( index ) {

                var indices = index.array;

                if ( groups.length === 0 ) {

                    this.addGroup( 0, indices.length );

                }

                for ( var j = 0, jl = groups.length; j < jl; ++j ) {

                    var group = groups[ j ];

                    var start = group.start;
                    var count = group.count;

                    for ( var i = start, il = start + count; i < il; i += 3 ) {

                        vA = indices[ i + 0 ] * 3;
                        vB = indices[ i + 1 ] * 3;
                        vC = indices[ i + 2 ] * 3;

                        pA.fromArray( positions, vA );
                        pB.fromArray( positions, vB );
                        pC.fromArray( positions, vC );

                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );

                        normals[ vA ] += cb.x;
                        normals[ vA + 1 ] += cb.y;
                        normals[ vA + 2 ] += cb.z;

                        normals[ vB ] += cb.x;
                        normals[ vB + 1 ] += cb.y;
                        normals[ vB + 2 ] += cb.z;

                        normals[ vC ] += cb.x;
                        normals[ vC + 1 ] += cb.y;
                        normals[ vC + 2 ] += cb.z;

                    }

                }

            }
            else {

                // non-indexed elements (unconnected triangle soup)

                for ( var i = 0, il = positions.length; i < il; i += 9 ) {

                    pA.fromArray( positions, i );
                    pB.fromArray( positions, i + 3 );
                    pC.fromArray( positions, i + 6 );

                    cb.subVectors( pC, pB );
                    ab.subVectors( pA, pB );
                    cb.cross( ab );

                    normals[ i ] = cb.x;
                    normals[ i + 1 ] = cb.y;
                    normals[ i + 2 ] = cb.z;

                    normals[ i + 3 ] = cb.x;
                    normals[ i + 4 ] = cb.y;
                    normals[ i + 5 ] = cb.z;

                    normals[ i + 6 ] = cb.x;
                    normals[ i + 7 ] = cb.y;
                    normals[ i + 8 ] = cb.z;

                }

            }

            this.normalizeNormals();

            attributes.normal.needsUpdate = true;

        }

    },

    computeTangents: function() {

        console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

    },

    computeOffsets: function( size ) {

        console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' )

    },

    merge: function( geometry, offset ) {

        if ( geometry instanceof THREE.BufferGeometry === false ) {

            console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
            return;

        }

        if ( offset === undefined ) offset = 0;

        var attributes = this.attributes;

        for ( var key in attributes ) {

            if ( geometry.attributes[ key ] === undefined ) continue;

            var attribute1 = attributes[ key ];
            var attributeArray1 = attribute1.array;

            var attribute2 = geometry.attributes[ key ];
            var attributeArray2 = attribute2.array;

            var attributeSize = attribute2.itemSize;

            for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++ ) {

                attributeArray1[ j ] = attributeArray2[ i ];

            }

        }

        return this;

    },

    normalizeNormals: function() {

        var normals = this.attributes.normal.array;

        var x, y, z, n;

        for ( var i = 0, il = normals.length; i < il; i += 3 ) {

            x = normals[ i ];
            y = normals[ i + 1 ];
            z = normals[ i + 2 ];

            n = 1.0 / Math.sqrt( x * x + y * y + z * z );

            normals[ i ] *= n;
            normals[ i + 1 ] *= n;
            normals[ i + 2 ] *= n;

        }

    },

    toJSON: function() {

        var data = {
            metadata: {
                version: 4.4,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };

        // standard BufferGeometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        data.data = {
            attributes: {}
        };

        var index = this.index;

        if ( index !== null ) {

            var array = Array.prototype.slice.call( index.array );

            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };

        }

        var attributes = this.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];

            var array = Array.prototype.slice.call( attribute.array );

            data.data.attributes[ key ] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array
            };

        }

        var groups = this.groups;

        if ( groups.length > 0 ) {

            data.data.groups = JSON.parse( JSON.stringify( groups ) );

        }

        var boundingSphere = this.boundingSphere;

        if ( boundingSphere !== null ) {

            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };

        }

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        var index = source.index;

        if ( index !== null ) {

            this.setIndex( index.clone() );

        }

        var attributes = source.attributes;

        for ( var name in attributes ) {

            var attribute = attributes[ name ];
            this.addAttribute( name, attribute.clone() );

        }

        var groups = source.groups;

        for ( var i = 0, l = groups.length; i < l; i++ ) {

            var group = groups[ i ];
            this.addGroup( group.start, group.count );

        }

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function() {

    THREE.BufferGeometry.call( this );

    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function( start, count, instances ) {

    this.groups.push( {

        start: start,
        count: count,
        instances: instances

    } );

};

THREE.InstancedBufferGeometry.prototype.copy = function( source ) {

    var index = source.index;

    if ( index !== null ) {

        this.setIndex( index.clone() );

    }

    var attributes = source.attributes;

    for ( var name in attributes ) {

        var attribute = attributes[ name ];
        this.addAttribute( name, attribute.clone() );

    }

    var groups = source.groups;

    for ( var i = 0, l = groups.length; i < l; i++ ) {

        var group = groups[ i ];
        this.addGroup( group.start, group.count, group.instances );

    }

    return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Camera = function() {

    THREE.Object3D.call( this );

    this.type = 'Camera';

    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function() {

    var quaternion = new THREE.Quaternion();

    return function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.getWorldQuaternion( quaternion );

        return result.set( 0, 0, -1 ).applyQuaternion( quaternion );

    };

}();

THREE.Camera.prototype.lookAt = function() {

    // This routine does not support cameras with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function( vector ) {

        m1.lookAt( this.position, vector, this.up );

        this.quaternion.setFromRotationMatrix( m1 );

    };

}();

THREE.Camera.prototype.clone = function() {

    return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.matrixWorldInverse.copy( source.matrixWorldInverse );
    this.projectionMatrix.copy( source.projectionMatrix );

    return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function( near, far, cubeResolution ) {

    THREE.Object3D.call( this );

    this.type = 'CubeCamera';

    var fov = 90,
        aspect = 1;

    var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPX.up.set( 0, -1, 0 );
    cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
    this.add( cameraPX );

    var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNX.up.set( 0, -1, 0 );
    cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
    this.add( cameraNX );

    var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPY.up.set( 0, 0, 1 );
    cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
    this.add( cameraPY );

    var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNY.up.set( 0, 0, -1 );
    cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
    this.add( cameraNY );

    var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPZ.up.set( 0, -1, 0 );
    cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
    this.add( cameraPZ );

    var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNZ.up.set( 0, -1, 0 );
    cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
    this.add( cameraNZ );

    this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    } );

    this.updateCubeMap = function( renderer, scene ) {

        if ( this.parent === null ) this.updateMatrixWorld();

        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.generateMipmaps;

        renderTarget.generateMipmaps = false;

        renderTarget.activeCubeFace = 0;
        renderer.render( scene, cameraPX, renderTarget );

        renderTarget.activeCubeFace = 1;
        renderer.render( scene, cameraNX, renderTarget );

        renderTarget.activeCubeFace = 2;
        renderer.render( scene, cameraPY, renderTarget );

        renderTarget.activeCubeFace = 3;
        renderer.render( scene, cameraNY, renderTarget );

        renderTarget.activeCubeFace = 4;
        renderer.render( scene, cameraPZ, renderTarget );

        renderTarget.generateMipmaps = generateMipmaps;

        renderTarget.activeCubeFace = 5;
        renderer.render( scene, cameraNZ, renderTarget );

        renderer.setRenderTarget( null );

    };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function( left, right, top, bottom, near, far ) {

    THREE.Camera.call( this );

    this.type = 'OrthographicCamera';

    this.zoom = 1;

    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;

    this.near = ( near !== undefined ) ? near : 0.1;
    this.far = ( far !== undefined ) ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {

    var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    var cx = ( this.right + this.left ) / 2;
    var cy = ( this.top + this.bottom ) / 2;

    this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.OrthographicCamera.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function( fov, aspect, near, far ) {

    THREE.Camera.call( this );

    this.type = 'PerspectiveCamera';

    this.zoom = 1;

    this.fov = fov !== undefined ? fov : 50;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function( focalLength, frameHeight ) {

    if ( frameHeight === undefined ) frameHeight = 24;

    this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
    this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function( fullWidth, fullHeight, x, y, width, height ) {

    this.fullWidth = fullWidth;
    this.fullHeight = fullHeight;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {

    var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

    if ( this.fullWidth ) {

        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs( right - left );
        var height = Math.abs( top - bottom );

        this.projectionMatrix.makeFrustum(
            left + this.x * width / this.fullWidth,
            left + ( this.x + this.width ) * width / this.fullWidth,
            top - ( this.y + this.height ) * height / this.fullHeight,
            top - this.y * height / this.fullHeight,
            this.near,
            this.far
        );

    }
    else {

        this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

    }

};

THREE.PerspectiveCamera.prototype.copy = function( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.fov = source.fov;
    this.aspect = source.aspect;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.fov = this.fov;
    data.object.aspect = this.aspect;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function( color ) {

    THREE.Object3D.call( this );

    this.type = 'Light';

    this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.color.copy( source.color );

    return this;

};
// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function( color ) {

    THREE.Light.call( this, color );

    this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();

    return data;

};

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function( color, intensity ) {

    THREE.Light.call( this, color );

    this.type = 'DirectionalLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;

    this.castShadow = false;
    this.onlyShadow = false;

    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5000;

    this.shadowCameraLeft = -500;
    this.shadowCameraRight = 500;
    this.shadowCameraTop = 500;
    this.shadowCameraBottom = -500;

    this.shadowCameraVisible = false;

    this.shadowBias = 0;
    this.shadowDarkness = 0.5;

    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;

    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.target = source.target.clone();

    this.castShadow = source.castShadow;
    this.onlyShadow = source.onlyShadow;

    this.shadowCameraNear = source.shadowCameraNear;
    this.shadowCameraFar = source.shadowCameraFar;

    this.shadowCameraLeft = source.shadowCameraLeft;
    this.shadowCameraRight = source.shadowCameraRight;
    this.shadowCameraTop = source.shadowCameraTop;
    this.shadowCameraBottom = source.shadowCameraBottom;

    this.shadowCameraVisible = source.shadowCameraVisible;

    this.shadowBias = source.shadowBias;
    this.shadowDarkness = source.shadowDarkness;

    this.shadowMapWidth = source.shadowMapWidth;
    this.shadowMapHeight = source.shadowMapHeight;

    return this;

};

THREE.DirectionalLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;

    return data;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function( skyColor, groundColor, intensity ) {

    THREE.Light.call( this, skyColor );

    this.type = 'HemisphereLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.groundColor = new THREE.Color( groundColor );
    this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.groundColor.copy( source.groundColor );
    this.intensity = source.intensity;

    return this;

};

THREE.HemisphereLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.groundColor = this.groundColor.getHex();
    data.object.intensity = this.intensity;

    return data;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function( color, intensity, distance, decay ) {

    THREE.Light.call( this, color );

    this.type = 'PointLight';

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.decay = source.decay;

    return this;

};

THREE.PointLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    data.object.distance = this.distance;
    data.object.decay = this.decay;

    return data;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function( color, intensity, distance, angle, exponent, decay ) {

    THREE.Light.call( this, color );

    this.type = 'SpotLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    this.exponent = ( exponent !== undefined ) ? exponent : 10;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

    this.castShadow = false;
    this.onlyShadow = false;

    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5000;
    this.shadowCameraFov = 50;

    this.shadowCameraVisible = false;

    this.shadowBias = 0;
    this.shadowDarkness = 0.5;

    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;

    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.angle = source.angle;
    this.exponent = source.exponent;
    this.decay = source.decay;

    this.target = source.target.clone();

    this.castShadow = source.castShadow;
    this.onlyShadow = source.onlyShadow;

    this.shadowCameraNear = source.shadowCameraNear;
    this.shadowCameraFar = source.shadowCameraFar;
    this.shadowCameraFov = source.shadowCameraFov;

    this.shadowCameraVisible = source.shadowCameraVisible;

    this.shadowBias = source.shadowBias;
    this.shadowDarkness = source.shadowDarkness;

    this.shadowMapWidth = source.shadowMapWidth;
    this.shadowMapHeight = source.shadowMapHeight;

    return this;
}

THREE.SpotLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    data.object.distance = this.distance;
    data.object.angle = this.angle;
    data.object.exponent = this.exponent;
    data.object.decay = this.decay;

    return data;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

    enabled: false,

    files: {},

    add: function( key, file ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Adding key:', key );

        this.files[ key ] = file;

    },

    get: function( key ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Checking key:', key );

        return this.files[ key ];

    },

    remove: function( key ) {

        delete this.files[ key ];

    },

    clear: function() {

        this.files = {};

    }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function() {

    this.onLoadStart = function() {};
    this.onLoadProgress = function() {};
    this.onLoadComplete = function() {};

};

THREE.Loader.prototype = {

    constructor: THREE.Loader,

    crossOrigin: undefined,

    extractUrlBase: function( url ) {

        var parts = url.split( '/' );

        if ( parts.length === 1 ) return './';

        parts.pop();

        return parts.join( '/' ) + '/';

    },

    initMaterials: function( materials, texturePath, crossOrigin ) {

        var array = [];

        for ( var i = 0; i < materials.length; ++i ) {

            array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

        }

        return array;

    },

    createMaterial: ( function() {

        var imageLoader;

        return function createMaterial( m, texturePath, crossOrigin ) {

            var scope = this;

            if ( crossOrigin === undefined && scope.crossOrigin !== undefined ) crossOrigin = scope.crossOrigin;

            if ( imageLoader === undefined ) imageLoader = new THREE.ImageLoader();

            function nearest_pow2( n ) {

                var l = Math.log( n ) / Math.LN2;
                return Math.pow( 2, Math.round( l ) );

            }

            function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

                var fullPath = texturePath + sourceFile;

                var texture;

                var loader = THREE.Loader.Handlers.get( fullPath );

                if ( loader !== null ) {

                    texture = loader.load( fullPath );

                }
                else {

                    texture = new THREE.Texture();

                    loader = imageLoader;
                    loader.setCrossOrigin( crossOrigin );
                    loader.load( fullPath, function( image ) {

                        if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
                            THREE.Math.isPowerOfTwo( image.height ) === false ) {

                            var width = nearest_pow2( image.width );
                            var height = nearest_pow2( image.height );

                            var canvas = document.createElement( 'canvas' );
                            canvas.width = width;
                            canvas.height = height;

                            var context = canvas.getContext( '2d' );
                            context.drawImage( image, 0, 0, width, height );

                            texture.image = canvas;

                        }
                        else {

                            texture.image = image;

                        }

                        texture.needsUpdate = true;

                    } );

                }

                texture.sourceFile = sourceFile;

                if ( repeat ) {

                    texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

                    if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
                    if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

                }

                if ( offset ) {

                    texture.offset.set( offset[ 0 ], offset[ 1 ] );

                }

                if ( wrap ) {

                    var wrapMap = {
                        'repeat': THREE.RepeatWrapping,
                        'mirror': THREE.MirroredRepeatWrapping
                    };

                    if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
                    if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

                }

                if ( anisotropy ) {

                    texture.anisotropy = anisotropy;

                }

                where[ name ] = texture;

            }

            function rgb2hex( rgb ) {

                return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

            }

            // defaults

            var mtype = 'MeshLambertMaterial';
            var mpars = {};

            // parameters from model file

            if ( m.shading ) {

                var shading = m.shading.toLowerCase();

                if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
                else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

            }

            if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

                mpars.blending = THREE[ m.blending ];

            }

            if ( m.transparent !== undefined ) {

                mpars.transparent = m.transparent;

            }

            if ( m.opacity !== undefined && m.opacity < 1.0 ) {

                mpars.transparent = true;

            }

            if ( m.depthTest !== undefined ) {

                mpars.depthTest = m.depthTest;

            }

            if ( m.depthWrite !== undefined ) {

                mpars.depthWrite = m.depthWrite;

            }

            if ( m.visible !== undefined ) {

                mpars.visible = m.visible;

            }

            if ( m.flipSided !== undefined ) {

                mpars.side = THREE.BackSide;

            }

            if ( m.doubleSided !== undefined ) {

                mpars.side = THREE.DoubleSide;

            }

            if ( m.wireframe !== undefined ) {

                mpars.wireframe = m.wireframe;

            }

            if ( m.vertexColors !== undefined ) {

                if ( m.vertexColors === 'face' ) {

                    mpars.vertexColors = THREE.FaceColors;

                }
                else if ( m.vertexColors ) {

                    mpars.vertexColors = THREE.VertexColors;

                }

            }

            // colors

            if ( m.colorDiffuse ) {

                mpars.color = rgb2hex( m.colorDiffuse );

            }
            else if ( m.DbgColor ) {

                mpars.color = m.DbgColor;

            }

            if ( m.colorEmissive ) {

                mpars.emissive = rgb2hex( m.colorEmissive );

            }

            if ( mtype === 'MeshPhongMaterial' ) {

                if ( m.colorSpecular ) {

                    mpars.specular = rgb2hex( m.colorSpecular );

                }

                if ( m.specularCoef ) {

                    mpars.shininess = m.specularCoef;

                }

            }

            // modifiers

            if ( m.transparency !== undefined ) {

                console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
                m.opacity = m.transparency;

            }

            if ( m.opacity !== undefined ) {

                mpars.opacity = m.opacity;

            }

            // textures

            if ( texturePath ) {

                if ( m.mapDiffuse ) {

                    create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

                }

                if ( m.mapLight ) {

                    create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

                }

                if ( m.mapAO ) {

                    create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

                }

                if ( m.mapBump ) {

                    create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

                }

                if ( m.mapNormal ) {

                    create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

                }

                if ( m.mapSpecular ) {

                    create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

                }

                if ( m.mapAlpha ) {

                    create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

                }

            }

            //

            if ( m.mapBumpScale ) {

                mpars.bumpScale = m.mapBumpScale;

            }

            if ( m.mapNormalFactor ) {

                mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

            }

            var material = new THREE[ mtype ]( mpars );

            if ( m.DbgName !== undefined ) material.name = m.DbgName;

            return material;

        };

    } )()

};

THREE.Loader.Handlers = {

    handlers: [],

    add: function( regex, loader ) {

        this.handlers.push( regex, loader );

    },

    get: function( file ) {

        for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

            var regex = this.handlers[ i ];
            var loader = this.handlers[ i + 1 ];

            if ( regex.test( file ) ) {

                return loader;

            }

        }

        return null;

    }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

    constructor: THREE.XHRLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function() {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var request = new XMLHttpRequest();
        request.open( 'GET', url, true );

        request.addEventListener( 'load', function( event ) {

            THREE.Cache.add( url, this.response );

            if ( onLoad ) onLoad( this.response );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            request.addEventListener( 'progress', function( event ) {

                onProgress( event );

            }, false );

        }

        request.addEventListener( 'error', function( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
        if ( this.responseType !== undefined ) request.responseType = this.responseType;
        if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

        request.send( null );

        scope.manager.itemStart( url );

        return request;

    },

    setResponseType: function( value ) {

        this.responseType = value;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setWithCredentials: function( value ) {

        this.withCredentials = value;

    }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

    constructor: THREE.ImageLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function() {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var image = document.createElement( 'img' );

        image.addEventListener( 'load', function( event ) {

            THREE.Cache.add( url, this );

            if ( onLoad ) onLoad( this );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            image.addEventListener( 'progress', function( event ) {

                onProgress( event );

            }, false );

        }

        image.addEventListener( 'error', function( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

        scope.manager.itemStart( url );

        image.src = url;

        return image;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function( manager ) {

    if ( typeof manager === 'boolean' ) {

        console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
        manager = undefined;

    }

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

    constructor: THREE.JSONLoader,

    // Deprecated

    get statusDomElement() {

        if ( this._statusDomElement === undefined ) {

            this._statusDomElement = document.createElement( 'div' );

        }

        console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
        return this._statusDomElement;

    },

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setWithCredentials( this.withCredentials );
        loader.load( url, function( text ) {

            var json = JSON.parse( text );
            var metadata = json.metadata;

            if ( metadata !== undefined ) {

                if ( metadata.type === 'object' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
                    return;

                }

                if ( metadata.type === 'scene' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
                    return;

                }

            }

            var object = scope.parse( json, texturePath );
            onLoad( object.geometry, object.materials );

        } );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setTexturePath: function( value ) {

        this.texturePath = value;

    },

    parse: function( json, texturePath ) {

        var geometry = new THREE.Geometry(),
            scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

        parseModel( scale );

        parseSkin();
        parseMorphing( scale );

        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();

        function parseModel( scale ) {

            function isBitSet( value, position ) {

                return value & ( 1 << position );

            }

            var i, j, fi,

                offset, zLength,

                colorIndex, normalIndex, uvIndex, materialIndex,

                type,
                isQuad,
                hasMaterial,
                hasFaceVertexUv,
                hasFaceNormal, hasFaceVertexNormal,
                hasFaceColor, hasFaceVertexColor,

                vertex, face, faceA, faceB, hex, normal,

                uvLayer, uv, u, v,

                faces = json.faces,
                vertices = json.vertices,
                normals = json.normals,
                colors = json.colors,

                nUvLayers = 0;

            if ( json.uvs !== undefined ) {

                // disregard empty arrays

                for ( i = 0; i < json.uvs.length; i++ ) {

                    if ( json.uvs[ i ].length ) nUvLayers++;

                }

                for ( i = 0; i < nUvLayers; i++ ) {

                    geometry.faceVertexUvs[ i ] = [];

                }

            }

            offset = 0;
            zLength = vertices.length;

            while ( offset < zLength ) {

                vertex = new THREE.Vector3();

                vertex.x = vertices[ offset++ ] * scale;
                vertex.y = vertices[ offset++ ] * scale;
                vertex.z = vertices[ offset++ ] * scale;

                geometry.vertices.push( vertex );

            }

            offset = 0;
            zLength = faces.length;

            while ( offset < zLength ) {

                type = faces[ offset++ ];


                isQuad = isBitSet( type, 0 );
                hasMaterial = isBitSet( type, 1 );
                hasFaceVertexUv = isBitSet( type, 3 );
                hasFaceNormal = isBitSet( type, 4 );
                hasFaceVertexNormal = isBitSet( type, 5 );
                hasFaceColor = isBitSet( type, 6 );
                hasFaceVertexColor = isBitSet( type, 7 );

                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                if ( isQuad ) {

                    faceA = new THREE.Face3();
                    faceA.a = faces[ offset ];
                    faceA.b = faces[ offset + 1 ];
                    faceA.c = faces[ offset + 3 ];

                    faceB = new THREE.Face3();
                    faceB.a = faces[ offset + 1 ];
                    faceB.b = faces[ offset + 2 ];
                    faceB.c = faces[ offset + 3 ];

                    offset += 4;

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset++ ];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];
                            geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                            for ( j = 0; j < 4; j++ ) {

                                uvIndex = faces[ offset++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset++ ] * 3;

                        faceA.normal.set(
                            normals[ normalIndex++ ],
                            normals[ normalIndex++ ],
                            normals[ normalIndex ]
                        );

                        faceB.normal.copy( faceA.normal );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 4; i++ ) {

                            normalIndex = faces[ offset++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex++ ],
                                normals[ normalIndex++ ],
                                normals[ normalIndex ]
                            );


                            if ( i !== 2 ) faceA.vertexNormals.push( normal );
                            if ( i !== 0 ) faceB.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset++ ];
                        hex = colors[ colorIndex ];

                        faceA.color.setHex( hex );
                        faceB.color.setHex( hex );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 4; i++ ) {

                            colorIndex = faces[ offset++ ];
                            hex = colors[ colorIndex ];

                            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
                            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

                        }

                    }

                    geometry.faces.push( faceA );
                    geometry.faces.push( faceB );

                }
                else {

                    face = new THREE.Face3();
                    face.a = faces[ offset++ ];
                    face.b = faces[ offset++ ];
                    face.c = faces[ offset++ ];

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset++ ];
                        face.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];

                            for ( j = 0; j < 3; j++ ) {

                                uvIndex = faces[ offset++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                geometry.faceVertexUvs[ i ][ fi ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset++ ] * 3;

                        face.normal.set(
                            normals[ normalIndex++ ],
                            normals[ normalIndex++ ],
                            normals[ normalIndex ]
                        );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 3; i++ ) {

                            normalIndex = faces[ offset++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex++ ],
                                normals[ normalIndex++ ],
                                normals[ normalIndex ]
                            );

                            face.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset++ ];
                        face.color.setHex( colors[ colorIndex ] );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 3; i++ ) {

                            colorIndex = faces[ offset++ ];
                            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

                        }

                    }

                    geometry.faces.push( face );

                }

            }

        };

        function parseSkin() {

            var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

            if ( json.skinWeights ) {

                for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

                    var x = json.skinWeights[ i ];
                    var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
                    var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
                    var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

                    geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

                }

            }

            if ( json.skinIndices ) {

                for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

                    var a = json.skinIndices[ i ];
                    var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
                    var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
                    var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

                    geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

                }

            }

            geometry.bones = json.bones;

            if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

                console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                    geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

            }


            // could change this to json.animations[0] or remove completely

            geometry.animation = json.animation;
            geometry.animations = json.animations;

        };

        function parseMorphing( scale ) {

            if ( json.morphTargets !== undefined ) {

                var i, l, v, vl, dstVertices, srcVertices;

                for ( i = 0, l = json.morphTargets.length; i < l; i++ ) {

                    geometry.morphTargets[ i ] = {};
                    geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
                    geometry.morphTargets[ i ].vertices = [];

                    dstVertices = geometry.morphTargets[ i ].vertices;
                    srcVertices = json.morphTargets[ i ].vertices;

                    for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

                        var vertex = new THREE.Vector3();
                        vertex.x = srcVertices[ v ] * scale;
                        vertex.y = srcVertices[ v + 1 ] * scale;
                        vertex.z = srcVertices[ v + 2 ] * scale;

                        dstVertices.push( vertex );

                    }

                }

            }

            if ( json.morphColors !== undefined ) {

                var i, l, c, cl, dstColors, srcColors, color;

                for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

                    geometry.morphColors[ i ] = {};
                    geometry.morphColors[ i ].name = json.morphColors[ i ].name;
                    geometry.morphColors[ i ].colors = [];

                    dstColors = geometry.morphColors[ i ].colors;
                    srcColors = json.morphColors[ i ].colors;

                    for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

                        color = new THREE.Color( 0xffaa00 );
                        color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
                        dstColors.push( color );

                    }

                }

            }

        };

        if ( json.materials === undefined || json.materials.length === 0 ) {

            return {
                geometry: geometry
            };

        }
        else {

            var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

            return {
                geometry: geometry,
                materials: materials
            };

        }

    }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function( onLoad, onProgress, onError ) {

    var scope = this;

    var isLoading = false,
        itemsLoaded = 0,
        itemsTotal = 0;

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function( url ) {

        itemsTotal++;

        if ( isLoading === false ) {

            if ( scope.onStart !== undefined ) {

                scope.onStart( url, itemsLoaded, itemsTotal );

            }

        }

        isLoading = true;

    };

    this.itemEnd = function( url ) {

        itemsLoaded++;

        if ( scope.onProgress !== undefined ) {

            scope.onProgress( url, itemsLoaded, itemsTotal );

        }

        if ( itemsLoaded === itemsTotal ) {

            isLoading = false;

            if ( scope.onLoad !== undefined ) {

                scope.onLoad();

            }

        }

    };

    this.itemError = function( url ) {

        if ( scope.onError !== undefined ) {

            scope.onError( url );

        }

    };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

    constructor: THREE.BufferGeometryLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    parse: function( json ) {

        var geometry = new THREE.BufferGeometry();

        var index = json.data.index;

        if ( index !== undefined ) {

            var typedArray = new self[ index.type ]( index.array );
            geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

        }

        var attributes = json.data.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];
            var typedArray = new self[ attribute.type ]( attribute.array );

            geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

        }

        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

        if ( groups !== undefined ) {

            for ( var i = 0, n = groups.length; i !== n; ++i ) {

                var group = groups[ i ];

                geometry.addGroup( group.start, group.count );

            }

        }

        var boundingSphere = json.data.boundingSphere;

        if ( boundingSphere !== undefined ) {

            var center = new THREE.Vector3();

            if ( boundingSphere.center !== undefined ) {

                center.fromArray( boundingSphere.center );

            }

            geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

        }

        return geometry;

    }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.textures = {};

};

THREE.MaterialLoader.prototype = {

    constructor: THREE.MaterialLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setTextures: function( value ) {

        this.textures = value;

    },

    getTexture: function( name ) {

        var textures = this.textures;

        if ( textures[ name ] === undefined ) {

            console.warn( 'THREE.MaterialLoader: Undefined texture', name );

        }

        return textures[ name ];

    },

    parse: function( json ) {

        var material = new THREE[ json.type ];
        material.uuid = json.uuid;

        if ( json.name !== undefined ) material.name = json.name;
        if ( json.color !== undefined ) material.color.setHex( json.color );
        if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
        if ( json.specular !== undefined ) material.specular.setHex( json.specular );
        if ( json.shininess !== undefined ) material.shininess = json.shininess;
        if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
        if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
        if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
        if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
        if ( json.shading !== undefined ) material.shading = json.shading;
        if ( json.blending !== undefined ) material.blending = json.blending;
        if ( json.side !== undefined ) material.side = json.side;
        if ( json.opacity !== undefined ) material.opacity = json.opacity;
        if ( json.transparent !== undefined ) material.transparent = json.transparent;
        if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
        if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
        if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
        if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
        if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

        // for PointsMaterial
        if ( json.size !== undefined ) material.size = json.size;
        if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

        // maps

        if ( json.map !== undefined ) material.map = this.getTexture( json.map );

        if ( json.alphaMap !== undefined ) {

            material.alphaMap = this.getTexture( json.alphaMap );
            material.transparent = true;

        }

        if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
        if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

        if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
        if ( json.normalScale ) material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

        if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
        if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
        if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

        if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

        if ( json.envMap !== undefined ) {

            material.envMap = this.getTexture( json.envMap );
            material.combine = THREE.MultiplyOperation;

        }

        if ( json.reflectivity ) material.reflectivity = json.reflectivity;

        if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
        if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

        if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
        if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

        // MeshFaceMaterial

        if ( json.materials !== undefined ) {

            for ( var i = 0, l = json.materials.length; i < l; i++ ) {

                material.materials.push( this.parse( json.materials[ i ] ) );

            }

        }

        return material;

    }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

    constructor: THREE.ObjectLoader,

    load: function( url, onLoad, onProgress, onError ) {

        if ( this.texturePath === '' ) {

            this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

        }

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            scope.parse( JSON.parse( text ), onLoad );

        }, onProgress, onError );

    },

    setTexturePath: function( value ) {

        this.texturePath = value;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    parse: function( json, onLoad ) {

        var geometries = this.parseGeometries( json.geometries );

        var images = this.parseImages( json.images, function() {

            if ( onLoad !== undefined ) onLoad( object );

        } );

        var textures = this.parseTextures( json.textures, images );
        var materials = this.parseMaterials( json.materials, textures );
        var object = this.parseObject( json.object, geometries, materials );

        if ( json.images === undefined || json.images.length === 0 ) {

            if ( onLoad !== undefined ) onLoad( object );

        }

        return object;

    },

    parseGeometries: function( json ) {

        var geometries = {};

        if ( json !== undefined ) {

            var geometryLoader = new THREE.JSONLoader();
            var bufferGeometryLoader = new THREE.BufferGeometryLoader();

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var geometry;
                var data = json[ i ];

                switch ( data.type ) {

                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':

                        geometry = new THREE[ data.type ](
                            data.width,
                            data.height,
                            data.widthSegments,
                            data.heightSegments
                        );

                        break;

                    case 'BoxGeometry':
                    case 'CubeGeometry': // backwards compatible

                        geometry = new THREE.BoxGeometry(
                            data.width,
                            data.height,
                            data.depth,
                            data.widthSegments,
                            data.heightSegments,
                            data.depthSegments
                        );

                        break;

                    case 'CircleBufferGeometry':

                        geometry = new THREE.CircleBufferGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CircleGeometry':

                        geometry = new THREE.CircleGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CylinderGeometry':

                        geometry = new THREE.CylinderGeometry(
                            data.radiusTop,
                            data.radiusBottom,
                            data.height,
                            data.radialSegments,
                            data.heightSegments,
                            data.openEnded,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereGeometry':

                        geometry = new THREE.SphereGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereBufferGeometry':

                        geometry = new THREE.SphereBufferGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'DodecahedronGeometry':

                        geometry = new THREE.DodecahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'IcosahedronGeometry':

                        geometry = new THREE.IcosahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'OctahedronGeometry':

                        geometry = new THREE.OctahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'TetrahedronGeometry':

                        geometry = new THREE.TetrahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'RingGeometry':

                        geometry = new THREE.RingGeometry(
                            data.innerRadius,
                            data.outerRadius,
                            data.thetaSegments,
                            data.phiSegments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'TorusGeometry':

                        geometry = new THREE.TorusGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.arc
                        );

                        break;

                    case 'TorusKnotGeometry':

                        geometry = new THREE.TorusKnotGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.p,
                            data.q,
                            data.heightScale
                        );

                        break;

                    case 'TextGeometry':

                        geometry = new THREE.TextGeometry(
                            data.text,
                            data.data
                        );

                        break;

                    case 'BufferGeometry':

                        geometry = bufferGeometryLoader.parse( data );

                        break;

                    case 'Geometry':

                        geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

                        break;

                    default:

                        console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

                        continue;

                }

                geometry.uuid = data.uuid;

                if ( data.name !== undefined ) geometry.name = data.name;

                geometries[ data.uuid ] = geometry;

            }

        }

        return geometries;

    },

    parseMaterials: function( json, textures ) {

        var materials = {};

        if ( json !== undefined ) {

            var loader = new THREE.MaterialLoader();
            loader.setTextures( textures );

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var material = loader.parse( json[ i ] );
                materials[ material.uuid ] = material;

            }

        }

        return materials;

    },

    parseImages: function( json, onLoad ) {

        var scope = this;
        var images = {};

        function loadImage( url ) {

            scope.manager.itemStart( url );

            return loader.load( url, function() {

                scope.manager.itemEnd( url );

            } );

        }

        if ( json !== undefined && json.length > 0 ) {

            var manager = new THREE.LoadingManager( onLoad );

            var loader = new THREE.ImageLoader( manager );
            loader.setCrossOrigin( this.crossOrigin );

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var image = json[ i ];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

                images[ image.uuid ] = loadImage( path );

            }

        }

        return images;

    },

    parseTextures: function( json, images ) {

        function parseConstant( value ) {

            if ( typeof( value ) === 'number' ) return value;

            console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

            return THREE[ value ];

        }

        var textures = {};

        if ( json !== undefined ) {

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var data = json[ i ];

                if ( data.image === undefined ) {

                    console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

                }

                if ( images[ data.image ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

                }

                var texture = new THREE.Texture( images[ data.image ] );
                texture.needsUpdate = true;

                texture.uuid = data.uuid;

                if ( data.name !== undefined ) texture.name = data.name;
                if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
                if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
                if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
                if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
                if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
                if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
                if ( Array.isArray( data.wrap ) ) {

                    texture.wrapS = parseConstant( data.wrap[ 0 ] );
                    texture.wrapT = parseConstant( data.wrap[ 1 ] );

                }

                textures[ data.uuid ] = texture;

            }

        }

        return textures;

    },

    parseObject: function() {

        var matrix = new THREE.Matrix4();

        return function( data, geometries, materials ) {

            var object;

            var getGeometry = function( name ) {

                if ( geometries[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

                }

                return geometries[ name ];

            };

            var getMaterial = function( name ) {

                if ( materials[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined material', name );

                }

                return materials[ name ];

            };

            switch ( data.type ) {

                case 'Scene':

                    object = new THREE.Scene();

                    break;

                case 'PerspectiveCamera':

                    object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

                    break;

                case 'OrthographicCamera':

                    object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

                    break;

                case 'AmbientLight':

                    object = new THREE.AmbientLight( data.color );

                    break;

                case 'DirectionalLight':

                    object = new THREE.DirectionalLight( data.color, data.intensity );

                    break;

                case 'PointLight':

                    object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

                    break;

                case 'SpotLight':

                    object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

                    break;

                case 'HemisphereLight':

                    object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

                    break;

                case 'Mesh':

                    object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'LOD':

                    object = new THREE.LOD();

                    break;

                case 'Line':

                    object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

                    break;

                case 'PointCloud':
                case 'Points':

                    object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'Sprite':

                    object = new THREE.Sprite( getMaterial( data.material ) );

                    break;

                case 'Group':

                    object = new THREE.Group();

                    break;

                default:

                    object = new THREE.Object3D();

            }

            object.uuid = data.uuid;

            if ( data.name !== undefined ) object.name = data.name;
            if ( data.matrix !== undefined ) {

                matrix.fromArray( data.matrix );
                matrix.decompose( object.position, object.quaternion, object.scale );

            }
            else {

                if ( data.position !== undefined ) object.position.fromArray( data.position );
                if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
                if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

            }

            if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
            if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

            if ( data.visible !== undefined ) object.visible = data.visible;
            if ( data.userData !== undefined ) object.userData = data.userData;

            if ( data.children !== undefined ) {

                for ( var child in data.children ) {

                    object.add( this.parseObject( data.children[ child ], geometries, materials ) );

                }

            }

            if ( data.type === 'LOD' ) {

                var levels = data.levels;

                for ( var l = 0; l < levels.length; l++ ) {

                    var level = levels[ l ];
                    var child = object.getObjectByProperty( 'uuid', level.object );

                    if ( child !== undefined ) {

                        object.addLevel( child, level.distance );

                    }

                }

            }

            return object;

        }

    }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

    constructor: THREE.TextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.ImageLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( image ) {

            var texture = new THREE.Texture( image );
            texture.needsUpdate = true;

            if ( onLoad !== undefined ) {

                onLoad( texture );

            }

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

    constructor: THREE.BinaryTextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texture = new THREE.DataTexture();

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        loader.load( url, function( buffer ) {

            var texData = scope._parser( buffer );

            if ( !texData ) return;

            if ( undefined !== texData.image ) {

                texture.image = texData.image;

            }
            else if ( undefined !== texData.data ) {

                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;

            }

            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

            if ( undefined !== texData.format ) {

                texture.format = texData.format;

            }
            if ( undefined !== texData.type ) {

                texture.type = texData.type;

            }

            if ( undefined !== texData.mipmaps ) {

                texture.mipmaps = texData.mipmaps;

            }

            if ( 1 === texData.mipmapCount ) {

                texture.minFilter = THREE.LinearFilter;

            }

            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture, texData );

        }, onProgress, onError );


        return texture;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

    constructor: THREE.CompressedTextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var images = [];

        var texture = new THREE.CompressedTexture();
        texture.image = images;

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        if ( Array.isArray( url ) ) {

            var loaded = 0;

            var loadTexture = function( i ) {

                loader.load( url[ i ], function( buffer ) {

                    var texDatas = scope._parser( buffer, true );

                    images[ i ] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };

                    loaded += 1;

                    if ( loaded === 6 ) {

                        if ( texDatas.mipmapCount === 1 )
                            texture.minFilter = THREE.LinearFilter;

                        texture.format = texDatas.format;
                        texture.needsUpdate = true;

                        if ( onLoad ) onLoad( texture );

                    }

                }, onProgress, onError );

            };

            for ( var i = 0, il = url.length; i < il; ++i ) {

                loadTexture( i );

            }

        }
        else {

            // compressed cubemap texture stored in a single DDS file

            loader.load( url, function( buffer ) {

                var texDatas = scope._parser( buffer, true );

                if ( texDatas.isCubemap ) {

                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                    for ( var f = 0; f < faces; f++ ) {

                        images[ f ] = {
                            mipmaps: []
                        };

                        for ( var i = 0; i < texDatas.mipmapCount; i++ ) {

                            images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
                            images[ f ].format = texDatas.format;
                            images[ f ].width = texDatas.width;
                            images[ f ].height = texDatas.height;

                        }

                    }

                }
                else {

                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;

                }

                if ( texDatas.mipmapCount === 1 ) {

                    texture.minFilter = THREE.LinearFilter;

                }

                texture.format = texDatas.format;
                texture.needsUpdate = true;

                if ( onLoad ) onLoad( texture );

            }, onProgress, onError );

        }

        return texture;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.MaterialIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Material';

    this.side = THREE.FrontSide;

    this.opacity = 1;
    this.transparent = false;

    this.blending = THREE.NormalBlending;

    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;

    this.depthFunc = THREE.LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;

    this.colorWrite = true;

    this.precision = null; // override the renderer's default precision for this material

    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;

    this.alphaTest = 0;

    this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    this.visible = true;

    this._needsUpdate = true;

};

THREE.Material.prototype = {

    constructor: THREE.Material,

    get needsUpdate() {

        return this._needsUpdate;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.update();

        this._needsUpdate = value;

    },

    setValues: function( values ) {

        if ( values === undefined ) return;

        for ( var key in values ) {

            var newValue = values[ key ];

            if ( newValue === undefined ) {

                console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
                continue;

            }

            var currentValue = this[ key ];

            if ( currentValue === undefined ) {

                console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
                continue;

            }

            if ( currentValue instanceof THREE.Color ) {

                currentValue.set( newValue );

            }
            else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

                currentValue.copy( newValue );

            }
            else if ( key === 'overdraw' ) {

                // ensure overdraw is backwards-compatible with legacy boolean type
                this[ key ] = Number( newValue );

            }
            else {

                this[ key ] = newValue;

            }

        }

    },

    toJSON: function( meta ) {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };

        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
        if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
        if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
        if ( this.shininess !== undefined ) data.shininess = this.shininess;

        if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
        if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
        if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
        if ( this.bumpMap instanceof THREE.Texture ) {

            data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
            data.bumpScale = this.bumpScale;

        }
        if ( this.normalMap instanceof THREE.Texture ) {

            data.normalMap = this.normalMap.toJSON( meta ).uuid;
            data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

        }
        if ( this.displacementMap instanceof THREE.Texture ) {

            data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;

        }
        if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
        if ( this.envMap instanceof THREE.Texture ) {

            data.envMap = this.envMap.toJSON( meta ).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap

        }

        if ( this.size !== undefined ) data.size = this.size;
        if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

        if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
        if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
        if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
        if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

        if ( this.opacity < 1 ) data.opacity = this.opacity;
        if ( this.transparent === true ) data.transparent = this.transparent;
        if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
        if ( this.wireframe === true ) data.wireframe = this.wireframe;
        if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.name = source.name;

        this.side = source.side;

        this.opacity = source.opacity;
        this.transparent = source.transparent;

        this.blending = source.blending;

        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;

        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;

        this.precision = source.precision;

        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;

        this.alphaTest = source.alphaTest;

        this.overdraw = source.overdraw;

        this.visible = source.visible;

        return this;

    },

    update: function() {

        this.dispatchEvent( {
            type: 'update'
        } );

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    },

    // Deprecated

    get wrapAround() {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    set wrapAround( boolean ) {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    get wrapRGB() {

        console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
        return new THREE.Color();

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineBasicMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineDashedMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;

    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;

    this.vertexColors = false;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;

    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshBasicMaterial';

    this.color = new THREE.Color( 0xffffff ); // emissive

    this.map = null;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshLambertMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );

    this.map = null;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );

    this.map = source.map;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshPhongMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );
    this.specular = new THREE.Color( 0x111111 );
    this.shininess = 30;

    this.metal = false;

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissiveMap = null;

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new THREE.Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );
    this.specular.copy( source.specular );
    this.shininess = source.shininess;

    this.metal = source.metal;

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissiveMap = source.emissiveMap;

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshDepthMaterial';

    this.morphTargets = false;
    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function( parameters ) {

    THREE.Material.call( this, parameters );

    this.type = 'MeshNormalMaterial';

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function( materials ) {

    this.uuid = THREE.Math.generateUUID();

    this.type = 'MultiMaterial';

    this.materials = materials instanceof Array ? materials : [];

    this.visible = true;

};

THREE.MultiMaterial.prototype = {

    constructor: THREE.MultiMaterial,

    toJSON: function() {

        var output = {
            metadata: {
                version: 4.2,
                type: 'material',
                generator: 'MaterialExporter'
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };

        for ( var i = 0, l = this.materials.length; i < l; i++ ) {

            output.materials.push( this.materials[ i ].toJSON() );

        }

        output.visible = this.visible;

        return output;

    },

    clone: function() {

        var material = new this.constructor();

        for ( var i = 0; i < this.materials.length; i++ ) {

            material.materials.push( this.materials[ i ].clone() );

        }

        material.visible = this.visible;

        return material;

    }

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'PointsMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.map = null;

    this.size = 1;
    this.sizeAttenuation = true;

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function( parameters ) {

    console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function( parameters ) {

    console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function( parameters ) {

    console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'ShaderMaterial';

    this.defines = {};
    this.uniforms = {};

    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    this.shading = THREE.SmoothShading;

    this.linewidth = 1;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false; // set to use scene fog

    this.lights = false; // set to use scene lights

    this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

    this.skinning = false; // set to use skinning attribute streams

    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals

    this.derivatives = false; // set to use derivatives

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [ 1, 1, 1 ],
        'uv': [ 0, 0 ],
        'uv2': [ 0, 0 ]
    };

    this.index0AttributeName = undefined;

    if ( parameters !== undefined ) {

        if ( parameters.attributes !== undefined ) {

            console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

        }

        this.setValues( parameters );

    }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;

    this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

    this.attributes = source.attributes;
    this.defines = source.defines;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    this.fog = source.fog;

    this.lights = source.lights;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;

    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    this.derivatives = source.derivatives;

    return this;

};

THREE.ShaderMaterial.prototype.toJSON = function( meta ) {

    var data = THREE.Material.prototype.toJSON.call( this, meta );

    data.uniforms = this.uniforms;
    data.attributes = this.attributes;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;

    return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function( parameters ) {

    THREE.ShaderMaterial.call( this, parameters );

    this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'SpriteMaterial';

    this.color = new THREE.Color( 0xffffff );
    this.map = null;

    this.rotation = 0;

    this.fog = false;

    // set parameters

    this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.map = source.map;

    this.rotation = source.rotation;

    this.fog = source.fog;

    return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    Object.defineProperty( this, 'id', {
        value: THREE.TextureIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.sourceFile = '';

    this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];

    this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    this.format = format !== undefined ? format : THREE.RGBAFormat;
    this.type = type !== undefined ? type : THREE.UnsignedByteType;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    this.version = 0;
    this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

    constructor: THREE.Texture,

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.image = source.image;
        this.mipmaps = source.mipmaps.slice( 0 );

        this.mapping = source.mapping;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.format = source.format;
        this.type = source.type;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;

        return this;

    },

    toJSON: function( meta ) {

        if ( meta.textures[ this.uuid ] !== undefined ) {

            return meta.textures[ this.uuid ];

        }

        function getDataURL( image ) {

            var canvas;

            if ( image.toDataURL !== undefined ) {

                canvas = image;

            }
            else {

                canvas = document.createElement( 'canvas' );
                canvas.width = image.width;
                canvas.height = image.height;

                canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {

                return canvas.toDataURL( 'image/jpeg', 0.6 );

            }
            else {

                return canvas.toDataURL( 'image/png' );

            }

        }

        var output = {
            metadata: {
                version: 4.4,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },

            uuid: this.uuid,
            name: this.name,

            mapping: this.mapping,

            repeat: [ this.repeat.x, this.repeat.y ],
            offset: [ this.offset.x, this.offset.y ],
            wrap: [ this.wrapS, this.wrapT ],

            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };

        if ( this.image !== undefined ) {

            // TODO: Move to THREE.Image

            var image = this.image;

            if ( image.uuid === undefined ) {

                image.uuid = THREE.Math.generateUUID(); // UGH

            }

            if ( meta.images[ image.uuid ] === undefined ) {

                meta.images[ image.uuid ] = {
                    uuid: image.uuid,
                    url: getDataURL( image )
                };

            }

            output.image = image.uuid;

        }

        meta.textures[ this.uuid ] = output;

        return output;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    },

    transformUv: function( uv ) {

        if ( this.mapping !== THREE.UVMapping ) return;

        uv.multiply( this.repeat );
        uv.add( this.offset );

        if ( uv.x < 0 || uv.x > 1 ) {

            switch ( this.wrapS ) {

                case THREE.RepeatWrapping:

                    uv.x = uv.x - Math.floor( uv.x );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

                        uv.x = Math.ceil( uv.x ) - uv.x;

                    }
                    else {

                        uv.x = uv.x - Math.floor( uv.x );

                    }
                    break;

            }

        }

        if ( uv.y < 0 || uv.y > 1 ) {

            switch ( this.wrapT ) {

                case THREE.RepeatWrapping:

                    uv.y = uv.y - Math.floor( uv.y );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

                        uv.y = Math.ceil( uv.y ) - uv.y;

                    }
                    else {

                        uv.y = uv.y - Math.floor( uv.y );

                    }
                    break;

            }

        }

        if ( this.flipY ) {

            uv.y = 1 - uv.y;

        }

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

    THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.images = images;
    this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function( source ) {

    THREE.Texture.prototype.copy.call( this, source );

    this.images = source.images;

    return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;

    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    this.flipY = false;

    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = {
        data: data,
        width: width,
        height: height
    };

    this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

    this.flipY = false;
    this.generateMipmaps = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.generateMipmaps = false;

    var scope = this;

    var update = function() {

        requestAnimationFrame( update );

        if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

            scope.needsUpdate = true;

        }

    };

    update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function() {

    THREE.Object3D.call( this );

    this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Points';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.PointsMaterial( {
        color: Math.random() * 0xffffff
    } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();

    return function raycast( raycaster, intersects ) {

        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.Points.threshold;

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();

        function testPoint( point, index ) {

            var rayPointDistanceSq = ray.distanceSqToPoint( point );

            if ( rayPointDistanceSq < localThresholdSq ) {

                var intersectPoint = ray.closestPointToPoint( point );
                intersectPoint.applyMatrix4( object.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectPoint );

                if ( distance < raycaster.near || distance > raycaster.far ) return;

                intersects.push( {

                    distance: distance,
                    distanceToRay: Math.sqrt( rayPointDistanceSq ),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object

                } );

            }

        }

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if ( index !== null ) {

                var indices = index.array;

                for ( var i = 0, il = indices.length; i < il; i++ ) {

                    var a = indices[ i ];

                    position.fromArray( positions, a * 3 );

                    testPoint( position, a );

                }

            }
            else {

                for ( var i = 0, l = positions.length / 3; i < l; i++ ) {

                    position.fromArray( positions, i * 3 );

                    testPoint( position, i );

                }

            }

        }
        else {

            var vertices = geometry.vertices;

            for ( var i = 0, l = vertices.length; i < l; i++ ) {

                testPoint( vertices[ i ], i );

            }

        }

    };

}() );

THREE.Points.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Points.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// Backwards compatibility

THREE.PointCloud = function( geometry, material ) {

    console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function( geometry, material ) {

    console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function( geometry, material, mode ) {

    if ( mode === 1 ) {

        console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
        return new THREE.LineSegments( geometry, material );

    }

    THREE.Object3D.call( this );

    this.type = 'Line';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.LineBasicMaterial( {
        color: Math.random() * 0xffffff
    } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    return function raycast( raycaster, intersects ) {

        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;

        var geometry = this.geometry;

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        // Checking boundingSphere distance to ray

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this instanceof THREE.LineSegments ? 2 : 1;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

                    var a = indices[ i ];
                    var b = indices[ i + 1 ];

                    vStart.fromArray( positions, a * 3 );
                    vEnd.fromArray( positions, b * 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }
            else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

                    vStart.fromArray( positions, 3 * i );
                    vEnd.fromArray( positions, 3 * i + 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }

        }
        else if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;
            var nbVertices = vertices.length;

            for ( var i = 0; i < nbVertices - 1; i += step ) {

                var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

                if ( distSq > precisionSq ) continue;

                interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                var distance = raycaster.ray.origin.distanceTo( interRay );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                intersects.push( {

                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Line.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Line.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function( geometry, material ) {

    THREE.Line.call( this, geometry, material );

    this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Mesh';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( {
        color: Math.random() * 0xffffff
    } );

    this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function() {

    if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

        this.morphTargetBase = -1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};

        for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++ ) {

            this.morphTargetInfluences.push( 0 );
            this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

        }

    }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function( name ) {

    if ( this.morphTargetDictionary[ name ] !== undefined ) {

        return this.morphTargetDictionary[ name ];

    }

    console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

    return 0;

};


THREE.Mesh.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var tempA = new THREE.Vector3();
    var tempB = new THREE.Vector3();
    var tempC = new THREE.Vector3();

    var uvA = new THREE.Vector2();
    var uvB = new THREE.Vector2();
    var uvC = new THREE.Vector2();

    var barycoord = new THREE.Vector3();

    var intersectionPoint = new THREE.Vector3();
    var intersectionPointWorld = new THREE.Vector3();

    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

        uv1.multiplyScalar( barycoord.x );
        uv2.multiplyScalar( barycoord.y );
        uv3.multiplyScalar( barycoord.z );

        uv1.add( uv2 ).add( uv3 );

        return uv1.clone();

    }

    return function raycast( raycaster, intersects ) {

        var geometry = this.geometry;
        var material = this.material;

        if ( material === undefined ) return;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        // Check boundingBox before continuing

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var a, b, c;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                    a = indices[ i ];
                    b = indices[ i + 1 ];
                    c = indices[ i + 2 ];

                    vA.fromArray( positions, a * 3 );
                    vB.fromArray( positions, b * 3 );
                    vC.fromArray( positions, c * 3 );

                    if ( material.side === THREE.BackSide ) {

                        if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

                    }
                    else {

                        if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                    }

                    intersectionPointWorld.copy( intersectionPoint );
                    intersectionPointWorld.applyMatrix4( this.matrixWorld );

                    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    var uv;

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;
                        uvA.fromArray( uvs, a * 2 );
                        uvB.fromArray( uvs, b * 2 );
                        uvC.fromArray( uvs, c * 2 );
                        uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

                    }

                    intersects.push( {

                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        uv: uv,
                        face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
                        faceIndex: Math.floor( i / 3 ), // triangle number in indices buffer semantics
                        object: this

                    } );

                }

            }
            else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length; i < l; i += 9 ) {

                    vA.fromArray( positions, i );
                    vB.fromArray( positions, i + 3 );
                    vC.fromArray( positions, i + 6 );

                    if ( material.side === THREE.BackSide ) {

                        if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

                    }
                    else {

                        if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                    }

                    intersectionPointWorld.copy( intersectionPoint );
                    intersectionPointWorld.applyMatrix4( this.matrixWorld );

                    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    var uv;

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;
                        uvA.fromArray( uvs, i );
                        uvB.fromArray( uvs, i + 2 );
                        uvC.fromArray( uvs, i + 4 );
                        uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

                    }

                    a = i / 3;
                    b = a + 1;
                    c = a + 2;

                    intersects.push( {

                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        uv: uv,
                        face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
                        index: a, // triangle number in positions buffer semantics
                        object: this

                    } );

                }

            }

        }
        else if ( geometry instanceof THREE.Geometry ) {

            var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
            var materials = isFaceMaterial === true ? material.materials : null;

            var vertices = geometry.vertices;
            var faces = geometry.faces;

            for ( var f = 0, fl = faces.length; f < fl; f++ ) {

                var face = faces[ f ];
                var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

                if ( faceMaterial === undefined ) continue;

                a = vertices[ face.a ];
                b = vertices[ face.b ];
                c = vertices[ face.c ];

                if ( faceMaterial.morphTargets === true ) {

                    var morphTargets = geometry.morphTargets;
                    var morphInfluences = this.morphTargetInfluences;

                    vA.set( 0, 0, 0 );
                    vB.set( 0, 0, 0 );
                    vC.set( 0, 0, 0 );

                    for ( var t = 0, tl = morphTargets.length; t < tl; t++ ) {

                        var influence = morphInfluences[ t ];

                        if ( influence === 0 ) continue;

                        var targets = morphTargets[ t ].vertices;

                        vA.addScaledVector( tempA.subVectors( targets[ face.a ], a ), influence );
                        vB.addScaledVector( tempB.subVectors( targets[ face.b ], b ), influence );
                        vC.addScaledVector( tempC.subVectors( targets[ face.c ], c ), influence );

                    }

                    vA.add( a );
                    vB.add( b );
                    vC.add( c );

                    a = vA;
                    b = vB;
                    c = vC;

                }

                if ( faceMaterial.side === THREE.BackSide ) {

                    if ( ray.intersectTriangle( c, b, a, true, intersectionPoint ) === null ) continue;

                }
                else {

                    if ( ray.intersectTriangle( a, b, c, faceMaterial.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                }

                intersectionPointWorld.copy( intersectionPoint );
                intersectionPointWorld.applyMatrix4( this.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                var uv;

                if ( geometry.faceVertexUvs[ 0 ].length > 0 ) {

                    var uvs = geometry.faceVertexUvs[ 0 ][ f ];
                    uvA.copy( uvs[ 0 ] );
                    uvB.copy( uvs[ 1 ] );
                    uvC.copy( uvs[ 2 ] );
                    uv = uvIntersection( intersectionPoint, a, b, c, uvA, uvB, uvC );

                }

                intersects.push( {

                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    uv: uv,
                    face: face,
                    faceIndex: f,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Mesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Mesh.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function( skin ) {

    THREE.Object3D.call( this );

    this.type = 'Bone';

    this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.skin = source.skin;

    return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function( bones, boneInverses, useVertexTexture ) {

    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    this.identityMatrix = new THREE.Matrix4();

    // copy the bone array

    bones = bones || [];

    this.bones = bones.slice( 0 );

    // create a bone texture or an array of floats

    if ( this.useVertexTexture ) {

        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


        var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
        size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
        size = Math.max( size, 4 );

        this.boneTextureWidth = size;
        this.boneTextureHeight = size;

        this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
        this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

    }
    else {

        this.boneMatrices = new Float32Array( 16 * this.bones.length );

    }

    // use the supplied bone inverses or calculate the inverses

    if ( boneInverses === undefined ) {

        this.calculateInverses();

    }
    else {

        if ( this.bones.length === boneInverses.length ) {

            this.boneInverses = boneInverses.slice( 0 );

        }
        else {

            console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

            this.boneInverses = [];

            for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

                this.boneInverses.push( new THREE.Matrix4() );

            }

        }

    }

};

THREE.Skeleton.prototype.calculateInverses = function() {

    this.boneInverses = [];

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        var inverse = new THREE.Matrix4();

        if ( this.bones[ b ] ) {

            inverse.getInverse( this.bones[ b ].matrixWorld );

        }

        this.boneInverses.push( inverse );

    }

};

THREE.Skeleton.prototype.pose = function() {

    var bone;

    // recover the bind-time world matrices

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            bone.matrixWorld.getInverse( this.boneInverses[ b ] );

        }

    }

    // compute the local matrices, positions, rotations and scales

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            if ( bone.parent ) {

                bone.matrix.getInverse( bone.parent.matrixWorld );
                bone.matrix.multiply( bone.matrixWorld );

            }
            else {

                bone.matrix.copy( bone.matrixWorld );

            }

            bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

        }

    }

};

THREE.Skeleton.prototype.update = ( function() {

    var offsetMatrix = new THREE.Matrix4();

    return function update() {

        // flatten bone matrices to array

        for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

            // compute the offset between the current and the original transform

            var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

            offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
            offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

        }

        if ( this.useVertexTexture ) {

            this.boneTexture.needsUpdate = true;

        }

    };

} )();

THREE.Skeleton.prototype.clone = function() {

    return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function( geometry, material, useVertexTexture ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'SkinnedMesh';

    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();

    // init bones

    // TODO: remove bone creation as there is no reason (other than
    // convenience) for THREE.SkinnedMesh to do this.

    var bones = [];

    if ( this.geometry && this.geometry.bones !== undefined ) {

        var bone, gbone;

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

            gbone = this.geometry.bones[ b ];

            bone = new THREE.Bone( this );
            bones.push( bone );

            bone.name = gbone.name;
            bone.position.fromArray( gbone.pos );
            bone.quaternion.fromArray( gbone.rotq );
            if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

        }

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

            gbone = this.geometry.bones[ b ];

            if ( gbone.parent !== -1 ) {

                bones[ gbone.parent ].add( bones[ b ] );

            }
            else {

                this.add( bones[ b ] );

            }

        }

    }

    this.normalizeSkinWeights();

    this.updateMatrixWorld( true );
    this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

    this.skeleton = skeleton;

    if ( bindMatrix === undefined ) {

        this.updateMatrixWorld( true );

        this.skeleton.calculateInverses();

        bindMatrix = this.matrixWorld;

    }

    this.bindMatrix.copy( bindMatrix );
    this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function() {

    this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {

    if ( this.geometry instanceof THREE.Geometry ) {

        for ( var i = 0; i < this.geometry.skinIndices.length; i++ ) {

            var sw = this.geometry.skinWeights[ i ];

            var scale = 1.0 / sw.lengthManhattan();

            if ( scale !== Infinity ) {

                sw.multiplyScalar( scale );

            }
            else {

                sw.set( 1 ); // this will be normalized by the shader anyway

            }

        }

    }
    else {

        // skinning weights assumed to be normalized for THREE.BufferGeometry

    }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

    THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

    if ( this.bindMode === "attached" ) {

        this.bindMatrixInverse.getInverse( this.matrixWorld );

    }
    else if ( this.bindMode === "detached" ) {

        this.bindMatrixInverse.getInverse( this.bindMatrix );

    }
    else {

        console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    }

};

THREE.SkinnedMesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'MorphAnimMesh';

    // API

    this.duration = 1000; // milliseconds
    this.mirroredLoop = false;
    this.time = 0;

    // internals

    this.lastKeyframe = 0;
    this.currentKeyframe = 0;

    this.direction = 1;
    this.directionBackwards = false;

    this.setFrameRange( 0, geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function( start, end ) {

    this.startKeyframe = start;
    this.endKeyframe = end;

    this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function() {

    this.direction = 1;
    this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {

    this.direction = -1;
    this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function() {

    var geometry = this.geometry;

    if ( !geometry.animations ) geometry.animations = {};

    var firstAnimation, animations = geometry.animations;

    var pattern = /([a-z]+)_?(\d+)/;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i++ ) {

        var morph = geometry.morphTargets[ i ];
        var parts = morph.name.match( pattern );

        if ( parts && parts.length > 1 ) {

            var label = parts[ 1 ];

            if ( !animations[ label ] ) animations[ label ] = {
                start: Infinity,
                end: -Infinity
            };

            var animation = animations[ label ];

            if ( i < animation.start ) animation.start = i;
            if ( i > animation.end ) animation.end = i;

            if ( !firstAnimation ) firstAnimation = label;

        }

    }

    geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function( label, start, end ) {

    if ( !this.geometry.animations ) this.geometry.animations = {};

    this.geometry.animations[ label ] = {
        start: start,
        end: end
    };

};

THREE.MorphAnimMesh.prototype.playAnimation = function( label, fps ) {

    var animation = this.geometry.animations[ label ];

    if ( animation ) {

        this.setFrameRange( animation.start, animation.end );
        this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
        this.time = 0;

    }
    else {

        console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

    }

};

THREE.MorphAnimMesh.prototype.updateAnimation = function( delta ) {

    var frameTime = this.duration / this.length;

    this.time += this.direction * delta;

    if ( this.mirroredLoop ) {

        if ( this.time > this.duration || this.time < 0 ) {

            this.direction *= -1;

            if ( this.time > this.duration ) {

                this.time = this.duration;
                this.directionBackwards = true;

            }

            if ( this.time < 0 ) {

                this.time = 0;
                this.directionBackwards = false;

            }

        }

    }
    else {

        this.time = this.time % this.duration;

        if ( this.time < 0 ) this.time += this.duration;

    }

    var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

    var influences = this.morphTargetInfluences;

    if ( keyframe !== this.currentKeyframe ) {

        influences[ this.lastKeyframe ] = 0;
        influences[ this.currentKeyframe ] = 1;
        influences[ keyframe ] = 0;

        this.lastKeyframe = this.currentKeyframe;
        this.currentKeyframe = keyframe;

    }

    var mix = ( this.time % frameTime ) / frameTime;

    if ( this.directionBackwards ) {

        mix = 1 - mix;

    }

    influences[ this.currentKeyframe ] = mix;
    influences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function( a, b, t ) {

    var influences = this.morphTargetInfluences;

    for ( var i = 0, l = influences.length; i < l; i++ ) {

        influences[ i ] = 0;

    }

    if ( a > -1 ) influences[ a ] = 1 - t;
    if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.copy = function( source ) {

    THREE.Mesh.prototype.copy.call( this, source );

    this.duration = source.duration;
    this.mirroredLoop = source.mirroredLoop;
    this.time = source.time;

    this.lastKeyframe = source.lastKeyframe;
    this.currentKeyframe = source.currentKeyframe;

    this.direction = source.direction;
    this.directionBackwards = source.directionBackwards;

    return this;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function() {

    THREE.Object3D.call( this );

    this.type = 'LOD';

    Object.defineProperties( this, {
        levels: {
            enumerable: true,
            value: []
        },
        objects: {
            get: function() {

                console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
                return this.levels;

            }
        }
    } );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function( object, distance ) {

    if ( distance === undefined ) distance = 0;

    distance = Math.abs( distance );

    var levels = this.levels;

    for ( var l = 0; l < levels.length; l++ ) {

        if ( distance < levels[ l ].distance ) {

            break;

        }

    }

    levels.splice( l, 0, {
        distance: distance,
        object: object
    } );

    this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function( distance ) {

    var levels = this.levels;

    for ( var i = 1, l = levels.length; i < l; i++ ) {

        if ( distance < levels[ i ].distance ) {

            break;

        }

    }

    return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function() {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( matrixPosition );

        this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    };

}() );

THREE.LOD.prototype.update = function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function update( camera ) {

        var levels = this.levels;

        if ( levels.length > 1 ) {

            v1.setFromMatrixPosition( camera.matrixWorld );
            v2.setFromMatrixPosition( this.matrixWorld );

            var distance = v1.distanceTo( v2 );

            levels[ 0 ].object.visible = true;

            for ( var i = 1, l = levels.length; i < l; i++ ) {

                if ( distance >= levels[ i ].distance ) {

                    levels[ i - 1 ].object.visible = false;
                    levels[ i ].object.visible = true;

                }
                else {

                    break;

                }

            }

            for ( ; i < l; i++ ) {

                levels[ i ].object.visible = false;

            }

        }

    };

}();

THREE.LOD.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source, false );

    var levels = source.levels;

    for ( var i = 0, l = levels.length; i < l; i++ ) {

        var level = levels[ i ];

        this.addLevel( level.object.clone(), level.distance );

    }

    return this;

};

THREE.LOD.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.levels = [];

    var levels = this.levels;

    for ( var i = 0, l = levels.length; i < l; i++ ) {

        var level = levels[ i ];

        data.object.levels.push( {
            object: level.object.uuid,
            distance: level.distance
        } );

    }

    return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function() {

    var indices = new Uint16Array( [ 0, 1, 2, 0, 2, 3 ] );
    var vertices = new Float32Array( [ -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0 ] );
    var uvs = new Float32Array( [ 0, 0, 1, 0, 1, 1, 0, 1 ] );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    return function Sprite( material ) {

        THREE.Object3D.call( this );

        this.type = 'Sprite';

        this.geometry = geometry;
        this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

    };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function() {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
        var guessSizeSq = this.scale.x * this.scale.y;

        if ( distanceSq > guessSizeSq ) {

            return;

        }

        intersects.push( {

            distance: Math.sqrt( distanceSq ),
            point: this.position,
            face: null,
            object: this

        } );

    };

}() );

THREE.Sprite.prototype.clone = function() {

    return new this.constructor( this.material ).copy( this );

};

THREE.Sprite.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.material = this.material.uuid;

    return data;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function( texture, size, distance, blending, color ) {

    THREE.Object3D.call( this );

    this.lensFlares = [];

    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;

    if ( texture !== undefined ) {

        this.add( texture, size, distance, blending, color );

    }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function( texture, size, distance, blending, color, opacity ) {

    if ( size === undefined ) size = -1;
    if ( distance === undefined ) distance = 0;
    if ( opacity === undefined ) opacity = 1;
    if ( color === undefined ) color = new THREE.Color( 0xffffff );
    if ( blending === undefined ) blending = THREE.NormalBlending;

    distance = Math.min( distance, Math.max( 0, distance ) );

    this.lensFlares.push( {
        texture: texture, // THREE.Texture
        size: size, // size in pixels (-1 = use texture.width)
        distance: distance, // distance (0-1) from light source (0=at light source)
        x: 0,
        y: 0,
        z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back
        scale: 1, // scale
        rotation: 0, // rotation
        opacity: opacity, // opacity
        color: color, // color
        blending: blending // blending
    } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function() {

    var f, fl = this.lensFlares.length;
    var flare;
    var vecX = -this.positionScreen.x * 2;
    var vecY = -this.positionScreen.y * 2;

    for ( f = 0; f < fl; f++ ) {

        flare = this.lensFlares[ f ];

        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;

        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    }

};

THREE.LensFlare.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.positionScreen.copy( source.positionScreen );
    this.customUpdateCallback = source.customUpdateCallback;

    for ( var i = 0, l = source.lensFlares.length; i < l; i++ ) {

        this.lensFlares.push( source.lensFlares[ i ] );

    }

    return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function() {

    THREE.Object3D.call( this );

    this.type = 'Scene';

    this.fog = null;
    this.overrideMaterial = null;

    this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    if ( source.fog !== null ) this.fog = source.fog.clone();
    if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;

    return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function( color, near, far ) {

    this.name = '';

    this.color = new THREE.Color( color );

    this.near = ( near !== undefined ) ? near : 1;
    this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function() {

    return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function( color, density ) {

    this.name = '';

    this.color = new THREE.Color( color );
    this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function() {

    return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment' ] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment' ] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment' ] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment' ] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment' ] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex' ] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex' ] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment' ] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment' ] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex' ] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex' ] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common' ] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n	// Original approximation by Christophe Schlick '94\n	//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n	// geometry term is (nl)(nv) / 4(nl)(nv)\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n	// factor of 1/PI in distribution term omitted\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	//float dotNL = saturate( dot( normal, lightDir ) );\n	//float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex' ] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment' ] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment' ] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment' ] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment' ] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment' ] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment' ] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment' ] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex' ] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex' ] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment' ] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n			// specular\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += lightColor;\n\n		// specular (sky term only)\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex' ] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment' ] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment' ] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment' ] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment' ] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment' ] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment' ] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment' ] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex' ] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment' ] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n		#endif\n\n	}\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex' ] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex' ] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex' ] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex' ] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex' ] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment' ] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment' ] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex' ] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

    merge: function( uniforms ) {

        var merged = {};

        for ( var u = 0; u < uniforms.length; u++ ) {

            var tmp = this.clone( uniforms[ u ] );

            for ( var p in tmp ) {

                merged[ p ] = tmp[ p ];

            }

        }

        return merged;

    },

    clone: function( uniforms_src ) {

        var uniforms_dst = {};

        for ( var u in uniforms_src ) {

            uniforms_dst[ u ] = {};

            for ( var p in uniforms_src[ u ] ) {

                var parameter_src = uniforms_src[ u ][ p ];

                if ( parameter_src instanceof THREE.Color ||
                    parameter_src instanceof THREE.Vector2 ||
                    parameter_src instanceof THREE.Vector3 ||
                    parameter_src instanceof THREE.Vector4 ||
                    parameter_src instanceof THREE.Matrix3 ||
                    parameter_src instanceof THREE.Matrix4 ||
                    parameter_src instanceof THREE.Texture ) {

                    uniforms_dst[ u ][ p ] = parameter_src.clone();

                }
                else if ( Array.isArray( parameter_src ) ) {

                    uniforms_dst[ u ][ p ] = parameter_src.slice();

                }
                else {

                    uniforms_dst[ u ][ p ] = parameter_src;

                }

            }

        }

        return uniforms_dst;

    }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

    common: {

        "diffuse": {
            type: "c",
            value: new THREE.Color( 0xeeeeee )
        },
        "opacity": {
            type: "f",
            value: 1.0
        },

        "map": {
            type: "t",
            value: null
        },
        "offsetRepeat": {
            type: "v4",
            value: new THREE.Vector4( 0, 0, 1, 1 )
        },

        "specularMap": {
            type: "t",
            value: null
        },
        "alphaMap": {
            type: "t",
            value: null
        },

        "envMap": {
            type: "t",
            value: null
        },
        "flipEnvMap": {
            type: "f",
            value: -1
        },
        "reflectivity": {
            type: "f",
            value: 1.0
        },
        "refractionRatio": {
            type: "f",
            value: 0.98
        }

    },

    aomap: {

        "aoMap": {
            type: "t",
            value: null
        },
        "aoMapIntensity": {
            type: "f",
            value: 1
        },

    },

    lightmap: {

        "lightMap": {
            type: "t",
            value: null
        },
        "lightMapIntensity": {
            type: "f",
            value: 1
        },

    },

    emissivemap: {

        "emissiveMap": {
            type: "t",
            value: null
        },

    },

    bumpmap: {

        "bumpMap": {
            type: "t",
            value: null
        },
        "bumpScale": {
            type: "f",
            value: 1
        }

    },

    normalmap: {

        "normalMap": {
            type: "t",
            value: null
        },
        "normalScale": {
            type: "v2",
            value: new THREE.Vector2( 1, 1 )
        }

    },

    displacementmap: {

        "displacementMap": {
            type: "t",
            value: null
        },
        "displacementScale": {
            type: "f",
            value: 1
        },
        "displacementBias": {
            type: "f",
            value: 0
        }

    },

    fog: {

        "fogDensity": {
            type: "f",
            value: 0.00025
        },
        "fogNear": {
            type: "f",
            value: 1
        },
        "fogFar": {
            type: "f",
            value: 2000
        },
        "fogColor": {
            type: "c",
            value: new THREE.Color( 0xffffff )
        }

    },

    lights: {

        "ambientLightColor": {
            type: "fv",
            value: []
        },

        "directionalLightDirection": {
            type: "fv",
            value: []
        },
        "directionalLightColor": {
            type: "fv",
            value: []
        },

        "hemisphereLightDirection": {
            type: "fv",
            value: []
        },
        "hemisphereLightSkyColor": {
            type: "fv",
            value: []
        },
        "hemisphereLightGroundColor": {
            type: "fv",
            value: []
        },

        "pointLightColor": {
            type: "fv",
            value: []
        },
        "pointLightPosition": {
            type: "fv",
            value: []
        },
        "pointLightDistance": {
            type: "fv1",
            value: []
        },
        "pointLightDecay": {
            type: "fv1",
            value: []
        },

        "spotLightColor": {
            type: "fv",
            value: []
        },
        "spotLightPosition": {
            type: "fv",
            value: []
        },
        "spotLightDirection": {
            type: "fv",
            value: []
        },
        "spotLightDistance": {
            type: "fv1",
            value: []
        },
        "spotLightAngleCos": {
            type: "fv1",
            value: []
        },
        "spotLightExponent": {
            type: "fv1",
            value: []
        },
        "spotLightDecay": {
            type: "fv1",
            value: []
        }

    },

    points: {

        "psColor": {
            type: "c",
            value: new THREE.Color( 0xeeeeee )
        },
        "opacity": {
            type: "f",
            value: 1.0
        },
        "size": {
            type: "f",
            value: 1.0
        },
        "scale": {
            type: "f",
            value: 1.0
        },
        "map": {
            type: "t",
            value: null
        },
        "offsetRepeat": {
            type: "v4",
            value: new THREE.Vector4( 0, 0, 1, 1 )
        },

        "fogDensity": {
            type: "f",
            value: 0.00025
        },
        "fogNear": {
            type: "f",
            value: 1
        },
        "fogFar": {
            type: "f",
            value: 2000
        },
        "fogColor": {
            type: "c",
            value: new THREE.Color( 0xffffff )
        }

    },

    shadowmap: {

        "shadowMap": {
            type: "tv",
            value: []
        },
        "shadowMapSize": {
            type: "v2v",
            value: []
        },

        "shadowBias": {
            type: "fv1",
            value: []
        },
        "shadowDarkness": {
            type: "fv1",
            value: []
        },

        "shadowMatrix": {
            type: "m4v",
            value: []
        }

    }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

    'basic': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],

            "	#ifdef USE_ENVMAP",

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "	#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],

            "	outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ], // TODO: Shadows on an otherwise unlit surface doesn't make sense.

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'lambert': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive": {
                    type: "c",
                    value: new THREE.Color( 0x000000 )
                }
            }

        ] ),

        vertexShader: [

            "#define LAMBERT",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform float opacity;",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],

            "	#ifdef DOUBLE_SIDED",

            "		if ( gl_FrontFacing )",
            "			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
            "		else",
            "			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

            "	#else",

            "		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

            "	#endif",

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'phong': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "lightmap" ],
            THREE.UniformsLib[ "emissivemap" ],
            THREE.UniformsLib[ "bumpmap" ],
            THREE.UniformsLib[ "normalmap" ],
            THREE.UniformsLib[ "displacementmap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive": {
                    type: "c",
                    value: new THREE.Color( 0x000000 )
                },
                "specular": {
                    type: "c",
                    value: new THREE.Color( 0x111111 )
                },
                "shininess": {
                    type: "f",
                    value: 30
                }
            }

        ] ),

        vertexShader: [

            "#define PHONG",

            "varying vec3 vViewPosition;",

            "#ifndef FLAT_SHADED",

            "	varying vec3 vNormal;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

            "	vNormal = normalize( transformedNormal );",

            "#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "displacementmap_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "	vViewPosition = - mvPosition.xyz;",

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_phong_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "#define PHONG",

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "lightmap_pars_fragment" ],
            THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
            THREE.ShaderChunk[ "normalmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = ambientLightColor;",
            "	vec3 totalEmissiveLight = emissive;",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "lightmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],
            THREE.ShaderChunk[ "emissivemap_fragment" ],

            THREE.ShaderChunk[ "lights_phong_fragment" ],

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'points': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "points" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            "uniform float size;",
            "uniform float scale;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

            "	#ifdef USE_SIZEATTENUATION",
            "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
            "	#else",
            "		gl_PointSize = size;",
            "	#endif",

            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],
            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 psColor;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "map_particle_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( psColor, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_particle_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "shadowmap_fragment" ],
            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'dashed': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],

            {
                "scale": {
                    type: "f",
                    value: 1
                },
                "dashSize": {
                    type: "f",
                    value: 1
                },
                "totalSize": {
                    type: "f",
                    value: 2
                }
            }

        ] ),

        vertexShader: [

            "uniform float scale;",
            "attribute float lineDistance;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vLineDistance = scale * lineDistance;",

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            "uniform float dashSize;",
            "uniform float totalSize;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

            "		discard;",

            "	}",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'depth': {

        uniforms: {

            "mNear": {
                type: "f",
                value: 1.0
            },
            "mFar": {
                type: "f",
                value: 2000.0
            },
            "opacity": {
                type: "f",
                value: 1.0
            }

        },

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float mNear;",
            "uniform float mFar;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

            "	#else",

            "		float depth = gl_FragCoord.z / gl_FragCoord.w;",

            "	#endif",

            "	float color = 1.0 - smoothstep( mNear, mFar, depth );",
            "	gl_FragColor = vec4( vec3( color ), opacity );",

            "}"

        ].join( "\n" )

    },

    'normal': {

        uniforms: {

            "opacity": {
                type: "f",
                value: 1.0
            }

        },

        vertexShader: [

            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vNormal = normalize( normalMatrix * normal );",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float opacity;",
            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

    'cube': {

        uniforms: {
            "tCube": {
                type: "t",
                value: null
            },
            "tFlip": {
                type: "f",
                value: -1
            }
        },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform samplerCube tCube;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

    'equirect': {

        uniforms: {
            "tEquirect": {
                type: "t",
                value: null
            },
            "tFlip": {
                type: "f",
                value: -1
            }
        },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform sampler2D tEquirect;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            // "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            "vec3 direction = normalize( vWorldPosition );",
            "vec2 sampleUV;",
            "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
            "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
            "gl_FragColor = texture2D( tEquirect, sampleUV );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* Depth encoding into RGBA texture
     *
     * based on SpiderGL shadow map example
     * http://spidergl.org/example.php?id=6
     *
     * originally from
     * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
     *
     * see also
     * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
     */

    'depthRGBA': {

        uniforms: {},

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "skinbase_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "vec4 pack_depth( const in float depth ) {",

            "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
            "	res -= res.xxyz * bit_mask;",
            "	return res;",

            "}",

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

            "	#else",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

            "	#endif",

            //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
            //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
            //"gl_FragData[ 0 ] = pack_depth( z );",
            //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

            "}"

        ].join( "\n" )

    }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function( parameters ) {

    console.log( 'THREE.WebGLRenderer', THREE.REVISION );

    parameters = parameters || {};

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
        _context = parameters.context !== undefined ? parameters.context : null,

        _width = _canvas.width,
        _height = _canvas.height,

        pixelRatio = 1,

        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

        _clearColor = new THREE.Color( 0x000000 ),
        _clearAlpha = 0;

    var lights = [];

    var opaqueObjects = [];
    var opaqueObjectsLastIndex = -1;
    var transparentObjects = [];
    var transparentObjectsLastIndex = -1;

    var opaqueImmediateObjects = [];
    var opaqueImmediateObjectsLastIndex = -1;
    var transparentImmediateObjects = [];
    var transparentImmediateObjectsLastIndex = -1;

    var morphInfluences = new Float32Array( 8 );


    var sprites = [];
    var lensFlares = [];

    // public properties

    this.domElement = _canvas;
    this.context = null;

    // clearing

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;

    // scene graph

    this.sortObjects = true;

    // physically based shading

    this.gammaFactor = 2.0; // for backwards compatibility
    this.gammaInput = false;
    this.gammaOutput = false;

    // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;

    // flags

    this.autoScaleCubemaps = true;

    // internal properties

    var _this = this,

        // internal state cache

        _currentProgram = null,
        _currentFramebuffer = null,
        _currentMaterialId = -1,
        _currentGeometryProgram = '',
        _currentCamera = null,

        _usedTextureUnits = 0,

        _viewportX = 0,
        _viewportY = 0,
        _viewportWidth = _canvas.width,
        _viewportHeight = _canvas.height,
        _currentWidth = 0,
        _currentHeight = 0,

        // frustum

        _frustum = new THREE.Frustum(),

        // camera matrices cache

        _projScreenMatrix = new THREE.Matrix4(),

        _vector3 = new THREE.Vector3(),

        // light arrays cache

        _direction = new THREE.Vector3(),

        _lightsNeedUpdate = true,

        _lights = {

            ambient: [ 0, 0, 0 ],
            directional: {
                length: 0,
                colors: [],
                positions: []
            },
            point: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                decays: []
            },
            spot: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                directions: [],
                anglesCos: [],
                exponents: [],
                decays: []
            },
            hemi: {
                length: 0,
                skyColors: [],
                groundColors: [],
                positions: []
            }

        },

        // info

        _infoMemory = {

            geometries: 0,
            textures: 0

        },

        _infoRender = {

            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0

        };

    this.info = {

        render: _infoRender,
        memory: _infoMemory,
        programs: null

    };


    // initialize

    var _gl;

    try {

        var attributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer
        };

        _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

        if ( _gl === null ) {

            if ( _canvas.getContext( 'webgl' ) !== null ) {

                throw 'Error creating WebGL context with your selected attributes.';

            }
            else {

                throw 'Error creating WebGL context.';

            }

        }

        _canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    }
    catch ( error ) {

        console.error( 'THREE.WebGLRenderer: ' + error );

    }

    var extensions = new THREE.WebGLExtensions( _gl );

    extensions.get( 'OES_texture_float' );
    extensions.get( 'OES_texture_float_linear' );
    extensions.get( 'OES_texture_half_float' );
    extensions.get( 'OES_texture_half_float_linear' );
    extensions.get( 'OES_standard_derivatives' );
    extensions.get( 'ANGLE_instanced_arrays' );

    if ( extensions.get( 'OES_element_index_uint' ) ) {

        THREE.BufferGeometry.MaxIndex = 4294967296;

    }

    var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

    var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
    var properties = new THREE.WebGLProperties();
    var objects = new THREE.WebGLObjects( _gl, properties, this.info );
    var programCache = new THREE.WebGLPrograms( this, capabilities );

    this.info.programs = programCache.programs;

    var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
    var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    //

    function glClearColor( r, g, b, a ) {

        if ( _premultipliedAlpha === true ) {

            r *= a;
            g *= a;
            b *= a;

        }

        _gl.clearColor( r, g, b, a );

    }

    function setDefaultGLState() {

        state.init();

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    }

    function resetGLState() {

        _currentProgram = null;
        _currentCamera = null;

        _currentGeometryProgram = '';
        _currentMaterialId = -1;

        _lightsNeedUpdate = true;

        state.reset();

    }

    setDefaultGLState();

    this.context = _gl;
    this.capabilities = capabilities;
    this.extensions = extensions;
    this.state = state;

    // shadow map

    var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

    this.shadowMap = shadowMap;


    // Plugins

    var spritePlugin = new THREE.SpritePlugin( this, sprites );
    var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

    // API

    this.getContext = function() {

        return _gl;

    };

    this.getContextAttributes = function() {

        return _gl.getContextAttributes();

    };

    this.forceContextLoss = function() {

        extensions.get( 'WEBGL_lose_context' ).loseContext();

    };

    this.getMaxAnisotropy = ( function() {

        var value;

        return function getMaxAnisotropy() {

            if ( value !== undefined ) return value;

            var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

            if ( extension !== null ) {

                value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

            }
            else {

                value = 0;

            }

            return value;

        }

    } )();

    this.getPrecision = function() {

        return capabilities.precision;

    };

    this.getPixelRatio = function() {

        return pixelRatio;

    };

    this.setPixelRatio = function( value ) {

        if ( value !== undefined ) pixelRatio = value;

    };

    this.getSize = function() {

        return {
            width: _width,
            height: _height
        };

    };

    this.setSize = function( width, height, updateStyle ) {

        _width = width;
        _height = height;

        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;

        if ( updateStyle !== false ) {

            _canvas.style.width = width + 'px';
            _canvas.style.height = height + 'px';

        }

        this.setViewport( 0, 0, width, height );

    };

    this.setViewport = function( x, y, width, height ) {

        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;

        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    };

    this.setScissor = function( x, y, width, height ) {

        _gl.scissor(
            x * pixelRatio,
            y * pixelRatio,
            width * pixelRatio,
            height * pixelRatio
        );

    };

    this.enableScissorTest = function( boolean ) {

        state.setScissorTest( boolean );

    };

    // Clearing

    this.getClearColor = function() {

        return _clearColor;

    };

    this.setClearColor = function( color, alpha ) {

        _clearColor.set( color );

        _clearAlpha = alpha !== undefined ? alpha : 1;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.getClearAlpha = function() {

        return _clearAlpha;

    };

    this.setClearAlpha = function( alpha ) {

        _clearAlpha = alpha;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.clear = function( color, depth, stencil ) {

        var bits = 0;

        if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
        if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
        if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

        _gl.clear( bits );

    };

    this.clearColor = function() {

        _gl.clear( _gl.COLOR_BUFFER_BIT );

    };

    this.clearDepth = function() {

        _gl.clear( _gl.DEPTH_BUFFER_BIT );

    };

    this.clearStencil = function() {

        _gl.clear( _gl.STENCIL_BUFFER_BIT );

    };

    this.clearTarget = function( renderTarget, color, depth, stencil ) {

        this.setRenderTarget( renderTarget );
        this.clear( color, depth, stencil );

    };

    // Reset

    this.resetGLState = resetGLState;

    this.dispose = function() {

        _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    };

    // Events

    function onContextLost( event ) {

        event.preventDefault();

        resetGLState();
        setDefaultGLState();

        properties.clear();

    };

    function onTextureDispose( event ) {

        var texture = event.target;

        texture.removeEventListener( 'dispose', onTextureDispose );

        deallocateTexture( texture );

        _infoMemory.textures--;


    }

    function onRenderTargetDispose( event ) {

        var renderTarget = event.target;

        renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

        deallocateRenderTarget( renderTarget );

        _infoMemory.textures--;

    }

    function onMaterialDispose( event ) {

        var material = event.target;

        material.removeEventListener( 'dispose', onMaterialDispose );

        deallocateMaterial( material );

    }

    // Buffer deallocation

    function deallocateTexture( texture ) {

        var textureProperties = properties.get( texture );

        if ( texture.image && textureProperties.__image__webglTextureCube ) {

            // cube texture

            _gl.deleteTexture( textureProperties.__image__webglTextureCube );

        }
        else {

            // 2D texture

            if ( textureProperties.__webglInit === undefined ) return;

            _gl.deleteTexture( textureProperties.__webglTexture );

        }

        // remove all webgl properties
        properties.delete( texture );

    }

    function deallocateRenderTarget( renderTarget ) {

        var renderTargetProperties = properties.get( renderTarget );

        if ( !renderTarget || renderTargetProperties.__webglTexture === undefined ) return;

        _gl.deleteTexture( renderTargetProperties.__webglTexture );

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            for ( var i = 0; i < 6; i++ ) {

                _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
                _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

            }

        }
        else {

            _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
            _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

        }

        properties.delete( renderTarget );

    }

    function deallocateMaterial( material ) {

        releaseMaterialProgramReference( material );

        properties.delete( material );

    }


    function releaseMaterialProgramReference( material ) {

        var programInfo = properties.get( material ).program;

        material.program = undefined;

        if ( programInfo !== undefined ) {

            programCache.releaseProgram( programInfo );
        }

    }

    // Buffer rendering

    this.renderBufferImmediate = function( object, program, material ) {

        state.initAttributes();

        var buffers = properties.get( object );

        if ( object.hasPositions && !buffers.position ) buffers.position = _gl.createBuffer();
        if ( object.hasNormals && !buffers.normal ) buffers.normal = _gl.createBuffer();
        if ( object.hasUvs && !buffers.uv ) buffers.uv = _gl.createBuffer();
        if ( object.hasColors && !buffers.color ) buffers.color = _gl.createBuffer();

        var attributes = program.getAttributes();

        if ( object.hasPositions ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.position );
            _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasNormals ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

            if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

                for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

                    var array = object.normalArray;

                    var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
                    var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
                    var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

                    array[ i + 0 ] = nx;
                    array[ i + 1 ] = ny;
                    array[ i + 2 ] = nz;

                    array[ i + 3 ] = nx;
                    array[ i + 4 ] = ny;
                    array[ i + 5 ] = nz;

                    array[ i + 6 ] = nx;
                    array[ i + 7 ] = ny;
                    array[ i + 8 ] = nz;

                }

            }

            _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.normal );

            _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasUvs && material.map ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.uv );

            _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.color );

            _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

        }

        state.disableUnusedAttributes();

        _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

        object.count = 0;

    };

    this.renderBufferDirect = function( camera, lights, fog, geometry, material, object, group ) {

        setMaterial( material );

        var program = setProgram( camera, lights, fog, material, object );

        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

        if ( geometryProgram !== _currentGeometryProgram ) {

            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;

        }

        // morph targets

        var morphTargetInfluences = object.morphTargetInfluences;

        if ( morphTargetInfluences !== undefined ) {

            var activeInfluences = [];

            for ( var i = 0, l = morphTargetInfluences.length; i < l; i++ ) {

                var influence = morphTargetInfluences[ i ];
                activeInfluences.push( [ influence, i ] );

            }

            activeInfluences.sort( numericalSort );

            if ( activeInfluences.length > 8 ) {

                activeInfluences.length = 8;

            }

            var morphAttributes = geometry.morphAttributes;

            for ( var i = 0, l = activeInfluences.length; i < l; i++ ) {

                var influence = activeInfluences[ i ];
                morphInfluences[ i ] = influence[ 0 ];

                if ( influence[ 0 ] !== 0 ) {

                    var index = influence[ 1 ];

                    if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
                    if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

                }
                else {

                    if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
                    if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

                }

            }

            var uniforms = program.getUniforms();

            if ( uniforms.morphTargetInfluences !== null ) {

                _gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

            }

            updateBuffers = true;

        }

        //

        var index = geometry.index;
        var position = geometry.attributes.position;

        if ( material.wireframe === true ) {

            index = objects.getWireframeAttribute( geometry );

        }

        var renderer;

        if ( index !== null ) {

            renderer = indexedBufferRenderer;
            renderer.setIndex( index );

        }
        else {

            renderer = bufferRenderer;

        }

        if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry );

            if ( index !== null ) {

                _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

            }

        }

        if ( group === undefined ) {

            var count;

            if ( index !== null ) {
                count = index.count;

            }
            else if ( position instanceof THREE.InterleavedBufferAttribute ) {

                count = position.data.array.length / 3;

            }
            else {
                count = position.count;

            }

            var drawRange = geometry.drawRange;

            group = {
                start: drawRange.start,
                count: Math.min( drawRange.count, count )
            };

        }

        if ( object instanceof THREE.Mesh ) {

            if ( material.wireframe === true ) {

                state.setLineWidth( material.wireframeLinewidth * pixelRatio );
                renderer.setMode( _gl.LINES );

            }
            else {

                renderer.setMode( _gl.TRIANGLES );

            }

            if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

                renderer.renderInstances( geometry );

            }
            else {

                renderer.render( group.start, group.count );

            }

        }
        else if ( object instanceof THREE.Line ) {

            var lineWidth = material.linewidth;

            if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

            state.setLineWidth( lineWidth * pixelRatio );

            if ( object instanceof THREE.LineSegments ) {

                renderer.setMode( _gl.LINES );

            }
            else {

                renderer.setMode( _gl.LINE_STRIP );

            }

            renderer.render( group.start, group.count );

        }
        else if ( object instanceof THREE.Points ) {
            renderer.setMode( _gl.POINTS );
            renderer.render( group.start, group.count );

        }

    };

    function setupVertexAttributes( material, program, geometry, startIndex ) {

        var extension;

        if ( geometry instanceof THREE.InstancedBufferGeometry ) {

            extension = extensions.get( 'ANGLE_instanced_arrays' );

            if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

            }

        }

        if ( startIndex === undefined ) startIndex = 0;

        state.initAttributes();

        var geometryAttributes = geometry.attributes;

        var programAttributes = program.getAttributes();

        var materialDefaultAttributeValues = material.defaultAttributeValues;

        for ( var name in programAttributes ) {

            var programAttribute = programAttributes[ name ];

            if ( programAttribute >= 0 ) {

                var geometryAttribute = geometryAttributes[ name ];

                if ( geometryAttribute !== undefined ) {

                    state.enableAttribute( programAttribute );

                    var size = geometryAttribute.itemSize;
                    var buffer = objects.getAttributeBuffer( geometryAttribute );

                    if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

                        if ( data instanceof THREE.InstancedInterleavedBuffer ) {

                            if ( extension === null ) {

                                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                                return;

                            }

                            extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;

                            }

                        }

                    }
                    else {

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

                        if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

                            if ( extension === null ) {

                                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                                return;

                            }

                            extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                            }

                        }

                    }

                }
                else if ( materialDefaultAttributeValues !== undefined ) {

                    var value = materialDefaultAttributeValues[ name ];

                    if ( value !== undefined ) {

                        switch ( value.length ) {

                            case 2:
                                _gl.vertexAttrib2fv( programAttribute, value );
                                break;

                            case 3:
                                _gl.vertexAttrib3fv( programAttribute, value );
                                break;

                            case 4:
                                _gl.vertexAttrib4fv( programAttribute, value );
                                break;

                            default:
                                _gl.vertexAttrib1fv( programAttribute, value );

                        }

                    }

                }

            }

        }

        state.disableUnusedAttributes();

    }

    // Sorting

    function numericalSort( a, b ) {

        return b[ 0 ] - a[ 0 ];

    }

    function painterSortStable( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        }
        else if ( a.material.id !== b.material.id ) {

            return a.material.id - b.material.id;

        }
        else if ( a.z !== b.z ) {

            return a.z - b.z;

        }
        else {

            return a.id - b.id;

        }

    }

    function reversePainterSortStable( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        }
        if ( a.z !== b.z ) {

            return b.z - a.z;

        }
        else {

            return a.id - b.id;

        }

    }

    // Rendering

    this.render = function( scene, camera, renderTarget, forceClear ) {

        if ( camera instanceof THREE.Camera === false ) {

            console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
            return;

        }

        var fog = scene.fog;

        // reset caching for this frame

        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;

        // update scene graph

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

        // update camera matrices and frustum

        if ( camera.parent === null ) camera.updateMatrixWorld();

        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        _frustum.setFromMatrix( _projScreenMatrix );

        lights.length = 0;

        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;

        opaqueImmediateObjectsLastIndex = -1;
        transparentImmediateObjectsLastIndex = -1;

        sprites.length = 0;
        lensFlares.length = 0;

        projectObject( scene );

        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;

        opaqueImmediateObjects.length = opaqueImmediateObjectsLastIndex + 1;
        transparentImmediateObjects.length = transparentImmediateObjectsLastIndex + 1;

        if ( _this.sortObjects === true ) {

            opaqueObjects.sort( painterSortStable );
            transparentObjects.sort( reversePainterSortStable );

        }

        //

        shadowMap.render( scene, camera );

        //

        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;

        this.setRenderTarget( renderTarget );

        if ( this.autoClear || forceClear ) {

            this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

        }

        //

        if ( scene.overrideMaterial ) {

            var overrideMaterial = scene.overrideMaterial;

            renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
            renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

            renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog, overrideMaterial );
            renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog, overrideMaterial );

        }
        else {

            // opaque pass (front-to-back order)

            state.setBlending( THREE.NoBlending );

            renderObjects( opaqueObjects, camera, lights, fog );
            renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog );

            // transparent pass (back-to-front order)

            renderObjects( transparentObjects, camera, lights, fog );
            renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog );

        }

        // custom render plugins (post pass)

        spritePlugin.render( scene, camera );
        lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

        // Generate mipmap if we're using any kind of mipmap filtering

        if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

            updateRenderTargetMipmap( renderTarget );

        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render

        state.setDepthTest( true );
        state.setDepthWrite( true );
        state.setColorWrite( true );

        // _gl.finish();

    };

    function pushImmediateRenderItem( object ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( object.material.transparent ) {

            array = transparentImmediateObjects;
            index = ++transparentImmediateObjectsLastIndex;

        }
        else {

            array = opaqueImmediateObjects;
            index = ++opaqueImmediateObjectsLastIndex;

        }

        // recycle existing position or grow the array

        if ( index < array.length ) {

            array[ index ] = object;

        }
        else {

            // assert( index === array.length );
            array.push( object );

        }


    }

    function pushRenderItem( object, geometry, material, z, group ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( material.transparent ) {

            array = transparentObjects;
            index = ++transparentObjectsLastIndex;

        }
        else {

            array = opaqueObjects;
            index = ++opaqueObjectsLastIndex;

        }

        // recycle existing render item or grow the array

        var renderItem = array[ index ];

        if ( renderItem !== undefined ) {

            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = _vector3.z;
            renderItem.group = group;

        }
        else {

            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: _vector3.z,
                group: group
            };

            // assert( index === array.length );
            array.push( renderItem );

        }

    }

    function projectObject( object ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Light ) {

            lights.push( object );

        }
        else if ( object instanceof THREE.Sprite ) {

            sprites.push( object );

        }
        else if ( object instanceof THREE.LensFlare ) {

            lensFlares.push( object );

        }
        else if ( object instanceof THREE.ImmediateRenderObject ) {

            pushImmediateRenderItem( object );

        }
        else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object instanceof THREE.SkinnedMesh ) {

                object.skeleton.update();

            }

            if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                var material = object.material;

                if ( material.visible === true ) {

                    if ( _this.sortObjects === true ) {

                        _vector3.setFromMatrixPosition( object.matrixWorld );
                        _vector3.applyProjection( _projScreenMatrix );

                    }

                    var geometry = objects.update( object );

                    if ( material instanceof THREE.MeshFaceMaterial ) {

                        var groups = geometry.groups;
                        var materials = material.materials;

                        for ( var i = 0, l = groups.length; i < l; i++ ) {

                            var group = groups[ i ];
                            var groupMaterial = materials[ group.materialIndex ];

                            if ( groupMaterial.visible === true ) {

                                pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

                            }

                        }

                    }
                    else {

                        pushRenderItem( object, geometry, material, _vector3.z );

                    }

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            projectObject( children[ i ] );

        }

    }

    function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

        for ( var i = 0, l = renderList.length; i < l; i++ ) {

            var renderItem = renderList[ i ];

            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            _this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

        }

    }

    function renderObjectsImmediate( renderList, camera, lights, fog, overrideMaterial ) {

        var material = overrideMaterial;

        for ( var i = 0, l = renderList.length; i < l; i++ ) {

            var object = renderList[ i ];

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            if ( overrideMaterial === undefined ) material = object.material;

            setMaterial( material );

            var program = setProgram( camera, lights, fog, material, object );

            _currentGeometryProgram = '';

            object.render( function( object ) {

                _this.renderBufferImmediate( object, program, material );

            } );

        }

    }

    function initMaterial( material, lights, fog, object ) {

        var materialProperties = properties.get( material );

        var parameters = programCache.getParameters( material, lights, fog, object );
        var code = programCache.getProgramCode( material, parameters );

        var program = materialProperties.program;
        var programChange = true;

        if ( program === undefined ) {

            // new material
            material.addEventListener( 'dispose', onMaterialDispose );

        }
        else if ( program.code !== code ) {

            // changed glsl or parameters
            releaseMaterialProgramReference( material );

        }
        else if ( parameters.shaderID !== undefined ) {

            // same glsl and uniform list
            return;

        }
        else {

            // only rebuild uniform list
            programChange = false;

        }

        if ( programChange ) {

            if ( parameters.shaderID ) {

                var shader = THREE.ShaderLib[ parameters.shaderID ];

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };

            }
            else {

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };

            }

            material.__webglShader = materialProperties.__webglShader;

            program = programCache.acquireProgram( material, parameters, code );

            materialProperties.program = program;
            material.program = program;

        }

        var attributes = program.getAttributes();

        if ( material.morphTargets ) {

            material.numSupportedMorphTargets = 0;

            for ( var i = 0; i < _this.maxMorphTargets; i++ ) {

                if ( attributes[ 'morphTarget' + i ] >= 0 ) {

                    material.numSupportedMorphTargets++;

                }

            }

        }

        if ( material.morphNormals ) {

            material.numSupportedMorphNormals = 0;

            for ( i = 0; i < _this.maxMorphNormals; i++ ) {

                if ( attributes[ 'morphNormal' + i ] >= 0 ) {

                    material.numSupportedMorphNormals++;

                }

            }

        }

        materialProperties.uniformsList = [];

        var uniformLocations = materialProperties.program.getUniforms();

        for ( var u in materialProperties.__webglShader.uniforms ) {

            var location = uniformLocations[ u ];

            if ( location ) {

                materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

            }

        }

    }

    function setMaterial( material ) {

        setMaterialFaces( material );

        if ( material.transparent === true ) {

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

        }
        else {

            state.setBlending( THREE.NoBlending );

        }

        state.setDepthFunc( material.depthFunc );
        state.setDepthTest( material.depthTest );
        state.setDepthWrite( material.depthWrite );
        state.setColorWrite( material.colorWrite );
        state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    }

    function setMaterialFaces( material ) {

        material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
        state.setFlipSided( material.side === THREE.BackSide );

    }

    function setProgram( camera, lights, fog, material, object ) {

        _usedTextureUnits = 0;

        var materialProperties = properties.get( material );

        if ( material.needsUpdate || !materialProperties.program ) {

            initMaterial( material, lights, fog, object );
            material.needsUpdate = false;

        }

        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;

        var program = materialProperties.program,
            p_uniforms = program.getUniforms(),
            m_uniforms = materialProperties.__webglShader.uniforms;

        if ( program.id !== _currentProgram ) {

            _gl.useProgram( program.program );
            _currentProgram = program.id;

            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;

        }

        if ( material.id !== _currentMaterialId ) {

            if ( _currentMaterialId === -1 ) refreshLights = true;
            _currentMaterialId = material.id;

            refreshMaterial = true;

        }

        if ( refreshProgram || camera !== _currentCamera ) {

            _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

            if ( capabilities.logarithmicDepthBuffer ) {

                _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

            }


            if ( camera !== _currentCamera ) _currentCamera = camera;

            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)

            if ( material instanceof THREE.ShaderMaterial ||
                material instanceof THREE.MeshPhongMaterial ||
                material.envMap ) {

                if ( p_uniforms.cameraPosition !== undefined ) {

                    _vector3.setFromMatrixPosition( camera.matrixWorld );
                    _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

                }

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.ShaderMaterial ||
                material.skinning ) {

                if ( p_uniforms.viewMatrix !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

                }

            }

        }

        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // not sure why, but otherwise weird things happen

        if ( material.skinning ) {

            if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

            }

            if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

            }

            if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

                if ( p_uniforms.boneTexture !== undefined ) {

                    var textureUnit = getTextureUnit();

                    _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
                    _this.setTexture( object.skeleton.boneTexture, textureUnit );

                }

                if ( p_uniforms.boneTextureWidth !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

                }

                if ( p_uniforms.boneTextureHeight !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

                }

            }
            else if ( object.skeleton && object.skeleton.boneMatrices ) {

                if ( p_uniforms.boneGlobalMatrices !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

                }

            }

        }

        if ( refreshMaterial ) {

            // refresh uniforms common to several materials

            if ( fog && material.fog ) {

                refreshUniformsFog( m_uniforms, fog );

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material.lights ) {

                if ( _lightsNeedUpdate ) {

                    refreshLights = true;
                    setupLights( lights, camera );
                    _lightsNeedUpdate = false;

                }

                if ( refreshLights ) {

                    refreshUniformsLights( m_uniforms, _lights );
                    markUniformsLightsNeedsUpdate( m_uniforms, true );

                }
                else {

                    markUniformsLightsNeedsUpdate( m_uniforms, false );

                }

            }

            if ( material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsCommon( m_uniforms, material );

            }

            // refresh single material specific uniforms

            if ( material instanceof THREE.LineBasicMaterial ) {

                refreshUniformsLine( m_uniforms, material );

            }
            else if ( material instanceof THREE.LineDashedMaterial ) {

                refreshUniformsLine( m_uniforms, material );
                refreshUniformsDash( m_uniforms, material );

            }
            else if ( material instanceof THREE.PointsMaterial ) {

                refreshUniformsParticle( m_uniforms, material );

            }
            else if ( material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsPhong( m_uniforms, material );

            }
            else if ( material instanceof THREE.MeshDepthMaterial ) {

                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;

            }
            else if ( material instanceof THREE.MeshNormalMaterial ) {

                m_uniforms.opacity.value = material.opacity;

            }

            if ( object.receiveShadow && !material._shadowPass ) {

                refreshUniformsShadow( m_uniforms, lights );

            }

            // load common uniforms

            loadUniformsGeneric( materialProperties.uniformsList );

        }

        loadUniformsMatrices( p_uniforms, object );

        if ( p_uniforms.modelMatrix !== undefined ) {

            _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

        }

        return program;

    }

    // Uniforms (refresh uniforms objects)

    function refreshUniformsCommon( uniforms, material ) {

        uniforms.opacity.value = material.opacity;

        uniforms.diffuse.value = material.color;

        if ( material.emissive ) {

            uniforms.emissive.value = material.emissive;

        }

        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

        if ( material.aoMap ) {

            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;

        }

        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if ( material.map ) {

            uvScaleMap = material.map;

        }
        else if ( material.specularMap ) {

            uvScaleMap = material.specularMap;

        }
        else if ( material.displacementMap ) {

            uvScaleMap = material.displacementMap;

        }
        else if ( material.normalMap ) {

            uvScaleMap = material.normalMap;

        }
        else if ( material.bumpMap ) {

            uvScaleMap = material.bumpMap;

        }
        else if ( material.alphaMap ) {

            uvScaleMap = material.alphaMap;

        }
        else if ( material.emissiveMap ) {

            uvScaleMap = material.emissiveMap;

        }

        if ( uvScaleMap !== undefined ) {

            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;

    }

    function refreshUniformsLine( uniforms, material ) {

        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;

    }

    function refreshUniformsDash( uniforms, material ) {

        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;

    }

    function refreshUniformsParticle( uniforms, material ) {

        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

        uniforms.map.value = material.map;

        if ( material.map !== null ) {

            var offset = material.map.offset;
            var repeat = material.map.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

    }

    function refreshUniformsFog( uniforms, fog ) {

        uniforms.fogColor.value = fog.color;

        if ( fog instanceof THREE.Fog ) {

            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;

        }
        else if ( fog instanceof THREE.FogExp2 ) {

            uniforms.fogDensity.value = fog.density;

        }

    }

    function refreshUniformsPhong( uniforms, material ) {

        uniforms.specular.value = material.specular;
        uniforms.shininess.value = material.shininess;

        if ( material.lightMap ) {

            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;

        }

        if ( material.emissiveMap ) {

            uniforms.emissiveMap.value = material.emissiveMap;

        }

        if ( material.bumpMap ) {

            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;

        }

        if ( material.normalMap ) {

            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy( material.normalScale );

        }

        if ( material.displacementMap ) {

            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;

        }

    }

    function refreshUniformsLights( uniforms, lights ) {

        uniforms.ambientLightColor.value = lights.ambient;

        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;

        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;

        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;

        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;

    }

    // If uniforms are marked as clean, they don't need to be loaded to the GPU.

    function markUniformsLightsNeedsUpdate( uniforms, value ) {

        uniforms.ambientLightColor.needsUpdate = value;

        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;

        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;

        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;

        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;

    }

    function refreshUniformsShadow( uniforms, lights ) {

        if ( uniforms.shadowMatrix ) {

            var j = 0;

            for ( var i = 0, il = lights.length; i < il; i++ ) {

                var light = lights[ i ];

                if ( !light.castShadow ) continue;

                if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight ) ) {

                    uniforms.shadowMap.value[ j ] = light.shadowMap;
                    uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

                    uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

                    uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
                    uniforms.shadowBias.value[ j ] = light.shadowBias;

                    j++;

                }

            }

        }

    }

    // Uniforms (load to GPU)

    function loadUniformsMatrices( uniforms, object ) {

        _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

        if ( uniforms.normalMatrix ) {

            _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

        }

    }

    function getTextureUnit() {

        var textureUnit = _usedTextureUnits;

        if ( textureUnit >= capabilities.maxTextures ) {

            console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

        }

        _usedTextureUnits += 1;

        return textureUnit;

    }

    function loadUniformsGeneric( uniforms ) {

        var texture, textureUnit;

        for ( var j = 0, jl = uniforms.length; j < jl; j++ ) {

            var uniform = uniforms[ j ][ 0 ];

            // needsUpdate property is not added to all uniforms.
            if ( uniform.needsUpdate === false ) continue;

            var type = uniform.type;
            var value = uniform.value;
            var location = uniforms[ j ][ 1 ];

            switch ( type ) {

                case '1i':
                    _gl.uniform1i( location, value );
                    break;

                case '1f':
                    _gl.uniform1f( location, value );
                    break;

                case '2f':
                    _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
                    break;

                case '3f':
                    _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
                    break;

                case '4f':
                    _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
                    break;

                case '1iv':
                    _gl.uniform1iv( location, value );
                    break;

                case '3iv':
                    _gl.uniform3iv( location, value );
                    break;

                case '1fv':
                    _gl.uniform1fv( location, value );
                    break;

                case '2fv':
                    _gl.uniform2fv( location, value );
                    break;

                case '3fv':
                    _gl.uniform3fv( location, value );
                    break;

                case '4fv':
                    _gl.uniform4fv( location, value );
                    break;

                case 'Matrix3fv':
                    _gl.uniformMatrix3fv( location, false, value );
                    break;

                case 'Matrix4fv':
                    _gl.uniformMatrix4fv( location, false, value );
                    break;

                    //

                case 'i':

                    // single integer
                    _gl.uniform1i( location, value );

                    break;

                case 'f':

                    // single float
                    _gl.uniform1f( location, value );

                    break;

                case 'v2':

                    // single THREE.Vector2
                    _gl.uniform2f( location, value.x, value.y );

                    break;

                case 'v3':

                    // single THREE.Vector3
                    _gl.uniform3f( location, value.x, value.y, value.z );

                    break;

                case 'v4':

                    // single THREE.Vector4
                    _gl.uniform4f( location, value.x, value.y, value.z, value.w );

                    break;

                case 'c':

                    // single THREE.Color
                    _gl.uniform3f( location, value.r, value.g, value.b );

                    break;

                case 'iv1':

                    // flat array of integers (JS or typed array)
                    _gl.uniform1iv( location, value );

                    break;

                case 'iv':

                    // flat array of integers with 3 x N size (JS or typed array)
                    _gl.uniform3iv( location, value );

                    break;

                case 'fv1':

                    // flat array of floats (JS or typed array)
                    _gl.uniform1fv( location, value );

                    break;

                case 'fv':

                    // flat array of floats with 3 x N size (JS or typed array)
                    _gl.uniform3fv( location, value );

                    break;

                case 'v2v':

                    // array of THREE.Vector2

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 2 * value.length );

                    }

                    for ( var i = 0, i2 = 0, il = value.length; i < il; i++, i2 += 2 ) {

                        uniform._array[ i2 + 0 ] = value[ i ].x;
                        uniform._array[ i2 + 1 ] = value[ i ].y;

                    }

                    _gl.uniform2fv( location, uniform._array );

                    break;

                case 'v3v':

                    // array of THREE.Vector3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 3 * value.length );

                    }

                    for ( var i = 0, i3 = 0, il = value.length; i < il; i++, i3 += 3 ) {

                        uniform._array[ i3 + 0 ] = value[ i ].x;
                        uniform._array[ i3 + 1 ] = value[ i ].y;
                        uniform._array[ i3 + 2 ] = value[ i ].z;

                    }

                    _gl.uniform3fv( location, uniform._array );

                    break;

                case 'v4v':

                    // array of THREE.Vector4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 4 * value.length );

                    }

                    for ( var i = 0, i4 = 0, il = value.length; i < il; i++, i4 += 4 ) {

                        uniform._array[ i4 + 0 ] = value[ i ].x;
                        uniform._array[ i4 + 1 ] = value[ i ].y;
                        uniform._array[ i4 + 2 ] = value[ i ].z;
                        uniform._array[ i4 + 3 ] = value[ i ].w;

                    }

                    _gl.uniform4fv( location, uniform._array );

                    break;

                case 'm3':

                    // single THREE.Matrix3
                    _gl.uniformMatrix3fv( location, false, value.elements );

                    break;

                case 'm3v':

                    // array of THREE.Matrix3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 9 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

                    }

                    _gl.uniformMatrix3fv( location, false, uniform._array );

                    break;

                case 'm4':

                    // single THREE.Matrix4
                    _gl.uniformMatrix4fv( location, false, value.elements );

                    break;

                case 'm4v':

                    // array of THREE.Matrix4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 16 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

                    }

                    _gl.uniformMatrix4fv( location, false, uniform._array );

                    break;

                case 't':

                    // single THREE.Texture (2d or cube)

                    texture = value;
                    textureUnit = getTextureUnit();

                    _gl.uniform1i( location, textureUnit );

                    if ( !texture ) continue;

                    if ( texture instanceof THREE.CubeTexture ||
                        ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

                        // CompressedTexture can have Array in image :/

                        setCubeTexture( texture, textureUnit );

                    }
                    else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

                        setCubeTextureDynamic( texture, textureUnit );

                    }
                    else {

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                case 'tv':

                    // array of THREE.Texture (2d)

                    if ( uniform._array === undefined ) {

                        uniform._array = [];

                    }

                    for ( var i = 0, il = uniform.value.length; i < il; i++ ) {

                        uniform._array[ i ] = getTextureUnit();

                    }

                    _gl.uniform1iv( location, uniform._array );

                    for ( var i = 0, il = uniform.value.length; i < il; i++ ) {

                        texture = uniform.value[ i ];
                        textureUnit = uniform._array[ i ];

                        if ( !texture ) continue;

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                default:

                    console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

            }

        }

    }

    function setColorLinear( array, offset, color, intensity ) {

        array[ offset + 0 ] = color.r * intensity;
        array[ offset + 1 ] = color.g * intensity;
        array[ offset + 2 ] = color.b * intensity;

    }

    function setupLights( lights, camera ) {

        var l, ll, light,
            r = 0,
            g = 0,
            b = 0,
            color, skyColor, groundColor,
            intensity,
            distance,

            zlights = _lights,

            viewMatrix = camera.matrixWorldInverse,

            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,

            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,

            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,

            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,

            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,

            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,

            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;

        for ( l = 0, ll = lights.length; l < ll; l++ ) {

            light = lights[ l ];

            if ( light.onlyShadow ) continue;

            color = light.color;
            intensity = light.intensity;
            distance = light.distance;

            if ( light instanceof THREE.AmbientLight ) {

                if ( !light.visible ) continue;

                r += color.r;
                g += color.g;
                b += color.b;

            }
            else if ( light instanceof THREE.DirectionalLight ) {

                dirCount += 1;

                if ( !light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                dirOffset = dirLength * 3;

                dirPositions[ dirOffset + 0 ] = _direction.x;
                dirPositions[ dirOffset + 1 ] = _direction.y;
                dirPositions[ dirOffset + 2 ] = _direction.z;

                setColorLinear( dirColors, dirOffset, color, intensity );

                dirLength += 1;

            }
            else if ( light instanceof THREE.PointLight ) {

                pointCount += 1;

                if ( !light.visible ) continue;

                pointOffset = pointLength * 3;

                setColorLinear( pointColors, pointOffset, color, intensity );

                _vector3.setFromMatrixPosition( light.matrixWorld );
                _vector3.applyMatrix4( viewMatrix );

                pointPositions[ pointOffset + 0 ] = _vector3.x;
                pointPositions[ pointOffset + 1 ] = _vector3.y;
                pointPositions[ pointOffset + 2 ] = _vector3.z;

                // distance is 0 if decay is 0, because there is no attenuation at all.
                pointDistances[ pointLength ] = distance;
                pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                pointLength += 1;

            }
            else if ( light instanceof THREE.SpotLight ) {

                spotCount += 1;

                if ( !light.visible ) continue;

                spotOffset = spotLength * 3;

                setColorLinear( spotColors, spotOffset, color, intensity );

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.copy( _direction ).applyMatrix4( viewMatrix );

                spotPositions[ spotOffset + 0 ] = _vector3.x;
                spotPositions[ spotOffset + 1 ] = _vector3.y;
                spotPositions[ spotOffset + 2 ] = _vector3.z;

                spotDistances[ spotLength ] = distance;

                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                spotDirections[ spotOffset + 0 ] = _direction.x;
                spotDirections[ spotOffset + 1 ] = _direction.y;
                spotDirections[ spotOffset + 2 ] = _direction.z;

                spotAnglesCos[ spotLength ] = Math.cos( light.angle );
                spotExponents[ spotLength ] = light.exponent;
                spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                spotLength += 1;

            }
            else if ( light instanceof THREE.HemisphereLight ) {

                hemiCount += 1;

                if ( !light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _direction.transformDirection( viewMatrix );

                hemiOffset = hemiLength * 3;

                hemiPositions[ hemiOffset + 0 ] = _direction.x;
                hemiPositions[ hemiOffset + 1 ] = _direction.y;
                hemiPositions[ hemiOffset + 2 ] = _direction.z;

                skyColor = light.color;
                groundColor = light.groundColor;

                setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
                setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

                hemiLength += 1;

            }

        }

        // null eventual remains from removed lights
        // (this is to avoid if in shader)

        for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l++ ) dirColors[ l ] = 0.0;
        for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l++ ) pointColors[ l ] = 0.0;
        for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l++ ) spotColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l++ ) hemiSkyColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l++ ) hemiGroundColors[ l ] = 0.0;

        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;

        zlights.ambient[ 0 ] = r;
        zlights.ambient[ 1 ] = g;
        zlights.ambient[ 2 ] = b;

    }

    // GL state setting

    this.setFaceCulling = function( cullFace, frontFaceDirection ) {

        if ( cullFace === THREE.CullFaceNone ) {

            state.disable( _gl.CULL_FACE );

        }
        else {

            if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

                _gl.frontFace( _gl.CW );

            }
            else {

                _gl.frontFace( _gl.CCW );

            }

            if ( cullFace === THREE.CullFaceBack ) {

                _gl.cullFace( _gl.BACK );

            }
            else if ( cullFace === THREE.CullFaceFront ) {

                _gl.cullFace( _gl.FRONT );

            }
            else {

                _gl.cullFace( _gl.FRONT_AND_BACK );

            }

            state.enable( _gl.CULL_FACE );

        }

    };

    // Textures

    function setTextureParameters( textureType, texture, isImagePowerOfTwo ) {

        var extension;

        if ( isImagePowerOfTwo ) {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

        }
        else {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

            if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

            }

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

            if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

            }

        }

        extension = extensions.get( 'EXT_texture_filter_anisotropic' );

        if ( extension ) {

            if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
            if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

            if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

                _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
                properties.get( texture ).__currentAnisotropy = texture.anisotropy;

            }

        }

    }

    function uploadTexture( textureProperties, texture, slot ) {

        if ( textureProperties.__webglInit === undefined ) {

            textureProperties.__webglInit = true;

            texture.__webglInit = true;

            texture.addEventListener( 'dispose', onTextureDispose );

            textureProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
        _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
        _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

        texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

        var image = texture.image,
            isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
            glFormat = paramThreeToGL( texture.format ),
            glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

        var mipmap, mipmaps = texture.mipmaps;

        if ( texture instanceof THREE.DataTexture ) {

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

                texture.generateMipmaps = false;

            }
            else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

            }

        }
        else if ( texture instanceof THREE.CompressedTexture ) {

            for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                mipmap = mipmaps[ i ];

                if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                    if ( state.getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                        state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                    }
                    else {

                        console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

                    }

                }
                else {

                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

            }

        }
        else {

            // regular Texture (image, video, canvas)

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

                }

                texture.generateMipmaps = false;

            }
            else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

            }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

        textureProperties.__version = texture.version;

        if ( texture.onUpdate ) texture.onUpdate( texture );

    }

    this.setTexture = function( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

            var image = texture.image;

            if ( image === undefined ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
                return;

            }

            if ( image.complete === false ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
                return;

            }

            uploadTexture( textureProperties, texture, slot );
            return;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    };

    function clampToMaxSize( image, maxSize ) {

        if ( image.width > maxSize || image.height > maxSize ) {

            // Warning: Scaling through the canvas will only work with images that use
            // premultiplied alpha.

            var scale = maxSize / Math.max( image.width, image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = Math.floor( image.width * scale );
            canvas.height = Math.floor( image.height * scale );

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

            console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

            return canvas;

        }

        return image;

    }

    function setCubeTexture( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.image.length === 6 ) {

            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

                if ( !textureProperties.__image__webglTextureCube ) {

                    texture.addEventListener( 'dispose', onTextureDispose );

                    textureProperties.__image__webglTextureCube = _gl.createTexture();

                    _infoMemory.textures++;

                }

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

                _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

                var isCompressed = texture instanceof THREE.CompressedTexture;
                var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

                var cubeImage = [];

                for ( var i = 0; i < 6; i++ ) {

                    if ( _this.autoScaleCubemaps && !isCompressed && !isDataTexture ) {

                        cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

                    }
                    else {

                        cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

                    }

                }

                var image = cubeImage[ 0 ],
                    isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
                    glFormat = paramThreeToGL( texture.format ),
                    glType = paramThreeToGL( texture.type );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

                for ( var i = 0; i < 6; i++ ) {

                    if ( !isCompressed ) {

                        if ( isDataTexture ) {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

                        }
                        else {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

                        }

                    }
                    else {

                        var mipmap, mipmaps = cubeImage[ i ].mipmaps;

                        for ( var j = 0, jl = mipmaps.length; j < jl; j++ ) {

                            mipmap = mipmaps[ j ];

                            if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                                if ( state.getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                                    state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                                }
                                else {

                                    console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                                }

                            }
                            else {

                                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                            }

                        }

                    }

                }

                if ( texture.generateMipmaps && isImagePowerOfTwo ) {

                    _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

                }

                textureProperties.__version = texture.version;

                if ( texture.onUpdate ) texture.onUpdate( texture );

            }
            else {

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

            }

        }

    }

    function setCubeTextureDynamic( texture, slot ) {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    }

    // Render targets

    function setupFrameBuffer( framebuffer, renderTarget, textureTarget ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget ).__webglTexture, 0 );

    }

    function setupRenderBuffer( renderbuffer, renderTarget ) {

        _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

        if ( renderTarget.depthBuffer && !renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            /* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/

        }
        else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

        }
        else {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

        }

    }

    this.setRenderTarget = function( renderTarget ) {

        var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

        if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
            if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

            renderTargetProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures++;

            // Setup texture, create render and frame buffers

            var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
                glFormat = paramThreeToGL( renderTarget.format ),
                glType = paramThreeToGL( renderTarget.type );

            if ( isCube ) {

                renderTargetProperties.__webglFramebuffer = [];
                renderTargetProperties.__webglRenderbuffer = [];

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

                for ( var i = 0; i < 6; i++ ) {

                    renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
                    renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

                    state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                    setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

                }

                if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

            }
            else {

                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

                if ( renderTarget.shareDepthFrom ) {

                    renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

                }
                else {

                    renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

                }

                state.bindTexture( _gl.TEXTURE_2D, renderTargetProperties.__webglTexture );
                setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

                if ( renderTarget.shareDepthFrom ) {

                    if ( renderTarget.depthBuffer && !renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }
                    else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }

                }
                else {

                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

                }

                if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

            }

            // Release everything

            if ( isCube ) {

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

            }
            else {

                state.bindTexture( _gl.TEXTURE_2D, null );

            }

            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( isCube ) {

                framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

            }
            else {

                framebuffer = renderTargetProperties.__webglFramebuffer;

            }

            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        }
        else {

            framebuffer = null;

            width = _viewportWidth;
            height = _viewportHeight;

            vx = _viewportX;
            vy = _viewportY;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        _currentWidth = width;
        _currentHeight = height;

    };

    this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

        if ( !( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
            return;

        }

        if ( properties.get( renderTarget ).__webglFramebuffer ) {

            if ( renderTarget.format !== THREE.RGBAFormat ) {

                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
                return;

            }

            var restore = false;

            if ( properties.get( renderTarget ).__webglFramebuffer !== _currentFramebuffer ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, properties.get( renderTarget ).__webglFramebuffer );

                restore = true;

            }

            if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

                _gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

            }
            else {

                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

            }

            if ( restore ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

            }

        }

    };

    function updateRenderTargetMipmap( renderTarget ) {

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( renderTarget ).__webglTexture );
            _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
            state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

        }
        else {

            state.bindTexture( _gl.TEXTURE_2D, properties.get( renderTarget ).__webglTexture );
            _gl.generateMipmap( _gl.TEXTURE_2D );
            state.bindTexture( _gl.TEXTURE_2D, null );

        }

    }

    // Fallback filters for non-power-of-2 textures

    function filterFallback( f ) {

        if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

            return _gl.NEAREST;

        }

        return _gl.LINEAR;

    }

    // Map three.js constants to WebGL constants

    function paramThreeToGL( p ) {

        var extension;

        if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
        if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
        if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

        if ( p === THREE.NearestFilter ) return _gl.NEAREST;
        if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
        if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

        if ( p === THREE.LinearFilter ) return _gl.LINEAR;
        if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
        if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

        if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
        if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
        if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
        if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

        if ( p === THREE.ByteType ) return _gl.BYTE;
        if ( p === THREE.ShortType ) return _gl.SHORT;
        if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
        if ( p === THREE.IntType ) return _gl.INT;
        if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
        if ( p === THREE.FloatType ) return _gl.FLOAT;

        extension = extensions.get( 'OES_texture_half_float' );

        if ( extension !== null ) {

            if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

        }

        if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
        if ( p === THREE.RGBFormat ) return _gl.RGB;
        if ( p === THREE.RGBAFormat ) return _gl.RGBA;
        if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
        if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

        if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
        if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
        if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

        if ( p === THREE.ZeroFactor ) return _gl.ZERO;
        if ( p === THREE.OneFactor ) return _gl.ONE;
        if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
        if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
        if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
        if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
        if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
        if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

        if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
        if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
        if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

        extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

        }

        extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

        }

        extension = extensions.get( 'EXT_blend_minmax' );

        if ( extension !== null ) {

            if ( p === THREE.MinEquation ) return extension.MIN_EXT;
            if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

        }

        return 0;

    }

    // DEPRECATED

    this.supportsFloatTextures = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
        return extensions.get( 'OES_texture_float' );

    };

    this.supportsHalfFloatTextures = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
        return extensions.get( 'OES_texture_half_float' );

    };

    this.supportsStandardDerivatives = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
        return extensions.get( 'OES_standard_derivatives' );

    };

    this.supportsCompressedTextureS3TC = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_s3tc' );

    };

    this.supportsCompressedTexturePVRTC = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    };

    this.supportsBlendMinMax = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
        return extensions.get( 'EXT_blend_minmax' );

    };

    this.supportsVertexTextures = function() {

        return capabilities.vertexTextures;

    };

    this.supportsInstancedArrays = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
        return extensions.get( 'ANGLE_instanced_arrays' );

    };

    //

    this.initMaterial = function() {

        console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

    };

    this.addPrePlugin = function() {

        console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

    };

    this.addPostPlugin = function() {

        console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

    };

    this.updateShadowMap = function() {

        console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

    };

    Object.defineProperties( this, {
        shadowMapEnabled: {
            get: function() {

                return shadowMap.enabled;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
                shadowMap.enabled = value;

            }
        },
        shadowMapType: {
            get: function() {

                return shadowMap.type;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
                shadowMap.type = value;

            }
        },
        shadowMapCullFace: {
            get: function() {

                return shadowMap.cullFace;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
                shadowMap.cullFace = value;

            }
        },
        shadowMapDebug: {
            get: function() {

                return shadowMap.debug;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
                shadowMap.debug = value;

            }
        }
    } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function( width, height, options ) {

    this.uuid = THREE.Math.generateUUID();

    this.width = width;
    this.height = height;

    options = options || {};

    this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
    this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
    this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

    this.generateMipmaps = true;

    this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

    constructor: THREE.WebGLRenderTarget,

    setSize: function( width, height ) {

        if ( this.width !== width || this.height !== height ) {

            this.width = width;
            this.height = height;

            this.dispose();

        }

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.width = source.width;
        this.height = source.height;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.format = source.format;
        this.type = source.type;

        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;

        this.generateMipmaps = source.generateMipmaps;

        this.shareDepthFrom = source.shareDepthFrom;

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function( width, height, options ) {

    THREE.WebGLRenderTarget.call( this, width, height, options );

    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLBufferRenderer = function( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var traceCount = 0;

    function render( start, count ) {
        if ( traceCount === 0 ) {
            traceCount = 1;
        }

        _gl.drawArrays( mode, start, count );

        _infoRender.calls++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var position = geometry.attributes.position;

        if ( position instanceof THREE.InterleavedBufferAttribute ) {

            extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

        }
        else {

            extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

        }

    }

    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLIndexedBufferRenderer = function( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var type, size;

    function setIndex( index ) {

        if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

            type = _gl.UNSIGNED_INT;
            size = 4;

        }
        else {

            type = _gl.UNSIGNED_SHORT;
            size = 2;

        }

    }

    function render( start, count ) {

        _gl.drawElements( mode, count, type, start * size );

        _infoRender.calls++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var index = geometry.index;

        extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

    }

    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLExtensions = function( gl ) {

    var extensions = {};

    this.get = function( name ) {

        if ( extensions[ name ] !== undefined ) {

            return extensions[ name ];

        }

        var extension;

        switch ( name ) {

            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
                break;

            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
                break;

            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
                break;

            default:
                extension = gl.getExtension( name );

        }

        if ( extension === null ) {

            console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

        }

        extensions[ name ] = extension;

        return extension;

    };

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function( gl, extensions, parameters ) {

    function getMaxPrecision( precision ) {

        if ( precision === 'highp' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

                return 'highp';

            }

            precision = 'mediump';

        }

        if ( precision === 'mediump' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

                return 'mediump';

            }

        }

        return 'lowp';

    }

    this.getMaxPrecision = getMaxPrecision;

    this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
    this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

    this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    this.vertexTextures = this.maxVertexTextures > 0;
    this.floatFragmentTextures = !!extensions.get( 'OES_texture_float' );
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

    var _maxPrecision = getMaxPrecision( this.precision );

    if ( _maxPrecision !== this.precision ) {

        console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
        this.precision = _maxPrecision;

    }

    if ( this.logarithmicDepthBuffer ) {

        this.logarithmicDepthBuffer = !!extensions.get( 'EXT_frag_depth' );

    }

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLGeometries = function( gl, properties, info ) {

    var geometries = {};

    function get( object ) {

        var geometry = object.geometry;

        if ( geometries[ geometry.id ] !== undefined ) {

            return geometries[ geometry.id ];

        }

        geometry.addEventListener( 'dispose', onGeometryDispose );

        var buffergeometry;

        if ( geometry instanceof THREE.BufferGeometry ) {

            buffergeometry = geometry;

        }
        else if ( geometry instanceof THREE.Geometry ) {

            if ( geometry._bufferGeometry === undefined ) {

                geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

            }

            buffergeometry = geometry._bufferGeometry;

        }

        geometries[ geometry.id ] = buffergeometry;

        info.memory.geometries++;

        return buffergeometry;

    }

    function onGeometryDispose( event ) {

        var geometry = event.target;
        var buffergeometry = geometries[ geometry.id ];

        deleteAttributes( buffergeometry.attributes );

        geometry.removeEventListener( 'dispose', onGeometryDispose );

        delete geometries[ geometry.id ];

        var property = properties.get( geometry );
        if ( property.wireframe ) deleteAttribute( property.wireframe );

        info.memory.geometries--;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function deleteAttribute( attribute ) {

        var buffer = getAttributeBuffer( attribute );

        if ( buffer !== undefined ) {

            gl.deleteBuffer( buffer );
            removeAttributeBuffer( attribute );

        }

    }

    function deleteAttributes( attributes ) {

        for ( var name in attributes ) {

            deleteAttribute( attributes[ name ] );

        }

    }

    function removeAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            properties.delete( attribute.data );

        }
        else {

            properties.delete( attribute );

        }

    }

    this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLObjects = function( gl, properties, info ) {

    var geometries = new THREE.WebGLGeometries( gl, properties, info );

    //

    function update( object ) {

        // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

        var geometry = geometries.get( object );

        if ( object.geometry instanceof THREE.Geometry ) {

            geometry.updateFromObject( object );

        }

        var index = geometry.index;
        var attributes = geometry.attributes;

        if ( index !== null ) {

            updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

        }

        for ( var name in attributes ) {

            updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

        }

        // morph targets

        var morphAttributes = geometry.morphAttributes;

        for ( var name in morphAttributes ) {

            var array = morphAttributes[ name ];

            for ( var i = 0, l = array.length; i < l; i++ ) {

                updateAttribute( array[ i ], gl.ARRAY_BUFFER );

            }

        }

        return geometry;

    }

    function updateAttribute( attribute, bufferType ) {

        var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

        var attributeProperties = properties.get( data );

        if ( attributeProperties.__webglBuffer === undefined ) {
            createBuffer( attributeProperties, data, bufferType );

        }
        else if ( attributeProperties.version !== data.version ) {

            updateBuffer( attributeProperties, data, bufferType );

        }

    }

    function createBuffer( attributeProperties, data, bufferType ) {

        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        gl.bufferData( bufferType, data.array, usage );

        attributeProperties.version = data.version;

    }

    function updateBuffer( attributeProperties, data, bufferType ) {

        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        if ( data.dynamic === false || data.updateRange.count === -1 ) {

            // Not using update ranges
            gl.bufferSubData( bufferType, 0, data.array );

        }
        else if ( data.updateRange.count === 0 ) {

            console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

        }
        else {
            gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

            data.updateRange.count = 0; // reset range

        }

        attributeProperties.version = data.version;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function getWireframeAttribute( geometry ) {

        var property = properties.get( geometry );

        if ( property.wireframe !== undefined ) {

            return property.wireframe;

        }

        var indices = [];

        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;

        // console.time( 'wireframe' );

        if ( index !== null ) {

            var edges = {};
            var array = index.array;

            for ( var i = 0, l = array.length; i < l; i += 3 ) {

                var a = array[ i + 0 ];
                var b = array[ i + 1 ];
                var c = array[ i + 2 ];

                if ( checkEdge( edges, a, b ) ) indices.push( a, b );
                if ( checkEdge( edges, b, c ) ) indices.push( b, c );
                if ( checkEdge( edges, c, a ) ) indices.push( c, a );

            }

        }
        else {

            var array = attributes.position.array;

            for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

                var a = i + 0;
                var b = i + 1;
                var c = i + 2;

                indices.push( a, b, b, c, c, a );

            }

        }

        // console.timeEnd( 'wireframe' );

        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

        updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

        property.wireframe = attribute;

        return attribute;

    }

    function checkEdge( edges, a, b ) {

        if ( a > b ) {

            var tmp = a;
            a = b;
            b = tmp;

        }

        var list = edges[ a ];

        if ( list === undefined ) {

            edges[ a ] = [ b ];
            return true;

        }
        else if ( list.indexOf( b ) === -1 ) {

            list.push( b );
            return true;

        }

        return false;

    }

    this.getAttributeBuffer = getAttributeBuffer;
    this.getWireframeAttribute = getWireframeAttribute;

    this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function() {

    var programIdCount = 0;

    function generateDefines( defines ) {

        var chunks = [];

        for ( var name in defines ) {

            var value = defines[ name ];

            if ( value === false ) continue;

            chunks.push( '#define ' + name + ' ' + value );

        }

        return chunks.join( '\n' );

    }

    function fetchUniformLocations( gl, program, identifiers ) {

        var uniforms = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

        for ( var i = 0; i < n; i++ ) {

            var info = gl.getActiveUniform( program, i );
            var name = info.name;
            var location = gl.getUniformLocation( program, name );

            // console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

            var suffixPos = name.lastIndexOf( '[0]' );
            if ( suffixPos !== -1 && suffixPos === name.length - 3 ) {

                uniforms[ name.substr( 0, suffixPos ) ] = location;

            }

            uniforms[ name ] = location;

        }

        return uniforms;

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

        var attributes = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

        for ( var i = 0; i < n; i++ ) {

            var info = gl.getActiveAttrib( program, i );
            var name = info.name;

            // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

            attributes[ name ] = gl.getAttribLocation( program, name );

        }

        return attributes;

    }

    function filterEmptyLine( string ) {

        return string !== '';

    }

    return function WebGLProgram( renderer, code, material, parameters ) {

        var gl = renderer.context;

        var defines = material.defines;

        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;

        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

        if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

        }
        else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

        }

        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

        if ( parameters.envMap ) {

            switch ( material.envMap.mapping ) {

                case THREE.CubeReflectionMapping:
                case THREE.CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;

                case THREE.EquirectangularReflectionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;

                case THREE.SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;

            }

            switch ( material.envMap.mapping ) {

                case THREE.CubeRefractionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;

            }

            switch ( material.combine ) {

                case THREE.MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;

                case THREE.MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;

                case THREE.AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;

            }

        }

        var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

        // console.log( 'building new program ' );

        //

        var customDefines = generateDefines( defines );

        //

        var program = gl.createProgram();

        var prefixVertex, prefixFragment;

        if ( material instanceof THREE.RawShaderMaterial ) {

            prefixVertex = '';
            prefixFragment = '';

        }
        else {

            prefixVertex = [

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                '#define MAX_BONES ' + parameters.maxBones,

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',

                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',

                '#ifdef USE_COLOR',

                '	attribute vec3 color;',

                '#endif',

                '#ifdef USE_MORPHTARGETS',

                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',

                '	#ifdef USE_MORPHNORMALS',

                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',

                '	#else',

                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',

                '	#endif',

                '#endif',

                '#ifdef USE_SKINNING',

                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',

                '#endif',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

            prefixFragment = [

                parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '', ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.metal ? '#define METAL' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

        }

        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;

        var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
        var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

        gl.attachShader( program, glVertexShader );
        gl.attachShader( program, glFragmentShader );

        // Force a particular attribute to index 0.

        if ( material.index0AttributeName !== undefined ) {

            gl.bindAttribLocation( program, 0, material.index0AttributeName );

        }
        else if ( parameters.morphTargets === true ) {

            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation( program, 0, 'position' );

        }

        gl.linkProgram( program );

        var programLog = gl.getProgramInfoLog( program );
        var vertexLog = gl.getShaderInfoLog( glVertexShader );
        var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

        var runnable = true;
        var haveDiagnostics = true;

        if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

            runnable = false;

            console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

        }
        else if ( programLog !== '' ) {

            console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

        }
        else if ( vertexLog === '' || fragmentLog === '' ) {

            haveDiagnostics = false;

        }

        if ( haveDiagnostics ) {

            this.diagnostics = {

                runnable: runnable,
                material: material,

                programLog: programLog,

                vertexShader: {

                    log: vertexLog,
                    prefix: prefixVertex

                },

                fragmentShader: {

                    log: fragmentLog,
                    prefix: prefixFragment

                }

            };

        }

        // clean up

        gl.deleteShader( glVertexShader );
        gl.deleteShader( glFragmentShader );

        // set up caching for uniform locations

        var cachedUniforms;

        this.getUniforms = function() {

            if ( cachedUniforms === undefined ) {

                cachedUniforms = fetchUniformLocations( gl, program );

            }

            return cachedUniforms;

        };

        // set up caching for attribute locations

        var cachedAttributes;

        this.getAttributes = function() {

            if ( cachedAttributes === undefined ) {

                cachedAttributes = fetchAttributeLocations( gl, program );

            }

            return cachedAttributes;

        };

        // free resource

        this.destroy = function() {

            gl.deleteProgram( program );
            this.program = undefined;

        };

        // DEPRECATED

        Object.defineProperties( this, {

            uniforms: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
                    return this.getUniforms();

                }
            },

            attributes: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
                    return this.getAttributes();

                }
            }

        } );


        //

        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;

        return this;

    };

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function( renderer, capabilities ) {

    var programs = [];

    var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
    };

    var parameterNames = [
        "precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
        "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "specularMap",
        "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
        "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
        "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
        "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
        "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled",
        "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
        "flipSided"
    ];


    function allocateBones( object ) {

        if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

            return 1024;

        }
        else {

            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)

            var nVertexUniforms = capabilities.maxVertexUniforms;
            var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

            var maxBones = nVertexMatrices;

            if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

                maxBones = Math.min( object.skeleton.bones.length, maxBones );

                if ( maxBones < object.skeleton.bones.length ) {

                    console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

                }

            }

            return maxBones;

        }

    }

    function allocateLights( lights ) {

        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;

        for ( var l = 0, ll = lights.length; l < ll; l++ ) {

            var light = lights[ l ];

            if ( light.onlyShadow || light.visible === false ) continue;

            if ( light instanceof THREE.DirectionalLight ) dirLights++;
            if ( light instanceof THREE.PointLight ) pointLights++;
            if ( light instanceof THREE.SpotLight ) spotLights++;
            if ( light instanceof THREE.HemisphereLight ) hemiLights++;

        }

        return {
            'directional': dirLights,
            'point': pointLights,
            'spot': spotLights,
            'hemi': hemiLights
        };

    }

    function allocateShadows( lights ) {

        var maxShadows = 0;

        for ( var l = 0, ll = lights.length; l < ll; l++ ) {

            var light = lights[ l ];

            if ( !light.castShadow ) continue;

            if ( light instanceof THREE.SpotLight ) maxShadows++;
            if ( light instanceof THREE.DirectionalLight ) maxShadows++;

        }

        return maxShadows;

    }

    this.getParameters = function( material, lights, fog, object ) {

        var shaderID = shaderIDs[ material.type ];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)

        var maxLightCount = allocateLights( lights );
        var maxShadows = allocateShadows( lights );
        var maxBones = allocateBones( object );
        var precision = renderer.getPrecision();

        if ( material.precision !== null ) {

            precision = capabilities.getMaxPrecision( material.precision );

            if ( precision !== material.precision ) {

                console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

            }

        }

        var parameters = {

            shaderID: shaderID,

            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,

            map: !!material.map,
            envMap: !!material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            displacementMap: !!material.displacementMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,

            combine: material.combine,

            vertexColors: material.vertexColors,

            fog: fog,
            useFog: material.fog,
            fogExp: fog instanceof THREE.FogExp2,

            flatShading: material.shading === THREE.FlatShading,

            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: renderer.logarithmicDepthBuffer,

            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,

            maxDirLights: maxLightCount.directional,
            maxPointLights: maxLightCount.point,
            maxSpotLights: maxLightCount.spot,
            maxHemiLights: maxLightCount.hemi,

            maxShadows: maxShadows,
            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && maxShadows > 0,
            shadowMapType: renderer.shadowMap.type,
            shadowMapDebug: renderer.shadowMap.debug,

            alphaTest: material.alphaTest,
            metal: material.metal,
            doubleSided: material.side === THREE.DoubleSide,
            flipSided: material.side === THREE.BackSide

        };

        return parameters;

    };

    this.getProgramCode = function( material, parameters ) {

        var chunks = [];

        if ( parameters.shaderID ) {

            chunks.push( parameters.shaderID );

        }
        else {

            chunks.push( material.fragmentShader );
            chunks.push( material.vertexShader );

        }

        if ( material.defines !== undefined ) {

            for ( var name in material.defines ) {

                chunks.push( name );
                chunks.push( material.defines[ name ] );

            }

        }

        for ( var i = 0; i < parameterNames.length; i++ ) {

            var parameterName = parameterNames[ i ];
            chunks.push( parameterName );
            chunks.push( parameters[ parameterName ] );

        }

        return chunks.join();

    };

    this.acquireProgram = function( material, parameters, code ) {

        var program;

        // Check if code has been already compiled
        for ( var p = 0, pl = programs.length; p < pl; p++ ) {

            var programInfo = programs[ p ];

            if ( programInfo.code === code ) {

                program = programInfo;
                ++program.usedTimes;

                break;

            }

        }

        if ( program === undefined ) {

            program = new THREE.WebGLProgram( renderer, code, material, parameters );
            programs.push( program );

        }

        return program;

    };

    this.releaseProgram = function( program ) {

        if ( --program.usedTimes === 0 ) {

            // Remove from unordered set
            var i = programs.indexOf( program );
            programs[ i ] = programs[ programs.length - 1 ];
            programs.pop();

            // Free WebGL resources
            program.destroy();

        }

    };

    // Exposed for resource monitoring & error feedback via renderer.info:
    this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
 * @author fordacious / fordacious.github.io
 */

THREE.WebGLProperties = function() {

    var properties = {};

    this.get = function( object ) {

        var uuid = object.uuid;
        var map = properties[ uuid ];

        if ( map === undefined ) {

            map = {};
            properties[ uuid ] = map;

        }

        return map;

    };

    this.delete = function( object ) {

        delete properties[ object.uuid ];

    };

    this.clear = function() {

        properties = {};

    };

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function() {

    var addLineNumbers = function( string ) {

        var lines = string.split( '\n' );

        for ( var i = 0; i < lines.length; i++ ) {

            lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

        }

        return lines.join( '\n' );

    };

    return function WebGLShader( gl, type, string ) {

        var shader = gl.createShader( type );

        gl.shaderSource( shader, string );
        gl.compileShader( shader );

        if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

            console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

        }

        if ( gl.getShaderInfoLog( shader ) !== '' ) {

            console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

        }

        // --enable-privileged-webgl-extension
        // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

        return shader;

    };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function( _renderer, _lights, _objects ) {

    var _gl = _renderer.context,
        _state = _renderer.state,
        _frustum = new THREE.Frustum(),
        _projScreenMatrix = new THREE.Matrix4(),

        _min = new THREE.Vector3(),
        _max = new THREE.Vector3(),

        _matrixPosition = new THREE.Vector3(),

        _renderList = [];

    // init

    var depthShader = THREE.ShaderLib[ "depthRGBA" ];
    var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

    var _depthMaterial = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader
    } );

    var _depthMaterialMorph = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true
    } );

    var _depthMaterialSkin = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        skinning: true
    } );

    var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true,
        skinning: true
    } );

    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;

    //

    var scope = this;

    this.enabled = false;

    this.autoUpdate = true;
    this.needsUpdate = false;

    this.type = THREE.PCFShadowMap;
    this.cullFace = THREE.CullFaceFront;

    this.render = function( scene, camera ) {

        if ( scope.enabled === false ) return;
        if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

        // set GL state for depth map

        _gl.clearColor( 1, 1, 1, 1 );
        _state.disable( _gl.BLEND );

        _state.enable( _gl.CULL_FACE );
        _gl.frontFace( _gl.CCW );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.FRONT );

        }
        else {

            _gl.cullFace( _gl.BACK );

        }

        _state.setDepthTest( true );

        // render depth map

        for ( var i = 0, il = _lights.length; i < il; i++ ) {

            var light = _lights[ i ];

            if ( !light.castShadow ) continue;

            if ( !light.shadowMap ) {

                var shadowFilter = THREE.LinearFilter;

                if ( scope.type === THREE.PCFSoftShadowMap ) {

                    shadowFilter = THREE.NearestFilter;

                }

                var pars = {
                    minFilter: shadowFilter,
                    magFilter: shadowFilter,
                    format: THREE.RGBAFormat
                };

                light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
                light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

                light.shadowMatrix = new THREE.Matrix4();

            }

            if ( !light.shadowCamera ) {

                if ( light instanceof THREE.SpotLight ) {

                    light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

                }
                else if ( light instanceof THREE.DirectionalLight ) {

                    light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

                }
                else {

                    console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
                    continue;

                }

                scene.add( light.shadowCamera );

                if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

            }

            if ( light.shadowCameraVisible && !light.cameraHelper ) {

                light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
                scene.add( light.cameraHelper );

            }

            var shadowMap = light.shadowMap;
            var shadowMatrix = light.shadowMatrix;
            var shadowCamera = light.shadowCamera;

            //

            shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
            _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
            shadowCamera.lookAt( _matrixPosition );
            shadowCamera.updateMatrixWorld();

            shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

            //

            if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
            if ( light.shadowCameraVisible ) light.cameraHelper.update();

            // compute shadow matrix

            shadowMatrix.set(
                0.5, 0.0, 0.0, 0.5,
                0.0, 0.5, 0.0, 0.5,
                0.0, 0.0, 0.5, 0.5,
                0.0, 0.0, 0.0, 1.0
            );

            shadowMatrix.multiply( shadowCamera.projectionMatrix );
            shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

            // update camera matrices and frustum

            _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
            _frustum.setFromMatrix( _projScreenMatrix );

            // render shadow map

            _renderer.setRenderTarget( shadowMap );
            _renderer.clear();

            // set object matrices & frustum culling

            _renderList.length = 0;

            projectObject( scene, shadowCamera );


            // render regular objects

            for ( var j = 0, jl = _renderList.length; j < jl; j++ ) {

                var object = _renderList[ j ];
                var geometry = _objects.update( object );
                var material = object.material;

                if ( material instanceof THREE.MeshFaceMaterial ) {

                    var groups = geometry.groups;
                    var materials = material.materials;

                    for ( var k = 0, kl = groups.length; k < kl; k++ ) {

                        var group = groups[ k ];
                        var groupMaterial = materials[ group.materialIndex ];

                        if ( groupMaterial.visible === true ) {

                            _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, groupMaterial ), object, group );

                        }

                    }

                }
                else {

                    _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, material ), object );

                }

            }

        }

        // restore GL state

        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();

        _renderer.setClearColor( clearColor, clearAlpha );
        _state.enable( _gl.BLEND );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.BACK );

        }

        _renderer.resetGLState();

        scope.needsUpdate = false;

    };

    function getDepthMaterial( object, material ) {

        var geometry = object.geometry;

        var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
        var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

        var depthMaterial;

        if ( object.customDepthMaterial ) {

            depthMaterial = object.customDepthMaterial;

        }
        else if ( useSkinning ) {

            depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

        }
        else if ( useMorphing ) {

            depthMaterial = _depthMaterialMorph;

        }
        else {

            depthMaterial = _depthMaterial;

        }

        depthMaterial.visible = material.visible;
        depthMaterial.wireframe = material.wireframe;
        depthMaterial.wireframeLinewidth = material.wireframeLinewidth;

        return depthMaterial;

    }

    function projectObject( object, camera ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

                var material = object.material;

                if ( material.visible === true ) {

                    object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
                    _renderList.push( object );

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            projectObject( children[ i ], camera );

        }

    }

};

// File:src/renderers/webgl/WebGLState.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLState = function( gl, extensions, paramThreeToGL ) {

    var _this = this;

    var newAttributes = new Uint8Array( 16 );
    var enabledAttributes = new Uint8Array( 16 );

    var capabilities = {};

    var compressedTextureFormats = null;

    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;

    var currentDepthFunc = null;
    var currentDepthWrite = null;

    var currentColorWrite = null;

    var currentFlipSided = null;

    var currentLineWidth = null;

    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;

    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    var currentTextureSlot = undefined;
    var currentBoundTextures = {};

    this.init = function() {

        gl.clearColor( 0, 0, 0, 1 );
        gl.clearDepth( 1 );
        gl.clearStencil( 0 );

        this.enable( gl.DEPTH_TEST );
        gl.depthFunc( gl.LEQUAL );

        gl.frontFace( gl.CCW );
        gl.cullFace( gl.BACK );
        this.enable( gl.CULL_FACE );

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

    };

    this.initAttributes = function() {

        for ( var i = 0, l = newAttributes.length; i < l; i++ ) {

            newAttributes[ i ] = 0;

        }

    };

    this.enableAttribute = function( attribute ) {

        newAttributes[ attribute ] = 1;

        if ( enabledAttributes[ attribute ] === 0 ) {

            gl.enableVertexAttribArray( attribute );
            enabledAttributes[ attribute ] = 1;

        }

    };

    this.disableUnusedAttributes = function() {

        for ( var i = 0, l = enabledAttributes.length; i < l; i++ ) {

            if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

    };

    this.enable = function( id ) {

        if ( capabilities[ id ] !== true ) {

            gl.enable( id );
            capabilities[ id ] = true;

        }

    };

    this.disable = function( id ) {

        if ( capabilities[ id ] !== false ) {

            gl.disable( id );
            capabilities[ id ] = false;

        }

    };

    this.getCompressedTextureFormats = function() {

        if ( compressedTextureFormats === null ) {

            compressedTextureFormats = [];

            if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
                extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

                var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

                for ( var i = 0; i < formats.length; i++ ) {

                    compressedTextureFormats.push( formats[ i ] );

                }

            }

        }

        return compressedTextureFormats;

    };

    this.setBlending = function( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

        if ( blending !== currentBlending ) {

            if ( blending === THREE.NoBlending ) {

                this.disable( gl.BLEND );

            }
            else if ( blending === THREE.AdditiveBlending ) {

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

            }
            else if ( blending === THREE.SubtractiveBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

            }
            else if ( blending === THREE.MultiplyBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

            }
            else if ( blending === THREE.CustomBlending ) {

                this.enable( gl.BLEND );

            }
            else {

                this.enable( gl.BLEND );
                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

            }

            currentBlending = blending;

        }

        if ( blending === THREE.CustomBlending ) {

            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;

            if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

                gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;

            }

            if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

                gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;

            }

        }
        else {

            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;

        }

    };

    this.setDepthFunc = function( depthFunc ) {

        if ( currentDepthFunc !== depthFunc ) {

            if ( depthFunc ) {

                switch ( depthFunc ) {

                    case THREE.NeverDepth:

                        gl.depthFunc( gl.NEVER );
                        break;

                    case THREE.AlwaysDepth:

                        gl.depthFunc( gl.ALWAYS );
                        break;

                    case THREE.LessDepth:

                        gl.depthFunc( gl.LESS );
                        break;

                    case THREE.LessEqualDepth:

                        gl.depthFunc( gl.LEQUAL );
                        break;

                    case THREE.EqualDepth:

                        gl.depthFunc( gl.EQUAL );
                        break;

                    case THREE.GreaterEqualDepth:

                        gl.depthFunc( gl.GEQUAL );
                        break;

                    case THREE.GreaterDepth:

                        gl.depthFunc( gl.GREATER );
                        break;

                    case THREE.NotEqualDepth:

                        gl.depthFunc( gl.NOTEQUAL );
                        break;

                    default:

                        gl.depthFunc( gl.LEQUAL );

                }

            }
            else {

                gl.depthFunc( gl.LEQUAL );

            }

            currentDepthFunc = depthFunc;

        }

    };

    this.setDepthTest = function( depthTest ) {

        if ( depthTest ) {

            this.enable( gl.DEPTH_TEST );

        }
        else {

            this.disable( gl.DEPTH_TEST );

        }

    };

    this.setDepthWrite = function( depthWrite ) {

        if ( currentDepthWrite !== depthWrite ) {

            gl.depthMask( depthWrite );
            currentDepthWrite = depthWrite;

        }

    };

    this.setColorWrite = function( colorWrite ) {

        if ( currentColorWrite !== colorWrite ) {

            gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
            currentColorWrite = colorWrite;

        }

    };

    this.setFlipSided = function( flipSided ) {

        if ( currentFlipSided !== flipSided ) {

            if ( flipSided ) {

                gl.frontFace( gl.CW );

            }
            else {

                gl.frontFace( gl.CCW );

            }

            currentFlipSided = flipSided;

        }

    };

    this.setLineWidth = function( width ) {

        if ( width !== currentLineWidth ) {

            gl.lineWidth( width );

            currentLineWidth = width;

        }

    };

    this.setPolygonOffset = function( polygonOffset, factor, units ) {

        if ( polygonOffset ) {

            this.enable( gl.POLYGON_OFFSET_FILL );

        }
        else {

            this.disable( gl.POLYGON_OFFSET_FILL );

        }

        if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

            gl.polygonOffset( factor, units );

            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;

        }

    };

    this.setScissorTest = function( scissorTest ) {

        if ( scissorTest ) {

            this.enable( gl.SCISSOR_TEST );

        }
        else {

            this.disable( gl.SCISSOR_TEST );

        }

    };

    // texture

    this.activeTexture = function( webglSlot ) {

        if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

        if ( currentTextureSlot !== webglSlot ) {

            gl.activeTexture( webglSlot );
            currentTextureSlot = webglSlot;

        }

    }

    this.bindTexture = function( webglType, webglTexture ) {

        if ( currentTextureSlot === undefined ) {

            _this.activeTexture();

        }

        var boundTexture = currentBoundTextures[ currentTextureSlot ];

        if ( boundTexture === undefined ) {

            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[ currentTextureSlot ] = boundTexture;

        }

        if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

            gl.bindTexture( webglType, webglTexture );

            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;

        }

    };

    this.compressedTexImage2D = function() {

        try {

            gl.compressedTexImage2D.apply( gl, arguments );

        }
        catch ( error ) {

            console.error( error );

        }

    };

    this.texImage2D = function() {

        try {

            gl.texImage2D.apply( gl, arguments );

        }
        catch ( error ) {

            console.error( error );

        }

    };

    //

    this.reset = function() {

        for ( var i = 0; i < enabledAttributes.length; i++ ) {

            if ( enabledAttributes[ i ] === 1 ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

        capabilities = {};

        compressedTextureFormats = null;

        currentBlending = null;

        currentDepthWrite = null;
        currentColorWrite = null;

        currentFlipSided = null;

    };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function( renderer, flares ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var hasVertexTexture;

    var tempTexture, occlusionTexture;

    var init = function() {

        var vertices = new Float32Array( [ -1, -1, 0, 0,
            1, -1, 1, 0,
            1, 1, 1, 1, -1, 1, 0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        // buffers

        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        // textures

        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();

        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

        var shader;

        if ( hasVertexTexture ) {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "uniform sampler2D occlusionMap;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if( renderType == 2 ) {",

                    "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

                    "vVisibility =        visibility.r / 9.0;",
                    "vVisibility *= 1.0 - visibility.g / 9.0;",
                    "vVisibility *=       visibility.b / 9.0;",
                    "vVisibility *= 1.0 - visibility.a / 9.0;",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    // pink square

                    "if( renderType == 0 ) {",

                    "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

                    // restore

                    "} else if( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * vVisibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }
        else {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if( renderType == 2 ) {",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "precision mediump float;",

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform sampler2D occlusionMap;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",

                    "void main() {",

                    // pink square

                    "if( renderType == 0 ) {",

                    "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

                    // restore

                    "} else if( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
                    "visibility = ( 1.0 - visibility / 4.0 );",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * visibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }

        program = createProgram( shader );

        attributes = {
            vertex: gl.getAttribLocation( program, "position" ),
            uv: gl.getAttribLocation( program, "uv" )
        };

        uniforms = {
            renderType: gl.getUniformLocation( program, "renderType" ),
            map: gl.getUniformLocation( program, "map" ),
            occlusionMap: gl.getUniformLocation( program, "occlusionMap" ),
            opacity: gl.getUniformLocation( program, "opacity" ),
            color: gl.getUniformLocation( program, "color" ),
            scale: gl.getUniformLocation( program, "scale" ),
            rotation: gl.getUniformLocation( program, "rotation" ),
            screenPosition: gl.getUniformLocation( program, "screenPosition" )
        };

    };

    /*
     * Render lens flares
     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
     *         reads these back and calculates occlusion.
     */

    this.render = function( scene, camera, viewportWidth, viewportHeight ) {

        if ( flares.length === 0 ) return;

        var tempPosition = new THREE.Vector3();

        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;

        var size = 16 / viewportHeight,
            scale = new THREE.Vector2( size * invAspect, size );

        var screenPosition = new THREE.Vector3( 1, 1, 0 ),
            screenPositionPixels = new THREE.Vector2( 1, 1 );

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.vertex );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        // loop through all lens flares to update their occlusion and positions
        // setup gl and common used attribs/uniforms

        gl.uniform1i( uniforms.occlusionMap, 0 );
        gl.uniform1i( uniforms.map, 1 );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        state.disable( gl.CULL_FACE );
        gl.depthMask( false );

        for ( var i = 0, l = flares.length; i < l; i++ ) {

            size = 16 / viewportHeight;
            scale.set( size * invAspect, size );

            // calc object screen position

            var flare = flares[ i ];

            tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

            tempPosition.applyMatrix4( camera.matrixWorldInverse );
            tempPosition.applyProjection( camera.projectionMatrix );

            // setup arrays for gl programs

            screenPosition.copy( tempPosition );

            screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
            screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

            // screen cull

            if ( hasVertexTexture || (
                screenPositionPixels.x > 0 &&
                screenPositionPixels.x < viewportWidth &&
                screenPositionPixels.y > 0 &&
                screenPositionPixels.y < viewportHeight ) ) {

                // save current RGB to temp texture

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, null );
                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // render pink quad

                gl.uniform1i( uniforms.renderType, 0 );
                gl.uniform2f( uniforms.scale, scale.x, scale.y );
                gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

                state.disable( gl.BLEND );
                state.enable( gl.DEPTH_TEST );

                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // copy result to occlusionMap

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // restore graphics

                gl.uniform1i( uniforms.renderType, 1 );
                state.disable( gl.DEPTH_TEST );

                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // update object positions

                flare.positionScreen.copy( screenPosition );

                if ( flare.customUpdateCallback ) {

                    flare.customUpdateCallback( flare );

                }
                else {

                    flare.updateLensFlares();

                }

                // render flares

                gl.uniform1i( uniforms.renderType, 2 );
                state.enable( gl.BLEND );

                for ( var j = 0, jl = flare.lensFlares.length; j < jl; j++ ) {

                    var sprite = flare.lensFlares[ j ];

                    if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;

                        size = sprite.size * sprite.scale / viewportHeight;

                        scale.x = size * invAspect;
                        scale.y = size;

                        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
                        gl.uniform2f( uniforms.scale, scale.x, scale.y );
                        gl.uniform1f( uniforms.rotation, sprite.rotation );

                        gl.uniform1f( uniforms.opacity, sprite.opacity );
                        gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

                        state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
                        renderer.setTexture( sprite.texture, 1 );

                        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

                    }

                }

            }

        }

        // restore gl

        state.enable( gl.CULL_FACE );
        state.enable( gl.DEPTH_TEST );
        gl.depthMask( true );

        renderer.resetGLState();

    };

    function createProgram( shader ) {

        var program = gl.createProgram();

        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
        var vertexShader = gl.createShader( gl.VERTEX_SHADER );

        var prefix = "precision " + renderer.getPrecision() + " float;\n";

        gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
        gl.shaderSource( vertexShader, prefix + shader.vertexShader );

        gl.compileShader( fragmentShader );
        gl.compileShader( vertexShader );

        gl.attachShader( program, fragmentShader );
        gl.attachShader( program, vertexShader );

        gl.linkProgram( program );

        return program;

    }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function( renderer, sprites ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;

    var texture;

    // decompose matrixWorld

    var spritePosition = new THREE.Vector3();
    var spriteRotation = new THREE.Quaternion();
    var spriteScale = new THREE.Vector3();

    var init = function() {

        var vertices = new Float32Array( [ -0.5, -0.5, 0, 0,
            0.5, -0.5, 1, 0,
            0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        program = createProgram();

        attributes = {
            position: gl.getAttribLocation( program, 'position' ),
            uv: gl.getAttribLocation( program, 'uv' )
        };

        uniforms = {
            uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
            uvScale: gl.getUniformLocation( program, 'uvScale' ),

            rotation: gl.getUniformLocation( program, 'rotation' ),
            scale: gl.getUniformLocation( program, 'scale' ),

            color: gl.getUniformLocation( program, 'color' ),
            map: gl.getUniformLocation( program, 'map' ),
            opacity: gl.getUniformLocation( program, 'opacity' ),

            modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
            projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

            fogType: gl.getUniformLocation( program, 'fogType' ),
            fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
            fogNear: gl.getUniformLocation( program, 'fogNear' ),
            fogFar: gl.getUniformLocation( program, 'fogFar' ),
            fogColor: gl.getUniformLocation( program, 'fogColor' ),

            alphaTest: gl.getUniformLocation( program, 'alphaTest' )
        };

        var canvas = document.createElement( 'canvas' );
        canvas.width = 8;
        canvas.height = 8;

        var context = canvas.getContext( '2d' );
        context.fillStyle = 'white';
        context.fillRect( 0, 0, 8, 8 );

        texture = new THREE.Texture( canvas );
        texture.needsUpdate = true;

    };

    this.render = function( scene, camera ) {

        if ( sprites.length === 0 ) return;

        // setup gl

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.position );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        state.disable( gl.CULL_FACE );
        state.enable( gl.BLEND );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

        state.activeTexture( gl.TEXTURE0 );
        gl.uniform1i( uniforms.map, 0 );

        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;

        if ( fog ) {

            gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

            if ( fog instanceof THREE.Fog ) {

                gl.uniform1f( uniforms.fogNear, fog.near );
                gl.uniform1f( uniforms.fogFar, fog.far );

                gl.uniform1i( uniforms.fogType, 1 );
                oldFogType = 1;
                sceneFogType = 1;

            }
            else if ( fog instanceof THREE.FogExp2 ) {

                gl.uniform1f( uniforms.fogDensity, fog.density );

                gl.uniform1i( uniforms.fogType, 2 );
                oldFogType = 2;
                sceneFogType = 2;

            }

        }
        else {

            gl.uniform1i( uniforms.fogType, 0 );
            oldFogType = 0;
            sceneFogType = 0;

        }


        // update positions and sort

        for ( var i = 0, l = sprites.length; i < l; i++ ) {

            var sprite = sprites[ i ];

            sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
            sprite.z = -sprite.modelViewMatrix.elements[ 14 ];

        }

        sprites.sort( painterSortStable );

        // render all sprites

        var scale = [];

        for ( var i = 0, l = sprites.length; i < l; i++ ) {

            var sprite = sprites[ i ];
            var material = sprite.material;

            gl.uniform1f( uniforms.alphaTest, material.alphaTest );
            gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

            sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

            scale[ 0 ] = spriteScale.x;
            scale[ 1 ] = spriteScale.y;

            var fogType = 0;

            if ( scene.fog && material.fog ) {

                fogType = sceneFogType;

            }

            if ( oldFogType !== fogType ) {

                gl.uniform1i( uniforms.fogType, fogType );
                oldFogType = fogType;

            }

            if ( material.map !== null ) {

                gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
                gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

            }
            else {

                gl.uniform2f( uniforms.uvOffset, 0, 0 );
                gl.uniform2f( uniforms.uvScale, 1, 1 );

            }

            gl.uniform1f( uniforms.opacity, material.opacity );
            gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

            gl.uniform1f( uniforms.rotation, material.rotation );
            gl.uniform2fv( uniforms.scale, scale );

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
            state.setDepthTest( material.depthTest );
            state.setDepthWrite( material.depthWrite );

            if ( material.map && material.map.image && material.map.image.width ) {

                renderer.setTexture( material.map, 0 );

            }
            else {

                renderer.setTexture( texture, 0 );

            }

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

        }

        // restore gl

        state.enable( gl.CULL_FACE );

        renderer.resetGLState();

    };

    function createProgram() {

        var program = gl.createProgram();

        var vertexShader = gl.createShader( gl.VERTEX_SHADER );
        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

        gl.shaderSource( vertexShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform float rotation;',
            'uniform vec2 scale;',
            'uniform vec2 uvOffset;',
            'uniform vec2 uvScale;',

            'attribute vec2 position;',
            'attribute vec2 uv;',

            'varying vec2 vUV;',

            'void main() {',

            'vUV = uvOffset + uv * uvScale;',

            'vec2 alignedPosition = position * scale;',

            'vec2 rotatedPosition;',
            'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
            'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

            'vec4 finalPosition;',

            'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
            'finalPosition.xy += rotatedPosition;',
            'finalPosition = projectionMatrix * finalPosition;',

            'gl_Position = finalPosition;',

            '}'

        ].join( '\n' ) );

        gl.shaderSource( fragmentShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform vec3 color;',
            'uniform sampler2D map;',
            'uniform float opacity;',

            'uniform int fogType;',
            'uniform vec3 fogColor;',
            'uniform float fogDensity;',
            'uniform float fogNear;',
            'uniform float fogFar;',
            'uniform float alphaTest;',

            'varying vec2 vUV;',

            'void main() {',

            'vec4 texture = texture2D( map, vUV );',

            'if ( texture.a < alphaTest ) discard;',

            'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

            'if ( fogType > 0 ) {',

            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
            'float fogFactor = 0.0;',

            'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

            '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

            '}',

            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

            '}',

            '}'

        ].join( '\n' ) );

        gl.compileShader( vertexShader );
        gl.compileShader( fragmentShader );

        gl.attachShader( program, vertexShader );
        gl.attachShader( program, fragmentShader );

        gl.linkProgram( program );

        return program;

    }

    function painterSortStable( a, b ) {

        if ( a.z !== b.z ) {

            return b.z - a.z;

        }
        else {

            return b.id - a.id;

        }

    }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

    merge: function( geometry1, geometry2, materialIndexOffset ) {

        console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

        var matrix;

        if ( geometry2 instanceof THREE.Mesh ) {

            geometry2.matrixAutoUpdate && geometry2.updateMatrix();

            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;

        }

        geometry1.merge( geometry2, matrix, materialIndexOffset );

    },

    center: function( geometry ) {

        console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
        return geometry.center();

    }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

    crossOrigin: undefined,

    loadTexture: function( url, mapping, onLoad, onError ) {

        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;

        var texture = new THREE.Texture( undefined, mapping );

        loader.load( url, function( image ) {

            texture.image = image;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

        }, undefined, function( event ) {

            if ( onError ) onError( event );

        } );

        texture.sourceFile = url;

        return texture;

    },

    loadTextureCube: function( array, mapping, onLoad, onError ) {

        var images = [];

        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;

        var texture = new THREE.CubeTexture( images, mapping );

        var loaded = 0;

        var loadTexture = function( i ) {

            loader.load( array[ i ], function( image ) {

                texture.images[ i ] = image;

                loaded += 1;

                if ( loaded === 6 ) {

                    texture.needsUpdate = true;

                    if ( onLoad ) onLoad( texture );

                }

            }, undefined, onError );

        };

        for ( var i = 0, il = array.length; i < il; ++i ) {

            loadTexture( i );

        }

        return texture;

    },

    loadCompressedTexture: function() {

        console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

    },

    loadCompressedTextureCube: function() {

        console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

    },

    getNormalMap: function( image, depth ) {

        // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

        var cross = function( a, b ) {

            return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

        };

        var subtract = function( a, b ) {

            return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

        };

        var normalize = function( a ) {

            var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
            return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

        };

        depth = depth | 1;

        var width = image.width;
        var height = image.height;

        var canvas = document.createElement( 'canvas' );
        canvas.width = width;
        canvas.height = height;

        var context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0 );

        var data = context.getImageData( 0, 0, width, height ).data;
        var imageData = context.createImageData( width, height );
        var output = imageData.data;

        for ( var x = 0; x < width; x++ ) {

            for ( var y = 0; y < height; y++ ) {

                var ly = y - 1 < 0 ? 0 : y - 1;
                var uy = y + 1 > height - 1 ? height - 1 : y + 1;
                var lx = x - 1 < 0 ? 0 : x - 1;
                var ux = x + 1 > width - 1 ? width - 1 : x + 1;

                var points = [];
                var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
                points.push( [ -1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
                points.push( [ -1, -1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
                points.push( [ 0, -1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
                points.push( [ 1, -1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
                points.push( [ -1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

                var normals = [];
                var num_points = points.length;

                for ( var i = 0; i < num_points; i++ ) {

                    var v1 = points[ i ];
                    var v2 = points[ ( i + 1 ) % num_points ];
                    v1 = subtract( v1, origin );
                    v2 = subtract( v2, origin );
                    normals.push( normalize( cross( v1, v2 ) ) );

                }

                var normal = [ 0, 0, 0 ];

                for ( var i = 0; i < normals.length; i++ ) {

                    normal[ 0 ] += normals[ i ][ 0 ];
                    normal[ 1 ] += normals[ i ][ 1 ];
                    normal[ 2 ] += normals[ i ][ 2 ];

                }

                normal[ 0 ] /= normals.length;
                normal[ 1 ] /= normals.length;
                normal[ 2 ] /= normals.length;

                var idx = ( y * width + x ) * 4;

                output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
                output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
                output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
                output[ idx + 3 ] = 255;

            }

        }

        context.putImageData( imageData, 0, 0 );

        return canvas;

    },

    generateDataTexture: function( width, height, color ) {

        var size = width * height;
        var data = new Uint8Array( 3 * size );

        var r = Math.floor( color.r * 255 );
        var g = Math.floor( color.g * 255 );
        var b = Math.floor( color.b * 255 );

        for ( var i = 0; i < size; i++ ) {

            data[ i * 3 ] = r;
            data[ i * 3 + 1 ] = g;
            data[ i * 3 + 2 ] = b;

        }

        var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
        texture.needsUpdate = true;

        return texture;

    }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

    createMultiMaterialObject: function( geometry, materials ) {

        var group = new THREE.Group();

        for ( var i = 0, l = materials.length; i < l; i++ ) {

            group.add( new THREE.Mesh( geometry, materials[ i ] ) );

        }

        return group;

    },

    detach: function( child, parent, scene ) {

        child.applyMatrix( parent.matrixWorld );
        parent.remove( child );
        scene.add( child );

    },

    attach: function( child, scene, parent ) {

        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse( parent.matrixWorld );
        child.applyMatrix( matrixWorldInverse );

        scene.remove( child );
        parent.add( child );

    }

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

    faces: {},

    // Just for now. face[weight][style]

    face: 'helvetiker',
    weight: 'normal',
    style: 'normal',
    size: 150,
    divisions: 10,

    getFace: function() {

        try {

            return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

        }
        catch ( e ) {

            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

        }

    },

    loadFace: function( data ) {

        var family = data.familyName.toLowerCase();

        var ThreeFont = this;

        ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

        ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        return data;

    },

    drawText: function( text ) {

        // RenderText

        var i,
            face = this.getFace(),
            scale = this.size / face.resolution,
            offset = 0,
            chars = String( text ).split( '' ),
            length = chars.length;

        var fontPaths = [];

        for ( i = 0; i < length; i++ ) {

            var path = new THREE.Path();

            var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
            offset += ret.offset;

            fontPaths.push( ret.path );

        }

        // get the width

        var width = offset / 2;
        //
        // for ( p = 0; p < allPts.length; p++ ) {
        //
        // 	allPts[ p ].x -= width;
        //
        // }

        //var extract = this.extractPoints( allPts, characterPts );
        //extract.contour = allPts;

        //extract.paths = fontPaths;
        //extract.offset = width;

        return {
            paths: fontPaths,
            offset: width
        };

    },




    extractGlyphPoints: function( c, face, scale, offset, path ) {

        var pts = [];

        var i, i2, divisions,
            outline, action, length,
            scaleX, scaleY,
            x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
            laste,
            glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

        if ( !glyph ) return;

        if ( glyph.o ) {

            outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
            length = outline.length;

            scaleX = scale;
            scaleY = scale;

            for ( i = 0; i < length; ) {

                action = outline[ i++ ];

                //console.log( action );

                switch ( action ) {

                    case 'm':

                        // Move To

                        x = outline[ i++ ] * scaleX + offset;
                        y = outline[ i++ ] * scaleY;

                        path.moveTo( x, y );
                        break;

                    case 'l':

                        // Line To

                        x = outline[ i++ ] * scaleX + offset;
                        y = outline[ i++ ] * scaleY;
                        path.lineTo( x, y );
                        break;

                    case 'q':

                        // QuadraticCurveTo

                        cpx = outline[ i++ ] * scaleX + offset;
                        cpy = outline[ i++ ] * scaleY;
                        cpx1 = outline[ i++ ] * scaleX + offset;
                        cpy1 = outline[ i++ ] * scaleY;

                        path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2++ ) {

                                var t = i2 / divisions;
                                THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
                                THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

                            }

                        }

                        break;

                    case 'b':

                        // Cubic Bezier Curve

                        cpx = outline[ i++ ] * scaleX + offset;
                        cpy = outline[ i++ ] * scaleY;
                        cpx1 = outline[ i++ ] * scaleX + offset;
                        cpy1 = outline[ i++ ] * scaleY;
                        cpx2 = outline[ i++ ] * scaleX + offset;
                        cpy2 = outline[ i++ ] * scaleY;

                        path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2++ ) {

                                var t = i2 / divisions;
                                THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
                                THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

                            }

                        }

                        break;

                }

            }

        }



        return {
            offset: glyph.ha * scale,
            path: path
        };

    }

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

    // Parameters

    parameters = parameters || {};

    var size = parameters.size !== undefined ? parameters.size : 100;
    var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

    var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
    var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
    var style = parameters.style !== undefined ? parameters.style : 'normal';

    THREE.FontUtils.size = size;
    THREE.FontUtils.divisions = curveSegments;

    THREE.FontUtils.face = font;
    THREE.FontUtils.weight = weight;
    THREE.FontUtils.style = style;

    // Get a Font data json object

    var data = THREE.FontUtils.drawText( text );

    var paths = data.paths;
    var shapes = [];

    for ( var p = 0, pl = paths.length; p < pl; p++ ) {

        Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    }

    return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

    var EPSILON = 0.0000000001;

    // takes in an contour array and returns

    var process = function( contour, indices ) {

        var n = contour.length;

        if ( n < 3 ) return null;

        var result = [],
            verts = [],
            vertIndices = [];

        /* we want a counter-clockwise polygon in verts */

        var u, v, w;

        if ( area( contour ) > 0.0 ) {

            for ( v = 0; v < n; v++ ) verts[ v ] = v;

        }
        else {

            for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

        }

        var nv = n;

        /*  remove nv - 2 vertices, creating 1 triangle every time */

        var count = 2 * nv; /* error detection */

        for ( v = nv - 1; nv > 2; ) {

            /* if we loop, it is probably a non-simple polygon */

            if ( ( count-- ) <= 0 ) {

                //** Triangulate: ERROR - probable bad polygon!

                //throw ( "Warning, unable to triangulate polygon!" );
                //return null;
                // Sometimes warning is fine, especially polygons are triangulated in reverse.
                console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

                if ( indices ) return vertIndices;
                return result;

            }

            /* three consecutive vertices in current polygon, <u,v,w> */

            u = v;
            if ( nv <= u ) u = 0; /* previous */
            v = u + 1;
            if ( nv <= v ) v = 0; /* new v    */
            w = v + 1;
            if ( nv <= w ) w = 0; /* next     */

            if ( snip( contour, u, v, w, nv, verts ) ) {

                var a, b, c, s, t;

                /* true names of the vertices */

                a = verts[ u ];
                b = verts[ v ];
                c = verts[ w ];

                /* output Triangle */

                result.push( [ contour[ a ],
                    contour[ b ],
                    contour[ c ]
                ] );


                vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

                /* remove v from the remaining polygon */

                for ( s = v, t = v + 1; t < nv; s++, t++ ) {

                    verts[ s ] = verts[ t ];

                }

                nv--;

                /* reset error detection counter */

                count = 2 * nv;

            }

        }

        if ( indices ) return vertIndices;
        return result;

    };

    // calculate area of the contour polygon

    var area = function( contour ) {

        var n = contour.length;
        var a = 0.0;

        for ( var p = n - 1, q = 0; q < n; p = q++ ) {

            a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

        }

        return a * 0.5;

    };

    var snip = function( contour, u, v, w, n, verts ) {

        var p;
        var ax, ay, bx, by;
        var cx, cy, px, py;

        ax = contour[ verts[ u ] ].x;
        ay = contour[ verts[ u ] ].y;

        bx = contour[ verts[ v ] ].x;
        by = contour[ verts[ v ] ].y;

        cx = contour[ verts[ w ] ].x;
        cy = contour[ verts[ w ] ].y;

        if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

        var aX, aY, bX, bY, cX, cY;
        var apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;

        aX = cx - bx;
        aY = cy - by;
        bX = ax - cx;
        bY = ay - cy;
        cX = bx - ax;
        cY = by - ay;

        for ( p = 0; p < n; p++ ) {

            px = contour[ verts[ p ] ].x;
            py = contour[ verts[ p ] ].y;

            if ( ( ( px === ax ) && ( py === ay ) ) ||
                ( ( px === bx ) && ( py === by ) ) ||
                ( ( px === cx ) && ( py === cy ) ) ) continue;

            apx = px - ax;
            apy = py - ay;
            bpx = px - bx;
            bpy = py - by;
            cpx = px - cx;
            cpy = py - cy;

            // see if p is inside triangle abc

            aCROSSbp = aX * bpy - aY * bpx;
            cCROSSap = cX * apy - cY * apx;
            bCROSScp = bX * cpy - bY * cpx;

            if ( ( aCROSSbp >= -EPSILON ) && ( bCROSScp >= -EPSILON ) && ( cCROSSap >= -EPSILON ) ) return false;

        }

        return true;

    };


    namespace.Triangulate = process;
    namespace.Triangulate.area = area;

    return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API

THREE.typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
};
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function( listener ) {

    THREE.Object3D.call( this );

    this.type = 'Audio';

    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind( this );

    this.gain = this.context.createGain();
    this.gain.connect( this.context.destination );

    this.panner = this.context.createPanner();
    this.panner.connect( this.gain );

    this.autoplay = false;

    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function( file ) {

    var scope = this;

    var request = new XMLHttpRequest();
    request.open( 'GET', file, true );
    request.responseType = 'arraybuffer';
    request.onload = function( e ) {

        scope.context.decodeAudioData( this.response, function( buffer ) {

            scope.source.buffer = buffer;

            if ( scope.autoplay ) scope.play();

        } );

    };
    request.send();

    return this;

};

THREE.Audio.prototype.play = function() {

    if ( this.isPlaying === true ) {

        console.warn( 'THREE.Audio: Audio is already playing.' );
        return;

    }

    var source = this.context.createBufferSource();

    source.buffer = this.source.buffer;
    source.loop = this.source.loop;
    source.onended = this.source.onended;
    source.start( 0, this.startTime );
    source.playbackRate.value = this.playbackRate;

    this.isPlaying = true;

    this.source = source;

    this.connect();

};

THREE.Audio.prototype.pause = function() {

    this.source.stop();
    this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function() {

    this.source.stop();
    this.startTime = 0;

};

THREE.Audio.prototype.connect = function() {

    if ( this.filter !== undefined ) {

        this.source.connect( this.filter );
        this.filter.connect( this.panner );

    }
    else {

        this.source.connect( this.panner );

    }

};

THREE.Audio.prototype.disconnect = function() {

    if ( this.filter !== undefined ) {

        this.source.disconnect( this.filter );
        this.filter.disconnect( this.panner );

    }
    else {

        this.source.disconnect( this.panner );

    }

};

THREE.Audio.prototype.setFilter = function( value ) {

    if ( this.isPlaying === true ) {

        this.disconnect();
        this.filter = value;
        this.connect();

    }
    else {

        this.filter = value;

    }

};

THREE.Audio.prototype.getFilter = function() {

    return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function( value ) {

    this.playbackRate = value;

    if ( this.isPlaying === true ) {

        this.source.playbackRate.value = this.playbackRate;

    }

};

THREE.Audio.prototype.getPlaybackRate = function() {

    return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

    this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function( value ) {

    this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function() {

    return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function( value ) {

    this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function() {

    return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function( value ) {

    this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function() {

    return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function( value ) {

    this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function() {

    return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function() {

    var position = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        position.setFromMatrixPosition( this.matrixWorld );

        this.panner.setPosition( position.x, position.y, position.z );

    };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function() {

    THREE.Object3D.call( this );

    this.type = 'AudioListener';

    this.context = new( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function() {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();

    var orientation = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        var listener = this.context.listener;
        var up = this.up;

        this.matrixWorld.decompose( position, quaternion, scale );

        orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );

        listener.setPosition( position.x, position.y, position.z );
        listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function() {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function( t ) {

    console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function( u ) {

    var t = this.getUtoTmapping( u );
    return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function( divisions ) {

    if ( !divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d++ ) {

        pts.push( this.getPoint( d / divisions ) );

    }

    return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function( divisions ) {

    if ( !divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d++ ) {

        pts.push( this.getPointAt( d / divisions ) );

    }

    return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function() {

    var lengths = this.getLengths();
    return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function( divisions ) {

    if ( !divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    if ( this.cacheArcLengths && ( this.cacheArcLengths.length === divisions + 1 ) && !this.needsUpdate ) {

        //console.log( "cached", this.cacheArcLengths );
        return this.cacheArcLengths;

    }

    this.needsUpdate = false;

    var cache = [];
    var current, last = this.getPoint( 0 );
    var p, sum = 0;

    cache.push( 0 );

    for ( p = 1; p <= divisions; p++ ) {

        current = this.getPoint( p / divisions );
        sum += current.distanceTo( last );
        cache.push( sum );
        last = current;

    }

    this.cacheArcLengths = cache;

    return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {

    this.needsUpdate = true;
    this.getLengths();

};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

THREE.Curve.prototype.getUtoTmapping = function( u, distance ) {

    var arcLengths = this.getLengths();

    var i = 0,
        il = arcLengths.length;

    var targetArcLength; // The targeted u distance value to get

    if ( distance ) {

        targetArcLength = distance;

    }
    else {

        targetArcLength = u * arcLengths[ il - 1 ];

    }

    //var time = Date.now();

    // binary search for the index with largest value smaller than target u distance

    var low = 0,
        high = il - 1,
        comparison;

    while ( low <= high ) {

        i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

        comparison = arcLengths[ i ] - targetArcLength;

        if ( comparison < 0 ) {

            low = i + 1;

        }
        else if ( comparison > 0 ) {

            high = i - 1;

        }
        else {

            high = i;
            break;

            // DONE

        }

    }

    i = high;

    //console.log('b' , i, low, high, Date.now()- time);

    if ( arcLengths[ i ] === targetArcLength ) {

        var t = i / ( il - 1 );
        return t;

    }

    // we could get finer grain at lengths, or use simple interpolation between two points

    var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il - 1 );

    return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

    var delta = 0.0001;
    var t1 = t - delta;
    var t2 = t + delta;

    // Capping in case of danger

    if ( t1 < 0 ) t1 = 0;
    if ( t2 > 1 ) t2 = 1;

    var pt1 = this.getPoint( t1 );
    var pt2 = this.getPoint( t2 );

    var vec = pt2.clone().sub( pt1 );
    return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function( u ) {

    var t = this.getUtoTmapping( u );
    return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

    tangentQuadraticBezier: function( t, p0, p1, p2 ) {

        return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    },

    // Puay Bing, thanks for helping with this derivative!

    tangentCubicBezier: function( t, p0, p1, p2, p3 ) {

        return -3 * p0 * ( 1 - t ) * ( 1 - t ) +
            3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
            6 * t * p2 * ( 1 - t ) - 3 * t * t * p2 +
            3 * t * t * p3;

    },

    tangentSpline: function( t, p0, p1, p2, p3 ) {

        // To check if my formulas are correct

        var h00 = 6 * t * t - 6 * t; // derived from 2t^3  3t^2 + 1
        var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
        var h01 = -6 * t * t + 6 * t; //  2t3 + 3t2
        var h11 = 3 * t * t - 2 * t; // t3  t2

        return h00 + h10 + h01 + h11;

    },

    // Catmull-Rom

    interpolate: function( p0, p1, p2, p3, t ) {

        var v0 = ( p2 - p0 ) * 0.5;
        var v1 = ( p3 - p1 ) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function( constructor, getPointFunc ) {

    constructor.prototype = Object.create( THREE.Curve.prototype );
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;

    return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function() {

    this.curves = [];
    this.bends = [];

    this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function( curve ) {

    this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
    // TODO
    // If the ending of curve is not connected to the starting
    // or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {

    // TODO Test
    // and verify for vector3 (needs to implement equals)
    // Add a line curve if start and end of lines are not connected
    var startPoint = this.curves[ 0 ].getPoint( 0 );
    var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    if ( !startPoint.equals( endPoint ) ) {

        this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

    }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0,
        diff, curve;

    // To think about boundaries points.

    while ( i < curveLengths.length ) {

        if ( curveLengths[ i ] >= d ) {

            diff = curveLengths[ i ] - d;
            curve = this.curves[ i ];

            var u = 1 - diff / curve.getLength();

            return curve.getPointAt( u );

        }

        i++;

    }

    return null;

    // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

    var lens = this.getCurveLengths();
    return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

    // We use cache values if curves and cache array are same length

    if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

        return this.cacheLengths;

    }

    // Get length of sub-curve
    // Push sums into cached array

    var lengths = [],
        sums = 0;
    var i, il = this.curves.length;

    for ( i = 0; i < il; i++ ) {

        sums += this.curves[ i ].getLength();
        lengths.push( sums );

    }

    this.cacheLengths = lengths;

    return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function() {

    var points = this.getPoints();

    var maxX, maxY, maxZ;
    var minX, minY, minZ;

    maxX = maxY = Number.NEGATIVE_INFINITY;
    minX = minY = Number.POSITIVE_INFINITY;

    var p, i, il, sum;

    var v3 = points[ 0 ] instanceof THREE.Vector3;

    sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

    for ( i = 0, il = points.length; i < il; i++ ) {

        p = points[ i ];

        if ( p.x > maxX ) maxX = p.x;
        else if ( p.x < minX ) minX = p.x;

        if ( p.y > maxY ) maxY = p.y;
        else if ( p.y < minY ) minY = p.y;

        if ( v3 ) {

            if ( p.z > maxZ ) maxZ = p.z;
            else if ( p.z < minZ ) minZ = p.z;

        }

        sum.add( p );

    }

    var ret = {

        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY

    };

    if ( v3 ) {

        ret.maxZ = maxZ;
        ret.minZ = minZ;

    }

    return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

    var pts = this.getPoints( divisions, true );
    return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

    var pts = this.getSpacedPoints( divisions, true );
    return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < points.length; i++ ) {

        geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0 ) );

    }

    return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function( bendpath ) {

    this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

    var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
    var i, il;

    if ( !bends ) {

        bends = this.bends;

    }

    for ( i = 0, il = bends.length; i < il; i++ ) {

        oldPts = this.getWrapPoints( oldPts, bends[ i ] );

    }

    return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

    var oldPts = this.getSpacedPoints( segments );

    var i, il;

    if ( !bends ) {

        bends = this.bends;

    }

    for ( i = 0, il = bends.length; i < il; i++ ) {

        oldPts = this.getWrapPoints( oldPts, bends[ i ] );

    }

    return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function( oldPts, path ) {

    var bounds = this.getBoundingBox();

    var i, il, p, oldX, oldY, xNorm;

    for ( i = 0, il = oldPts.length; i < il; i++ ) {

        p = oldPts[ i ];

        oldX = p.x;
        oldY = p.y;

        xNorm = oldX / bounds.maxX;

        // If using actual distance, for length > path, requires line extrusions
        //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

        xNorm = path.getUtoTmapping( xNorm, oldX );

        // check for out of bounds?

        var pathPt = path.getPoint( xNorm );
        var normal = path.getTangent( xNorm );
        normal.set( -normal.y, normal.x ).multiplyScalar( oldY );

        p.x = pathPt.x + normal.x;
        p.y = pathPt.y + normal.y;

    }

    return oldPts;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function( points ) {

    THREE.CurvePath.call( this );

    this.actions = [];

    if ( points ) {

        this.fromPoints( points );

    }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {

    MOVE_TO: 'moveTo',
    LINE_TO: 'lineTo',
    QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
    BEZIER_CURVE_TO: 'bezierCurveTo', // Bezier cubic curve
    CSPLINE_THRU: 'splineThru', // Catmull-Rom spline
    ARC: 'arc', // Circle
    ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function( vectors ) {

    this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    for ( var v = 1, vlen = vectors.length; v < vlen; v++ ) {

        this.lineTo( vectors[ v ].x, vectors[ v ].y );

    }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function( x, y ) {

    var args = Array.prototype.slice.call( arguments );
    this.actions.push( {
        action: THREE.PathActions.MOVE_TO,
        args: args
    } );

};

THREE.Path.prototype.lineTo = function( x, y ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.LINE_TO,
        args: args
    } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCPx, aCPy ),
        new THREE.Vector2( aX, aY ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: args
    } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
    aCP2x, aCP2y,
    aX, aY ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCP1x, aCP1y ),
        new THREE.Vector2( aCP2x, aCP2y ),
        new THREE.Vector2( aX, aY ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: args
    } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

    var args = Array.prototype.slice.call( arguments );
    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];
    //---
    var npts = [ new THREE.Vector2( x0, y0 ) ];
    Array.prototype.push.apply( npts, pts );

    var curve = new THREE.SplineCurve( npts );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.CSPLINE_THRU,
        args: args
    } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function( aX, aY, aRadius,
    aStartAngle, aEndAngle, aClockwise ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absarc( aX + x0, aY + y0, aRadius,
        aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.absarc = function( aX, aY, aRadius,
    aStartAngle, aEndAngle, aClockwise ) {

    this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.ellipse = function( aX, aY, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absellipse( aX + x0, aY + y0, xRadius, yRadius,
        aStartAngle, aEndAngle, aClockwise, aRotation );

};


THREE.Path.prototype.absellipse = function( aX, aY, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var args = [
        aX, aY,
        xRadius, yRadius,
        aStartAngle, aEndAngle,
        aClockwise,
        aRotation || 0 // aRotation is optional.
    ];
    var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
        aStartAngle, aEndAngle, aClockwise, aRotation );
    this.curves.push( curve );

    var lastPoint = curve.getPoint( 1 );
    args.push( lastPoint.x );
    args.push( lastPoint.y );

    this.actions.push( {
        action: THREE.PathActions.ELLIPSE,
        args: args
    } );

};

THREE.Path.prototype.getSpacedPoints = function( divisions, closedPath ) {

    if ( !divisions ) divisions = 40;

    var points = [];

    for ( var i = 0; i < divisions; i++ ) {

        points.push( this.getPoint( i / divisions ) );

        //if( !this.getPoint( i / divisions ) ) throw "DIE";

    }

    // if ( closedPath ) {
    //
    // 	points.push( points[ 0 ] );
    //
    // }

    return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

    if ( this.useSpacedPoints ) {

        return this.getSpacedPoints( divisions, closedPath );

    }

    divisions = divisions || 12;

    var points = [];

    var i, il, item, action, args;
    var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
        laste, j,
        t, tx, ty;

    for ( i = 0, il = this.actions.length; i < il; i++ ) {

        item = this.actions[ i ];

        action = item.action;
        args = item.args;

        switch ( action ) {

            case THREE.PathActions.MOVE_TO:

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case THREE.PathActions.LINE_TO:

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case THREE.PathActions.QUADRATIC_CURVE_TO:

                cpx = args[ 2 ];
                cpy = args[ 3 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                }
                else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }

                for ( j = 1; j <= divisions; j++ ) {

                    t = j / divisions;

                    tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
                    ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case THREE.PathActions.BEZIER_CURVE_TO:

                cpx = args[ 4 ];
                cpy = args[ 5 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                cpx2 = args[ 2 ];
                cpy2 = args[ 3 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                }
                else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }


                for ( j = 1; j <= divisions; j++ ) {

                    t = j / divisions;

                    tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
                    ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case THREE.PathActions.CSPLINE_THRU:

                laste = this.actions[ i - 1 ].args;

                var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
                var spts = [ last ];

                var n = divisions * args[ 0 ].length;

                spts = spts.concat( args[ 0 ] );

                var spline = new THREE.SplineCurve( spts );

                for ( j = 1; j <= n; j++ ) {

                    points.push( spline.getPointAt( j / n ) );

                }

                break;

            case THREE.PathActions.ARC:

                var aX = args[ 0 ],
                    aY = args[ 1 ],
                    aRadius = args[ 2 ],
                    aStartAngle = args[ 3 ],
                    aEndAngle = args[ 4 ],
                    aClockwise = !!args[ 5 ];

                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                for ( j = 1; j <= tdivisions; j++ ) {

                    t = j / tdivisions;

                    if ( !aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + aRadius * Math.cos( angle );
                    ty = aY + aRadius * Math.sin( angle );

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

            case THREE.PathActions.ELLIPSE:

                var aX = args[ 0 ],
                    aY = args[ 1 ],
                    xRadius = args[ 2 ],
                    yRadius = args[ 3 ],
                    aStartAngle = args[ 4 ],
                    aEndAngle = args[ 5 ],
                    aClockwise = !!args[ 6 ],
                    aRotation = args[ 7 ];


                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                var cos, sin;
                if ( aRotation !== 0 ) {

                    cos = Math.cos( aRotation );
                    sin = Math.sin( aRotation );

                }

                for ( j = 1; j <= tdivisions; j++ ) {

                    t = j / tdivisions;

                    if ( !aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + xRadius * Math.cos( angle );
                    ty = aY + yRadius * Math.sin( angle );

                    if ( aRotation !== 0 ) {

                        var x = tx,
                            y = ty;

                        // Rotate the point about the center of the ellipse.
                        tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
                        ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

                    }

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

        } // end switch

    }



    // Normalize to remove the closing point by default.
    var lastPoint = points[ points.length - 1 ];
    var EPSILON = 0.0000000001;
    if ( Math.abs( lastPoint.x - points[ 0 ].x ) < EPSILON &&
        Math.abs( lastPoint.y - points[ 0 ].y ) < EPSILON )
        points.splice( points.length - 1, 1 );
    if ( closedPath ) {

        points.push( points[ 0 ] );

    }

    return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

    function extractSubpaths( inActions ) {

        var i, il, item, action, args;

        var subPaths = [],
            lastPath = new THREE.Path();

        for ( i = 0, il = inActions.length; i < il; i++ ) {

            item = inActions[ i ];

            args = item.args;
            action = item.action;

            if ( action === THREE.PathActions.MOVE_TO ) {

                if ( lastPath.actions.length !== 0 ) {

                    subPaths.push( lastPath );
                    lastPath = new THREE.Path();

                }

            }

            lastPath[ action ].apply( lastPath, args );

        }

        if ( lastPath.actions.length !== 0 ) {

            subPaths.push( lastPath );

        }

        // console.log(subPaths);

        return subPaths;

    }

    function toShapesNoHoles( inSubpaths ) {

        var shapes = [];

        for ( var i = 0, il = inSubpaths.length; i < il; i++ ) {

            var tmpPath = inSubpaths[ i ];

            var tmpShape = new THREE.Shape();
            tmpShape.actions = tmpPath.actions;
            tmpShape.curves = tmpPath.curves;

            shapes.push( tmpShape );

        }

        //console.log("shape", shapes);

        return shapes;

    }

    function isPointInsidePolygon( inPt, inPolygon ) {

        var EPSILON = 0.0000000001;

        var polyLen = inPolygon.length;

        // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line
        var inside = false;
        for ( var p = polyLen - 1, q = 0; q < polyLen; p = q++ ) {

            var edgeLowPt = inPolygon[ p ];
            var edgeHighPt = inPolygon[ q ];

            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;

            if ( Math.abs( edgeDy ) > EPSILON ) {

                // not parallel
                if ( edgeDy < 0 ) {

                    edgeLowPt = inPolygon[ q ];
                    edgeDx = -edgeDx;
                    edgeHighPt = inPolygon[ p ];
                    edgeDy = -edgeDy;

                }
                if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) continue;

                if ( inPt.y === edgeLowPt.y ) {

                    if ( inPt.x === edgeLowPt.x ) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!

                }
                else {

                    var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
                    if ( perpEdge === 0 ) return true; // inPt is on contour ?
                    if ( perpEdge < 0 ) continue;
                    inside = !inside; // true intersection left of inPt

                }

            }
            else {

                // parallel or collinear
                if ( inPt.y !== edgeLowPt.y ) continue; // parallel
                // edge lies on the same horizontal line as inPt
                if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
                    ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) ) return true; // inPt: Point on contour !
                // continue;

            }

        }

        return inside;

    }


    var subPaths = extractSubpaths( this.actions );
    if ( subPaths.length === 0 ) return [];

    if ( noHoles === true ) return toShapesNoHoles( subPaths );


    var solid, tmpPath, tmpShape, shapes = [];

    if ( subPaths.length === 1 ) {

        tmpPath = subPaths[ 0 ];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push( tmpShape );
        return shapes;

    }

    var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
    holesFirst = isCCW ? !holesFirst : holesFirst;

    // console.log("Holes first", holesFirst);

    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;

    newShapes[ mainIdx ] = undefined;
    newShapeHoles[ mainIdx ] = [];

    var i, il;

    for ( i = 0, il = subPaths.length; i < il; i++ ) {

        tmpPath = subPaths[ i ];
        tmpPoints = tmpPath.getPoints();
        solid = THREE.Shape.Utils.isClockWise( tmpPoints );
        solid = isCCW ? !solid : solid;

        if ( solid ) {

            if ( ( !holesFirst ) && ( newShapes[ mainIdx ] ) ) mainIdx++;

            newShapes[ mainIdx ] = {
                s: new THREE.Shape(),
                p: tmpPoints
            };
            newShapes[ mainIdx ].s.actions = tmpPath.actions;
            newShapes[ mainIdx ].s.curves = tmpPath.curves;

            if ( holesFirst ) mainIdx++;
            newShapeHoles[ mainIdx ] = [];

            //console.log('cw', i);

        }
        else {

            newShapeHoles[ mainIdx ].push( {
                h: tmpPath,
                p: tmpPoints[ 0 ]
            } );

            //console.log('ccw', i);

        }

    }

    // only Holes? -> probably all Shapes with wrong orientation
    if ( !newShapes[ 0 ] ) return toShapesNoHoles( subPaths );


    if ( newShapes.length > 1 ) {

        var ambiguous = false;
        var toChange = [];

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {

            betterShapeHoles[ sIdx ] = [];

        }
        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {

            var sho = newShapeHoles[ sIdx ];
            for ( var hIdx = 0; hIdx < sho.length; hIdx++ ) {

                var ho = sho[ hIdx ];
                var hole_unassigned = true;
                for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx++ ) {

                    if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

                        if ( sIdx !== s2Idx ) toChange.push( {
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        } );
                        if ( hole_unassigned ) {

                            hole_unassigned = false;
                            betterShapeHoles[ s2Idx ].push( ho );

                        }
                        else {

                            ambiguous = true;

                        }

                    }

                }
                if ( hole_unassigned ) {

                    betterShapeHoles[ sIdx ].push( ho );

                }

            }

        }
        // console.log("ambiguous: ", ambiguous);
        if ( toChange.length > 0 ) {

            // console.log("to change: ", toChange);
            if ( !ambiguous ) newShapeHoles = betterShapeHoles;

        }

    }

    var tmpHoles, j, jl;
    for ( i = 0, il = newShapes.length; i < il; i++ ) {

        tmpShape = newShapes[ i ].s;
        shapes.push( tmpShape );
        tmpHoles = newShapeHoles[ i ];
        for ( j = 0, jl = tmpHoles.length; j < jl; j++ ) {

            tmpShape.holes.push( tmpHoles[ j ].h );

        }

    }

    //console.log("shape", shapes);

    return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function() {

    THREE.Path.apply( this, arguments );
    this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function( options ) {

    var extruded = new THREE.ExtrudeGeometry( this, options );
    return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function( options ) {

    var geometry = new THREE.ShapeGeometry( this, options );
    return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function( divisions ) {

    var i, il = this.holes.length,
        holesPts = [];

    for ( i = 0; i < il; i++ ) {

        holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

    }

    return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function( divisions ) {

    var i, il = this.holes.length,
        holesPts = [];

    for ( i = 0; i < il; i++ ) {

        holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

    }

    return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function( divisions ) {

    return {

        shape: this.getTransformedPoints( divisions ),
        holes: this.getPointsHoles( divisions )

    };

};

THREE.Shape.prototype.extractPoints = function( divisions ) {

    if ( this.useSpacedPoints ) {

        return this.extractAllSpacedPoints( divisions );

    }

    return this.extractAllPoints( divisions );

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function( divisions ) {

    return {

        shape: this.getTransformedSpacedPoints( divisions ),
        holes: this.getSpacedPointsHoles( divisions )

    };

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

    triangulateShape: function( contour, holes ) {

        function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

            // inOtherPt needs to be collinear to the inSegment
            if ( inSegPt1.x !== inSegPt2.x ) {

                if ( inSegPt1.x < inSegPt2.x ) {

                    return ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

                }
                else {

                    return ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

                }

            }
            else {

                if ( inSegPt1.y < inSegPt2.y ) {

                    return ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

                }
                else {

                    return ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

                }

            }

        }

        function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

            var EPSILON = 0.0000000001;

            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
                seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
                seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

            var limit = seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

            if ( Math.abs( limit ) > EPSILON ) {

                // not parallel

                var perpSeg2;
                if ( limit > 0 ) {

                    if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) return [];

                }
                else {

                    if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) return [];

                }

                // i.e. to reduce rounding errors
                // intersection at endpoint of segment#1?
                if ( perpSeg2 === 0 ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) ) return [];
                    return [ inSeg1Pt1 ];

                }
                if ( perpSeg2 === limit ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) ) return [];
                    return [ inSeg1Pt2 ];

                }
                // intersection at endpoint of segment#2?
                if ( perpSeg1 === 0 ) return [ inSeg2Pt1 ];
                if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

                // return real intersection point
                var factorSeg1 = perpSeg2 / limit;
                return [ {
                    x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                    y: inSeg1Pt1.y + factorSeg1 * seg1dy
                } ];

            }
            else {

                // parallel or collinear
                if ( ( perpSeg1 !== 0 ) ||
                    ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) return [];

                // they are collinear or degenerate
                var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) ); // segment1 is just a point?
                var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) ); // segment2 is just a point?
                // both segments are points
                if ( seg1Pt && seg2Pt ) {

                    if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
                        ( inSeg1Pt1.y !== inSeg2Pt1.y ) ) return []; // they are distinct  points
                    return [ inSeg1Pt1 ]; // they are the same point

                }
                // segment#1  is a single point
                if ( seg1Pt ) {

                    if ( !point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) ) return []; // but not in segment#2
                    return [ inSeg1Pt1 ];

                }
                // segment#2  is a single point
                if ( seg2Pt ) {

                    if ( !point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) ) return []; // but not in segment#1
                    return [ inSeg2Pt1 ];

                }

                // they are collinear segments, which might overlap
                var seg1min, seg1max, seg1minVal, seg1maxVal;
                var seg2min, seg2max, seg2minVal, seg2maxVal;
                if ( seg1dx !== 0 ) {

                    // the segments are NOT on a vertical line
                    if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.x;

                    }
                    else {

                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.x;

                    }
                    if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.x;

                    }
                    else {

                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.x;

                    }

                }
                else {

                    // the segments are on a vertical line
                    if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.y;

                    }
                    else {

                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.y;

                    }
                    if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.y;

                    }
                    else {

                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.y;

                    }

                }
                if ( seg1minVal <= seg2minVal ) {

                    if ( seg1maxVal < seg2minVal ) return [];
                    if ( seg1maxVal === seg2minVal ) {

                        if ( inExcludeAdjacentSegs ) return [];
                        return [ seg2min ];

                    }
                    if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
                    return [ seg2min, seg2max ];

                }
                else {

                    if ( seg1minVal > seg2maxVal ) return [];
                    if ( seg1minVal === seg2maxVal ) {

                        if ( inExcludeAdjacentSegs ) return [];
                        return [ seg1min ];

                    }
                    if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
                    return [ seg1min, seg2max ];

                }

            }

        }

        function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

            // The order of legs is important

            var EPSILON = 0.0000000001;

            // translation of all points, so that Vertex is at (0,0)
            var legFromPtX = inLegFromPt.x - inVertex.x,
                legFromPtY = inLegFromPt.y - inVertex.y;
            var legToPtX = inLegToPt.x - inVertex.x,
                legToPtY = inLegToPt.y - inVertex.y;
            var otherPtX = inOtherPt.x - inVertex.x,
                otherPtY = inOtherPt.y - inVertex.y;

            // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
            var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

            if ( Math.abs( from2toAngle ) > EPSILON ) {

                // angle != 180 deg.

                var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

                if ( from2toAngle > 0 ) {

                    // main angle < 180 deg.
                    return ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

                }
                else {

                    // main angle > 180 deg.
                    return ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

                }

            }
            else {

                // angle == 180 deg.
                // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                return ( from2otherAngle > 0 );

            }

        }


        function removeHoles( contour, holes ) {

            var shape = contour.concat(); // work on this shape
            var hole;

            function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

                // Check if hole point lies within angle around shape point
                var lastShapeIdx = shape.length - 1;

                var prevShapeIdx = inShapeIdx - 1;
                if ( prevShapeIdx < 0 ) prevShapeIdx = lastShapeIdx;

                var nextShapeIdx = inShapeIdx + 1;
                if ( nextShapeIdx > lastShapeIdx ) nextShapeIdx = 0;

                var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
                if ( !insideAngle ) {

                    // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                    return false;

                }

                // Check if shape point lies within angle around hole point
                var lastHoleIdx = hole.length - 1;

                var prevHoleIdx = inHoleIdx - 1;
                if ( prevHoleIdx < 0 ) prevHoleIdx = lastHoleIdx;

                var nextHoleIdx = inHoleIdx + 1;
                if ( nextHoleIdx > lastHoleIdx ) nextHoleIdx = 0;

                insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
                if ( !insideAngle ) {

                    // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
                    return false;

                }

                return true;

            }

            function intersectsShapeEdge( inShapePt, inHolePt ) {

                // checks for intersections with shape edges
                var sIdx, nextIdx, intersection;
                for ( sIdx = 0; sIdx < shape.length; sIdx++ ) {

                    nextIdx = sIdx + 1;
                    nextIdx %= shape.length;
                    intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
                    if ( intersection.length > 0 ) return true;

                }

                return false;

            }

            var indepHoles = [];

            function intersectsHoleEdge( inShapePt, inHolePt ) {

                // checks for intersections with hole edges
                var ihIdx, chkHole,
                    hIdx, nextIdx, intersection;
                for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx++ ) {

                    chkHole = holes[ indepHoles[ ihIdx ] ];
                    for ( hIdx = 0; hIdx < chkHole.length; hIdx++ ) {

                        nextIdx = hIdx + 1;
                        nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
                        if ( intersection.length > 0 ) return true;

                    }

                }
                return false;

            }

            var holeIndex, shapeIndex,
                shapePt, holePt,
                holeIdx, cutKey, failedCuts = [],
                tmpShape1, tmpShape2,
                tmpHole1, tmpHole2;

            for ( var h = 0, hl = holes.length; h < hl; h++ ) {

                indepHoles.push( h );

            }

            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while ( indepHoles.length > 0 ) {

                counter--;
                if ( counter < 0 ) {

                    console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
                    break;

                }

                // search for shape-vertex and hole-vertex,
                // which can be connected without intersections
                for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++ ) {

                    shapePt = shape[ shapeIndex ];
                    holeIndex = -1;

                    // search for hole which can be reached without intersections
                    for ( var h = 0; h < indepHoles.length; h++ ) {

                        holeIdx = indepHoles[ h ];

                        // prevent multiple checks
                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                        if ( failedCuts[ cutKey ] !== undefined ) continue;

                        hole = holes[ holeIdx ];
                        for ( var h2 = 0; h2 < hole.length; h2++ ) {

                            holePt = hole[ h2 ];
                            if ( !isCutLineInsideAngles( shapeIndex, h2 ) ) continue;
                            if ( intersectsShapeEdge( shapePt, holePt ) ) continue;
                            if ( intersectsHoleEdge( shapePt, holePt ) ) continue;

                            holeIndex = h2;
                            indepHoles.splice( h, 1 );

                            tmpShape1 = shape.slice( 0, shapeIndex + 1 );
                            tmpShape2 = shape.slice( shapeIndex );
                            tmpHole1 = hole.slice( holeIndex );
                            tmpHole2 = hole.slice( 0, holeIndex + 1 );

                            shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

                            minShapeIndex = shapeIndex;

                            // Debug only, to show the selected cuts
                            // glob_CutLines.push( [ shapePt, holePt ] );

                            break;

                        }
                        if ( holeIndex >= 0 ) break; // hole-vertex found

                        failedCuts[ cutKey ] = true; // remember failure

                    }
                    if ( holeIndex >= 0 ) break; // hole-vertex found

                }

            }

            return shape; /* shape with no holes */

        }


        var i, il, f, face,
            key, index,
            allPointsMap = {};

        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

        var allpoints = contour.concat();

        for ( var h = 0, hl = holes.length; h < hl; h++ ) {

            Array.prototype.push.apply( allpoints, holes[ h ] );

        }

        //console.log( "allpoints",allpoints, allpoints.length );

        // prepare all points map

        for ( i = 0, il = allpoints.length; i < il; i++ ) {

            key = allpoints[ i ].x + ":" + allpoints[ i ].y;

            if ( allPointsMap[ key ] !== undefined ) {

                console.warn( "THREE.Shape: Duplicate point", key );

            }

            allPointsMap[ key ] = i;

        }

        // remove holes by cutting paths to holes and adding them to the shape
        var shapeWithoutHoles = removeHoles( contour, holes );

        var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
        //console.log( "triangles",triangles, triangles.length );

        // check all face vertices against all points map

        for ( i = 0, il = triangles.length; i < il; i++ ) {

            face = triangles[ i ];

            for ( f = 0; f < 3; f++ ) {

                key = face[ f ].x + ":" + face[ f ].y;

                index = allPointsMap[ key ];

                if ( index !== undefined ) {

                    face[ f ] = index;

                }

            }

        }

        return triangles.concat();

    },

    isClockWise: function( pts ) {

        return THREE.FontUtils.Triangulate.area( pts ) < 0;

    },

    // Bezier Curves formulas obtained from
    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    // Quad Bezier Functions

    b2p0: function( t, p ) {

        var k = 1 - t;
        return k * k * p;

    },

    b2p1: function( t, p ) {

        return 2 * ( 1 - t ) * t * p;

    },

    b2p2: function( t, p ) {

        return t * t * p;

    },

    b2: function( t, p0, p1, p2 ) {

        return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

    },

    // Cubic Bezier Functions

    b3p0: function( t, p ) {

        var k = 1 - t;
        return k * k * k * p;

    },

    b3p1: function( t, p ) {

        var k = 1 - t;
        return 3 * k * k * t * p;

    },

    b3p2: function( t, p ) {

        var k = 1 - t;
        return 3 * k * t * t * p;

    },

    b3p3: function( t, p ) {

        return t * t * t * p;

    },

    b3: function( t, p0, p1, p2, p3 ) {

        return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) + this.b3p3( t, p3 );

    }

};

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function( t ) {

    var point = this.v2.clone().sub( this.v1 );
    point.multiplyScalar( t ).add( this.v1 );

    return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function( u ) {

    return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

    var tangent = this.v2.clone().sub( this.v1 );

    return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function( t ) {

    var vector = new THREE.Vector2();

    vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

    return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

    var vector = new THREE.Vector2();

    vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

    // returns unit vector

    return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function( t ) {

    var tx, ty;

    tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

    return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

    var tx, ty;

    tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

    var tangent = new THREE.Vector2( tx, ty );
    tangent.normalize();

    return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function( points /* array of Vector2 */ ) {

    this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var vector = new THREE.Vector2();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

    return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    this.aX = aX;
    this.aY = aY;

    this.xRadius = xRadius;
    this.yRadius = yRadius;

    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;

    this.aClockwise = aClockwise;

    this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function( t ) {

    var deltaAngle = this.aEndAngle - this.aStartAngle;

    if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
    if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

    var angle;

    if ( this.aClockwise === true ) {

        angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

    }
    else {

        angle = this.aStartAngle + t * deltaAngle;

    }

    var x = this.aX + this.xRadius * Math.cos( angle );
    var y = this.aY + this.yRadius * Math.sin( angle );

    if ( this.aRotation !== 0 ) {

        var cos = Math.cos( this.aRotation );
        var sin = Math.sin( this.aRotation );

        var tx = x,
            ty = y;

        // Rotate the point about the center of the ellipse.
        x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
        y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

    }

    return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

    function( v1, v2 ) {

        this.v1 = v1;
        this.v2 = v2;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.subVectors( this.v2, this.v1 ); // diff
        vector.multiplyScalar( t );
        vector.add( this.v1 );

        return vector;

    }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

    function( v0, v1, v2 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
        vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
        vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

        return vector;

    }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

    function( v0, v1, v2, v3 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
        vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
        vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

        return vector;

    }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

    function( points /* array of Vector3 */ ) {

        console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
        this.points = ( points == undefined ) ? [] : points;

    },

    function( t ) {

        var points = this.points;
        var point = ( points.length - 1 ) * t;

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
        var point1 = points[ intPoint ];
        var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
        var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

        var vector = new THREE.Vector3();

        vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
        vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
        vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

        return vector;

    }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

    var
        tmp = new THREE.Vector3(),
        px = new CubicPoly(),
        py = new CubicPoly(),
        pz = new CubicPoly();

    /*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

    function CubicPoly() {

    }

    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

        this.c0 = x0;
        this.c1 = t0;
        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    };

    CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

        // compute tangents when parameterized in [t1,t2]
        var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
        var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;

        // initCubicPoly
        this.init( x1, x2, t1, t2 );

    };

    // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

        this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    };

    CubicPoly.prototype.calc = function( t ) {

        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    };

    // Subclass Three.js curve
    return THREE.Curve.create(

        function( p /* array of Vector3 */ ) {

            this.points = p || [];

        },

        function( t ) {

            var points = this.points,
                point, intPoint, weight, l;

            l = points.length;

            if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

            point = ( l - 1 ) * t;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            if ( weight === 0 && intPoint === l - 1 ) {

                intPoint = l - 2;
                weight = 1;

            }

            var p0, p1, p2, p3;

            if ( intPoint === 0 ) {

                // extrapolate first point
                tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
                p0 = tmp;

            }
            else {

                p0 = points[ intPoint - 1 ];

            }

            p1 = points[ intPoint ];
            p2 = points[ intPoint + 1 ];

            if ( intPoint + 2 < l ) {

                p3 = points[ intPoint + 2 ]

            }
            else {

                // extrapolate last point
                tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
                p3 = tmp;

            }

            if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

                // init Centripetal / Chordal Catmull-Rom
                var pow = this.type === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
                var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
                var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

                // safety check for repeated points
                if ( dt1 < 1e-4 ) dt1 = 1.0;
                if ( dt0 < 1e-4 ) dt0 = dt1;
                if ( dt2 < 1e-4 ) dt2 = dt1;

                px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
                py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
                pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

            }
            else if ( this.type === 'catmullrom' ) {

                var tension = this.tension !== undefined ? this.tension : 0.5;
                px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
                py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
                pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

            }

            var v = new THREE.Vector3(
                px.calc( weight ),
                py.calc( weight ),
                pz.calc( weight )
            );

            return v;

        }

    );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

    function( points /* array of Vector3 */ ) {

        this.points = ( points == undefined ) ? [] : points;

    },

    function( t ) {

        var points = this.points;
        var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

        var point0 = points[ ( intPoint - 1 ) % points.length ];
        var point1 = points[ ( intPoint ) % points.length ];
        var point2 = points[ ( intPoint + 1 ) % points.length ];
        var point3 = points[ ( intPoint + 2 ) % points.length ];

        var vector = new THREE.Vector3();

        vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
        vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
        vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

        return vector;

    }

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2,

    //

    add: function() {

        console.warn( 'THREE.AnimationHandler.add() has been deprecated.' );

    },
    get: function() {

        console.warn( 'THREE.AnimationHandler.get() has been deprecated.' );

    },
    remove: function() {

        console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );

    },

    //

    animations: [],

    init: function( data ) {

        if ( data.initialized === true ) return data;

        // loop through all keys

        for ( var h = 0; h < data.hierarchy.length; h++ ) {

            for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                // remove minus times

                if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

                    data.hierarchy[ h ].keys[ k ].time = 0;

                }

                // create quaternions

                if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
                    !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

                    var quat = data.hierarchy[ h ].keys[ k ].rot;
                    data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

                }

            }

            // prepare morph target keys

            if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

                // get all used

                var usedMorphTargets = {};

                for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                    for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m++ ) {

                        var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
                        usedMorphTargets[ morphTargetName ] = -1;

                    }

                }

                data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


                // set all used on all frames

                for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                    var influences = {};

                    for ( var morphTargetName in usedMorphTargets ) {

                        for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m++ ) {

                            if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

                                influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
                                break;

                            }

                        }

                        if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

                            influences[ morphTargetName ] = 0;

                        }

                    }

                    data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

                }

            }


            // remove all keys that are on the same time

            for ( var k = 1; k < data.hierarchy[ h ].keys.length; k++ ) {

                if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

                    data.hierarchy[ h ].keys.splice( k, 1 );
                    k--;

                }

            }


            // set index

            for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                data.hierarchy[ h ].keys[ k ].index = k;

            }

        }

        data.initialized = true;

        return data;

    },

    parse: function( root ) {

        var parseRecurseHierarchy = function( root, hierarchy ) {

            hierarchy.push( root );

            for ( var c = 0; c < root.children.length; c++ )
                parseRecurseHierarchy( root.children[ c ], hierarchy );

        };

        // setup hierarchy

        var hierarchy = [];

        if ( root instanceof THREE.SkinnedMesh ) {

            for ( var b = 0; b < root.skeleton.bones.length; b++ ) {

                hierarchy.push( root.skeleton.bones[ b ] );

            }

        }
        else {

            parseRecurseHierarchy( root, hierarchy );

        }

        return hierarchy;

    },

    play: function( animation ) {

        if ( this.animations.indexOf( animation ) === -1 ) {

            this.animations.push( animation );

        }

    },

    stop: function( animation ) {

        var index = this.animations.indexOf( animation );

        if ( index !== -1 ) {

            this.animations.splice( index, 1 );

        }

    },

    update: function( deltaTimeMS ) {

        for ( var i = 0; i < this.animations.length; i++ ) {

            this.animations[ i ].resetBlendWeights();

        }

        for ( var i = 0; i < this.animations.length; i++ ) {

            this.animations[ i ].update( deltaTimeMS );

        }

    }

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function( root, data ) {

    this.root = root;
    this.data = THREE.AnimationHandler.init( data );
    this.hierarchy = THREE.AnimationHandler.parse( root );

    this.currentTime = 0;
    this.timeScale = 1;

    this.isPlaying = false;
    this.loop = true;
    this.weight = 0;

    this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype = {

    constructor: THREE.Animation,

    keyTypes: [ "pos", "rot", "scl" ],

    play: function( startTime, weight ) {

        this.currentTime = startTime !== undefined ? startTime : 0;
        this.weight = weight !== undefined ? weight : 1;

        this.isPlaying = true;

        this.reset();

        THREE.AnimationHandler.play( this );

    },

    stop: function() {

        this.isPlaying = false;

        THREE.AnimationHandler.stop( this );

    },

    reset: function() {

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];

            if ( object.animationCache === undefined ) {

                object.animationCache = {
                    animations: {},
                    blending: {
                        positionWeight: 0.0,
                        quaternionWeight: 0.0,
                        scaleWeight: 0.0
                    }
                };

            }

            var name = this.data.name;
            var animations = object.animationCache.animations;
            var animationCache = animations[ name ];

            if ( animationCache === undefined ) {

                animationCache = {
                    prevKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    nextKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    originalMatrix: object.matrix
                };

                animations[ name ] = animationCache;

            }

            // Get keys to match our current time

            for ( var t = 0; t < 3; t++ ) {

                var type = this.keyTypes[ t ];

                var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
                var nextKey = this.getNextKeyWith( type, h, 1 );

                while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                    prevKey = nextKey;
                    nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

                }

                animationCache.prevKey[ type ] = prevKey;
                animationCache.nextKey[ type ] = nextKey;

            }

        }

    },

    resetBlendWeights: function() {

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];
            var animationCache = object.animationCache;

            if ( animationCache !== undefined ) {

                var blending = animationCache.blending;

                blending.positionWeight = 0.0;
                blending.quaternionWeight = 0.0;
                blending.scaleWeight = 0.0;

            }

        }

    },

    update: ( function() {

        var points = [];
        var target = new THREE.Vector3();
        var newVector = new THREE.Vector3();
        var newQuat = new THREE.Quaternion();

        // Catmull-Rom spline

        var interpolateCatmullRom = function( points, scale ) {

            var c = [],
                v3 = [],
                point, intPoint, weight, w2, w3,
                pa, pb, pc, pd;

            point = ( points.length - 1 ) * scale;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
            c[ 1 ] = intPoint;
            c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
            c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

            pa = points[ c[ 0 ] ];
            pb = points[ c[ 1 ] ];
            pc = points[ c[ 2 ] ];
            pd = points[ c[ 3 ] ];

            w2 = weight * weight;
            w3 = weight * w2;

            v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
            v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
            v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

            return v3;

        };

        var interpolate = function( p0, p1, p2, p3, t, t2, t3 ) {

            var v0 = ( p2 - p0 ) * 0.5,
                v1 = ( p3 - p1 ) * 0.5;

            return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( -3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

        };

        return function( delta ) {

            if ( this.isPlaying === false ) return;

            this.currentTime += delta * this.timeScale;

            if ( this.weight === 0 )
                return;

            //

            var duration = this.data.length;

            if ( this.currentTime > duration || this.currentTime < 0 ) {

                if ( this.loop ) {

                    this.currentTime %= duration;

                    if ( this.currentTime < 0 )
                        this.currentTime += duration;

                    this.reset();

                }
                else {

                    this.stop();

                }

            }

            for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

                var object = this.hierarchy[ h ];
                var animationCache = object.animationCache.animations[ this.data.name ];
                var blending = object.animationCache.blending;

                // loop through pos/rot/scl

                for ( var t = 0; t < 3; t++ ) {

                    // get keys

                    var type = this.keyTypes[ t ];
                    var prevKey = animationCache.prevKey[ type ];
                    var nextKey = animationCache.nextKey[ type ];

                    if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
                        ( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

                        prevKey = this.data.hierarchy[ h ].keys[ 0 ];
                        nextKey = this.getNextKeyWith( type, h, 1 );

                        while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                            prevKey = nextKey;
                            nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

                        }

                        animationCache.prevKey[ type ] = prevKey;
                        animationCache.nextKey[ type ] = nextKey;

                    }

                    var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

                    var prevXYZ = prevKey[ type ];
                    var nextXYZ = nextKey[ type ];

                    if ( scale < 0 ) scale = 0;
                    if ( scale > 1 ) scale = 1;

                    // interpolate

                    if ( type === "pos" ) {

                        if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

                            newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
                            newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
                            newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

                            // blend
                            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
                            object.position.lerp( newVector, proportionalWeight );
                            blending.positionWeight += this.weight;

                        }
                        else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
                            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                            points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
                            points[ 1 ] = prevXYZ;
                            points[ 2 ] = nextXYZ;
                            points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

                            scale = scale * 0.33 + 0.33;

                            var currentPoint = interpolateCatmullRom( points, scale );
                            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
                            blending.positionWeight += this.weight;

                            // blend

                            var vector = object.position;

                            vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
                            vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
                            vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

                            if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                                var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

                                target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
                                target.sub( vector );
                                target.y = 0;
                                target.normalize();

                                var angle = Math.atan2( target.x, target.z );
                                object.rotation.set( 0, angle, 0 );

                            }

                        }

                    }
                    else if ( type === "rot" ) {

                        THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

                        // Avoid paying the cost of an additional slerp if we don't have to
                        if ( blending.quaternionWeight === 0 ) {

                            object.quaternion.copy( newQuat );
                            blending.quaternionWeight = this.weight;

                        }
                        else {

                            var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
                            THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
                            blending.quaternionWeight += this.weight;

                        }

                    }
                    else if ( type === "scl" ) {

                        newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
                        newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
                        newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

                        var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
                        object.scale.lerp( newVector, proportionalWeight );
                        blending.scaleWeight += this.weight;

                    }

                }

            }

            return true;

        };

    } )(),

    getNextKeyWith: function( type, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;

        if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

            key = key < keys.length - 1 ? key : keys.length - 1;

        }
        else {

            key = key % keys.length;

        }

        for ( ; key < keys.length; key++ ) {

            if ( keys[ key ][ type ] !== undefined ) {

                return keys[ key ];

            }

        }

        return this.data.hierarchy[ h ].keys[ 0 ];

    },

    getPrevKeyWith: function( type, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;

        if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

            key = key > 0 ? key : 0;

        }
        else {

            key = key >= 0 ? key : key + keys.length;

        }


        for ( ; key >= 0; key-- ) {

            if ( keys[ key ][ type ] !== undefined ) {

                return keys[ key ];

            }

        }

        return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

    }

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function( data ) {

    this.root = data.node;
    this.data = THREE.AnimationHandler.init( data );
    this.hierarchy = THREE.AnimationHandler.parse( this.root );
    this.currentTime = 0;
    this.timeScale = 0.001;
    this.isPlaying = false;
    this.isPaused = true;
    this.loop = true;

    // initialize to first keyframes

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

        var keys = this.data.hierarchy[ h ].keys,
            sids = this.data.hierarchy[ h ].sids,
            obj = this.hierarchy[ h ];

        if ( keys.length && sids ) {

            for ( var s = 0; s < sids.length; s++ ) {

                var sid = sids[ s ],
                    next = this.getNextKeyWith( sid, h, 0 );

                if ( next ) {

                    next.apply( sid );

                }

            }

            obj.matrixAutoUpdate = false;
            this.data.hierarchy[ h ].node.updateMatrix();
            obj.matrixWorldNeedsUpdate = true;

        }

    }

};

THREE.KeyFrameAnimation.prototype = {

    constructor: THREE.KeyFrameAnimation,

    play: function( startTime ) {

        this.currentTime = startTime !== undefined ? startTime : 0;

        if ( this.isPlaying === false ) {

            this.isPlaying = true;

            // reset key cache

            var h, hl = this.hierarchy.length,
                object,
                node;

            for ( h = 0; h < hl; h++ ) {

                object = this.hierarchy[ h ];
                node = this.data.hierarchy[ h ];

                if ( node.animationCache === undefined ) {

                    node.animationCache = {};
                    node.animationCache.prevKey = null;
                    node.animationCache.nextKey = null;
                    node.animationCache.originalMatrix = object.matrix;

                }

                var keys = this.data.hierarchy[ h ].keys;

                if ( keys.length ) {

                    node.animationCache.prevKey = keys[ 0 ];
                    node.animationCache.nextKey = keys[ 1 ];

                    this.startTime = Math.min( keys[ 0 ].time, this.startTime );
                    this.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );

                }

            }

            this.update( 0 );

        }

        this.isPaused = false;

        THREE.AnimationHandler.play( this );

    },

    stop: function() {

        this.isPlaying = false;
        this.isPaused = false;

        THREE.AnimationHandler.stop( this );

        // reset JIT matrix and remove cache

        for ( var h = 0; h < this.data.hierarchy.length; h++ ) {

            var obj = this.hierarchy[ h ];
            var node = this.data.hierarchy[ h ];

            if ( node.animationCache !== undefined ) {

                var original = node.animationCache.originalMatrix;

                original.copy( obj.matrix );
                obj.matrix = original;

                delete node.animationCache;

            }

        }

    },

    update: function( delta ) {

        if ( this.isPlaying === false ) return;

        this.currentTime += delta * this.timeScale;

        //

        var duration = this.data.length;

        if ( this.loop === true && this.currentTime > duration ) {

            this.currentTime %= duration;

        }

        this.currentTime = Math.min( this.currentTime, duration );

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];
            var node = this.data.hierarchy[ h ];

            var keys = node.keys,
                animationCache = node.animationCache;


            if ( keys.length ) {

                var prevKey = animationCache.prevKey;
                var nextKey = animationCache.nextKey;

                if ( nextKey.time <= this.currentTime ) {

                    while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                        prevKey = nextKey;
                        nextKey = keys[ prevKey.index + 1 ];

                    }

                    animationCache.prevKey = prevKey;
                    animationCache.nextKey = nextKey;

                }

                if ( nextKey.time >= this.currentTime ) {

                    prevKey.interpolate( nextKey, this.currentTime );

                }
                else {

                    prevKey.interpolate( nextKey, nextKey.time );

                }

                this.data.hierarchy[ h ].node.updateMatrix();
                object.matrixWorldNeedsUpdate = true;

            }

        }

    },

    getNextKeyWith: function( sid, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;
        key = key % keys.length;

        for ( ; key < keys.length; key++ ) {

            if ( keys[ key ].hasTarget( sid ) ) {

                return keys[ key ];

            }

        }

        return keys[ 0 ];

    },

    getPrevKeyWith: function( sid, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;
        key = key >= 0 ? key : key + keys.length;

        for ( ; key >= 0; key-- ) {

            if ( keys[ key ].hasTarget( sid ) ) {

                return keys[ key ];

            }

        }

        return keys[ keys.length - 1 ];

    }

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author willy-vvu / http://willy-vvu.github.io
 */

THREE.MorphAnimation = function( mesh ) {

    this.mesh = mesh;
    this.frames = mesh.morphTargetInfluences.length;
    this.currentTime = 0;
    this.duration = 1000;
    this.loop = true;
    this.lastFrame = 0;
    this.currentFrame = 0;

    this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

    constructor: THREE.MorphAnimation,

    play: function() {

        this.isPlaying = true;

    },

    pause: function() {

        this.isPlaying = false;

    },

    update: function( delta ) {

        if ( this.isPlaying === false ) return;

        this.currentTime += delta;

        if ( this.loop === true && this.currentTime > this.duration ) {

            this.currentTime %= this.duration;

        }

        this.currentTime = Math.min( this.currentTime, this.duration );

        var frameTime = this.duration / this.frames;
        var frame = Math.floor( this.currentTime / frameTime );

        var influences = this.mesh.morphTargetInfluences;

        if ( frame !== this.currentFrame ) {

            influences[ this.lastFrame ] = 0;
            influences[ this.currentFrame ] = 1;
            influences[ frame ] = 0;

            this.lastFrame = this.currentFrame;
            this.currentFrame = frame;

        }

        var mix = ( this.currentTime % frameTime ) / frameTime;

        influences[ frame ] = mix;
        influences[ this.lastFrame ] = 1 - mix;

    }

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    THREE.Geometry.call( this );

    this.type = 'BoxGeometry';

    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };

    this.widthSegments = widthSegments || 1;
    this.heightSegments = heightSegments || 1;
    this.depthSegments = depthSegments || 1;

    var scope = this;

    var width_half = width / 2;
    var height_half = height / 2;
    var depth_half = depth / 2;

    buildPlane( 'z', 'y', -1, -1, depth, height, width_half, 0 ); // px
    buildPlane( 'z', 'y', 1, -1, depth, height, -width_half, 1 ); // nx
    buildPlane( 'x', 'z', 1, 1, width, depth, height_half, 2 ); // py
    buildPlane( 'x', 'z', 1, -1, width, depth, -height_half, 3 ); // ny
    buildPlane( 'x', 'y', 1, -1, width, height, depth_half, 4 ); // pz
    buildPlane( 'x', 'y', -1, -1, width, height, -depth_half, 5 ); // nz

    function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

        var w, ix, iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;

        if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

            w = 'z';

        }
        else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

            w = 'y';
            gridY = scope.depthSegments;

        }
        else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

            w = 'x';
            gridX = scope.depthSegments;

        }

        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();

        normal[ w ] = depth > 0 ? 1 : -1;

        for ( iy = 0; iy < gridY1; iy++ ) {

            for ( ix = 0; ix < gridX1; ix++ ) {

                var vector = new THREE.Vector3();
                vector[ u ] = ( ix * segment_width - width_half ) * udir;
                vector[ v ] = ( iy * segment_height - height_half ) * vdir;
                vector[ w ] = depth;

                scope.vertices.push( vector );

            }

        }

        for ( iy = 0; iy < gridY; iy++ ) {

            for ( ix = 0; ix < gridX; ix++ ) {

                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * ( iy + 1 );
                var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
                var d = ( ix + 1 ) + gridX1 * iy;

                var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
                var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
                var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
                var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

                var face = new THREE.Face3( a + offset, b + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

                face = new THREE.Face3( b + offset, c + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

            }

        }

    }

    this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function() {

    var geometry = new THREE.BoxGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.depth,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.depthSegments
    );

    return geometry;

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function( radius, segments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CircleGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var i, uvs = [],
        center = new THREE.Vector3(),
        centerUV = new THREE.Vector2( 0.5, 0.5 );

    this.vertices.push( center );
    uvs.push( centerUV );

    for ( i = 0; i <= segments; i++ ) {

        var vertex = new THREE.Vector3();
        var segment = thetaStart + i / segments * thetaLength;

        vertex.x = radius * Math.cos( segment );
        vertex.y = radius * Math.sin( segment );

        this.vertices.push( vertex );
        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 1; i <= segments; i++ ) {

        this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
        this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function() {

    var geometry = new THREE.CircleGeometry(
        this.parameters.radius,
        this.parameters.segments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function( radius, segments, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'CircleBufferGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var vertices = segments + 2;

    var positions = new Float32Array( vertices * 3 );
    var normals = new Float32Array( vertices * 3 );
    var uvs = new Float32Array( vertices * 2 );

    // center data is already zero, but need to set a few extras
    normals[ 3 ] = 1.0;
    uvs[ 0 ] = 0.5;
    uvs[ 1 ] = 0.5;

    for ( var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2 ) {

        var segment = thetaStart + s / segments * thetaLength;

        positions[ i ] = radius * Math.cos( segment );
        positions[ i + 1 ] = radius * Math.sin( segment );

        normals[ i + 2 ] = 1; // normal z

        uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
        uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    }

    var indices = [];

    for ( var i = 1; i <= segments; i++ ) {

        indices.push( i );
        indices.push( i + 1 );
        indices.push( 0 );

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.CircleBufferGeometry(
        this.parameters.radius,
        this.parameters.segments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CylinderGeometry';

    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;

    radialSegments = radialSegments || 8;
    heightSegments = heightSegments || 1;

    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

    var heightHalf = height / 2;

    var x, y, vertices = [],
        uvs = [];

    for ( y = 0; y <= heightSegments; y++ ) {

        var verticesRow = [];
        var uvsRow = [];

        var v = y / heightSegments;
        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

        for ( x = 0; x <= radialSegments; x++ ) {

            var u = x / radialSegments;

            var vertex = new THREE.Vector3();
            vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
            vertex.y = -v * height + heightHalf;
            vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

            this.vertices.push( vertex );

            verticesRow.push( this.vertices.length - 1 );
            uvsRow.push( new THREE.Vector2( u, 1 - v ) );

        }

        vertices.push( verticesRow );
        uvs.push( uvsRow );

    }

    var tanTheta = ( radiusBottom - radiusTop ) / height;
    var na, nb;

    for ( x = 0; x < radialSegments; x++ ) {

        if ( radiusTop !== 0 ) {

            na = this.vertices[ vertices[ 0 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

        }
        else {

            na = this.vertices[ vertices[ 1 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

        }

        na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
        nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

        for ( y = 0; y < heightSegments; y++ ) {

            var v1 = vertices[ y ][ x ];
            var v2 = vertices[ y + 1 ][ x ];
            var v3 = vertices[ y + 1 ][ x + 1 ];
            var v4 = vertices[ y ][ x + 1 ];

            var n1 = na.clone();
            var n2 = na.clone();
            var n3 = nb.clone();
            var n4 = nb.clone();

            var uv1 = uvs[ y ][ x ].clone();
            var uv2 = uvs[ y + 1 ][ x ].clone();
            var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
            var uv4 = uvs[ y ][ x + 1 ].clone();

            this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

            this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

        }

    }

    // top cap

    if ( openEnded === false && radiusTop > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x++ ) {

            var v1 = vertices[ 0 ][ x ];
            var v2 = vertices[ 0 ][ x + 1 ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, 1, 0 );
            var n2 = new THREE.Vector3( 0, 1, 0 );
            var n3 = new THREE.Vector3( 0, 1, 0 );

            var uv1 = uvs[ 0 ][ x ].clone();
            var uv2 = uvs[ 0 ][ x + 1 ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 0 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    // bottom cap

    if ( openEnded === false && radiusBottom > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, -heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x++ ) {

            var v1 = vertices[ heightSegments ][ x + 1 ];
            var v2 = vertices[ heightSegments ][ x ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, -1, 0 );
            var n2 = new THREE.Vector3( 0, -1, 0 );
            var n3 = new THREE.Vector3( 0, -1, 0 );

            var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
            var uv2 = uvs[ heightSegments ][ x ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 1 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function() {

    var geometry = new THREE.CylinderGeometry(
        this.parameters.radiusTop,
        this.parameters.radiusBottom,
        this.parameters.height,
        this.parameters.radialSegments,
        this.parameters.heightSegments,
        this.parameters.openEnded,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function( geometry, thresholdAngle ) {

    THREE.BufferGeometry.call( this );

    thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

    var edge = [ 0, 0 ],
        hash = {};
    var sortFunction = function( a, b ) {

        return a - b;

    };

    var keys = [ 'a', 'b', 'c' ];

    var geometry2;

    if ( geometry instanceof THREE.BufferGeometry ) {

        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry( geometry );

    }
    else {

        geometry2 = geometry.clone();

    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();

    var vertices = geometry2.vertices;
    var faces = geometry2.faces;

    for ( var i = 0, l = faces.length; i < l; i++ ) {

        var face = faces[ i ];

        for ( var j = 0; j < 3; j++ ) {

            edge[ 0 ] = face[ keys[ j ] ];
            edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

                hash[ key ] = {
                    vert1: edge[ 0 ],
                    vert2: edge[ 1 ],
                    face1: i,
                    face2: undefined
                };

            }
            else {

                hash[ key ].face2 = i;

            }

        }

    }

    var coords = [];

    for ( var key in hash ) {

        var h = hash[ key ];

        if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

            var vertex = vertices[ h.vert1 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

            vertex = vertices[ h.vert2 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

        }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function( shapes, options ) {

    if ( typeof( shapes ) === "undefined" ) {

        shapes = [];
        return;

    }

    THREE.Geometry.call( this );

    this.type = 'ExtrudeGeometry';

    shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

    // can't really use automatic vertex normals
    // as then front and back sides get smoothed too
    // should do separate smoothing just for sides

    //this.computeVertexNormals();

    //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function( shapes, options ) {

    var sl = shapes.length;

    for ( var s = 0; s < sl; s++ ) {

        var shape = shapes[ s ];
        this.addShape( shape, options );

    }

};

THREE.ExtrudeGeometry.prototype.addShape = function( shape, options ) {

    var amount = options.amount !== undefined ? options.amount : 100;

    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var steps = options.steps !== undefined ? options.steps : 1;

    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;

    // Use default WorldUVGenerator if no UV generators are specified.
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

    var splineTube, binormal, normal, position2;
    if ( extrudePath ) {

        extrudePts = extrudePath.getSpacedPoints( steps );

        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion

        // SETUP TNB variables

        // Reuse TNB from TubeGeomtry for now.
        // TODO1 - have a .isClosed in spline?

        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();

    }

    // Safeguards if bevels are not enabled

    if ( !bevelEnabled ) {

        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;

    }

    // Variables initialization

    var ahole, h, hl; // looping of holes
    var scope = this;

    var shapesOffset = this.vertices.length;

    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = !THREE.Shape.Utils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];

            if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

                holes[ h ] = ahole.reverse();

            }

        }

        reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    }


    var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for ( h = 0, hl = holes.length; h < hl; h++ ) {

        ahole = holes[ h ];

        vertices = vertices.concat( ahole );

    }


    function scalePt2( pt, vec, size ) {

        if ( !vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

        return vec.clone().multiplyScalar( size ).add( pt );

    }

    var b, bs, t, z,
        vert, vlen = vertices.length,
        face, flen = faces.length;


    // Find directions for point movement


    function getBevelVec( inPt, inPrev, inNext ) {

        var EPSILON = 0.0000000001;

        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.

        var v_trans_x, v_trans_y, shrink_by = 1; // resulting translation vector for inPt

        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;

        var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

        // check for collinear edges
        var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

        if ( Math.abs( collinear0 ) > EPSILON ) {

            // not collinear

            // length of vectors for normalizing

            var v_prev_len = Math.sqrt( v_prev_lensq );
            var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

            // shift adjacent points by unit vectors to the left

            var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
            var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

            var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
            var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

            // scaling factor for v_prev to intersection point

            var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
                    ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
                ( v_prev_x * v_next_y - v_prev_y * v_next_x );

            // vector from inPt to intersection point

            v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
            v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

            // Don't normalize!, otherwise sharp corners become ugly
            //  but prevent crazy spikes
            var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
            if ( v_trans_lensq <= 2 ) {

                return new THREE.Vector2( v_trans_x, v_trans_y );

            }
            else {

                shrink_by = Math.sqrt( v_trans_lensq / 2 );

            }

        }
        else {

            // handle special case of collinear edges

            var direction_eq = false; // assumes: opposite
            if ( v_prev_x > EPSILON ) {

                if ( v_next_x > EPSILON ) {

                    direction_eq = true;

                }

            }
            else {

                if ( v_prev_x < -EPSILON ) {

                    if ( v_next_x < -EPSILON ) {

                        direction_eq = true;

                    }

                }
                else {

                    if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

                        direction_eq = true;

                    }

                }

            }

            if ( direction_eq ) {

                // console.log("Warning: lines are a straight sequence");
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt( v_prev_lensq );

            }
            else {

                // console.log("Warning: lines are a straight spike");
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt( v_prev_lensq / 2 );

            }

        }

        return new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    }


    var contourMovements = [];

    for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++ ) {

        if ( j === il ) j = 0;
        if ( k === il ) k = 0;

        //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    }

    var holesMovements = [],
        oneHoleMovements, verticesMovements = contourMovements.concat();

    for ( h = 0, hl = holes.length; h < hl; h++ ) {

        ahole = holes[ h ];

        oneHoleMovements = [];

        for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++ ) {

            if ( j === il ) j = 0;
            if ( k === il ) k = 0;

            //  (j)---(i)---(k)
            oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

        }

        holesMovements.push( oneHoleMovements );
        verticesMovements = verticesMovements.concat( oneHoleMovements );

    }


    // Loop bevelSegments, 1 for the front, 1 for the back

    for ( b = 0; b < bevelSegments; b++ ) {

        //for ( b = bevelSegments; b > 0; b -- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );

        //z = bevelThickness * t;
        bs = bevelSize * ( Math.sin( t * Math.PI / 2 ) ); // curved
        //bs = bevelSize * t; // linear

        // contract shape

        for ( i = 0, il = contour.length; i < il; i++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

            v( vert.x, vert.y, -z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                v( vert.x, vert.y, -z );

            }

        }

    }

    bs = bevelSize;

    // Back facing vertices

    for ( i = 0; i < vlen; i++ ) {

        vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

        if ( !extrudeByPath ) {

            v( vert.x, vert.y, 0 );

        }
        else {

            // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

            normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
            binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

            position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

            v( position2.x, position2.y, position2.z );

        }

    }

    // Add stepped vertices...
    // Including front facing vertices

    var s;

    for ( s = 1; s <= steps; s++ ) {

        for ( i = 0; i < vlen; i++ ) {

            vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

            if ( !extrudeByPath ) {

                v( vert.x, vert.y, amount / steps * s );

            }
            else {

                // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
                binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

                position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

                v( position2.x, position2.y, position2.z );

            }

        }

    }


    // Add bevel segments planes

    //for ( b = 1; b <= bevelSegments; b ++ ) {
    for ( b = bevelSegments - 1; b >= 0; b-- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );
        //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
        bs = bevelSize * Math.sin( t * Math.PI / 2 );

        // contract shape

        for ( i = 0, il = contour.length; i < il; i++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
            v( vert.x, vert.y, amount + z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                if ( !extrudeByPath ) {

                    v( vert.x, vert.y, amount + z );

                }
                else {

                    v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

                }

            }

        }

    }

    /* Faces */

    // Top and bottom faces

    buildLidFaces();

    // Sides faces

    buildSideFaces();


    /////  Internal functions

    function buildLidFaces() {

        if ( bevelEnabled ) {

            var layer = 0; // steps + 1
            var offset = vlen * layer;

            // Bottom faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

            }

            layer = steps + bevelSegments * 2;
            offset = vlen * layer;

            // Top faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

            }

        }
        else {

            // Bottom faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 2 ], face[ 1 ], face[ 0 ] );

            }

            // Top faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

            }

        }

    }

    // Create faces for the z-sides of the shape

    function buildSideFaces() {

        var layeroffset = 0;
        sidewalls( contour, layeroffset );
        layeroffset += contour.length;

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            sidewalls( ahole, layeroffset );

            //, true
            layeroffset += ahole.length;

        }

    }

    function sidewalls( contour, layeroffset ) {

        var j, k;
        i = contour.length;

        while ( --i >= 0 ) {

            j = i;
            k = i - 1;
            if ( k < 0 ) k = contour.length - 1;

            //console.log('b', i,j, i-1, k,vertices.length);

            var s = 0,
                sl = steps + bevelSegments * 2;

            for ( s = 0; s < sl; s++ ) {

                var slen1 = vlen * s;
                var slen2 = vlen * ( s + 1 );

                var a = layeroffset + j + slen1,
                    b = layeroffset + k + slen1,
                    c = layeroffset + k + slen2,
                    d = layeroffset + j + slen2;

                f4( a, b, c, d, contour, s, sl, j, k );

            }

        }

    }


    function v( x, y, z ) {

        scope.vertices.push( new THREE.Vector3( x, y, z ) );

    }

    function f3( a, b, c ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, c ) );

        var uvs = uvgen.generateTopUV( scope, a, b, c );

        scope.faceVertexUvs[ 0 ].push( uvs );

    }

    function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, d ) );
        scope.faces.push( new THREE.Face3( b, c, d ) );

        var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

        scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
        scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

    generateTopUV: function( geometry, indexA, indexB, indexC ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];

        return [
            new THREE.Vector2( a.x, a.y ),
            new THREE.Vector2( b.x, b.y ),
            new THREE.Vector2( c.x, c.y )
        ];

    },

    generateSideWallUV: function( geometry, indexA, indexB, indexC, indexD ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];
        var d = vertices[ indexD ];

        if ( Math.abs( a.y - b.y ) < 0.01 ) {

            return [
                new THREE.Vector2( a.x, 1 - a.z ),
                new THREE.Vector2( b.x, 1 - b.z ),
                new THREE.Vector2( c.x, 1 - c.z ),
                new THREE.Vector2( d.x, 1 - d.z )
            ];

        }
        else {

            return [
                new THREE.Vector2( a.y, 1 - a.z ),
                new THREE.Vector2( b.y, 1 - b.z ),
                new THREE.Vector2( c.y, 1 - c.z ),
                new THREE.Vector2( d.y, 1 - d.z )
            ];

        }

    }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function( shapes, options ) {

    THREE.Geometry.call( this );

    this.type = 'ShapeGeometry';

    if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function( shapes, options ) {

    for ( var i = 0, l = shapes.length; i < l; i++ ) {

        this.addShape( shapes[ i ], options );

    }

    return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function( shape, options ) {

    if ( options === undefined ) options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    //

    var i, l, hole;

    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = !THREE.Shape.Utils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe...

        for ( i = 0, l = holes.length; i < l; i++ ) {

            hole = holes[ i ];

            if ( THREE.Shape.Utils.isClockWise( hole ) ) {

                holes[ i ] = hole.reverse();

            }

        }

        reverse = false;

    }

    var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

    // Vertices

    for ( i = 0, l = holes.length; i < l; i++ ) {

        hole = holes[ i ];
        vertices = vertices.concat( hole );

    }

    //

    var vert, vlen = vertices.length;
    var face, flen = faces.length;

    for ( i = 0; i < vlen; i++ ) {

        vert = vertices[ i ];

        this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

    }

    for ( i = 0; i < flen; i++ ) {

        face = faces[ i ];

        var a = face[ 0 ] + shapesOffset;
        var b = face[ 1 ] + shapesOffset;
        var c = face[ 2 ] + shapesOffset;

        this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
        this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function( points, segments, phiStart, phiLength ) {

    THREE.Geometry.call( this );

    this.type = 'LatheGeometry';

    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };

    segments = segments || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || 2 * Math.PI;

    var inversePointLength = 1.0 / ( points.length - 1 );
    var inverseSegments = 1.0 / segments;

    for ( var i = 0, il = segments; i <= il; i++ ) {

        var phi = phiStart + i * inverseSegments * phiLength;

        var c = Math.cos( phi ),
            s = Math.sin( phi );

        for ( var j = 0, jl = points.length; j < jl; j++ ) {

            var pt = points[ j ];

            var vertex = new THREE.Vector3();

            vertex.x = c * pt.x - s * pt.y;
            vertex.y = s * pt.x + c * pt.y;
            vertex.z = pt.z;

            this.vertices.push( vertex );

        }

    }

    var np = points.length;

    for ( var i = 0, il = segments; i < il; i++ ) {

        for ( var j = 0, jl = points.length - 1; j < jl; j++ ) {

            var base = j + np * i;
            var a = base;
            var b = base + np;
            var c = base + 1 + np;
            var d = base + 1;

            var u0 = i * inverseSegments;
            var v0 = j * inversePointLength;
            var u1 = u0 + inverseSegments;
            var v1 = v0 + inversePointLength;

            this.faces.push( new THREE.Face3( a, b, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u0, v0 ),
                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u0, v1 )

            ] );

            this.faces.push( new THREE.Face3( b, c, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u1, v1 ),
                new THREE.Vector2( u0, v1 )

            ] );


        }

    }

    this.mergeVertices();
    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function( width, height, widthSegments, heightSegments ) {

    THREE.Geometry.call( this );

    this.type = 'PlaneGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function() {

    var geometry = new THREE.PlaneGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.widthSegments,
        this.parameters.heightSegments
    );

    return geometry;

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function( width, height, widthSegments, heightSegments ) {

    THREE.BufferGeometry.call( this );

    this.type = 'PlaneBufferGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    var width_half = width / 2;
    var height_half = height / 2;

    var gridX = Math.floor( widthSegments ) || 1;
    var gridY = Math.floor( heightSegments ) || 1;

    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;

    var segment_width = width / gridX;
    var segment_height = height / gridY;

    var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    var normals = new Float32Array( gridX1 * gridY1 * 3 );
    var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    var offset = 0;
    var offset2 = 0;

    for ( var iy = 0; iy < gridY1; iy++ ) {

        var y = iy * segment_height - height_half;

        for ( var ix = 0; ix < gridX1; ix++ ) {

            var x = ix * segment_width - width_half;

            vertices[ offset ] = x;
            vertices[ offset + 1 ] = -y;

            normals[ offset + 2 ] = 1;

            uvs[ offset2 ] = ix / gridX;
            uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

            offset += 3;
            offset2 += 2;

        }

    }

    offset = 0;

    var indices = new( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    for ( var iy = 0; iy < gridY; iy++ ) {

        for ( var ix = 0; ix < gridX; ix++ ) {

            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * ( iy + 1 );
            var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
            var d = ( ix + 1 ) + gridX1 * iy;

            indices[ offset ] = a;
            indices[ offset + 1 ] = b;
            indices[ offset + 2 ] = d;

            indices[ offset + 3 ] = b;
            indices[ offset + 4 ] = c;
            indices[ offset + 5 ] = d;

            offset += 6;

        }

    }

    this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.PlaneBufferGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.widthSegments,
        this.parameters.heightSegments
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'RingGeometry';

    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    innerRadius = innerRadius || 0;
    outerRadius = outerRadius || 50;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

    var i, o, uvs = [],
        radius = innerRadius,
        radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

    for ( i = 0; i < phiSegments + 1; i++ ) {

        // concentric circles inside ring

        for ( o = 0; o < thetaSegments + 1; o++ ) {

            // number of segments per circle

            var vertex = new THREE.Vector3();
            var segment = thetaStart + o / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos( segment );
            vertex.y = radius * Math.sin( segment );

            this.vertices.push( vertex );
            uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

        }

        radius += radiusStep;

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 0; i < phiSegments; i++ ) {

        // concentric circles inside ring

        var thetaSegment = i * ( thetaSegments + 1 );

        for ( o = 0; o < thetaSegments; o++ ) {

            // number of segments per circle

            var segment = o + thetaSegment;

            var v1 = segment;
            var v2 = segment + thetaSegments + 1;
            var v3 = segment + thetaSegments + 2;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

            v1 = segment;
            v2 = segment + thetaSegments + 2;
            v3 = segment + 1;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

        }

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function() {

    var geometry = new THREE.RingGeometry(
        this.parameters.innerRadius,
        this.parameters.outerRadius,
        this.parameters.thetaSegments,
        this.parameters.phiSegments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'SphereGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function() {

    var geometry = new THREE.SphereGeometry(
        this.parameters.radius,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.phiStart,
        this.parameters.phiLength,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'SphereBufferGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;

    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    var thetaEnd = thetaStart + thetaLength;

    var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    var index = 0,
        vertices = [],
        normal = new THREE.Vector3();

    for ( var y = 0; y <= heightSegments; y++ ) {

        var verticesRow = [];

        var v = y / heightSegments;

        for ( var x = 0; x <= widthSegments; x++ ) {

            var u = x / widthSegments;

            var px = -radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
            var py = radius * Math.cos( thetaStart + v * thetaLength );
            var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

            normal.set( px, py, pz ).normalize();

            positions.setXYZ( index, px, py, pz );
            normals.setXYZ( index, normal.x, normal.y, normal.z );
            uvs.setXY( index, u, 1 - v );

            verticesRow.push( index );

            index++;

        }

        vertices.push( verticesRow );

    }

    var indices = [];

    for ( var y = 0; y < heightSegments; y++ ) {

        for ( var x = 0; x < widthSegments; x++ ) {

            var v1 = vertices[ y ][ x + 1 ];
            var v2 = vertices[ y ][ x ];
            var v3 = vertices[ y + 1 ][ x ];
            var v4 = vertices[ y + 1 ][ x + 1 ];

            if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
            if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

        }

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', positions );
    this.addAttribute( 'normal', normals );
    this.addAttribute( 'uv', uvs );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.SphereBufferGeometry(
        this.parameters.radius,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.phiStart,
        this.parameters.phiLength,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function( text, parameters ) {

    parameters = parameters || {};

    var textShapes = THREE.FontUtils.generateShapes( text, parameters );

    // translate parameters to ExtrudeGeometry API

    parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    // defaults

    if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    THREE.ExtrudeGeometry.call( this, textShapes, parameters );

    this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function( radius, tube, radialSegments, tubularSegments, arc ) {

    THREE.Geometry.call( this );

    this.type = 'TorusGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var center = new THREE.Vector3(),
        uvs = [],
        normals = [];

    for ( var j = 0; j <= radialSegments; j++ ) {

        for ( var i = 0; i <= tubularSegments; i++ ) {

            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            center.x = radius * Math.cos( u );
            center.y = radius * Math.sin( u );

            var vertex = new THREE.Vector3();
            vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            vertex.z = tube * Math.sin( v );

            this.vertices.push( vertex );

            uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
            normals.push( vertex.clone().sub( center ).normalize() );

        }

    }

    for ( var j = 1; j <= radialSegments; j++ ) {

        for ( var i = 1; i <= tubularSegments; i++ ) {

            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

            face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

        }

    }

    this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function() {

    var geometry = new THREE.TorusGeometry(
        this.parameters.radius,
        this.parameters.tube,
        this.parameters.radialSegments,
        this.parameters.tubularSegments,
        this.parameters.arc
    );

    return geometry;

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

    THREE.Geometry.call( this );

    this.type = 'TorusKnotGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 64;
    tubularSegments = tubularSegments || 8;
    p = p || 2;
    q = q || 3;
    heightScale = heightScale || 1;

    var grid = new Array( radialSegments );
    var tang = new THREE.Vector3();
    var n = new THREE.Vector3();
    var bitan = new THREE.Vector3();

    for ( var i = 0; i < radialSegments; ++i ) {

        grid[ i ] = new Array( tubularSegments );
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos( u, q, p, radius, heightScale );
        var p2 = getPos( u + 0.01, q, p, radius, heightScale );
        tang.subVectors( p2, p1 );
        n.addVectors( p2, p1 );

        bitan.crossVectors( tang, n );
        n.crossVectors( bitan, tang );
        bitan.normalize();
        n.normalize();

        for ( var j = 0; j < tubularSegments; ++j ) {

            var v = j / tubularSegments * 2 * Math.PI;
            var cx = -tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            var cy = tube * Math.sin( v );

            var pos = new THREE.Vector3();
            pos.x = p1.x + cx * n.x + cy * bitan.x;
            pos.y = p1.y + cx * n.y + cy * bitan.y;
            pos.z = p1.z + cx * n.z + cy * bitan.z;

            grid[ i ][ j ] = this.vertices.push( pos ) - 1;

        }

    }

    for ( var i = 0; i < radialSegments; ++i ) {

        for ( var j = 0; j < tubularSegments; ++j ) {

            var ip = ( i + 1 ) % radialSegments;
            var jp = ( j + 1 ) % tubularSegments;

            var a = grid[ i ][ j ];
            var b = grid[ ip ][ j ];
            var c = grid[ ip ][ jp ];
            var d = grid[ i ][ jp ];

            var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
            var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
            var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
            var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

    function getPos( u, in_q, in_p, radius, heightScale ) {

        var cu = Math.cos( u );
        var su = Math.sin( u );
        var quOverP = in_q / in_p * u;
        var cs = Math.cos( quOverP );

        var tx = radius * ( 2 + cs ) * 0.5 * cu;
        var ty = radius * ( 2 + cs ) * su * 0.5;
        var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

        return new THREE.Vector3( tx, ty, tz );

    }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function() {

    var geometry = new THREE.TorusKnotGeometry(
        this.parameters.radius,
        this.parameters.tube,
        this.parameters.radialSegments,
        this.parameters.tubularSegments,
        this.parameters.p,
        this.parameters.q,
        this.parameters.heightScale
    );

    return geometry;

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed, taper ) {

    THREE.Geometry.call( this );

    this.type = 'TubeGeometry';

    this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };

    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || THREE.TubeGeometry.NoTaper;

    var grid = [];

    var scope = this,

        tangent,
        normal,
        binormal,

        numpoints = segments + 1,

        u, v, r,

        cx, cy,
        pos, pos2 = new THREE.Vector3(),
        i, j,
        ip, jp,
        a, b, c, d,
        uva, uvb, uvc, uvd;

    var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
        tangents = frames.tangents,
        normals = frames.normals,
        binormals = frames.binormals;

    // proxy internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    function vert( x, y, z ) {

        return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

    }

    // construct the grid

    for ( i = 0; i < numpoints; i++ ) {

        grid[ i ] = [];

        u = i / ( numpoints - 1 );

        pos = path.getPointAt( u );

        tangent = tangents[ i ];
        normal = normals[ i ];
        binormal = binormals[ i ];

        r = radius * taper( u );

        for ( j = 0; j < radialSegments; j++ ) {

            v = j / radialSegments * 2 * Math.PI;

            cx = -r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            cy = r * Math.sin( v );

            pos2.copy( pos );
            pos2.x += cx * normal.x + cy * binormal.x;
            pos2.y += cx * normal.y + cy * binormal.y;
            pos2.z += cx * normal.z + cy * binormal.z;

            grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

        }

    }


    // construct the mesh

    for ( i = 0; i < segments; i++ ) {

        for ( j = 0; j < radialSegments; j++ ) {

            ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
            jp = ( j + 1 ) % radialSegments;

            a = grid[ i ][ j ]; // *** NOT NECESSARILY PLANAR ! ***
            b = grid[ ip ][ j ];
            c = grid[ ip ][ jp ];
            d = grid[ i ][ jp ];

            uva = new THREE.Vector2( i / segments, j / radialSegments );
            uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
            uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
            uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function( u ) {

    return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function( u ) {

    return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function( path, segments, closed ) {

    var normal = new THREE.Vector3(),

        tangents = [],
        normals = [],
        binormals = [],

        vec = new THREE.Vector3(),
        mat = new THREE.Matrix4(),

        numpoints = segments + 1,
        theta,
        epsilon = 0.0001,
        smallest,

        tx, ty, tz,
        i, u;


    // expose internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    // compute the tangent vectors for each segment on the path

    for ( i = 0; i < numpoints; i++ ) {

        u = i / ( numpoints - 1 );

        tangents[ i ] = path.getTangentAt( u );
        tangents[ i ].normalize();

    }

    initialNormal3();

    /*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

    function initialNormal3() {

        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the smallest tangent xyz component

        normals[ 0 ] = new THREE.Vector3();
        binormals[ 0 ] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs( tangents[ 0 ].x );
        ty = Math.abs( tangents[ 0 ].y );
        tz = Math.abs( tangents[ 0 ].z );

        if ( tx <= smallest ) {

            smallest = tx;
            normal.set( 1, 0, 0 );

        }

        if ( ty <= smallest ) {

            smallest = ty;
            normal.set( 0, 1, 0 );

        }

        if ( tz <= smallest ) {

            normal.set( 0, 0, 1 );

        }

        vec.crossVectors( tangents[ 0 ], normal ).normalize();

        normals[ 0 ].crossVectors( tangents[ 0 ], vec );
        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    }


    // compute the slowly-varying normal and binormal vectors for each segment on the path

    for ( i = 1; i < numpoints; i++ ) {

        normals[ i ] = normals[ i - 1 ].clone();

        binormals[ i ] = binormals[ i - 1 ].clone();

        vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

        if ( vec.length() > epsilon ) {

            vec.normalize();

            theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

            normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

        }

        binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }


    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    if ( closed ) {

        theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), -1, 1 ) );
        theta /= ( numpoints - 1 );

        if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

            theta = -theta;

        }

        for ( i = 1; i < numpoints; i++ ) {

            // twist a little...
            normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

        }

    }

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.PolyhedronGeometry = function( vertices, indices, radius, detail ) {

    THREE.Geometry.call( this );

    this.type = 'PolyhedronGeometry';

    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };

    radius = radius || 1;
    detail = detail || 0;

    var that = this;

    for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

        prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    }

    var p = this.vertices;

    var faces = [];

    for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j++ ) {

        var v1 = p[ indices[ i ] ];
        var v2 = p[ indices[ i + 1 ] ];
        var v3 = p[ indices[ i + 2 ] ];

        faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

    }

    var centroid = new THREE.Vector3();

    for ( var i = 0, l = faces.length; i < l; i++ ) {

        subdivide( faces[ i ], detail );

    }


    // Handle case when face straddles the seam

    for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i++ ) {

        var uvs = this.faceVertexUvs[ 0 ][ i ];

        var x0 = uvs[ 0 ].x;
        var x1 = uvs[ 1 ].x;
        var x2 = uvs[ 2 ].x;

        var max = Math.max( x0, Math.max( x1, x2 ) );
        var min = Math.min( x0, Math.min( x1, x2 ) );

        if ( max > 0.9 && min < 0.1 ) {

            // 0.9 is somewhat arbitrary

            if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
            if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
            if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

        }

    }


    // Apply radius

    for ( var i = 0, l = this.vertices.length; i < l; i++ ) {

        this.vertices[ i ].multiplyScalar( radius );

    }


    // Merge vertices

    this.mergeVertices();

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


    // Project vector onto sphere's surface

    function prepare( vector ) {

        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push( vertex ) - 1;

        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

        var u = azimuth( vector ) / 2 / Math.PI + 0.5;
        var v = inclination( vector ) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2( u, 1 - v );

        return vertex;

    }


    // Approximate a curved face with recursively sub-divided triangles.

    function make( v1, v2, v3, materialIndex ) {

        var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
        that.faces.push( face );

        centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

        var azi = azimuth( centroid );

        that.faceVertexUvs[ 0 ].push( [
            correctUV( v1.uv, v1, azi ),
            correctUV( v2.uv, v2, azi ),
            correctUV( v3.uv, v3, azi )
        ] );

    }


    // Analytically subdivide a face to the required detail level.

    function subdivide( face, detail ) {

        var cols = Math.pow( 2, detail );
        var a = prepare( that.vertices[ face.a ] );
        var b = prepare( that.vertices[ face.b ] );
        var c = prepare( that.vertices[ face.c ] );
        var v = [];

        var materialIndex = face.materialIndex;

        // Construct all of the vertices for this subdivision.

        for ( var i = 0; i <= cols; i++ ) {

            v[ i ] = [];

            var aj = prepare( a.clone().lerp( c, i / cols ) );
            var bj = prepare( b.clone().lerp( c, i / cols ) );
            var rows = cols - i;

            for ( var j = 0; j <= rows; j++ ) {

                if ( j === 0 && i === cols ) {

                    v[ i ][ j ] = aj;

                }
                else {

                    v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

                }

            }

        }

        // Construct all of the faces.

        for ( var i = 0; i < cols; i++ ) {

            for ( var j = 0; j < 2 * ( cols - i ) - 1; j++ ) {

                var k = Math.floor( j / 2 );

                if ( j % 2 === 0 ) {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        v[ i ][ k ],
                        materialIndex
                    );

                }
                else {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        materialIndex
                    );

                }

            }

        }

    }


    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth( vector ) {

        return Math.atan2( vector.z, -vector.x );

    }


    // Angle above the XZ plane.

    function inclination( vector ) {

        return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    }


    // Texture fixing helper. Spheres have some odd behaviours.

    function correctUV( uv, vector, azimuth ) {

        if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
        if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
        return uv.clone();

    }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function() {

    var geometry = new THREE.PolyhedronGeometry(
        this.parameters.vertices,
        this.parameters.indices,
        this.parameters.radius,
        this.parameters.detail
    );

    return geometry.copy( this );

};

THREE.PolyhedronGeometry.prototype.copy = function( source ) {

    THREE.Geometry.prototype.copy.call( this, source );
    return this;

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    var r = 1 / t;

    var vertices = [

        // (1, 1, 1)
        -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1,
        1, -1, -1, 1, -1, 1,
        1, 1, -1, 1, 1, 1,

        // (0, 1/, )
        0, -r, -t, 0, -r, t,
        0, r, -t, 0, r, t,

        // (1/, , 0)
        -r, -t, 0, -r, t, 0,
        r, -t, 0, r, t, 0,

        // (, 0, 1/)
        -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r
    ];

    var indices = [
        3, 11, 7, 3, 7, 15, 3, 15, 13,
        7, 19, 17, 7, 17, 6, 7, 6, 15,
        17, 4, 8, 17, 8, 10, 17, 10, 6,
        8, 0, 16, 8, 16, 2, 8, 2, 10,
        0, 12, 1, 0, 1, 18, 0, 18, 16,
        6, 10, 2, 6, 2, 13, 6, 13, 15,
        2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3,
        4, 14, 12, 4, 12, 0, 4, 0, 8,
        11, 9, 5, 11, 5, 19, 11, 19, 7,
        19, 5, 14, 19, 14, 4, 19, 4, 17,
        1, 12, 14, 1, 14, 5, 1, 5, 9
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'DodecahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.DodecahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
        0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
        t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
    ];

    var indices = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
        1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
        3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'IcosahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.IcosahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function( radius, detail ) {

    var vertices = [
        1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1
    ];

    var indices = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'OctahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.OctahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function( radius, detail ) {

    var vertices = [
        1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
    ];

    var indices = [
        2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'TetrahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.TetrahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function( func, slices, stacks ) {

    THREE.Geometry.call( this );

    this.type = 'ParametricGeometry';

    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };

    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[ 0 ];

    var i, j, p;
    var u, v;

    var sliceCount = slices + 1;

    for ( i = 0; i <= stacks; i++ ) {

        v = i / stacks;

        for ( j = 0; j <= slices; j++ ) {

            u = j / slices;

            p = func( u, v );
            verts.push( p );

        }

    }

    var a, b, c, d;
    var uva, uvb, uvc, uvd;

    for ( i = 0; i < stacks; i++ ) {

        for ( j = 0; j < slices; j++ ) {

            a = i * sliceCount + j;
            b = i * sliceCount + j + 1;
            c = ( i + 1 ) * sliceCount + j + 1;
            d = ( i + 1 ) * sliceCount + j;

            uva = new THREE.Vector2( j / slices, i / stacks );
            uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
            uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
            uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

            faces.push( new THREE.Face3( a, b, d ) );
            uvs.push( [ uva, uvb, uvd ] );

            faces.push( new THREE.Face3( b, c, d ) );
            uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    // console.log(this);

    // magic bullet
    // var diff = this.mergeVertices();
    // console.log('removed ', diff, ' vertices by merging');

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function( geometry ) {

    THREE.BufferGeometry.call( this );

    var edge = [ 0, 0 ],
        hash = {};
    var sortFunction = function( a, b ) {

        return a - b;

    };

    var keys = [ 'a', 'b', 'c' ];

    if ( geometry instanceof THREE.Geometry ) {

        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;

        // allocate maximal size
        var edges = new Uint32Array( 6 * faces.length );

        for ( var i = 0, l = faces.length; i < l; i++ ) {

            var face = faces[ i ];

            for ( var j = 0; j < 3; j++ ) {

                edge[ 0 ] = face[ keys[ j ] ];
                edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
                edge.sort( sortFunction );

                var key = edge.toString();

                if ( hash[ key ] === undefined ) {

                    edges[ 2 * numEdges ] = edge[ 0 ];
                    edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                    hash[ key ] = true;
                    numEdges++;

                }

            }

        }

        var coords = new Float32Array( numEdges * 2 * 3 );

        for ( var i = 0, l = numEdges; i < l; i++ ) {

            for ( var j = 0; j < 2; j++ ) {

                var vertex = vertices[ edges[ 2 * i + j ] ];

                var index = 6 * i + 3 * j;
                coords[ index + 0 ] = vertex.x;
                coords[ index + 1 ] = vertex.y;
                coords[ index + 2 ] = vertex.z;

            }

        }

        this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }
    else if ( geometry instanceof THREE.BufferGeometry ) {

        if ( geometry.index !== null ) {

            // Indexed BufferGeometry

            var indices = geometry.index.array;
            var vertices = geometry.attributes.position;
            var drawcalls = geometry.drawcalls;
            var numEdges = 0;

            if ( drawcalls.length === 0 ) {

                geometry.addDrawCall( 0, indices.length );

            }

            // allocate maximal size
            var edges = new Uint32Array( 2 * indices.length );

            for ( var o = 0, ol = drawcalls.length; o < ol; ++o ) {

                var drawcall = drawcalls[ o ];

                var start = drawcall.start;
                var count = drawcall.count;

                for ( var i = start, il = start + count; i < il; i += 3 ) {

                    for ( var j = 0; j < 3; j++ ) {

                        edge[ 0 ] = indices[ i + j ];
                        edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
                        edge.sort( sortFunction );

                        var key = edge.toString();

                        if ( hash[ key ] === undefined ) {

                            edges[ 2 * numEdges ] = edge[ 0 ];
                            edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                            hash[ key ] = true;
                            numEdges++;

                        }

                    }

                }

            }

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numEdges; i < l; i++ ) {

                for ( var j = 0; j < 2; j++ ) {

                    var index = 6 * i + 3 * j;
                    var index2 = edges[ 2 * i + j ];

                    coords[ index + 0 ] = vertices.getX( index2 );
                    coords[ index + 1 ] = vertices.getY( index2 );
                    coords[ index + 2 ] = vertices.getZ( index2 );

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }
        else {

            // non-indexed BufferGeometry

            var vertices = geometry.attributes.position.array;
            var numEdges = vertices.length / 3;
            var numTris = numEdges / 3;

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numTris; i < l; i++ ) {

                for ( var j = 0; j < 3; j++ ) {

                    var index = 18 * i + 6 * j;

                    var index1 = 9 * i + 3 * j;
                    coords[ index + 0 ] = vertices[ index1 ];
                    coords[ index + 1 ] = vertices[ index1 + 1 ];
                    coords[ index + 2 ] = vertices[ index1 + 2 ];

                    var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
                    coords[ index + 3 ] = vertices[ index2 ];
                    coords[ index + 4 ] = vertices[ index2 + 1 ];
                    coords[ index + 5 ] = vertices[ index2 + 2 ];

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }

    }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function( size ) {

    size = size || 1;

    var vertices = new Float32Array( [
        0, 0, 0, size, 0, 0,
        0, 0, 0, 0, size, 0,
        0, 0, 0, 0, 0, size
    ] );

    var colors = new Float32Array( [
        1, 0, 0, 1, 0.6, 0,
        0, 1, 0, 0.6, 1, 0,
        0, 0, 1, 0, 0.6, 1
    ] );

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors
    } );

    THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function() {

    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

    var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, -0.5, 0 );

    return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

        // dir is assumed to be normalized

        THREE.Object3D.call( this );

        if ( color === undefined ) color = 0xffff00;
        if ( length === undefined ) length = 1;
        if ( headLength === undefined ) headLength = 0.2 * length;
        if ( headWidth === undefined ) headWidth = 0.2 * headLength;

        this.position.copy( origin );

        if ( headLength < length ) {
            this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( {
                color: color
            } ) );
            this.line.matrixAutoUpdate = false;
            this.add( this.line );
        }

        this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( {
            color: color
        } ) );
        this.cone.matrixAutoUpdate = false;
        this.add( this.cone );

        this.setDirection( dir );
        this.setLength( length, headLength, headWidth );

    }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function() {

    var axis = new THREE.Vector3();
    var radians;

    return function setDirection( dir ) {

        // dir is assumed to be normalized

        if ( dir.y > 0.99999 ) {

            this.quaternion.set( 0, 0, 0, 1 );

        }
        else if ( dir.y < -0.99999 ) {

            this.quaternion.set( 1, 0, 0, 0 );

        }
        else {

            axis.set( dir.z, 0, -dir.x ).normalize();

            radians = Math.acos( dir.y );

            this.quaternion.setFromAxisAngle( axis, radians );

        }

    };

}() );

THREE.ArrowHelper.prototype.setLength = function( length, headLength, headWidth ) {

    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    if ( headLength < length ) {
        this.line.scale.set( 1, length - headLength, 1 );
        this.line.updateMatrix();
    }

    this.cone.scale.set( headWidth, headLength, headWidth );
    this.cone.position.y = length;
    this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function( color ) {

    if ( this.line !== undefined ) this.line.material.color.set( color );
    this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function( object ) {

    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    var positions = new Float32Array( 8 * 3 );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: 0xffff00
    } ) );

    if ( object !== undefined ) {

        this.update( object );

    }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function() {

    var box = new THREE.Box3();

    return function( object ) {

        box.setFromObject( object );

        if ( box.empty() ) return;

        var min = box.min;
        var max = box.max;

        /*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

        var position = this.geometry.attributes.position;
        var array = position.array;

        array[ 0 ] = max.x;
        array[ 1 ] = max.y;
        array[ 2 ] = max.z;
        array[ 3 ] = min.x;
        array[ 4 ] = max.y;
        array[ 5 ] = max.z;
        array[ 6 ] = min.x;
        array[ 7 ] = min.y;
        array[ 8 ] = max.z;
        array[ 9 ] = max.x;
        array[ 10 ] = min.y;
        array[ 11 ] = max.z;
        array[ 12 ] = max.x;
        array[ 13 ] = max.y;
        array[ 14 ] = min.z;
        array[ 15 ] = min.x;
        array[ 16 ] = max.y;
        array[ 17 ] = min.z;
        array[ 18 ] = min.x;
        array[ 19 ] = min.y;
        array[ 20 ] = min.z;
        array[ 21 ] = max.x;
        array[ 22 ] = min.y;
        array[ 23 ] = min.z;

        position.needsUpdate = true;

        this.geometry.computeBoundingSphere();

    }

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0x888888;

    this.object = object;

    this.box = new THREE.Box3();

    THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( {
        color: color,
        wireframe: true
    } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function() {

    this.box.setFromObject( this.object );

    this.box.size( this.scale );

    this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function( camera ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( {
        color: 0xffffff,
        vertexColors: THREE.FaceColors
    } );

    var pointMap = {};

    // colors

    var hexFrustum = 0xffaa00;
    var hexCone = 0xff0000;
    var hexUp = 0x00aaff;
    var hexTarget = 0xffffff;
    var hexCross = 0x333333;

    // near

    addLine( "n1", "n2", hexFrustum );
    addLine( "n2", "n4", hexFrustum );
    addLine( "n4", "n3", hexFrustum );
    addLine( "n3", "n1", hexFrustum );

    // far

    addLine( "f1", "f2", hexFrustum );
    addLine( "f2", "f4", hexFrustum );
    addLine( "f4", "f3", hexFrustum );
    addLine( "f3", "f1", hexFrustum );

    // sides

    addLine( "n1", "f1", hexFrustum );
    addLine( "n2", "f2", hexFrustum );
    addLine( "n3", "f3", hexFrustum );
    addLine( "n4", "f4", hexFrustum );

    // cone

    addLine( "p", "n1", hexCone );
    addLine( "p", "n2", hexCone );
    addLine( "p", "n3", hexCone );
    addLine( "p", "n4", hexCone );

    // up

    addLine( "u1", "u2", hexUp );
    addLine( "u2", "u3", hexUp );
    addLine( "u3", "u1", hexUp );

    // target

    addLine( "c", "t", hexTarget );
    addLine( "p", "c", hexCross );

    // cross

    addLine( "cn1", "cn2", hexCross );
    addLine( "cn3", "cn4", hexCross );

    addLine( "cf1", "cf2", hexCross );
    addLine( "cf3", "cf4", hexCross );

    function addLine( a, b, hex ) {

        addPoint( a, hex );
        addPoint( b, hex );

    }

    function addPoint( id, hex ) {

        geometry.vertices.push( new THREE.Vector3() );
        geometry.colors.push( new THREE.Color( hex ) );

        if ( pointMap[ id ] === undefined ) {

            pointMap[ id ] = [];

        }

        pointMap[ id ].push( geometry.vertices.length - 1 );

    }

    THREE.LineSegments.call( this, geometry, material );

    this.camera = camera;
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;

    this.pointMap = pointMap;

    this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function() {

    var geometry, pointMap;

    var vector = new THREE.Vector3();
    var camera = new THREE.Camera();

    var setPoint = function( point, x, y, z ) {

        vector.set( x, y, z ).unproject( camera );

        var points = pointMap[ point ];

        if ( points !== undefined ) {

            for ( var i = 0, il = points.length; i < il; i++ ) {

                geometry.vertices[ points[ i ] ].copy( vector );

            }

        }

    };

    return function() {

        geometry = this.geometry;
        pointMap = this.pointMap;

        var w = 1,
            h = 1;

        // we need just camera projection matrix
        // world matrix must be identity

        camera.projectionMatrix.copy( this.camera.projectionMatrix );

        // center / target

        setPoint( "c", 0, 0, -1 );
        setPoint( "t", 0, 0, 1 );

        // near

        setPoint( "n1", -w, -h, -1 );
        setPoint( "n2", w, -h, -1 );
        setPoint( "n3", -w, h, -1 );
        setPoint( "n4", w, h, -1 );

        // far

        setPoint( "f1", -w, -h, 1 );
        setPoint( "f2", w, -h, 1 );
        setPoint( "f3", -w, h, 1 );
        setPoint( "f4", w, h, 1 );

        // up

        setPoint( "u1", w * 0.7, h * 1.1, -1 );
        setPoint( "u2", -w * 0.7, h * 1.1, -1 );
        setPoint( "u3", 0, h * 2, -1 );

        // cross

        setPoint( "cf1", -w, 0, 1 );
        setPoint( "cf2", w, 0, 1 );
        setPoint( "cf3", 0, -h, 1 );
        setPoint( "cf4", 0, h, 1 );

        setPoint( "cn1", -w, 0, -1 );
        setPoint( "cn2", w, 0, -1 );
        setPoint( "cn3", 0, -h, -1 );
        setPoint( "cn4", 0, h, -1 );

        geometry.verticesNeedUpdate = true;

    };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function( light, size ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    size = size || 1;

    var geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3( -size, size, 0 ),
        new THREE.Vector3( size, size, 0 ),
        new THREE.Vector3( size, -size, 0 ),
        new THREE.Vector3( -size, -size, 0 ),
        new THREE.Vector3( -size, size, 0 )
    );

    var material = new THREE.LineBasicMaterial( {
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.lightPlane = new THREE.Line( geometry, material );
    this.add( this.lightPlane );

    geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3(),
        new THREE.Vector3()
    );

    material = new THREE.LineBasicMaterial( {
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine = new THREE.Line( geometry, material );
    this.add( this.targetLine );

    this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function() {

    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v3 = new THREE.Vector3();

    return function() {

        v1.setFromMatrixPosition( this.light.matrixWorld );
        v2.setFromMatrixPosition( this.light.target.matrixWorld );
        v3.subVectors( v2, v1 );

        this.lightPlane.lookAt( v3 );
        this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

        this.targetLine.geometry.vertices[ 1 ].copy( v3 );
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy( this.lightPlane.material.color );

    };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function( object, hex, thresholdAngle ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( {
        color: color
    } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.FaceNormalsHelper = function( object, size, hex, linewidth ) {

    // FaceNormalsHelper only supports THREE.Geometry

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length;

    }
    else {

        console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: color,
        linewidth: width
    } ) );

    //

    this.matrixAutoUpdate = false;
    this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        var vertices = objGeometry.vertices;

        var faces = objGeometry.faces;

        var idx = 0;

        for ( var i = 0, l = faces.length; i < l; i++ ) {

            var face = faces[ i ];

            var normal = face.normal;

            v1.copy( vertices[ face.a ] )
                .add( vertices[ face.b ] )
                .add( vertices[ face.c ] )
                .divideScalar( 3 )
                .applyMatrix4( matrixWorld );

            v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

            position.setXYZ( idx, v1.x, v1.y, v1.z );

            idx = idx + 1;

            position.setXYZ( idx, v2.x, v2.y, v2.z );

            idx = idx + 1;

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function( size, step ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors
    } );

    this.color1 = new THREE.Color( 0x444444 );
    this.color2 = new THREE.Color( 0x888888 );

    for ( var i = -size; i <= size; i += step ) {

        geometry.vertices.push(
            new THREE.Vector3( -size, 0, i ), new THREE.Vector3( size, 0, i ),
            new THREE.Vector3( i, 0, -size ), new THREE.Vector3( i, 0, size )
        );

        var color = i === 0 ? this.color1 : this.color2;

        geometry.colors.push( color, color, color, color );

    }

    THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

    this.color1.set( colorCenterLine );
    this.color2.set( colorGrid );

    this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function( light, sphereSize ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.colors = [ new THREE.Color(), new THREE.Color() ];

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    geometry.rotateX( -Math.PI / 2 );

    for ( var i = 0, il = 8; i < il; i++ ) {

        geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    }

    var material = new THREE.MeshBasicMaterial( {
        vertexColors: THREE.FaceColors,
        wireframe: true
    } );

    this.lightSphere = new THREE.Mesh( geometry, material );
    this.add( this.lightSphere );

    this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function() {

    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function() {

    var vector = new THREE.Vector3();

    return function() {

        this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
        this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

        this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
        this.lightSphere.geometry.colorsNeedUpdate = true;

    }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function( light, sphereSize ) {

    this.light = light;
    this.light.updateMatrixWorld();

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    var material = new THREE.MeshBasicMaterial( {
        wireframe: true,
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    THREE.Mesh.call( this, geometry, material );

    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;

    /*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function() {

    this.geometry.dispose();
    this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function() {

    this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    /*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function( object ) {

    this.bones = this.getBoneList( object );

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < this.bones.length; i++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            geometry.vertices.push( new THREE.Vector3() );
            geometry.vertices.push( new THREE.Vector3() );
            geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
            geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

        }

    }

    geometry.dynamic = true;

    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
    } );

    THREE.LineSegments.call( this, geometry, material );

    this.root = object;

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

    this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

    var boneList = [];

    if ( object instanceof THREE.Bone ) {

        boneList.push( object );

    }

    for ( var i = 0; i < object.children.length; i++ ) {

        boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    }

    return boneList;

};

THREE.SkeletonHelper.prototype.update = function() {

    var geometry = this.geometry;

    var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

    var boneMatrix = new THREE.Matrix4();

    var j = 0;

    for ( var i = 0; i < this.bones.length; i++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
            geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
            geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

            j += 2;

        }

    }

    geometry.verticesNeedUpdate = true;

    geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.SpotLightHelper = function( light ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

    geometry.translate( 0, -0.5, 0 );
    geometry.rotateX( -Math.PI / 2 );

    var material = new THREE.MeshBasicMaterial( {
        wireframe: true,
        fog: false
    } );

    this.cone = new THREE.Mesh( geometry, material );
    this.add( this.cone );

    this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function() {

    this.cone.geometry.dispose();
    this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function() {

    var vector = new THREE.Vector3();
    var vector2 = new THREE.Vector3();

    return function() {

        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan( this.light.angle );

        this.cone.scale.set( coneWidth, coneWidth, coneLength );

        vector.setFromMatrixPosition( this.light.matrixWorld );
        vector2.setFromMatrixPosition( this.light.target.matrixWorld );

        this.cone.lookAt( vector2.sub( vector ) );

        this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.VertexNormalsHelper = function( object, size, hex, linewidth ) {

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xff0000;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length * 3;

    }
    else if ( objGeometry instanceof THREE.BufferGeometry ) {

        nNormals = objGeometry.attributes.normal.count

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: color,
        linewidth: width
    } ) );

    //

    this.matrixAutoUpdate = false;

    this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        var keys = [ 'a', 'b', 'c' ];

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        if ( objGeometry instanceof THREE.Geometry ) {

            var vertices = objGeometry.vertices;

            var faces = objGeometry.faces;

            var idx = 0;

            for ( var i = 0, l = faces.length; i < l; i++ ) {

                var face = faces[ i ];

                for ( var j = 0, jl = face.vertexNormals.length; j < jl; j++ ) {

                    var vertex = vertices[ face[ keys[ j ] ] ];

                    var normal = face.vertexNormals[ j ];

                    v1.copy( vertex ).applyMatrix4( matrixWorld );

                    v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                    position.setXYZ( idx, v1.x, v1.y, v1.z );

                    idx = idx + 1;

                    position.setXYZ( idx, v2.x, v2.y, v2.z );

                    idx = idx + 1;

                }

            }

        }
        else if ( objGeometry instanceof THREE.BufferGeometry ) {

            var objPos = objGeometry.attributes.position;

            var objNorm = objGeometry.attributes.normal;

            var idx = 0;

            // for simplicity, ignore index and drawcalls, and render every normal

            for ( var j = 0, jl = objPos.count; j < jl; j++ ) {

                v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

                v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

                v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                position.setXYZ( idx, v1.x, v1.y, v1.z );

                idx = idx + 1;

                position.setXYZ( idx, v2.x, v2.y, v2.z );

                idx = idx + 1;

            }

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( {
        color: color
    } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function() {

    THREE.Object3D.call( this );

    this.render = function( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.animationsMap = {};
    this.animationsList = [];

    // prepare default animation
    // (all frames played together in 1 second)

    var numFrames = this.geometry.morphTargets.length;

    var name = "__default";

    var startFrame = 0;
    var endFrame = numFrames - 1;

    var fps = numFrames / 1;

    this.createAnimation( name, startFrame, endFrame, fps );
    this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function( name, start, end, fps ) {

    var animation = {

        start: start,
        end: end,

        length: end - start + 1,

        fps: fps,
        duration: ( end - start ) / fps,

        lastFrame: 0,
        currentFrame: 0,

        active: false,

        time: 0,
        direction: 1,
        weight: 1,

        directionBackwards: false,
        mirroredLoop: false

    };

    this.animationsMap[ name ] = animation;
    this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function( fps ) {

    var pattern = /([a-z]+)_?(\d+)/;

    var firstAnimation, frameRanges = {};

    var geometry = this.geometry;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i++ ) {

        var morph = geometry.morphTargets[ i ];
        var chunks = morph.name.match( pattern );

        if ( chunks && chunks.length > 1 ) {

            var name = chunks[ 1 ];

            if ( !frameRanges[ name ] ) frameRanges[ name ] = {
                start: Infinity,
                end: -Infinity
            };

            var range = frameRanges[ name ];

            if ( i < range.start ) range.start = i;
            if ( i > range.end ) range.end = i;

            if ( !firstAnimation ) firstAnimation = name;

        }

    }

    for ( var name in frameRanges ) {

        var range = frameRanges[ name ];
        this.createAnimation( name, range.start, range.end, fps );

    }

    this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = 1;
        animation.directionBackwards = false;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = -1;
        animation.directionBackwards = true;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function( name, fps ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.fps = fps;
        animation.duration = ( animation.end - animation.start ) / animation.fps;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function( name, duration ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.duration = duration;
        animation.fps = ( animation.end - animation.start ) / animation.duration;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function( name, weight ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.weight = weight;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function( name, time ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = time;

    }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function( name ) {

    var time = 0;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        time = animation.time;

    }

    return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function( name ) {

    var duration = -1;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        duration = animation.duration;

    }

    return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = 0;
        animation.active = true;

    }
    else {

        console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.active = false;

    }

};

THREE.MorphBlendMesh.prototype.update = function( delta ) {

    for ( var i = 0, il = this.animationsList.length; i < il; i++ ) {

        var animation = this.animationsList[ i ];

        if ( !animation.active ) continue;

        var frameTime = animation.duration / animation.length;

        animation.time += animation.direction * delta;

        if ( animation.mirroredLoop ) {

            if ( animation.time > animation.duration || animation.time < 0 ) {

                animation.direction *= -1;

                if ( animation.time > animation.duration ) {

                    animation.time = animation.duration;
                    animation.directionBackwards = true;

                }

                if ( animation.time < 0 ) {

                    animation.time = 0;
                    animation.directionBackwards = false;

                }

            }

        }
        else {

            animation.time = animation.time % animation.duration;

            if ( animation.time < 0 ) animation.time += animation.duration;

        }

        var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
        var weight = animation.weight;

        if ( keyframe !== animation.currentFrame ) {

            this.morphTargetInfluences[ animation.lastFrame ] = 0;
            this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

            this.morphTargetInfluences[ keyframe ] = 0;

            animation.lastFrame = animation.currentFrame;
            animation.currentFrame = keyframe;

        }

        var mix = ( animation.time % frameTime ) / frameTime;

        if ( animation.directionBackwards ) mix = 1 - mix;

        if ( animation.currentFrame !== animation.lastFrame ) {

            this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
            this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

        }
        else {

            this.morphTargetInfluences[ animation.currentFrame ] = weight;

        }

    }

};
},{}],"TextLayer":[function(require,module,exports){
var TextLayer, convertTextLayers, convertToTextLayer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

TextLayer = (function(superClass) {
  extend(TextLayer, superClass);

  function TextLayer(options) {
    if (options == null) {
      options = {};
    }
    this.doAutoSize = false;
    this.doAutoSizeHeight = false;
    if (options.backgroundColor == null) {
      options.backgroundColor = options.setup ? "hsla(60, 90%, 47%, .4)" : "transparent";
    }
    if (options.color == null) {
      options.color = "red";
    }
    if (options.lineHeight == null) {
      options.lineHeight = 1.25;
    }
    if (options.fontFamily == null) {
      options.fontFamily = "Helvetica";
    }
    if (options.fontSize == null) {
      options.fontSize = 20;
    }
    if (options.text == null) {
      options.text = "Use layer.text to add text";
    }
    TextLayer.__super__.constructor.call(this, options);
    this.style.whiteSpace = "pre-line";
    this.style.outline = "none";
  }

  TextLayer.prototype.setStyle = function(property, value, pxSuffix) {
    if (pxSuffix == null) {
      pxSuffix = false;
    }
    this.style[property] = pxSuffix ? value + "px" : value;
    this.emit("change:" + property, value);
    if (this.doAutoSize) {
      return this.calcSize();
    }
  };

  TextLayer.prototype.calcSize = function() {
    var constraints, size, sizeAffectingStyles;
    sizeAffectingStyles = {
      lineHeight: this.style["line-height"],
      fontSize: this.style["font-size"],
      fontWeight: this.style["font-weight"],
      paddingTop: this.style["padding-top"],
      paddingRight: this.style["padding-right"],
      paddingBottom: this.style["padding-bottom"],
      paddingLeft: this.style["padding-left"],
      textTransform: this.style["text-transform"],
      borderWidth: this.style["border-width"],
      letterSpacing: this.style["letter-spacing"],
      fontFamily: this.style["font-family"],
      fontStyle: this.style["font-style"],
      fontVariant: this.style["font-variant"]
    };
    constraints = {};
    if (this.doAutoSizeHeight) {
      constraints.width = this.width;
    }
    size = Utils.textSize(this.text, sizeAffectingStyles, constraints);
    if (this.style.textAlign === "right") {
      this.width = size.width;
      this.x = this.x - this.width;
    } else {
      this.width = size.width;
    }
    return this.height = size.height;
  };

  TextLayer.define("autoSize", {
    get: function() {
      return this.doAutoSize;
    },
    set: function(value) {
      this.doAutoSize = value;
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("autoSizeHeight", {
    set: function(value) {
      this.doAutoSize = value;
      this.doAutoSizeHeight = value;
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("contentEditable", {
    set: function(boolean) {
      this._element.contentEditable = boolean;
      this.ignoreEvents = !boolean;
      return this.on("input", function() {
        if (this.doAutoSize) {
          return this.calcSize();
        }
      });
    }
  });

  TextLayer.define("text", {
    get: function() {
      return this._element.textContent;
    },
    set: function(value) {
      this._element.textContent = value;
      this.emit("change:text", value);
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("fontFamily", {
    get: function() {
      return this.style.fontFamily;
    },
    set: function(value) {
      return this.setStyle("fontFamily", value);
    }
  });

  TextLayer.define("fontSize", {
    get: function() {
      return this.style.fontSize.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("fontSize", value, true);
    }
  });

  TextLayer.define("lineHeight", {
    get: function() {
      return this.style.lineHeight;
    },
    set: function(value) {
      return this.setStyle("lineHeight", value);
    }
  });

  TextLayer.define("fontWeight", {
    get: function() {
      return this.style.fontWeight;
    },
    set: function(value) {
      return this.setStyle("fontWeight", value);
    }
  });

  TextLayer.define("fontStyle", {
    get: function() {
      return this.style.fontStyle;
    },
    set: function(value) {
      return this.setStyle("fontStyle", value);
    }
  });

  TextLayer.define("fontVariant", {
    get: function() {
      return this.style.fontVariant;
    },
    set: function(value) {
      return this.setStyle("fontVariant", value);
    }
  });

  TextLayer.define("padding", {
    set: function(value) {
      this.setStyle("paddingTop", value, true);
      this.setStyle("paddingRight", value, true);
      this.setStyle("paddingBottom", value, true);
      return this.setStyle("paddingLeft", value, true);
    }
  });

  TextLayer.define("paddingTop", {
    get: function() {
      return this.style.paddingTop.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingTop", value, true);
    }
  });

  TextLayer.define("paddingRight", {
    get: function() {
      return this.style.paddingRight.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingRight", value, true);
    }
  });

  TextLayer.define("paddingBottom", {
    get: function() {
      return this.style.paddingBottom.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingBottom", value, true);
    }
  });

  TextLayer.define("paddingLeft", {
    get: function() {
      return this.style.paddingLeft.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingLeft", value, true);
    }
  });

  TextLayer.define("textAlign", {
    set: function(value) {
      return this.setStyle("textAlign", value);
    }
  });

  TextLayer.define("textTransform", {
    get: function() {
      return this.style.textTransform;
    },
    set: function(value) {
      return this.setStyle("textTransform", value);
    }
  });

  TextLayer.define("letterSpacing", {
    get: function() {
      return this.style.letterSpacing.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("letterSpacing", value, true);
    }
  });

  TextLayer.define("length", {
    get: function() {
      return this.text.length;
    }
  });

  return TextLayer;

})(Layer);

convertToTextLayer = function(layer, debug) {
  var css, key, styleObj, t, val;
  t = new TextLayer({
    name: layer.name,
    frame: layer.frame,
    parent: layer.parent,
    text: layer._info.metadata.string
  });
  styleObj = {};
  css = layer._info.metadata.css;
  css.forEach(function(rule) {
    var arr, prop, value;
    if (_.includes(rule, '/*')) {
      return;
    }
    arr = rule.split(': ');
    prop = _.camelCase(arr[0]);
    value = arr[1].replace(';', '');
    if (["fontSize", "letterSpacing", "lineHeight"].indexOf(prop) > -1) {
      value = parseInt(value);
    }
    return styleObj[prop] = value;
  });
  if (styleObj.hasOwnProperty("lineHeight")) {
    styleObj["lineHeight"] = styleObj.lineHeight / styleObj.fontSize;
  } else {
    styleObj["lineHeight"] = 1.3;
  }
  for (key in styleObj) {
    val = styleObj[key];
    t[key] = val;
  }
  t.y -= (t.fontSize / t.lineHeight) / (4 - t.lineHeight);
  t.x -= t.fontSize * 0.07;
  t.width += t.fontSize * 0.5;
  if (debug) {
    layer.opacity = .5;
  } else {
    layer.destroy();
  }
  return t;
};

Layer.prototype.convertToTextLayer = function(debug) {
  return convertToTextLayer(this, debug);
};

convertTextLayers = function(obj, debug) {
  var layer, prop, results;
  results = [];
  for (prop in obj) {
    layer = obj[prop];
    if (layer._info.kind === "text") {
      results.push(obj[prop] = convertToTextLayer(layer, debug));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

Layer.prototype.frameAsTextLayer = function(properties) {
  var t;
  t = new TextLayer;
  t.frame = this.frame;
  t.superLayer = this.superLayer;
  _.extend(t, properties);
  this.destroy();
  return t;
};

exports.TextLayer = TextLayer;

exports.convertTextLayers = convertTextLayers;


},{}],"myModule":[function(require,module,exports){
exports.myVar = "myVariable";

exports.myFunction = function() {
  return print("myFunction is running");
};

exports.myArray = [1, 2, 3];


},{}]},{},[])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWVyLm1vZHVsZXMuanMiLCJzb3VyY2VzIjpbIi4uL21vZHVsZXMvbXlNb2R1bGUuY29mZmVlIiwiLi4vbW9kdWxlcy9UZXh0TGF5ZXIuY29mZmVlIiwiLi4vbW9kdWxlcy9USFJFRS1yNzIuanMiLCIuLi9tb2R1bGVzL1NQRS5taW4uanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIiMgQWRkIHRoZSBmb2xsb3dpbmcgbGluZSB0byB5b3VyIHByb2plY3QgaW4gRnJhbWVyIFN0dWRpby4gXG4jIG15TW9kdWxlID0gcmVxdWlyZSBcIm15TW9kdWxlXCJcbiMgUmVmZXJlbmNlIHRoZSBjb250ZW50cyBieSBuYW1lLCBsaWtlIG15TW9kdWxlLm15RnVuY3Rpb24oKSBvciBteU1vZHVsZS5teVZhclxuXG5leHBvcnRzLm15VmFyID0gXCJteVZhcmlhYmxlXCJcblxuZXhwb3J0cy5teUZ1bmN0aW9uID0gLT5cblx0cHJpbnQgXCJteUZ1bmN0aW9uIGlzIHJ1bm5pbmdcIlxuXG5leHBvcnRzLm15QXJyYXkgPSBbMSwgMiwgM10iLCIjIFRPRE86IFJlbmFtZSB0aGlzIGNsYXNzIHNvIHRoZXJlIGFyZW4ndCBuYW1lc3BhY2UgY29uZmxpY3RzLlxuY2xhc3MgVGV4dExheWVyIGV4dGVuZHMgTGF5ZXJcblx0XHRcblx0Y29uc3RydWN0b3I6IChvcHRpb25zPXt9KSAtPlxuXHRcdEBkb0F1dG9TaXplID0gZmFsc2Vcblx0XHRAZG9BdXRvU2l6ZUhlaWdodCA9IGZhbHNlXG5cdFx0b3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgPz0gaWYgb3B0aW9ucy5zZXR1cCB0aGVuIFwiaHNsYSg2MCwgOTAlLCA0NyUsIC40KVwiIGVsc2UgXCJ0cmFuc3BhcmVudFwiXG5cdFx0b3B0aW9ucy5jb2xvciA/PSBcInJlZFwiXG5cdFx0b3B0aW9ucy5saW5lSGVpZ2h0ID89IDEuMjVcblx0XHRvcHRpb25zLmZvbnRGYW1pbHkgPz0gXCJIZWx2ZXRpY2FcIlxuXHRcdG9wdGlvbnMuZm9udFNpemUgPz0gMjBcblx0XHRvcHRpb25zLnRleHQgPz0gXCJVc2UgbGF5ZXIudGV4dCB0byBhZGQgdGV4dFwiXG5cdFx0c3VwZXIgb3B0aW9uc1xuXHRcdEBzdHlsZS53aGl0ZVNwYWNlID0gXCJwcmUtbGluZVwiICMgYWxsb3cgXFxuIGluIC50ZXh0XG5cdFx0QHN0eWxlLm91dGxpbmUgPSBcIm5vbmVcIiAjIG5vIGJvcmRlciB3aGVuIHNlbGVjdGVkXG5cdFx0XG5cdHNldFN0eWxlOiAocHJvcGVydHksIHZhbHVlLCBweFN1ZmZpeCA9IGZhbHNlKSAtPlxuXHRcdEBzdHlsZVtwcm9wZXJ0eV0gPSBpZiBweFN1ZmZpeCB0aGVuIHZhbHVlK1wicHhcIiBlbHNlIHZhbHVlXG5cdFx0QGVtaXQoXCJjaGFuZ2U6I3twcm9wZXJ0eX1cIiwgdmFsdWUpXG5cdFx0aWYgQGRvQXV0b1NpemUgdGhlbiBAY2FsY1NpemUoKVxuXHRcdFxuXHRjYWxjU2l6ZTogLT5cblx0XHRzaXplQWZmZWN0aW5nU3R5bGVzID1cblx0XHRcdGxpbmVIZWlnaHQ6IEBzdHlsZVtcImxpbmUtaGVpZ2h0XCJdXG5cdFx0XHRmb250U2l6ZTogQHN0eWxlW1wiZm9udC1zaXplXCJdXG5cdFx0XHRmb250V2VpZ2h0OiBAc3R5bGVbXCJmb250LXdlaWdodFwiXVxuXHRcdFx0cGFkZGluZ1RvcDogQHN0eWxlW1wicGFkZGluZy10b3BcIl1cblx0XHRcdHBhZGRpbmdSaWdodDogQHN0eWxlW1wicGFkZGluZy1yaWdodFwiXVxuXHRcdFx0cGFkZGluZ0JvdHRvbTogQHN0eWxlW1wicGFkZGluZy1ib3R0b21cIl1cblx0XHRcdHBhZGRpbmdMZWZ0OiBAc3R5bGVbXCJwYWRkaW5nLWxlZnRcIl1cblx0XHRcdHRleHRUcmFuc2Zvcm06IEBzdHlsZVtcInRleHQtdHJhbnNmb3JtXCJdXG5cdFx0XHRib3JkZXJXaWR0aDogQHN0eWxlW1wiYm9yZGVyLXdpZHRoXCJdXG5cdFx0XHRsZXR0ZXJTcGFjaW5nOiBAc3R5bGVbXCJsZXR0ZXItc3BhY2luZ1wiXVxuXHRcdFx0Zm9udEZhbWlseTogQHN0eWxlW1wiZm9udC1mYW1pbHlcIl1cblx0XHRcdGZvbnRTdHlsZTogQHN0eWxlW1wiZm9udC1zdHlsZVwiXVxuXHRcdFx0Zm9udFZhcmlhbnQ6IEBzdHlsZVtcImZvbnQtdmFyaWFudFwiXVxuXHRcdGNvbnN0cmFpbnRzID0ge31cblx0XHRpZiBAZG9BdXRvU2l6ZUhlaWdodCB0aGVuIGNvbnN0cmFpbnRzLndpZHRoID0gQHdpZHRoXG5cdFx0c2l6ZSA9IFV0aWxzLnRleHRTaXplIEB0ZXh0LCBzaXplQWZmZWN0aW5nU3R5bGVzLCBjb25zdHJhaW50c1xuXHRcdGlmIEBzdHlsZS50ZXh0QWxpZ24gaXMgXCJyaWdodFwiXG5cdFx0XHRAd2lkdGggPSBzaXplLndpZHRoXG5cdFx0XHRAeCA9IEB4LUB3aWR0aFxuXHRcdGVsc2Vcblx0XHRcdEB3aWR0aCA9IHNpemUud2lkdGhcblx0XHRAaGVpZ2h0ID0gc2l6ZS5oZWlnaHRcblxuXHRAZGVmaW5lIFwiYXV0b1NpemVcIixcblx0XHRnZXQ6IC0+IEBkb0F1dG9TaXplXG5cdFx0c2V0OiAodmFsdWUpIC0+IFxuXHRcdFx0QGRvQXV0b1NpemUgPSB2YWx1ZVxuXHRcdFx0aWYgQGRvQXV0b1NpemUgdGhlbiBAY2FsY1NpemUoKVxuXHRAZGVmaW5lIFwiYXV0b1NpemVIZWlnaHRcIixcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gXG5cdFx0XHRAZG9BdXRvU2l6ZSA9IHZhbHVlXG5cdFx0XHRAZG9BdXRvU2l6ZUhlaWdodCA9IHZhbHVlXG5cdFx0XHRpZiBAZG9BdXRvU2l6ZSB0aGVuIEBjYWxjU2l6ZSgpXG5cdEBkZWZpbmUgXCJjb250ZW50RWRpdGFibGVcIixcblx0XHRzZXQ6IChib29sZWFuKSAtPlxuXHRcdFx0QF9lbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IGJvb2xlYW5cblx0XHRcdEBpZ25vcmVFdmVudHMgPSAhYm9vbGVhblxuXHRcdFx0QG9uIFwiaW5wdXRcIiwgLT4gQGNhbGNTaXplKCkgaWYgQGRvQXV0b1NpemVcblx0QGRlZmluZSBcInRleHRcIixcblx0XHRnZXQ6IC0+IEBfZWxlbWVudC50ZXh0Q29udGVudFxuXHRcdHNldDogKHZhbHVlKSAtPlxuXHRcdFx0QF9lbGVtZW50LnRleHRDb250ZW50ID0gdmFsdWVcblx0XHRcdEBlbWl0KFwiY2hhbmdlOnRleHRcIiwgdmFsdWUpXG5cdFx0XHRpZiBAZG9BdXRvU2l6ZSB0aGVuIEBjYWxjU2l6ZSgpXG5cdEBkZWZpbmUgXCJmb250RmFtaWx5XCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLmZvbnRGYW1pbHlcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwiZm9udEZhbWlseVwiLCB2YWx1ZSlcblx0QGRlZmluZSBcImZvbnRTaXplXCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLmZvbnRTaXplLnJlcGxhY2UoXCJweFwiLFwiXCIpXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcImZvbnRTaXplXCIsIHZhbHVlLCB0cnVlKVxuXHRAZGVmaW5lIFwibGluZUhlaWdodFwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5saW5lSGVpZ2h0IFxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJsaW5lSGVpZ2h0XCIsIHZhbHVlKVxuXHRAZGVmaW5lIFwiZm9udFdlaWdodFwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5mb250V2VpZ2h0IFxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJmb250V2VpZ2h0XCIsIHZhbHVlKVxuXHRAZGVmaW5lIFwiZm9udFN0eWxlXCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLmZvbnRTdHlsZVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJmb250U3R5bGVcIiwgdmFsdWUpXG5cdEBkZWZpbmUgXCJmb250VmFyaWFudFwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5mb250VmFyaWFudFxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJmb250VmFyaWFudFwiLCB2YWx1ZSlcblx0QGRlZmluZSBcInBhZGRpbmdcIixcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gXG5cdFx0XHRAc2V0U3R5bGUoXCJwYWRkaW5nVG9wXCIsIHZhbHVlLCB0cnVlKVxuXHRcdFx0QHNldFN0eWxlKFwicGFkZGluZ1JpZ2h0XCIsIHZhbHVlLCB0cnVlKVxuXHRcdFx0QHNldFN0eWxlKFwicGFkZGluZ0JvdHRvbVwiLCB2YWx1ZSwgdHJ1ZSlcblx0XHRcdEBzZXRTdHlsZShcInBhZGRpbmdMZWZ0XCIsIHZhbHVlLCB0cnVlKVxuXHRAZGVmaW5lIFwicGFkZGluZ1RvcFwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5wYWRkaW5nVG9wLnJlcGxhY2UoXCJweFwiLFwiXCIpXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcInBhZGRpbmdUb3BcIiwgdmFsdWUsIHRydWUpXG5cdEBkZWZpbmUgXCJwYWRkaW5nUmlnaHRcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUucGFkZGluZ1JpZ2h0LnJlcGxhY2UoXCJweFwiLFwiXCIpXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcInBhZGRpbmdSaWdodFwiLCB2YWx1ZSwgdHJ1ZSlcblx0QGRlZmluZSBcInBhZGRpbmdCb3R0b21cIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUucGFkZGluZ0JvdHRvbS5yZXBsYWNlKFwicHhcIixcIlwiKVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJwYWRkaW5nQm90dG9tXCIsIHZhbHVlLCB0cnVlKVxuXHRAZGVmaW5lIFwicGFkZGluZ0xlZnRcIixcblx0XHRnZXQ6IC0+IEBzdHlsZS5wYWRkaW5nTGVmdC5yZXBsYWNlKFwicHhcIixcIlwiKVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJwYWRkaW5nTGVmdFwiLCB2YWx1ZSwgdHJ1ZSlcblx0QGRlZmluZSBcInRleHRBbGlnblwiLFxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJ0ZXh0QWxpZ25cIiwgdmFsdWUpXG5cdEBkZWZpbmUgXCJ0ZXh0VHJhbnNmb3JtXCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLnRleHRUcmFuc2Zvcm0gXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcInRleHRUcmFuc2Zvcm1cIiwgdmFsdWUpXG5cdEBkZWZpbmUgXCJsZXR0ZXJTcGFjaW5nXCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLmxldHRlclNwYWNpbmcucmVwbGFjZShcInB4XCIsXCJcIilcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwibGV0dGVyU3BhY2luZ1wiLCB2YWx1ZSwgdHJ1ZSlcblx0QGRlZmluZSBcImxlbmd0aFwiLCBcblx0XHRnZXQ6IC0+IEB0ZXh0Lmxlbmd0aFxuXG5jb252ZXJ0VG9UZXh0TGF5ZXIgPSAobGF5ZXIsIGRlYnVnKSAtPlxuXG5cdCMgQ3JlYXRlIGEgdGV4dCBsYXllciB3aXRoIGFsbCB0aGUgYmFzaWMgcHJvcGVydGllcy5cblx0dCA9IG5ldyBUZXh0TGF5ZXJcblx0XHRuYW1lOiBsYXllci5uYW1lXG5cdFx0ZnJhbWU6IGxheWVyLmZyYW1lXG5cdFx0cGFyZW50OiBsYXllci5wYXJlbnRcblx0XHR0ZXh0OiBsYXllci5faW5mby5tZXRhZGF0YS5zdHJpbmdcblxuXHQjIE9iamVjdCBmb3Igc3R5bGUgcHJvcHMuXG5cdHN0eWxlT2JqID0ge31cblx0XG5cdCMgR2V0IENTUyBmcm9tIG1ldGFkYXRhLlxuXHRjc3MgPSBsYXllci5faW5mby5tZXRhZGF0YS5jc3NcblxuXHQjIEdvIHRocm91Z2ggZWFjaCBydWxlXG5cdGNzcy5mb3JFYWNoIChydWxlKSAtPlxuXG5cdFx0IyBEaXRjaCB0aGUgZHVtYiBsYXllciBuYW1lLlxuXHRcdHJldHVybiBpZiBfLmluY2x1ZGVzIHJ1bGUsICcvKidcblx0XHRcblx0XHQjIFNwbGl0IHRoZSBrZXkgYW5kIHZhbHVlIG91dFxuXHRcdGFyciA9IHJ1bGUuc3BsaXQoJzogJylcblx0XHRcblx0XHQjRm9ybWF0IHRoZSBrZXkgYW5kIHZhbHVlIHByb3Blcmx5XG5cdFx0cHJvcCA9IF8uY2FtZWxDYXNlKGFyclswXSlcblx0XHR2YWx1ZSA9IGFyclsxXS5yZXBsYWNlKCc7JywnJylcblx0XHRcblx0XHQjQ29udmVydCB0byBudW1iZXJzIGZvciBudW1lcmljIHByb3BlcnRpZXNcblx0XHRpZiBbXCJmb250U2l6ZVwiLFwibGV0dGVyU3BhY2luZ1wiLFwibGluZUhlaWdodFwiXS5pbmRleE9mKHByb3ApID4gLTFcblx0XHRcdHZhbHVlID0gcGFyc2VJbnQodmFsdWUpIFxuXG5cdFx0IyBTZXQgdGhlIGtleSBhbmQgdmFsdWUgaW4gc3R5bGVPYmpcblx0XHRzdHlsZU9ialtwcm9wXSA9IHZhbHVlXG5cdFx0XG5cdCMgU2V0IHRoZSBsaW5lLWhlaWdodCBhcyBhIHByb3BvcnRpb24gaW5zdGVhZCBvZiBwaXhlbCB2YWx1ZS5cblx0aWYgc3R5bGVPYmouaGFzT3duUHJvcGVydHkoXCJsaW5lSGVpZ2h0XCIpXG5cdFx0c3R5bGVPYmpbXCJsaW5lSGVpZ2h0XCJdID0gIHN0eWxlT2JqLmxpbmVIZWlnaHQgLyBzdHlsZU9iai5mb250U2l6ZVxuXHRlbHNlXG5cdFx0c3R5bGVPYmpbXCJsaW5lSGVpZ2h0XCJdID0gMS4zXG4gXHRcdCMgVE9ETzogRmluZCBhIHdheSB0byBwcm9wZXJseSBzZXQgdGV4dCBsaW5lLWhlaWdodCBmb3IgYXV0byB2YWx1ZXMgaW4gU2tldGNoLlxuIFx0XHQjIEN1cnJlbnRseSBhdXRvIGxpbmUtaGVpZ2h0cyB2YXJ5IGJ5IGZvbnQsIHNvIHRoaXMgaXMganVzdCBzZXR0aW5nIGEgZmFsbGJhY2sgYXJiaXRyYXJpbHkuXG5cdFxuXHRcblx0IyBTZXQgdGhlIHByb3BlcnRpZXMgZm9yIGV2ZXJ5IGtleSBpbiBzdHlsZU9ialxuXHRmb3Iga2V5LCB2YWwgb2Ygc3R5bGVPYmpcblx0XHR0W2tleV0gPSB2YWxcblxuXHQjIE9mZnNldHMgdG8gY29tcGVuc2F0ZSBmb3IgU2tldGNoJ3MgcGFkZGluZy5cblx0dC55IC09ICh0LmZvbnRTaXplIC8gdC5saW5lSGVpZ2h0KSAvICg0IC0gdC5saW5lSGVpZ2h0KVxuXHR0LnggLT0gdC5mb250U2l6ZSAqIDAuMDdcblx0dC53aWR0aCArPSB0LmZvbnRTaXplICogMC41XG5cblx0IyBTZXQgdXAgZGVidWc6IGlmIHRydWUsIGl0IGRvZXNuJ3QgZGVzdHJveSB0aGUgbGF5ZXIgc28geW91IGNhblxuXHQjIG1hbnVhbGx5IHBvc2l0aW9uIGxpbmUtaGVpZ2h0IGFuZCBzdHVmZi4gIEhlbHBmdWwuXG5cdGlmIGRlYnVnIHRoZW4gbGF5ZXIub3BhY2l0eSA9IC41IGVsc2UgbGF5ZXIuZGVzdHJveSgpXG5cdFxuXHRyZXR1cm4gdFxuXG5MYXllcjo6Y29udmVydFRvVGV4dExheWVyID0gKGRlYnVnKSAtPiBjb252ZXJ0VG9UZXh0TGF5ZXIoQCwgZGVidWcpXG5cbmNvbnZlcnRUZXh0TGF5ZXJzID0gKG9iaiwgZGVidWcpIC0+XG5cdGZvciBwcm9wLGxheWVyIG9mIG9ialxuXHRcdGlmIGxheWVyLl9pbmZvLmtpbmQgaXMgXCJ0ZXh0XCJcblx0XHRcdG9ialtwcm9wXSA9IGNvbnZlcnRUb1RleHRMYXllcihsYXllciwgZGVidWcpXG5cblxuIyBCYWNrd2FyZHMgY29tcGFiaWxpdHkuIFJlcGxhY2VkIGJ5IGNvbnZlcnRUb1RleHRMYXllcigpXG5MYXllcjo6ZnJhbWVBc1RleHRMYXllciA9IChwcm9wZXJ0aWVzKSAtPlxuICAgIHQgPSBuZXcgVGV4dExheWVyXG4gICAgdC5mcmFtZSA9IEBmcmFtZVxuICAgIHQuc3VwZXJMYXllciA9IEBzdXBlckxheWVyXG4gICAgXy5leHRlbmQgdCxwcm9wZXJ0aWVzXG4gICAgQGRlc3Ryb3koKVxuICAgIHRcblxuZXhwb3J0cy5UZXh0TGF5ZXIgPSBUZXh0TGF5ZXJcbmV4cG9ydHMuY29udmVydFRleHRMYXllcnMgPSBjb252ZXJ0VGV4dExheWVyc1xuIiwiLy8gRmlsZTpzcmMvVGhyZWUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbnZhciBUSFJFRSA9IHtcbiAgICBSRVZJU0lPTjogJzcyJ1xufTtcblxuLy9cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cbiAgICBkZWZpbmUoICd0aHJlZScsIFRIUkVFICk7XG5cbn1cbmVsc2UgaWYgKCAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGV4cG9ydHMgJiYgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUgKSB7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRIUkVFO1xuXG59XG5cblxuLy8gcG9seWZpbGxzXG5cbmlmICggc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCB8fCBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAvLyBNaXNzaW5nIGluIEFuZHJvaWQgc3RvY2sgYnJvd3Nlci5cblxuICAgICggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICAgICAgdmFyIHZlbmRvcnMgPSBbICdtcycsICdtb3onLCAnd2Via2l0JywgJ28nIF07XG5cbiAgICAgICAgZm9yICggdmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3ggKSB7XG5cbiAgICAgICAgICAgIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gc2VsZlsgdmVuZG9yc1sgeCBdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcbiAgICAgICAgICAgIHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnIF0gfHwgc2VsZlsgdmVuZG9yc1sgeCBdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuc2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyVGltZSA9IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNlbGYuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xuXG4gICAgICAgICAgICAgICAgfSwgdGltZVRvQ2FsbCApO1xuICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgJiYgc2VsZi5jbGVhclRpbWVvdXQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBpZCApIHtcblxuICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KCBpZCApO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgIH0oKSApO1xuXG59XG5cbmlmICggTWF0aC5zaWduID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cblxuICAgIE1hdGguc2lnbiA9IGZ1bmN0aW9uKCB4ICkge1xuXG4gICAgICAgIHJldHVybiAoIHggPCAwICkgPyAtMSA6ICggeCA+IDAgKSA/IDEgOiAreDtcblxuICAgIH07XG5cbn1cblxuaWYgKCBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgLy8gTWlzc2luZyBpbiBJRTktMTEuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBGdW5jdGlvbi5wcm90b3R5cGUsICduYW1lJywge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvIClbIDEgXTtcblxuICAgICAgICB9XG5cbiAgICB9ICk7XG5cbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9uXG5cblRIUkVFLk1PVVNFID0ge1xuICAgIExFRlQ6IDAsXG4gICAgTUlERExFOiAxLFxuICAgIFJJR0hUOiAyXG59O1xuXG4vLyBHTCBTVEFURSBDT05TVEFOVFNcblxuVEhSRUUuQ3VsbEZhY2VOb25lID0gMDtcblRIUkVFLkN1bGxGYWNlQmFjayA9IDE7XG5USFJFRS5DdWxsRmFjZUZyb250ID0gMjtcblRIUkVFLkN1bGxGYWNlRnJvbnRCYWNrID0gMztcblxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSAwO1xuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcblxuLy8gU0hBRE9XSU5HIFRZUEVTXG5cblRIUkVFLkJhc2ljU2hhZG93TWFwID0gMDtcblRIUkVFLlBDRlNoYWRvd01hcCA9IDE7XG5USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwID0gMjtcblxuLy8gTUFURVJJQUwgQ09OU1RBTlRTXG5cbi8vIHNpZGVcblxuVEhSRUUuRnJvbnRTaWRlID0gMDtcblRIUkVFLkJhY2tTaWRlID0gMTtcblRIUkVFLkRvdWJsZVNpZGUgPSAyO1xuXG4vLyBzaGFkaW5nXG5cblRIUkVFLkZsYXRTaGFkaW5nID0gMTtcblRIUkVFLlNtb290aFNoYWRpbmcgPSAyO1xuXG4vLyBjb2xvcnNcblxuVEhSRUUuTm9Db2xvcnMgPSAwO1xuVEhSRUUuRmFjZUNvbG9ycyA9IDE7XG5USFJFRS5WZXJ0ZXhDb2xvcnMgPSAyO1xuXG4vLyBibGVuZGluZyBtb2Rlc1xuXG5USFJFRS5Ob0JsZW5kaW5nID0gMDtcblRIUkVFLk5vcm1hbEJsZW5kaW5nID0gMTtcblRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgPSAyO1xuVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XG5USFJFRS5NdWx0aXBseUJsZW5kaW5nID0gNDtcblRIUkVFLkN1c3RvbUJsZW5kaW5nID0gNTtcblxuLy8gY3VzdG9tIGJsZW5kaW5nIGVxdWF0aW9uc1xuLy8gKG51bWJlcnMgc3RhcnQgZnJvbSAxMDAgbm90IHRvIGNsYXNoIHdpdGggb3RoZXJcbi8vIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxuXG5USFJFRS5BZGRFcXVhdGlvbiA9IDEwMDtcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5USFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcblRIUkVFLk1pbkVxdWF0aW9uID0gMTAzO1xuVEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBkZXN0aW5hdGlvbiBmYWN0b3JzXG5cblRIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG5USFJFRS5PbmVGYWN0b3IgPSAyMDE7XG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcblRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcblRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBzb3VyY2UgZmFjdG9yc1xuXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG4vL1RIUkVFLk9uZUZhY3RvciA9IDIwMTtcbi8vVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG4vL1RIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xuLy9USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5USFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcblxuLy8gZGVwdGggbW9kZXNcblxuVEhSRUUuTmV2ZXJEZXB0aCA9IDA7XG5USFJFRS5BbHdheXNEZXB0aCA9IDE7XG5USFJFRS5MZXNzRGVwdGggPSAyO1xuVEhSRUUuTGVzc0VxdWFsRGVwdGggPSAzO1xuVEhSRUUuRXF1YWxEZXB0aCA9IDQ7XG5USFJFRS5HcmVhdGVyRXF1YWxEZXB0aCA9IDU7XG5USFJFRS5HcmVhdGVyRGVwdGggPSA2O1xuVEhSRUUuTm90RXF1YWxEZXB0aCA9IDc7XG5cblxuLy8gVEVYVFVSRSBDT05TVEFOVFNcblxuVEhSRUUuTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xuVEhSRUUuTWl4T3BlcmF0aW9uID0gMTtcblRIUkVFLkFkZE9wZXJhdGlvbiA9IDI7XG5cbi8vIE1hcHBpbmcgbW9kZXNcblxuVEhSRUUuVVZNYXBwaW5nID0gMzAwO1xuXG5USFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XG5cblRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XG5cblRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xuXG4vLyBXcmFwcGluZyBtb2Rlc1xuXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDEwMDA7XG5USFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcblRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xuXG4vLyBGaWx0ZXJzXG5cblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xuVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5USFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xuVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5USFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuXG4vLyBEYXRhIHR5cGVzXG5cblRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuVEhSRUUuQnl0ZVR5cGUgPSAxMDEwO1xuVEhSRUUuU2hvcnRUeXBlID0gMTAxMTtcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcblRIUkVFLkludFR5cGUgPSAxMDEzO1xuVEhSRUUuVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcblRIUkVFLkZsb2F0VHlwZSA9IDEwMTU7XG5USFJFRS5IYWxmRmxvYXRUeXBlID0gMTAyNTtcblxuLy8gUGl4ZWwgdHlwZXNcblxuLy9USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XG5USFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE3O1xuVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE4O1xuXG4vLyBQaXhlbCBmb3JtYXRzXG5cblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcblRIUkVFLlJHQkZvcm1hdCA9IDEwMjA7XG5USFJFRS5SR0JBRm9ybWF0ID0gMTAyMTtcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XG5USFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjM7XG4vLyBUSFJFRS5SR0JFRm9ybWF0IGhhbmRsZWQgYXMgVEhSRUUuUkdCQUZvcm1hdCBpbiBzaGFkZXJzXG5USFJFRS5SR0JFRm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDsgLy8xMDI0O1xuXG4vLyBERFMgLyBTVDNDIENvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXG5cblRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMTtcblRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDI7XG5USFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMjAwNDtcblxuXG4vLyBQVlJUQyBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xuXG5USFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XG5USFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDE7XG5USFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAyO1xuVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcblxuXG4vLyBERVBSRUNBVEVEXG5cblRIUkVFLlByb2plY3RvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XG5cbiAgICB0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IucHJvamVjdCgpLicgKTtcbiAgICAgICAgdmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xuXG4gICAgfTtcblxuICAgIHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24oIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnVucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IudW5wcm9qZWN0KCkuJyApO1xuICAgICAgICB2ZWN0b3IudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvcjogLnBpY2tpbmdSYXkoKSBpcyBub3cgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoKS4nICk7XG5cbiAgICB9O1xuXG59O1xuXG5USFJFRS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uKCkge307XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQ29sb3IuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNvbG9yID0gZnVuY3Rpb24oIGNvbG9yICkge1xuXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldFJHQiggYXJndW1lbnRzWyAwIF0sIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KCBjb2xvciApO1xuXG59O1xuXG5USFJFRS5Db2xvci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXG5cbiAgICByOiAxLFxuICAgIGc6IDEsXG4gICAgYjogMSxcblxuICAgIHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIGlmICggdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcblxuICAgICAgICAgICAgdGhpcy5jb3B5KCB2YWx1ZSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEhleDogZnVuY3Rpb24oIGhleCApIHtcblxuICAgICAgICBoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcblxuICAgICAgICB0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xuICAgICAgICB0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG4gICAgICAgIHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0UkdCOiBmdW5jdGlvbiggciwgZywgYiApIHtcblxuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLmcgPSBnO1xuICAgICAgICB0aGlzLmIgPSBiO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEhTTDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcblxuICAgICAgICAgICAgaWYgKCB0IDwgMCApIHQgKz0gMTtcbiAgICAgICAgICAgIGlmICggdCA+IDEgKSB0IC09IDE7XG4gICAgICAgICAgICBpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XG4gICAgICAgICAgICBpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuICAgICAgICAgICAgaWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggaCwgcywgbCApIHtcblxuICAgICAgICAgICAgLy8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcbiAgICAgICAgICAgIGggPSBUSFJFRS5NYXRoLmV1Y2xpZGVhbk1vZHVsbyggaCwgMSApO1xuICAgICAgICAgICAgcyA9IFRIUkVFLk1hdGguY2xhbXAoIHMsIDAsIDEgKTtcbiAgICAgICAgICAgIGwgPSBUSFJFRS5NYXRoLmNsYW1wKCBsLCAwLCAxICk7XG5cbiAgICAgICAgICAgIGlmICggcyA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcbiAgICAgICAgICAgICAgICB2YXIgcSA9ICggMiAqIGwgKSAtIHA7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBodWUycmdiKCBxLCBwLCBoICk7XG4gICAgICAgICAgICAgICAgdGhpcy5iID0gaHVlMnJnYiggcSwgcCwgaCAtIDEgLyAzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiggc3R5bGUgKSB7XG5cbiAgICAgICAgdmFyIHBhcnNlQWxwaGEgPSBmdW5jdGlvbiggc3RyQWxwaGEgKSB7XG5cbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQoIHN0ckFscGhhICk7XG5cbiAgICAgICAgICAgIGlmICggYWxwaGEgPCAxICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFscGhhO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBtO1xuXG4gICAgICAgIGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcblxuICAgICAgICAgICAgLy8gcmdiIC8gaHNsXG5cbiAgICAgICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbVsgMSBdO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIG5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJnYigyNTUsMCwwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMjU1O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmdiKDEwMCUsMCUsMCUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJnYmEoMjU1LDAsMCwwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUFscGhhKCBjb2xvclsgNCBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZ2JhKDEwMCUsMCUsMCUsMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VBbHBoYSggY29sb3JbIDQgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29sb3IgPSAvXihbMC05XSpcXC4/WzAtOV0rKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhzbCgxMjAsNTAlLDUwJSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gcGFyc2VGbG9hdCggY29sb3JbIDEgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEhTTCggaCwgcywgbCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbGEnOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29sb3IgPSAvXihbMC05XSpcXC4/WzAtOV0rKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQWxwaGEoIGNvbG9yWyA0IF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbSA9IC9eXFwjKFtBLUZhLWYwLTldKykkLy5leGVjKCBzdHlsZSApICkge1xuXG4gICAgICAgICAgICAvLyBoZXggY29sb3JcblxuICAgICAgICAgICAgdmFyIGhleCA9IG1bIDEgXTtcbiAgICAgICAgICAgIHZhciBzaXplID0gaGV4Lmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCBzaXplID09PSAzICkge1xuXG4gICAgICAgICAgICAgICAgLy8gI2ZmMFxuICAgICAgICAgICAgICAgIHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAwICksIDE2ICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICB0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMjU1O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gI2ZmMDAwMFxuICAgICAgICAgICAgICAgIHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICB0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAvLyBjb2xvciBrZXl3b3Jkc1xuICAgICAgICAgICAgdmFyIGhleCA9IFRIUkVFLkNvbG9yS2V5d29yZHNbIHN0eWxlIF07XG5cbiAgICAgICAgICAgIGlmICggaGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyByZWRcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhleCggaGV4ICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gdW5rbm93biBjb2xvclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICAgICAgdGhpcy5yID0gY29sb3IucjtcbiAgICAgICAgdGhpcy5nID0gY29sb3IuZztcbiAgICAgICAgdGhpcy5iID0gY29sb3IuYjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24oIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuICAgICAgICBpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcblxuICAgICAgICB0aGlzLnIgPSBNYXRoLnBvdyggY29sb3IuciwgZ2FtbWFGYWN0b3IgKTtcbiAgICAgICAgdGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XG4gICAgICAgIHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBnYW1tYUZhY3RvciApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG4gICAgICAgIGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG4gICAgICAgIHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XG5cbiAgICAgICAgdGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XG4gICAgICAgIHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBzYWZlSW52ZXJzZSApO1xuICAgICAgICB0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgc2FmZUludmVyc2UgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLnIsXG4gICAgICAgICAgICBnID0gdGhpcy5nLFxuICAgICAgICAgICAgYiA9IHRoaXMuYjtcblxuICAgICAgICB0aGlzLnIgPSByICogcjtcbiAgICAgICAgdGhpcy5nID0gZyAqIGc7XG4gICAgICAgIHRoaXMuYiA9IGIgKiBiO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbnZlcnRMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xuICAgICAgICB0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xuICAgICAgICB0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldEhleDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XG5cbiAgICB9LFxuXG4gICAgZ2V0SGV4U3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLTYgKTtcblxuICAgIH0sXG5cbiAgICBnZXRIU0w6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG4gICAgICAgIHZhciBoc2wgPSBvcHRpb25hbFRhcmdldCB8fCB7XG4gICAgICAgICAgICBoOiAwLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgIGw6IDBcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgciA9IHRoaXMucixcbiAgICAgICAgICAgIGcgPSB0aGlzLmcsXG4gICAgICAgICAgICBiID0gdGhpcy5iO1xuXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heCggciwgZywgYiApO1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuICAgICAgICB2YXIgaHVlLCBzYXR1cmF0aW9uO1xuICAgICAgICB2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcblxuICAgICAgICBpZiAoIG1pbiA9PT0gbWF4ICkge1xuXG4gICAgICAgICAgICBodWUgPSAwO1xuICAgICAgICAgICAgc2F0dXJhdGlvbiA9IDA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuXG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIG1heCApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgICAgICAgICAgaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgICAgICAgICBodWUgPSAoIGIgLSByICkgLyBkZWx0YSArIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgICAgICAgICAgaHVlID0gKCByIC0gZyApIC8gZGVsdGEgKyA0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBodWUgLz0gNjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaHNsLmggPSBodWU7XG4gICAgICAgIGhzbC5zID0gc2F0dXJhdGlvbjtcbiAgICAgICAgaHNsLmwgPSBsaWdodG5lc3M7XG5cbiAgICAgICAgcmV0dXJuIGhzbDtcblxuICAgIH0sXG5cbiAgICBnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICdyZ2IoJyArICggKCB0aGlzLnIgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmcgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmIgKiAyNTUgKSB8IDAgKSArICcpJztcblxuICAgIH0sXG5cbiAgICBvZmZzZXRIU0w6IGZ1bmN0aW9uKCBoLCBzLCBsICkge1xuXG4gICAgICAgIHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xuXG4gICAgICAgIGhzbC5oICs9IGg7XG4gICAgICAgIGhzbC5zICs9IHM7XG4gICAgICAgIGhzbC5sICs9IGw7XG5cbiAgICAgICAgdGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgICAgICB0aGlzLnIgKz0gY29sb3IucjtcbiAgICAgICAgdGhpcy5nICs9IGNvbG9yLmc7XG4gICAgICAgIHRoaXMuYiArPSBjb2xvci5iO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZENvbG9yczogZnVuY3Rpb24oIGNvbG9yMSwgY29sb3IyICkge1xuXG4gICAgICAgIHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XG4gICAgICAgIHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XG4gICAgICAgIHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnIgKz0gcztcbiAgICAgICAgdGhpcy5nICs9IHM7XG4gICAgICAgIHRoaXMuYiArPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICAgICAgdGhpcy5yICo9IGNvbG9yLnI7XG4gICAgICAgIHRoaXMuZyAqPSBjb2xvci5nO1xuICAgICAgICB0aGlzLmIgKj0gY29sb3IuYjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy5yICo9IHM7XG4gICAgICAgIHRoaXMuZyAqPSBzO1xuICAgICAgICB0aGlzLmIgKj0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsZXJwOiBmdW5jdGlvbiggY29sb3IsIGFscGhhICkge1xuXG4gICAgICAgIHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xuICAgICAgICB0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggYyApIHtcblxuICAgICAgICByZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cbiAgICAgICAgdGhpcy5yID0gYXJyYXlbIDAgXTtcbiAgICAgICAgdGhpcy5nID0gYXJyYXlbIDEgXTtcbiAgICAgICAgdGhpcy5iID0gYXJyYXlbIDIgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLnI7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Db2xvcktleXdvcmRzID0ge1xuICAgICdhbGljZWJsdWUnOiAweEYwRjhGRixcbiAgICAnYW50aXF1ZXdoaXRlJzogMHhGQUVCRDcsXG4gICAgJ2FxdWEnOiAweDAwRkZGRixcbiAgICAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LFxuICAgICdhenVyZSc6IDB4RjBGRkZGLFxuICAgICdiZWlnZSc6IDB4RjVGNURDLFxuICAgICdiaXNxdWUnOiAweEZGRTRDNCxcbiAgICAnYmxhY2snOiAweDAwMDAwMCxcbiAgICAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCxcbiAgICAnYmx1ZSc6IDB4MDAwMEZGLFxuICAgICdibHVldmlvbGV0JzogMHg4QTJCRTIsXG4gICAgJ2Jyb3duJzogMHhBNTJBMkEsXG4gICAgJ2J1cmx5d29vZCc6IDB4REVCODg3LFxuICAgICdjYWRldGJsdWUnOiAweDVGOUVBMCxcbiAgICAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLFxuICAgICdjaG9jb2xhdGUnOiAweEQyNjkxRSxcbiAgICAnY29yYWwnOiAweEZGN0Y1MCxcbiAgICAnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCxcbiAgICAnY29ybnNpbGsnOiAweEZGRjhEQyxcbiAgICAnY3JpbXNvbic6IDB4REMxNDNDLFxuICAgICdjeWFuJzogMHgwMEZGRkYsXG4gICAgJ2RhcmtibHVlJzogMHgwMDAwOEIsXG4gICAgJ2RhcmtjeWFuJzogMHgwMDhCOEIsXG4gICAgJ2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQixcbiAgICAnZGFya2dyYXknOiAweEE5QTlBOSxcbiAgICAnZGFya2dyZWVuJzogMHgwMDY0MDAsXG4gICAgJ2RhcmtncmV5JzogMHhBOUE5QTksXG4gICAgJ2RhcmtraGFraSc6IDB4QkRCNzZCLFxuICAgICdkYXJrbWFnZW50YSc6IDB4OEIwMDhCLFxuICAgICdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLFxuICAgICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsXG4gICAgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQyxcbiAgICAnZGFya3JlZCc6IDB4OEIwMDAwLFxuICAgICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsXG4gICAgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxuICAgICdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsXG4gICAgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RixcbiAgICAnZGFya3NsYXRlZ3JleSc6IDB4MkY0RjRGLFxuICAgICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsXG4gICAgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcbiAgICAnZGVlcHBpbmsnOiAweEZGMTQ5MyxcbiAgICAnZGVlcHNreWJsdWUnOiAweDAwQkZGRixcbiAgICAnZGltZ3JheSc6IDB4Njk2OTY5LFxuICAgICdkaW1ncmV5JzogMHg2OTY5NjksXG4gICAgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRixcbiAgICAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXG4gICAgJ2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsXG4gICAgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsXG4gICAgJ2Z1Y2hzaWEnOiAweEZGMDBGRixcbiAgICAnZ2FpbnNib3JvJzogMHhEQ0RDREMsXG4gICAgJ2dob3N0d2hpdGUnOiAweEY4RjhGRixcbiAgICAnZ29sZCc6IDB4RkZENzAwLFxuICAgICdnb2xkZW5yb2QnOiAweERBQTUyMCxcbiAgICAnZ3JheSc6IDB4ODA4MDgwLFxuICAgICdncmVlbic6IDB4MDA4MDAwLFxuICAgICdncmVlbnllbGxvdyc6IDB4QURGRjJGLFxuICAgICdncmV5JzogMHg4MDgwODAsXG4gICAgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsXG4gICAgJ2hvdHBpbmsnOiAweEZGNjlCNCxcbiAgICAnaW5kaWFucmVkJzogMHhDRDVDNUMsXG4gICAgJ2luZGlnbyc6IDB4NEIwMDgyLFxuICAgICdpdm9yeSc6IDB4RkZGRkYwLFxuICAgICdraGFraSc6IDB4RjBFNjhDLFxuICAgICdsYXZlbmRlcic6IDB4RTZFNkZBLFxuICAgICdsYXZlbmRlcmJsdXNoJzogMHhGRkYwRjUsXG4gICAgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuICAgICdsZW1vbmNoaWZmb24nOiAweEZGRkFDRCxcbiAgICAnbGlnaHRibHVlJzogMHhBREQ4RTYsXG4gICAgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCxcbiAgICAnbGlnaHRjeWFuJzogMHhFMEZGRkYsXG4gICAgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsXG4gICAgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxuICAgICdsaWdodGdyZWVuJzogMHg5MEVFOTAsXG4gICAgJ2xpZ2h0Z3JleSc6IDB4RDNEM0QzLFxuICAgICdsaWdodHBpbmsnOiAweEZGQjZDMSxcbiAgICAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSxcbiAgICAnbGlnaHRzZWFncmVlbic6IDB4MjBCMkFBLFxuICAgICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcbiAgICAnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSxcbiAgICAnbGlnaHRzbGF0ZWdyZXknOiAweDc3ODg5OSxcbiAgICAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSxcbiAgICAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCxcbiAgICAnbGltZSc6IDB4MDBGRjAwLFxuICAgICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcbiAgICAnbGluZW4nOiAweEZBRjBFNixcbiAgICAnbWFnZW50YSc6IDB4RkYwMEZGLFxuICAgICdtYXJvb24nOiAweDgwMDAwMCxcbiAgICAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLFxuICAgICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsXG4gICAgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxuICAgICdtZWRpdW1wdXJwbGUnOiAweDkzNzBEQixcbiAgICAnbWVkaXVtc2VhZ3JlZW4nOiAweDNDQjM3MSxcbiAgICAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsXG4gICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsXG4gICAgJ21lZGl1bXR1cnF1b2lzZSc6IDB4NDhEMUNDLFxuICAgICdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSxcbiAgICAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsXG4gICAgJ21pbnRjcmVhbSc6IDB4RjVGRkZBLFxuICAgICdtaXN0eXJvc2UnOiAweEZGRTRFMSxcbiAgICAnbW9jY2FzaW4nOiAweEZGRTRCNSxcbiAgICAnbmF2YWpvd2hpdGUnOiAweEZGREVBRCxcbiAgICAnbmF2eSc6IDB4MDAwMDgwLFxuICAgICdvbGRsYWNlJzogMHhGREY1RTYsXG4gICAgJ29saXZlJzogMHg4MDgwMDAsXG4gICAgJ29saXZlZHJhYic6IDB4NkI4RTIzLFxuICAgICdvcmFuZ2UnOiAweEZGQTUwMCxcbiAgICAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsXG4gICAgJ29yY2hpZCc6IDB4REE3MEQ2LFxuICAgICdwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsXG4gICAgJ3BhbGVncmVlbic6IDB4OThGQjk4LFxuICAgICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsXG4gICAgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MyxcbiAgICAncGFwYXlhd2hpcCc6IDB4RkZFRkQ1LFxuICAgICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcbiAgICAncGVydSc6IDB4Q0Q4NTNGLFxuICAgICdwaW5rJzogMHhGRkMwQ0IsXG4gICAgJ3BsdW0nOiAweEREQTBERCxcbiAgICAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LFxuICAgICdwdXJwbGUnOiAweDgwMDA4MCxcbiAgICAncmVkJzogMHhGRjAwMDAsXG4gICAgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxuICAgICdyb3lhbGJsdWUnOiAweDQxNjlFMSxcbiAgICAnc2FkZGxlYnJvd24nOiAweDhCNDUxMyxcbiAgICAnc2FsbW9uJzogMHhGQTgwNzIsXG4gICAgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCxcbiAgICAnc2VhZ3JlZW4nOiAweDJFOEI1NyxcbiAgICAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcbiAgICAnc2llbm5hJzogMHhBMDUyMkQsXG4gICAgJ3NpbHZlcic6IDB4QzBDMEMwLFxuICAgICdza3libHVlJzogMHg4N0NFRUIsXG4gICAgJ3NsYXRlYmx1ZSc6IDB4NkE1QUNELFxuICAgICdzbGF0ZWdyYXknOiAweDcwODA5MCxcbiAgICAnc2xhdGVncmV5JzogMHg3MDgwOTAsXG4gICAgJ3Nub3cnOiAweEZGRkFGQSxcbiAgICAnc3ByaW5nZ3JlZW4nOiAweDAwRkY3RixcbiAgICAnc3RlZWxibHVlJzogMHg0NjgyQjQsXG4gICAgJ3Rhbic6IDB4RDJCNDhDLFxuICAgICd0ZWFsJzogMHgwMDgwODAsXG4gICAgJ3RoaXN0bGUnOiAweEQ4QkZEOCxcbiAgICAndG9tYXRvJzogMHhGRjYzNDcsXG4gICAgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuICAgICd2aW9sZXQnOiAweEVFODJFRSxcbiAgICAnd2hlYXQnOiAweEY1REVCMyxcbiAgICAnd2hpdGUnOiAweEZGRkZGRixcbiAgICAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LFxuICAgICd5ZWxsb3cnOiAweEZGRkYwMCxcbiAgICAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMlxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9RdWF0ZXJuaW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiggeCwgeSwgeiwgdyApIHtcblxuICAgIHRoaXMuX3ggPSB4IHx8IDA7XG4gICAgdGhpcy5feSA9IHkgfHwgMDtcbiAgICB0aGlzLl96ID0geiB8fCAwO1xuICAgIHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlF1YXRlcm5pb24sXG5cbiAgICBnZXQgeCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5feDtcblxuICAgIH0sXG5cbiAgICBzZXQgeCggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBnZXQgeSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5feTtcblxuICAgIH0sXG5cbiAgICBzZXQgeSggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBnZXQgeigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fejtcblxuICAgIH0sXG5cbiAgICBzZXQgeiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5feiA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBnZXQgdygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdztcblxuICAgIH0sXG5cbiAgICBzZXQgdyggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5fdyA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgdGhpcy5feiA9IHo7XG4gICAgICAgIHRoaXMuX3cgPSB3O1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggcXVhdGVybmlvbiApIHtcblxuICAgICAgICB0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuICAgICAgICB0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuICAgICAgICB0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuICAgICAgICB0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21FdWxlcjogZnVuY3Rpb24oIGV1bGVyLCB1cGRhdGUgKSB7XG5cbiAgICAgICAgaWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cbiAgICAgICAgLy8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cbiAgICAgICAgLy9cdGNvbnRlbnQvU3BpbkNhbGMubVxuXG4gICAgICAgIHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcbiAgICAgICAgdmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xuICAgICAgICB2YXIgYzMgPSBNYXRoLmNvcyggZXVsZXIuX3ogLyAyICk7XG4gICAgICAgIHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcbiAgICAgICAgdmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xuICAgICAgICB2YXIgczMgPSBNYXRoLnNpbiggZXVsZXIuX3ogLyAyICk7XG5cbiAgICAgICAgdmFyIG9yZGVyID0gZXVsZXIub3JkZXI7XG5cbiAgICAgICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24oIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuICAgICAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG4gICAgICAgIHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG4gICAgICAgIHRoaXMuX3ggPSBheGlzLnggKiBzO1xuICAgICAgICB0aGlzLl95ID0gYXhpcy55ICogcztcbiAgICAgICAgdGhpcy5feiA9IGF4aXMueiAqIHM7XG4gICAgICAgIHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICAgICAgdmFyIHRlID0gbS5lbGVtZW50cyxcblxuICAgICAgICAgICAgbTExID0gdGVbIDAgXSxcbiAgICAgICAgICAgIG0xMiA9IHRlWyA0IF0sXG4gICAgICAgICAgICBtMTMgPSB0ZVsgOCBdLFxuICAgICAgICAgICAgbTIxID0gdGVbIDEgXSxcbiAgICAgICAgICAgIG0yMiA9IHRlWyA1IF0sXG4gICAgICAgICAgICBtMjMgPSB0ZVsgOSBdLFxuICAgICAgICAgICAgbTMxID0gdGVbIDIgXSxcbiAgICAgICAgICAgIG0zMiA9IHRlWyA2IF0sXG4gICAgICAgICAgICBtMzMgPSB0ZVsgMTAgXSxcblxuICAgICAgICAgICAgdHJhY2UgPSBtMTEgKyBtMjIgKyBtMzMsXG4gICAgICAgICAgICBzO1xuXG4gICAgICAgIGlmICggdHJhY2UgPiAwICkge1xuXG4gICAgICAgICAgICBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG4gICAgICAgICAgICB0aGlzLl93ID0gMC4yNSAvIHM7XG4gICAgICAgICAgICB0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG4gICAgICAgICAgICB0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG4gICAgICAgICAgICB0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcblxuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcbiAgICAgICAgICAgIHRoaXMuX3ggPSAwLjI1ICogcztcbiAgICAgICAgICAgIHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcbiAgICAgICAgICAgIHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG4gICAgICAgICAgICB0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG4gICAgICAgICAgICB0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG4gICAgICAgICAgICB0aGlzLl95ID0gMC4yNSAqIHM7XG4gICAgICAgICAgICB0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICAgICAgICAgIHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcbiAgICAgICAgICAgIHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwLjI1ICogcztcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBodHRwOi8vbG9sZW5naW5lLm5ldC9ibG9nLzIwMTQvMDIvMjQvcXVhdGVybmlvbi1mcm9tLXR3by12ZWN0b3JzLWZpbmFsXG5cbiAgICAgICAgLy8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cbiAgICAgICAgdmFyIHYxLCByO1xuXG4gICAgICAgIHZhciBFUFMgPSAwLjAwMDAwMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHZGcm9tLCB2VG8gKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xuXG4gICAgICAgICAgICBpZiAoIHIgPCBFUFMgKSB7XG5cbiAgICAgICAgICAgICAgICByID0gMDtcblxuICAgICAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdjEuc2V0KCAtdkZyb20ueSwgdkZyb20ueCwgMCApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHYxLnNldCggMCwgLXZGcm9tLnosIHZGcm9tLnkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2MS5jcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl94ID0gdjEueDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSB2MS55O1xuICAgICAgICAgICAgdGhpcy5feiA9IHYxLno7XG4gICAgICAgICAgICB0aGlzLl93ID0gcjtcblxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgfSgpLFxuXG4gICAgaW52ZXJzZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb25qdWdhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuX3ggKj0gLTE7XG4gICAgICAgIHRoaXMuX3kgKj0gLTE7XG4gICAgICAgIHRoaXMuX3ogKj0gLTE7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZG90OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblxuICAgIH0sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKCBsID09PSAwICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICAgICAgdGhpcy5feiA9IDA7XG4gICAgICAgICAgICB0aGlzLl93ID0gMTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBsID0gMSAvIGw7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLl94ICogbDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl95ICogbDtcbiAgICAgICAgICAgIHRoaXMuX3ogPSB0aGlzLl96ICogbDtcbiAgICAgICAgICAgIHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKCBxLCBwICkge1xuXG4gICAgICAgIGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCBwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblxuICAgICAgICB2YXIgcWF4ID0gYS5feCxcbiAgICAgICAgICAgIHFheSA9IGEuX3ksXG4gICAgICAgICAgICBxYXogPSBhLl96LFxuICAgICAgICAgICAgcWF3ID0gYS5fdztcbiAgICAgICAgdmFyIHFieCA9IGIuX3gsXG4gICAgICAgICAgICBxYnkgPSBiLl95LFxuICAgICAgICAgICAgcWJ6ID0gYi5feixcbiAgICAgICAgICAgIHFidyA9IGIuX3c7XG5cbiAgICAgICAgdGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcbiAgICAgICAgdGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcbiAgICAgICAgdGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcbiAgICAgICAgdGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIHNsZXJwOiBmdW5jdGlvbiggcWIsIHQgKSB7XG5cbiAgICAgICAgaWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgICAgICB6ID0gdGhpcy5feixcbiAgICAgICAgICAgIHcgPSB0aGlzLl93O1xuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cbiAgICAgICAgdmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcblxuICAgICAgICBpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3cgPSAtcWIuX3c7XG4gICAgICAgICAgICB0aGlzLl94ID0gLXFiLl94O1xuICAgICAgICAgICAgdGhpcy5feSA9IC1xYi5feTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSAtcWIuX3o7XG5cbiAgICAgICAgICAgIGNvc0hhbGZUaGV0YSA9IC1jb3NIYWxmVGhldGE7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5jb3B5KCBxYiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3cgPSB3O1xuICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSB6O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XG4gICAgICAgIHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG4gICAgICAgIGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XG4gICAgICAgICAgICB0aGlzLl94ID0gMC41ICogKCB4ICsgdGhpcy5feCApO1xuICAgICAgICAgICAgdGhpcy5feSA9IDAuNSAqICggeSArIHRoaXMuX3kgKTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuICAgICAgICAgICAgcmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuICAgICAgICB0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xuICAgICAgICB0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuICAgICAgICB0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuICAgICAgICB0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHF1YXRlcm5pb24gKSB7XG5cbiAgICAgICAgcmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICAgICAgdGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgICAgIHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuICAgICAgICB0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICBvbkNoYW5nZTogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge31cblxufTtcblxuVEhSRUUuUXVhdGVybmlvbi5zbGVycCA9IGZ1bmN0aW9uKCBxYSwgcWIsIHFtLCB0ICkge1xuXG4gICAgcmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yMi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5USFJFRS5WZWN0b3IyID0gZnVuY3Rpb24oIHgsIHkgKSB7XG5cbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuXG59O1xuXG5USFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggeCwgeSApIHtcblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFg6IGZ1bmN0aW9uKCB4ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WTogZnVuY3Rpb24oIHkgKSB7XG5cbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55ICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgICAgdGhpcy55ICs9IHYueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMueCArPSBzO1xuICAgICAgICB0aGlzLnkgKz0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB0aGlzLnggPSBhLnggKyBiLng7XG4gICAgICAgIHRoaXMueSA9IGEueSArIGIueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uKCB2LCBzICkge1xuXG4gICAgICAgIHRoaXMueCArPSB2LnggKiBzO1xuICAgICAgICB0aGlzLnkgKz0gdi55ICogcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWI6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YlNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy54IC09IHM7XG4gICAgICAgIHRoaXMueSAtPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YlZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB0aGlzLnggKj0gdi54O1xuICAgICAgICB0aGlzLnkgKj0gdi55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnggKj0gcztcbiAgICAgICAgdGhpcy55ICo9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGl2aWRlOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB0aGlzLnggLz0gdi54O1xuICAgICAgICB0aGlzLnkgLz0gdi55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24oIHNjYWxhciApIHtcblxuICAgICAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgICAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICAgICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGlmICggdGhpcy54ID4gdi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55ID4gdi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHYueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IHYueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xhbXA6IGZ1bmN0aW9uKCBtaW4sIG1heCApIHtcblxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgICAgIGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IG1pbi54O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSBtYXgueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gbWluLnk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IG1heC55O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbGFtcFNjYWxhcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1pbiwgbWF4O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cbiAgICAgICAgICAgIGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICAgICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwgKTtcbiAgICAgICAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBmbG9vcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNlaWw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICByb3VuZFRvWmVybzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICAgICAgdGhpcy55ID0gLXRoaXMueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkb3Q6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuICAgIH0sXG5cbiAgICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdi54LFxuICAgICAgICAgICAgZHkgPSB0aGlzLnkgLSB2Lnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgIH0sXG5cbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uKCBsICkge1xuXG4gICAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcblxuICAgICAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsZXJwOiBmdW5jdGlvbiggdiwgYWxwaGEgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsZXJwVmVjdG9yczogZnVuY3Rpb24oIHYxLCB2MiwgYWxwaGEgKSB7XG5cbiAgICAgICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICAgICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgICAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiggeCwgeSwgeiApIHtcblxuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgdGhpcy56ID0geiB8fCAwO1xuXG59O1xuXG5USFJFRS5WZWN0b3IzLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IzLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggeCwgeSwgeiApIHtcblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFg6IGZ1bmN0aW9uKCB4ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WTogZnVuY3Rpb24oIHkgKSB7XG5cbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRaOiBmdW5jdGlvbiggeiApIHtcblxuICAgICAgICB0aGlzLnogPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24oIGluZGV4LCB2YWx1ZSApIHtcblxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMueiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICAgIHRoaXMueiA9IHYuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgICB0aGlzLnogKz0gdi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHM7XG4gICAgICAgIHRoaXMueSArPSBzO1xuICAgICAgICB0aGlzLnogKz0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB0aGlzLnggPSBhLnggKyBiLng7XG4gICAgICAgIHRoaXMueSA9IGEueSArIGIueTtcbiAgICAgICAgdGhpcy56ID0gYS56ICsgYi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24oIHYsIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHYueCAqIHM7XG4gICAgICAgIHRoaXMueSArPSB2LnkgKiBzO1xuICAgICAgICB0aGlzLnogKz0gdi56ICogcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWI6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuICAgICAgICB0aGlzLnogLT0gdi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YlNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy54IC09IHM7XG4gICAgICAgIHRoaXMueSAtPSBzO1xuICAgICAgICB0aGlzLnogLT0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWJWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcbiAgICAgICAgdGhpcy56ID0gYS56IC0gYi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgICAgdGhpcy56ICo9IHYuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24oIHNjYWxhciApIHtcblxuICAgICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgICAgICB0aGlzLnogKj0gc2NhbGFyO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gYS54ICogYi54O1xuICAgICAgICB0aGlzLnkgPSBhLnkgKiBiLnk7XG4gICAgICAgIHRoaXMueiA9IGEueiAqIGIuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhcHBseUV1bGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcXVhdGVybmlvbjtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XG5cbiAgICAgICAgICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgYXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGFwcGx5TWF0cml4MzogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuICAgICAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG4gICAgICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblxuICAgICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgICAgICB6ID0gdGhpcy56O1xuXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdO1xuICAgICAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdO1xuICAgICAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IHByb2plY3Rpb24gbWF0cml4XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICAgICAgeiA9IHRoaXMuejtcblxuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG4gICAgICAgIHZhciBkID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXG5cbiAgICAgICAgdGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICkgKiBkO1xuICAgICAgICB0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKSAqIGQ7XG4gICAgICAgIHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIGQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiggcSApIHtcblxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgICAgIHZhciBxeCA9IHEueDtcbiAgICAgICAgdmFyIHF5ID0gcS55O1xuICAgICAgICB2YXIgcXogPSBxLno7XG4gICAgICAgIHZhciBxdyA9IHEudztcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG4gICAgICAgIHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgICAgICAgdmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICAgICAgICB2YXIgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gICAgICAgIHZhciBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gICAgICAgIHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgICAgIHRoaXMueSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgICAgIHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hdHJpeDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xuXG4gICAgICAgICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHVucHJvamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hdHJpeDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cbiAgICAgICAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkLCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKSApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG4gICAgICAgIC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG4gICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgeSA9IHRoaXMueSxcbiAgICAgICAgICAgIHogPSB0aGlzLno7XG5cbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcbiAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xuICAgICAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG4gICAgICAgIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGl2aWRlOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB0aGlzLnggLz0gdi54O1xuICAgICAgICB0aGlzLnkgLz0gdi55O1xuICAgICAgICB0aGlzLnogLz0gdi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24oIHNjYWxhciApIHtcblxuICAgICAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgICAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICAgICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuICAgICAgICAgICAgdGhpcy56ICo9IGludlNjYWxhcjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgICAgIHRoaXMueiA9IDA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1pbjogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPiB2LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHYueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IHYueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnogPiB2LnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IHYuejtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBpZiAoIHRoaXMueCA8IHYueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA8IHYueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueiA8IHYueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbGFtcDogZnVuY3Rpb24oIG1pbiwgbWF4ICkge1xuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gbWluLng7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IG1heC54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSBtaW4ueTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gbWF4Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy56IDwgbWluLnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IG1pbi56O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueiA+IG1heC56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSBtYXguejtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xhbXBTY2FsYXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtaW4sIG1heDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICAgICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcbiAgICAgICAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGZsb29yOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNlaWw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmRUb1plcm86IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbmVnYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgICB0aGlzLnogPSAtdGhpcy56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRvdDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuICAgIH0sXG5cbiAgICBsZW5ndGhTcTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuICAgIH0sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG4gICAgfSxcblxuICAgIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuICAgIH0sXG5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gICAgfSxcblxuICAgIHNldExlbmd0aDogZnVuY3Rpb24oIGwgKSB7XG5cbiAgICAgICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICkge1xuXG4gICAgICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxlcnA6IGZ1bmN0aW9uKCB2LCBhbHBoYSApIHtcblxuICAgICAgICB0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgICAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuICAgICAgICB0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxlcnBWZWN0b3JzOiBmdW5jdGlvbiggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgICAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjcm9zczogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgeSA9IHRoaXMueSxcbiAgICAgICAgICAgIHogPSB0aGlzLno7XG5cbiAgICAgICAgdGhpcy54ID0geSAqIHYueiAtIHogKiB2Lnk7XG4gICAgICAgIHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xuICAgICAgICB0aGlzLnogPSB4ICogdi55IC0geSAqIHYueDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHZhciBheCA9IGEueCxcbiAgICAgICAgICAgIGF5ID0gYS55LFxuICAgICAgICAgICAgYXogPSBhLno7XG4gICAgICAgIHZhciBieCA9IGIueCxcbiAgICAgICAgICAgIGJ5ID0gYi55LFxuICAgICAgICAgICAgYnogPSBiLno7XG5cbiAgICAgICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgICAgIHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgICAgICB0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSwgZG90O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwcm9qZWN0T25WZWN0b3IoIHZlY3RvciApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgZG90ID0gdGhpcy5kb3QoIHYxICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcHkoIHYxICkubXVsdGlwbHlTY2FsYXIoIGRvdCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdjEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKCB2MSApO1xuXG4gICAgICAgIH1cblxuICAgIH0oKSxcblxuICAgIHJlZmxlY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuICAgICAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWZsZWN0KCBub3JtYWwgKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSgpLFxuXG4gICAgYW5nbGVUbzogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggdGhpcy5sZW5ndGgoKSAqIHYubGVuZ3RoKCkgKTtcblxuICAgICAgICAvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRoZXRhLCAtMSwgMSApICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHZhciBkeCA9IHRoaXMueCAtIHYueDtcbiAgICAgICAgdmFyIGR5ID0gdGhpcy55IC0gdi55O1xuICAgICAgICB2YXIgZHogPSB0aGlzLnogLSB2Lno7XG5cbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuICAgIH0sXG5cbiAgICBzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24oIG0sIG9yZGVyICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgaW5zdGVhZC4nICk7XG5cbiAgICB9LFxuXG4gICAgc2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24oIHEsIG9yZGVyICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xuXG4gICAgfSxcblxuICAgIGdldFBvc2l0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKTtcblxuICAgIH0sXG5cbiAgICBnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRnJvbU1hdHJpeDogZnVuY3Rpb24oIGluZGV4LCBtYXRyaXggKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuJyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIGluZGV4LCBtYXRyaXggKTtcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XG4gICAgICAgIHRoaXMueSA9IG0uZWxlbWVudHNbIDEzIF07XG4gICAgICAgIHRoaXMueiA9IG0uZWxlbWVudHNbIDE0IF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbU1hdHJpeFNjYWxlOiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB2YXIgc3ggPSB0aGlzLnNldCggbS5lbGVtZW50c1sgMCBdLCBtLmVsZW1lbnRzWyAxIF0sIG0uZWxlbWVudHNbIDIgXSApLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1sgNCBdLCBtLmVsZW1lbnRzWyA1IF0sIG0uZWxlbWVudHNbIDYgXSApLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ogPSB0aGlzLnNldCggbS5lbGVtZW50c1sgOCBdLCBtLmVsZW1lbnRzWyA5IF0sIG0uZWxlbWVudHNbIDEwIF0gKS5sZW5ndGgoKTtcblxuICAgICAgICB0aGlzLnggPSBzeDtcbiAgICAgICAgdGhpcy55ID0gc3k7XG4gICAgICAgIHRoaXMueiA9IHN6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uKCBpbmRleCwgbWF0cml4ICkge1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBpbmRleCAqIDQ7XG5cbiAgICAgICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICAgIHRoaXMueCA9IG1lWyBvZmZzZXQgXTtcbiAgICAgICAgdGhpcy55ID0gbWVbIG9mZnNldCArIDEgXTtcbiAgICAgICAgdGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICAgICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgICAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuICAgICAgICB0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjQuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuVmVjdG9yNCA9IGZ1bmN0aW9uKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgdGhpcy54ID0geCB8fCAwO1xuICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICB0aGlzLnogPSB6IHx8IDA7XG4gICAgdGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG59O1xuXG5USFJFRS5WZWN0b3I0LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3I0LFxuXG4gICAgc2V0OiBmdW5jdGlvbiggeCwgeSwgeiwgdyApIHtcblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICB0aGlzLncgPSB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFg6IGZ1bmN0aW9uKCB4ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WTogZnVuY3Rpb24oIHkgKSB7XG5cbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRaOiBmdW5jdGlvbiggeiApIHtcblxuICAgICAgICB0aGlzLnogPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFc6IGZ1bmN0aW9uKCB3ICkge1xuXG4gICAgICAgIHRoaXMudyA9IHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiggaW5kZXgsIHZhbHVlICkge1xuXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy56ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy53ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLno7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICAgIHRoaXMueiA9IHYuejtcbiAgICAgICAgdGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgICB0aGlzLnogKz0gdi56O1xuICAgICAgICB0aGlzLncgKz0gdi53O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHM7XG4gICAgICAgIHRoaXMueSArPSBzO1xuICAgICAgICB0aGlzLnogKz0gcztcbiAgICAgICAgdGhpcy53ICs9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkVmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xuICAgICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG4gICAgICAgIHRoaXMueiA9IGEueiArIGIuejtcbiAgICAgICAgdGhpcy53ID0gYS53ICsgYi53O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24oIHYsIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHYueCAqIHM7XG4gICAgICAgIHRoaXMueSArPSB2LnkgKiBzO1xuICAgICAgICB0aGlzLnogKz0gdi56ICogcztcbiAgICAgICAgdGhpcy53ICs9IHYudyAqIHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViOiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgICAgdGhpcy55IC09IHYueTtcbiAgICAgICAgdGhpcy56IC09IHYuejtcbiAgICAgICAgdGhpcy53IC09IHYudztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWJTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMueCAtPSBzO1xuICAgICAgICB0aGlzLnkgLT0gcztcbiAgICAgICAgdGhpcy56IC09IHM7XG4gICAgICAgIHRoaXMudyAtPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YlZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xuICAgICAgICB0aGlzLnogPSBhLnogLSBiLno7XG4gICAgICAgIHRoaXMudyA9IGEudyAtIGIudztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24oIHNjYWxhciApIHtcblxuICAgICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgICAgICB0aGlzLnogKj0gc2NhbGFyO1xuICAgICAgICB0aGlzLncgKj0gc2NhbGFyO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB2YXIgeiA9IHRoaXMuejtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xuICAgICAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcbiAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xuICAgICAgICB0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiggc2NhbGFyICkge1xuXG4gICAgICAgIGlmICggc2NhbGFyICE9PSAwICkge1xuXG4gICAgICAgICAgICB2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuICAgICAgICAgICAgdGhpcy54ICo9IGludlNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueSAqPSBpbnZTY2FsYXI7XG4gICAgICAgICAgICB0aGlzLnogKj0gaW52U2NhbGFyO1xuICAgICAgICAgICAgdGhpcy53ICo9IGludlNjYWxhcjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgICAgIHRoaXMueiA9IDA7XG4gICAgICAgICAgICB0aGlzLncgPSAxO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24oIHEgKSB7XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgICAgIC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICAgICAgdGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XG5cbiAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcblxuICAgICAgICBpZiAoIHMgPCAwLjAwMDEgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IDE7XG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgdGhpcy56ID0gMDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLnggPSBxLnggLyBzO1xuICAgICAgICAgICAgdGhpcy55ID0gcS55IC8gcztcbiAgICAgICAgICAgIHRoaXMueiA9IHEueiAvIHM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXG5cbiAgICAgICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgICAgICB2YXIgYW5nbGUsIHgsIHksIHosIC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XG4gICAgICAgICAgICBlcHNpbG9uID0gMC4wMSwgLy8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcbiAgICAgICAgICAgIGVwc2lsb24yID0gMC4xLCAvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xuXG4gICAgICAgICAgICB0ZSA9IG0uZWxlbWVudHMsXG5cbiAgICAgICAgICAgIG0xMSA9IHRlWyAwIF0sXG4gICAgICAgICAgICBtMTIgPSB0ZVsgNCBdLFxuICAgICAgICAgICAgbTEzID0gdGVbIDggXSxcbiAgICAgICAgICAgIG0yMSA9IHRlWyAxIF0sXG4gICAgICAgICAgICBtMjIgPSB0ZVsgNSBdLFxuICAgICAgICAgICAgbTIzID0gdGVbIDkgXSxcbiAgICAgICAgICAgIG0zMSA9IHRlWyAyIF0sXG4gICAgICAgICAgICBtMzIgPSB0ZVsgNiBdLFxuICAgICAgICAgICAgbTMzID0gdGVbIDEwIF07XG5cbiAgICAgICAgaWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKSAmJiAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKSAmJiAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcblxuICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgZm91bmRcbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcbiAgICAgICAgICAgIC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcblxuICAgICAgICAgICAgaWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yICkgJiYgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApICYmICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKSAmJiAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldCggMSwgMCwgMCwgMCApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcblxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLlBJO1xuXG4gICAgICAgICAgICB2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XG4gICAgICAgICAgICB2YXIgeXkgPSAoIG0yMiArIDEgKSAvIDI7XG4gICAgICAgICAgICB2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XG4gICAgICAgICAgICB2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcbiAgICAgICAgICAgIHZhciB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xuICAgICAgICAgICAgdmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XG5cbiAgICAgICAgICAgIGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG4gICAgICAgICAgICAgICAgaWYgKCB4eCA8IGVwc2lsb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICAgICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLnNxcnQoIHh4ICk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4eSAvIHg7XG4gICAgICAgICAgICAgICAgICAgIHogPSB4eiAvIHg7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCB5eSA+IHp6ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuICAgICAgICAgICAgICAgIGlmICggeXkgPCBlcHNpbG9uICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHggPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHogPSAwLjcwNzEwNjc4MTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5zcXJ0KCB5eSApO1xuICAgICAgICAgICAgICAgICAgICB4ID0geHkgLyB5O1xuICAgICAgICAgICAgICAgICAgICB6ID0geXogLyB5O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblxuICAgICAgICAgICAgICAgIGlmICggenogPCBlcHNpbG9uICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHggPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgICAgICAgICAgICB6ID0gMDtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB6ID0gTWF0aC5zcXJ0KCB6eiApO1xuICAgICAgICAgICAgICAgICAgICB4ID0geHogLyB6O1xuICAgICAgICAgICAgICAgICAgICB5ID0geXogLyB6O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG4gICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKSArICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICsgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcblxuICAgICAgICBpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xuXG4gICAgICAgIC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcbiAgICAgICAgLy8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXG5cbiAgICAgICAgdGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG4gICAgICAgIHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xuICAgICAgICB0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICAgICAgdGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGlmICggdGhpcy54ID4gdi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55ID4gdi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy56ID4gdi56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy53ID4gdi53ICkge1xuXG4gICAgICAgICAgICB0aGlzLncgPSB2Lnc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHYueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IHYueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnogPCB2LnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IHYuejtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLncgPCB2LncgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudyA9IHYudztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xhbXA6IGZ1bmN0aW9uKCBtaW4sIG1heCApIHtcblxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgICAgIGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IG1pbi54O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSBtYXgueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gbWluLnk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IG1heC55O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueiA8IG1pbi56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSBtaW4uejtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gbWF4Lno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy53IDwgbWluLncgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudyA9IG1pbi53O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMudyA+IG1heC53ICkge1xuXG4gICAgICAgICAgICB0aGlzLncgPSBtYXgudztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xhbXBTY2FsYXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtaW4sIG1heDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICAgICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbWluID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcbiAgICAgICAgICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuICAgICAgICAgICAgbWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBmbG9vcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcbiAgICAgICAgdGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2VpbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcbiAgICAgICAgdGhpcy53ID0gTWF0aC5jZWlsKCB0aGlzLncgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcbiAgICAgICAgdGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmRUb1plcm86IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgICAgIHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICAgICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcbiAgICAgICAgdGhpcy53ID0gLXRoaXMudztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkb3Q6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuICAgIH0sXG5cbiAgICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIH0sXG5cbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uKCBsICkge1xuXG4gICAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcblxuICAgICAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsZXJwOiBmdW5jdGlvbiggdiwgYWxwaGEgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsZXJwVmVjdG9yczogZnVuY3Rpb24oIHYxLCB2MiwgYWxwaGEgKSB7XG5cbiAgICAgICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSAmJiAoIHYudyA9PT0gdGhpcy53ICkgKTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICAgICAgdGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICAgICAgdGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcbiAgICAgICAgdGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuICAgICAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG4gICAgICAgIHRoaXMueiA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAyIF07XG4gICAgICAgIHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvRXVsZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5FdWxlciA9IGZ1bmN0aW9uKCB4LCB5LCB6LCBvcmRlciApIHtcblxuICAgIHRoaXMuX3ggPSB4IHx8IDA7XG4gICAgdGhpcy5feSA9IHkgfHwgMDtcbiAgICB0aGlzLl96ID0geiB8fCAwO1xuICAgIHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xuXG59O1xuXG5USFJFRS5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcblxuVEhSRUUuRXVsZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkV1bGVyLFxuXG4gICAgZ2V0IHgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG5cbiAgICB9LFxuXG4gICAgc2V0IHgoIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgZ2V0IHkoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG5cbiAgICB9LFxuXG4gICAgc2V0IHkoIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgZ2V0IHooKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XG5cbiAgICB9LFxuXG4gICAgc2V0IHooIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX3ogPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgZ2V0IG9yZGVyKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRlcjtcblxuICAgIH0sXG5cbiAgICBzZXQgb3JkZXIoIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX29yZGVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oIHgsIHksIHosIG9yZGVyICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgdGhpcy5feiA9IHo7XG4gICAgICAgIHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggZXVsZXIgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IGV1bGVyLl94O1xuICAgICAgICB0aGlzLl95ID0gZXVsZXIuX3k7XG4gICAgICAgIHRoaXMuX3ogPSBldWxlci5fejtcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiggbSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuICAgICAgICB2YXIgY2xhbXAgPSBUSFJFRS5NYXRoLmNsYW1wO1xuXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICAgICAgdmFyIHRlID0gbS5lbGVtZW50cztcbiAgICAgICAgdmFyIG0xMSA9IHRlWyAwIF0sXG4gICAgICAgICAgICBtMTIgPSB0ZVsgNCBdLFxuICAgICAgICAgICAgbTEzID0gdGVbIDggXTtcbiAgICAgICAgdmFyIG0yMSA9IHRlWyAxIF0sXG4gICAgICAgICAgICBtMjIgPSB0ZVsgNSBdLFxuICAgICAgICAgICAgbTIzID0gdGVbIDkgXTtcbiAgICAgICAgdmFyIG0zMSA9IHRlWyAyIF0sXG4gICAgICAgICAgICBtMzIgPSB0ZVsgNiBdLFxuICAgICAgICAgICAgbTMzID0gdGVbIDEwIF07XG5cbiAgICAgICAgb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuICAgICAgICBpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLTEsIDEgKSApO1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggLW0yMywgbTMzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIC1tMTIsIG0xMSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hc2luKCAtY2xhbXAoIG0yMywgLTEsIDEgKSApO1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLW0zMSwgbTExICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0xLCAxICkgKTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC1tMzEsIG0zMyApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtbTEyLCBtMjIgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbiggLWNsYW1wKCBtMzEsIC0xLCAxICkgKTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIC1tMTIsIG0yMiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtMSwgMSApICk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtbTIzLCBtMjIgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLW0zMSwgbTExICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4oIC1jbGFtcCggbTEyLCAtMSwgMSApICk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtbTIzLCBtMzMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29yZGVyID0gb3JkZXI7XG5cbiAgICAgICAgaWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXRyaXg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBxLCBvcmRlciwgdXBkYXRlICkge1xuXG4gICAgICAgICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgICAgIG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuICAgICAgICAgICAgdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgc2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uKCB2LCBvcmRlciApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XG5cbiAgICB9LFxuXG4gICAgcmVvcmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG4gICAgICAgIHZhciBxID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG5ld09yZGVyICkge1xuXG4gICAgICAgICAgICBxLnNldEZyb21FdWxlciggdGhpcyApO1xuICAgICAgICAgICAgdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggZXVsZXIgKSB7XG5cbiAgICAgICAgcmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5ICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuICAgICAgICB0aGlzLl95ID0gYXJyYXlbIDEgXTtcbiAgICAgICAgdGhpcy5feiA9IGFycmF5WyAyIF07XG4gICAgICAgIGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICB0b1ZlY3RvcjM6IGZ1bmN0aW9uKCBvcHRpb25hbFJlc3VsdCApIHtcblxuICAgICAgICBpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgb25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24oKSB7fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0xpbmUzLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuTGluZTMgPSBmdW5jdGlvbiggc3RhcnQsIGVuZCApIHtcblxuICAgIHRoaXMuc3RhcnQgPSAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IHN0YXJ0IDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLmVuZCA9ICggZW5kICE9PSB1bmRlZmluZWQgKSA/IGVuZCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLkxpbmUzLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lMyxcblxuICAgIHNldDogZnVuY3Rpb24oIHN0YXJ0LCBlbmQgKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xuICAgICAgICB0aGlzLmVuZC5jb3B5KCBlbmQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBsaW5lICkge1xuXG4gICAgICAgIHRoaXMuc3RhcnQuY29weSggbGluZS5zdGFydCApO1xuICAgICAgICB0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNlbnRlcjogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgfSxcblxuICAgIGRlbHRhOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVNxOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcblxuICAgIH0sXG5cbiAgICBhdDogZnVuY3Rpb24oIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGFydFAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgc3RhcnRFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcG9pbnQsIGNsYW1wVG9MaW5lICkge1xuXG4gICAgICAgICAgICBzdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcbiAgICAgICAgICAgIHN0YXJ0RW5kLnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cbiAgICAgICAgICAgIHZhciBzdGFydEVuZDIgPSBzdGFydEVuZC5kb3QoIHN0YXJ0RW5kICk7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbmRfc3RhcnRQID0gc3RhcnRFbmQuZG90KCBzdGFydFAgKTtcblxuICAgICAgICAgICAgdmFyIHQgPSBzdGFydEVuZF9zdGFydFAgLyBzdGFydEVuZDI7XG5cbiAgICAgICAgICAgIGlmICggY2xhbXBUb0xpbmUgKSB7XG5cbiAgICAgICAgICAgICAgICB0ID0gVEhSRUUuTWF0aC5jbGFtcCggdCwgMCwgMSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiggbWF0cml4ICkge1xuXG4gICAgICAgIHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcbiAgICAgICAgdGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBsaW5lICkge1xuXG4gICAgICAgIHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gyLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuQm94MiA9IGZ1bmN0aW9uKCBtaW4sIG1heCApIHtcblxuICAgIHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xuICAgIHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjIoIC1JbmZpbml0eSwgLUluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJveDIsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBtaW4sIG1heCApIHtcblxuICAgICAgICB0aGlzLm1pbi5jb3B5KCBtaW4gKTtcbiAgICAgICAgdGhpcy5tYXguY29weSggbWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVBvaW50czogZnVuY3Rpb24oIHBvaW50cyApIHtcblxuICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggY2VudGVyLCBzaXplICkge1xuXG4gICAgICAgICAgICB2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuICAgICAgICAgICAgdGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuICAgICAgICAgICAgdGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcbiAgICAgICAgdGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VFbXB0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XG5cbiAgICB9LFxuXG4gICAgY2VudGVyOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuICAgIH0sXG5cbiAgICBleHBhbmRCeVBvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgdGhpcy5taW4ubWluKCBwb2ludCApO1xuICAgICAgICB0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgdGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcbiAgICAgICAgdGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24oIHNjYWxhciApIHtcblxuICAgICAgICB0aGlzLm1pbi5hZGRTY2FsYXIoIC1zY2FsYXIgKTtcbiAgICAgICAgdGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgaWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9LFxuXG4gICAgY29udGFpbnNCb3g6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgaWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG4gICAgICAgICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfSxcblxuICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuICAgICAgICAvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KFxuICAgICAgICAgICAgKCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLCAoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcbiAgICAgICAgKTtcblxuICAgIH0sXG5cbiAgICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICAvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuICAgICAgICBpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSxcblxuICAgIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgICAgIHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgdGhpcy5taW4ubWF4KCBib3gubWluICk7XG4gICAgICAgIHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHVuaW9uOiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuICAgICAgICB0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcbiAgICAgICAgdGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgcmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0JveDMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkJveDMgPSBmdW5jdGlvbiggbWluLCBtYXggKSB7XG5cbiAgICB0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XG4gICAgdGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVEhSRUUuVmVjdG9yMyggLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSApO1xuXG59O1xuXG5USFJFRS5Cb3gzLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gzLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggbWluLCBtYXggKSB7XG5cbiAgICAgICAgdGhpcy5taW4uY29weSggbWluICk7XG4gICAgICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cbiAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBjZW50ZXIsIHNpemUgKSB7XG5cbiAgICAgICAgICAgIHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICAgICAgICAgIHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcbiAgICAgICAgICAgIHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG4gICAgICAgIC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuXG4gICAgICAgICAgICBvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uKCBub2RlICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbm9kZS5nZW9tZXRyeTtcblxuICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0uYXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxLnNldCggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICB0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG4gICAgICAgIHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlRW1wdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtSW5maW5pdHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xuXG4gICAgfSxcblxuICAgIGNlbnRlcjogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cbiAgICB9LFxuXG4gICAgZXhwYW5kQnlQb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHRoaXMubWluLm1pbiggcG9pbnQgKTtcbiAgICAgICAgdGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIHRoaXMubWluLnN1YiggdmVjdG9yICk7XG4gICAgICAgIHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgdGhpcy5taW4uYWRkU2NhbGFyKCAtc2NhbGFyICk7XG4gICAgICAgIHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XG4gICAgICAgICAgICBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBjb250YWluc0JveDogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICBpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcbiAgICAgICAgICAgICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcbiAgICAgICAgICAgICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG4gICAgICAgIC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksICggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSwgKCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXG4gICAgICAgICk7XG5cbiAgICB9LFxuXG4gICAgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgLy8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cbiAgICAgICAgaWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxuICAgICAgICAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSxcblxuICAgIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgICAgIHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgICAgICAgICByZXN1bHQuY2VudGVyID0gdGhpcy5jZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGludGVyc2VjdDogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICB0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcbiAgICAgICAgdGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdW5pb246IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgdGhpcy5taW4ubWluKCBib3gubWluICk7XG4gICAgICAgIHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBtYXRyaXggKSB7XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG4gICAgICAgICAgICBwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcbiAgICAgICAgICAgIHBvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxuICAgICAgICAgICAgcG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG4gICAgICAgICAgICBwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcbiAgICAgICAgICAgIHBvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxuICAgICAgICAgICAgcG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG4gICAgICAgICAgICBwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcbiAgICAgICAgICAgIHBvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMVxuXG4gICAgICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oIG9mZnNldCApIHtcblxuICAgICAgICB0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuICAgICAgICB0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICByZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cbiAgICAgICAgMSwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCxcbiAgICAgICAgMCwgMCwgMVxuXG4gICAgXSApO1xuXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1hdHJpeDMucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdGVbIDAgXSA9IG4xMTtcbiAgICAgICAgdGVbIDMgXSA9IG4xMjtcbiAgICAgICAgdGVbIDYgXSA9IG4xMztcbiAgICAgICAgdGVbIDEgXSA9IG4yMTtcbiAgICAgICAgdGVbIDQgXSA9IG4yMjtcbiAgICAgICAgdGVbIDcgXSA9IG4yMztcbiAgICAgICAgdGVbIDIgXSA9IG4zMTtcbiAgICAgICAgdGVbIDUgXSA9IG4zMjtcbiAgICAgICAgdGVbIDggXSA9IG4zMztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBpZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIDEsIDAsIDAsXG4gICAgICAgICAgICAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIG1lWyAwIF0sIG1lWyAzIF0sIG1lWyA2IF0sXG4gICAgICAgICAgICBtZVsgMSBdLCBtZVsgNCBdLCBtZVsgNyBdLFxuICAgICAgICAgICAgbWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCBhICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xuXG4gICAgfSxcblxuICAgIGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgdjEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xuICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xuICAgICAgICAgICAgICAgIHYxLnRvQXJyYXkoIGFycmF5LCBqICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBhcHBseVRvQnVmZmVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrLCBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcbiAgICAgICAgICAgICAgICB2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcbiAgICAgICAgICAgICAgICB2MS56ID0gYnVmZmVyLmdldFooIGogKTtcblxuICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRlWyAwIF0gKj0gcztcbiAgICAgICAgdGVbIDMgXSAqPSBzO1xuICAgICAgICB0ZVsgNiBdICo9IHM7XG4gICAgICAgIHRlWyAxIF0gKj0gcztcbiAgICAgICAgdGVbIDQgXSAqPSBzO1xuICAgICAgICB0ZVsgNyBdICo9IHM7XG4gICAgICAgIHRlWyAyIF0gKj0gcztcbiAgICAgICAgdGVbIDUgXSAqPSBzO1xuICAgICAgICB0ZVsgOCBdICo9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdmFyIGEgPSB0ZVsgMCBdLFxuICAgICAgICAgICAgYiA9IHRlWyAxIF0sXG4gICAgICAgICAgICBjID0gdGVbIDIgXSxcbiAgICAgICAgICAgIGQgPSB0ZVsgMyBdLFxuICAgICAgICAgICAgZSA9IHRlWyA0IF0sXG4gICAgICAgICAgICBmID0gdGVbIDUgXSxcbiAgICAgICAgICAgIGcgPSB0ZVsgNiBdLFxuICAgICAgICAgICAgaCA9IHRlWyA3IF0sXG4gICAgICAgICAgICBpID0gdGVbIDggXTtcblxuICAgICAgICByZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG4gICAgfSxcblxuICAgIGdldEludmVyc2U6IGZ1bmN0aW9uKCBtYXRyaXgsIHRocm93T25JbnZlcnRpYmxlICkge1xuXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XG4gICAgICAgIC8vICggYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLW1qcy8gKVxuXG4gICAgICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0ZVsgMCBdID0gbWVbIDEwIF0gKiBtZVsgNSBdIC0gbWVbIDYgXSAqIG1lWyA5IF07XG4gICAgICAgIHRlWyAxIF0gPSAtbWVbIDEwIF0gKiBtZVsgMSBdICsgbWVbIDIgXSAqIG1lWyA5IF07XG4gICAgICAgIHRlWyAyIF0gPSBtZVsgNiBdICogbWVbIDEgXSAtIG1lWyAyIF0gKiBtZVsgNSBdO1xuICAgICAgICB0ZVsgMyBdID0gLW1lWyAxMCBdICogbWVbIDQgXSArIG1lWyA2IF0gKiBtZVsgOCBdO1xuICAgICAgICB0ZVsgNCBdID0gbWVbIDEwIF0gKiBtZVsgMCBdIC0gbWVbIDIgXSAqIG1lWyA4IF07XG4gICAgICAgIHRlWyA1IF0gPSAtbWVbIDYgXSAqIG1lWyAwIF0gKyBtZVsgMiBdICogbWVbIDQgXTtcbiAgICAgICAgdGVbIDYgXSA9IG1lWyA5IF0gKiBtZVsgNCBdIC0gbWVbIDUgXSAqIG1lWyA4IF07XG4gICAgICAgIHRlWyA3IF0gPSAtbWVbIDkgXSAqIG1lWyAwIF0gKyBtZVsgMSBdICogbWVbIDggXTtcbiAgICAgICAgdGVbIDggXSA9IG1lWyA1IF0gKiBtZVsgMCBdIC0gbWVbIDEgXSAqIG1lWyA0IF07XG5cbiAgICAgICAgdmFyIGRldCA9IG1lWyAwIF0gKiB0ZVsgMCBdICsgbWVbIDEgXSAqIHRlWyAzIF0gKyBtZVsgMiBdICogdGVbIDYgXTtcblxuICAgICAgICAvLyBubyBpbnZlcnNlXG5cbiAgICAgICAgaWYgKCBkZXQgPT09IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBtc2cgPSBcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cbiAgICAgICAgICAgIGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggbXNnICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pZGVudGl0eSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0bXAgPSBtWyAxIF07XG4gICAgICAgIG1bIDEgXSA9IG1bIDMgXTtcbiAgICAgICAgbVsgMyBdID0gdG1wO1xuICAgICAgICB0bXAgPSBtWyAyIF07XG4gICAgICAgIG1bIDIgXSA9IG1bIDYgXTtcbiAgICAgICAgbVsgNiBdID0gdG1wO1xuICAgICAgICB0bXAgPSBtWyA1IF07XG4gICAgICAgIG1bIDUgXSA9IG1bIDcgXTtcbiAgICAgICAgbVsgNyBdID0gdG1wO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIGdldE5vcm1hbE1hdHJpeDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcblxuICAgICAgICB0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0cmFuc3Bvc2VJbnRvQXJyYXk6IGZ1bmN0aW9uKCByICkge1xuXG4gICAgICAgIHZhciBtID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICByWyAwIF0gPSBtWyAwIF07XG4gICAgICAgIHJbIDEgXSA9IG1bIDMgXTtcbiAgICAgICAgclsgMiBdID0gbVsgNiBdO1xuICAgICAgICByWyAzIF0gPSBtWyAxIF07XG4gICAgICAgIHJbIDQgXSA9IG1bIDQgXTtcbiAgICAgICAgclsgNSBdID0gbVsgNyBdO1xuICAgICAgICByWyA2IF0gPSBtWyAyIF07XG4gICAgICAgIHJbIDcgXSA9IG1bIDUgXTtcbiAgICAgICAgclsgOCBdID0gbVsgOCBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5ICkge1xuXG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0sXG4gICAgICAgICAgICB0ZVsgMyBdLCB0ZVsgNCBdLCB0ZVsgNSBdLFxuICAgICAgICAgICAgdGVbIDYgXSwgdGVbIDcgXSwgdGVbIDggXVxuICAgICAgICBdO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIGpvcmRpX3JvcyAvIGh0dHA6Ly9wbGF0dHNvZnQuY29tXG4gKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuTWF0cml4NCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblxuICAgICAgICAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICBdICk7XG5cbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTWF0cml4NC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcblxuICAgIHNldDogZnVuY3Rpb24oIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRlWyAwIF0gPSBuMTE7XG4gICAgICAgIHRlWyA0IF0gPSBuMTI7XG4gICAgICAgIHRlWyA4IF0gPSBuMTM7XG4gICAgICAgIHRlWyAxMiBdID0gbjE0O1xuICAgICAgICB0ZVsgMSBdID0gbjIxO1xuICAgICAgICB0ZVsgNSBdID0gbjIyO1xuICAgICAgICB0ZVsgOSBdID0gbjIzO1xuICAgICAgICB0ZVsgMTMgXSA9IG4yNDtcbiAgICAgICAgdGVbIDIgXSA9IG4zMTtcbiAgICAgICAgdGVbIDYgXSA9IG4zMjtcbiAgICAgICAgdGVbIDEwIF0gPSBuMzM7XG4gICAgICAgIHRlWyAxNCBdID0gbjM0O1xuICAgICAgICB0ZVsgMyBdID0gbjQxO1xuICAgICAgICB0ZVsgNyBdID0gbjQyO1xuICAgICAgICB0ZVsgMTEgXSA9IG40MztcbiAgICAgICAgdGVbIDE1IF0gPSBuNDQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgaWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICAxLCAwLCAwLCAwLFxuICAgICAgICAgICAgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZXQoIG0uZWxlbWVudHMgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBleHRyYWN0UG9zaXRpb246IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5leHRyYWN0UG9zaXRpb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3B5UG9zaXRpb24oKS4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xuXG4gICAgfSxcblxuICAgIGNvcHlQb3NpdGlvbjogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgICAgICB0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuICAgICAgICB0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuICAgICAgICB0ZVsgMTQgXSA9IG1lWyAxNCBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGV4dHJhY3RCYXNpczogZnVuY3Rpb24oIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB4QXhpcy5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcbiAgICAgICAgeUF4aXMuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XG4gICAgICAgIHpBeGlzLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlQmFzaXM6IGZ1bmN0aW9uKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG4gICAgICAgIHRoaXMuc2V0KFxuICAgICAgICAgICAgeEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcbiAgICAgICAgICAgIHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG4gICAgICAgICAgICB4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0KCBtZVsgNCBdLCBtZVsgNSBdLCBtZVsgNiBdICkubGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgc2NhbGVaID0gMSAvIHYxLnNldCggbWVbIDggXSwgbWVbIDkgXSwgbWVbIDEwIF0gKS5sZW5ndGgoKTtcblxuICAgICAgICAgICAgdGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG4gICAgICAgICAgICB0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcbiAgICAgICAgICAgIHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXG4gICAgICAgICAgICB0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcbiAgICAgICAgICAgIHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuICAgICAgICAgICAgdGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cbiAgICAgICAgICAgIHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuICAgICAgICAgICAgdGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiggZXVsZXIgKSB7XG5cbiAgICAgICAgaWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdmFyIHggPSBldWxlci54LFxuICAgICAgICAgICAgeSA9IGV1bGVyLnksXG4gICAgICAgICAgICB6ID0gZXVsZXIuejtcbiAgICAgICAgdmFyIGEgPSBNYXRoLmNvcyggeCApLFxuICAgICAgICAgICAgYiA9IE1hdGguc2luKCB4ICk7XG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHkgKSxcbiAgICAgICAgICAgIGQgPSBNYXRoLnNpbiggeSApO1xuICAgICAgICB2YXIgZSA9IE1hdGguY29zKCB6ICksXG4gICAgICAgICAgICBmID0gTWF0aC5zaW4oIHogKTtcblxuICAgICAgICBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuICAgICAgICAgICAgdmFyIGFlID0gYSAqIGUsXG4gICAgICAgICAgICAgICAgYWYgPSBhICogZixcbiAgICAgICAgICAgICAgICBiZSA9IGIgKiBlLFxuICAgICAgICAgICAgICAgIGJmID0gYiAqIGY7XG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcbiAgICAgICAgICAgIHRlWyA0IF0gPSAtYyAqIGY7XG4gICAgICAgICAgICB0ZVsgOCBdID0gZDtcblxuICAgICAgICAgICAgdGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuICAgICAgICAgICAgdGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuICAgICAgICAgICAgdGVbIDkgXSA9IC1iICogYztcblxuICAgICAgICAgICAgdGVbIDIgXSA9IGJmIC0gYWUgKiBkO1xuICAgICAgICAgICAgdGVbIDYgXSA9IGJlICsgYWYgKiBkO1xuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cbiAgICAgICAgICAgIHZhciBjZSA9IGMgKiBlLFxuICAgICAgICAgICAgICAgIGNmID0gYyAqIGYsXG4gICAgICAgICAgICAgICAgZGUgPSBkICogZSxcbiAgICAgICAgICAgICAgICBkZiA9IGQgKiBmO1xuXG4gICAgICAgICAgICB0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG4gICAgICAgICAgICB0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG4gICAgICAgICAgICB0ZVsgOCBdID0gYSAqIGQ7XG5cbiAgICAgICAgICAgIHRlWyAxIF0gPSBhICogZjtcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhICogZTtcbiAgICAgICAgICAgIHRlWyA5IF0gPSAtYjtcblxuICAgICAgICAgICAgdGVbIDIgXSA9IGNmICogYiAtIGRlO1xuICAgICAgICAgICAgdGVbIDYgXSA9IGRmICsgY2UgKiBiO1xuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICAgICAgICAgIHZhciBjZSA9IGMgKiBlLFxuICAgICAgICAgICAgICAgIGNmID0gYyAqIGYsXG4gICAgICAgICAgICAgICAgZGUgPSBkICogZSxcbiAgICAgICAgICAgICAgICBkZiA9IGQgKiBmO1xuXG4gICAgICAgICAgICB0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XG4gICAgICAgICAgICB0ZVsgNCBdID0gLWEgKiBmO1xuICAgICAgICAgICAgdGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG4gICAgICAgICAgICB0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG4gICAgICAgICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICAgICAgICB0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cbiAgICAgICAgICAgIHRlWyAyIF0gPSAtYSAqIGQ7XG4gICAgICAgICAgICB0ZVsgNiBdID0gYjtcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICAgICAgICB2YXIgYWUgPSBhICogZSxcbiAgICAgICAgICAgICAgICBhZiA9IGEgKiBmLFxuICAgICAgICAgICAgICAgIGJlID0gYiAqIGUsXG4gICAgICAgICAgICAgICAgYmYgPSBiICogZjtcblxuICAgICAgICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgICAgICAgdGVbIDQgXSA9IGJlICogZCAtIGFmO1xuICAgICAgICAgICAgdGVbIDggXSA9IGFlICogZCArIGJmO1xuXG4gICAgICAgICAgICB0ZVsgMSBdID0gYyAqIGY7XG4gICAgICAgICAgICB0ZVsgNSBdID0gYmYgKiBkICsgYWU7XG4gICAgICAgICAgICB0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XG5cbiAgICAgICAgICAgIHRlWyAyIF0gPSAtZDtcbiAgICAgICAgICAgIHRlWyA2IF0gPSBiICogYztcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICAgICAgICB2YXIgYWMgPSBhICogYyxcbiAgICAgICAgICAgICAgICBhZCA9IGEgKiBkLFxuICAgICAgICAgICAgICAgIGJjID0gYiAqIGMsXG4gICAgICAgICAgICAgICAgYmQgPSBiICogZDtcblxuICAgICAgICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgICAgICAgdGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xuICAgICAgICAgICAgdGVbIDggXSA9IGJjICogZiArIGFkO1xuXG4gICAgICAgICAgICB0ZVsgMSBdID0gZjtcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhICogZTtcbiAgICAgICAgICAgIHRlWyA5IF0gPSAtYiAqIGU7XG5cbiAgICAgICAgICAgIHRlWyAyIF0gPSAtZCAqIGU7XG4gICAgICAgICAgICB0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgICAgICAgdmFyIGFjID0gYSAqIGMsXG4gICAgICAgICAgICAgICAgYWQgPSBhICogZCxcbiAgICAgICAgICAgICAgICBiYyA9IGIgKiBjLFxuICAgICAgICAgICAgICAgIGJkID0gYiAqIGQ7XG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcbiAgICAgICAgICAgIHRlWyA0IF0gPSAtZjtcbiAgICAgICAgICAgIHRlWyA4IF0gPSBkICogZTtcblxuICAgICAgICAgICAgdGVbIDEgXSA9IGFjICogZiArIGJkO1xuICAgICAgICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgICAgICAgdGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG4gICAgICAgICAgICB0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XG4gICAgICAgICAgICB0ZVsgNiBdID0gYiAqIGU7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBsYXN0IGNvbHVtblxuICAgICAgICB0ZVsgMyBdID0gMDtcbiAgICAgICAgdGVbIDcgXSA9IDA7XG4gICAgICAgIHRlWyAxMSBdID0gMDtcblxuICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgIHRlWyAxMiBdID0gMDtcbiAgICAgICAgdGVbIDEzIF0gPSAwO1xuICAgICAgICB0ZVsgMTQgXSA9IDA7XG4gICAgICAgIHRlWyAxNSBdID0gMTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiggcSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cbiAgICB9LFxuXG4gICAgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uKCBxICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdmFyIHggPSBxLngsXG4gICAgICAgICAgICB5ID0gcS55LFxuICAgICAgICAgICAgeiA9IHEueixcbiAgICAgICAgICAgIHcgPSBxLnc7XG4gICAgICAgIHZhciB4MiA9IHggKyB4LFxuICAgICAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgICAgIHoyID0geiArIHo7XG4gICAgICAgIHZhciB4eCA9IHggKiB4MixcbiAgICAgICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICAgICAgeHogPSB4ICogejI7XG4gICAgICAgIHZhciB5eSA9IHkgKiB5MixcbiAgICAgICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICAgICAgenogPSB6ICogejI7XG4gICAgICAgIHZhciB3eCA9IHcgKiB4MixcbiAgICAgICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICAgICAgdGVbIDAgXSA9IDEgLSAoIHl5ICsgenogKTtcbiAgICAgICAgdGVbIDQgXSA9IHh5IC0gd3o7XG4gICAgICAgIHRlWyA4IF0gPSB4eiArIHd5O1xuXG4gICAgICAgIHRlWyAxIF0gPSB4eSArIHd6O1xuICAgICAgICB0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xuICAgICAgICB0ZVsgOSBdID0geXogLSB3eDtcblxuICAgICAgICB0ZVsgMiBdID0geHogLSB3eTtcbiAgICAgICAgdGVbIDYgXSA9IHl6ICsgd3g7XG4gICAgICAgIHRlWyAxMCBdID0gMSAtICggeHggKyB5eSApO1xuXG4gICAgICAgIC8vIGxhc3QgY29sdW1uXG4gICAgICAgIHRlWyAzIF0gPSAwO1xuICAgICAgICB0ZVsgNyBdID0gMDtcbiAgICAgICAgdGVbIDExIF0gPSAwO1xuXG4gICAgICAgIC8vIGJvdHRvbSByb3dcbiAgICAgICAgdGVbIDEyIF0gPSAwO1xuICAgICAgICB0ZVsgMTMgXSA9IDA7XG4gICAgICAgIHRlWyAxNCBdID0gMDtcbiAgICAgICAgdGVbIDE1IF0gPSAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGxvb2tBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHgsIHksIHo7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBleWUsIHRhcmdldCwgdXAgKSB7XG5cbiAgICAgICAgICAgIGlmICggeCA9PT0gdW5kZWZpbmVkICkgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBpZiAoIHkgPT09IHVuZGVmaW5lZCApIHkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgaWYgKCB6ID09PSB1bmRlZmluZWQgKSB6ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICAgICAgei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICBpZiAoIHoubGVuZ3RoKCkgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICB6LnogPSAxO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICBpZiAoIHgubGVuZ3RoKCkgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICB6LnggKz0gMC4wMDAxO1xuICAgICAgICAgICAgICAgIHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XG5cblxuICAgICAgICAgICAgdGVbIDAgXSA9IHgueDtcbiAgICAgICAgICAgIHRlWyA0IF0gPSB5Lng7XG4gICAgICAgICAgICB0ZVsgOCBdID0gei54O1xuICAgICAgICAgICAgdGVbIDEgXSA9IHgueTtcbiAgICAgICAgICAgIHRlWyA1IF0gPSB5Lnk7XG4gICAgICAgICAgICB0ZVsgOSBdID0gei55O1xuICAgICAgICAgICAgdGVbIDIgXSA9IHguejtcbiAgICAgICAgICAgIHRlWyA2IF0gPSB5Lno7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IHouejtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiggbSwgbiApIHtcblxuICAgICAgICBpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdmFyIGFlID0gYS5lbGVtZW50cztcbiAgICAgICAgdmFyIGJlID0gYi5lbGVtZW50cztcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB2YXIgYTExID0gYWVbIDAgXSxcbiAgICAgICAgICAgIGExMiA9IGFlWyA0IF0sXG4gICAgICAgICAgICBhMTMgPSBhZVsgOCBdLFxuICAgICAgICAgICAgYTE0ID0gYWVbIDEyIF07XG4gICAgICAgIHZhciBhMjEgPSBhZVsgMSBdLFxuICAgICAgICAgICAgYTIyID0gYWVbIDUgXSxcbiAgICAgICAgICAgIGEyMyA9IGFlWyA5IF0sXG4gICAgICAgICAgICBhMjQgPSBhZVsgMTMgXTtcbiAgICAgICAgdmFyIGEzMSA9IGFlWyAyIF0sXG4gICAgICAgICAgICBhMzIgPSBhZVsgNiBdLFxuICAgICAgICAgICAgYTMzID0gYWVbIDEwIF0sXG4gICAgICAgICAgICBhMzQgPSBhZVsgMTQgXTtcbiAgICAgICAgdmFyIGE0MSA9IGFlWyAzIF0sXG4gICAgICAgICAgICBhNDIgPSBhZVsgNyBdLFxuICAgICAgICAgICAgYTQzID0gYWVbIDExIF0sXG4gICAgICAgICAgICBhNDQgPSBhZVsgMTUgXTtcblxuICAgICAgICB2YXIgYjExID0gYmVbIDAgXSxcbiAgICAgICAgICAgIGIxMiA9IGJlWyA0IF0sXG4gICAgICAgICAgICBiMTMgPSBiZVsgOCBdLFxuICAgICAgICAgICAgYjE0ID0gYmVbIDEyIF07XG4gICAgICAgIHZhciBiMjEgPSBiZVsgMSBdLFxuICAgICAgICAgICAgYjIyID0gYmVbIDUgXSxcbiAgICAgICAgICAgIGIyMyA9IGJlWyA5IF0sXG4gICAgICAgICAgICBiMjQgPSBiZVsgMTMgXTtcbiAgICAgICAgdmFyIGIzMSA9IGJlWyAyIF0sXG4gICAgICAgICAgICBiMzIgPSBiZVsgNiBdLFxuICAgICAgICAgICAgYjMzID0gYmVbIDEwIF0sXG4gICAgICAgICAgICBiMzQgPSBiZVsgMTQgXTtcbiAgICAgICAgdmFyIGI0MSA9IGJlWyAzIF0sXG4gICAgICAgICAgICBiNDIgPSBiZVsgNyBdLFxuICAgICAgICAgICAgYjQzID0gYmVbIDExIF0sXG4gICAgICAgICAgICBiNDQgPSBiZVsgMTUgXTtcblxuICAgICAgICB0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuICAgICAgICB0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuICAgICAgICB0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuICAgICAgICB0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuICAgICAgICB0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuICAgICAgICB0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuICAgICAgICB0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuICAgICAgICB0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuICAgICAgICB0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuICAgICAgICB0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuICAgICAgICB0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcbiAgICAgICAgdGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cbiAgICAgICAgdGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcbiAgICAgICAgdGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcbiAgICAgICAgdGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG4gICAgICAgIHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24oIGEsIGIsIHIgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcblxuICAgICAgICByWyAwIF0gPSB0ZVsgMCBdO1xuICAgICAgICByWyAxIF0gPSB0ZVsgMSBdO1xuICAgICAgICByWyAyIF0gPSB0ZVsgMiBdO1xuICAgICAgICByWyAzIF0gPSB0ZVsgMyBdO1xuICAgICAgICByWyA0IF0gPSB0ZVsgNCBdO1xuICAgICAgICByWyA1IF0gPSB0ZVsgNSBdO1xuICAgICAgICByWyA2IF0gPSB0ZVsgNiBdO1xuICAgICAgICByWyA3IF0gPSB0ZVsgNyBdO1xuICAgICAgICByWyA4IF0gPSB0ZVsgOCBdO1xuICAgICAgICByWyA5IF0gPSB0ZVsgOSBdO1xuICAgICAgICByWyAxMCBdID0gdGVbIDEwIF07XG4gICAgICAgIHJbIDExIF0gPSB0ZVsgMTEgXTtcbiAgICAgICAgclsgMTIgXSA9IHRlWyAxMiBdO1xuICAgICAgICByWyAxMyBdID0gdGVbIDEzIF07XG4gICAgICAgIHJbIDE0IF0gPSB0ZVsgMTQgXTtcbiAgICAgICAgclsgMTUgXSA9IHRlWyAxNSBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRlWyAwIF0gKj0gcztcbiAgICAgICAgdGVbIDQgXSAqPSBzO1xuICAgICAgICB0ZVsgOCBdICo9IHM7XG4gICAgICAgIHRlWyAxMiBdICo9IHM7XG4gICAgICAgIHRlWyAxIF0gKj0gcztcbiAgICAgICAgdGVbIDUgXSAqPSBzO1xuICAgICAgICB0ZVsgOSBdICo9IHM7XG4gICAgICAgIHRlWyAxMyBdICo9IHM7XG4gICAgICAgIHRlWyAyIF0gKj0gcztcbiAgICAgICAgdGVbIDYgXSAqPSBzO1xuICAgICAgICB0ZVsgMTAgXSAqPSBzO1xuICAgICAgICB0ZVsgMTQgXSAqPSBzO1xuICAgICAgICB0ZVsgMyBdICo9IHM7XG4gICAgICAgIHRlWyA3IF0gKj0gcztcbiAgICAgICAgdGVbIDExIF0gKj0gcztcbiAgICAgICAgdGVbIDE1IF0gKj0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVZlY3RvcjQ6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24oIGEgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICB2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG4gICAgICAgICAgICAgICAgdjEudG9BcnJheSggYXJyYXksIGogKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpKyssIGorKyApIHtcblxuICAgICAgICAgICAgICAgIHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuICAgICAgICAgICAgICAgIHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xuICAgICAgICAgICAgICAgIHYxLnogPSBidWZmZXIuZ2V0WiggaiApO1xuXG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlQXhpczogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG4gICAgICAgIHYudHJhbnNmb3JtRGlyZWN0aW9uKCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY3Jvc3NWZWN0b3I6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGRldGVybWluYW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHZhciBuMTEgPSB0ZVsgMCBdLFxuICAgICAgICAgICAgbjEyID0gdGVbIDQgXSxcbiAgICAgICAgICAgIG4xMyA9IHRlWyA4IF0sXG4gICAgICAgICAgICBuMTQgPSB0ZVsgMTIgXTtcbiAgICAgICAgdmFyIG4yMSA9IHRlWyAxIF0sXG4gICAgICAgICAgICBuMjIgPSB0ZVsgNSBdLFxuICAgICAgICAgICAgbjIzID0gdGVbIDkgXSxcbiAgICAgICAgICAgIG4yNCA9IHRlWyAxMyBdO1xuICAgICAgICB2YXIgbjMxID0gdGVbIDIgXSxcbiAgICAgICAgICAgIG4zMiA9IHRlWyA2IF0sXG4gICAgICAgICAgICBuMzMgPSB0ZVsgMTAgXSxcbiAgICAgICAgICAgIG4zNCA9IHRlWyAxNCBdO1xuICAgICAgICB2YXIgbjQxID0gdGVbIDMgXSxcbiAgICAgICAgICAgIG40MiA9IHRlWyA3IF0sXG4gICAgICAgICAgICBuNDMgPSB0ZVsgMTEgXSxcbiAgICAgICAgICAgIG40NCA9IHRlWyAxNSBdO1xuXG4gICAgICAgIC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG4gICAgICAgIC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBuNDEgKiAoICtuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQgKSArXG4gICAgICAgICAgICBuNDIgKiAoICtuMTEgKiBuMjMgKiBuMzQgLSBuMTEgKiBuMjQgKiBuMzMgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKSArXG4gICAgICAgICAgICBuNDMgKiAoICtuMTEgKiBuMjQgKiBuMzIgLSBuMTEgKiBuMjIgKiBuMzQgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgKyBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgKSArXG4gICAgICAgICAgICBuNDQgKiAoIC1uMTMgKiBuMjIgKiBuMzEgLSBuMTEgKiBuMjMgKiBuMzIgKyBuMTEgKiBuMjIgKiBuMzMgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTIgKiBuMjMgKiBuMzEgKVxuXG4gICAgICAgICk7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdG1wO1xuXG4gICAgICAgIHRtcCA9IHRlWyAxIF07XG4gICAgICAgIHRlWyAxIF0gPSB0ZVsgNCBdO1xuICAgICAgICB0ZVsgNCBdID0gdG1wO1xuICAgICAgICB0bXAgPSB0ZVsgMiBdO1xuICAgICAgICB0ZVsgMiBdID0gdGVbIDggXTtcbiAgICAgICAgdGVbIDggXSA9IHRtcDtcbiAgICAgICAgdG1wID0gdGVbIDYgXTtcbiAgICAgICAgdGVbIDYgXSA9IHRlWyA5IF07XG4gICAgICAgIHRlWyA5IF0gPSB0bXA7XG5cbiAgICAgICAgdG1wID0gdGVbIDMgXTtcbiAgICAgICAgdGVbIDMgXSA9IHRlWyAxMiBdO1xuICAgICAgICB0ZVsgMTIgXSA9IHRtcDtcbiAgICAgICAgdG1wID0gdGVbIDcgXTtcbiAgICAgICAgdGVbIDcgXSA9IHRlWyAxMyBdO1xuICAgICAgICB0ZVsgMTMgXSA9IHRtcDtcbiAgICAgICAgdG1wID0gdGVbIDExIF07XG4gICAgICAgIHRlWyAxMSBdID0gdGVbIDE0IF07XG4gICAgICAgIHRlWyAxNCBdID0gdG1wO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA5IF0gPSB0ZVsgOSBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHYxLnNldCggdGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0ZVsgMTIgXSA9IHYueDtcbiAgICAgICAgdGVbIDEzIF0gPSB2Lnk7XG4gICAgICAgIHRlWyAxNCBdID0gdi56O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldEludmVyc2U6IGZ1bmN0aW9uKCBtLCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcblxuICAgICAgICAvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgICAgICB2YXIgbjExID0gbWVbIDAgXSxcbiAgICAgICAgICAgIG4xMiA9IG1lWyA0IF0sXG4gICAgICAgICAgICBuMTMgPSBtZVsgOCBdLFxuICAgICAgICAgICAgbjE0ID0gbWVbIDEyIF07XG4gICAgICAgIHZhciBuMjEgPSBtZVsgMSBdLFxuICAgICAgICAgICAgbjIyID0gbWVbIDUgXSxcbiAgICAgICAgICAgIG4yMyA9IG1lWyA5IF0sXG4gICAgICAgICAgICBuMjQgPSBtZVsgMTMgXTtcbiAgICAgICAgdmFyIG4zMSA9IG1lWyAyIF0sXG4gICAgICAgICAgICBuMzIgPSBtZVsgNiBdLFxuICAgICAgICAgICAgbjMzID0gbWVbIDEwIF0sXG4gICAgICAgICAgICBuMzQgPSBtZVsgMTQgXTtcbiAgICAgICAgdmFyIG40MSA9IG1lWyAzIF0sXG4gICAgICAgICAgICBuNDIgPSBtZVsgNyBdLFxuICAgICAgICAgICAgbjQzID0gbWVbIDExIF0sXG4gICAgICAgICAgICBuNDQgPSBtZVsgMTUgXTtcblxuICAgICAgICB0ZVsgMCBdID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0O1xuICAgICAgICB0ZVsgNCBdID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0O1xuICAgICAgICB0ZVsgOCBdID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0O1xuICAgICAgICB0ZVsgMTIgXSA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcbiAgICAgICAgdGVbIDEgXSA9IG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NDtcbiAgICAgICAgdGVbIDUgXSA9IG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NDtcbiAgICAgICAgdGVbIDkgXSA9IG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NDtcbiAgICAgICAgdGVbIDEzIF0gPSBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQ7XG4gICAgICAgIHRlWyAyIF0gPSBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQ7XG4gICAgICAgIHRlWyA2IF0gPSBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQ7XG4gICAgICAgIHRlWyAxMCBdID0gbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0O1xuICAgICAgICB0ZVsgMTQgXSA9IG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNDtcbiAgICAgICAgdGVbIDMgXSA9IG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MztcbiAgICAgICAgdGVbIDcgXSA9IG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MztcbiAgICAgICAgdGVbIDExIF0gPSBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDM7XG4gICAgICAgIHRlWyAxNSBdID0gbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzO1xuXG4gICAgICAgIHZhciBkZXQgPSBuMTEgKiB0ZVsgMCBdICsgbjIxICogdGVbIDQgXSArIG4zMSAqIHRlWyA4IF0gKyBuNDEgKiB0ZVsgMTIgXTtcblxuICAgICAgICBpZiAoIGRldCA9PT0gMCApIHtcblxuICAgICAgICAgICAgdmFyIG1zZyA9IFwiVEhSRUUuTWF0cml4NC5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcblxuICAgICAgICAgICAgaWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBtc2cgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gZGV0ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIHJvdGF0ZVg6IGZ1bmN0aW9uKCBhbmdsZSApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICByb3RhdGVZOiBmdW5jdGlvbiggYW5nbGUgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgcm90YXRlWjogZnVuY3Rpb24oIGFuZ2xlICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24oIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQnlBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB4ID0gdi54LFxuICAgICAgICAgICAgeSA9IHYueSxcbiAgICAgICAgICAgIHogPSB2Lno7XG5cbiAgICAgICAgdGVbIDAgXSAqPSB4O1xuICAgICAgICB0ZVsgNCBdICo9IHk7XG4gICAgICAgIHRlWyA4IF0gKj0gejtcbiAgICAgICAgdGVbIDEgXSAqPSB4O1xuICAgICAgICB0ZVsgNSBdICo9IHk7XG4gICAgICAgIHRlWyA5IF0gKj0gejtcbiAgICAgICAgdGVbIDIgXSAqPSB4O1xuICAgICAgICB0ZVsgNiBdICo9IHk7XG4gICAgICAgIHRlWyAxMCBdICo9IHo7XG4gICAgICAgIHRlWyAzIF0gKj0geDtcbiAgICAgICAgdGVbIDcgXSAqPSB5O1xuICAgICAgICB0ZVsgMTEgXSAqPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcbiAgICAgICAgdmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuICAgICAgICB2YXIgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIE1hdGgubWF4KCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApICk7XG5cbiAgICB9LFxuXG4gICAgbWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiggeCwgeSwgeiApIHtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgMSwgMCwgMCwgeCxcbiAgICAgICAgICAgIDAsIDEsIDAsIHksXG4gICAgICAgICAgICAwLCAwLCAxLCB6LFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZVJvdGF0aW9uWDogZnVuY3Rpb24oIHRoZXRhICkge1xuXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCBjLCAtcywgMCxcbiAgICAgICAgICAgIDAsIHMsIGMsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiggdGhldGEgKSB7XG5cbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgYywgMCwgcywgMCxcbiAgICAgICAgICAgIDAsIDEsIDAsIDAsIC1zLCAwLCBjLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZVJvdGF0aW9uWjogZnVuY3Rpb24oIHRoZXRhICkge1xuXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIGMsIC1zLCAwLCAwLFxuICAgICAgICAgICAgcywgYywgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcbiAgICAgICAgdmFyIHQgPSAxIC0gYztcbiAgICAgICAgdmFyIHggPSBheGlzLngsXG4gICAgICAgICAgICB5ID0gYXhpcy55LFxuICAgICAgICAgICAgeiA9IGF4aXMuejtcbiAgICAgICAgdmFyIHR4ID0gdCAqIHgsXG4gICAgICAgICAgICB0eSA9IHQgKiB5O1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICB0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXG4gICAgICAgICAgICB0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXG4gICAgICAgICAgICB0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlU2NhbGU6IGZ1bmN0aW9uKCB4LCB5LCB6ICkge1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICB4LCAwLCAwLCAwLFxuICAgICAgICAgICAgMCwgeSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIHosIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb21wb3NlOiBmdW5jdGlvbiggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG4gICAgICAgIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcbiAgICAgICAgdGhpcy5zY2FsZSggc2NhbGUgKTtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2ZWN0b3IsIG1hdHJpeDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuICAgICAgICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICAgICAgdmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIHN5ID0gdmVjdG9yLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIHN6ID0gdmVjdG9yLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcblxuICAgICAgICAgICAgLy8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcbiAgICAgICAgICAgIHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG4gICAgICAgICAgICBpZiAoIGRldCA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBzeCA9IC1zeDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbi54ID0gdGVbIDEyIF07XG4gICAgICAgICAgICBwb3NpdGlvbi55ID0gdGVbIDEzIF07XG4gICAgICAgICAgICBwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cbiAgICAgICAgICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50cy5zZXQoIHRoaXMuZWxlbWVudHMgKTsgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxuXG4gICAgICAgICAgICB2YXIgaW52U1ggPSAxIC8gc3g7XG4gICAgICAgICAgICB2YXIgaW52U1kgPSAxIC8gc3k7XG4gICAgICAgICAgICB2YXIgaW52U1ogPSAxIC8gc3o7XG5cbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG4gICAgICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgICAgICAgIHNjYWxlLnggPSBzeDtcbiAgICAgICAgICAgIHNjYWxlLnkgPSBzeTtcbiAgICAgICAgICAgIHNjYWxlLnogPSBzejtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIG1ha2VGcnVzdHVtOiBmdW5jdGlvbiggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG4gICAgICAgIHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xuXG4gICAgICAgIHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG4gICAgICAgIHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG4gICAgICAgIHZhciBjID0gLSggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG4gICAgICAgIHZhciBkID0gLTIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XG5cbiAgICAgICAgdGVbIDAgXSA9IHg7XG4gICAgICAgIHRlWyA0IF0gPSAwO1xuICAgICAgICB0ZVsgOCBdID0gYTtcbiAgICAgICAgdGVbIDEyIF0gPSAwO1xuICAgICAgICB0ZVsgMSBdID0gMDtcbiAgICAgICAgdGVbIDUgXSA9IHk7XG4gICAgICAgIHRlWyA5IF0gPSBiO1xuICAgICAgICB0ZVsgMTMgXSA9IDA7XG4gICAgICAgIHRlWyAyIF0gPSAwO1xuICAgICAgICB0ZVsgNiBdID0gMDtcbiAgICAgICAgdGVbIDEwIF0gPSBjO1xuICAgICAgICB0ZVsgMTQgXSA9IGQ7XG4gICAgICAgIHRlWyAzIF0gPSAwO1xuICAgICAgICB0ZVsgNyBdID0gMDtcbiAgICAgICAgdGVbIDExIF0gPSAtMTtcbiAgICAgICAgdGVbIDE1IF0gPSAwO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24oIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cbiAgICAgICAgdmFyIHltYXggPSBuZWFyICogTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICk7XG4gICAgICAgIHZhciB5bWluID0gLXltYXg7XG4gICAgICAgIHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcbiAgICAgICAgdmFyIHhtYXggPSB5bWF4ICogYXNwZWN0O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VGcnVzdHVtKCB4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBuZWFyLCBmYXIgKTtcblxuICAgIH0sXG5cbiAgICBtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHcgPSByaWdodCAtIGxlZnQ7XG4gICAgICAgIHZhciBoID0gdG9wIC0gYm90dG9tO1xuICAgICAgICB2YXIgcCA9IGZhciAtIG5lYXI7XG5cbiAgICAgICAgdmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApIC8gdztcbiAgICAgICAgdmFyIHkgPSAoIHRvcCArIGJvdHRvbSApIC8gaDtcbiAgICAgICAgdmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XG5cbiAgICAgICAgdGVbIDAgXSA9IDIgLyB3O1xuICAgICAgICB0ZVsgNCBdID0gMDtcbiAgICAgICAgdGVbIDggXSA9IDA7XG4gICAgICAgIHRlWyAxMiBdID0gLXg7XG4gICAgICAgIHRlWyAxIF0gPSAwO1xuICAgICAgICB0ZVsgNSBdID0gMiAvIGg7XG4gICAgICAgIHRlWyA5IF0gPSAwO1xuICAgICAgICB0ZVsgMTMgXSA9IC15O1xuICAgICAgICB0ZVsgMiBdID0gMDtcbiAgICAgICAgdGVbIDYgXSA9IDA7XG4gICAgICAgIHRlWyAxMCBdID0gLTIgLyBwO1xuICAgICAgICB0ZVsgMTQgXSA9IC16O1xuICAgICAgICB0ZVsgMyBdID0gMDtcbiAgICAgICAgdGVbIDcgXSA9IDA7XG4gICAgICAgIHRlWyAxMSBdID0gMDtcbiAgICAgICAgdGVbIDE1IF0gPSAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIG1hdHJpeCApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkrKyApIHtcblxuICAgICAgICAgICAgaWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSApIHtcblxuICAgICAgICB0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLCB0ZVsgMyBdLFxuICAgICAgICAgICAgdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSwgdGVbIDcgXSxcbiAgICAgICAgICAgIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdLCB0ZVsgMTEgXSxcbiAgICAgICAgICAgIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0sIHRlWyAxNSBdXG4gICAgICAgIF07XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUmF5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUmF5ID0gZnVuY3Rpb24oIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG4gICAgdGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuUmF5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5SYXksXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICAgICAgICB0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggcmF5ICkge1xuXG4gICAgICAgIHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGF0OiBmdW5jdGlvbiggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gICAgfSxcblxuICAgIHJlY2FzdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmNvcHkoIHRoaXMuYXQoIHQsIHYxICkgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJlc3VsdC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgICAgICBpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVNxVG9Qb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICAgICAgICAgIC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XG5cbiAgICAgICAgICAgIGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICAgICAgICByZXR1cm4gdjEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgc2VnRGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIGRpZmYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cbiAgICAgICAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvRGlzdGFuY2UvV201RGlzdFJheTNTZWdtZW50My5jcHBcbiAgICAgICAgICAgIC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAvLyBkZWZpbmVkIGJ5IHYwIGFuZCB2MVxuICAgICAgICAgICAgLy8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcbiAgICAgICAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxuICAgICAgICAgICAgLy8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxuXG4gICAgICAgICAgICBzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuICAgICAgICAgICAgc2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgZGlmZi5jb3B5KCB0aGlzLm9yaWdpbiApLnN1Yiggc2VnQ2VudGVyICk7XG5cbiAgICAgICAgICAgIHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xuICAgICAgICAgICAgdmFyIGEwMSA9IC10aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xuICAgICAgICAgICAgdmFyIGIwID0gZGlmZi5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG4gICAgICAgICAgICB2YXIgYjEgPSAtZGlmZi5kb3QoIHNlZ0RpciApO1xuICAgICAgICAgICAgdmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XG4gICAgICAgICAgICB2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcbiAgICAgICAgICAgIHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuICAgICAgICAgICAgaWYgKCBkZXQgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJheSBhbmQgc2VnbWVudCBhcmUgbm90IHBhcmFsbGVsLlxuXG4gICAgICAgICAgICAgICAgczAgPSBhMDEgKiBiMSAtIGIwO1xuICAgICAgICAgICAgICAgIHMxID0gYTAxICogYjAgLSBiMTtcbiAgICAgICAgICAgICAgICBleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHMwID49IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzMSA+PSAtZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludkRldCA9IDEgLyBkZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgKj0gaW52RGV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxICo9IGludkRldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiAxXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHNlZ0V4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtKCBhMDEgKiBzMSArIGIwICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gNVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IC1zZWdFeHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtKCBhMDEgKiBzMSArIGIwICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzMSA8PSAtZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gNFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtKCAtYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSAoIHMwID4gMCApID8gLXNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLXNlZ0V4dGVudCwgLWIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDNcblxuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC1zZWdFeHRlbnQsIC1iMSApLCBzZWdFeHRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDJcblxuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtc2VnRXh0ZW50LCAtYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXG5cbiAgICAgICAgICAgICAgICBzMSA9ICggYTAxID4gMCApID8gLXNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcbiAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtKCBhMDEgKiBzMSArIGIwICkgKTtcbiAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIgKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzcXJEaXN0O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cblxuICAgIGlzSW50ZXJzZWN0aW9uU3BoZXJlOiBmdW5jdGlvbiggc3BoZXJlICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXM7XG5cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuc2NyYXRjaGFwaXhlbC5jb20vbGVzc29ucy8zZC1iYXNpYy1sZXNzb25zL2xlc3Nvbi03LWludGVyc2VjdGluZy1zaW1wbGUtc2hhcGVzL3JheS1zcGhlcmUtaW50ZXJzZWN0aW9uL1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICAgICAgICB2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgICAgICAgICB2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XG5cbiAgICAgICAgICAgIHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cbiAgICAgICAgICAgIGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG4gICAgICAgICAgICAvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuICAgICAgICAgICAgdmFyIHQwID0gdGNhIC0gdGhjO1xuXG4gICAgICAgICAgICAvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG4gICAgICAgICAgICB2YXIgdDEgPSB0Y2EgKyB0aGM7XG5cbiAgICAgICAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgaWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuICAgICAgICAgICAgLy8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuICAgICAgICAgICAgaWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSgpLFxuXG4gICAgaXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24oIHBsYW5lICkge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcblxuICAgICAgICB2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgICAgaWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICAgICAgaWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiggcGxhbmUgKSB7XG5cbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcbiAgICAgICAgaWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuICAgICAgICAgICAgLy8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgICAgICAgICAgaWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IC0oIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICAgICAgLy8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcblxuICAgICAgICByZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XG5cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uKCBwbGFuZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcblxuICAgICAgICBpZiAoIHQgPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hdCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIH0sXG5cbiAgICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgdiApICE9PSBudWxsO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKCBib3gsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuc2NyYXRjaGFwaXhlbC5jb20vbGVzc29ucy8zZC1iYXNpYy1sZXNzb25zL2xlc3Nvbi03LWludGVyc2VjdGluZy1zaW1wbGUtc2hhcGVzL3JheS1ib3gtaW50ZXJzZWN0aW9uL1xuXG4gICAgICAgIHZhciB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblxuICAgICAgICB2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxuICAgICAgICAgICAgaW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxuICAgICAgICAgICAgaW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuICAgICAgICBpZiAoIGludmRpcnggPj0gMCApIHtcblxuICAgICAgICAgICAgdG1pbiA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG4gICAgICAgICAgICB0bWF4ID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcbiAgICAgICAgICAgIHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGludmRpcnkgPj0gMCApIHtcblxuICAgICAgICAgICAgdHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgICAgICAgICAgdHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcbiAgICAgICAgICAgIHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXG4gICAgICAgIC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cblxuICAgICAgICBpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xuXG4gICAgICAgIGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XG5cbiAgICAgICAgaWYgKCBpbnZkaXJ6ID49IDAgKSB7XG5cbiAgICAgICAgICAgIHR6bWluID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcbiAgICAgICAgICAgIHR6bWF4ID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgICAgICAgICB0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgaWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuICAgICAgICBpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xuXG4gICAgICAgIC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcblxuICAgICAgICBpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoIHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cbiAgICAgICAgdmFyIGRpZmYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgZWRnZTEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvSW50ZXJzZWN0aW9uL1dtNUludHJSYXkzVHJpYW5nbGUzLmNwcFxuXG4gICAgICAgICAgICBlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XG4gICAgICAgICAgICBlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG4gICAgICAgICAgICBub3JtYWwuY3Jvc3NWZWN0b3JzKCBlZGdlMSwgZWRnZTIgKTtcblxuICAgICAgICAgICAgLy8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXG4gICAgICAgICAgICAvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG4gICAgICAgICAgICAvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcbiAgICAgICAgICAgIC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxuICAgICAgICAgICAgLy8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcbiAgICAgICAgICAgIHZhciBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIG5vcm1hbCApO1xuICAgICAgICAgICAgdmFyIHNpZ247XG5cbiAgICAgICAgICAgIGlmICggRGROID4gMCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgc2lnbiA9IDE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBEZE4gPCAwICkge1xuXG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgICAgIERkTiA9IC1EZE47XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlmZi5zdWJWZWN0b3JzKCB0aGlzLm9yaWdpbiwgYSApO1xuICAgICAgICAgICAgdmFyIERkUXhFMiA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UyLmNyb3NzVmVjdG9ycyggZGlmZiwgZWRnZTIgKSApO1xuXG4gICAgICAgICAgICAvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgICAgICAgICAgaWYgKCBEZFF4RTIgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcblxuICAgICAgICAgICAgLy8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIGlmICggRGRFMXhRIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICBpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXG4gICAgICAgICAgICB2YXIgUWROID0gLXNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XG5cbiAgICAgICAgICAgIC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIGlmICggUWROIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiggbWF0cml4NCApIHtcblxuICAgICAgICB0aGlzLmRpcmVjdGlvbi5hZGQoIHRoaXMub3JpZ2luICkuYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG4gICAgICAgIHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbi5zdWIoIHRoaXMub3JpZ2luICk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHJheSApIHtcblxuICAgICAgICByZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvU3BoZXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNwaGVyZSA9IGZ1bmN0aW9uKCBjZW50ZXIsIHJhZGl1cyApIHtcblxuICAgIHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XG5cbn07XG5cblRIUkVFLlNwaGVyZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuU3BoZXJlLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggY2VudGVyLCByYWRpdXMgKSB7XG5cbiAgICAgICAgdGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcblxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBib3guc2V0RnJvbVBvaW50cyggcG9pbnRzICkuY2VudGVyKCBjZW50ZXIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzcGhlcmUgKSB7XG5cbiAgICAgICAgdGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcblxuICAgIH0sXG5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgcmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICByZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiggc3BoZXJlICkge1xuXG4gICAgICAgIHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cbiAgICAgICAgcmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcblxuICAgIH0sXG5cbiAgICBjbGFtcFBvaW50OiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJlc3VsdC5jb3B5KCBwb2ludCApO1xuXG4gICAgICAgIGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG4gICAgICAgICAgICByZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0sXG5cbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgICAgIGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuICAgICAgICBib3guZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XG5cbiAgICAgICAgcmV0dXJuIGJveDtcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uKCBtYXRyaXggKSB7XG5cbiAgICAgICAgdGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oIG9mZnNldCApIHtcblxuICAgICAgICB0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHNwaGVyZSApIHtcblxuICAgICAgICByZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0ZydXN0dW0uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkZydXN0dW0gPSBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuICAgIHRoaXMucGxhbmVzID0gW1xuXG4gICAgICAgICggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgVEhSRUUuUGxhbmUoKSwgKCBwMSAhPT0gdW5kZWZpbmVkICkgPyBwMSA6IG5ldyBUSFJFRS5QbGFuZSgpLCAoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksICggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgVEhSRUUuUGxhbmUoKSwgKCBwNCAhPT0gdW5kZWZpbmVkICkgPyBwNCA6IG5ldyBUSFJFRS5QbGFuZSgpLCAoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcblxuICAgIF07XG5cbn07XG5cblRIUkVFLkZydXN0dW0ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkZydXN0dW0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgICAgICBwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xuICAgICAgICBwbGFuZXNbIDEgXS5jb3B5KCBwMSApO1xuICAgICAgICBwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xuICAgICAgICBwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xuICAgICAgICBwbGFuZXNbIDQgXS5jb3B5KCBwNCApO1xuICAgICAgICBwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIGZydXN0dW0gKSB7XG5cbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgcGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG4gICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG4gICAgICAgIHZhciBtZTAgPSBtZVsgMCBdLFxuICAgICAgICAgICAgbWUxID0gbWVbIDEgXSxcbiAgICAgICAgICAgIG1lMiA9IG1lWyAyIF0sXG4gICAgICAgICAgICBtZTMgPSBtZVsgMyBdO1xuICAgICAgICB2YXIgbWU0ID0gbWVbIDQgXSxcbiAgICAgICAgICAgIG1lNSA9IG1lWyA1IF0sXG4gICAgICAgICAgICBtZTYgPSBtZVsgNiBdLFxuICAgICAgICAgICAgbWU3ID0gbWVbIDcgXTtcbiAgICAgICAgdmFyIG1lOCA9IG1lWyA4IF0sXG4gICAgICAgICAgICBtZTkgPSBtZVsgOSBdLFxuICAgICAgICAgICAgbWUxMCA9IG1lWyAxMCBdLFxuICAgICAgICAgICAgbWUxMSA9IG1lWyAxMSBdO1xuICAgICAgICB2YXIgbWUxMiA9IG1lWyAxMiBdLFxuICAgICAgICAgICAgbWUxMyA9IG1lWyAxMyBdLFxuICAgICAgICAgICAgbWUxNCA9IG1lWyAxNCBdLFxuICAgICAgICAgICAgbWUxNSA9IG1lWyAxNSBdO1xuXG4gICAgICAgIHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xuICAgICAgICBwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XG4gICAgICAgIHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xuICAgICAgICBwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XG4gICAgICAgIHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgICAgICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgICAgICAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uKCBzcGhlcmUgKSB7XG5cbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuICAgICAgICB2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcbiAgICAgICAgdmFyIG5lZ1JhZGl1cyA9IC1zcGhlcmUucmFkaXVzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcblxuICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RzQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgcDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBwbGFuZSA9IHBsYW5lc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgcDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcbiAgICAgICAgICAgICAgICBwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuICAgICAgICAgICAgICAgIHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XG4gICAgICAgICAgICAgICAgcDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcbiAgICAgICAgICAgICAgICBwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xuICAgICAgICAgICAgICAgIHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XG5cbiAgICAgICAgICAgICAgICB2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgYm90aCBvdXRzaWRlIHBsYW5lLCBubyBpbnRlcnNlY3Rpb25cblxuICAgICAgICAgICAgICAgIGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgIGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9QbGFuZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLlBsYW5lID0gZnVuY3Rpb24oIG5vcm1hbCwgY29uc3RhbnQgKSB7XG5cbiAgICB0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG4gICAgdGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xuXG59O1xuXG5USFJFRS5QbGFuZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUGxhbmUsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG4gICAgICAgIHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgICAgICB0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0Q29tcG9uZW50czogZnVuY3Rpb24oIHgsIHksIHosIHcgKSB7XG5cbiAgICAgICAgdGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiggbm9ybWFsLCBwb2ludCApIHtcblxuICAgICAgICB0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IC1wb2ludC5kb3QoIHRoaXMubm9ybWFsICk7IC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tQ29wbGFuYXJQb2ludHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBhLCBiLCBjICkge1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgLy8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cblxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBwbGFuZSApIHtcblxuICAgICAgICB0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXG5cbiAgICAgICAgdmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcbiAgICAgICAgdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jb25zdGFudCAqPSAtMTtcbiAgICAgICAgdGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24oIHNwaGVyZSApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XG5cbiAgICB9LFxuXG4gICAgcHJvamVjdFBvaW50OiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9ydGhvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApLnN1YiggcG9pbnQgKS5uZWdhdGUoKTtcblxuICAgIH0sXG5cbiAgICBvcnRob1BvaW50OiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciBwZXJwZW5kaWN1bGFyTWFnbml0dWRlID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggcGVycGVuZGljdWxhck1hZ25pdHVkZSApO1xuXG4gICAgfSxcblxuICAgIGlzSW50ZXJzZWN0aW9uTGluZTogZnVuY3Rpb24oIGxpbmUgKSB7XG5cbiAgICAgICAgLy8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXG5cbiAgICAgICAgdmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG4gICAgICAgIHZhciBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XG5cbiAgICAgICAgcmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG4gICAgICAgICAgICBpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgLy8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKSA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHQgPSAtKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG4gICAgICAgICAgICBpZiAoIHQgPCAwIHx8IHQgPiAxICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuXG4gICAgY29wbGFuYXJQb2ludDogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC10aGlzLmNvbnN0YW50ICk7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcblxuICAgICAgICAgICAgLy8gY29tcHV0ZSBuZXcgbm9ybWFsIGJhc2VkIG9uIHRoZW9yeSBoZXJlOlxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXG4gICAgICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcbiAgICAgICAgICAgIHZhciBuZXdOb3JtYWwgPSB2MS5jb3B5KCB0aGlzLm5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICk7XG5cbiAgICAgICAgICAgIHZhciBuZXdDb3BsYW5hclBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MiApO1xuICAgICAgICAgICAgbmV3Q29wbGFuYXJQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgICAgICAgICB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBuZXdOb3JtYWwsIG5ld0NvcGxhbmFyUG9pbnQgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oIG9mZnNldCApIHtcblxuICAgICAgICB0aGlzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudCAtIG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggcGxhbmUgKSB7XG5cbiAgICAgICAgcmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRoID0ge1xuXG4gICAgZ2VuZXJhdGVVVUlEOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBodHRwOi8vd3d3LmJyb29mYS5jb20vVG9vbHMvTWF0aC51dWlkLmh0bVxuXG4gICAgICAgIHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoICcnICk7XG4gICAgICAgIHZhciB1dWlkID0gbmV3IEFycmF5KCAzNiApO1xuICAgICAgICB2YXIgcm5kID0gMCxcbiAgICAgICAgICAgIHI7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpID09PSA4IHx8IGkgPT09IDEzIHx8IGkgPT09IDE4IHx8IGkgPT09IDIzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHV1aWRbIGkgXSA9ICctJztcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggaSA9PT0gMTQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdXVpZFsgaSBdID0gJzQnO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBybmQgJiAweGY7XG4gICAgICAgICAgICAgICAgICAgIHJuZCA9IHJuZCA+PiA0O1xuICAgICAgICAgICAgICAgICAgICB1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV1aWQuam9pbiggJycgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgLy8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XG5cbiAgICBjbGFtcDogZnVuY3Rpb24oIHgsIGEsIGIgKSB7XG5cbiAgICAgICAgcmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7XG5cbiAgICB9LFxuXG4gICAgLy8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGluZilcblxuICAgIGNsYW1wQm90dG9tOiBmdW5jdGlvbiggeCwgYSApIHtcblxuICAgICAgICByZXR1cm4geCA8IGEgPyBhIDogeDtcblxuICAgIH0sXG5cbiAgICAvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXG5cbiAgICBldWNsaWRlYW5Nb2R1bG86IGZ1bmN0aW9uKCBuLCBtICkge1xuXG4gICAgICAgIHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbiAgICB9LFxuXG4gICAgLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuXG4gICAgbWFwTGluZWFyOiBmdW5jdGlvbiggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cbiAgICAgICAgcmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XG5cbiAgICB9LFxuXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXG5cbiAgICBzbW9vdGhzdGVwOiBmdW5jdGlvbiggeCwgbWluLCBtYXggKSB7XG5cbiAgICAgICAgaWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuICAgICAgICBpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cbiAgICAgICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuICAgICAgICByZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG4gICAgfSxcblxuICAgIHNtb290aGVyc3RlcDogZnVuY3Rpb24oIHgsIG1pbiwgbWF4ICkge1xuXG4gICAgICAgIGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgICAgIHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cbiAgICAgICAgcmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxuICAgIH0sXG5cbiAgICAvLyBSYW5kb20gZmxvYXQgZnJvbSA8MCwgMT4gd2l0aCAxNiBiaXRzIG9mIHJhbmRvbW5lc3NcbiAgICAvLyAoc3RhbmRhcmQgTWF0aC5yYW5kb20oKSBjcmVhdGVzIHJlcGV0aXRpdmUgcGF0dGVybnMgd2hlbiBhcHBsaWVkIG92ZXIgbGFyZ2VyIHNwYWNlKVxuXG4gICAgcmFuZG9tMTY6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAoIDY1MjgwICogTWF0aC5yYW5kb20oKSArIDI1NSAqIE1hdGgucmFuZG9tKCkgKSAvIDY1NTM1O1xuXG4gICAgfSxcblxuICAgIC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuICAgIHJhbmRJbnQ6IGZ1bmN0aW9uKCBsb3csIGhpZ2ggKSB7XG5cbiAgICAgICAgcmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxuICAgIH0sXG5cbiAgICAvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG4gICAgcmFuZEZsb2F0OiBmdW5jdGlvbiggbG93LCBoaWdoICkge1xuXG4gICAgICAgIHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XG5cbiAgICB9LFxuXG4gICAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG4gICAgcmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiggcmFuZ2UgKSB7XG5cbiAgICAgICAgcmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XG5cbiAgICB9LFxuXG4gICAgZGVnVG9SYWQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkZWdyZWVUb1JhZGlhbnNGYWN0b3IgPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGVncmVlcyApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBkZWdyZWVUb1JhZGlhbnNGYWN0b3I7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJhZFRvRGVnOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcmFkaWFuVG9EZWdyZWVzRmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHJhZGlhbnMgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiByYWRpYW5zICogcmFkaWFuVG9EZWdyZWVzRmFjdG9yO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICByZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxuICAgIH0sXG5cbiAgICBuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHZhbHVlLS07XG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDE7XG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDI7XG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDQ7XG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDg7XG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDE2O1xuICAgICAgICB2YWx1ZSsrO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9TcGxpbmUuanNcblxuLyoqXG4gKiBTcGxpbmUgZnJvbSBUd2Vlbi5qcywgc2xpZ2h0bHkgb3B0aW1pemVkIChhbmQgdHJhc2hlZClcbiAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcbiAqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcGxpbmUgPSBmdW5jdGlvbiggcG9pbnRzICkge1xuXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgICB2YXIgYyA9IFtdLFxuICAgICAgICB2MyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgejogMFxuICAgICAgICB9LFxuICAgICAgICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxuICAgICAgICBwYSwgcGIsIHBjLCBwZDtcblxuICAgIHRoaXMuaW5pdEZyb21BcnJheSA9IGZ1bmN0aW9uKCBhICkge1xuXG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5wb2ludHNbIGkgXSA9IHtcbiAgICAgICAgICAgICAgICB4OiBhWyBpIF1bIDAgXSxcbiAgICAgICAgICAgICAgICB5OiBhWyBpIF1bIDEgXSxcbiAgICAgICAgICAgICAgICB6OiBhWyBpIF1bIDIgXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uKCBrICkge1xuXG4gICAgICAgIHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xuICAgICAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgICAgY1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcbiAgICAgICAgY1sgMSBdID0gaW50UG9pbnQ7XG4gICAgICAgIGNbIDIgXSA9IGludFBvaW50ID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMiA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XG4gICAgICAgIGNbIDMgXSA9IGludFBvaW50ID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMyA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDI7XG5cbiAgICAgICAgcGEgPSB0aGlzLnBvaW50c1sgY1sgMCBdIF07XG4gICAgICAgIHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xuICAgICAgICBwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcbiAgICAgICAgcGQgPSB0aGlzLnBvaW50c1sgY1sgMyBdIF07XG5cbiAgICAgICAgdzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG4gICAgICAgIHczID0gd2VpZ2h0ICogdzI7XG5cbiAgICAgICAgdjMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgICB2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XG4gICAgICAgIHYzLnogPSBpbnRlcnBvbGF0ZSggcGEueiwgcGIueiwgcGMueiwgcGQueiwgd2VpZ2h0LCB3MiwgdzMgKTtcblxuICAgICAgICByZXR1cm4gdjM7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGNvb3JkcyA9IFtdO1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBwID0gdGhpcy5wb2ludHNbIGkgXTtcbiAgICAgICAgICAgIGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb29yZHM7XG5cbiAgICB9O1xuXG4gICAgLy8gYXBwcm94aW1hdGUgbGVuZ3RoIGJ5IHN1bW1pbmcgbGluZWFyIHNlZ21lbnRzXG5cbiAgICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKCBuU3ViRGl2aXNpb25zICkge1xuXG4gICAgICAgIHZhciBpLCBpbmRleCwgblNhbXBsZXMsIHBvc2l0aW9uLFxuICAgICAgICAgICAgcG9pbnQgPSAwLFxuICAgICAgICAgICAgaW50UG9pbnQgPSAwLFxuICAgICAgICAgICAgb2xkSW50UG9pbnQgPSAwLFxuICAgICAgICAgICAgb2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgdG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIGNodW5rTGVuZ3RocyA9IFtdLFxuICAgICAgICAgICAgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxuXG4gICAgICAgIGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcblxuICAgICAgICBpZiAoICFuU3ViRGl2aXNpb25zICkgblN1YkRpdmlzaW9ucyA9IDEwMDtcblxuICAgICAgICBuU2FtcGxlcyA9IHRoaXMucG9pbnRzLmxlbmd0aCAqIG5TdWJEaXZpc2lvbnM7XG5cbiAgICAgICAgb2xkUG9zaXRpb24uY29weSggdGhpcy5wb2ludHNbIDAgXSApO1xuXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgblNhbXBsZXM7IGkrKyApIHtcblxuICAgICAgICAgICAgaW5kZXggPSBpIC8gblNhbXBsZXM7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcbiAgICAgICAgICAgIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xuXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSB0bXBWZWMuZGlzdGFuY2VUbyggb2xkUG9zaXRpb24gKTtcblxuICAgICAgICAgICAgb2xkUG9zaXRpb24uY29weSggcG9zaXRpb24gKTtcblxuICAgICAgICAgICAgcG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xuICAgICAgICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXG4gICAgICAgICAgICBpZiAoIGludFBvaW50ICE9PSBvbGRJbnRQb2ludCApIHtcblxuICAgICAgICAgICAgICAgIGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG9sZEludFBvaW50ID0gaW50UG9pbnQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXG5cbiAgICAgICAgY2h1bmtMZW5ndGhzWyBjaHVua0xlbmd0aHMubGVuZ3RoIF0gPSB0b3RhbExlbmd0aDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2h1bmtzOiBjaHVua0xlbmd0aHMsXG4gICAgICAgICAgICB0b3RhbDogdG90YWxMZW5ndGhcbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICB0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uKCBzYW1wbGluZ0NvZWYgKSB7XG5cbiAgICAgICAgdmFyIGksIGosXG4gICAgICAgICAgICBpbmRleCwgaW5kZXhDdXJyZW50LCBpbmRleE5leHQsXG4gICAgICAgICAgICByZWFsRGlzdGFuY2UsXG4gICAgICAgICAgICBzYW1wbGluZywgcG9zaXRpb24sXG4gICAgICAgICAgICBuZXdwb2ludHMgPSBbXSxcbiAgICAgICAgICAgIHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cbiAgICAgICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xuXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIC8vdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIC0gMSBdICk7XG4gICAgICAgICAgICAvL2xpbmVhckRpc3RhbmNlID0gdG1wVmVjLmRpc3RhbmNlVG8oIHRoaXMucG9pbnRzWyBpIF0gKTtcblxuICAgICAgICAgICAgcmVhbERpc3RhbmNlID0gc2wuY2h1bmtzWyBpIF0gLSBzbC5jaHVua3NbIGkgLSAxIF07XG5cbiAgICAgICAgICAgIHNhbXBsaW5nID0gTWF0aC5jZWlsKCBzYW1wbGluZ0NvZWYgKiByZWFsRGlzdGFuY2UgLyBzbC50b3RhbCApO1xuXG4gICAgICAgICAgICBpbmRleEN1cnJlbnQgPSAoIGkgLSAxICkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgICAgICAgICAgIGluZGV4TmV4dCA9IGkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcblxuICAgICAgICAgICAgZm9yICggaiA9IDE7IGogPCBzYW1wbGluZyAtIDE7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXhDdXJyZW50ICsgaiAqICggMSAvIHNhbXBsaW5nICkgKiAoIGluZGV4TmV4dCAtIGluZGV4Q3VycmVudCApO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuICAgICAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcblxuICAgIH07XG5cbiAgICAvLyBDYXRtdWxsLVJvbVxuXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cbiAgICAgICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXG4gICAgICAgICAgICB2MSA9ICggcDMgLSBwMSApICogMC41O1xuXG4gICAgICAgIHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVHJpYW5nbGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuVHJpYW5nbGUgPSBmdW5jdGlvbiggYSwgYiwgYyApIHtcblxuICAgIHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5UcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJlc3VsdC5zdWJWZWN0b3JzKCBjLCBiICk7XG4gICAgICAgIHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcbiAgICAgICAgcmVzdWx0LmNyb3NzKCB2MCApO1xuXG4gICAgICAgIHZhciByZXN1bHRMZW5ndGhTcSA9IHJlc3VsdC5sZW5ndGhTcSgpO1xuICAgICAgICBpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMCApO1xuXG4gICAgfTtcblxufSgpO1xuXG4vLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2MC5zdWJWZWN0b3JzKCBjLCBhICk7XG4gICAgICAgIHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcbiAgICAgICAgdjIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuICAgICAgICB2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XG4gICAgICAgIHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcbiAgICAgICAgdmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuICAgICAgICB2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XG4gICAgICAgIHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuICAgICAgICB2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG4gICAgICAgIGlmICggZGVub20gPT09IDAgKSB7XG5cbiAgICAgICAgICAgIC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xuICAgICAgICAgICAgLy8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIC0yLCAtMSwgLTEgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xuICAgICAgICB2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuICAgICAgICB2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG4gICAgICAgIC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcblxuICAgIH07XG5cbn0oKTtcblxuVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiggcG9pbnQsIGEsIGIsIGMgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XG5cbiAgICAgICAgcmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xuXG4gICAgfTtcblxufSgpO1xuXG5USFJFRS5UcmlhbmdsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBhLCBiLCBjICkge1xuXG4gICAgICAgIHRoaXMuYS5jb3B5KCBhICk7XG4gICAgICAgIHRoaXMuYi5jb3B5KCBiICk7XG4gICAgICAgIHRoaXMuYy5jb3B5KCBjICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cbiAgICAgICAgdGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xuICAgICAgICB0aGlzLmIuY29weSggcG9pbnRzWyBpMSBdICk7XG4gICAgICAgIHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCB0cmlhbmdsZSApIHtcblxuICAgICAgICB0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xuICAgICAgICB0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xuICAgICAgICB0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFyZWE6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xuICAgICAgICAgICAgdjEuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBtaWRwb2ludDogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcblxuICAgIH0sXG5cbiAgICBub3JtYWw6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgfSxcblxuICAgIHBsYW5lOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5QbGFuZSgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cbiAgICB9LFxuXG4gICAgYmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgfSxcblxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCB0cmlhbmdsZSApIHtcblxuICAgICAgICByZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvQ2xvY2suanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkNsb2NrID0gZnVuY3Rpb24oIGF1dG9TdGFydCApIHtcblxuICAgIHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLm9sZFRpbWUgPSAwO1xuICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkNsb2NrLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiBzZWxmLnBlcmZvcm1hbmNlLm5vdyAhPT0gdW5kZWZpbmVkID8gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCk7XG5cbiAgICAgICAgdGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIH0sXG5cbiAgICBnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5nZXREZWx0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbGFwc2VkVGltZTtcblxuICAgIH0sXG5cbiAgICBnZXREZWx0YTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRpZmYgPSAwO1xuXG4gICAgICAgIGlmICggdGhpcy5hdXRvU3RhcnQgJiYgIXRoaXMucnVubmluZyApIHtcblxuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMucnVubmluZyApIHtcblxuICAgICAgICAgICAgdmFyIG5ld1RpbWUgPSBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCA/IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICBkaWZmID0gMC4wMDEgKiAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKTtcbiAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XG5cbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpZmY7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzXG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG4gKi9cblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24oKSB7fTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5FdmVudERpc3BhdGNoZXIsXG5cbiAgICBhcHBseTogZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgb2JqZWN0Lmhhc0V2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmhhc0V2ZW50TGlzdGVuZXI7XG4gICAgICAgIG9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblxuICAgIH0sXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0xICkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtMSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH0sXG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG4gICAgICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XG5cbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IC0xICkge1xuXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgYXJyYXlbIGkgXSA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9SYXljYXN0ZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tL1xuICogQGF1dGhvciBzdGVwaG9taSAvIGh0dHA6Ly9zdGVwaGFuZWdpbmllci5jb20vXG4gKi9cblxuKCBmdW5jdGlvbiggVEhSRUUgKSB7XG5cbiAgICBUSFJFRS5SYXljYXN0ZXIgPSBmdW5jdGlvbiggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcblxuICAgICAgICB0aGlzLnJheSA9IG5ldyBUSFJFRS5SYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XG4gICAgICAgIC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cbiAgICAgICAgdGhpcy5uZWFyID0gbmVhciB8fCAwO1xuICAgICAgICB0aGlzLmZhciA9IGZhciB8fCBJbmZpbml0eTtcblxuICAgICAgICB0aGlzLnBhcmFtcyA9IHtcbiAgICAgICAgICAgIE1lc2g6IHt9LFxuICAgICAgICAgICAgTGluZToge30sXG4gICAgICAgICAgICBMT0Q6IHt9LFxuICAgICAgICAgICAgUG9pbnRzOiB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU3ByaXRlOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xuICAgICAgICAgICAgUG9pbnRDbG91ZDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3RlcjogcGFyYW1zLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBwYXJhbXMuUG9pbnRzLicgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuUG9pbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlc2NTb3J0KCBhLCBiICkge1xuXG4gICAgICAgIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcblxuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3RPYmplY3QgPSBmdW5jdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICBvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cbiAgICAgICAgaWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvL1xuXG4gICAgVEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUmF5Y2FzdGVyLFxuXG4gICAgICAgIGxpbmVQcmVjaXNpb246IDEsXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICAgICAgICAgIC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cbiAgICAgICAgICAgIHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uKCBjb29yZHMsIGNhbWVyYSApIHtcblxuICAgICAgICAgICAgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yYXkub3JpZ2luLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAtMSApLnVucHJvamVjdCggY2FtZXJhICk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLTEgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RzID0gW107XG5cbiAgICAgICAgICAgIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuICAgICAgICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0cztcblxuICAgICAgICB9LFxuXG4gICAgICAgIGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RzID0gW107XG5cbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0cyApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0cztcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCBUSFJFRSApICk7XG5cbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZWxlcGhhbnRhdHdvcmsgLyB3d3cuZWxlcGhhbnRhdHdvcmsuY2hcbiAqL1xuXG5USFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBUSFJFRS5PYmplY3QzRElkQ291bnQrK1xuICAgIH0gKTtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMudXAgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcblxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHJvdGF0aW9uID0gbmV3IFRIUkVFLkV1bGVyKCk7XG4gICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XG5cbiAgICB2YXIgb25Sb3RhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcblxuICAgIH07XG5cbiAgICB2YXIgb25RdWF0ZXJuaW9uQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblxuICAgIH07XG5cbiAgICByb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xuICAgIHF1YXRlcm5pb24ub25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcG9zaXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcm90YXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgcXVhdGVybmlvbjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBxdWF0ZXJuaW9uXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHNjYWxlXG4gICAgICAgIH0sXG4gICAgICAgIG1vZGVsVmlld01hdHJpeDoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KClcbiAgICAgICAgfSxcbiAgICAgICAgbm9ybWFsTWF0cml4OiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLk1hdHJpeDMoKVxuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0cnVlO1xuXG4gICAgdGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHRoaXMubWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gVEhSRUUuT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XG4gICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gICAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgdGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG5cbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyT3JkZXIgPSAwO1xuXG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuXG59O1xuXG5USFJFRS5PYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5USFJFRS5PYmplY3QzRC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0M0QsXG5cbiAgICBnZXQgZXVsZXJPcmRlcigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gLnJvdGF0aW9uLm9yZGVyLicgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbi5vcmRlcjtcblxuICAgIH0sXG5cbiAgICBzZXQgZXVsZXJPcmRlciggdmFsdWUgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGhhcyBiZWVuIG1vdmVkIHRvIC5yb3RhdGlvbi5vcmRlci4nICk7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIGdldCB1c2VRdWF0ZXJuaW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuICAgIH0sXG5cbiAgICBzZXQgdXNlUXVhdGVybmlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG4gICAgfSxcblxuICAgIHNldCByZW5kZXJEZXB0aCggdmFsdWUgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5yZW5kZXJEZXB0aCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnJlbmRlck9yZGVyLCBpbnN0ZWFkLicgKTtcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDogZnVuY3Rpb24oIG1hdHJpeCApIHtcblxuICAgICAgICB0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuICAgIH0sXG5cbiAgICBzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uKCBheGlzLCBhbmdsZSApIHtcblxuICAgICAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG4gICAgfSxcblxuICAgIHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiggZXVsZXIgKSB7XG5cbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcblxuICAgIH0sXG5cbiAgICBzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG4gICAgfSxcblxuICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uKCBxICkge1xuXG4gICAgICAgIC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXG5cbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcblxuICAgIH0sXG5cbiAgICByb3RhdGVPbkF4aXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcbiAgICAgICAgLy8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgICAgICB2YXIgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZVg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlWTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGFuZ2xlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVaOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuICAgICAgICAvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBheGlzLCBkaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgdjEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XG5cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkKCB2MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiggZGlzdGFuY2UsIGF4aXMgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xuXG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZVg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBkaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlWTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGVaOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgfSxcblxuICAgIHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIG0xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBsb29rQXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG4gICAgICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgICAgIG0xLmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XG5cbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGFkZDogZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QgKSB7XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZGVkJ1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiLCBvYmplY3QgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVkJ1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZSggbmFtZSApO1xuXG4gICAgfSxcblxuICAgIGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uKCBpZCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG4gICAgfSxcblxuICAgIGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0T2JqZWN0QnlQcm9wZXJ0eTogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXG4gICAgICAgIGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIH0sXG5cbiAgICBnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcmVzdWx0LCBzY2FsZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5FdWxlcigpO1xuXG4gICAgICAgICAgICB0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB0aGlzLnJvdGF0aW9uLm9yZGVyLCBmYWxzZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBnZXRXb3JsZFNjYWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZ2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcmF5Y2FzdDogZnVuY3Rpb24oKSB7fSxcblxuICAgIHRyYXZlcnNlOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgY2FsbGJhY2soIHRoaXMgKTtcblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgY2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIGNhbGxiYWNrKCB0aGlzICk7XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgICAgICBpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgY2FsbGJhY2soIHBhcmVudCApO1xuXG4gICAgICAgICAgICBwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICB1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24oIGZvcmNlICkge1xuXG4gICAgICAgIGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICBpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZHJlblxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICAgICAgdmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkICk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgICAvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuICAgICAgICAvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxuICAgICAgICAvLyBiZWluZyBzZXJpYWxpemVkLlxuICAgICAgICBpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuICAgICAgICAgICAgbWV0YSA9IHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyaWVzOiB7fSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHM6IHt9LFxuICAgICAgICAgICAgICAgIHRleHR1cmVzOiB7fSxcbiAgICAgICAgICAgICAgICBpbWFnZXM6IHt9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkYXRhLm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnT2JqZWN0JyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cbiAgICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgICAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcbiAgICAgICAgaWYgKCB0aGlzLnZpc2libGUgIT09IHRydWUgKSBkYXRhLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cbiAgICAgICAgZGF0YS5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XG5cbiAgICAgICAgaWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIGRhdGEuY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGRhdGEuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSB7fTtcblxuICAgICAgICBpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuICAgICAgICAgICAgdmFyIGdlb21ldHJpZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmdlb21ldHJpZXMgKTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xuICAgICAgICAgICAgdmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuICAgICAgICAgICAgdmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG4gICAgICAgICAgICBpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgICAgICAgICAgIGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQub2JqZWN0ID0gZGF0YTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgICAgIC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG4gICAgICAgIC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cbiAgICAgICAgLy8gYW5kIHJldHVybiBhcyBhcnJheVxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiggcmVjdXJzaXZlICkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuICAgICAgICB0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuICAgICAgICB0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xuXG4gICAgICAgIHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gc291cmNlLnJvdGF0aW9uQXV0b1VwZGF0ZTtcblxuICAgICAgICB0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG4gICAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG4gICAgICAgIHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuICAgICAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcblxuICAgICAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcbiAgICAgICAgdGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuICAgICAgICB0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XG5cbiAgICAgICAgaWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5USFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2UzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRmFjZTMgPSBmdW5jdGlvbiggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuXG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xuXG4gICAgdGhpcy5jb2xvciA9IGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyBjb2xvciA6IG5ldyBUSFJFRS5Db2xvcigpO1xuICAgIHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XG5cbiAgICB0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcblxufTtcblxuVEhSRUUuRmFjZTMucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkZhY2UzLFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHRoaXMuYSA9IHNvdXJjZS5hO1xuICAgICAgICB0aGlzLmIgPSBzb3VyY2UuYjtcbiAgICAgICAgdGhpcy5jID0gc291cmNlLmM7XG5cbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgICAgIHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9GYWNlNC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuRmFjZTQgPSBmdW5jdGlvbiggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2U0IGhhcyBiZWVuIHJlbW92ZWQuIEEgVEhSRUUuRmFjZTMgd2lsbCBiZSBjcmVhdGVkIGluc3RlYWQuJyApO1xuICAgIHJldHVybiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKTtcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlUmFuZ2UgPSB7XG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY291bnQ6IC0xXG4gICAgfTtcblxuICAgIHRoaXMudmVyc2lvbiA9IDA7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyQXR0cmlidXRlLFxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgICB9LFxuXG4gICAgZ2V0IGNvdW50KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCAvIHRoaXMuaXRlbVNpemU7XG5cbiAgICB9LFxuXG4gICAgc2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uKys7XG5cbiAgICB9LFxuXG4gICAgc2V0RHluYW1pYzogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xuICAgICAgICB0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlBdDogZnVuY3Rpb24oIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cbiAgICAgICAgaW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG4gICAgICAgIGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlBcnJheTogZnVuY3Rpb24oIGFycmF5ICkge1xuXG4gICAgICAgIHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24oIGNvbG9ycyApIHtcblxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvcnNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IGNvbG9yLnI7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IGNvbG9yLmc7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IGNvbG9yLmI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uKCBpbmRpY2VzICkge1xuXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRpY2VzWyBpIF07XG5cbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gaW5kZXguYTtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gaW5kZXguYjtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gaW5kZXguYztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uKCB2ZWN0b3JzICkge1xuXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci54O1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uKCB2ZWN0b3JzICkge1xuXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci54O1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IueTtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiggdmVjdG9ycyApIHtcblxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgICAgICAgICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IueDtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLnk7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci56O1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IudztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiggdmFsdWUsIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldFg6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cbiAgICB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24oIGluZGV4LCB4ICkge1xuXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRZOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuICAgIH0sXG5cbiAgICBzZXRZOiBmdW5jdGlvbiggaW5kZXgsIHkgKSB7XG5cbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRaOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcblxuICAgIH0sXG5cbiAgICBzZXRaOiBmdW5jdGlvbiggaW5kZXgsIHogKSB7XG5cbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRXOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuICAgIH0sXG5cbiAgICBzZXRXOiBmdW5jdGlvbiggaW5kZXgsIHcgKSB7XG5cbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYWTogZnVuY3Rpb24oIGluZGV4LCB4LCB5ICkge1xuXG4gICAgICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WFlaOiBmdW5jdGlvbiggaW5kZXgsIHgsIHksIHogKSB7XG5cbiAgICAgICAgaW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFhZWlc6IGZ1bmN0aW9uKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuICAgICAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfVxuXG59O1xuXG4vL1xuXG5USFJFRS5JbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5JbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5JbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5GbG9hdDMyQXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5GbG9hdDY0QXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQ2NEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5cbi8vIERlcHJlY2F0ZWRcblxuVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0RHluYW1pYyggdHJ1ZSApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKS5zZXREeW5hbWljKCB0cnVlICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtU2l6ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuICAgIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcblxuICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiggYXJyYXksIHN0cmlkZSApIHtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG5cbiAgICB0aGlzLmR5bmFtaWMgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlID0ge1xuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGNvdW50OiAtMVxuICAgIH07XG5cbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuXG59O1xuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIsXG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICAgIH0sXG5cbiAgICBnZXQgY291bnQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XG5cbiAgICB9LFxuXG4gICAgc2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uKys7XG5cbiAgICB9LFxuXG4gICAgc2V0RHluYW1pYzogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xuICAgICAgICB0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG4gICAgfSxcblxuICAgIGNvcHlBdDogZnVuY3Rpb24oIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cbiAgICAgICAgaW5kZXgxICo9IHRoaXMuc3RyaWRlO1xuICAgICAgICBpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnN0cmlkZTsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiggYXJyYXksIHN0cmlkZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuICAgIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcblxuICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcblxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiggaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQgKSB7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXG59O1xuXG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgLmNvdW50LicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuXG4gICAgfSxcblxuICAgIGdldCBjb3VudCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5Lmxlbmd0aCAvIHRoaXMuZGF0YS5zdHJpZGU7XG5cbiAgICB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24oIGluZGV4LCB4ICkge1xuXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WTogZnVuY3Rpb24oIGluZGV4LCB5ICkge1xuXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFo6IGZ1bmN0aW9uKCBpbmRleCwgeiApIHtcblxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRXOiBmdW5jdGlvbiggaW5kZXgsIHcgKSB7XG5cbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0WDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF07XG5cbiAgICB9LFxuXG4gICAgZ2V0WTogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xuXG4gICAgfSxcblxuICAgIGdldFo6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcblxuICAgIH0sXG5cbiAgICBnZXRXOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF07XG5cbiAgICB9LFxuXG4gICAgc2V0WFk6IGZ1bmN0aW9uKCBpbmRleCwgeCwgeSApIHtcblxuICAgICAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYWVo6IGZ1bmN0aW9uKCBpbmRleCwgeCwgeSwgeiApIHtcblxuICAgICAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WFlaVzogZnVuY3Rpb24oIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5HZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQrK1xuICAgIH0gKTtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIHRoaXMuY29sb3JzID0gW107XG4gICAgdGhpcy5mYWNlcyA9IFtdO1xuICAgIHRoaXMuZmFjZVZlcnRleFV2cyA9IFtcbiAgICAgICAgW11cbiAgICBdO1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcbiAgICB0aGlzLm1vcnBoQ29sb3JzID0gW107XG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuICAgIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcbiAgICB0aGlzLnNraW5JbmRpY2VzID0gW107XG5cbiAgICB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG4gICAgLy8gdXBkYXRlIGZsYWdzXG5cbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkdlb21ldHJ5LFxuXG4gICAgYXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCBtYXRyaXggKSB7XG5cbiAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgICAgICAgICAgdmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuICAgICAgICAgICAgZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICByb3RhdGVYOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlWjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHNjYWxlIGdlb21ldHJ5XG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGxvb2tBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG9iajtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgICAgIGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgICAgICAgICAgb2JqLmxvb2tBdCggdmVjdG9yICk7XG5cbiAgICAgICAgICAgIG9iai51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY29sb3JzID0gYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5jb2xvci5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcblxuICAgICAgICB2YXIgdGVtcE5vcm1hbHMgPSBbXTtcbiAgICAgICAgdmFyIHRlbXBVVnMgPSBbXTtcbiAgICAgICAgdmFyIHRlbXBVVnMyID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gMCwgayA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMywgaiArPSAyLCBrICs9IDQgKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xuXG4gICAgICAgICAgICBpZiAoIG5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHRlbXBOb3JtYWxzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBub3JtYWxzWyBpIF0sIG5vcm1hbHNbIGkgKyAxIF0sIG5vcm1hbHNbIGkgKyAyIF0gKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZW1wVVZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHRlbXBVVnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnMyWyBqIF0sIHV2czJbIGogKyAxIF0gKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhZGRGYWNlID0gZnVuY3Rpb24oIGEsIGIsIGMgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMgKTtcblxuICAgICAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuXG4gICAgICAgICAgICBpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAxIF0ucHVzaCggWyB0ZW1wVVZzMlsgYSBdLmNsb25lKCksIHRlbXBVVnMyWyBiIF0uY2xvbmUoKSwgdGVtcFVWczJbIGMgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cbiAgICAgICAgICAgIGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZhY2UoIGluZGljZXNbIGogXSwgaW5kaWNlc1sgaiArIDEgXSwgaW5kaWNlc1sgaiArIDIgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgYWRkRmFjZSggaSwgaSArIDEsIGkgKyAyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5jZW50ZXIoKS5uZWdhdGUoKTtcblxuICAgICAgICB0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuXG4gICAgICAgIHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcblxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgbWF0cml4LnNldChcbiAgICAgICAgICAgIHMsIDAsIDAsIC1zICogY2VudGVyLngsXG4gICAgICAgICAgICAwLCBzLCAwLCAtcyAqIGNlbnRlci55LFxuICAgICAgICAgICAgMCwgMCwgcywgLXMgKiBjZW50ZXIueixcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtYXRyaXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgICAgICAgICB2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgICAgICAgICAgY2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG4gICAgICAgICAgICBhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcbiAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xuXG4gICAgICAgICAgICBjYi5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cbiAgICAgICAgdmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XG5cbiAgICAgICAgdmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgZm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdisrICkge1xuXG4gICAgICAgICAgICB2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cbiAgICAgICAgICAgIC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXG5cbiAgICAgICAgICAgIHZhciB2QSwgdkIsIHZDO1xuICAgICAgICAgICAgdmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgICAgICBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgICAgICAgICB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuICAgICAgICAgICAgICAgIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgICAgICAgICAgICAgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgICAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgICAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xuICAgICAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xuXG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBjYiApO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGNiICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdisrICkge1xuXG4gICAgICAgICAgICB2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgICAgICBpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xuXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMCBdID0gdmVydGljZXNbIGZhY2UuYSBdLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMSBdID0gdmVydGljZXNbIGZhY2UuYiBdLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZU1vcnBoTm9ybWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcblxuICAgICAgICAvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcbiAgICAgICAgLy8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXG4gICAgICAgIC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcblxuICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgICAgIGlmICggIWZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAhZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDAsIGlsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXG5cbiAgICAgICAgdmFyIHRtcEdlbyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICB0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcblxuICAgICAgICAgICAgaWYgKCAhdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XG5cbiAgICAgICAgICAgICAgICB2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xuICAgICAgICAgICAgICAgIHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGM6IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBkc3ROb3JtYWxzRmFjZS5wdXNoKCBmYWNlTm9ybWFsICk7XG4gICAgICAgICAgICAgICAgICAgIGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xuXG4gICAgICAgICAgICAvLyBzZXQgdmVydGljZXMgdG8gbW9ycGggdGFyZ2V0XG5cbiAgICAgICAgICAgIHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG5cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xuXG4gICAgICAgICAgICB0bXBHZW8uY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgICAgICAgICB0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgICAgICAgICAgLy8gc3RvcmUgbW9ycGggbm9ybWFsc1xuXG4gICAgICAgICAgICB2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuICAgICAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICAgICAgICAgIGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcblxuICAgICAgICAgICAgICAgIGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xuXG4gICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICAgICAgZmFjZS5ub3JtYWwgPSBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsO1xuICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVMaW5lRGlzdGFuY2VzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZCA9IDA7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGlmICggaSA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBkICs9IHZlcnRpY2VzWyBpIF0uZGlzdGFuY2VUbyggdmVydGljZXNbIGkgLSAxIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxpbmVEaXN0YW5jZXNbIGkgXSA9IGQ7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG4gICAgfSxcblxuICAgIG1lcmdlOiBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3JtYWxNYXRyaXgsXG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXG4gICAgICAgICAgICB2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcbiAgICAgICAgICAgIGZhY2VzMSA9IHRoaXMuZmFjZXMsXG4gICAgICAgICAgICBmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcbiAgICAgICAgICAgIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcbiAgICAgICAgICAgIHV2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF07XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcnRpY2VzXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XG5cbiAgICAgICAgICAgIGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cbiAgICAgICAgICAgIHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhY2VzXG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXMyWyBpIF0sXG4gICAgICAgICAgICAgICAgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXG4gICAgICAgICAgICAgICAgZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXG4gICAgICAgICAgICAgICAgZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG4gICAgICAgICAgICBmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xuICAgICAgICAgICAgZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgICAgICAgIGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZhY2VDb3B5LmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xuICAgICAgICAgICAgICAgIGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmFjZUNvcHkubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleCArIG1hdGVyaWFsSW5kZXhPZmZzZXQ7XG5cbiAgICAgICAgICAgIGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB1dnNcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB1diA9IHV2czJbIGkgXSxcbiAgICAgICAgICAgICAgICB1dkNvcHkgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCB1diA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB1dkNvcHkucHVzaCggdXZbIGogXS5jbG9uZSgpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXZzMS5wdXNoKCB1dkNvcHkgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWVyZ2VNZXNoOiBmdW5jdGlvbiggbWVzaCApIHtcblxuICAgICAgICBpZiAoIG1lc2ggaW5zdGFuY2VvZiBUSFJFRS5NZXNoID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgbWVzaC5tYXRyaXhBdXRvVXBkYXRlICYmIG1lc2gudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgICAgdGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcblxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cbiAgICAgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXG4gICAgICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cbiAgICAgKi9cblxuICAgIG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuICAgICAgICB2YXIgdW5pcXVlID0gW10sXG4gICAgICAgICAgICBjaGFuZ2VzID0gW107XG5cbiAgICAgICAgdmFyIHYsIGtleTtcbiAgICAgICAgdmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcbiAgICAgICAgdmFyIGksIGlsLCBmYWNlO1xuICAgICAgICB2YXIgaW5kaWNlcywgaiwgamw7XG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgICAgICAgICAga2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xuXG4gICAgICAgICAgICBpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdmVydGljZXNNYXBbIGtleSBdID0gaTtcbiAgICAgICAgICAgICAgICB1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XG4gICAgICAgICAgICAgICAgY2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcbiAgICAgICAgLy8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cbiAgICAgICAgdmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cbiAgICAgICAgICAgIGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xuICAgICAgICAgICAgZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XG4gICAgICAgICAgICBmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcblxuICAgICAgICAgICAgaW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xuXG4gICAgICAgICAgICB2YXIgZHVwSW5kZXggPSAtMTtcblxuICAgICAgICAgICAgLy8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZhY2UgYXMgbm90aGluZyBjYW4gYmUgc2F2ZWRcbiAgICAgICAgICAgIGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4rKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZHVwSW5kZXggPSBuO1xuICAgICAgICAgICAgICAgICAgICBmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaSA9IGZhY2VJbmRpY2VzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cbiAgICAgICAgICAgIHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblxuICAgICAgICAgICAgZm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXG5cbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIHVuaXF1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMudmVydGljZXMgPSB1bmlxdWU7XG4gICAgICAgIHJldHVybiBkaWZmO1xuXG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnR2VvbWV0cnknLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ0dlb21ldHJ5LnRvSlNPTidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGFuZGFyZCBHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cbiAgICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgICAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgICBpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhY2VzID0gW107XG4gICAgICAgIHZhciBub3JtYWxzID0gW107XG4gICAgICAgIHZhciBub3JtYWxzSGFzaCA9IHt9O1xuICAgICAgICB2YXIgY29sb3JzID0gW107XG4gICAgICAgIHZhciBjb2xvcnNIYXNoID0ge307XG4gICAgICAgIHZhciB1dnMgPSBbXTtcbiAgICAgICAgdmFyIHV2c0hhc2ggPSB7fTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZhY2VzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuICAgICAgICAgICAgdmFyIGhhc01hdGVyaWFsID0gZmFsc2U7IC8vIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGhhc0ZhY2VVdiA9IGZhbHNlOyAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICB2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XG4gICAgICAgICAgICB2YXIgaGFzRmFjZVZlcnRleE5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xuICAgICAgICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAgIHZhciBmYWNlVHlwZSA9IDA7XG5cbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMCwgMCApO1xuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAxLCBoYXNNYXRlcmlhbCApO1xuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMywgaGFzRmFjZVZlcnRleFV2ICk7XG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDQsIGhhc0ZhY2VOb3JtYWwgKTtcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA2LCBoYXNGYWNlQ29sb3IgKTtcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNywgaGFzRmFjZVZlcnRleENvbG9yICk7XG5cbiAgICAgICAgICAgIGZhY2VzLnB1c2goIGZhY2VUeXBlICk7XG4gICAgICAgICAgICBmYWNlcy5wdXNoKCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jICk7XG5cbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZ2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXG4gICAgICAgICAgICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxuICAgICAgICAgICAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxuICAgICAgICAgICAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDAgXSApLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRCaXQoIHZhbHVlLCBwb3NpdGlvbiwgZW5hYmxlZCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWQgPyB2YWx1ZSB8ICggMSA8PCBwb3NpdGlvbiApIDogdmFsdWUgJiAoIH4oIDEgPDwgcG9zaXRpb24gKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xuXG4gICAgICAgICAgICB2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xuICAgICAgICAgICAgbm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cbiAgICAgICAgICAgIHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcblxuICAgICAgICAgICAgdmFyIGhhc2ggPSBjb2xvci5yLnRvU3RyaW5nKCkgKyBjb2xvci5nLnRvU3RyaW5nKCkgKyBjb2xvci5iLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBjb2xvcnMucHVzaCggY29sb3IuZ2V0SGV4KCkgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XG5cbiAgICAgICAgICAgIHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cbiAgICAgICAgICAgIHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZGF0YSA9IHt9O1xuXG4gICAgICAgIGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICBkYXRhLmRhdGEubm9ybWFscyA9IG5vcm1hbHM7XG4gICAgICAgIGlmICggY29sb3JzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEuY29sb3JzID0gY29sb3JzO1xuICAgICAgICBpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgZGF0YS5kYXRhLmZhY2VzID0gZmFjZXM7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mYWNlcyA9IFtdO1xuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbXG4gICAgICAgICAgICBbXVxuICAgICAgICBdO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNvdXJjZS52ZXJ0aWNlcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSBzb3VyY2UuZmFjZVZlcnRleFV2c1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLFxuICAgICAgICAgICAgICAgICAgICB1dnNDb3B5ID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgayA9IDAsIGtsID0gdXZzLmxlbmd0aDsgayA8IGtsOyBrKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2ID0gdXZzWyBrIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdXZzQ29weS5wdXNoKCB1di5jbG9uZSgpICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXS5wdXNoKCB1dnNDb3B5ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICB0eXBlOiAnZGlzcG9zZSdcbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuVEhSRUUuR2VvbWV0cnlJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvY29yZS9EaXJlY3RHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuRGlyZWN0R2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50KytcbiAgICB9ICk7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy50eXBlID0gJ0RpcmVjdEdlb21ldHJ5JztcblxuICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICB0aGlzLm5vcm1hbHMgPSBbXTtcbiAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgIHRoaXMudXZzID0gW107XG4gICAgdGhpcy51dnMyID0gW107XG5cbiAgICB0aGlzLmdyb3VwcyA9IFtdO1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcblxuICAgIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcbiAgICB0aGlzLnNraW5JbmRpY2VzID0gW107XG5cbiAgICAvLyB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG4gICAgLy8gdXBkYXRlIGZsYWdzXG5cbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkRpcmVjdEdlb21ldHJ5LFxuXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94OiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nQm94LFxuICAgIGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSxcblxuICAgIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVGYWNlTm9ybWFscygpIGlzIG5vdCBhIG1ldGhvZCBvZiB0aGlzIHR5cGUgb2YgZ2VvbWV0cnkuJyApO1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZVZlcnRleE5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcblxuICAgIH0sXG5cbiAgICBjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIGdyb3VwO1xuICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgIHZhciBtYXRlcmlhbEluZGV4O1xuXG4gICAgICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgICAgICAgIC8vIG1hdGVyaWFsc1xuXG4gICAgICAgICAgICBpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gbWF0ZXJpYWxJbmRleCApIHtcblxuICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goIGdyb3VwICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBncm91cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGkgKiAzLFxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XG4gICAgICAgICAgICBncm91cHMucHVzaCggZ3JvdXAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncm91cHMgPSBncm91cHM7XG5cbiAgICB9LFxuXG4gICAgZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XG5cbiAgICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcbiAgICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdjIgPSBmYWNlVmVydGV4VXZzWyAxIF0gJiYgZmFjZVZlcnRleFV2c1sgMSBdLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgLy8gbW9ycGhzXG5cbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzUG9zaXRpb24gPSBbXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNQb3NpdGlvblsgaSBdID0gW107XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMucG9zaXRpb24gPSBtb3JwaFRhcmdldHNQb3NpdGlvbjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscztcbiAgICAgICAgdmFyIG1vcnBoTm9ybWFsc0xlbmd0aCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCBtb3JwaE5vcm1hbHNMZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzTm9ybWFsID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzTm9ybWFsWyBpIF0gPSBbXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraW5zXG5cbiAgICAgICAgdmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XG4gICAgICAgIHZhciBza2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzO1xuXG4gICAgICAgIHZhciBoYXNTa2luSW5kaWNlcyA9IHNraW5JbmRpY2VzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICB2YXIgaGFzU2tpbldlaWdodHMgPSBza2luV2VpZ2h0cy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICAvL1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgICAgICAgICAgaWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5wdXNoKCB2ZXJ0ZXhOb3JtYWxzWyAwIF0sIHZlcnRleE5vcm1hbHNbIDEgXSwgdmVydGV4Tm9ybWFsc1sgMiBdICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgICAgICAgIGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBmYWNlLmNvbG9yO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdiAnLCBpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2MiA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAxIF1bIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dnMyLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3JwaHNcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGogXS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0ucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBqIF0udmVydGV4Tm9ybWFsc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzTm9ybWFsWyBqIF0ucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNraW5zXG5cbiAgICAgICAgICAgIGlmICggaGFzU2tpbkluZGljZXMgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBmYWNlLmEgXSwgc2tpbkluZGljZXNbIGZhY2UuYiBdLCBza2luSW5kaWNlc1sgZmFjZS5jIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhhc1NraW5XZWlnaHRzICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xuXG4gICAgICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xuICAgICAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG4gICAgICAgIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XG4gICAgICAgIHRoaXMudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XG4gICAgICAgIHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICB0eXBlOiAnZGlzcG9zZSdcbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5EaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvY29yZS9CdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCsrXG4gICAgfSApO1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICB0aGlzLmluZGV4ID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cbiAgICB0aGlzLmdyb3VwcyA9IFtdO1xuXG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbiAgICB0aGlzLmRyYXdSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGNvdW50OiBJbmZpbml0eVxuICAgIH07XG5cbn07XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSxcblxuICAgIGFkZEluZGV4OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRJbmRleCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEluZGV4KCkuJyApO1xuICAgICAgICB0aGlzLnNldEluZGV4KCBpbmRleCApO1xuXG4gICAgfSxcblxuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcblxuICAgIH0sXG5cbiAgICBzZXRJbmRleDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgIH0sXG5cbiAgICBhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgPT09IGZhbHNlICYmIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBuYW1lID09PSAnaW5kZXgnICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5hZGRBdHRyaWJ1dGU6IFVzZSAuc2V0SW5kZXgoKSBmb3IgaW5kZXggYXR0cmlidXRlLicgKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcblxuICAgIH0sXG5cbiAgICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgIH0sXG5cbiAgICByZW1vdmVBdHRyaWJ1dGU6IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgIH0sXG5cbiAgICBnZXQgZHJhd2NhbGxzKCkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHM7XG5cbiAgICB9LFxuXG4gICAgZ2V0IG9mZnNldHMoKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5vZmZzZXRzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwcztcblxuICAgIH0sXG5cbiAgICBhZGREcmF3Q2FsbDogZnVuY3Rpb24oIHN0YXJ0LCBjb3VudCwgaW5kZXhPZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIGluZGV4T2Zmc2V0LicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS4nICk7XG4gICAgICAgIHRoaXMuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCApO1xuXG4gICAgfSxcblxuICAgIGNsZWFyRHJhd0NhbGxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcbiAgICAgICAgdGhpcy5jbGVhckdyb3VwcygpO1xuXG4gICAgfSxcblxuICAgIGFkZEdyb3VwOiBmdW5jdGlvbiggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgICAgIHRoaXMuZ3JvdXBzLnB1c2goIHtcblxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgbWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDBcblxuICAgICAgICB9ICk7XG5cbiAgICB9LFxuXG4gICAgY2xlYXJHcm91cHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XG5cbiAgICB9LFxuXG4gICAgc2V0RHJhd1JhbmdlOiBmdW5jdGlvbiggc3RhcnQsIGNvdW50ICkge1xuXG4gICAgICAgIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCBtYXRyaXggKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XG4gICAgICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG4gICAgICAgIGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgICAgICAgIG5vcm1hbE1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBub3JtYWwuYXJyYXkgKTtcbiAgICAgICAgICAgIG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICByb3RhdGVYOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlWjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHNjYWxlIGdlb21ldHJ5XG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGxvb2tBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG9iajtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgICAgIGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgICAgICAgICAgb2JqLmxvb2tBdCggdmVjdG9yICk7XG5cbiAgICAgICAgICAgIG9iai51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuXG4gICAgfSxcblxuICAgIHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzLCAzICk7XG4gICAgICAgICAgICB2YXIgY29sb3JzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBjb2xvcnMuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgJiYgZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGggPT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIGxpbmVEaXN0YW5jZXMuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlRnJvbU9iamVjdDogZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcblxuICAgICAgICAgICAgaWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xuICAgICAgICAgICAgZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG4gICAgICAgICAgICBkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XG4gICAgICAgICAgICBkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XG4gICAgICAgICAgICBkaXJlY3QuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBkaXJlY3Q7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XG5cbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSApIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgKSB7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xuICAgICAgICAgICAgdGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSA9IG5ldyBUSFJFRS5EaXJlY3RHZW9tZXRyeSgpLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRGlyZWN0R2VvbWV0cnkoIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgKTtcblxuICAgIH0sXG5cbiAgICBmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LnV2cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS51dnMyLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2czIsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzMiApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgVHlwZUFycmF5ID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgVHlwZUFycmF5KCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCAqIDMgKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKS5jb3B5SW5kaWNlc0FycmF5KCBnZW9tZXRyeS5pbmRpY2VzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ3JvdXBzXG5cbiAgICAgICAgdGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cbiAgICAgICAgLy8gbW9ycGhzXG5cbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XG5cbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraW5uaW5nXG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgc2tpbkluZGljZXMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBza2luV2VpZ2h0cyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBza2luV2VpZ2h0cy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbldlaWdodHMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgIGlmICggcG9zaXRpb25zICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveDtcbiAgICAgICAgICAgICAgICBiYi5tYWtlRW1wdHkoKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgYmIuZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5taW4uc2V0KCAwLCAwLCAwICk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5tYXguc2V0KCAwLCAwLCAwICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbnMgKSB7XG5cbiAgICAgICAgICAgICAgICBib3gubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgICAgICAgICAgIGJveC5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJveC5jZW50ZXIoIGNlbnRlciApO1xuXG4gICAgICAgICAgICAgICAgLy8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgICAgICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiApIHtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuICAgICAgICAgICAgICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgXSA9IDA7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgICAgICAgICAgdmFyIHZBLCB2QiwgdkMsXG5cbiAgICAgICAgICAgICAgICBwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICAgICAgcEIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgICAgIHBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgICAgICAgICAgICAgIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgICAgICBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIC8vIGluZGV4ZWQgZWxlbWVudHNcblxuICAgICAgICAgICAgaWYgKCBpbmRleCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsraiApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGogXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdkEgPSBpbmRpY2VzWyBpICsgMCBdICogMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2QyA9IGluZGljZXNbIGkgKyAyIF0gKiAzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZDICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkEgXSArPSBjYi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZBICsgMiBdICs9IGNiLno7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QiArIDIgXSArPSBjYi56O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QyBdICs9IGNiLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QyArIDEgXSArPSBjYi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgcEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XG4gICAgICAgICAgICAgICAgICAgIHBDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuICAgICAgICAgICAgICAgICAgICBhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcbiAgICAgICAgICAgICAgICAgICAgY2IuY3Jvc3MoIGFiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSBdID0gY2IueDtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xuXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgNCBdID0gY2IueTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDUgXSA9IGNiLno7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgOCBdID0gY2IuejtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuICAgICAgICAgICAgYXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZU9mZnNldHM6IGZ1bmN0aW9uKCBzaXplICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKVxuXG4gICAgfSxcblxuICAgIG1lcmdlOiBmdW5jdGlvbiggZ2VvbWV0cnksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUxID0gYXR0cmlidXRlc1sga2V5IF07XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlQXJyYXkxID0gYXR0cmlidXRlMS5hcnJheTtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZTIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVBcnJheTIgPSBhdHRyaWJ1dGUyLmFycmF5O1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZTIuaXRlbVNpemU7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpKyssIGorKyApIHtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFycmF5MVsgaiBdID0gYXR0cmlidXRlQXJyYXkyWyBpIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgICAgIHZhciB4LCB5LCB6LCBuO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgIHggPSBub3JtYWxzWyBpIF07XG4gICAgICAgICAgICB5ID0gbm9ybWFsc1sgaSArIDEgXTtcbiAgICAgICAgICAgIHogPSBub3JtYWxzWyBpICsgMiBdO1xuXG4gICAgICAgICAgICBuID0gMS4wIC8gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuICAgICAgICAgICAgbm9ybWFsc1sgaSBdICo9IG47XG4gICAgICAgICAgICBub3JtYWxzWyBpICsgMSBdICo9IG47XG4gICAgICAgICAgICBub3JtYWxzWyBpICsgMiBdICo9IG47XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cbiAgICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgICAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgICBpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5kYXRhID0ge1xuICAgICAgICAgICAgYXR0cmlidXRlczoge31cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApO1xuXG4gICAgICAgICAgICBkYXRhLmRhdGEuaW5kZXggPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXR0cmlidXRlLmFycmF5ICk7XG5cbiAgICAgICAgICAgIGRhdGEuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcbiAgICAgICAgICAgICAgICBpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxuICAgICAgICAgICAgICAgIHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGFycmF5OiBhcnJheVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG4gICAgICAgIGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuICAgICAgICBpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG4gICAgICAgICAgICAgICAgY2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgIHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuICAgICAgICAgICAgdGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICAgIH0gKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcbiAgICB0aGlzLm1heEluc3RhbmNlZENvdW50ID0gdW5kZWZpbmVkO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbiggc3RhcnQsIGNvdW50LCBpbnN0YW5jZXMgKSB7XG5cbiAgICB0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGluc3RhbmNlczogaW5zdGFuY2VzXG5cbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG4gICAgICAgIHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAuaW5zdGFuY2VzICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5DYW1lcmEgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdDYW1lcmEnO1xuXG4gICAgdGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbn07XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmE7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuZ2V0V29ybGREaXJlY3Rpb24gPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgLTEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIH07XG5cbn0oKTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbigpIHtcblxuICAgIC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG4gICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIG0xLmxvb2tBdCggdGhpcy5wb3NpdGlvbiwgdmVjdG9yLCB0aGlzLnVwICk7XG5cbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuICAgIH07XG5cbn0oKTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzXG5cbi8qKlxuICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXG4gKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcbiAqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkN1YmVDYW1lcmEgPSBmdW5jdGlvbiggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuICAgIHZhciBmb3YgPSA5MCxcbiAgICAgICAgYXNwZWN0ID0gMTtcblxuICAgIHZhciBjYW1lcmFQWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIGNhbWVyYVBYLnVwLnNldCggMCwgLTEsIDAgKTtcbiAgICBjYW1lcmFQWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICkgKTtcbiAgICB0aGlzLmFkZCggY2FtZXJhUFggKTtcblxuICAgIHZhciBjYW1lcmFOWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIGNhbWVyYU5YLnVwLnNldCggMCwgLTEsIDAgKTtcbiAgICBjYW1lcmFOWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAtMSwgMCwgMCApICk7XG4gICAgdGhpcy5hZGQoIGNhbWVyYU5YICk7XG5cbiAgICB2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcbiAgICBjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcbiAgICB0aGlzLmFkZCggY2FtZXJhUFkgKTtcblxuICAgIHZhciBjYW1lcmFOWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLTEgKTtcbiAgICBjYW1lcmFOWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtMSwgMCApICk7XG4gICAgdGhpcy5hZGQoIGNhbWVyYU5ZICk7XG5cbiAgICB2YXIgY2FtZXJhUFogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBjYW1lcmFQWi51cC5zZXQoIDAsIC0xLCAwICk7XG4gICAgY2FtZXJhUFoubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApICk7XG4gICAgdGhpcy5hZGQoIGNhbWVyYVBaICk7XG5cbiAgICB2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBjYW1lcmFOWi51cC5zZXQoIDAsIC0xLCAwICk7XG4gICAgY2FtZXJhTloubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLTEgKSApO1xuICAgIHRoaXMuYWRkKCBjYW1lcmFOWiApO1xuXG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCBjdWJlUmVzb2x1dGlvbiwgY3ViZVJlc29sdXRpb24sIHtcbiAgICAgICAgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsXG4gICAgICAgIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxuICAgICAgICBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlclxuICAgIH0gKTtcblxuICAgIHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uKCByZW5kZXJlciwgc2NlbmUgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgICAgIHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlosIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xuXG4gICAgfTtcblxufTtcblxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViZUNhbWVyYTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IGZ1bmN0aW9uKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuICAgIFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnT3J0aG9ncmFwaGljQ2FtZXJhJztcblxuICAgIHRoaXMuem9vbSA9IDE7XG5cbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuICAgIHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xuICAgIHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcblxuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xuICAgIHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG4gICAgdmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xuICAgIHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcblxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBjeCAtIGR4LCBjeCArIGR4LCBjeSArIGR5LCBjeSAtIGR5LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xuICAgIHRoaXMudG9wID0gc291cmNlLnRvcDtcbiAgICB0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG4gICAgdGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG4gICAgdGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXG4gICAgdGhpcy56b29tID0gc291cmNlLnpvb207XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xuICAgIGRhdGEub2JqZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgZGF0YS5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgIGRhdGEub2JqZWN0LnRvcCA9IHRoaXMudG9wO1xuICAgIGRhdGEub2JqZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xuICAgIGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG4gICAgZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSA9IGZ1bmN0aW9uKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG4gICAgVEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cbiAgICB0aGlzLnpvb20gPSAxO1xuXG4gICAgdGhpcy5mb3YgPSBmb3YgIT09IHVuZGVmaW5lZCA/IGZvdiA6IDUwO1xuICAgIHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuICAgIHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG4gICAgdGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XG5cbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmE7XG5cblxuLyoqXG4gKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXG4gKiAzNW1tIChmdWxsLWZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XG4gKiBGb3JtdWxhIGJhc2VkIG9uIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xuXG4gICAgaWYgKCBmcmFtZUhlaWdodCA9PT0gdW5kZWZpbmVkICkgZnJhbWVIZWlnaHQgPSAyNDtcblxuICAgIHRoaXMuZm92ID0gMiAqIFRIUkVFLk1hdGgucmFkVG9EZWcoIE1hdGguYXRhbiggZnJhbWVIZWlnaHQgLyAoIGZvY2FsTGVuZ3RoICogMiApICkgKTtcbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuXG4vKipcbiAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3JcbiAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcbiAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcbiAqXG4gKiAgICstLS0rLS0tKy0tLStcbiAqICAgfCBBIHwgQiB8IEMgfFxuICogICArLS0tKy0tLSstLS0rXG4gKiAgIHwgRCB8IEUgfCBGIHxcbiAqICAgKy0tLSstLS0rLS0tK1xuICpcbiAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcbiAqXG4gKiAgIHZhciB3ID0gMTkyMDtcbiAqICAgdmFyIGggPSAxMDgwO1xuICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XG4gKiAgIHZhciBmdWxsSGVpZ2h0ID0gaCAqIDI7XG4gKlxuICogICAtLUEtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xuICogICAtLUItLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuICogICAtLUMtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xuICogICAtLUQtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xuICogICAtLUUtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuICogICAtLUYtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xuICpcbiAqICAgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0Vmlld09mZnNldCA9IGZ1bmN0aW9uKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICB0aGlzLmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcbiAgICB0aGlzLmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGZvdiA9IFRIUkVFLk1hdGgucmFkVG9EZWcoIDIgKiBNYXRoLmF0YW4oIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmZvdiApICogMC41ICkgLyB0aGlzLnpvb20gKSApO1xuXG4gICAgaWYgKCB0aGlzLmZ1bGxXaWR0aCApIHtcblxuICAgICAgICB2YXIgYXNwZWN0ID0gdGhpcy5mdWxsV2lkdGggLyB0aGlzLmZ1bGxIZWlnaHQ7XG4gICAgICAgIHZhciB0b3AgPSBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKSAqIHRoaXMubmVhcjtcbiAgICAgICAgdmFyIGJvdHRvbSA9IC10b3A7XG4gICAgICAgIHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xuICAgICAgICB2YXIgcmlnaHQgPSBhc3BlY3QgKiB0b3A7XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKCByaWdodCAtIGxlZnQgKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcblxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZUZydXN0dW0oXG4gICAgICAgICAgICBsZWZ0ICsgdGhpcy54ICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcbiAgICAgICAgICAgIGxlZnQgKyAoIHRoaXMueCArIHRoaXMud2lkdGggKSAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXG4gICAgICAgICAgICB0b3AgLSAoIHRoaXMueSArIHRoaXMuaGVpZ2h0ICkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXG4gICAgICAgICAgICB0b3AgLSB0aGlzLnkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXG4gICAgICAgICAgICB0aGlzLm5lYXIsXG4gICAgICAgICAgICB0aGlzLmZhclxuICAgICAgICApO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5mb3YgPSBzb3VyY2UuZm92O1xuICAgIHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcbiAgICB0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcbiAgICB0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cbiAgICB0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcbiAgICBkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcbiAgICBkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcbiAgICBkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuICAgIGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxpZ2h0ID0gZnVuY3Rpb24oIGNvbG9yICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0xpZ2h0JztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cbn07XG5cblRIUkVFLkxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGlnaHQ7XG5cblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuLy8gRmlsZTpzcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQW1iaWVudExpZ2h0ID0gZnVuY3Rpb24oIGNvbG9yICkge1xuXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICAgIHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xuXG59O1xuXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQW1iaWVudExpZ2h0O1xuXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiggY29sb3IsIGludGVuc2l0eSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cbiAgICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xuICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXG4gICAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgdGhpcy5vbmx5U2hhZG93ID0gZmFsc2U7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYU5lYXIgPSA1MDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IDUwMDA7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYUxlZnQgPSAtNTAwO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQgPSA1MDA7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFUb3AgPSA1MDA7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFCb3R0b20gPSAtNTAwO1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cbiAgICB0aGlzLnNoYWRvd0JpYXMgPSAwO1xuICAgIHRoaXMuc2hhZG93RGFya25lc3MgPSAwLjU7XG5cbiAgICB0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xuICAgIHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xuXG4gICAgdGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuICAgIHRoaXMuc2hhZG93TWFwU2l6ZSA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmEgPSBudWxsO1xuICAgIHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcbiAgICB0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuICAgIHRoaXMub25seVNoYWRvdyA9IHNvdXJjZS5vbmx5U2hhZG93O1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gc291cmNlLnNoYWRvd0NhbWVyYU5lYXI7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFGYXIgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhRmFyO1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFMZWZ0ID0gc291cmNlLnNoYWRvd0NhbWVyYUxlZnQ7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFSaWdodCA9IHNvdXJjZS5zaGFkb3dDYW1lcmFSaWdodDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYVRvcCA9IHNvdXJjZS5zaGFkb3dDYW1lcmFUb3A7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFCb3R0b20gPSBzb3VyY2Uuc2hhZG93Q2FtZXJhQm90dG9tO1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gc291cmNlLnNoYWRvd0NhbWVyYVZpc2libGU7XG5cbiAgICB0aGlzLnNoYWRvd0JpYXMgPSBzb3VyY2Uuc2hhZG93QmlhcztcbiAgICB0aGlzLnNoYWRvd0RhcmtuZXNzID0gc291cmNlLnNoYWRvd0RhcmtuZXNzO1xuXG4gICAgdGhpcy5zaGFkb3dNYXBXaWR0aCA9IHNvdXJjZS5zaGFkb3dNYXBXaWR0aDtcbiAgICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IHNvdXJjZS5zaGFkb3dNYXBIZWlnaHQ7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICAgIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodCA9IGZ1bmN0aW9uKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcblxuICAgIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG4gICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgIHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGdyb3VuZENvbG9yICk7XG4gICAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xuICAgIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG4gICAgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL1BvaW50TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlBvaW50TGlnaHQgPSBmdW5jdGlvbiggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlY2F5ICkge1xuXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcblxuICAgIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcbiAgICB0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG4gICAgdGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxOyAvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50TGlnaHQ7XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG4gICAgdGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcbiAgICB0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcbiAgICBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG4gICAgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9TcG90TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwb3RMaWdodCA9IGZ1bmN0aW9uKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50LCBkZWNheSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcblxuICAgIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG4gICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgIHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG4gICAgdGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuICAgIHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XG4gICAgdGhpcy5leHBvbmVudCA9ICggZXhwb25lbnQgIT09IHVuZGVmaW5lZCApID8gZXhwb25lbnQgOiAxMDtcbiAgICB0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7IC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgIHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhRm92ID0gNTA7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcblxuICAgIHRoaXMuc2hhZG93QmlhcyA9IDA7XG4gICAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcblxuICAgIHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XG4gICAgdGhpcy5zaGFkb3dNYXBIZWlnaHQgPSA1MTI7XG5cbiAgICB0aGlzLnNoYWRvd01hcCA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dNYXBTaXplID0gbnVsbDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dNYXRyaXggPSBudWxsO1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0O1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG4gICAgdGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcbiAgICB0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xuICAgIHRoaXMuZXhwb25lbnQgPSBzb3VyY2UuZXhwb25lbnQ7XG4gICAgdGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuICAgIHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xuXG4gICAgdGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG4gICAgdGhpcy5vbmx5U2hhZG93ID0gc291cmNlLm9ubHlTaGFkb3c7XG5cbiAgICB0aGlzLnNoYWRvd0NhbWVyYU5lYXIgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhTmVhcjtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFGYXI7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFGb3YgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhRm92O1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gc291cmNlLnNoYWRvd0NhbWVyYVZpc2libGU7XG5cbiAgICB0aGlzLnNoYWRvd0JpYXMgPSBzb3VyY2Uuc2hhZG93QmlhcztcbiAgICB0aGlzLnNoYWRvd0RhcmtuZXNzID0gc291cmNlLnNoYWRvd0RhcmtuZXNzO1xuXG4gICAgdGhpcy5zaGFkb3dNYXBXaWR0aCA9IHNvdXJjZS5zaGFkb3dNYXBXaWR0aDtcbiAgICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IHNvdXJjZS5zaGFkb3dNYXBIZWlnaHQ7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gICAgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG4gICAgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuICAgIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICBkYXRhLm9iamVjdC5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XG4gICAgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ2FjaGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNhY2hlID0ge1xuXG4gICAgZW5hYmxlZDogZmFsc2UsXG5cbiAgICBmaWxlczoge30sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCBrZXksIGZpbGUgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcblxuICAgICAgICB0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XG5cbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbigga2V5ICkge1xuXG4gICAgICAgIGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5maWxlc1sga2V5IF07XG5cbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigga2V5ICkge1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTG9hZGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24oKSB7fTtcblxufTtcblxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Mb2FkZXIsXG5cbiAgICBjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxuXG4gICAgZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cbiAgICAgICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcblxuICAgICAgICBpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xuXG4gICAgICAgIHBhcnRzLnBvcCgpO1xuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcblxuICAgIH0sXG5cbiAgICBpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKytpICkge1xuXG4gICAgICAgICAgICBhcnJheVsgaSBdID0gdGhpcy5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgY3JlYXRlTWF0ZXJpYWw6ICggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGltYWdlTG9hZGVyO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXRlcmlhbCggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIGNyb3NzT3JpZ2luID09PSB1bmRlZmluZWQgJiYgc2NvcGUuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGNyb3NzT3JpZ2luID0gc2NvcGUuY3Jvc3NPcmlnaW47XG5cbiAgICAgICAgICAgIGlmICggaW1hZ2VMb2FkZXIgPT09IHVuZGVmaW5lZCApIGltYWdlTG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5lYXJlc3RfcG93MiggbiApIHtcblxuICAgICAgICAgICAgICAgIHZhciBsID0gTWF0aC5sb2coIG4gKSAvIE1hdGguTE4yO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5yb3VuZCggbCApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlX3RleHR1cmUoIHdoZXJlLCBuYW1lLCBzb3VyY2VGaWxlLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgc291cmNlRmlsZTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIGZ1bGxQYXRoICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyID0gaW1hZ2VMb2FkZXI7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyLmxvYWQoIGZ1bGxQYXRoLCBmdW5jdGlvbiggaW1hZ2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG5lYXJlc3RfcG93MiggaW1hZ2Uud2lkdGggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gbmVhcmVzdF9wb3cyKCBpbWFnZS5oZWlnaHQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gY2FudmFzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnNvdXJjZUZpbGUgPSBzb3VyY2VGaWxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCByZXBlYXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5yZXBlYXQuc2V0KCByZXBlYXRbIDAgXSwgcmVwZWF0WyAxIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5vZmZzZXQuc2V0KCBvZmZzZXRbIDAgXSwgb2Zmc2V0WyAxIF0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggd3JhcCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcE1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXBlYXQnOiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaXJyb3InOiBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB3cmFwTWFwWyB3cmFwWyAwIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwUyA9IHdyYXBNYXBbIHdyYXBbIDAgXSBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHdyYXBNYXBbIHdyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBUID0gd3JhcE1hcFsgd3JhcFsgMSBdIF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGFuaXNvdHJvcHkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoZXJlWyBuYW1lIF0gPSB0ZXh0dXJlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJnYjJoZXgoIHJnYiApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoIHJnYlsgMCBdICogMjU1IDw8IDE2ICkgKyAoIHJnYlsgMSBdICogMjU1IDw8IDggKSArIHJnYlsgMiBdICogMjU1O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRlZmF1bHRzXG5cbiAgICAgICAgICAgIHZhciBtdHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcbiAgICAgICAgICAgIHZhciBtcGFycyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGZyb20gbW9kZWwgZmlsZVxuXG4gICAgICAgICAgICBpZiAoIG0uc2hhZGluZyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBzaGFkaW5nID0gbS5zaGFkaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNoYWRpbmcgPT09ICdwaG9uZycgKSBtdHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIHNoYWRpbmcgPT09ICdiYXNpYycgKSBtdHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgJiYgVEhSRUVbIG0uYmxlbmRpbmcgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuYmxlbmRpbmcgPSBUSFJFRVsgbS5ibGVuZGluZyBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5vcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgbS5vcGFjaXR5IDwgMS4wICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLmRlcHRoVGVzdCA9IG0uZGVwdGhUZXN0O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5kZXB0aFdyaXRlID0gbS5kZXB0aFdyaXRlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy52aXNpYmxlID0gbS52aXNpYmxlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5mbGlwU2lkZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLnNpZGUgPSBUSFJFRS5CYWNrU2lkZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0uZG91YmxlU2lkZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLndpcmVmcmFtZSA9IG0ud2lyZWZyYW1lO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggbS52ZXJ0ZXhDb2xvcnMgPT09ICdmYWNlJyApIHtcblxuICAgICAgICAgICAgICAgICAgICBtcGFycy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5GYWNlQ29sb3JzO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBtLnZlcnRleENvbG9ycyApIHtcblxuICAgICAgICAgICAgICAgICAgICBtcGFycy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29sb3JzXG5cbiAgICAgICAgICAgIGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5jb2xvciA9IHJnYjJoZXgoIG0uY29sb3JEaWZmdXNlICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBtLkRiZ0NvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuY29sb3IgPSBtLkRiZ0NvbG9yO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5jb2xvckVtaXNzaXZlICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuZW1pc3NpdmUgPSByZ2IyaGV4KCBtLmNvbG9yRW1pc3NpdmUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG10eXBlID09PSAnTWVzaFBob25nTWF0ZXJpYWwnICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtLmNvbG9yU3BlY3VsYXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbXBhcnMuc3BlY3VsYXIgPSByZ2IyaGV4KCBtLmNvbG9yU3BlY3VsYXIgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbS5zcGVjdWxhckNvZWYgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbXBhcnMuc2hpbmluZXNzID0gbS5zcGVjdWxhckNvZWY7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW9kaWZpZXJzXG5cbiAgICAgICAgICAgIGlmICggbS50cmFuc3BhcmVuY3kgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlcjogdHJhbnNwYXJlbmN5IGhhcyBiZWVuIHJlbmFtZWQgdG8gb3BhY2l0eScgKTtcbiAgICAgICAgICAgICAgICBtLm9wYWNpdHkgPSBtLnRyYW5zcGFyZW5jeTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMub3BhY2l0eSA9IG0ub3BhY2l0eTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZXh0dXJlc1xuXG4gICAgICAgICAgICBpZiAoIHRleHR1cmVQYXRoICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtLm1hcERpZmZ1c2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbWFwJywgbS5tYXBEaWZmdXNlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtLm1hcExpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ2xpZ2h0TWFwJywgbS5tYXBMaWdodCwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0ubWFwQU8gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYW9NYXAnLCBtLm1hcEFPLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbS5tYXBCdW1wICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ2J1bXBNYXAnLCBtLm1hcEJ1bXAsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0ubWFwTm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ25vcm1hbE1hcCcsIG0ubWFwTm9ybWFsLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0ubWFwU3BlY3VsYXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnc3BlY3VsYXJNYXAnLCBtLm1hcFNwZWN1bGFyLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbS5tYXBBbHBoYSApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdhbHBoYU1hcCcsIG0ubWFwQWxwaGEsIG0ubWFwQWxwaGFSZXBlYXQsIG0ubWFwQWxwaGFPZmZzZXQsIG0ubWFwQWxwaGFXcmFwLCBtLm1hcEFscGhhQW5pc290cm9weSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGlmICggbS5tYXBCdW1wU2NhbGUgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5idW1wU2NhbGUgPSBtLm1hcEJ1bXBTY2FsZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0ubWFwTm9ybWFsRmFjdG9yICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggbS5tYXBOb3JtYWxGYWN0b3IsIG0ubWFwTm9ybWFsRmFjdG9yICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFWyBtdHlwZSBdKCBtcGFycyApO1xuXG4gICAgICAgICAgICBpZiAoIG0uRGJnTmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IG0uRGJnTmFtZTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuXG4gICAgICAgIH07XG5cbiAgICB9ICkoKVxuXG59O1xuXG5USFJFRS5Mb2FkZXIuSGFuZGxlcnMgPSB7XG5cbiAgICBoYW5kbGVyczogW10sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCByZWdleCwgbG9hZGVyICkge1xuXG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xuXG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oIGZpbGUgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5oYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XG5cbiAgICAgICAgICAgIHZhciByZWdleCA9IHRoaXMuaGFuZGxlcnNbIGkgXTtcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmhhbmRsZXJzWyBpICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXI7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvWEhSTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5YSFJMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlhIUkxvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xuXG4gICAgICAgIGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCBjYWNoZWQgKTtcblxuICAgICAgICAgICAgICAgIH0sIDAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcblxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcy5yZXNwb25zZSApO1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGhpcy5yZXNwb25zZSApO1xuXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgICAgIH0sIGZhbHNlICk7XG5cbiAgICAgICAgaWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcblxuICAgICAgICAgICAgfSwgZmFsc2UgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuICAgICAgICB9LCBmYWxzZSApO1xuXG4gICAgICAgIGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG4gICAgICAgIGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG4gICAgICAgIGlmICggdGhpcy53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCApIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgICAgICAgcmVxdWVzdC5zZW5kKCBudWxsICk7XG5cbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuXG4gICAgfSxcblxuICAgIHNldFJlc3BvbnNlVHlwZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgc2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9JbWFnZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuSW1hZ2VMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcblxuICAgICAgICBpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIHtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCggY2FjaGVkICk7XG5cbiAgICAgICAgICAgICAgICB9LCAwICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcblxuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgVEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHRoaXMgKTtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcblxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgICAgICB9LCBmYWxzZSApO1xuXG4gICAgICAgIGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKCBldmVudCApO1xuXG4gICAgICAgICAgICB9LCBmYWxzZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuICAgICAgICB9LCBmYWxzZSApO1xuXG4gICAgICAgIGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XG5cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5KU09OTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICBpZiAoIHR5cGVvZiBtYW5hZ2VyID09PSAnYm9vbGVhbicgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogc2hvd1N0YXR1cyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGNvbnN0cnVjdG9yLicgKTtcbiAgICAgICAgbWFuYWdlciA9IHVuZGVmaW5lZDtcblxuICAgIH1cblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuSlNPTkxvYWRlcixcblxuICAgIC8vIERlcHJlY2F0ZWRcblxuICAgIGdldCBzdGF0dXNEb21FbGVtZW50KCkge1xuXG4gICAgICAgIGlmICggdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNEb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogLnN0YXR1c0RvbUVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXNEb21FbGVtZW50O1xuXG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXG4gICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cbiAgICAgICAgICAgIGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ29iamVjdCcgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5PYmplY3RMb2FkZXIgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ3NjZW5lJyApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLlNjZW5lTG9hZGVyIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHNjb3BlLnBhcnNlKCBqc29uLCB0ZXh0dXJlUGF0aCApO1xuICAgICAgICAgICAgb25Mb2FkKCBvYmplY3QuZ2VvbWV0cnksIG9iamVjdC5tYXRlcmlhbHMgKTtcblxuICAgICAgICB9ICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgc2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCBqc29uLCB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcbiAgICAgICAgICAgIHNjYWxlID0gKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSA/IDEuMCAvIGpzb24uc2NhbGUgOiAxLjA7XG5cbiAgICAgICAgcGFyc2VNb2RlbCggc2NhbGUgKTtcblxuICAgICAgICBwYXJzZVNraW4oKTtcbiAgICAgICAgcGFyc2VNb3JwaGluZyggc2NhbGUgKTtcblxuICAgICAgICBnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VNb2RlbCggc2NhbGUgKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgJiAoIDEgPDwgcG9zaXRpb24gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaSwgaiwgZmksXG5cbiAgICAgICAgICAgICAgICBvZmZzZXQsIHpMZW5ndGgsXG5cbiAgICAgICAgICAgICAgICBjb2xvckluZGV4LCBub3JtYWxJbmRleCwgdXZJbmRleCwgbWF0ZXJpYWxJbmRleCxcblxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgaXNRdWFkLFxuICAgICAgICAgICAgICAgIGhhc01hdGVyaWFsLFxuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhVdixcbiAgICAgICAgICAgICAgICBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxuICAgICAgICAgICAgICAgIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yLFxuXG4gICAgICAgICAgICAgICAgdmVydGV4LCBmYWNlLCBmYWNlQSwgZmFjZUIsIGhleCwgbm9ybWFsLFxuXG4gICAgICAgICAgICAgICAgdXZMYXllciwgdXYsIHUsIHYsXG5cbiAgICAgICAgICAgICAgICBmYWNlcyA9IGpzb24uZmFjZXMsXG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxuICAgICAgICAgICAgICAgIG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXG4gICAgICAgICAgICAgICAgY29sb3JzID0ganNvbi5jb2xvcnMsXG5cbiAgICAgICAgICAgICAgICBuVXZMYXllcnMgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXG5cbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGpzb24udXZzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMrKztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueCA9IHZlcnRpY2VzWyBvZmZzZXQrKyBdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgdmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0KysgXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCsrIF0gKiBzY2FsZTtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB6TGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICB0eXBlID0gZmFjZXNbIG9mZnNldCsrIF07XG5cblxuICAgICAgICAgICAgICAgIGlzUXVhZCA9IGlzQml0U2V0KCB0eXBlLCAwICk7XG4gICAgICAgICAgICAgICAgaGFzTWF0ZXJpYWwgPSBpc0JpdFNldCggdHlwZSwgMSApO1xuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhVdiA9IGlzQml0U2V0KCB0eXBlLCAzICk7XG4gICAgICAgICAgICAgICAgaGFzRmFjZU5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XG4gICAgICAgICAgICAgICAgaGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XG4gICAgICAgICAgICAgICAgaGFzRmFjZUNvbG9yID0gaXNCaXRTZXQoIHR5cGUsIDYgKTtcbiAgICAgICAgICAgICAgICBoYXNGYWNlVmVydGV4Q29sb3IgPSBpc0JpdFNldCggdHlwZSwgNyApO1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0eXBlXCIsIHR5cGUsIFwiYml0c1wiLCBpc1F1YWQsIGhhc01hdGVyaWFsLCBoYXNGYWNlVmVydGV4VXYsIGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yKTtcblxuICAgICAgICAgICAgICAgIGlmICggaXNRdWFkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XG4gICAgICAgICAgICAgICAgICAgIGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xuICAgICAgICAgICAgICAgICAgICBmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUIuYiA9IGZhY2VzWyBvZmZzZXQgKyAyIF07XG4gICAgICAgICAgICAgICAgICAgIGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG4gICAgICAgICAgICAgICAgICAgIGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqICE9PSAyICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF0gKiAzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlQS5ub3JtYWwuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUIubm9ybWFsLmNvcHkoIGZhY2VBLm5vcm1hbCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgNDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXSAqIDM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlQi5jb2xvci5zZXRIZXgoIGhleCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5hID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgIGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICBmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0KysgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc01hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuICAgICAgICAgICAgICAgICAgICBmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdICogMztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5ub3JtYWwuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF0gKiAzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlLmNvbG9yLnNldEhleCggY29sb3JzWyBjb2xvckluZGV4IF0gKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcblxuICAgICAgICAgICAgaWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luV2VpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBqc29uLnNraW5XZWlnaHRzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDEgXSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2tpbldlaWdodHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIHgsIHksIHosIHcgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgganNvbi5za2luSW5kaWNlcyApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0ganNvbi5za2luSW5kaWNlc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAxIF0gOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAyIF0gOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAzIF0gOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNraW5JbmRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCBhLCBiLCBjLCBkICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdXaGVuIHNraW5uaW5nLCBudW1iZXIgb2YgdmVydGljZXMgKCcgKyBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKyAnKSwgc2tpbkluZGljZXMgKCcgK1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGNvdWxkIGNoYW5nZSB0aGlzIHRvIGpzb24uYW5pbWF0aW9uc1swXSBvciByZW1vdmUgY29tcGxldGVseVxuXG4gICAgICAgICAgICBnZW9tZXRyeS5hbmltYXRpb24gPSBqc29uLmFuaW1hdGlvbjtcbiAgICAgICAgICAgIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBqc29uLmFuaW1hdGlvbnM7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU1vcnBoaW5nKCBzY2FsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGksIGwsIHYsIHZsLCBkc3RWZXJ0aWNlcywgc3JjVmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGRzdFZlcnRpY2VzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG4gICAgICAgICAgICAgICAgICAgIHNyY1ZlcnRpY2VzID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleC54ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3RWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaSwgbCwgYywgY2wsIGRzdENvbG9ycywgc3JjQ29sb3JzLCBjb2xvcjtcblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaENvbG9ycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoQ29sb3JzWyBpIF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBkc3RDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLmNvbG9ycztcbiAgICAgICAgICAgICAgICAgICAgc3JjQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgaSBdLmNvbG9ycztcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBjID0gMCwgY2wgPSBzcmNDb2xvcnMubGVuZ3RoOyBjIDwgY2w7IGMgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZhYTAwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvci5zZXRSR0IoIHNyY0NvbG9yc1sgYyBdLCBzcmNDb2xvcnNbIGMgKyAxIF0sIHNyY0NvbG9yc1sgYyArIDIgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHN0Q29sb3JzLnB1c2goIGNvbG9yICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIGpzb24ubWF0ZXJpYWxzID09PSB1bmRlZmluZWQgfHwganNvbi5tYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzOiBtYXRlcmlhbHNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uKCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGlzTG9hZGluZyA9IGZhbHNlLFxuICAgICAgICBpdGVtc0xvYWRlZCA9IDAsXG4gICAgICAgIGl0ZW1zVG90YWwgPSAwO1xuXG4gICAgdGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Mb2FkID0gb25Mb2FkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcblxuICAgIHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24oIHVybCApIHtcblxuICAgICAgICBpdGVtc1RvdGFsKys7XG5cbiAgICAgICAgaWYgKCBpc0xvYWRpbmcgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLm9uU3RhcnQoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpc0xvYWRpbmcgPSB0cnVlO1xuXG4gICAgfTtcblxuICAgIHRoaXMuaXRlbUVuZCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cbiAgICAgICAgaXRlbXNMb2FkZWQrKztcblxuICAgICAgICBpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgc2NvcGUub25Qcm9ncmVzcyggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGl0ZW1zTG9hZGVkID09PSBpdGVtc1RvdGFsICkge1xuXG4gICAgICAgICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLm9uTG9hZCgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuaXRlbUVycm9yID0gZnVuY3Rpb24oIHVybCApIHtcblxuICAgICAgICBpZiAoIHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgc2NvcGUub25FcnJvciggdXJsICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufTtcblxuVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCk7XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQnVmZmVyR2VvbWV0cnlMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXG4gICAgICAgICAgICBvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24oIGpzb24gKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0ganNvbi5kYXRhLmluZGV4O1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXkgPSBuZXcgc2VsZlsgaW5kZXgudHlwZSBdKCBpbmRleC5hcnJheSApO1xuICAgICAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIDEgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXkgPSBuZXcgc2VsZlsgYXR0cmlidXRlLnR5cGUgXSggYXR0cmlidXRlLmFycmF5ICk7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgga2V5LCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0ganNvbi5kYXRhLmdyb3VwcyB8fCBqc29uLmRhdGEuZHJhd2NhbGxzIHx8IGpzb24uZGF0YS5vZmZzZXRzO1xuXG4gICAgICAgIGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsraSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuICAgICAgICBpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICBpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY2VudGVyLmZyb21BcnJheSggYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTWF0ZXJpYWxMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcbiAgICB0aGlzLnRleHR1cmVzID0ge307XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRlcmlhbExvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggdGV4dCApIHtcblxuICAgICAgICAgICAgb25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgc2V0VGV4dHVyZXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLnRleHR1cmVzID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgZ2V0VGV4dHVyZTogZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcblxuICAgICAgICBpZiAoIHRleHR1cmVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWxMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcblxuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24oIGpzb24gKSB7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFWyBqc29uLnR5cGUgXTtcbiAgICAgICAgbWF0ZXJpYWwudXVpZCA9IGpzb24udXVpZDtcblxuICAgICAgICBpZiAoIGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcbiAgICAgICAgaWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcbiAgICAgICAgaWYgKCBqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcbiAgICAgICAgaWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcbiAgICAgICAgaWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG4gICAgICAgIGlmICgganNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudW5pZm9ybXMgPSBqc29uLnVuaWZvcm1zO1xuICAgICAgICBpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcbiAgICAgICAgaWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xuICAgICAgICBpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hhZGluZyA9IGpzb24uc2hhZGluZztcbiAgICAgICAgaWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG4gICAgICAgIGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xuICAgICAgICBpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcbiAgICAgICAgaWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG4gICAgICAgIGlmICgganNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xuICAgICAgICBpZiAoIGpzb24uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFRlc3QgPSBqc29uLmRlcHRoVGVzdDtcbiAgICAgICAgaWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG4gICAgICAgIGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xuICAgICAgICBpZiAoIGpzb24ud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBqc29uLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgICAgICAvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcbiAgICAgICAgaWYgKCBqc29uLnNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XG4gICAgICAgIGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xuXG4gICAgICAgIC8vIG1hcHNcblxuICAgICAgICBpZiAoIGpzb24ubWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubWFwICk7XG5cbiAgICAgICAgaWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmFscGhhTWFwICk7XG4gICAgICAgICAgICBtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcbiAgICAgICAgaWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XG5cbiAgICAgICAgaWYgKCBqc29uLm5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm5vcm1hbE1hcCApO1xuICAgICAgICBpZiAoIGpzb24ubm9ybWFsU2NhbGUgKSBtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqc29uLm5vcm1hbFNjYWxlLCBqc29uLm5vcm1hbFNjYWxlICk7XG5cbiAgICAgICAgaWYgKCBqc29uLmRpc3BsYWNlbWVudE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmRpc3BsYWNlbWVudE1hcCApO1xuICAgICAgICBpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgaWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICAgICAgaWYgKCBqc29uLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xuXG4gICAgICAgIGlmICgganNvbi5lbnZNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgbWF0ZXJpYWwuZW52TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xuICAgICAgICAgICAgbWF0ZXJpYWwuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGpzb24ucmVmbGVjdGl2aXR5ICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0ganNvbi5yZWZsZWN0aXZpdHk7XG5cbiAgICAgICAgaWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xuICAgICAgICBpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcblxuICAgICAgICBpZiAoIGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XG4gICAgICAgIGlmICgganNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgICAgIC8vIE1lc2hGYWNlTWF0ZXJpYWxcblxuICAgICAgICBpZiAoIGpzb24ubWF0ZXJpYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvT2JqZWN0TG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5PYmplY3RMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuICAgIHRoaXMudGV4dHVyZVBhdGggPSAnJztcblxufTtcblxuVEhSRUUuT2JqZWN0TG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3RMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnRleHR1cmVQYXRoID09PSAnJyApIHtcblxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlUGF0aCA9IHVybC5zdWJzdHJpbmcoIDAsIHVybC5sYXN0SW5kZXhPZiggJy8nICkgKyAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXG4gICAgICAgICAgICBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApLCBvbkxvYWQgKTtcblxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICB9LFxuXG4gICAgc2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCBqc29uLCBvbkxvYWQgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzICk7XG5cbiAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoIGpzb24uaW1hZ2VzLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMucGFyc2VUZXh0dXJlcygganNvbi50ZXh0dXJlcywgaW1hZ2VzICk7XG4gICAgICAgIHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKTtcblxuICAgICAgICBpZiAoIGpzb24uaW1hZ2VzID09PSB1bmRlZmluZWQgfHwganNvbi5pbWFnZXMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgIH0sXG5cbiAgICBwYXJzZUdlb21ldHJpZXM6IGZ1bmN0aW9uKCBqc29uICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyaWVzID0ge307XG5cbiAgICAgICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XG4gICAgICAgICAgICB2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uWyBpIF07XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUGxhbmVHZW9tZXRyeSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRVsgZGF0YS50eXBlIF0oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQm94R2VvbWV0cnknOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGVwdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXB0aFNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NpcmNsZUdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXNUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXNCb3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub3BlbkVuZGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTcGhlcmVHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ09jdGFoZWRyb25HZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGV0cmFoZWRyb25HZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JpbmdHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlubmVyUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub3V0ZXJSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHViZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHVidWxhclNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYXJjXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUb3J1c0tub3RHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHViZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHVidWxhclNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGV4dEdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV4dEdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEuZGF0YSwgdGhpcy50ZXh0dXJlUGF0aCApLmdlb21ldHJ5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCInICsgZGF0YS50eXBlICsgJ1wiJyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdlb21ldHJpZXM7XG5cbiAgICB9LFxuXG4gICAgcGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uKCBqc29uLCB0ZXh0dXJlcyApIHtcblxuICAgICAgICB2YXIgbWF0ZXJpYWxzID0ge307XG5cbiAgICAgICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIoKTtcbiAgICAgICAgICAgIGxvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBsb2FkZXIucGFyc2UoIGpzb25bIGkgXSApO1xuICAgICAgICAgICAgICAgIG1hdGVyaWFsc1sgbWF0ZXJpYWwudXVpZCBdID0gbWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGVyaWFscztcblxuICAgIH0sXG5cbiAgICBwYXJzZUltYWdlczogZnVuY3Rpb24oIGpzb24sIG9uTG9hZCApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICB2YXIgaW1hZ2VzID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlKCB1cmwgKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcblxuICAgICAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggbWFuYWdlciApO1xuICAgICAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0ganNvblsgaSBdO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KCBpbWFnZS51cmwgKSA/IGltYWdlLnVybCA6IHNjb3BlLnRleHR1cmVQYXRoICsgaW1hZ2UudXJsO1xuXG4gICAgICAgICAgICAgICAgaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBsb2FkSW1hZ2UoIHBhdGggKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW1hZ2VzO1xuXG4gICAgfSxcblxuICAgIHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uKCBqc29uLCBpbWFnZXMgKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VDb25zdGFudCggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mKCB2YWx1ZSApID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gVEhSRUVbIHZhbHVlIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHt9O1xuXG4gICAgICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0ganNvblsgaSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLmltYWdlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBcImltYWdlXCIgc3BlY2lmaWVkIGZvcicsIGRhdGEudXVpZCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZyApO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEub2Zmc2V0WyAwIF0sIGRhdGEub2Zmc2V0WyAxIF0gKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBkYXRhLnJlcGVhdFsgMCBdLCBkYXRhLnJlcGVhdFsgMSBdICk7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciApO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xuICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggZGF0YS53cmFwICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS53cmFwUyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMCBdICk7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZXNbIGRhdGEudXVpZCBdID0gdGV4dHVyZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZXM7XG5cbiAgICB9LFxuXG4gICAgcGFyc2VPYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkge1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0O1xuXG4gICAgICAgICAgICB2YXIgZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0TWF0ZXJpYWwgPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3dpdGNoICggZGF0YS50eXBlICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnU2NlbmUnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdBbWJpZW50TGlnaHQnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoIGRhdGEuY29sb3IgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnUG9pbnRMaWdodCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdTcG90TGlnaHQnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLmV4cG9uZW50LCBkYXRhLmRlY2F5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdNZXNoJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnTE9EJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTE9EKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdMaW5lJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTGluZSggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSwgZGF0YS5tb2RlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdQb2ludENsb3VkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdQb2ludHMnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ1Nwcml0ZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnR3JvdXAnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcblxuICAgICAgICAgICAgaWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICAgICAgaWYgKCBkYXRhLm1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcbiAgICAgICAgICAgICAgICBtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmNhc3RTaGFkb3cgPSBkYXRhLmNhc3RTaGFkb3c7XG4gICAgICAgICAgICBpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cbiAgICAgICAgICAgIGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcbiAgICAgICAgICAgIGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblxuICAgICAgICAgICAgaWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgY2hpbGQgaW4gZGF0YS5jaGlsZHJlbiApIHtcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLmNoaWxkcmVuWyBjaGlsZCBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBsZXZlbHMgPSBkYXRhLmxldmVscztcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGwgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoICd1dWlkJywgbGV2ZWwub2JqZWN0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgICAgIH1cblxuICAgIH0oKVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5UZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIGltYWdlICkge1xuXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBpbWFnZSApO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9CaW5hcnlUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXG4gKlxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxuICovXG5cblRIUkVFLkRhdGFUZXh0dXJlTG9hZGVyID0gVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICAvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuICAgIHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbn07XG5cblRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggYnVmZmVyICkge1xuXG4gICAgICAgICAgICB2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xuXG4gICAgICAgICAgICBpZiAoICF0ZXhEYXRhICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmRhdGEgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBUID8gdGV4RGF0YS53cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cbiAgICAgICAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWluRmlsdGVyID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgICAgIHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcblxuICAgICAgICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZm9ybWF0ICkge1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUudHlwZSA9IHRleERhdGEudHlwZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taXBtYXBzICkge1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggMSA9PT0gdGV4RGF0YS5taXBtYXBDb3VudCApIHtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xuXG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcbiAqL1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICAvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuICAgIHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbn07XG5cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKCk7XG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XG5cbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiggaSApIHtcblxuICAgICAgICAgICAgICAgIGxvYWRlci5sb2FkKCB1cmxbIGkgXSwgZnVuY3Rpb24oIGJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGkgXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkICs9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKytpICkge1xuXG4gICAgICAgICAgICAgICAgbG9hZFRleHR1cmUoIGkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxuXG4gICAgICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggYnVmZmVyICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pcG1hcHM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCB0ZXhEYXRhcy5taXBtYXBzWyBmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24oKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IFRIUkVFLk1hdGVyaWFsSWRDb3VudCsrXG4gICAgfSApO1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XG5cbiAgICB0aGlzLnNpZGUgPSBUSFJFRS5Gcm9udFNpZGU7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuICAgIHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcblxuICAgIHRoaXMuYmxlbmRTcmMgPSBUSFJFRS5TcmNBbHBoYUZhY3RvcjtcbiAgICB0aGlzLmJsZW5kRHN0ID0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvcjtcbiAgICB0aGlzLmJsZW5kRXF1YXRpb24gPSBUSFJFRS5BZGRFcXVhdGlvbjtcbiAgICB0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgIHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG4gICAgdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXG4gICAgdGhpcy5kZXB0aEZ1bmMgPSBUSFJFRS5MZXNzRXF1YWxEZXB0aDtcbiAgICB0aGlzLmRlcHRoVGVzdCA9IHRydWU7XG4gICAgdGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblxuICAgIHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cbiAgICB0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXG5cbiAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcbiAgICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuICAgIHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcblxuICAgIHRoaXMuYWxwaGFUZXN0ID0gMDtcblxuICAgIHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXG5cbiAgICBnZXQgbmVlZHNVcGRhdGUoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlO1xuXG4gICAgfSxcblxuICAgIHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBzZXRWYWx1ZXM6IGZ1bmN0aW9uKCB2YWx1ZXMgKSB7XG5cbiAgICAgICAgaWYgKCB2YWx1ZXMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcblxuICAgICAgICAgICAgaWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLk1hdGVyaWFsOiAnXCIgKyBrZXkgKyBcIicgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cIiApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcblxuICAgICAgICAgICAgaWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5cIiArIHRoaXMudHlwZSArIFwiOiAnXCIgKyBrZXkgKyBcIicgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC5cIiApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGtleSA9PT0gJ292ZXJkcmF3JyApIHtcblxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0aWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcbiAgICAgICAgICAgICAgICB0aGlzWyBrZXkgXSA9IE51bWJlciggbmV3VmFsdWUgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnTWF0ZXJpYWwnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXG4gICAgICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICAgICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgICAgaWYgKCB0aGlzLmNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICAgICAgaWYgKCB0aGlzLmVtaXNzaXZlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcbiAgICAgICAgaWYgKCB0aGlzLnNwZWN1bGFyIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcbiAgICAgICAgaWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcblxuICAgICAgICBpZiAoIHRoaXMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgaWYgKCB0aGlzLmFscGhhTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgIGlmICggdGhpcy5saWdodE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICBpZiAoIHRoaXMuYnVtcE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIGRhdGEuYnVtcE1hcCA9IHRoaXMuYnVtcE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICAgICAgZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcblxuICAgICAgICB9XG4gICAgICAgIGlmICggdGhpcy5ub3JtYWxNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG4gICAgICAgICAgICBkYXRhLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgICAgICBkYXRhLm5vcm1hbFNjYWxlID0gdGhpcy5ub3JtYWxTY2FsZTsgLy8gUmVtb3ZlZCBmb3Igbm93LCBjYXVzZXMgaXNzdWUgaW4gZWRpdG9yIHVpLmpzXG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMuZGlzcGxhY2VtZW50TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICAgICAgZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICBkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMuc3BlY3VsYXJNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgaWYgKCB0aGlzLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgICAgIGRhdGEucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7IC8vIFNjYWxlIGJlaGluZCBlbnZNYXBcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKCB0aGlzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcblxuICAgICAgICBpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcbiAgICAgICAgaWYgKCB0aGlzLnNoYWRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNoYWRpbmcgIT09IFRIUkVFLlNtb290aFNoYWRpbmcgKSBkYXRhLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG4gICAgICAgIGlmICggdGhpcy5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG4gICAgICAgIGlmICggdGhpcy5zaWRlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cbiAgICAgICAgaWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICBpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgKSBkYXRhLnRyYW5zcGFyZW50ID0gdGhpcy50cmFuc3BhcmVudDtcbiAgICAgICAgaWYgKCB0aGlzLmFscGhhVGVzdCA+IDAgKSBkYXRhLmFscGhhVGVzdCA9IHRoaXMuYWxwaGFUZXN0O1xuICAgICAgICBpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcbiAgICAgICAgaWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuICAgICAgICB0aGlzLnNpZGUgPSBzb3VyY2Uuc2lkZTtcblxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBzb3VyY2Uub3BhY2l0eTtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcblxuICAgICAgICB0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xuXG4gICAgICAgIHRoaXMuYmxlbmRTcmMgPSBzb3VyY2UuYmxlbmRTcmM7XG4gICAgICAgIHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xuICAgICAgICB0aGlzLmJsZW5kU3JjQWxwaGEgPSBzb3VyY2UuYmxlbmRTcmNBbHBoYTtcbiAgICAgICAgdGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcblxuICAgICAgICB0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XG4gICAgICAgIHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcbiAgICAgICAgdGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XG5cbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xuXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3RvcjtcbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzb3VyY2UucG9seWdvbk9mZnNldFVuaXRzO1xuXG4gICAgICAgIHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblxuICAgICAgICB0aGlzLm92ZXJkcmF3ID0gc291cmNlLm92ZXJkcmF3O1xuXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICB0eXBlOiAndXBkYXRlJ1xuICAgICAgICB9ICk7XG5cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICB0eXBlOiAnZGlzcG9zZSdcbiAgICAgICAgfSApO1xuXG4gICAgfSxcblxuICAgIC8vIERlcHJlY2F0ZWRcblxuICAgIGdldCB3cmFwQXJvdW5kKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICBzZXQgd3JhcEFyb3VuZCggYm9vbGVhbiApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0IHdyYXBSR0IoKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLkNvbG9yKCk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG4gICAgdGhpcy5saW5ld2lkdGggPSAxO1xuICAgIHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG4gICAgdGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgdGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuICAgIHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xuICAgIHRoaXMubGluZWpvaW4gPSBzb3VyY2UubGluZWpvaW47XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVEYXNoZWRNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBzY2FsZTogPGZsb2F0PixcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcbiAqICBnYXBTaXplOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG4gICAgdGhpcy5saW5ld2lkdGggPSAxO1xuXG4gICAgdGhpcy5zY2FsZSA9IDE7XG4gICAgdGhpcy5kYXNoU2l6ZSA9IDM7XG4gICAgdGhpcy5nYXBTaXplID0gMTtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XG5cbiAgICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsO1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgdGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuXG4gICAgdGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcbiAgICB0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuICAgIHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxuXG4gICAgdGhpcy5tYXAgPSBudWxsO1xuXG4gICAgdGhpcy5hb01hcCA9IG51bGw7XG4gICAgdGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmVudk1hcCA9IG51bGw7XG4gICAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcblxuICAgIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICAgIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtcblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cbiAgICB0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gICAgdGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuICpcbiAqXHRmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcbiAgICB0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuXG4gICAgdGhpcy5tYXAgPSBudWxsO1xuXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICAgIHRoaXMuZW52TWFwID0gbnVsbDtcbiAgICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgICB0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtcblxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG4gICAgdGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cbiAgICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gICAgdGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuICAgIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICB0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hQaG9uZ01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIHNwZWN1bGFyOiA8aGV4PixcbiAqICBzaGluaW5lc3M6IDxmbG9hdD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBidW1wU2NhbGU6IDxmbG9hdD4sXG4gKlxuICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuICpcbiAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG4gKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuICpcbiAqXHRmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuICAgIHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XG4gICAgdGhpcy5zcGVjdWxhciA9IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKTtcbiAgICB0aGlzLnNoaW5pbmVzcyA9IDMwO1xuXG4gICAgdGhpcy5tZXRhbCA9IGZhbHNlO1xuXG4gICAgdGhpcy5tYXAgPSBudWxsO1xuXG4gICAgdGhpcy5saWdodE1hcCA9IG51bGw7XG4gICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIHRoaXMuYW9NYXAgPSBudWxsO1xuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICB0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuICAgIHRoaXMuYnVtcE1hcCA9IG51bGw7XG4gICAgdGhpcy5idW1wU2NhbGUgPSAxO1xuXG4gICAgdGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuICAgIHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuICAgIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICAgIHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5lbnZNYXAgPSBudWxsO1xuICAgIHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgICB0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgICB0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDtcblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuICAgIHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG4gICAgdGhpcy5zcGVjdWxhci5jb3B5KCBzb3VyY2Uuc3BlY3VsYXIgKTtcbiAgICB0aGlzLnNoaW5pbmVzcyA9IHNvdXJjZS5zaGluaW5lc3M7XG5cbiAgICB0aGlzLm1ldGFsID0gc291cmNlLm1ldGFsO1xuXG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgdGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcbiAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgdGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblxuICAgIHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuICAgIHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuICAgIHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcbiAgICB0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG4gICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuICAgIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG4gICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICB0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICB0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hEZXB0aE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtcblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTXVsdGlNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTXVsdGlNYXRlcmlhbCA9IGZ1bmN0aW9uKCBtYXRlcmlhbHMgKSB7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy50eXBlID0gJ011bHRpTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5tYXRlcmlhbHMgPSBtYXRlcmlhbHMgaW5zdGFuY2VvZiBBcnJheSA/IG1hdGVyaWFscyA6IFtdO1xuXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuTXVsdGlNYXRlcmlhbC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTXVsdGlNYXRlcmlhbCxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC4yLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdtYXRlcmlhbCcsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnTWF0ZXJpYWxFeHBvcnRlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1dWlkOiB0aGlzLnV1aWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBtYXRlcmlhbHM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBvdXRwdXQubWF0ZXJpYWxzLnB1c2goIHRoaXMubWF0ZXJpYWxzWyBpIF0udG9KU09OKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgbWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMubWF0ZXJpYWxzWyBpIF0uY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBtYXRlcmlhbC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgICAgIHJldHVybiBtYXRlcmlhbDtcblxuICAgIH1cblxufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA9IFRIUkVFLk11bHRpTWF0ZXJpYWw7XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9Qb2ludHNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBzaXplOiA8ZmxvYXQ+LFxuICogIHNpemVBdHRlbnVhdGlvbjogPGJvb2w+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5Qb2ludHNNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BvaW50c01hdGVyaWFsJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cbiAgICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgICB0aGlzLnNpemUgPSAxO1xuICAgIHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50c01hdGVyaWFsO1xuXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgICB0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcbiAgICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcbiAqICB1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LCBcInBhcmFtZXRlcjJcIjogeyB0eXBlOiBcImlcIiB2YWx1ZTI6IDIgfSB9LFxuICpcbiAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXG4gKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIGxpZ2h0czogPGJvb2w+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKlx0Zm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcblxuICAgIHRoaXMuZGVmaW5lcyA9IHt9O1xuICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcblxuICAgIHRoaXMudmVydGV4U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufSc7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XFxufSc7XG5cbiAgICB0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG4gICAgdGhpcy5saW5ld2lkdGggPSAxO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgICB0aGlzLmZvZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xuXG4gICAgdGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cblxuICAgIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBza2lubmluZyBhdHRyaWJ1dGUgc3RyZWFtc1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXG5cbiAgICB0aGlzLmRlcml2YXRpdmVzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcblxuICAgIC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxuICAgIC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cbiAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSB7XG4gICAgICAgICdjb2xvcic6IFsgMSwgMSwgMSBdLFxuICAgICAgICAndXYnOiBbIDAsIDAgXSxcbiAgICAgICAgJ3V2Mic6IFsgMCwgMCBdXG4gICAgfTtcblxuICAgIHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGlmICggcGFyYW1ldGVycy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XG5cblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XG5cbiAgICB0aGlzLnVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc291cmNlLnVuaWZvcm1zICk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcbiAgICB0aGlzLmRlZmluZXMgPSBzb3VyY2UuZGVmaW5lcztcblxuICAgIHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG4gICAgdGhpcy5kZXJpdmF0aXZlcyA9IHNvdXJjZS5kZXJpdmF0aXZlcztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIGRhdGEudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG4gICAgZGF0YS5mcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXI7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxufTtcblxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbDtcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICpcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuICAgIHRoaXMubWFwID0gbnVsbDtcblxuICAgIHRoaXMucm90YXRpb24gPSAwO1xuXG4gICAgdGhpcy5mb2cgPSBmYWxzZTtcblxuICAgIC8vIHNldCBwYXJhbWV0ZXJzXG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZU1hdGVyaWFsO1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgdGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9UZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuVGV4dHVyZSA9IGZ1bmN0aW9uKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBUSFJFRS5UZXh0dXJlSWRDb3VudCsrXG4gICAgfSApO1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMuc291cmNlRmlsZSA9ICcnO1xuXG4gICAgdGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRTtcbiAgICB0aGlzLm1pcG1hcHMgPSBbXTtcblxuICAgIHRoaXMubWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORztcblxuICAgIHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcbiAgICB0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG4gICAgdGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XG5cbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcblxuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcbiAgICB0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG4gICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG4gICAgdGhpcy5mbGlwWSA9IHRydWU7XG4gICAgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0OyAvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcblxuICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgdGhpcy5vblVwZGF0ZSA9IG51bGw7XG5cbn07XG5cblRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcblRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVEhSRUUuVVZNYXBwaW5nO1xuXG5USFJFRS5UZXh0dXJlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlLFxuXG4gICAgc2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uKys7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBzb3VyY2UuaW1hZ2U7XG4gICAgICAgIHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XG5cbiAgICAgICAgdGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XG5cbiAgICAgICAgdGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcbiAgICAgICAgdGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblxuICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG4gICAgICAgIHRoaXMubWluRmlsdGVyID0gc291cmNlLm1pbkZpbHRlcjtcblxuICAgICAgICB0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblxuICAgICAgICB0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xuXG4gICAgICAgIHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcbiAgICAgICAgdGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG4gICAgICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgICAgIGlmICggbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcblxuICAgICAgICAgICAgdmFyIGNhbnZhcztcblxuICAgICAgICAgICAgaWYgKCBpbWFnZS50b0RhdGFVUkwgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGltYWdlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICkuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggY2FudmFzLndpZHRoID4gMjA0OCB8fCBjYW52YXMuaGVpZ2h0ID4gMjA0OCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnVGV4dHVyZScsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1dWlkOiB0aGlzLnV1aWQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG5cbiAgICAgICAgICAgIG1hcHBpbmc6IHRoaXMubWFwcGluZyxcblxuICAgICAgICAgICAgcmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcbiAgICAgICAgICAgIG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXG4gICAgICAgICAgICB3cmFwOiBbIHRoaXMud3JhcFMsIHRoaXMud3JhcFQgXSxcblxuICAgICAgICAgICAgbWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXG4gICAgICAgICAgICBhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBUSFJFRS5JbWFnZVxuXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgICAgICAgICBpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGltYWdlLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHV1aWQ6IGltYWdlLnV1aWQsXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0LmltYWdlID0gaW1hZ2UudXVpZDtcblxuICAgICAgICB9XG5cbiAgICAgICAgbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgICB9ICk7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtVXY6IGZ1bmN0aW9uKCB1diApIHtcblxuICAgICAgICBpZiAoIHRoaXMubWFwcGluZyAhPT0gVEhSRUUuVVZNYXBwaW5nICkgcmV0dXJuO1xuXG4gICAgICAgIHV2Lm11bHRpcGx5KCB0aGlzLnJlcGVhdCApO1xuICAgICAgICB1di5hZGQoIHRoaXMub2Zmc2V0ICk7XG5cbiAgICAgICAgaWYgKCB1di54IDwgMCB8fCB1di54ID4gMSApIHtcblxuICAgICAgICAgICAgc3dpdGNoICggdGhpcy53cmFwUyApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuUmVwZWF0V3JhcHBpbmc6XG5cbiAgICAgICAgICAgICAgICAgICAgdXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG4gICAgICAgICAgICAgICAgICAgIHV2LnggPSB1di54IDwgMCA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di54ICkgJSAyICkgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHV2LnggPSBNYXRoLmNlaWwoIHV2LnggKSAtIHV2Lng7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHV2LnkgPCAwIHx8IHV2LnkgPiAxICkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCB0aGlzLndyYXBUICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5SZXBlYXRXcmFwcGluZzpcblxuICAgICAgICAgICAgICAgICAgICB1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc6XG5cbiAgICAgICAgICAgICAgICAgICAgdXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnkgKSAlIDIgKSA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXYueSA9IE1hdGguY2VpbCggdXYueSApIC0gdXYueTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5mbGlwWSApIHtcblxuICAgICAgICAgICAgdXYueSA9IDEgLSB1di55O1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuVGV4dHVyZUlkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DYW52YXNUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DYW52YXNUZXh0dXJlID0gZnVuY3Rpb24oIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLkNhbnZhc1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkNhbnZhc1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FudmFzVGV4dHVyZTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ3ViZVRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkN1YmVUZXh0dXJlID0gZnVuY3Rpb24oIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgbWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlVGV4dHVyZTtcblxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuaW1hZ2VzID0gc291cmNlLmltYWdlcztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ29tcHJlc3NlZFRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlID0gZnVuY3Rpb24oIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICB0aGlzLmltYWdlID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLm1pcG1hcHMgPSBtaXBtYXBzO1xuXG4gICAgLy8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcbiAgICAvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxuXG4gICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xuXG4gICAgLy8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuICAgIC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcblxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvRGF0YVRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkRhdGFUZXh0dXJlID0gZnVuY3Rpb24oIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICB0aGlzLmltYWdlID0ge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcblxuICAgIHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXG4gICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EYXRhVGV4dHVyZTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVmlkZW9UZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5WaWRlb1RleHR1cmUgPSBmdW5jdGlvbiggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcblxuICAgICAgICBpZiAoIHZpZGVvLnJlYWR5U3RhdGUgPT09IHZpZGVvLkhBVkVfRU5PVUdIX0RBVEEgKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZpZGVvVGV4dHVyZTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Hcm91cC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR3JvdXAgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdHcm91cCc7XG5cbn07XG5cblRIUkVFLkdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3JvdXA7XG4vLyBGaWxlOnNyYy9vYmplY3RzL1BvaW50cy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRzID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQb2ludHMnO1xuXG4gICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZlxuICAgIH0gKTtcblxufTtcblxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50cztcblxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICAgICAgICB2YXIgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5Qb2ludHMudGhyZXNob2xkO1xuXG4gICAgICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuICAgICAgICByYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG4gICAgICAgIHZhciBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICBmdW5jdGlvbiB0ZXN0UG9pbnQoIHBvaW50LCBpbmRleCApIHtcblxuICAgICAgICAgICAgdmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcblxuICAgICAgICAgICAgaWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdFxuXG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5kaWNlc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRlc3RQb2ludCggcG9zaXRpb24sIGEgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSAqIDMgKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXN0UG9pbnQoIHBvc2l0aW9uLCBpICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdGVzdFBvaW50KCB2ZXJ0aWNlc1sgaSBdLCBpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkgKTtcblxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIGdlb21ldHJpZXMgY2FjaGVcbiAgICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oKTtcblxuICAgIH1cblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICAgIGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oKTtcblxuICAgIH1cblxuICAgIGRhdGEub2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuICAgIGRhdGEub2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBvaW50Q2xvdWQgPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5QYXJ0aWNsZVN5c3RlbSA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxpbmUgPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsLCBtb2RlICkge1xuXG4gICAgaWYgKCBtb2RlID09PSAxICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmU6IHBhcmFtZXRlciBUSFJFRS5MaW5lUGllY2VzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIENyZWF0ZWQgVEhSRUUuTGluZVNlZ21lbnRzIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLkxpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB9XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTGluZSc7XG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lO1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIubGluZVByZWNpc2lvbjtcbiAgICAgICAgdmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuICAgICAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgaWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICAgICAgdmFyIHZTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2RW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBpbnRlclJheSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBzdGVwID0gdGhpcyBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyA/IDIgOiAxO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5kaWNlc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGluZGljZXNbIGkgKyAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuICAgICAgICAgICAgICAgICAgICB2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XG4gICAgICAgICAgICAgICAgICAgIHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICsgMyApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgICAgICAgdmFyIG5iVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpICs9IHN0ZXAgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkgKTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICAgIGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTigpO1xuXG4gICAgfVxuXG4gICAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgbWF0ZXJpYWxzIGNhY2hlXG4gICAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTigpO1xuXG4gICAgfVxuXG4gICAgZGF0YS5vYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XG4gICAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gREVQUkVDQVRFRFxuXG5USFJFRS5MaW5lU3RyaXAgPSAwO1xuVEhSRUUuTGluZVBpZWNlcyA9IDE7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGluZVNlZ21lbnRzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lU2VnbWVudHMgPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgVEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXG59O1xuXG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lU2VnbWVudHM7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbS9cbiAqL1xuXG5USFJFRS5NZXNoID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdNZXNoJztcblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZcbiAgICB9ICk7XG5cbiAgICB0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG59O1xuXG5USFJFRS5NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoO1xuXG5USFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNb3JwaFRhcmdldHMgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmICggdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRCYXNlID0gLTE7XG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cbiAgICAgICAgZm9yICggdmFyIG0gPSAwLCBtbCA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgbSBdLm5hbWUgXSA9IG07XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICBpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcblxuICAgIH1cblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2guZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZTogbW9ycGggdGFyZ2V0ICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdC4gUmV0dXJuaW5nIDAuJyApO1xuXG4gICAgcmV0dXJuIDA7XG5cbn07XG5cblxuVEhSRUUuTWVzaC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcbiAgICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgdmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgdGVtcEEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB0ZW1wQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHRlbXBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciB1dkEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHZhciB1dkIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHZhciB1dkMgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgdmFyIGJhcnljb29yZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGZ1bmN0aW9uIHV2SW50ZXJzZWN0aW9uKCBwb2ludCwgcDEsIHAyLCBwMywgdXYxLCB1djIsIHV2MyApIHtcblxuICAgICAgICBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBwMSwgcDIsIHAzLCBiYXJ5Y29vcmQgKTtcblxuICAgICAgICB1djEubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC54ICk7XG4gICAgICAgIHV2Mi5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnkgKTtcbiAgICAgICAgdXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xuXG4gICAgICAgIHV2MS5hZGQoIHV2MiApLmFkZCggdXYzICk7XG5cbiAgICAgICAgcmV0dXJuIHV2MS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICBpZiAoIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xuXG4gICAgICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuICAgICAgICByYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSwgYiwgYztcblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGEgPSBpbmRpY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBjID0gaW5kaWNlc1sgaSArIDIgXTtcblxuICAgICAgICAgICAgICAgICAgICB2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcbiAgICAgICAgICAgICAgICAgICAgdkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG4gICAgICAgICAgICAgICAgICAgIHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QywgdkIsIHZBLCB0cnVlLCBpbnRlcnNlY3Rpb25Qb2ludCApID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUsIGludGVyc2VjdGlvblBvaW50ICkgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50V29ybGQgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2QS5mcm9tQXJyYXkoIHV2cywgYSAqIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2Qy5mcm9tQXJyYXkoIHV2cywgYyAqIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCB2QSwgdkIsIHZDLCB1dkEsIHV2QiwgdXZDICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXY6IHV2LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZTogbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBNYXRoLmZsb29yKCBpIC8gMyApLCAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kaWNlcyBidWZmZXIgc2VtYW50aWNzXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSA5ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgICAgICAgICAgIHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xuICAgICAgICAgICAgICAgICAgICB2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDYgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkMsIHZCLCB2QSwgdHJ1ZSwgaW50ZXJzZWN0aW9uUG9pbnQgKSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QSwgdkIsIHZDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBpbnRlcnNlY3Rpb25Qb2ludCApID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggaW50ZXJzZWN0aW9uUG9pbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1djtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dkEuZnJvbUFycmF5KCB1dnMsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2Qi5mcm9tQXJyYXkoIHV2cywgaSArIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2Qy5mcm9tQXJyYXkoIHV2cywgaSArIDQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCB2QSwgdkIsIHZDLCB1dkEsIHV2QiwgdXZDICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGEgPSBpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgYiA9IGEgKyAxO1xuICAgICAgICAgICAgICAgICAgICBjID0gYSArIDI7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB1djogdXYsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogYSwgLy8gdHJpYW5nbGUgbnVtYmVyIGluIHBvc2l0aW9ucyBidWZmZXIgc2VtYW50aWNzXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgaXNGYWNlTWF0ZXJpYWwgPSBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWw7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICAgICAgICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGYgXTtcbiAgICAgICAgICAgICAgICB2YXIgZmFjZU1hdGVyaWFsID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogbWF0ZXJpYWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZhY2VNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBhID0gdmVydGljZXNbIGZhY2UuYSBdO1xuICAgICAgICAgICAgICAgIGIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgICAgICAgICAgICAgYyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgICAgICAgICAgICAgIGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgdkEuc2V0KCAwLCAwLCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHZCLnNldCggMCwgMCwgMCApO1xuICAgICAgICAgICAgICAgICAgICB2Qy5zZXQoIDAsIDAsIDAgKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBtb3JwaFRhcmdldHNbIHQgXS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdkEuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQS5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmEgXSwgYSApLCBpbmZsdWVuY2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZCLmFkZFNjYWxlZFZlY3RvciggdGVtcEIuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5iIF0sIGIgKSwgaW5mbHVlbmNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2Qy5hZGRTY2FsZWRWZWN0b3IoIHRlbXBDLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYyBdLCBjICksIGluZmx1ZW5jZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2QS5hZGQoIGEgKTtcbiAgICAgICAgICAgICAgICAgICAgdkIuYWRkKCBiICk7XG4gICAgICAgICAgICAgICAgICAgIHZDLmFkZCggYyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGEgPSB2QTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IHZCO1xuICAgICAgICAgICAgICAgICAgICBjID0gdkM7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZhY2VNYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJheS5pbnRlcnNlY3RUcmlhbmdsZSggYywgYiwgYSwgdHJ1ZSwgaW50ZXJzZWN0aW9uUG9pbnQgKSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBmYWNlTWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSwgaW50ZXJzZWN0aW9uUG9pbnQgKSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgdXY7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1dnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF1bIGYgXTtcbiAgICAgICAgICAgICAgICAgICAgdXZBLmNvcHkoIHV2c1sgMCBdICk7XG4gICAgICAgICAgICAgICAgICAgIHV2Qi5jb3B5KCB1dnNbIDEgXSApO1xuICAgICAgICAgICAgICAgICAgICB1dkMuY29weSggdXZzWyAyIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgdXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGEsIGIsIGMsIHV2QSwgdXZCLCB1dkMgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgdXY6IHV2LFxuICAgICAgICAgICAgICAgICAgICBmYWNlOiBmYWNlLFxuICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IGYsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpICk7XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIGdlb21ldHJpZXMgY2FjaGVcbiAgICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oIG1ldGEgKTtcblxuICAgIH1cblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICAgIGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oIG1ldGEgKTtcblxuICAgIH1cblxuICAgIGRhdGEub2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuICAgIGRhdGEub2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvQm9uZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uKCBza2luICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0JvbmUnO1xuXG4gICAgdGhpcy5za2luID0gc2tpbjtcblxufTtcblxuVEhSRUUuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkJvbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm9uZTtcblxuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuc2tpbiA9IHNvdXJjZS5za2luO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU2tlbGV0b24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2VsZXRvbiA9IGZ1bmN0aW9uKCBib25lcywgYm9uZUludmVyc2VzLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XG5cbiAgICB0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIC8vIGNvcHkgdGhlIGJvbmUgYXJyYXlcblxuICAgIGJvbmVzID0gYm9uZXMgfHwgW107XG5cbiAgICB0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblxuICAgIC8vIGNyZWF0ZSBhIGJvbmUgdGV4dHVyZSBvciBhbiBhcnJheSBvZiBmbG9hdHNcblxuICAgIGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICAgIC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcbiAgICAgICAgLy8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuICAgICAgICAvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxuICAgICAgICAvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcbiAgICAgICAgLy8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG4gICAgICAgIC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxuXG5cbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuYm9uZXMubGVuZ3RoICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XG4gICAgICAgIHNpemUgPSBUSFJFRS5NYXRoLm5leHRQb3dlck9mVHdvKCBNYXRoLmNlaWwoIHNpemUgKSApO1xuICAgICAgICBzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcblxuICAgICAgICB0aGlzLmJvbmVUZXh0dXJlV2lkdGggPSBzaXplO1xuICAgICAgICB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ID0gc2l6ZTtcblxuICAgICAgICB0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG4gICAgICAgIHRoaXMuYm9uZVRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIHRoaXMuYm9uZU1hdHJpY2VzLCB0aGlzLmJvbmVUZXh0dXJlV2lkdGgsIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQsIFRIUkVFLlJHQkFGb3JtYXQsIFRIUkVFLkZsb2F0VHlwZSApO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB0aGlzLmJvbmVzLmxlbmd0aCApO1xuXG4gICAgfVxuXG4gICAgLy8gdXNlIHRoZSBzdXBwbGllZCBib25lIGludmVyc2VzIG9yIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZXNcblxuICAgIGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzLnNsaWNlKCAwICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XG5cbiAgICAgICAgICAgIHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiKysgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgVEhSRUUuTWF0cml4NCgpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jYWxjdWxhdGVJbnZlcnNlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiKysgKSB7XG5cbiAgICAgICAgdmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIGlmICggdGhpcy5ib25lc1sgYiBdICkge1xuXG4gICAgICAgICAgICBpbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgYm9uZTtcblxuICAgIC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIrKyApIHtcblxuICAgICAgICBib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG4gICAgICAgIGlmICggYm9uZSApIHtcblxuICAgICAgICAgICAgYm9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcblxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiKysgKSB7XG5cbiAgICAgICAgYm9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuICAgICAgICBpZiAoIGJvbmUgKSB7XG5cbiAgICAgICAgICAgIGlmICggYm9uZS5wYXJlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICBib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgYm9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvbmUubWF0cml4LmRlY29tcG9zZSggYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBvZmZzZXRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgICAgICAvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcblxuICAgICAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYisrICkge1xuXG4gICAgICAgICAgICAvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5ib25lc1sgYiBdID8gdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkIDogdGhpcy5pZGVudGl0eU1hdHJpeDtcblxuICAgICAgICAgICAgb2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuICAgICAgICAgICAgb2Zmc2V0TWF0cml4LmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB0aGlzLmJvbmVNYXRyaWNlcywgYiAqIDE2ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59ICkoKTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlNrZWxldG9uKCB0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcywgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU2tpbm5lZE1lc2guanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLlNraW5uZWRNZXNoID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xuXG4gICAgdGhpcy5iaW5kTW9kZSA9IFwiYXR0YWNoZWRcIjtcbiAgICB0aGlzLmJpbmRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgLy8gaW5pdCBib25lc1xuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXG4gICAgLy8gY29udmVuaWVuY2UpIGZvciBUSFJFRS5Ta2lubmVkTWVzaCB0byBkbyB0aGlzLlxuXG4gICAgdmFyIGJvbmVzID0gW107XG5cbiAgICBpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBib25lLCBnYm9uZTtcblxuICAgICAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKytiICkge1xuXG4gICAgICAgICAgICBnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblxuICAgICAgICAgICAgYm9uZSA9IG5ldyBUSFJFRS5Cb25lKCB0aGlzICk7XG4gICAgICAgICAgICBib25lcy5wdXNoKCBib25lICk7XG5cbiAgICAgICAgICAgIGJvbmUubmFtZSA9IGdib25lLm5hbWU7XG4gICAgICAgICAgICBib25lLnBvc2l0aW9uLmZyb21BcnJheSggZ2JvbmUucG9zICk7XG4gICAgICAgICAgICBib25lLnF1YXRlcm5pb24uZnJvbUFycmF5KCBnYm9uZS5yb3RxICk7XG4gICAgICAgICAgICBpZiAoIGdib25lLnNjbCAhPT0gdW5kZWZpbmVkICkgYm9uZS5zY2FsZS5mcm9tQXJyYXkoIGdib25lLnNjbCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKytiICkge1xuXG4gICAgICAgICAgICBnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblxuICAgICAgICAgICAgaWYgKCBnYm9uZS5wYXJlbnQgIT09IC0xICkge1xuXG4gICAgICAgICAgICAgICAgYm9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGIgXSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKCBib25lc1sgYiBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cbiAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG4gICAgdGhpcy5iaW5kKCBuZXcgVEhSRUUuU2tlbGV0b24oIGJvbmVzLCB1bmRlZmluZWQsIHVzZVZlcnRleFRleHR1cmUgKSwgdGhpcy5tYXRyaXhXb3JsZCApO1xuXG59O1xuXG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ta2lubmVkTWVzaDtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XG5cbiAgICB0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XG5cbiAgICBpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgICAgdGhpcy5za2VsZXRvbi5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG4gICAgICAgIGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG4gICAgfVxuXG4gICAgdGhpcy5iaW5kTWF0cml4LmNvcHkoIGJpbmRNYXRyaXggKTtcbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuc2tlbGV0b24ucG9zZSgpO1xuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUubm9ybWFsaXplU2tpbldlaWdodHMgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmICggdGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcblxuICAgICAgICAgICAgdmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XG5cbiAgICAgICAgICAgIGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG4gICAgICAgICAgICAgICAgc3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3cuc2V0KCAxICk7IC8vIHRoaXMgd2lsbCBiZSBub3JtYWxpemVkIGJ5IHRoZSBzaGFkZXIgYW55d2F5XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgLy8gc2tpbm5pbmcgd2VpZ2h0cyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgZm9yIFRIUkVFLkJ1ZmZlckdlb21ldHJ5XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uKCBmb3JjZSApIHtcblxuICAgIFRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcblxuICAgIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJhdHRhY2hlZFwiICkge1xuXG4gICAgICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImRldGFjaGVkXCIgKSB7XG5cbiAgICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJpbmRNYXRyaXggKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaCB1bnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTW9ycGhBbmltTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgdGhpcy50eXBlID0gJ01vcnBoQW5pbU1lc2gnO1xuXG4gICAgLy8gQVBJXG5cbiAgICB0aGlzLmR1cmF0aW9uID0gMTAwMDsgLy8gbWlsbGlzZWNvbmRzXG4gICAgdGhpcy5taXJyb3JlZExvb3AgPSBmYWxzZTtcbiAgICB0aGlzLnRpbWUgPSAwO1xuXG4gICAgLy8gaW50ZXJuYWxzXG5cbiAgICB0aGlzLmxhc3RLZXlmcmFtZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50S2V5ZnJhbWUgPSAwO1xuXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAxO1xuICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEZyYW1lUmFuZ2UoIDAsIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggLSAxICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhBbmltTWVzaDtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RnJhbWVSYW5nZSA9IGZ1bmN0aW9uKCBzdGFydCwgZW5kICkge1xuXG4gICAgdGhpcy5zdGFydEtleWZyYW1lID0gc3RhcnQ7XG4gICAgdGhpcy5lbmRLZXlmcmFtZSA9IGVuZDtcblxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5lbmRLZXlmcmFtZSAtIHRoaXMuc3RhcnRLZXlmcmFtZSArIDE7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuZGlyZWN0aW9uID0gMTtcbiAgICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXREaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAtMTtcbiAgICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnBhcnNlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICAgIGlmICggIWdlb21ldHJ5LmFuaW1hdGlvbnMgKSBnZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cbiAgICB2YXIgZmlyc3RBbmltYXRpb24sIGFuaW1hdGlvbnMgPSBnZW9tZXRyeS5hbmltYXRpb25zO1xuXG4gICAgdmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS87XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG4gICAgICAgIHZhciBwYXJ0cyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuICAgICAgICBpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHBhcnRzWyAxIF07XG5cbiAgICAgICAgICAgIGlmICggIWFuaW1hdGlvbnNbIGxhYmVsIF0gKSBhbmltYXRpb25zWyBsYWJlbCBdID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBlbmQ6IC1JbmZpbml0eVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbIGxhYmVsIF07XG5cbiAgICAgICAgICAgIGlmICggaSA8IGFuaW1hdGlvbi5zdGFydCApIGFuaW1hdGlvbi5zdGFydCA9IGk7XG4gICAgICAgICAgICBpZiAoIGkgPiBhbmltYXRpb24uZW5kICkgYW5pbWF0aW9uLmVuZCA9IGk7XG5cbiAgICAgICAgICAgIGlmICggIWZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBsYWJlbDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZW9tZXRyeS5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25MYWJlbCA9IGZ1bmN0aW9uKCBsYWJlbCwgc3RhcnQsIGVuZCApIHtcblxuICAgIGlmICggIXRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyApIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xuXG4gICAgdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgfTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBsYWJlbCwgZnBzICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIHRoaXMuc2V0RnJhbWVSYW5nZSggYW5pbWF0aW9uLnN0YXJ0LCBhbmltYXRpb24uZW5kICk7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwICogKCAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGZwcyApO1xuICAgICAgICB0aGlzLnRpbWUgPSAwO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1vcnBoQW5pbU1lc2g6IGFuaW1hdGlvblsnICsgbGFiZWwgKyAnXSB1bmRlZmluZWQgaW4gLnBsYXlBbmltYXRpb24oKScgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24oIGRlbHRhICkge1xuXG4gICAgdmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmxlbmd0aDtcblxuICAgIHRoaXMudGltZSArPSB0aGlzLmRpcmVjdGlvbiAqIGRlbHRhO1xuXG4gICAgaWYgKCB0aGlzLm1pcnJvcmVkTG9vcCApIHtcblxuICAgICAgICBpZiAoIHRoaXMudGltZSA+IHRoaXMuZHVyYXRpb24gfHwgdGhpcy50aW1lIDwgMCApIHtcblxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gKj0gLTE7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpcy50aW1lIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICB0aGlzLnRpbWUgPSB0aGlzLnRpbWUgJSB0aGlzLmR1cmF0aW9uO1xuXG4gICAgICAgIGlmICggdGhpcy50aW1lIDwgMCApIHRoaXMudGltZSArPSB0aGlzLmR1cmF0aW9uO1xuXG4gICAgfVxuXG4gICAgdmFyIGtleWZyYW1lID0gdGhpcy5zdGFydEtleWZyYW1lICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggdGhpcy50aW1lIC8gZnJhbWVUaW1lICksIDAsIHRoaXMubGVuZ3RoIC0gMSApO1xuXG4gICAgdmFyIGluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgIGlmICgga2V5ZnJhbWUgIT09IHRoaXMuY3VycmVudEtleWZyYW1lICkge1xuXG4gICAgICAgIGluZmx1ZW5jZXNbIHRoaXMubGFzdEtleWZyYW1lIF0gPSAwO1xuICAgICAgICBpbmZsdWVuY2VzWyB0aGlzLmN1cnJlbnRLZXlmcmFtZSBdID0gMTtcbiAgICAgICAgaW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cbiAgICAgICAgdGhpcy5sYXN0S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcbiAgICAgICAgdGhpcy5jdXJyZW50S2V5ZnJhbWUgPSBrZXlmcmFtZTtcblxuICAgIH1cblxuICAgIHZhciBtaXggPSAoIHRoaXMudGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG4gICAgaWYgKCB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyApIHtcblxuICAgICAgICBtaXggPSAxIC0gbWl4O1xuXG4gICAgfVxuXG4gICAgaW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IG1peDtcbiAgICBpbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMSAtIG1peDtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuaW50ZXJwb2xhdGVUYXJnZXRzID0gZnVuY3Rpb24oIGEsIGIsIHQgKSB7XG5cbiAgICB2YXIgaW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgaW5mbHVlbmNlc1sgaSBdID0gMDtcblxuICAgIH1cblxuICAgIGlmICggYSA+IC0xICkgaW5mbHVlbmNlc1sgYSBdID0gMSAtIHQ7XG4gICAgaWYgKCBiID4gLTEgKSBpbmZsdWVuY2VzWyBiIF0gPSB0O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1lc2gucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmR1cmF0aW9uID0gc291cmNlLmR1cmF0aW9uO1xuICAgIHRoaXMubWlycm9yZWRMb29wID0gc291cmNlLm1pcnJvcmVkTG9vcDtcbiAgICB0aGlzLnRpbWUgPSBzb3VyY2UudGltZTtcblxuICAgIHRoaXMubGFzdEtleWZyYW1lID0gc291cmNlLmxhc3RLZXlmcmFtZTtcbiAgICB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IHNvdXJjZS5jdXJyZW50S2V5ZnJhbWU7XG5cbiAgICB0aGlzLmRpcmVjdGlvbiA9IHNvdXJjZS5kaXJlY3Rpb247XG4gICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBzb3VyY2UuZGlyZWN0aW9uQmFja3dhcmRzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTE9ELmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxPRCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0xPRCc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuICAgICAgICBsZXZlbHM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0czoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxPRDogLm9iamVjdHMgaGFzIGJlZW4gcmVuYW1lZCB0byAubGV2ZWxzLicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbHM7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gKTtcblxufTtcblxuXG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5MT0QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTE9EO1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmFkZExldmVsID0gZnVuY3Rpb24oIG9iamVjdCwgZGlzdGFuY2UgKSB7XG5cbiAgICBpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cbiAgICBkaXN0YW5jZSA9IE1hdGguYWJzKCBkaXN0YW5jZSApO1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgZm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCsrICkge1xuXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGwgXS5kaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbGV2ZWxzLnNwbGljZSggbCwgMCwge1xuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfSApO1xuXG4gICAgdGhpcy5hZGQoIG9iamVjdCApO1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlID0gZnVuY3Rpb24oIGRpc3RhbmNlICkge1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgZm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICBpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0O1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICAgICAgbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcblxuICAgICAgICB0aGlzLmdldE9iamVjdEZvckRpc3RhbmNlKCBkaXN0YW5jZSApLnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG4gICAgfTtcblxufSgpICk7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBjYW1lcmEgKSB7XG5cbiAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgICAgIGlmICggbGV2ZWxzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgICAgIHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdjEuZGlzdGFuY2VUbyggdjIgKTtcblxuICAgICAgICAgICAgbGV2ZWxzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA+PSBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCk7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIGZhbHNlICk7XG5cbiAgICB2YXIgbGV2ZWxzID0gc291cmNlLmxldmVscztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cbiAgICAgICAgdGhpcy5hZGRMZXZlbCggbGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcblxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cbiAgICAgICAgZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcbiAgICAgICAgICAgIG9iamVjdDogbGV2ZWwub2JqZWN0LnV1aWQsXG4gICAgICAgICAgICBkaXN0YW5jZTogbGV2ZWwuZGlzdGFuY2VcbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU3ByaXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDIsIDAsIDIsIDMgXSApO1xuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgLTAuNSwgLTAuNSwgMCwgMC41LCAtMC41LCAwLCAwLjUsIDAuNSwgMCwgLTAuNSwgMC41LCAwIF0gKTtcbiAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggWyAwLCAwLCAxLCAwLCAxLCAxLCAwLCAxIF0gKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gU3ByaXRlKCBtYXRlcmlhbCApIHtcblxuICAgICAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICAgICAgdGhpcy50eXBlID0gJ1Nwcml0ZSc7XG5cbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xuXG4gICAgfTtcblxufSApKCk7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGU7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgICAgICBtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2VTcSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VTcVRvUG9pbnQoIG1hdHJpeFBvc2l0aW9uICk7XG4gICAgICAgIHZhciBndWVzc1NpemVTcSA9IHRoaXMuc2NhbGUueCAqIHRoaXMuc2NhbGUueTtcblxuICAgICAgICBpZiAoIGRpc3RhbmNlU3EgPiBndWVzc1NpemVTcSApIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgZGlzdGFuY2U6IE1hdGguc3FydCggZGlzdGFuY2VTcSApLFxuICAgICAgICAgICAgcG9pbnQ6IHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgfSApO1xuXG4gICAgfTtcblxufSgpICk7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG5cbiAgICB9XG5cbiAgICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5USFJFRS5QYXJ0aWNsZSA9IFRIUkVFLlNwcml0ZTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MZW5zRmxhcmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUgPSBmdW5jdGlvbiggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMubGVuc0ZsYXJlcyA9IFtdO1xuXG4gICAgdGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcblxuICAgIGlmICggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRoaXMuYWRkKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MZW5zRmxhcmU7XG5cblxuLypcbiAqIEFkZDogYWRkcyBhbm90aGVyIGZsYXJlXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuICAgIGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0xO1xuICAgIGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcbiAgICBpZiAoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xuICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuICAgIGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cbiAgICBkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcblxuICAgIHRoaXMubGVuc0ZsYXJlcy5wdXNoKCB7XG4gICAgICAgIHRleHR1cmU6IHRleHR1cmUsIC8vIFRIUkVFLlRleHR1cmVcbiAgICAgICAgc2l6ZTogc2l6ZSwgLy8gc2l6ZSBpbiBwaXhlbHMgKC0xID0gdXNlIHRleHR1cmUud2lkdGgpXG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSwgLy8gZGlzdGFuY2UgKDAtMSkgZnJvbSBsaWdodCBzb3VyY2UgKDA9YXQgbGlnaHQgc291cmNlKVxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB6OiAwLCAvLyBzY3JlZW4gcG9zaXRpb24gKC0xID0+IDEpIHogPSAwIGlzIGluIGZyb250IHogPSAxIGlzIGJhY2tcbiAgICAgICAgc2NhbGU6IDEsIC8vIHNjYWxlXG4gICAgICAgIHJvdGF0aW9uOiAwLCAvLyByb3RhdGlvblxuICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LCAvLyBvcGFjaXR5XG4gICAgICAgIGNvbG9yOiBjb2xvciwgLy8gY29sb3JcbiAgICAgICAgYmxlbmRpbmc6IGJsZW5kaW5nIC8vIGJsZW5kaW5nXG4gICAgfSApO1xuXG59O1xuXG4vKlxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXG4gKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxuICovXG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUudXBkYXRlTGVuc0ZsYXJlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcbiAgICB2YXIgZmxhcmU7XG4gICAgdmFyIHZlY1ggPSAtdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcbiAgICB2YXIgdmVjWSA9IC10aGlzLnBvc2l0aW9uU2NyZWVuLnkgKiAyO1xuXG4gICAgZm9yICggZiA9IDA7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgIGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XG5cbiAgICAgICAgZmxhcmUueCA9IHRoaXMucG9zaXRpb25TY3JlZW4ueCArIHZlY1ggKiBmbGFyZS5kaXN0YW5jZTtcbiAgICAgICAgZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcblxuICAgICAgICBmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcbiAgICAgICAgZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xuICAgIHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBzb3VyY2UuY3VzdG9tVXBkYXRlQ2FsbGJhY2s7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuc0ZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdGhpcy5sZW5zRmxhcmVzLnB1c2goIHNvdXJjZS5sZW5zRmxhcmVzWyBpIF0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvU2NlbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNjZW5lID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXG4gICAgdGhpcy5mb2cgPSBudWxsO1xuICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cbiAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXG59O1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNjZW5lO1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xuICAgIGlmICggc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xuXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvc2NlbmVzL0ZvZy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZvZyA9IGZ1bmN0aW9uKCBjb2xvciwgbmVhciwgZmFyICkge1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG4gICAgdGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xuICAgIHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxufTtcblxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Gb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvc2NlbmVzL0ZvZ0V4cDIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2dFeHAyID0gZnVuY3Rpb24oIGNvbG9yLCBkZW5zaXR5ICkge1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuICAgIHRoaXMuZGVuc2l0eSA9ICggZGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBkZW5zaXR5IDogMC4wMDAyNTtcblxufTtcblxuVEhSRUUuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuRm9nRXhwMiggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rLmpzXG5cblRIUkVFLlNoYWRlckNodW5rID0ge307XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcblx0ZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhdGVzdF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGF0ZXN0X2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgQUxQSEFURVNUXFxuXFxuXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFxuXHR0b3RhbEFtYmllbnRMaWdodCAqPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYW9tYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbl92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JlZ2luX3ZlcnRleCcgXSA9IFwiXFxudmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2lubm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYmVnaW5ub3JtYWxfdmVydGV4JyBdID0gXCJcXG52ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9idW1wbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2J1bXBtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFxuXHQvLyBEZXJpdmF0aXZlIG1hcHMgLSBidW1wIG1hcHBpbmcgdW5wYXJhbWV0cml6ZWQgc3VyZmFjZXMgYnkgTW9ydGVuIE1pa2tlbHNlblxcblx0Ly8gaHR0cDovL21taWtrZWxzZW4zZC5ibG9nc3BvdC5zay8yMDExLzA3L2Rlcml2YXRpdmUtbWFwcy5odG1sXFxuXFxuXHQvLyBFdmFsdWF0ZSB0aGUgZGVyaXZhdGl2ZSBvZiB0aGUgaGVpZ2h0IHcuci50LiBzY3JlZW4tc3BhY2UgdXNpbmcgZm9yd2FyZCBkaWZmZXJlbmNpbmcgKGxpc3RpbmcgMilcXG5cXG5cdHZlYzIgZEhkeHlfZndkKCkge1xcblxcblx0XHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuXHRcdHZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcXG5cXG5cdFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcblx0XHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXG5cdFx0ZmxvYXQgZEJ5ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeSApLnggLSBIbGw7XFxuXFxuXHRcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcblx0fVxcblxcblx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG5cXG5cdFx0dmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcXG5cdFx0dmVjMyB2U2lnbWFZID0gZEZkeSggc3VyZl9wb3MgKTtcXG5cdFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcdFx0Ly8gbm9ybWFsaXplZFxcblxcblx0XHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXHRcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXG5cdFx0ZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXG5cXG5cdFx0dmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dkNvbG9yLnh5eiA9IGNvbG9yLnh5ejtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29tbW9uLmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb21tb24nIF0gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OVxcbiNkZWZpbmUgUEkyIDYuMjgzMThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcblxcbiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZGVmaW5lIHdoaXRlQ29tcGxpbWVudChhKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcblxcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIG5vcm1hbCwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICkgKS54eXogKTtcXG5cXG59XFxuXFxuLy8gaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9HTFNMX1Byb2dyYW1taW5nL0FwcGx5aW5nX01hdHJpeF9UcmFuc2Zvcm1hdGlvbnNcXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXG5cdHJldHVybiBub3JtYWxpemUoICggdmVjNCggbm9ybWFsLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcblxcbn1cXG5cXG52ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcblxcblx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcblxcbn1cXG5cXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXHRyZXR1cm4gc2lnbiggZG90KCBwb2ludCAtIHBvaW50T25QbGFuZSwgcGxhbmVOb3JtYWwgKSApO1xcblxcbn1cXG5cXG52ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG5cdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXG5cXG59XFxuXFxuZmxvYXQgY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcblx0aWYgKCBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcblxcblx0ICByZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuXFxuXHR9XFxuXFxuXHRyZXR1cm4gMS4wO1xcblxcbn1cXG5cXG52ZWMzIEZfU2NobGljayggaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBpbiBmbG9hdCBkb3RMSCApIHtcXG5cXG5cdC8vIE9yaWdpbmFsIGFwcHJveGltYXRpb24gYnkgQ2hyaXN0b3BoZSBTY2hsaWNrICc5NFxcblx0Ly87ZmxvYXQgZnJlc25lbCA9IHBvdyggMS4wIC0gZG90TEgsIDUuMCApO1xcblxcblx0Ly8gT3B0aW1pemVkIHZhcmlhbnQgKHByZXNlbnRlZCBieSBFcGljIGF0IFNJR0dSQVBIICcxMylcXG5cdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC01LjU1NDM3ICogZG90TEggLSA2Ljk4MzE2ICkgKiBkb3RMSCApO1xcblxcblx0cmV0dXJuICggMS4wIC0gc3BlY3VsYXJDb2xvciApICogZnJlc25lbCArIHNwZWN1bGFyQ29sb3I7XFxuXFxufVxcblxcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggLyogaW4gZmxvYXQgZG90TkwsIGluIGZsb2F0IGRvdE5WICovICkge1xcblxcblx0Ly8gZ2VvbWV0cnkgdGVybSBpcyAobuKLhWwpKG7ii4V2KSAvIDQobuKLhWwpKG7ii4V2KVxcblxcblx0cmV0dXJuIDAuMjU7XFxuXFxufVxcblxcbmZsb2F0IERfQmxpbm5QaG9uZyggaW4gZmxvYXQgc2hpbmluZXNzLCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXG5cdC8vIGZhY3RvciBvZiAxL1BJIGluIGRpc3RyaWJ1dGlvbiB0ZXJtIG9taXR0ZWRcXG5cXG5cdHJldHVybiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxuXFxufVxcblxcbnZlYzMgQlJERl9CbGlublBob25nKCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgbGlnaHREaXIsIGluIHZlYzMgdmlld0RpciApIHtcXG5cXG5cdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFxuXHQvL2Zsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXHQvL2Zsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggbGlnaHREaXIsIGhhbGZEaXIgKSApO1xcblxcblx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcblxcblx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggLyogZG90TkwsIGRvdE5WICovICk7XFxuXFxuXHRmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxuXFxuXHRyZXR1cm4gRiAqIEcgKiBEO1xcblxcbn1cXG5cXG52ZWMzIGlucHV0VG9MaW5lYXIoIGluIHZlYzMgYSApIHtcXG5cXG5cdCNpZmRlZiBHQU1NQV9JTlBVVFxcblxcblx0XHRyZXR1cm4gcG93KCBhLCB2ZWMzKCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKSApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0cmV0dXJuIGE7XFxuXFxuXHQjZW5kaWZcXG5cXG59XFxuXFxudmVjMyBsaW5lYXJUb091dHB1dCggaW4gdmVjMyBhICkge1xcblxcblx0I2lmZGVmIEdBTU1BX09VVFBVVFxcblxcblx0XHRyZXR1cm4gcG93KCBhLCB2ZWMzKCAxLjAgLyBmbG9hdCggR0FNTUFfRkFDVE9SICkgKSApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0cmV0dXJuIGE7XFxuXFxuXHQjZW5kaWZcXG5cXG59XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCcgXSA9IFwiI2lmZGVmIEZMSVBfU0lERURcXG5cXG5cdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZGlzcGxhY2VtZW50bWFwX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXG5cdHRyYW5zZm9ybWVkICs9IG5vcm1hbCAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Rpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7XFxuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2VtaXNzaXZlbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcblx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdlV2ICk7XFxuXFxuXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGlucHV0VG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IucmdiICk7XFxuXFxuXHR0b3RhbEVtaXNzaXZlTGlnaHQgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2VtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2VtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG5cdFx0Ly8gVHJhbnNmb3JtaW5nIE5vcm1hbCBWZWN0b3JzIHdpdGggdGhlIEludmVyc2UgVHJhbnNmb3JtYXRpb25cXG5cdFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcblx0XHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblx0XHQjZWxzZVxcblxcblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0I2Vsc2VcXG5cXG5cdFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cdFx0ZmxvYXQgZmxpcE5vcm1hbCA9ICggZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKiAyLjAgLSAxLjAgKTtcXG5cdCNlbHNlXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAxLjA7XFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG5cdFx0dmVjMiBzYW1wbGVVVjtcXG5cdFx0c2FtcGxlVVYueSA9IHNhdHVyYXRlKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy55ICogMC41ICsgMC41ICk7XFxuXHRcdHNhbXBsZVVWLnggPSBhdGFuKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy56LCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXG5cdFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41ICk7XFxuXHQjZW5kaWZcXG5cXG5cdGVudkNvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIGVudkNvbG9yLnh5eiApO1xcblxcblx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXG5cXG5cdFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXG5cXG5cdFx0b3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcblx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cdFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuXHQjZWxzZVxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXHQjZW5kaWZcXG5cdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXG5cdHZlYzMgd29ybGROb3JtYWwgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIG9iamVjdE5vcm1hbCwgbW9kZWxNYXRyaXggKTtcXG5cXG5cdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG5cdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1xcblxcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRk9HX0VYUDJcXG5cXG5cdFx0ZmxvYXQgZm9nRmFjdG9yID0gd2hpdGVDb21wbGltZW50KCBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKSApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1xcblxcblx0I2VuZGlmXFxuXHRcXG5cdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHR0b3RhbEFtYmllbnRMaWdodCArPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4JyBdID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF92ZXJ0ZXgnIF0gPSBcInZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gcG9pbnRMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHRQb3NpdGlvblsgaSBdIC0gbXZQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cdFx0Ly8gYXR0ZW51YXRpb25cXG5cXG5cdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdHZMaWdodEJhY2sgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIC0gZG90UHJvZHVjdCApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBzcG90TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0UG9zaXRpb24gPSBzcG90TGlnaHRQb3NpdGlvblsgaSBdO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsaWdodFBvc2l0aW9uIC0gbXZQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cdFx0ZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IHNhdHVyYXRlKCBwb3coIHNhdHVyYXRlKCBzcG90RWZmZWN0ICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSApO1xcblxcblx0XHRcdC8vIGF0dGVudWF0aW9uXFxuXFxuXHRcdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodERpc3RhbmNlWyBpIF0sIHNwb3RMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cdFx0XHRhdHRlbnVhdGlvbiAqPSBzcG90RWZmZWN0O1xcblxcblx0XHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdFx0dkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0XHQjZW5kaWZcXG5cXG5cdFx0fVxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogc2F0dXJhdGUoIC0gZG90UHJvZHVjdCApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0QmFjayA9IC0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHRCYWNrICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbnZMaWdodEZyb250ICs9IGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdHZMaWdodEJhY2sgKz0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX2ZyYWdtZW50JyBdID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblxcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcblx0I2VuZGlmXFxuXFxuI2Vsc2VcXG5cXG5cdHZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApO1xcblx0dmVjMyBmZHkgPSBkRmR5KCB2Vmlld1Bvc2l0aW9uICk7XFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcXG5cXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxuXFxuXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcbnZlYzMgdG90YWxEaWZmdXNlTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHRvdGFsU3BlY3VsYXJMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gcG9pbnRMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHRQb3NpdGlvbiA9IHBvaW50TGlnaHRQb3NpdGlvblsgaSBdO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsaWdodFBvc2l0aW9uICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cdFx0Ly8gYXR0ZW51YXRpb25cXG5cXG5cdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG5cdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cdFx0Ly8gc3BlY3VsYXJcXG5cXG5cdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiArIHZWaWV3UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBsaWdodERpciApO1xcblxcblx0XHRpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcblxcblx0XHRcdHNwb3RFZmZlY3QgPSBzYXR1cmF0ZSggcG93KCBzYXR1cmF0ZSggc3BvdEVmZmVjdCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICkgKTtcXG5cXG5cdFx0XHQvLyBhdHRlbnVhdGlvblxcblxcblx0XHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXHRcdFx0YXR0ZW51YXRpb24gKj0gc3BvdEVmZmVjdDtcXG5cXG5cdFx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXHRcdFx0Ly8gc3BlY3VsYXJcXG5cXG5cdFx0XHR2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG5cdFx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblx0XHR9XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogY29zaW5lVGVybTtcXG5cXG5cdFx0Ly8gc3BlY3VsYXJcXG5cXG5cdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuXHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3I7XFxuXFxuXHRcdC8vIHNwZWN1bGFyIChza3kgdGVybSBvbmx5KVxcblxcblx0XHR2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG5cdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIE1FVEFMXFxuXFxuXHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHRvdGFsRGlmZnVzZUxpZ2h0ICsgdG90YWxBbWJpZW50TGlnaHQgKSAqIHNwZWN1bGFyICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1xcblxcbiNlbHNlXFxuXFxuXHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHRvdGFsRGlmZnVzZUxpZ2h0ICsgdG90YWxBbWJpZW50TGlnaHQgKSArIHRvdGFsU3BlY3VsYXJMaWdodCArIHRvdGFsRW1pc3NpdmVMaWdodDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50JyBdID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfdmVydGV4JyBdID0gXCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpbmVhcl90b19nYW1tYV9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50JyBdID0gXCJcXG5cdG91dGdvaW5nTGlnaHQgPSBsaW5lYXJUb091dHB1dCggb3V0Z29pbmdMaWdodCApO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfZnJhZ21lbnQnIF0gPSBcIiNpZiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRikgJiYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUZfRVhUKVxcblxcblx0Z2xfRnJhZ0RlcHRoRVhUID0gbG9nMih2RnJhZ0RlcHRoKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0Z2xfUG9zaXRpb24ueiA9IGxvZzIobWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkpICogbG9nRGVwdGhCdWZGQztcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcbiNlbHNlXFxuXFxuXHRcdGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcblx0dGV4ZWxDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCB0ZXhlbENvbG9yLnh5eiApO1xcblxcblx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHRkaWZmdXNlQ29sb3IgKj0gdGV4dHVyZTJEKCBtYXAsIHZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICkgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHkgKTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaG5vcm1hbF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaHRhcmdldF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFxuXHQjZWxzZVxcblxcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaHRhcmdldF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDEgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcblx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDYgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ub3JtYWxtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuXHQvLyBQZXItUGl4ZWwgVGFuZ2VudCBTcGFjZSBOb3JtYWwgTWFwcGluZ1xcblx0Ly8gaHR0cDovL2hhY2tzb2ZsaWZlLmJsb2dzcG90LmNoLzIwMDkvMTEvcGVyLXBpeGVsLXRhbmdlbnQtc3BhY2Utbm9ybWFsLW1hcHBpbmcuaHRtbFxcblxcblx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXG5cXG5cdFx0dmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xcblx0XHR2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcblx0XHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcblx0XHR2ZWMzIFMgPSBub3JtYWxpemUoIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxuXHRcdHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxuXHRcdHZlYzMgTiA9IG5vcm1hbGl6ZSggc3VyZl9ub3JtICk7XFxuXFxuXHRcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXHRcdG1hcE4ueHkgPSBub3JtYWxTY2FsZSAqIG1hcE4ueHk7XFxuXHRcdG1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1xcblx0XHRyZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3Byb2plY3RfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdwcm9qZWN0X3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG5cXG4jZWxzZVxcblxcblx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcbiNlbmRpZlxcblxcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0I2lmZGVmIFNIQURPV01BUF9ERUJVR1xcblxcblx0XHR2ZWMzIGZydXN0dW1Db2xvcnNbM107XFxuXHRcdGZydXN0dW1Db2xvcnNbMF0gPSB2ZWMzKCAxLjAsIDAuNSwgMC4wICk7XFxuXHRcdGZydXN0dW1Db2xvcnNbMV0gPSB2ZWMzKCAwLjAsIDEuMCwgMC44ICk7XFxuXHRcdGZydXN0dW1Db2xvcnNbMl0gPSB2ZWMzKCAwLjAsIDAuNSwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdGZsb2F0IGZEZXB0aDtcXG5cdHZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKCAxLjAgKTtcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgc2hhZG93Q29vcmQgPSB2U2hhZG93Q29vcmRbIGkgXS54eXogLyB2U2hhZG93Q29vcmRbIGkgXS53O1xcblxcblx0XHRcdFx0Ly8gaWYgKCBzb21ldGhpbmcgJiYgc29tZXRoaW5nICkgYnJlYWtzIEFUSSBPcGVuR0wgc2hhZGVyIGNvbXBpbGVyXFxuXHRcdFx0XHQvLyBpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApIHVzaW5nIHRoaXMgaW5zdGVhZFxcblxcblx0XHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXHRcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXG5cdFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcblx0XHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcblx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcblx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcblx0XHRcdFx0XHRcdC8vIFBlcmNlbnRhZ2UtY2xvc2UgZmlsdGVyaW5nXFxuXHRcdFx0XHRcdFx0Ly8gKDkgcGl4ZWwga2VybmVsKVxcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cXG5cXG5cdFx0XHRcdGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG5cdFx0LypcXG5cdFx0XHRcdFx0XHQvLyBuZXN0ZWQgbG9vcHMgYnJlYWtzIHNoYWRlciBjb21waWxlciAvIHZhbGlkYXRvciBvbiBzb21lIEFUSSBjYXJkcyB3aGVuIHVzaW5nIE9wZW5HTFxcblx0XHRcdFx0XHRcdC8vIG11c3QgZW5yb2xsIGxvb3AgbWFudWFsbHlcXG5cXG5cdFx0XHRcdGZvciAoIGZsb2F0IHkgPSAtMS4yNTsgeSA8PSAxLjI1OyB5ICs9IDEuMjUgKVxcblx0XHRcdFx0XHRmb3IgKCBmbG9hdCB4ID0gLTEuMjU7IHggPD0gMS4yNTsgeCArPSAxLjI1ICkge1xcblxcblx0XHRcdFx0XHRcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKTtcXG5cXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIHRleHR1cmUyRCBsb29rdXBcXG5cdFx0XHRcdFx0XHRcdFx0Ly92ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRFByb2ooIHNoYWRvd01hcFsgaSBdLCB2ZWM0KCB2U2hhZG93Q29vcmRbIGkgXS53ICogKCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApLCAwLjA1LCB2U2hhZG93Q29vcmRbIGkgXS53ICkgKTtcXG5cXG5cdFx0XHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXHRcdFx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cdFx0XHRcdFx0XHRcdHNoYWRvdyArPSAxLjA7XFxuXFxuXHRcdFx0XHR9XFxuXFxuXHRcdFx0XHRzaGFkb3cgLz0gOS4wO1xcblxcblx0XHQqL1xcblxcblx0XHRcdFx0Y29uc3QgZmxvYXQgc2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XFxuXFxuXHRcdFx0XHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cdFx0XHRcdGZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1xcblxcblx0XHRcdFx0ZmxvYXQgZHgwID0gLTEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR4MSA9IDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcXG5cXG5cdFx0XHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuXHRcdFx0XHRcdFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcXG5cdFx0XHRcdFx0XHQvLyAoOSBwaXhlbCBrZXJuZWwpXFxuXHRcdFx0XHRcdFx0Ly8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xcblxcblx0XHRcdFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcblx0XHRcdFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuXHRcdFx0XHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cdFx0XHRcdGZsb2F0IGR4MCA9IC0xLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtMS4wICogeVBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0bWF0MyBzaGFkb3dLZXJuZWw7XFxuXHRcdFx0XHRtYXQzIGRlcHRoS2VybmVsO1xcblxcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMF1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzBdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFswXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMV1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzFdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzFdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsyXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMl1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzJdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFxuXHRcdFx0XHR2ZWMzIHNoYWRvd1ogPSB2ZWMzKCBzaGFkb3dDb29yZC56ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMF0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzBdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzBdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMV0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzFdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzFdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMl0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzJdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzJdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHR2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbaV0ueHkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFswXSA9IG1peCggc2hhZG93S2VybmVsWzFdLCBzaGFkb3dLZXJuZWxbMF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMV0gPSBtaXgoIHNoYWRvd0tlcm5lbFsyXSwgc2hhZG93S2VybmVsWzFdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcblxcblx0XHRcdFx0dmVjNCBzaGFkb3dWYWx1ZXM7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueSA9IG1peCggc2hhZG93S2VybmVsWzBdWzJdLCBzaGFkb3dLZXJuZWxbMF1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWzFdWzFdLCBzaGFkb3dLZXJuZWxbMV1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3cgPSBkb3QoIHNoYWRvd1ZhbHVlcywgdmVjNCggMS4wICkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1xcblxcblx0XHRcdCNlbHNlXFxuXFxuXHRcdFx0XHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblxcblx0XHQvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBpcyBkYXJrZXJcXG5cXG5cdFx0XHRcdFx0c2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG5cdFx0Ly8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaGFzIHRoZSBzYW1lIGNvbG9yIGFzIHNpbmdsZSBzaGFkb3cgc3BvdFxcblxcblx0XHQvLyBcdFx0XHRcdFx0c2hhZG93Q29sb3IgPSBtaW4oIHNoYWRvd0NvbG9yLCB2ZWMzKCBzaGFkb3dEYXJrbmVzc1sgaSBdICkgKTtcXG5cXG5cdFx0XHQjZW5kaWZcXG5cXG5cdFx0fVxcblxcblxcblx0XHQjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXHRcdFx0aWYgKCBpbkZydXN0dW0gKSBvdXRnb2luZ0xpZ2h0ICo9IGZydXN0dW1Db2xvcnNbIGkgXTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuXHRvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqIHNoYWRvd0NvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dNYXBbIE1BWF9TSEFET1dTIF07XFxuXHR1bmlmb3JtIHZlYzIgc2hhZG93TWFwU2l6ZVsgTUFYX1NIQURPV1MgXTtcXG5cXG5cdHVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3NbIE1BWF9TSEFET1dTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0JpYXNbIE1BWF9TSEFET1dTIF07XFxuXFxuXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0ZmxvYXQgdW5wYWNrRGVwdGgoIGNvbnN0IGluIHZlYzQgcmdiYV9kZXB0aCApIHtcXG5cXG5cdFx0Y29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcblx0XHRmbG9hdCBkZXB0aCA9IGRvdCggcmdiYV9kZXB0aCwgYml0X3NoaWZ0ICk7XFxuXHRcdHJldHVybiBkZXB0aDtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuXHRcdHZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcblx0fVxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2luYmFzZV92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5iYXNlX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ19wYXJzX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7XFxuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFxuXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblx0XHR1bmlmb3JtIGludCBib25lVGV4dHVyZVdpZHRoO1xcblx0XHR1bmlmb3JtIGludCBib25lVGV4dHVyZUhlaWdodDtcXG5cXG5cdFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcblx0XHRcdGZsb2F0IGogPSBpICogNC4wO1xcblx0XHRcdGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cdFx0XHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXFxuXHRcdFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApO1xcblx0XHRcdGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlSGVpZ2h0ICk7XFxuXFxuXHRcdFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFxuXHRcdFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcblx0XHRcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFxuXHRcdFx0cmV0dXJuIGJvbmU7XFxuXFxuXHRcdH1cXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcblxcblx0XHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXHRcdFx0bWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cdFx0XHRyZXR1cm4gYm9uZTtcXG5cXG5cdFx0fVxcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcblx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cdHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5vcm1hbF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXG5cdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfZnJhZ21lbnQnIF0gPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcblxcbiNlbHNlXFxuXFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHRhdHRyaWJ1dGUgdmVjMiB1djI7XFxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHR2VXYyID0gdXYyO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXY7XFxuXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcblx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3dvcmxkcG9zX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnd29ybGRwb3NfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQIClcXG5cXG5cdCNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qc1xuXG4vKipcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXG4gKi9cblxuVEhSRUUuVW5pZm9ybXNVdGlscyA9IHtcblxuICAgIG1lcmdlOiBmdW5jdGlvbiggdW5pZm9ybXMgKSB7XG5cbiAgICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuXG4gICAgICAgIGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XG5cbiAgICAgICAgICAgICAgICBtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCB1bmlmb3Jtc19zcmMgKSB7XG5cbiAgICAgICAgdmFyIHVuaWZvcm1zX2RzdCA9IHt9O1xuXG4gICAgICAgIGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcblxuICAgICAgICAgICAgZm9yICggdmFyIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4MyB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5pZm9ybXNfZHN0O1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc0xpYi5qc1xuXG4vKipcbiAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXG4gKi9cblxuVEhSRUUuVW5pZm9ybXNMaWIgPSB7XG5cbiAgICBjb21tb246IHtcblxuICAgICAgICBcImRpZmZ1c2VcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApXG4gICAgICAgIH0sXG4gICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcblxuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwib2Zmc2V0UmVwZWF0XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidjRcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJzcGVjdWxhck1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWxwaGFNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIFwiZW52TWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJmbGlwRW52TWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IC0xXG4gICAgICAgIH0sXG4gICAgICAgIFwicmVmbGVjdGl2aXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICB9LFxuICAgICAgICBcInJlZnJhY3Rpb25SYXRpb1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLjk4XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBhb21hcDoge1xuXG4gICAgICAgIFwiYW9NYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcImFvTWFwSW50ZW5zaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgfSxcblxuICAgIH0sXG5cbiAgICBsaWdodG1hcDoge1xuXG4gICAgICAgIFwibGlnaHRNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcImxpZ2h0TWFwSW50ZW5zaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgfSxcblxuICAgIH0sXG5cbiAgICBlbWlzc2l2ZW1hcDoge1xuXG4gICAgICAgIFwiZW1pc3NpdmVNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuXG4gICAgfSxcblxuICAgIGJ1bXBtYXA6IHtcblxuICAgICAgICBcImJ1bXBNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcImJ1bXBTY2FsZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBub3JtYWxtYXA6IHtcblxuICAgICAgICBcIm5vcm1hbE1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9ybWFsU2NhbGVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ2MlwiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxIClcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRpc3BsYWNlbWVudG1hcDoge1xuXG4gICAgICAgIFwiZGlzcGxhY2VtZW50TWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJkaXNwbGFjZW1lbnRTY2FsZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlzcGxhY2VtZW50Qmlhc1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBmb2c6IHtcblxuICAgICAgICBcImZvZ0RlbnNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMC4wMDAyNVxuICAgICAgICB9LFxuICAgICAgICBcImZvZ05lYXJcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICB9LFxuICAgICAgICBcImZvZ0ZhclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAyMDAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9nQ29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBsaWdodHM6IHtcblxuICAgICAgICBcImFtYmllbnRMaWdodENvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0Q29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJwb2ludExpZ2h0Q29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pbnRMaWdodFBvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50TGlnaHREaXN0YW5jZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pbnRMaWdodERlY2F5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcblxuICAgICAgICBcInNwb3RMaWdodENvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodFBvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodERpcmVjdGlvblwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHREaXN0YW5jZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0QW5nbGVDb3NcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodEV4cG9uZW50XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHREZWNheVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwb2ludHM6IHtcblxuICAgICAgICBcInBzQ29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApXG4gICAgICAgIH0sXG4gICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaXplXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICB9LFxuICAgICAgICBcInNjYWxlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICB9LFxuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwib2Zmc2V0UmVwZWF0XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidjRcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJmb2dEZW5zaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDAuMDAwMjVcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dOZWFyXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dGYXJcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMjAwMFxuICAgICAgICB9LFxuICAgICAgICBcImZvZ0NvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc2hhZG93bWFwOiB7XG5cbiAgICAgICAgXCJzaGFkb3dNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0dlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhZG93TWFwU2l6ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInYydlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJzaGFkb3dCaWFzXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGFkb3dEYXJrbmVzc1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJzaGFkb3dNYXRyaXhcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJtNHZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi5qc1xuXG4vKipcbiAqIFdlYmdsIFNoYWRlciBMaWJyYXJ5IGZvciB0aHJlZS5qc1xuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5cblRIUkVFLlNoYWRlckxpYiA9IHtcblxuICAgICdiYXNpYyc6IHtcblxuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuICAgICAgICBdICksXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJcdCNpZmRlZiBVU0VfRU5WTUFQXCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcbiAgICAgICAgICAgIFwiXHR2ZWMzIHRvdGFsQW1iaWVudExpZ2h0ID0gdmVjMyggMS4wICk7XCIsIC8vIGhhcmR3aXJlZFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogdG90YWxBbWJpZW50TGlnaHQ7XCIsIC8vIHNpbXBsZSBzaGFkZXJcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sIC8vIFRPRE86IFNoYWRvd3Mgb24gYW4gb3RoZXJ3aXNlIHVubGl0IHN1cmZhY2UgZG9lc24ndCBtYWtlIHNlbnNlLlxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgICdsYW1iZXJ0Jzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImVtaXNzaXZlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgXSApLFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcIiNkZWZpbmUgTEFNQkVSVFwiLFxuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcblxuICAgICAgICAgICAgXCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cbiAgICAgICAgICAgIFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcblxuICAgICAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcblxuICAgICAgICAgICAgXCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cbiAgICAgICAgICAgIFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcblxuICAgICAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsIC8vIG91dGdvaW5nIGxpZ2h0IGRvZXMgbm90IGhhdmUgYW4gYWxwaGEsIHRoZSBzdXJmYWNlIGRvZXNcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHQjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cbiAgICAgICAgICAgIFwiXHRcdGlmICggZ2xfRnJvbnRGYWNpbmcgKVwiLFxuICAgICAgICAgICAgXCJcdFx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiB2TGlnaHRGcm9udCArIGVtaXNzaXZlO1wiLFxuICAgICAgICAgICAgXCJcdFx0ZWxzZVwiLFxuICAgICAgICAgICAgXCJcdFx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiB2TGlnaHRCYWNrICsgZW1pc3NpdmU7XCIsXG5cbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxuXG4gICAgICAgICAgICBcIlx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiB2TGlnaHRGcm9udCArIGVtaXNzaXZlO1wiLFxuXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgICdwaG9uZyc6IHtcblxuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZW1pc3NpdmVtYXBcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYnVtcG1hcFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZGlzcGxhY2VtZW50bWFwXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiZW1pc3NpdmVcIjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzcGVjdWxhclwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNoaW5pbmVzc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMzBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgXSApLFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcIiNkZWZpbmUgUEhPTkdcIixcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgXCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsXG5cbiAgICAgICAgICAgIFwiXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuICAgICAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIiNpZm5kZWYgRkxBVF9TSEFERURcIiwgLy8gTm9ybWFsIGNvbXB1dGVkIHdpdGggZGVyaXZhdGl2ZXMgd2hlbiBGTEFUX1NIQURFRFxuXG4gICAgICAgICAgICBcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcblxuICAgICAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRpc3BsYWNlbWVudG1hcF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIlx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCIjZGVmaW5lIFBIT05HXCIsXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnVtcG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG4gICAgICAgICAgICBcIlx0dmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IGFtYmllbnRMaWdodENvbG9yO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzMgdG90YWxFbWlzc2l2ZUxpZ2h0ID0gZW1pc3NpdmU7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAncG9pbnRzJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInBvaW50c1wiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXG5cbiAgICAgICAgXSApLFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcbiAgICAgICAgICAgIFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XCIsXG4gICAgICAgICAgICBcIlx0I2Vsc2VcIixcbiAgICAgICAgICAgIFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemU7XCIsXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHBzQ29sb3I7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBwc0NvbG9yLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XCIsIC8vIHNpbXBsZSBzaGFkZXJcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgJ2Rhc2hlZCc6IHtcblxuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwic2NhbGVcIjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGFzaFNpemVcIjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidG90YWxTaXplXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIF0gKSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuICAgICAgICAgICAgXCJhdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1wiLFxuXG4gICAgICAgICAgICBcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XCIsXG5cbiAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcIixcblxuICAgICAgICAgICAgXCJcdFx0ZGlzY2FyZDtcIixcblxuICAgICAgICAgICAgXCJcdH1cIixcblxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcIiwgLy8gc2ltcGxlIHNoYWRlclxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgICdkZXB0aCc6IHtcblxuICAgICAgICB1bmlmb3Jtczoge1xuXG4gICAgICAgICAgICBcIm1OZWFyXCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtRmFyXCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogMjAwMC4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgbU5lYXI7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgbUZhcjtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFwiLFxuXG4gICAgICAgICAgICBcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1wiLFxuXG4gICAgICAgICAgICBcIlx0I2Vsc2VcIixcblxuICAgICAgICAgICAgXCJcdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1wiLFxuXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFwiXHRmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcIixcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgICdub3JtYWwnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IHtcblxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuNSAqIG5vcm1hbGl6ZSggdk5vcm1hbCApICsgMC41LCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgJ2N1YmUnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIFwidEN1YmVcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0RmxpcFwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcblxuICAgICAgICAgICAgXCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG5cdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAnZXF1aXJlY3QnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIFwidEVxdWlyZWN0XCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidEZsaXBcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAtMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XCIsXG5cbiAgICAgICAgICAgIFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAvLyBcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcbiAgICAgICAgICAgIFwidmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XCIsXG4gICAgICAgICAgICBcInZlYzIgc2FtcGxlVVY7XCIsXG4gICAgICAgICAgICBcInNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcIixcbiAgICAgICAgICAgIFwic2FtcGxlVVYueCA9IGF0YW4oIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XCIsXG4gICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAvKiBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxuICAgICAqXG4gICAgICogYmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXG4gICAgICogaHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XG4gICAgICpcbiAgICAgKiBvcmlnaW5hbGx5IGZyb21cbiAgICAgKiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxuICAgICAqXG4gICAgICogc2VlIGFsc29cbiAgICAgKiBodHRwOi8vYXJhcy1wLmluZm8vYmxvZy8yMDA5LzA3LzMwL2VuY29kaW5nLWZsb2F0cy10by1yZ2JhLXRoZS1maW5hbC9cbiAgICAgKi9cblxuICAgICdkZXB0aFJHQkEnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IHt9LFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidmVjNCBwYWNrX2RlcHRoKCBjb25zdCBpbiBmbG9hdCBkZXB0aCApIHtcIixcblxuICAgICAgICAgICAgXCJcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXG4gICAgICAgICAgICBcIlx0Y29uc3QgdmVjNCBiaXRfbWFzayA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzQgcmVzID0gbW9kKCBkZXB0aCAqIGJpdF9zaGlmdCAqIHZlYzQoIDI1NSApLCB2ZWM0KCAyNTYgKSApIC8gdmVjNCggMjU1ICk7XCIsIC8vIFwiXHR2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdF9zaGlmdCApO1wiLFxuICAgICAgICAgICAgXCJcdHJlcyAtPSByZXMueHh5eiAqIGJpdF9tYXNrO1wiLFxuICAgICAgICAgICAgXCJcdHJldHVybiByZXM7XCIsXG5cbiAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcblxuICAgICAgICAgICAgXCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdEZXB0aEVYVCApO1wiLFxuXG4gICAgICAgICAgICBcIlx0I2Vsc2VcIixcblxuICAgICAgICAgICAgXCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXG5cbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcblxuICAgICAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICk7XCIsXG4gICAgICAgICAgICAvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXG4gICAgICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIHogKTtcIixcbiAgICAgICAgICAgIC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gdmVjNCggeiwgeiwgeiwgMS4wICk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgVEhSRUUuUkVWSVNJT04gKTtcblxuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgdmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxuICAgICAgICBfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcblxuICAgICAgICBfd2lkdGggPSBfY2FudmFzLndpZHRoLFxuICAgICAgICBfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXG5cbiAgICAgICAgcGl4ZWxSYXRpbyA9IDEsXG5cbiAgICAgICAgX2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IGZhbHNlLFxuICAgICAgICBfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcbiAgICAgICAgX3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG4gICAgICAgIF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcbiAgICAgICAgX3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXG4gICAgICAgIF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcblxuICAgICAgICBfY2xlYXJDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSxcbiAgICAgICAgX2NsZWFyQWxwaGEgPSAwO1xuXG4gICAgdmFyIGxpZ2h0cyA9IFtdO1xuXG4gICAgdmFyIG9wYXF1ZU9iamVjdHMgPSBbXTtcbiAgICB2YXIgb3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuICAgIHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcbiAgICB2YXIgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLTE7XG5cbiAgICB2YXIgb3BhcXVlSW1tZWRpYXRlT2JqZWN0cyA9IFtdO1xuICAgIHZhciBvcGFxdWVJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4ID0gLTE7XG4gICAgdmFyIHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0cyA9IFtdO1xuICAgIHZhciB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXggPSAtMTtcblxuICAgIHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XG5cblxuICAgIHZhciBzcHJpdGVzID0gW107XG4gICAgdmFyIGxlbnNGbGFyZXMgPSBbXTtcblxuICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgICAvLyBjbGVhcmluZ1xuXG4gICAgdGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgIHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuICAgIHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xuICAgIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cbiAgICAvLyBzY2VuZSBncmFwaFxuXG4gICAgdGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XG5cbiAgICAvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuICAgIHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7IC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtbWFPdXRwdXQgPSBmYWxzZTtcblxuICAgIC8vIG1vcnBoc1xuXG4gICAgdGhpcy5tYXhNb3JwaFRhcmdldHMgPSA4O1xuICAgIHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcblxuICAgIC8vIGZsYWdzXG5cbiAgICB0aGlzLmF1dG9TY2FsZUN1YmVtYXBzID0gdHJ1ZTtcblxuICAgIC8vIGludGVybmFsIHByb3BlcnRpZXNcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcblxuICAgICAgICBfY3VycmVudFByb2dyYW0gPSBudWxsLFxuICAgICAgICBfY3VycmVudEZyYW1lYnVmZmVyID0gbnVsbCxcbiAgICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLTEsXG4gICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJycsXG4gICAgICAgIF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcblxuICAgICAgICBfdXNlZFRleHR1cmVVbml0cyA9IDAsXG5cbiAgICAgICAgX3ZpZXdwb3J0WCA9IDAsXG4gICAgICAgIF92aWV3cG9ydFkgPSAwLFxuICAgICAgICBfdmlld3BvcnRXaWR0aCA9IF9jYW52YXMud2lkdGgsXG4gICAgICAgIF92aWV3cG9ydEhlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuICAgICAgICBfY3VycmVudFdpZHRoID0gMCxcbiAgICAgICAgX2N1cnJlbnRIZWlnaHQgPSAwLFxuXG4gICAgICAgIC8vIGZydXN0dW1cblxuICAgICAgICBfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXG5cbiAgICAgICAgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cbiAgICAgICAgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG4gICAgICAgIF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgICAgICAvLyBsaWdodCBhcnJheXMgY2FjaGVcblxuICAgICAgICBfZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgICAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWUsXG5cbiAgICAgICAgX2xpZ2h0cyA9IHtcblxuICAgICAgICAgICAgYW1iaWVudDogWyAwLCAwLCAwIF0sXG4gICAgICAgICAgICBkaXJlY3Rpb25hbDoge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogW10sXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICBkZWNheXM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3BvdDoge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogW10sXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zOiBbXSxcbiAgICAgICAgICAgICAgICBhbmdsZXNDb3M6IFtdLFxuICAgICAgICAgICAgICAgIGV4cG9uZW50czogW10sXG4gICAgICAgICAgICAgICAgZGVjYXlzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbWk6IHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgc2t5Q29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBncm91bmRDb2xvcnM6IFtdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogW11cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm9cblxuICAgICAgICBfaW5mb01lbW9yeSA9IHtcblxuICAgICAgICAgICAgZ2VvbWV0cmllczogMCxcbiAgICAgICAgICAgIHRleHR1cmVzOiAwXG5cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5mb1JlbmRlciA9IHtcblxuICAgICAgICAgICAgY2FsbHM6IDAsXG4gICAgICAgICAgICB2ZXJ0aWNlczogMCxcbiAgICAgICAgICAgIGZhY2VzOiAwLFxuICAgICAgICAgICAgcG9pbnRzOiAwXG5cbiAgICAgICAgfTtcblxuICAgIHRoaXMuaW5mbyA9IHtcblxuICAgICAgICByZW5kZXI6IF9pbmZvUmVuZGVyLFxuICAgICAgICBtZW1vcnk6IF9pbmZvTWVtb3J5LFxuICAgICAgICBwcm9ncmFtczogbnVsbFxuXG4gICAgfTtcblxuXG4gICAgLy8gaW5pdGlhbGl6ZVxuXG4gICAgdmFyIF9nbDtcblxuICAgIHRyeSB7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBhbHBoYTogX2FscGhhLFxuICAgICAgICAgICAgZGVwdGg6IF9kZXB0aCxcbiAgICAgICAgICAgIHN0ZW5jaWw6IF9zdGVuY2lsLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBfYW50aWFsaWFzLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgX2dsID0gX2NvbnRleHQgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnLCBhdHRyaWJ1dGVzICkgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyApO1xuXG4gICAgICAgIGlmICggX2dsID09PSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJztcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG4gICAgfVxuICAgIGNhdGNoICggZXJyb3IgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvciApO1xuXG4gICAgfVxuXG4gICAgdmFyIGV4dGVuc2lvbnMgPSBuZXcgVEhSRUUuV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcblxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICk7XG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG4gICAgZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgaWYgKCBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICAgICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xuXG4gICAgfVxuXG4gICAgdmFyIGNhcGFiaWxpdGllcyA9IG5ldyBUSFJFRS5XZWJHTENhcGFiaWxpdGllcyggX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICk7XG5cbiAgICB2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gbmV3IFRIUkVFLldlYkdMUHJvcGVydGllcygpO1xuICAgIHZhciBvYmplY3RzID0gbmV3IFRIUkVFLldlYkdMT2JqZWN0cyggX2dsLCBwcm9wZXJ0aWVzLCB0aGlzLmluZm8gKTtcbiAgICB2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xuXG4gICAgdGhpcy5pbmZvLnByb2dyYW1zID0gcHJvZ3JhbUNhY2hlLnByb2dyYW1zO1xuXG4gICAgdmFyIGJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcbiAgICB2YXIgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XG5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gZ2xDbGVhckNvbG9yKCByLCBnLCBiLCBhICkge1xuXG4gICAgICAgIGlmICggX3ByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgciAqPSBhO1xuICAgICAgICAgICAgZyAqPSBhO1xuICAgICAgICAgICAgYiAqPSBhO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfZ2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGVmYXVsdEdMU3RhdGUoKSB7XG5cbiAgICAgICAgc3RhdGUuaW5pdCgpO1xuXG4gICAgICAgIF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xuXG4gICAgICAgIGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0R0xTdGF0ZSgpIHtcblxuICAgICAgICBfY3VycmVudFByb2dyYW0gPSBudWxsO1xuICAgICAgICBfY3VycmVudENhbWVyYSA9IG51bGw7XG5cbiAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcbiAgICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XG5cbiAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHN0YXRlLnJlc2V0KCk7XG5cbiAgICB9XG5cbiAgICBzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gX2dsO1xuICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgLy8gc2hhZG93IG1hcFxuXG4gICAgdmFyIHNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFNoYWRvd01hcCggdGhpcywgbGlnaHRzLCBvYmplY3RzICk7XG5cbiAgICB0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcblxuXG4gICAgLy8gUGx1Z2luc1xuXG4gICAgdmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcbiAgICB2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IFRIUkVFLkxlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xuXG4gICAgLy8gQVBJXG5cbiAgICB0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gX2dsO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gX2dsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5mb3JjZUNvbnRleHRMb3NzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldE1heEFuaXNvdHJvcHkgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0TWF4QW5pc290cm9weSgpIHtcblxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cbiAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgICB9XG5cbiAgICB9ICkoKTtcblxuICAgIHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIGNhcGFiaWxpdGllcy5wcmVjaXNpb247XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHBpeGVsUmF0aW87XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHBpeGVsUmF0aW8gPSB2YWx1ZTtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldFNpemUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgICB9O1xuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcblxuICAgICAgICBfd2lkdGggPSB3aWR0aDtcbiAgICAgICAgX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICBfY2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICBfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cbiAgICAgICAgaWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24oIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICAgICAgX3ZpZXdwb3J0WCA9IHggKiBwaXhlbFJhdGlvO1xuICAgICAgICBfdmlld3BvcnRZID0geSAqIHBpeGVsUmF0aW87XG5cbiAgICAgICAgX3ZpZXdwb3J0V2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICAgIF92aWV3cG9ydEhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cbiAgICAgICAgX2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24oIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICAgICAgX2dsLnNjaXNzb3IoXG4gICAgICAgICAgICB4ICogcGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIHkgKiBwaXhlbFJhdGlvLFxuICAgICAgICAgICAgd2lkdGggKiBwaXhlbFJhdGlvLFxuICAgICAgICAgICAgaGVpZ2h0ICogcGl4ZWxSYXRpb1xuICAgICAgICApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiggYm9vbGVhbiApIHtcblxuICAgICAgICBzdGF0ZS5zZXRTY2lzc29yVGVzdCggYm9vbGVhbiApO1xuXG4gICAgfTtcblxuICAgIC8vIENsZWFyaW5nXG5cbiAgICB0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gX2NsZWFyQ29sb3I7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24oIGNvbG9yLCBhbHBoYSApIHtcblxuICAgICAgICBfY2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XG5cbiAgICAgICAgX2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xuXG4gICAgICAgIGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gX2NsZWFyQWxwaGE7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24oIGFscGhhICkge1xuXG4gICAgICAgIF9jbGVhckFscGhhID0gYWxwaGE7XG5cbiAgICAgICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG4gICAgICAgIHZhciBiaXRzID0gMDtcblxuICAgICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuICAgICAgICBpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xuICAgICAgICBpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG4gICAgICAgIF9nbC5jbGVhciggYml0cyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF9nbC5jbGVhciggX2dsLkNPTE9SX0JVRkZFUl9CSVQgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBfZ2wuY2xlYXIoIF9nbC5ERVBUSF9CVUZGRVJfQklUICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBfZ2wuY2xlYXIoIF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24oIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG4gICAgICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcbiAgICAgICAgdGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cbiAgICB9O1xuXG4gICAgLy8gUmVzZXRcblxuICAgIHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xuXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cbiAgICB9O1xuXG4gICAgLy8gRXZlbnRzXG5cbiAgICBmdW5jdGlvbiBvbkNvbnRleHRMb3N0KCBldmVudCApIHtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHJlc2V0R0xTdGF0ZSgpO1xuICAgICAgICBzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG4gICAgICAgIHByb3BlcnRpZXMuY2xlYXIoKTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICB0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgICAgIGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMtLTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKCBldmVudCApIHtcblxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG4gICAgICAgIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzLS07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuICAgICAgICBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICB9XG5cbiAgICAvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXG5cbiAgICBmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcblxuICAgICAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG4gICAgICAgIGlmICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG4gICAgICAgICAgICAvLyBjdWJlIHRleHR1cmVcblxuICAgICAgICAgICAgX2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyAyRCB0ZXh0dXJlXG5cbiAgICAgICAgICAgIGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgICAgICAgX2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgd2ViZ2wgcHJvcGVydGllc1xuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggdGV4dHVyZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIGlmICggIXJlbmRlclRhcmdldCB8fCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgX2dsLmRlbGV0ZVRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XG4gICAgICAgICAgICAgICAgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcbiAgICAgICAgICAgIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIG1hdGVyaWFsICk7XG5cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHZhciBwcm9ncmFtSW5mbyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW07XG5cbiAgICAgICAgbWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbUluZm8gKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIHJlbmRlcmluZ1xuXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApIHtcblxuICAgICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG4gICAgICAgIHZhciBidWZmZXJzID0gcHJvcGVydGllcy5nZXQoIG9iamVjdCApO1xuXG4gICAgICAgIGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyAmJiAhYnVmZmVycy5wb3NpdGlvbiApIGJ1ZmZlcnMucG9zaXRpb24gPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgIWJ1ZmZlcnMubm9ybWFsICkgYnVmZmVycy5ub3JtYWwgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmICggb2JqZWN0Lmhhc1V2cyAmJiAhYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiAhYnVmZmVycy5jb2xvciApIGJ1ZmZlcnMuY29sb3IgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XG4gICAgICAgICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9iamVjdC5oYXNOb3JtYWxzICkge1xuXG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5ub3JtYWwgKTtcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC50eXBlICE9PSAnTWVzaFBob25nTWF0ZXJpYWwnICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNvdW50ICogMzsgaSA8IGw7IGkgKz0gOSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBueSA9ICggYXJyYXlbIGkgKyAxIF0gKyBhcnJheVsgaSArIDQgXSArIGFycmF5WyBpICsgNyBdICkgLyAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnogPSAoIGFycmF5WyBpICsgMiBdICsgYXJyYXlbIGkgKyA1IF0gKyBhcnJheVsgaSArIDggXSApIC8gMztcblxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDAgXSA9IG54O1xuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDEgXSA9IG55O1xuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDIgXSA9IG56O1xuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgMyBdID0gbng7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgNCBdID0gbnk7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgNSBdID0gbno7XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA2IF0gPSBueDtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA3IF0gPSBueTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA4IF0gPSBuejtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Lm5vcm1hbEFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5ub3JtYWwgKTtcblxuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnV2ICk7XG4gICAgICAgICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xuXG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvciApO1xuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xuXG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgICAgIF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcblxuICAgICAgICBvYmplY3QuY291bnQgPSAwO1xuXG4gICAgfTtcblxuICAgIHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24oIGNhbWVyYSwgbGlnaHRzLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcblxuICAgICAgICBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuICAgICAgICB2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuICAgICAgICB2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgbWF0ZXJpYWwud2lyZWZyYW1lO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnlQcm9ncmFtICE9PSBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSApIHtcblxuICAgICAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeVByb2dyYW07XG4gICAgICAgICAgICB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW9ycGggdGFyZ2V0c1xuXG4gICAgICAgIHZhciBtb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgICAgIGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBhY3RpdmVJbmZsdWVuY2VzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgYWN0aXZlSW5mbHVlbmNlcy5wdXNoKCBbIGluZmx1ZW5jZSwgaSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWN0aXZlSW5mbHVlbmNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XG5cbiAgICAgICAgICAgIGlmICggYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPiA4ICkge1xuXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPSA4O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IGFjdGl2ZUluZmx1ZW5jZXNbIGkgXTtcbiAgICAgICAgICAgICAgICBtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IGluZmx1ZW5jZVsgMCBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpbmZsdWVuY2VbIDAgXSAhPT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbmZsdWVuY2VbIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb25bIGluZGV4IF0gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoQXR0cmlidXRlcy5ub3JtYWxbIGluZGV4IF0gKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIGdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpO1xuXG4gICAgICAgICAgICBpZiAoIHVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMsIG1vcnBoSW5mbHVlbmNlcyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBpbmRleCA9IG9iamVjdHMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZXI7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgcmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRJbmRleCggaW5kZXggKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICByZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgICAgIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggaW5kZXggKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ3JvdXAgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIGNvdW50O1xuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gaW5kZXguY291bnQ7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICAgICAgY291bnQgPSBwb3NpdGlvbi5kYXRhLmFycmF5Lmxlbmd0aCAvIDM7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gcG9zaXRpb24uY291bnQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcblxuICAgICAgICAgICAgZ3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRyYXdSYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICBjb3VudDogTWF0aC5taW4oIGRyYXdSYW5nZS5jb3VudCwgY291bnQgKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlLnNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICogcGl4ZWxSYXRpbyApO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlciggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xuXG4gICAgICAgICAgICBpZiAoIGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkICkgbGluZVdpZHRoID0gMTsgLy8gTm90IHVzaW5nIExpbmUqTWF0ZXJpYWxcblxuICAgICAgICAgICAgc3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBwaXhlbFJhdGlvICk7XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzICkge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfU1RSSVAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5QT0lOVFMgKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlciggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBzdGFydEluZGV4ICkge1xuXG4gICAgICAgIHZhciBleHRlbnNpb247XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkICkgc3RhcnRJbmRleCA9IDA7XG5cbiAgICAgICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgICAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICB2YXIgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcblxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgdmFyIHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICBpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeUF0dHJpYnV0ZSA9IGdlb21ldHJ5QXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5vZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAoIHN0YXJ0SW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKSAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5zZXR1cFZlcnRleEF0dHJpYnV0ZXM6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZGF0YS5tZXNoUGVyQXR0cmlidXRlICogZGF0YS5jb3VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBwcm9ncmFtQXR0cmlidXRlLCBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICggdmFsdWUubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliMmZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjNmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjFmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgfVxuXG4gICAgLy8gU29ydGluZ1xuXG4gICAgZnVuY3Rpb24gbnVtZXJpY2FsU29ydCggYSwgYiApIHtcblxuICAgICAgICByZXR1cm4gYlsgMCBdIC0gYVsgMCBdO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cbiAgICAgICAgaWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG4gICAgICAgIGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG4gICAgICAgICAgICByZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcblxuICAgICAgICB9XG4gICAgICAgIGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBiLnogLSBhLno7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIFJlbmRlcmluZ1xuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xuXG4gICAgICAgIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb2cgPSBzY2VuZS5mb2c7XG5cbiAgICAgICAgLy8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxuXG4gICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG4gICAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xuICAgICAgICBfY3VycmVudENhbWVyYSA9IG51bGw7XG4gICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuICAgICAgICBpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuICAgICAgICBpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgICBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgICAgIF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICAgICAgbGlnaHRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgb3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuICAgICAgICB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtMTtcblxuICAgICAgICBvcGFxdWVJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4ID0gLTE7XG4gICAgICAgIHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuXG4gICAgICAgIHNwcml0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgbGVuc0ZsYXJlcy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHByb2plY3RPYmplY3QoIHNjZW5lICk7XG5cbiAgICAgICAgb3BhcXVlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVPYmplY3RzTGFzdEluZGV4ICsgMTtcbiAgICAgICAgdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA9IHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCArIDE7XG5cbiAgICAgICAgb3BhcXVlSW1tZWRpYXRlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4ICsgMTtcbiAgICAgICAgdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzLmxlbmd0aCA9IHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleCArIDE7XG5cbiAgICAgICAgaWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgb3BhcXVlT2JqZWN0cy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRPYmplY3RzLnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL1xuXG4gICAgICAgIHNoYWRvd01hcC5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcblxuICAgICAgICAvL1xuXG4gICAgICAgIF9pbmZvUmVuZGVyLmNhbGxzID0gMDtcbiAgICAgICAgX2luZm9SZW5kZXIudmVydGljZXMgPSAwO1xuICAgICAgICBfaW5mb1JlbmRlci5mYWNlcyA9IDA7XG4gICAgICAgIF9pbmZvUmVuZGVyLnBvaW50cyA9IDA7XG5cbiAgICAgICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuICAgICAgICAgICAgdGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgaWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcbiAgICAgICAgICAgIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXG4gICAgICAgICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBvcGFxdWVJbW1lZGlhdGVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG4gICAgICAgICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcblxuICAgICAgICAgICAgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZyApO1xuICAgICAgICAgICAgcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggb3BhcXVlSW1tZWRpYXRlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZyApO1xuXG4gICAgICAgICAgICAvLyB0cmFuc3BhcmVudCBwYXNzIChiYWNrLXRvLWZyb250IG9yZGVyKVxuXG4gICAgICAgICAgICByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2cgKTtcbiAgICAgICAgICAgIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHBvc3QgcGFzcylcblxuICAgICAgICBzcHJpdGVQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG4gICAgICAgIGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50V2lkdGgsIF9jdXJyZW50SGVpZ2h0ICk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzICYmIHJlbmRlclRhcmdldC5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiYgcmVuZGVyVGFyZ2V0Lm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xuXG4gICAgICAgICAgICB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG4gICAgICAgIHN0YXRlLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuICAgICAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XG4gICAgICAgIHN0YXRlLnNldENvbG9yV3JpdGUoIHRydWUgKTtcblxuICAgICAgICAvLyBfZ2wuZmluaXNoKCk7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHVzaEltbWVkaWF0ZVJlbmRlckl0ZW0oIG9iamVjdCApIHtcblxuICAgICAgICB2YXIgYXJyYXksIGluZGV4O1xuXG4gICAgICAgIC8vIGFsbG9jYXRlIHRoZSBuZXh0IHBvc2l0aW9uIGluIHRoZSBhcHByb3ByaWF0ZSBhcnJheVxuXG4gICAgICAgIGlmICggb2JqZWN0Lm1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xuXG4gICAgICAgICAgICBhcnJheSA9IHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0cztcbiAgICAgICAgICAgIGluZGV4ID0gKyt0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXg7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgYXJyYXkgPSBvcGFxdWVJbW1lZGlhdGVPYmplY3RzO1xuICAgICAgICAgICAgaW5kZXggPSArK29wYXF1ZUltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXg7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3ljbGUgZXhpc3RpbmcgcG9zaXRpb24gb3IgZ3JvdyB0aGUgYXJyYXlcblxuICAgICAgICBpZiAoIGluZGV4IDwgYXJyYXkubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBhcnJheVsgaW5kZXggXSA9IG9iamVjdDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBhc3NlcnQoIGluZGV4ID09PSBhcnJheS5sZW5ndGggKTtcbiAgICAgICAgICAgIGFycmF5LnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCB6LCBncm91cCApIHtcblxuICAgICAgICB2YXIgYXJyYXksIGluZGV4O1xuXG4gICAgICAgIC8vIGFsbG9jYXRlIHRoZSBuZXh0IHBvc2l0aW9uIGluIHRoZSBhcHByb3ByaWF0ZSBhcnJheVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cbiAgICAgICAgICAgIGFycmF5ID0gdHJhbnNwYXJlbnRPYmplY3RzO1xuICAgICAgICAgICAgaW5kZXggPSArK3RyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBhcnJheSA9IG9wYXF1ZU9iamVjdHM7XG4gICAgICAgICAgICBpbmRleCA9ICsrb3BhcXVlT2JqZWN0c0xhc3RJbmRleDtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjeWNsZSBleGlzdGluZyByZW5kZXIgaXRlbSBvciBncm93IHRoZSBhcnJheVxuXG4gICAgICAgIHZhciByZW5kZXJJdGVtID0gYXJyYXlbIGluZGV4IF07XG5cbiAgICAgICAgaWYgKCByZW5kZXJJdGVtICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgICByZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgIHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgIHJlbmRlckl0ZW0ueiA9IF92ZWN0b3IzLno7XG4gICAgICAgICAgICByZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmVuZGVySXRlbSA9IHtcbiAgICAgICAgICAgICAgICBpZDogb2JqZWN0LmlkLFxuICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbDogbWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgejogX3ZlY3RvcjMueixcbiAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGFzc2VydCggaW5kZXggPT09IGFycmF5Lmxlbmd0aCApO1xuICAgICAgICAgICAgYXJyYXkucHVzaCggcmVuZGVySXRlbSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCApIHtcblxuICAgICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xuXG4gICAgICAgICAgICBsaWdodHMucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xuXG4gICAgICAgICAgICBzcHJpdGVzLnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcblxuICAgICAgICAgICAgbGVuc0ZsYXJlcy5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIHB1c2hJbW1lZGlhdGVSZW5kZXJJdGVtKCBvYmplY3QgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG4gICAgICAgICAgICAgICAgb2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBncm91cE1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIF92ZWN0b3IzLnosIGdyb3VwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIF92ZWN0b3IzLnogKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgcHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSByZW5kZXJJdGVtLmdlb21ldHJ5O1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gdW5kZWZpbmVkID8gcmVuZGVySXRlbS5tYXRlcmlhbCA6IG92ZXJyaWRlTWF0ZXJpYWw7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xuXG4gICAgICAgICAgICBvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgb2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblxuICAgICAgICAgICAgX3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCByZW5kZXJMaXN0LCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XG5cbiAgICAgICAgICAgIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICBvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xuXG4gICAgICAgICAgICBpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgICAgICBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICAgICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG5cbiAgICAgICAgICAgIG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKSB7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gcHJvZ3JhbUNhY2hlLmdldFBhcmFtZXRlcnMoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICk7XG4gICAgICAgIHZhciBjb2RlID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1Db2RlKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW07XG4gICAgICAgIHZhciBwcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgLy8gbmV3IG1hdGVyaWFsXG4gICAgICAgICAgICBtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggcHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xuXG4gICAgICAgICAgICAvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xuICAgICAgICAgICAgcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gb25seSByZWJ1aWxkIHVuaWZvcm0gbGlzdFxuICAgICAgICAgICAgcHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHByb2dyYW1DaGFuZ2UgKSB7XG5cbiAgICAgICAgICAgIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIHBhcmFtZXRlcnMuc2hhZGVySUQgXTtcblxuICAgICAgICAgICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRlcmlhbC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG1hdGVyaWFsLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBtYXRlcmlhbC51bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBtYXRlcmlhbC5mcmFnbWVudFNoYWRlclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0ZXJpYWwuX193ZWJnbFNoYWRlciA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyO1xuXG4gICAgICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUNhY2hlLmFjcXVpcmVQcm9ncmFtKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApO1xuXG4gICAgICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuICAgICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhUYXJnZXRzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBpIF0gPj0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMrKztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuICAgICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIGkgXSA+PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscysrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSBbXTtcblxuICAgICAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCk7XG5cbiAgICAgICAgZm9yICggdmFyIHUgaW4gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHVuaWZvcm1Mb2NhdGlvbnNbIHUgXTtcblxuICAgICAgICAgICAgaWYgKCBsb2NhdGlvbiApIHtcblxuICAgICAgICAgICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3Jtc1sgdSBdLCBsb2NhdGlvbiBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuc2V0RGVwdGhGdW5jKCBtYXRlcmlhbC5kZXB0aEZ1bmMgKTtcbiAgICAgICAgc3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcbiAgICAgICAgc3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuICAgICAgICBzdGF0ZS5zZXRDb2xvcldyaXRlKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XG4gICAgICAgIHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSA/IHN0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApIDogc3RhdGUuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xuICAgICAgICBzdGF0ZS5zZXRGbGlwU2lkZWQoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xuXG4gICAgICAgIF91c2VkVGV4dHVyZVVuaXRzID0gMDtcblxuICAgICAgICB2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSB8fCAhbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gKSB7XG5cbiAgICAgICAgICAgIGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKTtcbiAgICAgICAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XG4gICAgICAgIHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcbiAgICAgICAgICAgIHBfdW5pZm9ybXMgPSBwcm9ncmFtLmdldFVuaWZvcm1zKCksXG4gICAgICAgICAgICBtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXM7XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtLmlkICE9PSBfY3VycmVudFByb2dyYW0gKSB7XG5cbiAgICAgICAgICAgIF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKTtcbiAgICAgICAgICAgIF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW0uaWQ7XG5cbiAgICAgICAgICAgIHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG4gICAgICAgICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xuXG4gICAgICAgICAgICBpZiAoIF9jdXJyZW50TWF0ZXJpYWxJZCA9PT0gLTEgKSByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xuXG4gICAgICAgICAgICByZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XG5cbiAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICAgICAgICBpZiAoIGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZiggcF91bmlmb3Jtcy5sb2dEZXB0aEJ1ZkZDLCAyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuICAgICAgICAgICAgLy8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuICAgICAgICAgICAgLy8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmVudk1hcCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2YoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24sIF92ZWN0b3IzLngsIF92ZWN0b3IzLnksIF92ZWN0b3IzLnogKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLnZpZXdNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy52aWV3TWF0cml4LCBmYWxzZSwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5lbGVtZW50cyApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxuICAgICAgICAvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcbiAgICAgICAgLy8gbm90IHN1cmUgd2h5LCBidXQgb3RoZXJ3aXNlIHdlaXJkIHRoaW5ncyBoYXBwZW5cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5iaW5kTWF0cml4ICYmIHBfdW5pZm9ybXMuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeCwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UgJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeEludmVyc2UsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UuZWxlbWVudHMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGgsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZVdpZHRoICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0LCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVIZWlnaHQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcywgZmFsc2UsIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgLy8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcblxuICAgICAgICAgICAgaWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5saWdodHMgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIF9saWdodHNOZWVkVXBkYXRlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKTtcbiAgICAgICAgICAgICAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggcmVmcmVzaExpZ2h0cyApIHtcblxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNMaWdodHMoIG1fdW5pZm9ybXMsIF9saWdodHMgKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgZmFsc2UgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggc2luZ2xlIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICBtX3VuaWZvcm1zLm1OZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XG4gICAgICAgICAgICAgICAgbV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgICAgICAgICAgICBtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICBtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgIW1hdGVyaWFsLl9zaGFkb3dQYXNzICkge1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zU2hhZG93KCBtX3VuaWZvcm1zLCBsaWdodHMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xuXG4gICAgICAgICAgICBsb2FkVW5pZm9ybXNHZW5lcmljKCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcblxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXgsIGZhbHNlLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG5cbiAgICB9XG5cbiAgICAvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICAgICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuZW1pc3NpdmUgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgdW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcbiAgICAgICAgdW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuICAgICAgICAgICAgdW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG4gICAgICAgIC8vIDEuIGNvbG9yIG1hcFxuICAgICAgICAvLyAyLiBzcGVjdWxhciBtYXBcbiAgICAgICAgLy8gMy4gbm9ybWFsIG1hcFxuICAgICAgICAvLyA0LiBidW1wIG1hcFxuICAgICAgICAvLyA1LiBhbHBoYSBtYXBcbiAgICAgICAgLy8gNi4gZW1pc3NpdmUgbWFwXG5cbiAgICAgICAgdmFyIHV2U2NhbGVNYXA7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcblxuICAgICAgICAgICAgdW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwO1xuICAgICAgICB1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtMTtcblxuICAgICAgICB1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG4gICAgICAgIHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgICAgICB1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG4gICAgICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XG4gICAgICAgIHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcbiAgICAgICAgdW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BhcnRpY2xlKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMucHNDb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuICAgICAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcbiAgICAgICAgdW5pZm9ybXMuc2l6ZS52YWx1ZSA9IG1hdGVyaWFsLnNpemU7XG4gICAgICAgIHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gX2NhbnZhcy5oZWlnaHQgLyAyLjA7IC8vIFRPRE86IENhY2hlIHRoaXMuXG5cbiAgICAgICAgdW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF0ZXJpYWwubWFwLm9mZnNldDtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSBtYXRlcmlhbC5tYXAucmVwZWF0O1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyggdW5pZm9ybXMsIGZvZyApIHtcblxuICAgICAgICB1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcblxuICAgICAgICBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xuICAgICAgICAgICAgdW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgICAgICB1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xuICAgICAgICB1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBtYXRlcmlhbC5zaGluaW5lc3M7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcbiAgICAgICAgICAgIHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG4gICAgICAgICAgICB1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG4gICAgICAgICAgICB1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuICAgICAgICAgICAgdW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgIHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyggdW5pZm9ybXMsIGxpZ2h0cyApIHtcblxuICAgICAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5hbWJpZW50O1xuXG4gICAgICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XG4gICAgICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zO1xuXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5wb2ludC5jb2xvcnM7XG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5wb2ludC5wb3NpdGlvbnM7XG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kaXN0YW5jZXM7XG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHREZWNheS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kZWNheXM7XG5cbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3BvdC5jb2xvcnM7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QucG9zaXRpb25zO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpc3RhbmNlcztcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlyZWN0aW9ucztcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWUgPSBsaWdodHMuc3BvdC5hbmdsZXNDb3M7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50LnZhbHVlID0gbGlnaHRzLnNwb3QuZXhwb25lbnRzO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREZWNheS52YWx1ZSA9IGxpZ2h0cy5zcG90LmRlY2F5cztcblxuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLnNreUNvbG9ycztcbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5ncm91bmRDb2xvcnM7XG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5oZW1pLnBvc2l0aW9ucztcblxuICAgIH1cblxuICAgIC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cblxuICAgIGZ1bmN0aW9uIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCB1bmlmb3JtcywgdmFsdWUgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0UG9zaXRpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHREZWNheS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREZWNheS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU2hhZG93KCB1bmlmb3JtcywgbGlnaHRzICkge1xuXG4gICAgICAgIGlmICggdW5pZm9ybXMuc2hhZG93TWF0cml4ICkge1xuXG4gICAgICAgICAgICB2YXIgaiA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCB8fCAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hcC52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwO1xuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXBTaXplLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXBTaXplO1xuXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hdHJpeC52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWF0cml4O1xuXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93Qmlhcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93QmlhcztcblxuICAgICAgICAgICAgICAgICAgICBqKys7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBVbmlmb3JtcyAobG9hZCB0byBHUFUpXG5cbiAgICBmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyggdW5pZm9ybXMsIG9iamVjdCApIHtcblxuICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICAgIGlmICggdW5pZm9ybXMubm9ybWFsTWF0cml4ICkge1xuXG4gICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm5vcm1hbE1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHR1cmVVbml0KCkge1xuXG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xuXG4gICAgICAgIGlmICggdGV4dHVyZVVuaXQgPj0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0cnlpbmcgdG8gdXNlICcgKyB0ZXh0dXJlVW5pdCArICcgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICcgKyBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgX3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZVVuaXQ7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkVW5pZm9ybXNHZW5lcmljKCB1bmlmb3JtcyApIHtcblxuICAgICAgICB2YXIgdGV4dHVyZSwgdGV4dHVyZVVuaXQ7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbIGogXVsgMCBdO1xuXG4gICAgICAgICAgICAvLyBuZWVkc1VwZGF0ZSBwcm9wZXJ0eSBpcyBub3QgYWRkZWQgdG8gYWxsIHVuaWZvcm1zLlxuICAgICAgICAgICAgaWYgKCB1bmlmb3JtLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHVuaWZvcm0udHlwZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3Jtc1sgaiBdWyAxIF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIHR5cGUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICcxaSc6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzFmJzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnMmYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzNmJzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICc0Zic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdLCB2YWx1ZVsgMyBdICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnMWl2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzNpdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICcxZnYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnMmZ2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzNmdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICc0ZnYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnTWF0cml4M2Z2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdNYXRyaXg0ZnYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaSc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgZmxvYXRcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd2Mic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3YzJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yM1xuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndjQnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3I0XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56LCB2YWx1ZS53ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLnIsIHZhbHVlLmcsIHZhbHVlLmIgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2l2MSc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2l2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2Z2MSc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdmdic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndjJ2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IyXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDIgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpMiA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkrKywgaTIgKz0gMiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkyICsgMCBdID0gdmFsdWVbIGkgXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkyICsgMSBdID0gdmFsdWVbIGkgXS55O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd2M3YnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjNcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGkzID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSsrLCBpMyArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTMgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTMgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTMgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3Y0dic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yNFxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaTQgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpKyssIGk0ICs9IDQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpNCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpNCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpNCArIDIgXSA9IHZhbHVlWyBpIF0uejtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpNCArIDMgXSA9IHZhbHVlWyBpIF0udztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbTMnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5NYXRyaXgzXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtM3YnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDNcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiA5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtNCc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLk1hdHJpeDRcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ200dic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuTWF0cml4NFxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhdGV4dHVyZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIEFycmF5LmlzQXJyYXkoIHRleHR1cmUuaW1hZ2UgKSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0dic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVGV4dHVyZSAoMmQpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaSBdID0gZ2V0VGV4dHVyZVVuaXQoKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSB1bmlmb3JtLnZhbHVlWyBpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdCA9IHVuaWZvcm0uX2FycmF5WyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXRleHR1cmUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdHlwZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q29sb3JMaW5lYXIoIGFycmF5LCBvZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDAgXSA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nICogaW50ZW5zaXR5O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYiAqIGludGVuc2l0eTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwTGlnaHRzKCBsaWdodHMsIGNhbWVyYSApIHtcblxuICAgICAgICB2YXIgbCwgbGwsIGxpZ2h0LFxuICAgICAgICAgICAgciA9IDAsXG4gICAgICAgICAgICBnID0gMCxcbiAgICAgICAgICAgIGIgPSAwLFxuICAgICAgICAgICAgY29sb3IsIHNreUNvbG9yLCBncm91bmRDb2xvcixcbiAgICAgICAgICAgIGludGVuc2l0eSxcbiAgICAgICAgICAgIGRpc3RhbmNlLFxuXG4gICAgICAgICAgICB6bGlnaHRzID0gX2xpZ2h0cyxcblxuICAgICAgICAgICAgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsXG5cbiAgICAgICAgICAgIGRpckNvbG9ycyA9IHpsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzLFxuICAgICAgICAgICAgZGlyUG9zaXRpb25zID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnMsXG5cbiAgICAgICAgICAgIHBvaW50Q29sb3JzID0gemxpZ2h0cy5wb2ludC5jb2xvcnMsXG4gICAgICAgICAgICBwb2ludFBvc2l0aW9ucyA9IHpsaWdodHMucG9pbnQucG9zaXRpb25zLFxuICAgICAgICAgICAgcG9pbnREaXN0YW5jZXMgPSB6bGlnaHRzLnBvaW50LmRpc3RhbmNlcyxcbiAgICAgICAgICAgIHBvaW50RGVjYXlzID0gemxpZ2h0cy5wb2ludC5kZWNheXMsXG5cbiAgICAgICAgICAgIHNwb3RDb2xvcnMgPSB6bGlnaHRzLnNwb3QuY29sb3JzLFxuICAgICAgICAgICAgc3BvdFBvc2l0aW9ucyA9IHpsaWdodHMuc3BvdC5wb3NpdGlvbnMsXG4gICAgICAgICAgICBzcG90RGlzdGFuY2VzID0gemxpZ2h0cy5zcG90LmRpc3RhbmNlcyxcbiAgICAgICAgICAgIHNwb3REaXJlY3Rpb25zID0gemxpZ2h0cy5zcG90LmRpcmVjdGlvbnMsXG4gICAgICAgICAgICBzcG90QW5nbGVzQ29zID0gemxpZ2h0cy5zcG90LmFuZ2xlc0NvcyxcbiAgICAgICAgICAgIHNwb3RFeHBvbmVudHMgPSB6bGlnaHRzLnNwb3QuZXhwb25lbnRzLFxuICAgICAgICAgICAgc3BvdERlY2F5cyA9IHpsaWdodHMuc3BvdC5kZWNheXMsXG5cbiAgICAgICAgICAgIGhlbWlTa3lDb2xvcnMgPSB6bGlnaHRzLmhlbWkuc2t5Q29sb3JzLFxuICAgICAgICAgICAgaGVtaUdyb3VuZENvbG9ycyA9IHpsaWdodHMuaGVtaS5ncm91bmRDb2xvcnMsXG4gICAgICAgICAgICBoZW1pUG9zaXRpb25zID0gemxpZ2h0cy5oZW1pLnBvc2l0aW9ucyxcblxuICAgICAgICAgICAgZGlyTGVuZ3RoID0gMCxcbiAgICAgICAgICAgIHBvaW50TGVuZ3RoID0gMCxcbiAgICAgICAgICAgIHNwb3RMZW5ndGggPSAwLFxuICAgICAgICAgICAgaGVtaUxlbmd0aCA9IDAsXG5cbiAgICAgICAgICAgIGRpckNvdW50ID0gMCxcbiAgICAgICAgICAgIHBvaW50Q291bnQgPSAwLFxuICAgICAgICAgICAgc3BvdENvdW50ID0gMCxcbiAgICAgICAgICAgIGhlbWlDb3VudCA9IDAsXG5cbiAgICAgICAgICAgIGRpck9mZnNldCA9IDAsXG4gICAgICAgICAgICBwb2ludE9mZnNldCA9IDAsXG4gICAgICAgICAgICBzcG90T2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIGhlbWlPZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCsrICkge1xuXG4gICAgICAgICAgICBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG4gICAgICAgICAgICBpZiAoIGxpZ2h0Lm9ubHlTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sb3IgPSBsaWdodC5jb2xvcjtcbiAgICAgICAgICAgIGludGVuc2l0eSA9IGxpZ2h0LmludGVuc2l0eTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICByICs9IGNvbG9yLnI7XG4gICAgICAgICAgICAgICAgZyArPSBjb2xvci5nO1xuICAgICAgICAgICAgICAgIGIgKz0gY29sb3IuYjtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuICAgICAgICAgICAgICAgIGRpckNvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgICBkaXJPZmZzZXQgPSBkaXJMZW5ndGggKiAzO1xuXG4gICAgICAgICAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XG4gICAgICAgICAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgICAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggZGlyQ29sb3JzLCBkaXJPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgICAgICAgICAgICAgIGRpckxlbmd0aCArPSAxO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgcG9pbnRDb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgcG9pbnRPZmZzZXQgPSBwb2ludExlbmd0aCAqIDM7XG5cbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggcG9pbnRDb2xvcnMsIHBvaW50T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAwIF0gPSBfdmVjdG9yMy54O1xuICAgICAgICAgICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XG4gICAgICAgICAgICAgICAgcG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcblxuICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlIGlzIDAgaWYgZGVjYXkgaXMgMCwgYmVjYXVzZSB0aGVyZSBpcyBubyBhdHRlbnVhdGlvbiBhdCBhbGwuXG4gICAgICAgICAgICAgICAgcG9pbnREaXN0YW5jZXNbIHBvaW50TGVuZ3RoIF0gPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBwb2ludERlY2F5c1sgcG9pbnRMZW5ndGggXSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xuXG4gICAgICAgICAgICAgICAgcG9pbnRMZW5ndGggKz0gMTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgc3BvdENvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBzcG90T2Zmc2V0ID0gc3BvdExlbmd0aCAqIDM7XG5cbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggc3BvdENvbG9ycywgc3BvdE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuY29weSggX2RpcmVjdGlvbiApLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgc3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDAgXSA9IF92ZWN0b3IzLng7XG4gICAgICAgICAgICAgICAgc3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XG4gICAgICAgICAgICAgICAgc3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XG5cbiAgICAgICAgICAgICAgICBzcG90RGlzdGFuY2VzWyBzcG90TGVuZ3RoIF0gPSBkaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuICAgICAgICAgICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICAgICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuICAgICAgICAgICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG4gICAgICAgICAgICAgICAgc3BvdEFuZ2xlc0Nvc1sgc3BvdExlbmd0aCBdID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XG4gICAgICAgICAgICAgICAgc3BvdEV4cG9uZW50c1sgc3BvdExlbmd0aCBdID0gbGlnaHQuZXhwb25lbnQ7XG4gICAgICAgICAgICAgICAgc3BvdERlY2F5c1sgc3BvdExlbmd0aCBdID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cbiAgICAgICAgICAgICAgICBzcG90TGVuZ3RoICs9IDE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIHtcblxuICAgICAgICAgICAgICAgIGhlbWlDb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuICAgICAgICAgICAgICAgIGhlbWlPZmZzZXQgPSBoZW1pTGVuZ3RoICogMztcblxuICAgICAgICAgICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XG4gICAgICAgICAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcbiAgICAgICAgICAgICAgICBoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG4gICAgICAgICAgICAgICAgc2t5Q29sb3IgPSBsaWdodC5jb2xvcjtcbiAgICAgICAgICAgICAgICBncm91bmRDb2xvciA9IGxpZ2h0Lmdyb3VuZENvbG9yO1xuXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIGhlbWlTa3lDb2xvcnMsIGhlbWlPZmZzZXQsIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggaGVtaUdyb3VuZENvbG9ycywgaGVtaU9mZnNldCwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgICAgICAgICAgaGVtaUxlbmd0aCArPSAxO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG51bGwgZXZlbnR1YWwgcmVtYWlucyBmcm9tIHJlbW92ZWQgbGlnaHRzXG4gICAgICAgIC8vICh0aGlzIGlzIHRvIGF2b2lkIGlmIGluIHNoYWRlcilcblxuICAgICAgICBmb3IgKCBsID0gZGlyTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggZGlyQ29sb3JzLmxlbmd0aCwgZGlyQ291bnQgKiAzICk7IGwgPCBsbDsgbCsrICkgZGlyQ29sb3JzWyBsIF0gPSAwLjA7XG4gICAgICAgIGZvciAoIGwgPSBwb2ludExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHBvaW50Q29sb3JzLmxlbmd0aCwgcG9pbnRDb3VudCAqIDMgKTsgbCA8IGxsOyBsKysgKSBwb2ludENvbG9yc1sgbCBdID0gMC4wO1xuICAgICAgICBmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCsrICkgc3BvdENvbG9yc1sgbCBdID0gMC4wO1xuICAgICAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlTa3lDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCsrICkgaGVtaVNreUNvbG9yc1sgbCBdID0gMC4wO1xuICAgICAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlHcm91bmRDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCsrICkgaGVtaUdyb3VuZENvbG9yc1sgbCBdID0gMC4wO1xuXG4gICAgICAgIHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyTGVuZ3RoO1xuICAgICAgICB6bGlnaHRzLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xuICAgICAgICB6bGlnaHRzLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcbiAgICAgICAgemxpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cbiAgICAgICAgemxpZ2h0cy5hbWJpZW50WyAwIF0gPSByO1xuICAgICAgICB6bGlnaHRzLmFtYmllbnRbIDEgXSA9IGc7XG4gICAgICAgIHpsaWdodHMuYW1iaWVudFsgMiBdID0gYjtcblxuICAgIH1cblxuICAgIC8vIEdMIHN0YXRlIHNldHRpbmdcblxuICAgIHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcblxuICAgICAgICBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XG5cbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkZST05UX0FORF9CQUNLICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIFRleHR1cmVzXG5cbiAgICBmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgIHZhciBleHRlbnNpb247XG5cbiAgICAgICAgaWYgKCBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBTICkgKTtcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwVCApICk7XG5cbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWFnRmlsdGVyICkgKTtcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUud3JhcFMgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuICggJyArIHRleHR1cmUuc291cmNlRmlsZSArICcgKScgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cbiAgICAgICAgICAgIGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4gKCAnICsgdGV4dHVyZS5zb3VyY2VGaWxlICsgJyApJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uICkge1xuXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUudHlwZSA9PT0gVEhSRUUuRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApID09PSBudWxsICkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcblxuICAgICAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBfdGhpcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgICAgIGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuICAgICAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcysrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG4gICAgICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG4gICAgICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlLFxuICAgICAgICAgICAgaXNJbWFnZVBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXG4gICAgICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuICAgICAgICAgICAgZ2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG4gICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKTtcblxuICAgICAgICB2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xuXG4gICAgICAgIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xuXG4gICAgICAgICAgICAvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG4gICAgICAgICAgICAvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuICAgICAgICAgICAgaWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0xICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKClcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXG5cbiAgICAgICAgICAgIC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcbiAgICAgICAgICAgIC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG4gICAgICAgICAgICBpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuaW1hZ2UgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuICAgICAgICBpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldFRleHR1cmUgPSBmdW5jdGlvbiggdGV4dHVyZSwgc2xvdCApIHtcblxuICAgICAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG4gICAgICAgIGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuICAgICAgICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuICAgICAgICAgICAgaWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkJywgdGV4dHVyZSApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGltYWdlLmNvbXBsZXRlID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnLCB0ZXh0dXJlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplKCBpbWFnZSwgbWF4U2l6ZSApIHtcblxuICAgICAgICBpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG4gICAgICAgICAgICAvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxuICAgICAgICAgICAgLy8gcHJlbXVsdGlwbGllZCBhbHBoYS5cblxuICAgICAgICAgICAgdmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBzY2FsZSApO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW1hZ2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgc2xvdCApIHtcblxuICAgICAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG4gICAgICAgIGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuICAgICAgICAgICAgICAgIGlmICggIXRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcysrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG4gICAgICAgICAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcbiAgICAgICAgICAgICAgICB2YXIgaXNEYXRhVGV4dHVyZSA9IHRleHR1cmUuaW1hZ2VbIDAgXSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1YmVJbWFnZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgIWlzQ29tcHJlc3NlZCAmJiAhaXNEYXRhVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdWJlSW1hZ2VbIGkgXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlWyBpIF0uaW1hZ2UgOiB0ZXh0dXJlLmltYWdlWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXG4gICAgICAgICAgICAgICAgICAgIGlzSW1hZ2VQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApLFxuICAgICAgICAgICAgICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuICAgICAgICAgICAgICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XG5cbiAgICAgICAgICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNDb21wcmVzc2VkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzRGF0YVRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGN1YmVJbWFnZVsgaSBdLndpZHRoLCBjdWJlSW1hZ2VbIGkgXS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdLmRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGogXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0Q3ViZVRleHR1cmUoKVwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICAgICAgICAgICAgICBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdGFyZ2V0c1xuXG4gICAgZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlciggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcblxuICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG4gICAgICAgIF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRleHR1cmVUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsVGV4dHVyZSwgMCApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgICAgIF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuICAgICAgICAgICAgLyogRm9yIHNvbWUgcmVhc29uIHRoaXMgaXMgbm90IHdvcmtpbmcuIERlZmF1bHRpbmcgdG8gUkdCQTQuXG5cdFx0fSBlbHNlIGlmICggISByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuU1RFTkNJTF9JTkRFWDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXHRcdCovXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICAgICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24oIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgICB2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cbiAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcysrO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCB0ZXh0dXJlLCBjcmVhdGUgcmVuZGVyIGFuZCBmcmFtZSBidWZmZXJzXG5cbiAgICAgICAgICAgIHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC5oZWlnaHQgKSxcbiAgICAgICAgICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQuZm9ybWF0ICksXG4gICAgICAgICAgICAgICAgZ2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50eXBlICk7XG5cbiAgICAgICAgICAgIGlmICggaXNDdWJlICkge1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSBbXTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgICAgICAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuICAgICAgICAgICAgICAgICAgICBzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcblxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcbiAgICAgICAgICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG4gICAgICAgICAgICAgICAgc2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICFyZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbGVhc2UgZXZlcnl0aGluZ1xuXG4gICAgICAgICAgICBpZiAoIGlzQ3ViZSApIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG4gICAgICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgICAgICBpZiAoIGlzQ3ViZSApIHtcblxuICAgICAgICAgICAgICAgIGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSBdO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXI7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2eCA9IDA7XG4gICAgICAgICAgICB2eSA9IDA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZnJhbWVidWZmZXIgPSBudWxsO1xuXG4gICAgICAgICAgICB3aWR0aCA9IF92aWV3cG9ydFdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gX3ZpZXdwb3J0SGVpZ2h0O1xuXG4gICAgICAgICAgICB2eCA9IF92aWV3cG9ydFg7XG4gICAgICAgICAgICB2eSA9IF92aWV3cG9ydFk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcbiAgICAgICAgICAgIF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcblxuICAgICAgICB9XG5cbiAgICAgICAgX2N1cnJlbnRXaWR0aCA9IHdpZHRoO1xuICAgICAgICBfY3VycmVudEhlaWdodCA9IGhlaWdodDtcblxuICAgIH07XG5cbiAgICB0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XG5cbiAgICAgICAgaWYgKCAhKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCApICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyICkge1xuXG4gICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgZm9ybWF0LiByZWFkUGl4ZWxzIGNhbiByZWFkIG9ubHkgUkdCQSBmb3JtYXQuJyApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdG9yZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblxuICAgICAgICAgICAgICAgIHJlc3RvcmUgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgX2dsLlJHQkEsIF9nbC5VTlNJR05FRF9CWVRFLCBidWZmZXIgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHJlc3RvcmUgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9jdXJyZW50RnJhbWVidWZmZXIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbFRleHR1cmUgKTtcbiAgICAgICAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcbiAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xUZXh0dXJlICk7XG4gICAgICAgICAgICBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG4gICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2soIGYgKSB7XG5cbiAgICAgICAgaWYgKCBmID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBfZ2wuTkVBUkVTVDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9nbC5MSU5FQVI7XG5cbiAgICB9XG5cbiAgICAvLyBNYXAgdGhyZWUuanMgY29uc3RhbnRzIHRvIFdlYkdMIGNvbnN0YW50c1xuXG4gICAgZnVuY3Rpb24gcGFyYW1UaHJlZVRvR0woIHAgKSB7XG5cbiAgICAgICAgdmFyIGV4dGVuc2lvbjtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5SRVBFQVQ7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5NSVJST1JFRF9SRVBFQVQ7XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfQllURTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlNob3J0VHlwZSApIHJldHVybiBfZ2wuU0hPUlQ7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEludFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0lOVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5GbG9hdFR5cGUgKSByZXR1cm4gX2dsLkZMT0FUO1xuXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICkgcmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5BbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuQUxQSEE7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQUZvcm1hdCApIHJldHVybiBfZ2wuUkdCQTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuQWRkRXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfQUREO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlplcm9GYWN0b3IgKSByZXR1cm4gX2dsLlpFUk87XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lRmFjdG9yICkgcmV0dXJuIF9nbC5PTkU7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEE7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5Ec3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuRFNUX0FMUEhBO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQUxQSEE7XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5Ec3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQ09MT1I7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xuXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcblxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk1pbkVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NSU5fRVhUO1xuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5NYXhFcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUFYX0VYVDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICB9XG5cbiAgICAvLyBERVBSRUNBVEVEXG5cbiAgICB0aGlzLnN1cHBvcnRzRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9mbG9hdFxcJyApLicgKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XFwnICkuJyApO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcJyApLicgKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xcJyApLicgKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXFwnICkuJyApO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zdXBwb3J0c0JsZW5kTWluTWF4ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQmxlbmRNaW5NYXgoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdFWFRfYmxlbmRfbWlubWF4XFwnICkuJyApO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBjYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXM7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zdXBwb3J0c0luc3RhbmNlZEFycmF5cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0luc3RhbmNlZEFycmF5cygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0FOR0xFX2luc3RhbmNlZF9hcnJheXNcXCcgKS4nICk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICB9O1xuXG4gICAgLy9cblxuICAgIHRoaXMuaW5pdE1hdGVyaWFsID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmluaXRNYXRlcmlhbCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuYWRkUHJlUGx1Z2luID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuYWRkUG9zdFBsdWdpbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVTaGFkb3dNYXAgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudXBkYXRlU2hhZG93TWFwKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcbiAgICAgICAgc2hhZG93TWFwRW5hYmxlZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dNYXAuZW5hYmxlZDtcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nICk7XG4gICAgICAgICAgICAgICAgc2hhZG93TWFwLmVuYWJsZWQgPSB2YWx1ZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3dNYXBUeXBlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd01hcC50eXBlO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNoYWRvd01hcEN1bGxGYWNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5jdWxsRmFjZTtcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEN1bGxGYWNlIGlzIG5vdyAuc2hhZG93TWFwLmN1bGxGYWNlLicgKTtcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAuY3VsbEZhY2UgPSB2YWx1ZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3dNYXBEZWJ1Zzoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dNYXAuZGVidWc7XG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBEZWJ1ZyBpcyBub3cgLnNoYWRvd01hcC5kZWJ1Zy4nICk7XG4gICAgICAgICAgICAgICAgc2hhZG93TWFwLmRlYnVnID0gdmFsdWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gKTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0LmpzXG5cbi8qKlxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy53cmFwUyA9IG9wdGlvbnMud3JhcFMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIHRoaXMud3JhcFQgPSBvcHRpb25zLndyYXBUICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICAgIHRoaXMubWFnRmlsdGVyID0gb3B0aW9ucy5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuICAgIHRoaXMubWluRmlsdGVyID0gb3B0aW9ucy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG4gICAgdGhpcy5hbmlzb3Ryb3B5ID0gb3B0aW9ucy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaXNvdHJvcHkgOiAxO1xuXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xuICAgIHRoaXMucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuICAgIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XG5cbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XG4gICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xuXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuXG4gICAgdGhpcy5zaGFyZURlcHRoRnJvbSA9IG9wdGlvbnMuc2hhcmVEZXB0aEZyb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2hhcmVEZXB0aEZyb20gOiBudWxsO1xuXG59O1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQsXG5cbiAgICBzZXRTaXplOiBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCApIHtcblxuICAgICAgICBpZiAoIHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgKSB7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblxuICAgICAgICB0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuICAgICAgICB0aGlzLndyYXBUID0gc291cmNlLndyYXBUO1xuXG4gICAgICAgIHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xuXG4gICAgICAgIHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xuXG4gICAgICAgIHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcbiAgICAgICAgdGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xuXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcbiAgICAgICAgdGhpcy50eXBlID0gc291cmNlLnR5cGU7XG5cbiAgICAgICAgdGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcbiAgICAgICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgICAgIHRoaXMuc2hhcmVEZXB0aEZyb20gPSBzb3VyY2Uuc2hhcmVEZXB0aEZyb207XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICB0eXBlOiAnZGlzcG9zZSdcbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuICAgIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuICAgIHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEJ1ZmZlclJlbmRlcmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyID0gZnVuY3Rpb24oIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XG5cbiAgICB2YXIgbW9kZTtcblxuICAgIGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xuXG4gICAgICAgIG1vZGUgPSB2YWx1ZTtcblxuICAgIH1cblxuICAgIHZhciB0cmFjZUNvdW50ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xuICAgICAgICBpZiAoIHRyYWNlQ291bnQgPT09IDAgKSB7XG4gICAgICAgICAgICB0cmFjZUNvdW50ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9nbC5kcmF3QXJyYXlzKCBtb2RlLCBzdGFydCwgY291bnQgKTtcblxuICAgICAgICBfaW5mb1JlbmRlci5jYWxscysrO1xuICAgICAgICBfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcbiAgICAgICAgaWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmICggcG9zaXRpb24gaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uZGF0YS5jb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBwb3NpdGlvbi5jb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuICAgIHRoaXMucmVuZGVyID0gcmVuZGVyO1xuICAgIHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gZnVuY3Rpb24oIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XG5cbiAgICB2YXIgbW9kZTtcblxuICAgIGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xuXG4gICAgICAgIG1vZGUgPSB2YWx1ZTtcblxuICAgIH1cblxuICAgIHZhciB0eXBlLCBzaXplO1xuXG4gICAgZnVuY3Rpb24gc2V0SW5kZXgoIGluZGV4ICkge1xuXG4gICAgICAgIGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICAgICAgICAgIHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuICAgICAgICAgICAgc2l6ZSA9IDQ7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgICAgIHNpemUgPSAyO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xuXG4gICAgICAgIF9nbC5kcmF3RWxlbWVudHMoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIHNpemUgKTtcblxuICAgICAgICBfaW5mb1JlbmRlci5jYWxscysrO1xuICAgICAgICBfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcbiAgICAgICAgaWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblxuICAgICAgICBleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIGluZGV4LmFycmF5Lmxlbmd0aCwgdHlwZSwgMCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuICAgIH1cblxuICAgIHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG4gICAgdGhpcy5zZXRJbmRleCA9IHNldEluZGV4O1xuICAgIHRoaXMucmVuZGVyID0gcmVuZGVyO1xuICAgIHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xFeHRlbnNpb25zLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTEV4dGVuc2lvbnMgPSBmdW5jdGlvbiggZ2wgKSB7XG5cbiAgICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbnNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgICAgIHN3aXRjaCAoIG5hbWUgKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnNpb25zWyBuYW1lIF0gPSBleHRlbnNpb247XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcblxuICAgIH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTENhcGFiaWxpdGllcy5qc1xuXG5USFJFRS5XZWJHTENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApIHtcblxuICAgIGZ1bmN0aW9uIGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICkge1xuXG4gICAgICAgIGlmICggcHJlY2lzaW9uID09PSAnaGlnaHAnICkge1xuXG4gICAgICAgICAgICBpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcbiAgICAgICAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpZ2hwJztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVjaXNpb24gPSAnbWVkaXVtcCc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XG5cbiAgICAgICAgICAgIGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG4gICAgICAgICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJ21lZGl1bXAnO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnbG93cCc7XG5cbiAgICB9XG5cbiAgICB0aGlzLmdldE1heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbjtcblxuICAgIHRoaXMucHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJyxcbiAgICB0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA6IGZhbHNlO1xuXG4gICAgdGhpcy5tYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcbiAgICB0aGlzLm1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcbiAgICB0aGlzLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XG4gICAgdGhpcy5tYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xuXG4gICAgdGhpcy5tYXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX0FUVFJJQlMgKTtcbiAgICB0aGlzLm1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xuICAgIHRoaXMubWF4VmFyeWluZ3MgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgKTtcbiAgICB0aGlzLm1heEZyYWdtZW50VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgKTtcblxuICAgIHRoaXMudmVydGV4VGV4dHVyZXMgPSB0aGlzLm1heFZlcnRleFRleHR1cmVzID4gMDtcbiAgICB0aGlzLmZsb2F0RnJhZ21lbnRUZXh0dXJlcyA9ICEhZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcbiAgICB0aGlzLmZsb2F0VmVydGV4VGV4dHVyZXMgPSB0aGlzLnZlcnRleFRleHR1cmVzICYmIHRoaXMuZmxvYXRGcmFnbWVudFRleHR1cmVzO1xuXG4gICAgdmFyIF9tYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb24oIHRoaXMucHJlY2lzaW9uICk7XG5cbiAgICBpZiAoIF9tYXhQcmVjaXNpb24gIT09IHRoaXMucHJlY2lzaW9uICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgdGhpcy5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIF9tYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSBfbWF4UHJlY2lzaW9uO1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cbiAgICAgICAgdGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gISFleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xHZW9tZXRyaWVzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTEdlb21ldHJpZXMgPSBmdW5jdGlvbiggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0KCBvYmplY3QgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG4gICAgICAgIHZhciBidWZmZXJnZW9tZXRyeTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5O1xuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gYnVmZmVyZ2VvbWV0cnk7XG5cbiAgICAgICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcysrO1xuXG4gICAgICAgIHJldHVybiBidWZmZXJnZW9tZXRyeTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cbiAgICAgICAgZGVsZXRlQXR0cmlidXRlcyggYnVmZmVyZ2VvbWV0cnkuYXR0cmlidXRlcyApO1xuXG4gICAgICAgIGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuICAgICAgICBkZWxldGUgZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcbiAgICAgICAgaWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgKSBkZWxldGVBdHRyaWJ1dGUoIHByb3BlcnR5LndpcmVmcmFtZSApO1xuXG4gICAgICAgIGluZm8ubWVtb3J5Lmdlb21ldHJpZXMtLTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlLmRhdGEgKS5fX3dlYmdsQnVmZmVyO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuICAgICAgICB2YXIgYnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcblxuICAgICAgICBpZiAoIGJ1ZmZlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIoIGJ1ZmZlciApO1xuICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIGF0dHJpYnV0ZS5kYXRhICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIGF0dHJpYnV0ZSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuZ2V0ID0gZ2V0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xPYmplY3RzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTE9iamVjdHMgPSBmdW5jdGlvbiggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IG5ldyBUSFJFRS5XZWJHTEdlb21ldHJpZXMoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICk7XG5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XG5cbiAgICAgICAgLy8gVE9ETzogQXZvaWQgdXBkYXRpbmcgdHdpY2UgKHdoZW4gdXNpbmcgc2hhZG93TWFwKS4gTWF5YmUgYWRkIGZyYW1lIGNvdW50ZXIuXG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCApO1xuXG4gICAgICAgIGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LnVwZGF0ZUZyb21PYmplY3QoIG9iamVjdCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW9ycGggdGFyZ2V0c1xuXG4gICAgICAgIHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBhcnJheVsgaSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcblxuICAgICAgICB2YXIgZGF0YSA9ICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIGRhdGEgKTtcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uICE9PSBkYXRhLnZlcnNpb24gKSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApIHtcblxuICAgICAgICBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XG5cbiAgICAgICAgdmFyIHVzYWdlID0gZGF0YS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEuYXJyYXksIHVzYWdlICk7XG5cbiAgICAgICAgYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xuXG4gICAgICAgIGlmICggZGF0YS5keW5hbWljID09PSBmYWxzZSB8fCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAtMSApIHtcblxuICAgICAgICAgICAgLy8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIDAsIGRhdGEuYXJyYXkgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAwICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xPYmplY3RzLnVwZGF0ZUJ1ZmZlcjogZHluYW1pYyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCB1cGRhdGVSYW5nZS5jb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS4nICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgICAgICAgICBkYXRhLmFycmF5LnN1YmFycmF5KCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKyBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcblxuICAgICAgICAgICAgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9IDA7IC8vIHJlc2V0IHJhbmdlXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlLmRhdGEgKS5fX3dlYmdsQnVmZmVyO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG4gICAgICAgIGlmICggcHJvcGVydHkud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eS53aXJlZnJhbWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICAvLyBjb25zb2xlLnRpbWUoICd3aXJlZnJhbWUnICk7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdmFyIGVkZ2VzID0ge307XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBpbmRleC5hcnJheTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBhcnJheVsgaSArIDAgXTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGFycmF5WyBpICsgMSBdO1xuICAgICAgICAgICAgICAgIHZhciBjID0gYXJyYXlbIGkgKyAyIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGEsIGIgKSApIGluZGljZXMucHVzaCggYSwgYiApO1xuICAgICAgICAgICAgICAgIGlmICggY2hlY2tFZGdlKCBlZGdlcywgYiwgYyApICkgaW5kaWNlcy5wdXNoKCBiLCBjICk7XG4gICAgICAgICAgICAgICAgaWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBjLCBhICkgKSBpbmRpY2VzLnB1c2goIGMsIGEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBhID0gaSArIDA7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGkgKyAyO1xuXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS50aW1lRW5kKCAnd2lyZWZyYW1lJyApO1xuXG4gICAgICAgIHZhciBUeXBlQXJyYXkgPSBwb3NpdGlvbi5jb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBUeXBlQXJyYXkoIGluZGljZXMgKSwgMSApO1xuXG4gICAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xuXG4gICAgICAgIHByb3BlcnR5LndpcmVmcmFtZSA9IGF0dHJpYnV0ZTtcblxuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApIHtcblxuICAgICAgICBpZiAoIGEgPiBiICkge1xuXG4gICAgICAgICAgICB2YXIgdG1wID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgYiA9IHRtcDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3QgPSBlZGdlc1sgYSBdO1xuXG4gICAgICAgIGlmICggbGlzdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBlZGdlc1sgYSBdID0gWyBiIF07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBsaXN0LmluZGV4T2YoIGIgKSA9PT0gLTEgKSB7XG5cbiAgICAgICAgICAgIGxpc3QucHVzaCggYiApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyO1xuICAgIHRoaXMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlID0gZ2V0V2lyZWZyYW1lQXR0cmlidXRlO1xuXG4gICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW0uanNcblxuVEhSRUUuV2ViR0xQcm9ncmFtID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBwcm9ncmFtSWRDb3VudCA9IDA7XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XG5cbiAgICAgICAgdmFyIGNodW5rcyA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcblxuICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmV0Y2hVbmlmb3JtTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XG5cbiAgICAgICAgdmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSwgaSApO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmZvLm5hbWU7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBVTklGT1JNOlwiLCBuYW1lKTtcblxuICAgICAgICAgICAgdmFyIHN1ZmZpeFBvcyA9IG5hbWUubGFzdEluZGV4T2YoICdbMF0nICk7XG4gICAgICAgICAgICBpZiAoIHN1ZmZpeFBvcyAhPT0gLTEgJiYgc3VmZml4UG9zID09PSBuYW1lLmxlbmd0aCAtIDMgKSB7XG5cbiAgICAgICAgICAgICAgICB1bmlmb3Jtc1sgbmFtZS5zdWJzdHIoIDAsIHN1ZmZpeFBvcyApIF0gPSBsb2NhdGlvbjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1bmlmb3Jtc1sgbmFtZSBdID0gbG9jYXRpb247XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmlmb3JtcztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYiggcHJvZ3JhbSwgaSApO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmZvLm5hbWU7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVkVSVEVYIEFUVFJJQlVURTpcIiwgbmFtZSwgaSApO1xuXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWyBuYW1lIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckVtcHR5TGluZSggc3RyaW5nICkge1xuXG4gICAgICAgIHJldHVybiBzdHJpbmcgIT09ICcnO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICAgICAgdmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnZlcnRleFNoYWRlcjtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuICAgICAgICB2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNoYWRvd01hcCApIHtcblxuICAgICAgICAgICAgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcblxuICAgICAgICAgICAgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuICAgICAgICB2YXIgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcbiAgICAgICAgdmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG5cbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcblxuICAgICAgICAgICAgc3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOlxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgICAgICAgICAgIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfRVFVSVJFQyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgICAgICAgICAgIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmNvbWJpbmUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTWl4T3BlcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkFkZE9wZXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX0FERCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ2J1aWxkaW5nIG5ldyBwcm9ncmFtICcgKTtcblxuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XG5cbiAgICAgICAgLy9cblxuICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgICAgICB2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgIHByZWZpeFZlcnRleCA9ICcnO1xuICAgICAgICAgICAgcHJlZml4RnJhZ21lbnQgPSAnJztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBwcmVmaXhWZXJ0ZXggPSBbXG5cbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXG5cbiAgICAgICAgICAgICAgICAnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5uYW1lLFxuXG4gICAgICAgICAgICAgICAgY3VzdG9tRGVmaW5lcyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmdhbW1hSW5wdXQgPyAnI2RlZmluZSBHQU1NQV9JTlBVVCcgOiAnJyxcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYU91dHB1dCA/ICcjZGVmaW5lIEdBTU1BX09VVFBVVCcgOiAnJyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxuXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXG5cbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfU0hBRE9XUyAnICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxuXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxuXG5cbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcblxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JyxcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgdXY7JyxcblxuICAgICAgICAgICAgICAgICcjaWZkZWYgVVNFX0NPTE9SJyxcblxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsXG5cbiAgICAgICAgICAgICAgICAnI2VuZGlmJyxcblxuICAgICAgICAgICAgICAgICcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXG5cbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7JyxcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7JyxcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7JyxcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JyxcblxuICAgICAgICAgICAgICAgICdcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTJyxcblxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JyxcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLFxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXG5cbiAgICAgICAgICAgICAgICAnXHQjZWxzZScsXG5cbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDsnLFxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7JyxcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NzsnLFxuXG4gICAgICAgICAgICAgICAgJ1x0I2VuZGlmJyxcblxuICAgICAgICAgICAgICAgICcjZW5kaWYnLFxuXG4gICAgICAgICAgICAgICAgJyNpZmRlZiBVU0VfU0tJTk5JTkcnLFxuXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxuXG4gICAgICAgICAgICAgICAgJyNlbmRpZicsXG5cbiAgICAgICAgICAgICAgICAnXFxuJ1xuXG4gICAgICAgICAgICBdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgICAgICAgICAgcHJlZml4RnJhZ21lbnQgPSBbXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyB8fCBtYXRlcmlhbC5kZXJpdmF0aXZlcyA/ICcjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZScgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcmVuZGVyZXIuZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcblxuICAgICAgICAgICAgICAgIGN1c3RvbURlZmluZXMsXG5cbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfRElSX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhEaXJMaWdodHMsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfSEVNSV9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4SGVtaUxpZ2h0cyxcblxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFscGhhVGVzdCA/ICcjZGVmaW5lIEFMUEhBVEVTVCAnICsgcGFyYW1ldGVycy5hbHBoYVRlc3QgOiAnJyxcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmdhbW1hSW5wdXQgPyAnI2RlZmluZSBHQU1NQV9JTlBVVCcgOiAnJyxcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYU91dHB1dCA/ICcjZGVmaW5lIEdBTU1BX09VVFBVVCcgOiAnJyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxuXG4gICAgICAgICAgICAgICAgKCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJywgKCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tZXRhbCA/ICcjZGVmaW5lIE1FVEFMJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG4gICAgICAgICAgICAgICAgJ1xcbidcblxuICAgICAgICAgICAgXS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0ZXhHbHNsID0gcHJlZml4VmVydGV4ICsgdmVydGV4U2hhZGVyO1xuICAgICAgICB2YXIgZnJhZ21lbnRHbHNsID0gcHJlZml4RnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlcjtcblxuICAgICAgICB2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBUSFJFRS5XZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcbiAgICAgICAgdmFyIGdsRnJhZ21lbnRTaGFkZXIgPSBUSFJFRS5XZWJHTFNoYWRlciggZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRHbHNsICk7XG5cbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgICAgICAvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcbiAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgICAgIHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcbiAgICAgICAgdmFyIHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsVmVydGV4U2hhZGVyICk7XG4gICAgICAgIHZhciBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgICAgICB2YXIgcnVubmFibGUgPSB0cnVlO1xuICAgICAgICB2YXIgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBydW5uYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBzaGFkZXIgZXJyb3I6ICcsIGdsLmdldEVycm9yKCksICdnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMgKSwgJ2dsLmdldFByb2dyYW1JbmZvTG9nJywgcHJvZ3JhbUxvZywgdmVydGV4TG9nLCBmcmFnbWVudExvZyApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHByb2dyYW1Mb2cgIT09ICcnICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XG5cbiAgICAgICAgICAgIGhhdmVEaWFnbm9zdGljcyA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGhhdmVEaWFnbm9zdGljcyApIHtcblxuICAgICAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IHtcblxuICAgICAgICAgICAgICAgIHJ1bm5hYmxlOiBydW5uYWJsZSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbDogbWF0ZXJpYWwsXG5cbiAgICAgICAgICAgICAgICBwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxuXG4gICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9nOiB2ZXJ0ZXhMb2csXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4VmVydGV4XG5cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IHtcblxuICAgICAgICAgICAgICAgICAgICBsb2c6IGZyYWdtZW50TG9nLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeEZyYWdtZW50XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHVwXG5cbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgICAgICAvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcblxuICAgICAgICB2YXIgY2FjaGVkVW5pZm9ybXM7XG5cbiAgICAgICAgdGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjYWNoZWRVbmlmb3JtcyA9IGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVW5pZm9ybXM7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xuXG4gICAgICAgIHZhciBjYWNoZWRBdHRyaWJ1dGVzO1xuXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZyZWUgcmVzb3VyY2VcblxuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gREVQUkVDQVRFRFxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC51bmlmb3JtcyBpcyBub3cgLmdldFVuaWZvcm1zKCkuJyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAuYXR0cmlidXRlcyBpcyBub3cgLmdldEF0dHJpYnV0ZXMoKS4nICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9ICk7XG5cblxuICAgICAgICAvL1xuXG4gICAgICAgIHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCsrO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLnVzZWRUaW1lcyA9IDE7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW1zLmpzXG5cblRIUkVFLldlYkdMUHJvZ3JhbXMgPSBmdW5jdGlvbiggcmVuZGVyZXIsIGNhcGFiaWxpdGllcyApIHtcblxuICAgIHZhciBwcm9ncmFtcyA9IFtdO1xuXG4gICAgdmFyIHNoYWRlcklEcyA9IHtcbiAgICAgICAgTWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXG4gICAgICAgIE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXG4gICAgICAgIE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgICAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG4gICAgICAgIE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxuICAgICAgICBMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICAgICAgTGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcbiAgICAgICAgUG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnXG4gICAgfTtcblxuICAgIHZhciBwYXJhbWV0ZXJOYW1lcyA9IFtcbiAgICAgICAgXCJwcmVjaXNpb25cIiwgXCJzdXBwb3J0c1ZlcnRleFRleHR1cmVzXCIsIFwibWFwXCIsIFwiZW52TWFwXCIsIFwiZW52TWFwTW9kZVwiLFxuICAgICAgICBcImxpZ2h0TWFwXCIsIFwiYW9NYXBcIiwgXCJlbWlzc2l2ZU1hcFwiLCBcImJ1bXBNYXBcIiwgXCJub3JtYWxNYXBcIiwgXCJzcGVjdWxhck1hcFwiLFxuICAgICAgICBcImFscGhhTWFwXCIsIFwiY29tYmluZVwiLCBcInZlcnRleENvbG9yc1wiLCBcImZvZ1wiLCBcInVzZUZvZ1wiLCBcImZvZ0V4cFwiLFxuICAgICAgICBcImZsYXRTaGFkaW5nXCIsIFwic2l6ZUF0dGVudWF0aW9uXCIsIFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclwiLCBcInNraW5uaW5nXCIsXG4gICAgICAgIFwibWF4Qm9uZXNcIiwgXCJ1c2VWZXJ0ZXhUZXh0dXJlXCIsIFwibW9ycGhUYXJnZXRzXCIsIFwibW9ycGhOb3JtYWxzXCIsXG4gICAgICAgIFwibWF4TW9ycGhUYXJnZXRzXCIsIFwibWF4TW9ycGhOb3JtYWxzXCIsIFwibWF4RGlyTGlnaHRzXCIsIFwibWF4UG9pbnRMaWdodHNcIixcbiAgICAgICAgXCJtYXhTcG90TGlnaHRzXCIsIFwibWF4SGVtaUxpZ2h0c1wiLCBcIm1heFNoYWRvd3NcIiwgXCJzaGFkb3dNYXBFbmFibGVkXCIsXG4gICAgICAgIFwic2hhZG93TWFwVHlwZVwiLCBcInNoYWRvd01hcERlYnVnXCIsIFwiYWxwaGFUZXN0XCIsIFwibWV0YWxcIiwgXCJkb3VibGVTaWRlZFwiLFxuICAgICAgICBcImZsaXBTaWRlZFwiXG4gICAgXTtcblxuXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVCb25lcyggb2JqZWN0ICkge1xuXG4gICAgICAgIGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIDEwMjQ7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuICAgICAgICAgICAgLy8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcbiAgICAgICAgICAgIC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xuICAgICAgICAgICAgLy8gICAgKHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxuXG4gICAgICAgICAgICB2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xuICAgICAgICAgICAgdmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcblxuICAgICAgICAgICAgdmFyIG1heEJvbmVzID0gblZlcnRleE1hdHJpY2VzO1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG4gICAgICAgICAgICAgICAgbWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWF4Qm9uZXMgPCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRvbyBtYW55IGJvbmVzIC0gJyArIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0ICcgKyBtYXhCb25lcyArICcgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSknICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1heEJvbmVzO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKSB7XG5cbiAgICAgICAgdmFyIGRpckxpZ2h0cyA9IDA7XG4gICAgICAgIHZhciBwb2ludExpZ2h0cyA9IDA7XG4gICAgICAgIHZhciBzcG90TGlnaHRzID0gMDtcbiAgICAgICAgdmFyIGhlbWlMaWdodHMgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwrKyApIHtcblxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cbiAgICAgICAgICAgIGlmICggbGlnaHQub25seVNoYWRvdyB8fCBsaWdodC52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIGRpckxpZ2h0cysrO1xuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSBwb2ludExpZ2h0cysrO1xuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHNwb3RMaWdodHMrKztcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSBoZW1pTGlnaHRzKys7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZGlyZWN0aW9uYWwnOiBkaXJMaWdodHMsXG4gICAgICAgICAgICAncG9pbnQnOiBwb2ludExpZ2h0cyxcbiAgICAgICAgICAgICdzcG90Jzogc3BvdExpZ2h0cyxcbiAgICAgICAgICAgICdoZW1pJzogaGVtaUxpZ2h0c1xuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKSB7XG5cbiAgICAgICAgdmFyIG1heFNoYWRvd3MgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwrKyApIHtcblxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cbiAgICAgICAgICAgIGlmICggIWxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIG1heFNoYWRvd3MrKztcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgbWF4U2hhZG93cysrO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF4U2hhZG93cztcblxuICAgIH1cblxuICAgIHRoaXMuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcblxuICAgICAgICB2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcbiAgICAgICAgLy8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcbiAgICAgICAgLy8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuICAgICAgICB2YXIgbWF4TGlnaHRDb3VudCA9IGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKTtcbiAgICAgICAgdmFyIG1heFNoYWRvd3MgPSBhbGxvY2F0ZVNoYWRvd3MoIGxpZ2h0cyApO1xuICAgICAgICB2YXIgbWF4Qm9uZXMgPSBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IHJlbmRlcmVyLmdldFByZWNpc2lvbigpO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcblxuICAgICAgICAgICAgaWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXIuaW5pdE1hdGVyaWFsOicsIG1hdGVyaWFsLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgcHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB7XG5cbiAgICAgICAgICAgIHNoYWRlcklEOiBzaGFkZXJJRCxcblxuICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICAgICAgICBzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBjYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXMsXG5cbiAgICAgICAgICAgIG1hcDogISFtYXRlcmlhbC5tYXAsXG4gICAgICAgICAgICBlbnZNYXA6ICEhbWF0ZXJpYWwuZW52TWFwLFxuICAgICAgICAgICAgZW52TWFwTW9kZTogbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nLFxuICAgICAgICAgICAgbGlnaHRNYXA6ICEhbWF0ZXJpYWwubGlnaHRNYXAsXG4gICAgICAgICAgICBhb01hcDogISFtYXRlcmlhbC5hb01hcCxcbiAgICAgICAgICAgIGVtaXNzaXZlTWFwOiAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwLFxuICAgICAgICAgICAgYnVtcE1hcDogISFtYXRlcmlhbC5idW1wTWFwLFxuICAgICAgICAgICAgbm9ybWFsTWFwOiAhIW1hdGVyaWFsLm5vcm1hbE1hcCxcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudE1hcDogISFtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXG4gICAgICAgICAgICBzcGVjdWxhck1hcDogISFtYXRlcmlhbC5zcGVjdWxhck1hcCxcbiAgICAgICAgICAgIGFscGhhTWFwOiAhIW1hdGVyaWFsLmFscGhhTWFwLFxuXG4gICAgICAgICAgICBjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxuXG4gICAgICAgICAgICB2ZXJ0ZXhDb2xvcnM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyxcblxuICAgICAgICAgICAgZm9nOiBmb2csXG4gICAgICAgICAgICB1c2VGb2c6IG1hdGVyaWFsLmZvZyxcbiAgICAgICAgICAgIGZvZ0V4cDogZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMixcblxuICAgICAgICAgICAgZmxhdFNoYWRpbmc6IG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nLFxuXG4gICAgICAgICAgICBzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcbiAgICAgICAgICAgIGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IHJlbmRlcmVyLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cbiAgICAgICAgICAgIHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcbiAgICAgICAgICAgIG1heEJvbmVzOiBtYXhCb25lcyxcbiAgICAgICAgICAgIHVzZVZlcnRleFRleHR1cmU6IGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUsXG5cbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0czogbWF0ZXJpYWwubW9ycGhUYXJnZXRzLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXG4gICAgICAgICAgICBtYXhNb3JwaFRhcmdldHM6IHJlbmRlcmVyLm1heE1vcnBoVGFyZ2V0cyxcbiAgICAgICAgICAgIG1heE1vcnBoTm9ybWFsczogcmVuZGVyZXIubWF4TW9ycGhOb3JtYWxzLFxuXG4gICAgICAgICAgICBtYXhEaXJMaWdodHM6IG1heExpZ2h0Q291bnQuZGlyZWN0aW9uYWwsXG4gICAgICAgICAgICBtYXhQb2ludExpZ2h0czogbWF4TGlnaHRDb3VudC5wb2ludCxcbiAgICAgICAgICAgIG1heFNwb3RMaWdodHM6IG1heExpZ2h0Q291bnQuc3BvdCxcbiAgICAgICAgICAgIG1heEhlbWlMaWdodHM6IG1heExpZ2h0Q291bnQuaGVtaSxcblxuICAgICAgICAgICAgbWF4U2hhZG93czogbWF4U2hhZG93cyxcbiAgICAgICAgICAgIHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIG1heFNoYWRvd3MgPiAwLFxuICAgICAgICAgICAgc2hhZG93TWFwVHlwZTogcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUsXG4gICAgICAgICAgICBzaGFkb3dNYXBEZWJ1ZzogcmVuZGVyZXIuc2hhZG93TWFwLmRlYnVnLFxuXG4gICAgICAgICAgICBhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcbiAgICAgICAgICAgIG1ldGFsOiBtYXRlcmlhbC5tZXRhbCxcbiAgICAgICAgICAgIGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlLFxuICAgICAgICAgICAgZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRQcm9ncmFtQ29kZSA9IGZ1bmN0aW9uKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuICAgICAgICB2YXIgY2h1bmtzID0gW107XG5cbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xuXG4gICAgICAgICAgICBjaHVua3MucHVzaCggcGFyYW1ldGVycy5zaGFkZXJJRCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gbWF0ZXJpYWwuZGVmaW5lcyApIHtcblxuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKCBuYW1lICk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHBhcmFtZXRlck5hbWVzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWVzWyBpIF07XG4gICAgICAgICAgICBjaHVua3MucHVzaCggcGFyYW1ldGVyTmFtZSApO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIHBhcmFtZXRlck5hbWUgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmFjcXVpcmVQcm9ncmFtID0gZnVuY3Rpb24oIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xuXG4gICAgICAgIHZhciBwcm9ncmFtO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuICAgICAgICBmb3IgKCB2YXIgcCA9IDAsIHBsID0gcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHArKyApIHtcblxuICAgICAgICAgICAgdmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcblxuICAgICAgICAgICAgaWYgKCBwcm9ncmFtSW5mby5jb2RlID09PSBjb2RlICkge1xuXG4gICAgICAgICAgICAgICAgcHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xuICAgICAgICAgICAgICAgICsrcHJvZ3JhbS51c2VkVGltZXM7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcHJvZ3JhbSA9IG5ldyBUSFJFRS5XZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuICAgICAgICAgICAgcHJvZ3JhbXMucHVzaCggcHJvZ3JhbSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcblxuICAgIH07XG5cbiAgICB0aGlzLnJlbGVhc2VQcm9ncmFtID0gZnVuY3Rpb24oIHByb2dyYW0gKSB7XG5cbiAgICAgICAgaWYgKCAtLXByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB1bm9yZGVyZWQgc2V0XG4gICAgICAgICAgICB2YXIgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcbiAgICAgICAgICAgIHByb2dyYW1zWyBpIF0gPSBwcm9ncmFtc1sgcHJvZ3JhbXMubGVuZ3RoIC0gMSBdO1xuICAgICAgICAgICAgcHJvZ3JhbXMucG9wKCk7XG5cbiAgICAgICAgICAgIC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXG4gICAgICAgICAgICBwcm9ncmFtLmRlc3Ryb3koKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlZCBmb3IgcmVzb3VyY2UgbW9uaXRvcmluZyAmIGVycm9yIGZlZWRiYWNrIHZpYSByZW5kZXJlci5pbmZvOlxuICAgIHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtcztcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvcGVydGllcy5qc1xuXG4vKipcbiAqIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXG4gKi9cblxuVEhSRUUuV2ViR0xQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIHZhciB1dWlkID0gb2JqZWN0LnV1aWQ7XG4gICAgICAgIHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XG5cbiAgICAgICAgaWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgbWFwID0ge307XG4gICAgICAgICAgICBwcm9wZXJ0aWVzWyB1dWlkIF0gPSBtYXA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXA7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzWyBvYmplY3QudXVpZCBdO1xuXG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBwcm9wZXJ0aWVzID0ge307XG5cbiAgICB9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkZXIuanNcblxuVEhSRUUuV2ViR0xTaGFkZXIgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGFkZExpbmVOdW1iZXJzID0gZnVuY3Rpb24oIHN0cmluZyApIHtcblxuICAgICAgICB2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oICdcXG4nICk7XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFdlYkdMU2hhZGVyKCBnbCwgdHlwZSwgc3RyaW5nICkge1xuXG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTtcblxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xuXG4gICAgICAgIGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXCd0IGNvbXBpbGUuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApICE9PSAnJyApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkZXI6IGdsLmdldFNoYWRlckluZm9Mb2coKScsIHR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6ICdmcmFnbWVudCcsIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApLCBhZGRMaW5lTnVtYmVycyggc3RyaW5nICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cbiAgICAgICAgLy8gY29uc29sZS5sb2coIHR5cGUsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcblxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuXG4gICAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRvd01hcC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldlYkdMU2hhZG93TWFwID0gZnVuY3Rpb24oIF9yZW5kZXJlciwgX2xpZ2h0cywgX29iamVjdHMgKSB7XG5cbiAgICB2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXG4gICAgICAgIF9zdGF0ZSA9IF9yZW5kZXJlci5zdGF0ZSxcbiAgICAgICAgX2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxuICAgICAgICBfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cbiAgICAgICAgX21pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIF9tYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICAgIF9tYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgICAgX3JlbmRlckxpc3QgPSBbXTtcblxuICAgIC8vIGluaXRcblxuICAgIHZhciBkZXB0aFNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkZXB0aFJHQkFcIiBdO1xuICAgIHZhciBkZXB0aFVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGVwdGhTaGFkZXIudW5pZm9ybXMgKTtcblxuICAgIHZhciBfZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgICAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlclxuICAgIH0gKTtcblxuICAgIHZhciBfZGVwdGhNYXRlcmlhbE1vcnBoID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICBtb3JwaFRhcmdldHM6IHRydWVcbiAgICB9ICk7XG5cbiAgICB2YXIgX2RlcHRoTWF0ZXJpYWxTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICBza2lubmluZzogdHJ1ZVxuICAgIH0gKTtcblxuICAgIHZhciBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgICAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICAgICAgbW9ycGhUYXJnZXRzOiB0cnVlLFxuICAgICAgICBza2lubmluZzogdHJ1ZVxuICAgIH0gKTtcblxuICAgIF9kZXB0aE1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcbiAgICBfZGVwdGhNYXRlcmlhbE1vcnBoLl9zaGFkb3dQYXNzID0gdHJ1ZTtcbiAgICBfZGVwdGhNYXRlcmlhbFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xuICAgIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcblxuICAgIC8vXG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMudHlwZSA9IFRIUkVFLlBDRlNoYWRvd01hcDtcbiAgICB0aGlzLmN1bGxGYWNlID0gVEhSRUUuQ3VsbEZhY2VGcm9udDtcblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oIHNjZW5lLCBjYW1lcmEgKSB7XG5cbiAgICAgICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcbiAgICAgICAgaWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgLy8gc2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXBcblxuICAgICAgICBfZ2wuY2xlYXJDb2xvciggMSwgMSwgMSwgMSApO1xuICAgICAgICBfc3RhdGUuZGlzYWJsZSggX2dsLkJMRU5EICk7XG5cbiAgICAgICAgX3N0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cbiAgICAgICAgaWYgKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcblxuICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF9zdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcblxuICAgICAgICAvLyByZW5kZXIgZGVwdGggbWFwXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gX2xpZ2h0c1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoICFsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICggIWxpZ2h0LnNoYWRvd01hcCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dGaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLnR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2hhZG93RmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBtaW5GaWx0ZXI6IHNoYWRvd0ZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgbWFnRmlsdGVyOiBzaGFkb3dGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsaWdodC5zaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIHBhcnMgKTtcbiAgICAgICAgICAgICAgICBsaWdodC5zaGFkb3dNYXBTaXplID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQgKTtcblxuICAgICAgICAgICAgICAgIGxpZ2h0LnNoYWRvd01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAhbGlnaHQuc2hhZG93Q2FtZXJhICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuICAgICAgICAgICAgICAgICAgICBsaWdodC5zaGFkb3dDYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUZvdiwgbGlnaHQuc2hhZG93TWFwV2lkdGggLyBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlnaHQuc2hhZG93Q2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhTGVmdCwgbGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYVRvcCwgbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tLCBsaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBsaWdodC5zaGFkb3dDYW1lcmFGYXIgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIlRIUkVFLlNoYWRvd01hcFBsdWdpbjogVW5zdXBwb3J0ZWQgbGlnaHQgdHlwZSBmb3Igc2hhZG93XCIsIGxpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NlbmUuYWRkKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcblxuICAgICAgICAgICAgICAgIGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlICYmICFsaWdodC5jYW1lcmFIZWxwZXIgKSB7XG5cbiAgICAgICAgICAgICAgICBsaWdodC5jYW1lcmFIZWxwZXIgPSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcbiAgICAgICAgICAgICAgICBzY2VuZS5hZGQoIGxpZ2h0LmNhbWVyYUhlbHBlciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaGFkb3dNYXAgPSBsaWdodC5zaGFkb3dNYXA7XG4gICAgICAgICAgICB2YXIgc2hhZG93TWF0cml4ID0gbGlnaHQuc2hhZG93TWF0cml4O1xuICAgICAgICAgICAgdmFyIHNoYWRvd0NhbWVyYSA9IGxpZ2h0LnNoYWRvd0NhbWVyYTtcblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgc2hhZG93Q2FtZXJhLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIF9tYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgc2hhZG93Q2FtZXJhLmxvb2tBdCggX21hdHJpeFBvc2l0aW9uICk7XG4gICAgICAgICAgICBzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgICAgICAgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgaWYgKCBsaWdodC5jYW1lcmFIZWxwZXIgKSBsaWdodC5jYW1lcmFIZWxwZXIudmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG4gICAgICAgICAgICBpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgKSBsaWdodC5jYW1lcmFIZWxwZXIudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgc2hhZG93IG1hdHJpeFxuXG4gICAgICAgICAgICBzaGFkb3dNYXRyaXguc2V0KFxuICAgICAgICAgICAgICAgIDAuNSwgMC4wLCAwLjAsIDAuNSxcbiAgICAgICAgICAgICAgICAwLjAsIDAuNSwgMC4wLCAwLjUsXG4gICAgICAgICAgICAgICAgMC4wLCAwLjAsIDAuNSwgMC41LFxuICAgICAgICAgICAgICAgIDAuMCwgMC4wLCAwLjAsIDEuMFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuICAgICAgICAgICAgc2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuICAgICAgICAgICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICAgICAgICAgIF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICAgICAgICAgIC8vIHJlbmRlciBzaGFkb3cgbWFwXG5cbiAgICAgICAgICAgIF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xuICAgICAgICAgICAgX3JlbmRlcmVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcblxuICAgICAgICAgICAgX3JlbmRlckxpc3QubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcHJvamVjdE9iamVjdCggc2NlbmUsIHNoYWRvd0NhbWVyYSApO1xuXG5cbiAgICAgICAgICAgIC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IF9yZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gX3JlbmRlckxpc3RbIGogXTtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgaysrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGsgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxzWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBfbGlnaHRzLCBudWxsLCBnZW9tZXRyeSwgZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBncm91cE1hdGVyaWFsICksIG9iamVjdCwgZ3JvdXAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIG51bGwsIGdlb21ldHJ5LCBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsICksIG9iamVjdCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgR0wgc3RhdGVcblxuICAgICAgICB2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXG4gICAgICAgICAgICBjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcblxuICAgICAgICBfcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xuICAgICAgICBfc3RhdGUuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblxuICAgICAgICBpZiAoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG4gICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuICAgICAgICBzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICAgIHZhciB1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcbiAgICAgICAgdmFyIHVzZVNraW5uaW5nID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWwuc2tpbm5pbmc7XG5cbiAgICAgICAgdmFyIGRlcHRoTWF0ZXJpYWw7XG5cbiAgICAgICAgaWYgKCBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHVzZVNraW5uaW5nICkge1xuXG4gICAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdXNlTW9ycGhpbmcgPyBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA6IF9kZXB0aE1hdGVyaWFsU2tpbjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB1c2VNb3JwaGluZyApIHtcblxuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsTW9ycGg7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsO1xuXG4gICAgICAgIH1cblxuICAgICAgICBkZXB0aE1hdGVyaWFsLnZpc2libGUgPSBtYXRlcmlhbC52aXNpYmxlO1xuICAgICAgICBkZXB0aE1hdGVyaWFsLndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcbiAgICAgICAgZGVwdGhNYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIGRlcHRoTWF0ZXJpYWw7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcblxuICAgICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgICAgICBfcmVuZGVyTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFN0YXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTFN0YXRlID0gZnVuY3Rpb24oIGdsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xuICAgIHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xuXG4gICAgdmFyIGNhcGFiaWxpdGllcyA9IHt9O1xuXG4gICAgdmFyIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cbiAgICB2YXIgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuICAgIHZhciBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cbiAgICB2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcblxuICAgIHZhciBjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XG5cbiAgICB2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cbiAgICB2YXIgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cbiAgICB2YXIgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xuICAgIHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcblxuICAgIHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblxuICAgIHZhciBjdXJyZW50VGV4dHVyZVNsb3QgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBnbC5jbGVhckNvbG9yKCAwLCAwLCAwLCAxICk7XG4gICAgICAgIGdsLmNsZWFyRGVwdGgoIDEgKTtcbiAgICAgICAgZ2wuY2xlYXJTdGVuY2lsKCAwICk7XG5cbiAgICAgICAgdGhpcy5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcbiAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuICAgICAgICBnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuICAgICAgICBnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xuICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBuZXdBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLmVuYWJsZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgbmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG4gICAgICAgIGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XG4gICAgICAgICAgICBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gIT09IG5ld0F0dHJpYnV0ZXNbIGkgXSApIHtcblxuICAgICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuICAgICAgICAgICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24oIGlkICkge1xuXG4gICAgICAgIGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xuXG4gICAgICAgICAgICBnbC5lbmFibGUoIGlkICk7XG4gICAgICAgICAgICBjYXBhYmlsaXRpZXNbIGlkIF0gPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbiggaWQgKSB7XG5cbiAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBnbC5kaXNhYmxlKCBpZCApO1xuICAgICAgICAgICAgY2FwYWJpbGl0aWVzWyBpZCBdID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBmb3JtYXRzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyApO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMucHVzaCggZm9ybWF0c1sgaSBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cztcblxuICAgIH07XG5cbiAgICB0aGlzLnNldEJsZW5kaW5nID0gZnVuY3Rpb24oIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSApIHtcblxuICAgICAgICBpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgKSB7XG5cbiAgICAgICAgICAgIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk5vQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cblxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTXVsdGlwbHlCbGVuZGluZyApIHtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgICAgIGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuICAgICAgICAgICAgYmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG4gICAgICAgICAgICBibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcblxuICAgICAgICAgICAgaWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uQWxwaGEgKSApO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdCApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmNBbHBoYSApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3RBbHBoYSApICk7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGE7XG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG4gICAgICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXREZXB0aEZ1bmMgPSBmdW5jdGlvbiggZGVwdGhGdW5jICkge1xuXG4gICAgICAgIGlmICggY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jICkge1xuXG4gICAgICAgICAgICBpZiAoIGRlcHRoRnVuYyApIHtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk5ldmVyRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQWx3YXlzRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkxlc3NEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkxlc3NFcXVhbERlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5FcXVhbERlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkdyZWF0ZXJFcXVhbERlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkdFUVVBTCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5HcmVhdGVyRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5Ob3RFcXVhbERlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiggZGVwdGhUZXN0ICkge1xuXG4gICAgICAgIGlmICggZGVwdGhUZXN0ICkge1xuXG4gICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldERlcHRoV3JpdGUgPSBmdW5jdGlvbiggZGVwdGhXcml0ZSApIHtcblxuICAgICAgICBpZiAoIGN1cnJlbnREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xuXG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcbiAgICAgICAgICAgIGN1cnJlbnREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRDb2xvcldyaXRlID0gZnVuY3Rpb24oIGNvbG9yV3JpdGUgKSB7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50Q29sb3JXcml0ZSAhPT0gY29sb3JXcml0ZSApIHtcblxuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlICk7XG4gICAgICAgICAgICBjdXJyZW50Q29sb3JXcml0ZSA9IGNvbG9yV3JpdGU7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0RmxpcFNpZGVkID0gZnVuY3Rpb24oIGZsaXBTaWRlZCApIHtcblxuICAgICAgICBpZiAoIGN1cnJlbnRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcblxuICAgICAgICAgICAgaWYgKCBmbGlwU2lkZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC5mcm9udEZhY2UoIGdsLkNXICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZ2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uKCB3aWR0aCApIHtcblxuICAgICAgICBpZiAoIHdpZHRoICE9PSBjdXJyZW50TGluZVdpZHRoICkge1xuXG4gICAgICAgICAgICBnbC5saW5lV2lkdGgoIHdpZHRoICk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRQb2x5Z29uT2Zmc2V0ID0gZnVuY3Rpb24oIHBvbHlnb25PZmZzZXQsIGZhY3RvciwgdW5pdHMgKSB7XG5cbiAgICAgICAgaWYgKCBwb2x5Z29uT2Zmc2V0ICkge1xuXG4gICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHBvbHlnb25PZmZzZXQgJiYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkgKSB7XG5cbiAgICAgICAgICAgIGdsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcblxuICAgICAgICAgICAgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG4gICAgICAgICAgICBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiggc2Npc3NvclRlc3QgKSB7XG5cbiAgICAgICAgaWYgKCBzY2lzc29yVGVzdCApIHtcblxuICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIHRleHR1cmVcblxuICAgIHRoaXMuYWN0aXZlVGV4dHVyZSA9IGZ1bmN0aW9uKCB3ZWJnbFNsb3QgKSB7XG5cbiAgICAgICAgaWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xuXG4gICAgICAgIGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XG5cbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApO1xuICAgICAgICAgICAgY3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuYmluZFRleHR1cmUgPSBmdW5jdGlvbiggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgX3RoaXMuYWN0aXZlVGV4dHVyZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdO1xuXG4gICAgICAgIGlmICggYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGJvdW5kVGV4dHVyZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdID0gYm91bmRUZXh0dXJlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgICAgICAgIGJvdW5kVGV4dHVyZS50eXBlID0gd2ViZ2xUeXBlO1xuICAgICAgICAgICAgYm91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuY29tcHJlc3NlZFRleEltYWdlMkQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKCBlcnJvciApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy50ZXhJbWFnZTJEID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKCBlcnJvciApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy9cblxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG4gICAgICAgICAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY2FwYWJpbGl0aWVzID0ge307XG5cbiAgICAgICAgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcblxuICAgICAgICBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXG4gICAgICAgIGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcbiAgICAgICAgY3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xuXG4gICAgICAgIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuXG4gICAgfTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvTGVuc0ZsYXJlUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlUGx1Z2luID0gZnVuY3Rpb24oIHJlbmRlcmVyLCBmbGFyZXMgKSB7XG5cbiAgICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuICAgIHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXG4gICAgdmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcbiAgICB2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG4gICAgdmFyIGhhc1ZlcnRleFRleHR1cmU7XG5cbiAgICB2YXIgdGVtcFRleHR1cmUsIG9jY2x1c2lvblRleHR1cmU7XG5cbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgLTEsIC0xLCAwLCAwLFxuICAgICAgICAgICAgMSwgLTEsIDEsIDAsXG4gICAgICAgICAgICAxLCAxLCAxLCAxLCAtMSwgMSwgMCwgMVxuICAgICAgICBdICk7XG5cbiAgICAgICAgdmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG4gICAgICAgICAgICAwLCAxLCAyLFxuICAgICAgICAgICAgMCwgMiwgM1xuICAgICAgICBdICk7XG5cbiAgICAgICAgLy8gYnVmZmVyc1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuICAgICAgICBnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICAgICAgLy8gdGV4dHVyZXNcblxuICAgICAgICB0ZW1wVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgb2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCAxNiwgMTYsIDAsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuICAgICAgICBoYXNWZXJ0ZXhUZXh0dXJlID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKSA+IDA7XG5cbiAgICAgICAgdmFyIHNoYWRlcjtcblxuICAgICAgICBpZiAoIGhhc1ZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIHNoYWRlciA9IHtcblxuICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2VVYgPSB1djtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHBpbmsgc3F1YXJlXG5cbiAgICAgICAgICAgICAgICAgICAgXCJpZiggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZVxuXG4gICAgICAgICAgICAgICAgICAgIFwifSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhcmVcblxuICAgICAgICAgICAgICAgICAgICBcIn0gZWxzZSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgc2hhZGVyID0ge1xuXG4gICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2VVYgPSB1djtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgICAgICAgICAvLyBwaW5rIHNxdWFyZVxuXG4gICAgICAgICAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCggbWFwLCB2VVYgKS5yZ2IsIDAuMCApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmVcblxuICAgICAgICAgICAgICAgICAgICBcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXJlXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9IGVsc2Uge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZmxvYXQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICkuYTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICkuYTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2aXNpYmlsaXR5O1wiLFxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgICAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oIHNoYWRlciApO1xuXG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICB2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBcInBvc2l0aW9uXCIgKSxcbiAgICAgICAgICAgIHV2OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgXCJ1dlwiIClcbiAgICAgICAgfTtcblxuICAgICAgICB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIHJlbmRlclR5cGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcbiAgICAgICAgICAgIG1hcDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm1hcFwiICksXG4gICAgICAgICAgICBvY2NsdXNpb25NYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvY2NsdXNpb25NYXBcIiApLFxuICAgICAgICAgICAgb3BhY2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9wYWNpdHlcIiApLFxuICAgICAgICAgICAgY29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJjb2xvclwiICksXG4gICAgICAgICAgICBzY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicm90YXRpb25cIiApLFxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY3JlZW5Qb3NpdGlvblwiIClcbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFJlbmRlciBsZW5zIGZsYXJlc1xuICAgICAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXG4gICAgICogICAgICAgICByZWFkcyB0aGVzZSBiYWNrIGFuZCBjYWxjdWxhdGVzIG9jY2x1c2lvbi5cbiAgICAgKi9cblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0ICkge1xuXG4gICAgICAgIGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuICAgICAgICB2YXIgdGVtcFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2YXIgaW52QXNwZWN0ID0gdmlld3BvcnRIZWlnaHQgLyB2aWV3cG9ydFdpZHRoLFxuICAgICAgICAgICAgaGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoICogMC41LFxuICAgICAgICAgICAgaGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgKiAwLjU7XG5cbiAgICAgICAgdmFyIHNpemUgPSAxNiAvIHZpZXdwb3J0SGVpZ2h0LFxuICAgICAgICAgICAgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG4gICAgICAgIHZhciBzY3JlZW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAwICksXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGluaXQoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy52ZXJ0ZXggKTtcbiAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG4gICAgICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcbiAgICAgICAgLy8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMSApO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG4gICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuICAgICAgICBnbC5kZXB0aE1hc2soIGZhbHNlICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQ7XG4gICAgICAgICAgICBzY2FsZS5zZXQoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcblxuICAgICAgICAgICAgLy8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXG5cbiAgICAgICAgICAgIHZhciBmbGFyZSA9IGZsYXJlc1sgaSBdO1xuXG4gICAgICAgICAgICB0ZW1wUG9zaXRpb24uc2V0KCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTIgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEzIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxNCBdICk7XG5cbiAgICAgICAgICAgIHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICAgICAgICAgIHRlbXBQb3NpdGlvbi5hcHBseVByb2plY3Rpb24oIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICAgICAgICAgIC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcblxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XG5cbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPSBzY3JlZW5Qb3NpdGlvbi54ICogaGFsZlZpZXdwb3J0V2lkdGggKyBoYWxmVmlld3BvcnRXaWR0aDtcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPSBzY3JlZW5Qb3NpdGlvbi55ICogaGFsZlZpZXdwb3J0SGVpZ2h0ICsgaGFsZlZpZXdwb3J0SGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBzY3JlZW4gY3VsbFxuXG4gICAgICAgICAgICBpZiAoIGhhc1ZlcnRleFRleHR1cmUgfHwgKFxuICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPiAwICYmXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0V2lkdGggJiZcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55ID4gMCAmJlxuICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPCB2aWV3cG9ydEhlaWdodCApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuICAgICAgICAgICAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XG5cblxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBwaW5rIHF1YWRcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMCApO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlKCBnbC5CTEVORCApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVzdWx0IHRvIG9jY2x1c2lvbk1hcFxuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuICAgICAgICAgICAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSAtIDgsIDE2LCAxNiwgMCApO1xuXG5cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGdyYXBoaWNzXG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb2JqZWN0IHBvc2l0aW9uc1xuXG4gICAgICAgICAgICAgICAgZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKTtcblxuICAgICAgICAgICAgICAgIGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGZsYXJlc1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZsYXJlLmxlbnNGbGFyZXMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueCA9IHNwcml0ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueiA9IHNwcml0ZS56O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZS55ID0gc2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgc3ByaXRlLnJvdGF0aW9uICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgc3ByaXRlLm9wYWNpdHkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIHNwcml0ZS5ibGVuZGluZywgc3ByaXRlLmJsZW5kRXF1YXRpb24sIHNwcml0ZS5ibGVuZFNyYywgc3ByaXRlLmJsZW5kRHN0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCBzcHJpdGUudGV4dHVyZSwgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSBnbFxuXG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuICAgICAgICBnbC5kZXB0aE1hc2soIHRydWUgKTtcblxuICAgICAgICByZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKSB7XG5cbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuXG4gICAgICAgIHZhciBwcmVmaXggPSBcInByZWNpc2lvbiBcIiArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgXCIgZmxvYXQ7XFxuXCI7XG5cbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIudmVydGV4U2hhZGVyICk7XG5cbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL1Nwcml0ZVBsdWdpbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwcml0ZVBsdWdpbiA9IGZ1bmN0aW9uKCByZW5kZXJlciwgc3ByaXRlcyApIHtcblxuICAgIHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG4gICAgdmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cbiAgICB2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuICAgIHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcblxuICAgIHZhciB0ZXh0dXJlO1xuXG4gICAgLy8gZGVjb21wb3NlIG1hdHJpeFdvcmxkXG5cbiAgICB2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBzcHJpdGVSb3RhdGlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgdmFyIHNwcml0ZVNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtMC41LCAtMC41LCAwLCAwLFxuICAgICAgICAgICAgMC41LCAtMC41LCAxLCAwLFxuICAgICAgICAgICAgMC41LCAwLjUsIDEsIDEsIC0wLjUsIDAuNSwgMCwgMVxuICAgICAgICBdICk7XG5cbiAgICAgICAgdmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG4gICAgICAgICAgICAwLCAxLCAyLFxuICAgICAgICAgICAgMCwgMiwgM1xuICAgICAgICBdICk7XG5cbiAgICAgICAgdmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgICAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICdwb3NpdGlvbicgKSxcbiAgICAgICAgICAgIHV2OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgJ3V2JyApXG4gICAgICAgIH07XG5cbiAgICAgICAgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgICB1dk9mZnNldDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXG4gICAgICAgICAgICB1dlNjYWxlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dlNjYWxlJyApLFxuXG4gICAgICAgICAgICByb3RhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXG4gICAgICAgICAgICBzY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXG5cbiAgICAgICAgICAgIGNvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcbiAgICAgICAgICAgIG1hcDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxuICAgICAgICAgICAgb3BhY2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcblxuICAgICAgICAgICAgbW9kZWxWaWV3TWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXG4gICAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxuXG4gICAgICAgICAgICBmb2dUeXBlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxuICAgICAgICAgICAgZm9nRGVuc2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcbiAgICAgICAgICAgIGZvZ05lYXI6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ05lYXInICksXG4gICAgICAgICAgICBmb2dGYXI6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcbiAgICAgICAgICAgIGZvZ0NvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcblxuICAgICAgICAgICAgYWxwaGFUZXN0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdhbHBoYVRlc3QnIClcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gODtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDg7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIDgsIDggKTtcblxuICAgICAgICB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xuICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH07XG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCBzY2VuZSwgY2FtZXJhICkge1xuXG4gICAgICAgIGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cbiAgICAgICAgLy8gc2V0dXAgZ2xcblxuICAgICAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICAgICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG4gICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuICAgICAgICBzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xuXG4gICAgICAgIHZhciBvbGRGb2dUeXBlID0gMDtcbiAgICAgICAgdmFyIHNjZW5lRm9nVHlwZSA9IDA7XG4gICAgICAgIHZhciBmb2cgPSBzY2VuZS5mb2c7XG5cbiAgICAgICAgaWYgKCBmb2cgKSB7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuZm9nQ29sb3IsIGZvZy5jb2xvci5yLCBmb2cuY29sb3IuZywgZm9nLmNvbG9yLmIgKTtcblxuICAgICAgICAgICAgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ05lYXIsIGZvZy5uZWFyICk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xuICAgICAgICAgICAgICAgIG9sZEZvZ1R5cGUgPSAxO1xuICAgICAgICAgICAgICAgIHNjZW5lRm9nVHlwZSA9IDE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XG4gICAgICAgICAgICAgICAgb2xkRm9nVHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgc2NlbmVGb2dUeXBlID0gMjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xuICAgICAgICAgICAgb2xkRm9nVHlwZSA9IDA7XG4gICAgICAgICAgICBzY2VuZUZvZ1R5cGUgPSAwO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuICAgICAgICAgICAgc3ByaXRlLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIHNwcml0ZS56ID0gLXNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHNwcml0ZXMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblxuICAgICAgICAvLyByZW5kZXIgYWxsIHNwcml0ZXNcblxuICAgICAgICB2YXIgc2NhbGUgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICAgICAgICBzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XG5cbiAgICAgICAgICAgIHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xuICAgICAgICAgICAgc2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XG5cbiAgICAgICAgICAgIHZhciBmb2dUeXBlID0gMDtcblxuICAgICAgICAgICAgaWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG4gICAgICAgICAgICAgICAgZm9nVHlwZSA9IHNjZW5lRm9nVHlwZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcbiAgICAgICAgICAgICAgICBvbGRGb2dUeXBlID0gZm9nVHlwZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIG1hdGVyaWFsLm1hcC5vZmZzZXQueCwgbWF0ZXJpYWwubWFwLm9mZnNldC55ICk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIDAsIDAgKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xuXG4gICAgICAgICAgICBzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xuICAgICAgICAgICAgc3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcbiAgICAgICAgICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoIG1hdGVyaWFsLm1hcCwgMCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoIHRleHR1cmUsIDAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSBnbFxuXG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICAgICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSgpIHtcblxuICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG5cbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIFtcblxuICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHNjYWxlOycsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHV2T2Zmc2V0OycsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcblxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgdXY7JyxcblxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VVY7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuXG4gICAgICAgICAgICAndlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcblxuICAgICAgICAgICAgJ3ZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTsnLFxuXG4gICAgICAgICAgICAndmVjMiByb3RhdGVkUG9zaXRpb247JyxcbiAgICAgICAgICAgICdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcbiAgICAgICAgICAgICdyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcblxuICAgICAgICAgICAgJ3ZlYzQgZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgICAgICAgICAnZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXG4gICAgICAgICAgICAnZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247JyxcbiAgICAgICAgICAgICdmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcblxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgICAgICAgICAnfSdcblxuICAgICAgICBdLmpvaW4oICdcXG4nICkgKTtcblxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBbXG5cbiAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNvbG9yOycsXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgbWFwOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIGludCBmb2dUeXBlOycsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBmb2dOZWFyOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBmb2dGYXI7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG5cbiAgICAgICAgICAgICd2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcblxuICAgICAgICAgICAgJ2lmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxuXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IgKiB0ZXh0dXJlLnh5eiwgdGV4dHVyZS5hICogb3BhY2l0eSApOycsXG5cbiAgICAgICAgICAgICdpZiAoIGZvZ1R5cGUgPiAwICkgeycsXG5cbiAgICAgICAgICAgICdmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7JyxcbiAgICAgICAgICAgICdmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcblxuICAgICAgICAgICAgJ2lmICggZm9nVHlwZSA9PSAxICkgeycsXG5cbiAgICAgICAgICAgICdmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7JyxcblxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcblxuICAgICAgICAgICAgJ2NvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApOycsXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTsnLFxuXG4gICAgICAgICAgICAnfScsXG5cbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApOycsXG5cbiAgICAgICAgICAgICd9JyxcblxuICAgICAgICAgICAgJ30nXG5cbiAgICAgICAgXS5qb2luKCAnXFxuJyApICk7XG5cbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuICAgICAgICBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gYi56IC0gYS56O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9HZW9tZXRyeVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5HZW9tZXRyeVV0aWxzID0ge1xuXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuJyApO1xuXG4gICAgICAgIHZhciBtYXRyaXg7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeTIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICAgICAgICBnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgICAgICAgIG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XG4gICAgICAgICAgICBnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcblxuICAgIH0sXG5cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCBnZW9tZXRyeSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvSW1hZ2VVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBEYW9zaGVuZyBNdSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9EYW9zaGVuZ011L1xuICovXG5cblRIUkVFLkltYWdlVXRpbHMgPSB7XG5cbiAgICBjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxuXG4gICAgbG9hZFRleHR1cmU6IGZ1bmN0aW9uKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG4gICAgICAgIGxvYWRlci5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCBtYXBwaW5nICk7XG5cbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIGltYWdlICkge1xuXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgICB9LCB1bmRlZmluZWQsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgdGV4dHVyZS5zb3VyY2VGaWxlID0gdXJsO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gICAgfSxcblxuICAgIGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24oIGFycmF5LCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcbiAgICAgICAgbG9hZGVyLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSggaW1hZ2VzLCBtYXBwaW5nICk7XG5cbiAgICAgICAgdmFyIGxvYWRlZCA9IDA7XG5cbiAgICAgICAgdmFyIGxvYWRUZXh0dXJlID0gZnVuY3Rpb24oIGkgKSB7XG5cbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCBhcnJheVsgaSBdLCBmdW5jdGlvbiggaW1hZ2UgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlc1sgaSBdID0gaW1hZ2U7XG5cbiAgICAgICAgICAgICAgICBsb2FkZWQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArK2kgKSB7XG5cbiAgICAgICAgICAgIGxvYWRUZXh0dXJlKCBpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gICAgfSxcblxuICAgIGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nIClcblxuICAgIH0sXG5cbiAgICBsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nIClcblxuICAgIH0sXG5cbiAgICBnZXROb3JtYWxNYXA6IGZ1bmN0aW9uKCBpbWFnZSwgZGVwdGggKSB7XG5cbiAgICAgICAgLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL2xhYi9oZWlnaHRub3JtYWwvXG5cbiAgICAgICAgdmFyIGNyb3NzID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgICAgICByZXR1cm4gWyBhWyAwIF0gLSBiWyAwIF0sIGFbIDEgXSAtIGJbIDEgXSwgYVsgMiBdIC0gYlsgMiBdIF07XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24oIGEgKSB7XG5cbiAgICAgICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KCBhWyAwIF0gKiBhWyAwIF0gKyBhWyAxIF0gKiBhWyAxIF0gKyBhWyAyIF0gKiBhWyAyIF0gKTtcbiAgICAgICAgICAgIHJldHVybiBbIGFbIDAgXSAvIGwsIGFbIDEgXSAvIGwsIGFbIDIgXSAvIGwgXTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGRlcHRoID0gZGVwdGggfCAxO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCApO1xuXG4gICAgICAgIHZhciBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKS5kYXRhO1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEoIHdpZHRoLCBoZWlnaHQgKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgICAgIGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGx5ID0geSAtIDEgPCAwID8gMCA6IHkgLSAxO1xuICAgICAgICAgICAgICAgIHZhciB1eSA9IHkgKyAxID4gaGVpZ2h0IC0gMSA/IGhlaWdodCAtIDEgOiB5ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgbHggPSB4IC0gMSA8IDAgPyAwIDogeCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHV4ID0geCArIDEgPiB3aWR0aCAtIDEgPyB3aWR0aCAtIDEgOiB4ICsgMTtcblxuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gWyAwLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF07XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgLTEsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAtMSwgLTEsIGRhdGFbICggbHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgMCwgLTEsIGRhdGFbICggbHkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAxLCAtMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgMSwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggWyAwLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgLTEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBudW1fcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG51bV9wb2ludHM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdjEgPSBwb2ludHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYyID0gcG9pbnRzWyAoIGkgKyAxICkgJSBudW1fcG9pbnRzIF07XG4gICAgICAgICAgICAgICAgICAgIHYxID0gc3VidHJhY3QoIHYxLCBvcmlnaW4gKTtcbiAgICAgICAgICAgICAgICAgICAgdjIgPSBzdWJ0cmFjdCggdjIsIG9yaWdpbiApO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2goIG5vcm1hbGl6ZSggY3Jvc3MoIHYxLCB2MiApICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBbIDAsIDAsIDAgXTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsWyAwIF0gKz0gbm9ybWFsc1sgaSBdWyAwIF07XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFsgMSBdICs9IG5vcm1hbHNbIGkgXVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxbIDIgXSArPSBub3JtYWxzWyBpIF1bIDIgXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vcm1hbFsgMCBdIC89IG5vcm1hbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vcm1hbFsgMSBdIC89IG5vcm1hbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vcm1hbFsgMiBdIC89IG5vcm1hbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9ICggeSAqIHdpZHRoICsgeCApICogNDtcblxuICAgICAgICAgICAgICAgIG91dHB1dFsgaWR4IF0gPSAoICggbm9ybWFsWyAwIF0gKyAxLjAgKSAvIDIuMCAqIDI1NSApIHwgMDtcbiAgICAgICAgICAgICAgICBvdXRwdXRbIGlkeCArIDEgXSA9ICggKCBub3JtYWxbIDEgXSArIDEuMCApIC8gMi4wICogMjU1ICkgfCAwO1xuICAgICAgICAgICAgICAgIG91dHB1dFsgaWR4ICsgMiBdID0gKCBub3JtYWxbIDIgXSAqIDI1NSApIHwgMDtcbiAgICAgICAgICAgICAgICBvdXRwdXRbIGlkeCArIDMgXSA9IDI1NTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2VEYXRhLCAwLCAwICk7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcblxuICAgIH0sXG5cbiAgICBnZW5lcmF0ZURhdGFUZXh0dXJlOiBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgY29sb3IgKSB7XG5cbiAgICAgICAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggMyAqIHNpemUgKTtcblxuICAgICAgICB2YXIgciA9IE1hdGguZmxvb3IoIGNvbG9yLnIgKiAyNTUgKTtcbiAgICAgICAgdmFyIGcgPSBNYXRoLmZsb29yKCBjb2xvci5nICogMjU1ICk7XG4gICAgICAgIHZhciBiID0gTWF0aC5mbG9vciggY29sb3IuYiAqIDI1NSApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyApIHtcblxuICAgICAgICAgICAgZGF0YVsgaSAqIDMgXSA9IHI7XG4gICAgICAgICAgICBkYXRhWyBpICogMyArIDEgXSA9IGc7XG4gICAgICAgICAgICBkYXRhWyBpICogMyArIDIgXSA9IGI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBUSFJFRS5SR0JGb3JtYXQgKTtcbiAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9TY2VuZVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TY2VuZVV0aWxzID0ge1xuXG4gICAgY3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdDogZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgZ3JvdXAuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsc1sgaSBdICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuXG4gICAgfSxcblxuICAgIGRldGFjaDogZnVuY3Rpb24oIGNoaWxkLCBwYXJlbnQsIHNjZW5lICkge1xuXG4gICAgICAgIGNoaWxkLmFwcGx5TWF0cml4KCBwYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICAgICAgcGFyZW50LnJlbW92ZSggY2hpbGQgKTtcbiAgICAgICAgc2NlbmUuYWRkKCBjaGlsZCApO1xuXG4gICAgfSxcblxuICAgIGF0dGFjaDogZnVuY3Rpb24oIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xuXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgICBtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIGNoaWxkLmFwcGx5TWF0cml4KCBtYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgICAgICBzY2VuZS5yZW1vdmUoIGNoaWxkICk7XG4gICAgICAgIHBhcmVudC5hZGQoIGNoaWxkICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9Gb250VXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBUZXh0IG9wZXJhdGlvbnMgaW4gdGhyZWUuanMgKFNlZSBUZXh0R2VvbWV0cnkpXG4gKlxuICogSXQgdXNlcyB0ZWNobmlxdWVzIHVzZWQgaW46XG4gKlxuICpcdFRyaWFuZ3VsYXRpb24gcG9ydGVkIGZyb20gQVMzXG4gKlx0XHRTaW1wbGUgUG9seWdvbiBUcmlhbmd1bGF0aW9uXG4gKlx0XHRodHRwOi8vYWN0aW9uc25pcHBldC5jb20vP3A9MTQ2MlxuICpcbiAqIFx0QSBNZXRob2QgdG8gdHJpYW5ndWxhdGUgc2hhcGVzIHdpdGggaG9sZXNcbiAqXHRcdGh0dHA6Ly93d3cuc2FrcmkubmV0L2Jsb2cvMjAwOS8wNi8xMi9hbi1hcHByb2FjaC10by10cmlhbmd1bGF0aW5nLXBvbHlnb25zLXdpdGgtaG9sZXMvXG4gKlxuICovXG5cblRIUkVFLkZvbnRVdGlscyA9IHtcblxuICAgIGZhY2VzOiB7fSxcblxuICAgIC8vIEp1c3QgZm9yIG5vdy4gZmFjZVt3ZWlnaHRdW3N0eWxlXVxuXG4gICAgZmFjZTogJ2hlbHZldGlrZXInLFxuICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgc3R5bGU6ICdub3JtYWwnLFxuICAgIHNpemU6IDE1MCxcbiAgICBkaXZpc2lvbnM6IDEwLFxuXG4gICAgZ2V0RmFjZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXNbIHRoaXMuZmFjZS50b0xvd2VyQ2FzZSgpIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcblxuICAgICAgICB9XG4gICAgICAgIGNhdGNoICggZSApIHtcblxuICAgICAgICAgICAgdGhyb3cgXCJUaGUgZm9udCBcIiArIHRoaXMuZmFjZSArIFwiIHdpdGggXCIgKyB0aGlzLndlaWdodCArIFwiIHdlaWdodCBhbmQgXCIgKyB0aGlzLnN0eWxlICsgXCIgc3R5bGUgaXMgbWlzc2luZy5cIlxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBsb2FkRmFjZTogZnVuY3Rpb24oIGRhdGEgKSB7XG5cbiAgICAgICAgdmFyIGZhbWlseSA9IGRhdGEuZmFtaWx5TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHZhciBUaHJlZUZvbnQgPSB0aGlzO1xuXG4gICAgICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdIHx8IHt9O1xuXG4gICAgICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gfHwge307XG4gICAgICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcblxuICAgICAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICB9LFxuXG4gICAgZHJhd1RleHQ6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXG4gICAgICAgIC8vIFJlbmRlclRleHRcblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmdldEZhY2UoKSxcbiAgICAgICAgICAgIHNjYWxlID0gdGhpcy5zaXplIC8gZmFjZS5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICksXG4gICAgICAgICAgICBsZW5ndGggPSBjaGFycy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGZvbnRQYXRocyA9IFtdO1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBwYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuZXh0cmFjdEdseXBoUG9pbnRzKCBjaGFyc1sgaSBdLCBmYWNlLCBzY2FsZSwgb2Zmc2V0LCBwYXRoICk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcmV0Lm9mZnNldDtcblxuICAgICAgICAgICAgZm9udFBhdGhzLnB1c2goIHJldC5wYXRoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgd2lkdGhcblxuICAgICAgICB2YXIgd2lkdGggPSBvZmZzZXQgLyAyO1xuICAgICAgICAvL1xuICAgICAgICAvLyBmb3IgKCBwID0gMDsgcCA8IGFsbFB0cy5sZW5ndGg7IHArKyApIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gXHRhbGxQdHNbIHAgXS54IC09IHdpZHRoO1xuICAgICAgICAvL1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy92YXIgZXh0cmFjdCA9IHRoaXMuZXh0cmFjdFBvaW50cyggYWxsUHRzLCBjaGFyYWN0ZXJQdHMgKTtcbiAgICAgICAgLy9leHRyYWN0LmNvbnRvdXIgPSBhbGxQdHM7XG5cbiAgICAgICAgLy9leHRyYWN0LnBhdGhzID0gZm9udFBhdGhzO1xuICAgICAgICAvL2V4dHJhY3Qub2Zmc2V0ID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGhzOiBmb250UGF0aHMsXG4gICAgICAgICAgICBvZmZzZXQ6IHdpZHRoXG4gICAgICAgIH07XG5cbiAgICB9LFxuXG5cblxuXG4gICAgZXh0cmFjdEdseXBoUG9pbnRzOiBmdW5jdGlvbiggYywgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApIHtcblxuICAgICAgICB2YXIgcHRzID0gW107XG5cbiAgICAgICAgdmFyIGksIGkyLCBkaXZpc2lvbnMsXG4gICAgICAgICAgICBvdXRsaW5lLCBhY3Rpb24sIGxlbmd0aCxcbiAgICAgICAgICAgIHNjYWxlWCwgc2NhbGVZLFxuICAgICAgICAgICAgeCwgeSwgY3B4LCBjcHksIGNweDAsIGNweTAsIGNweDEsIGNweTEsIGNweDIsIGNweTIsXG4gICAgICAgICAgICBsYXN0ZSxcbiAgICAgICAgICAgIGdseXBoID0gZmFjZS5nbHlwaHNbIGMgXSB8fCBmYWNlLmdseXBoc1sgJz8nIF07XG5cbiAgICAgICAgaWYgKCAhZ2x5cGggKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCBnbHlwaC5vICkge1xuXG4gICAgICAgICAgICBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XG4gICAgICAgICAgICBsZW5ndGggPSBvdXRsaW5lLmxlbmd0aDtcblxuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGU7XG4gICAgICAgICAgICBzY2FsZVkgPSBzY2FsZTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW5ndGg7ICkge1xuXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gb3V0bGluZVsgaSsrIF07XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCBhY3Rpb24gKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoIGFjdGlvbiApIHtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBUb1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKCB4LCB5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBUb1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxpbmVUbyggeCwgeSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1YWRyYXRpY0N1cnZlVG9cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsYXN0ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDdWJpYyBCZXppZXIgQ3VydmVcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweDIgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweTIgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsYXN0ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2Zmc2V0OiBnbHlwaC5oYSAqIHNjYWxlLFxuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9O1xuXG4gICAgfVxuXG59O1xuXG5cblRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyA9IGZ1bmN0aW9uKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG4gICAgLy8gUGFyYW1ldGVyc1xuXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICB2YXIgc2l6ZSA9IHBhcmFtZXRlcnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaXplIDogMTAwO1xuICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgOiA0O1xuXG4gICAgdmFyIGZvbnQgPSBwYXJhbWV0ZXJzLmZvbnQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZm9udCA6ICdoZWx2ZXRpa2VyJztcbiAgICB2YXIgd2VpZ2h0ID0gcGFyYW1ldGVycy53ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2VpZ2h0IDogJ25vcm1hbCc7XG4gICAgdmFyIHN0eWxlID0gcGFyYW1ldGVycy5zdHlsZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdHlsZSA6ICdub3JtYWwnO1xuXG4gICAgVEhSRUUuRm9udFV0aWxzLnNpemUgPSBzaXplO1xuICAgIFRIUkVFLkZvbnRVdGlscy5kaXZpc2lvbnMgPSBjdXJ2ZVNlZ21lbnRzO1xuXG4gICAgVEhSRUUuRm9udFV0aWxzLmZhY2UgPSBmb250O1xuICAgIFRIUkVFLkZvbnRVdGlscy53ZWlnaHQgPSB3ZWlnaHQ7XG4gICAgVEhSRUUuRm9udFV0aWxzLnN0eWxlID0gc3R5bGU7XG5cbiAgICAvLyBHZXQgYSBGb250IGRhdGEganNvbiBvYmplY3RcblxuICAgIHZhciBkYXRhID0gVEhSRUUuRm9udFV0aWxzLmRyYXdUZXh0KCB0ZXh0ICk7XG5cbiAgICB2YXIgcGF0aHMgPSBkYXRhLnBhdGhzO1xuICAgIHZhciBzaGFwZXMgPSBbXTtcblxuICAgIGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCsrICkge1xuXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlcztcblxufTtcblxuXG4vKipcbiAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXG4gKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxuICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcbiAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcbiAqXG4gKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxuICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXG4gKlxuICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xuICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqL1xuXG5cbiggZnVuY3Rpb24oIG5hbWVzcGFjZSApIHtcblxuICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgLy8gdGFrZXMgaW4gYW4gY29udG91ciBhcnJheSBhbmQgcmV0dXJuc1xuXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiggY29udG91ciwgaW5kaWNlcyApIHtcblxuICAgICAgICB2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXG4gICAgICAgIGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB2ZXJ0cyA9IFtdLFxuICAgICAgICAgICAgdmVydEluZGljZXMgPSBbXTtcblxuICAgICAgICAvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xuXG4gICAgICAgIHZhciB1LCB2LCB3O1xuXG4gICAgICAgIGlmICggYXJlYSggY29udG91ciApID4gMC4wICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2ID0gMDsgdiA8IG47IHYrKyApIHZlcnRzWyB2IF0gPSB2O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGZvciAoIHYgPSAwOyB2IDwgbjsgdisrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudiA9IG47XG5cbiAgICAgICAgLyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xuXG4gICAgICAgIHZhciBjb3VudCA9IDIgKiBudjsgLyogZXJyb3IgZGV0ZWN0aW9uICovXG5cbiAgICAgICAgZm9yICggdiA9IG52IC0gMTsgbnYgPiAyOyApIHtcblxuICAgICAgICAgICAgLyogaWYgd2UgbG9vcCwgaXQgaXMgcHJvYmFibHkgYSBub24tc2ltcGxlIHBvbHlnb24gKi9cblxuICAgICAgICAgICAgaWYgKCAoIGNvdW50LS0gKSA8PSAwICkge1xuXG4gICAgICAgICAgICAgICAgLy8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcblxuICAgICAgICAgICAgICAgIC8vdGhyb3cgKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgd2FybmluZyBpcyBmaW5lLCBlc3BlY2lhbGx5IHBvbHlnb25zIGFyZSB0cmlhbmd1bGF0ZWQgaW4gcmV2ZXJzZS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Gb250VXRpbHM6IFdhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uISBpbiBUcmlhbmd1bGF0ZS5wcm9jZXNzKCknICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiB0aHJlZSBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBpbiBjdXJyZW50IHBvbHlnb24sIDx1LHYsdz4gKi9cblxuICAgICAgICAgICAgdSA9IHY7XG4gICAgICAgICAgICBpZiAoIG52IDw9IHUgKSB1ID0gMDsgLyogcHJldmlvdXMgKi9cbiAgICAgICAgICAgIHYgPSB1ICsgMTtcbiAgICAgICAgICAgIGlmICggbnYgPD0gdiApIHYgPSAwOyAvKiBuZXcgdiAgICAqL1xuICAgICAgICAgICAgdyA9IHYgKyAxO1xuICAgICAgICAgICAgaWYgKCBudiA8PSB3ICkgdyA9IDA7IC8qIG5leHQgICAgICovXG5cbiAgICAgICAgICAgIGlmICggc25pcCggY29udG91ciwgdSwgdiwgdywgbnYsIHZlcnRzICkgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgYywgcywgdDtcblxuICAgICAgICAgICAgICAgIC8qIHRydWUgbmFtZXMgb2YgdGhlIHZlcnRpY2VzICovXG5cbiAgICAgICAgICAgICAgICBhID0gdmVydHNbIHUgXTtcbiAgICAgICAgICAgICAgICBiID0gdmVydHNbIHYgXTtcbiAgICAgICAgICAgICAgICBjID0gdmVydHNbIHcgXTtcblxuICAgICAgICAgICAgICAgIC8qIG91dHB1dCBUcmlhbmdsZSAqL1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuICAgICAgICAgICAgICAgICAgICBjb250b3VyWyBiIF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRvdXJbIGMgXVxuICAgICAgICAgICAgICAgIF0gKTtcblxuXG4gICAgICAgICAgICAgICAgdmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuICAgICAgICAgICAgICAgIC8qIHJlbW92ZSB2IGZyb20gdGhlIHJlbWFpbmluZyBwb2x5Z29uICovXG5cbiAgICAgICAgICAgICAgICBmb3IgKCBzID0gdiwgdCA9IHYgKyAxOyB0IDwgbnY7IHMrKywgdCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnYtLTtcblxuICAgICAgICAgICAgICAgIC8qIHJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyICovXG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IDIgKiBudjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9O1xuXG4gICAgLy8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxuXG4gICAgdmFyIGFyZWEgPSBmdW5jdGlvbiggY29udG91ciApIHtcblxuICAgICAgICB2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuICAgICAgICB2YXIgYSA9IDAuMDtcblxuICAgICAgICBmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxKysgKSB7XG5cbiAgICAgICAgICAgIGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhICogMC41O1xuXG4gICAgfTtcblxuICAgIHZhciBzbmlwID0gZnVuY3Rpb24oIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xuXG4gICAgICAgIHZhciBwO1xuICAgICAgICB2YXIgYXgsIGF5LCBieCwgYnk7XG4gICAgICAgIHZhciBjeCwgY3ksIHB4LCBweTtcblxuICAgICAgICBheCA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS54O1xuICAgICAgICBheSA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS55O1xuXG4gICAgICAgIGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XG4gICAgICAgIGJ5ID0gY29udG91clsgdmVydHNbIHYgXSBdLnk7XG5cbiAgICAgICAgY3ggPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueDtcbiAgICAgICAgY3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcblxuICAgICAgICBpZiAoIEVQU0lMT04gPiAoICggKCBieCAtIGF4ICkgKiAoIGN5IC0gYXkgKSApIC0gKCAoIGJ5IC0gYXkgKSAqICggY3ggLSBheCApICkgKSApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgYVgsIGFZLCBiWCwgYlksIGNYLCBjWTtcbiAgICAgICAgdmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XG4gICAgICAgIHZhciBjQ1JPU1NhcCwgYkNST1NTY3AsIGFDUk9TU2JwO1xuXG4gICAgICAgIGFYID0gY3ggLSBieDtcbiAgICAgICAgYVkgPSBjeSAtIGJ5O1xuICAgICAgICBiWCA9IGF4IC0gY3g7XG4gICAgICAgIGJZID0gYXkgLSBjeTtcbiAgICAgICAgY1ggPSBieCAtIGF4O1xuICAgICAgICBjWSA9IGJ5IC0gYXk7XG5cbiAgICAgICAgZm9yICggcCA9IDA7IHAgPCBuOyBwKysgKSB7XG5cbiAgICAgICAgICAgIHB4ID0gY29udG91clsgdmVydHNbIHAgXSBdLng7XG4gICAgICAgICAgICBweSA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS55O1xuXG4gICAgICAgICAgICBpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcbiAgICAgICAgICAgICAgICAoICggcHggPT09IGJ4ICkgJiYgKCBweSA9PT0gYnkgKSApIHx8XG4gICAgICAgICAgICAgICAgKCAoIHB4ID09PSBjeCApICYmICggcHkgPT09IGN5ICkgKSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBhcHggPSBweCAtIGF4O1xuICAgICAgICAgICAgYXB5ID0gcHkgLSBheTtcbiAgICAgICAgICAgIGJweCA9IHB4IC0gYng7XG4gICAgICAgICAgICBicHkgPSBweSAtIGJ5O1xuICAgICAgICAgICAgY3B4ID0gcHggLSBjeDtcbiAgICAgICAgICAgIGNweSA9IHB5IC0gY3k7XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBwIGlzIGluc2lkZSB0cmlhbmdsZSBhYmNcblxuICAgICAgICAgICAgYUNST1NTYnAgPSBhWCAqIGJweSAtIGFZICogYnB4O1xuICAgICAgICAgICAgY0NST1NTYXAgPSBjWCAqIGFweSAtIGNZICogYXB4O1xuICAgICAgICAgICAgYkNST1NTY3AgPSBiWCAqIGNweSAtIGJZICogY3B4O1xuXG4gICAgICAgICAgICBpZiAoICggYUNST1NTYnAgPj0gLUVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC1FUFNJTE9OICkgJiYgKCBjQ1JPU1NhcCA+PSAtRVBTSUxPTiApICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH07XG5cblxuICAgIG5hbWVzcGFjZS5Ucmlhbmd1bGF0ZSA9IHByb2Nlc3M7XG4gICAgbmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xuXG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcblxufSApKCBUSFJFRS5Gb250VXRpbHMgKTtcblxuLy8gVG8gdXNlIHRoZSB0eXBlZmFjZS5qcyBmYWNlIGZpbGVzLCBob29rIHVwIHRoZSBBUElcblxuVEhSRUUudHlwZWZhY2VfanMgPSB7XG4gICAgZmFjZXM6IFRIUkVFLkZvbnRVdGlscy5mYWNlcyxcbiAgICBsb2FkRmFjZTogVEhSRUUuRm9udFV0aWxzLmxvYWRGYWNlXG59O1xuaWYgKCB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgKSBzZWxmLl90eXBlZmFjZV9qcyA9IFRIUkVFLnR5cGVmYWNlX2pzO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW8uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF1ZGlvID0gZnVuY3Rpb24oIGxpc3RlbmVyICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0F1ZGlvJztcblxuICAgIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgdGhpcy5zb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XG5cbiAgICB0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuICAgIHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuICAgIHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG4gICAgdGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgIHRoaXMucGxheWJhY2tSYXRlID0gMTtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvO1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCBmaWxlICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCAnR0VUJywgZmlsZSwgdHJ1ZSApO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCBlICkge1xuXG4gICAgICAgIHNjb3BlLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCB0aGlzLnJlc3BvbnNlLCBmdW5jdGlvbiggYnVmZmVyICkge1xuXG4gICAgICAgICAgICBzY29wZS5zb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmF1dG9wbGF5ICkgc2NvcGUucGxheSgpO1xuXG4gICAgICAgIH0gKTtcblxuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XG4gICAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cbiAgICBzb3VyY2UuYnVmZmVyID0gdGhpcy5zb3VyY2UuYnVmZmVyO1xuICAgIHNvdXJjZS5sb29wID0gdGhpcy5zb3VyY2UubG9vcDtcbiAgICBzb3VyY2Uub25lbmRlZCA9IHRoaXMuc291cmNlLm9uZW5kZWQ7XG4gICAgc291cmNlLnN0YXJ0KCAwLCB0aGlzLnN0YXJ0VGltZSApO1xuICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLnBsYXliYWNrUmF0ZTtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgdGhpcy5jb25uZWN0KCk7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5zb3VyY2Uuc3RvcCgpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5zb3VyY2Uuc3RvcCgpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmICggdGhpcy5maWx0ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xuICAgICAgICB0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLnBhbm5lciApO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoIHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcbiAgICAgICAgdGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLnBhbm5lciApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgdGhpcy5maWx0ZXIgPSB2YWx1ZTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgdGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcblxuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLm9uRW5kZWQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgdGhpcy5zb3VyY2UubG9vcCA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0TG9vcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmxvb3A7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0Um9sbG9mZkZhY3RvciA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFZvbHVtZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cbiAgICAgICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cbiAgICAgICAgcG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdGhpcy5wYW5uZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcblxuICAgIH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW9MaXN0ZW5lci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW9MaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gbmV3KCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG59O1xuXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpb0xpc3RlbmVyO1xuXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICB2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cbiAgICAgICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xuICAgICAgICB2YXIgdXAgPSB0aGlzLnVwO1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcblxuICAgICAgICBvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0xICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgICAgbGlzdGVuZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcbiAgICAgICAgbGlzdGVuZXIuc2V0T3JpZW50YXRpb24oIG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIHVwLngsIHVwLnksIHVwLnogKTtcblxuICAgIH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XG4gKlxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG4gKiAuZ2V0TGVuZ3RoKClcbiAqIC51cGRhdGVBcmNMZW5ndGhzKClcbiAqXG4gKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XG4gKlxuICogLS0gMmQgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuU3BsaW5lQ3VydmVcbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqXG4gKiAtLSAzZCBjbGFzc2VzIC0tXG4gKiBUSFJFRS5MaW5lQ3VydmUzXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZTNcbiAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xuICpcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmUgPSBmdW5jdGlvbigpIHtcblxufTtcblxuLy8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG4vL1x0LSB0IFswIC4uIDFdXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgY29uc29sZS53YXJuKCBcIlRIUkVFLkN1cnZlOiBXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIiApO1xuICAgIHJldHVybiBudWxsO1xuXG59O1xuXG4vLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcbi8vIC0gdSBbMCAuLiAxXVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uKCB1ICkge1xuXG4gICAgdmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcblxufTtcblxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgaWYgKCAhZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcblxuICAgIHZhciBkLCBwdHMgPSBbXTtcblxuICAgIGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCsrICkge1xuXG4gICAgICAgIHB0cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgaWYgKCAhZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcblxuICAgIHZhciBkLCBwdHMgPSBbXTtcblxuICAgIGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCsrICkge1xuXG4gICAgICAgIHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHB0cztcblxufTtcblxuLy8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcbiAgICByZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGhzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApID8gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgOiAyMDA7XG5cbiAgICBpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxICkgJiYgIXRoaXMubmVlZHNVcGRhdGUgKSB7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyggXCJjYWNoZWRcIiwgdGhpcy5jYWNoZUFyY0xlbmd0aHMgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXG4gICAgfVxuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGNhY2hlID0gW107XG4gICAgdmFyIGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XG4gICAgdmFyIHAsIHN1bSA9IDA7XG5cbiAgICBjYWNoZS5wdXNoKCAwICk7XG5cbiAgICBmb3IgKCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHArKyApIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xuICAgICAgICBzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XG4gICAgICAgIGNhY2hlLnB1c2goIHN1bSApO1xuICAgICAgICBsYXN0ID0gY3VycmVudDtcblxuICAgIH1cblxuICAgIHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XG5cbiAgICByZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG5cbn07XG5cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLnVwZGF0ZUFyY0xlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuZ2V0TGVuZ3RocygpO1xuXG59O1xuXG4vLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRVdG9UbWFwcGluZyA9IGZ1bmN0aW9uKCB1LCBkaXN0YW5jZSApIHtcblxuICAgIHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cbiAgICB2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuICAgIGlmICggZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgdGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgdGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xuXG4gICAgfVxuXG4gICAgLy92YXIgdGltZSA9IERhdGUubm93KCk7XG5cbiAgICAvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG4gICAgdmFyIGxvdyA9IDAsXG4gICAgICAgIGhpZ2ggPSBpbCAtIDEsXG4gICAgICAgIGNvbXBhcmlzb247XG5cbiAgICB3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xuXG4gICAgICAgIGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xuXG4gICAgICAgIGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XG5cbiAgICAgICAgaWYgKCBjb21wYXJpc29uIDwgMCApIHtcblxuICAgICAgICAgICAgbG93ID0gaSArIDE7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cbiAgICAgICAgICAgIGhpZ2ggPSBpIC0gMTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBoaWdoID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBET05FXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaSA9IGhpZ2g7XG5cbiAgICAvL2NvbnNvbGUubG9nKCdiJyAsIGksIGxvdywgaGlnaCwgRGF0ZS5ub3coKS0gdGltZSk7XG5cbiAgICBpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xuXG4gICAgICAgIHZhciB0ID0gaSAvICggaWwgLSAxICk7XG4gICAgICAgIHJldHVybiB0O1xuXG4gICAgfVxuXG4gICAgLy8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuICAgIHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XG4gICAgdmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcblxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG4gICAgdmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG4gICAgdmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XG5cbiAgICByZXR1cm4gdDtcblxufTtcblxuLy8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuLy8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxuLy8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcbi8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciBkZWx0YSA9IDAuMDAwMTtcbiAgICB2YXIgdDEgPSB0IC0gZGVsdGE7XG4gICAgdmFyIHQyID0gdCArIGRlbHRhO1xuXG4gICAgLy8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG4gICAgaWYgKCB0MSA8IDAgKSB0MSA9IDA7XG4gICAgaWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cbiAgICB2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcbiAgICB2YXIgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcblxuICAgIHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xuICAgIHJldHVybiB2ZWMubm9ybWFsaXplKCk7XG5cbn07XG5cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnRBdCA9IGZ1bmN0aW9uKCB1ICkge1xuXG4gICAgdmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCApO1xuXG59O1xuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFV0aWxzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlLlV0aWxzID0ge1xuXG4gICAgdGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24oIHQsIHAwLCBwMSwgcDIgKSB7XG5cbiAgICAgICAgcmV0dXJuIDIgKiAoIDEgLSB0ICkgKiAoIHAxIC0gcDAgKSArIDIgKiB0ICogKCBwMiAtIHAxICk7XG5cbiAgICB9LFxuXG4gICAgLy8gUHVheSBCaW5nLCB0aGFua3MgZm9yIGhlbHBpbmcgd2l0aCB0aGlzIGRlcml2YXRpdmUhXG5cbiAgICB0YW5nZW50Q3ViaWNCZXppZXI6IGZ1bmN0aW9uKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgICAgICByZXR1cm4gLTMgKiBwMCAqICggMSAtIHQgKSAqICggMSAtIHQgKSArXG4gICAgICAgICAgICAzICogcDEgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgLSA2ICogdCAqIHAxICogKCAxIC0gdCApICtcbiAgICAgICAgICAgIDYgKiB0ICogcDIgKiAoIDEgLSB0ICkgLSAzICogdCAqIHQgKiBwMiArXG4gICAgICAgICAgICAzICogdCAqIHQgKiBwMztcblxuICAgIH0sXG5cbiAgICB0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cbiAgICAgICAgLy8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcblxuICAgICAgICB2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7IC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxuICAgICAgICB2YXIgaDEwID0gMyAqIHQgKiB0IC0gNCAqIHQgKyAxOyAvLyB0XjMg4oiSIDJ0XjIgKyB0XG4gICAgICAgIHZhciBoMDEgPSAtNiAqIHQgKiB0ICsgNiAqIHQ7IC8vIOKIkiAydDMgKyAzdDJcbiAgICAgICAgdmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0OyAvLyB0MyDiiJIgdDJcblxuICAgICAgICByZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xuXG4gICAgfSxcblxuICAgIC8vIENhdG11bGwtUm9tXG5cbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xuXG4gICAgICAgIHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcbiAgICAgICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgICAgIHZhciB0MyA9IHQgKiB0MjtcbiAgICAgICAgcmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0zICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuICAgIH1cblxufTtcblxuXG4vLyBUT0RPOiBUcmFuc2Zvcm1hdGlvbiBmb3IgQ3VydmVzP1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHQzRCBDdXJ2ZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gQSBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGN1cnZlIHN1YmNsYXNzZXNcblxuVEhSRUUuQ3VydmUuY3JlYXRlID0gZnVuY3Rpb24oIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XG5cbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludEZ1bmM7XG5cbiAgICByZXR1cm4gY29uc3RydWN0b3I7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5jdXJ2ZXMgPSBbXTtcbiAgICB0aGlzLmJlbmRzID0gW107XG5cbiAgICB0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3VydmVQYXRoO1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKCBjdXJ2ZSApIHtcblxuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ET1xuICAgIC8vIElmIHRoZSBlbmRpbmcgb2YgY3VydmUgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgc3RhcnRpbmdcbiAgICAvLyBvciB0aGUgbmV4dCBjdXJ2ZSwgdGhlbiwgdGhpcyBpcyBub3QgYSByZWFsIHBhdGhcbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBUT0RPIFRlc3RcbiAgICAvLyBhbmQgdmVyaWZ5IGZvciB2ZWN0b3IzIChuZWVkcyB0byBpbXBsZW1lbnQgZXF1YWxzKVxuICAgIC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xuICAgIHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcblxuICAgIGlmICggIXN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xuXG4gICAgICAgIHRoaXMuY3VydmVzLnB1c2goIG5ldyBUSFJFRS5MaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcblxuICAgIH1cblxufTtcblxuLy8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXG4vLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG4vLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cbi8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cbi8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxuLy8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuLy8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgdmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBkaWZmLCBjdXJ2ZTtcblxuICAgIC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG4gICAgd2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuICAgICAgICBpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XG5cbiAgICAgICAgICAgIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG4gICAgICAgICAgICBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cbiAgICAgICAgICAgIHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcblxufTtcblxuLypcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xufTsqL1xuXG5cbi8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgVEhSRUUuQ3VydmUgZ2V0UG9pbnQoKSB3aXRoIGdldExlbmd0aCgpIGJlY2F1c2UgaW5cbi8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxuLy8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICAgIHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcblxufTtcblxuLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXG4vLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEN1cnZlTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxuXG4gICAgaWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XG5cbiAgICB9XG5cbiAgICAvLyBHZXQgbGVuZ3RoIG9mIHN1Yi1jdXJ2ZVxuICAgIC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxuXG4gICAgdmFyIGxlbmd0aHMgPSBbXSxcbiAgICAgICAgc3VtcyA9IDA7XG4gICAgdmFyIGksIGlsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcbiAgICAgICAgbGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG5cbiAgICByZXR1cm4gbGVuZ3RocztcblxufTtcblxuXG5cbi8vIFJldHVybnMgbWluIGFuZCBtYXggY29vcmRpbmF0ZXNcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XG5cbiAgICB2YXIgbWF4WCwgbWF4WSwgbWF4WjtcbiAgICB2YXIgbWluWCwgbWluWSwgbWluWjtcblxuICAgIG1heFggPSBtYXhZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIG1pblggPSBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgdmFyIHAsIGksIGlsLCBzdW07XG5cbiAgICB2YXIgdjMgPSBwb2ludHNbIDAgXSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjM7XG5cbiAgICBzdW0gPSB2MyA/IG5ldyBUSFJFRS5WZWN0b3IzKCkgOiBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgcCA9IHBvaW50c1sgaSBdO1xuXG4gICAgICAgIGlmICggcC54ID4gbWF4WCApIG1heFggPSBwLng7XG4gICAgICAgIGVsc2UgaWYgKCBwLnggPCBtaW5YICkgbWluWCA9IHAueDtcblxuICAgICAgICBpZiAoIHAueSA+IG1heFkgKSBtYXhZID0gcC55O1xuICAgICAgICBlbHNlIGlmICggcC55IDwgbWluWSApIG1pblkgPSBwLnk7XG5cbiAgICAgICAgaWYgKCB2MyApIHtcblxuICAgICAgICAgICAgaWYgKCBwLnogPiBtYXhaICkgbWF4WiA9IHAuejtcbiAgICAgICAgICAgIGVsc2UgaWYgKCBwLnogPCBtaW5aICkgbWluWiA9IHAuejtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3VtLmFkZCggcCApO1xuXG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcblxuICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICBtYXhZOiBtYXhZXG5cbiAgICB9O1xuXG4gICAgaWYgKCB2MyApIHtcblxuICAgICAgICByZXQubWF4WiA9IG1heFo7XG4gICAgICAgIHJldC5taW5aID0gbWluWjtcblxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdENyZWF0ZSBHZW9tZXRyaWVzIEhlbHBlcnNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gcGF0aCBwb2ludHMgKGZvciBMaW5lIG9yIFBvaW50cyBvYmplY3RzKVxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG59O1xuXG4vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW50IHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgdmFyIHB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHBvaW50c1sgaSBdLngsIHBvaW50c1sgaSBdLnksIHBvaW50c1sgaSBdLnogfHwgMCApICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0QmVuZCAvIFdyYXAgSGVscGVyIE1ldGhvZHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gV3JhcCBwYXRoIC8gQmVuZCBtb2RpZmllcnM/XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkV3JhcFBhdGggPSBmdW5jdGlvbiggYmVuZHBhdGggKSB7XG5cbiAgICB0aGlzLmJlbmRzLnB1c2goIGJlbmRwYXRoICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRQb2ludHMgPSBmdW5jdGlvbiggc2VnbWVudHMsIGJlbmRzICkge1xuXG4gICAgdmFyIG9sZFB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBzZWdtZW50cyApOyAvLyBnZXRQb2ludHMgZ2V0U3BhY2VkUG9pbnRzXG4gICAgdmFyIGksIGlsO1xuXG4gICAgaWYgKCAhYmVuZHMgKSB7XG5cbiAgICAgICAgYmVuZHMgPSB0aGlzLmJlbmRzO1xuXG4gICAgfVxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gYmVuZHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBvbGRQdHMgPSB0aGlzLmdldFdyYXBQb2ludHMoIG9sZFB0cywgYmVuZHNbIGkgXSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cbiAgICB2YXIgb2xkUHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIHNlZ21lbnRzICk7XG5cbiAgICB2YXIgaSwgaWw7XG5cbiAgICBpZiAoICFiZW5kcyApIHtcblxuICAgICAgICBiZW5kcyA9IHRoaXMuYmVuZHM7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBiZW5kcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIG9sZFB0cyA9IHRoaXMuZ2V0V3JhcFBvaW50cyggb2xkUHRzLCBiZW5kc1sgaSBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2xkUHRzO1xuXG59O1xuXG4vLyBUaGlzIHJldHVybnMgZ2V0UG9pbnRzKCkgYmVuZC93cmFwcGVkIGFyb3VuZCB0aGUgY29udG91ciBvZiBhIHBhdGguXG4vLyBSZWFkIGh0dHA6Ly93d3cucGxhbmV0Y2xlZ2cuY29tL3Byb2plY3RzL1dhcnBpbmdUZXh0VG9TcGxpbmVzLmh0bWxcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRXcmFwUG9pbnRzID0gZnVuY3Rpb24oIG9sZFB0cywgcGF0aCApIHtcblxuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICB2YXIgaSwgaWwsIHAsIG9sZFgsIG9sZFksIHhOb3JtO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gb2xkUHRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgcCA9IG9sZFB0c1sgaSBdO1xuXG4gICAgICAgIG9sZFggPSBwLng7XG4gICAgICAgIG9sZFkgPSBwLnk7XG5cbiAgICAgICAgeE5vcm0gPSBvbGRYIC8gYm91bmRzLm1heFg7XG5cbiAgICAgICAgLy8gSWYgdXNpbmcgYWN0dWFsIGRpc3RhbmNlLCBmb3IgbGVuZ3RoID4gcGF0aCwgcmVxdWlyZXMgbGluZSBleHRydXNpb25zXG4gICAgICAgIC8veE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKHhOb3JtLCBvbGRYKTsgLy8gMyBzdHlsZXMuIDEpIHdyYXAgc3RyZXRjaGVkLiAyKSB3cmFwIHN0cmV0Y2ggYnkgYXJjIGxlbmd0aCAzKSB3YXJwIGJ5IGFjdHVhbCBkaXN0YW5jZVxuXG4gICAgICAgIHhOb3JtID0gcGF0aC5nZXRVdG9UbWFwcGluZyggeE5vcm0sIG9sZFggKTtcblxuICAgICAgICAvLyBjaGVjayBmb3Igb3V0IG9mIGJvdW5kcz9cblxuICAgICAgICB2YXIgcGF0aFB0ID0gcGF0aC5nZXRQb2ludCggeE5vcm0gKTtcbiAgICAgICAgdmFyIG5vcm1hbCA9IHBhdGguZ2V0VGFuZ2VudCggeE5vcm0gKTtcbiAgICAgICAgbm9ybWFsLnNldCggLW5vcm1hbC55LCBub3JtYWwueCApLm11bHRpcGx5U2NhbGFyKCBvbGRZICk7XG5cbiAgICAgICAgcC54ID0gcGF0aFB0LnggKyBub3JtYWwueDtcbiAgICAgICAgcC55ID0gcGF0aFB0LnkgKyBub3JtYWwueTtcblxuICAgIH1cblxuICAgIHJldHVybiBvbGRQdHM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1BhdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cbiAqXG4gKiovXG5cblRIUkVFLlBhdGggPSBmdW5jdGlvbiggcG9pbnRzICkge1xuXG4gICAgVEhSRUUuQ3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKCBwb2ludHMgKSB7XG5cbiAgICAgICAgdGhpcy5mcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlICk7XG5USFJFRS5QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhdGg7XG5cblRIUkVFLlBhdGhBY3Rpb25zID0ge1xuXG4gICAgTU9WRV9UTzogJ21vdmVUbycsXG4gICAgTElORV9UTzogJ2xpbmVUbycsXG4gICAgUVVBRFJBVElDX0NVUlZFX1RPOiAncXVhZHJhdGljQ3VydmVUbycsIC8vIEJlemllciBxdWFkcmF0aWMgY3VydmVcbiAgICBCRVpJRVJfQ1VSVkVfVE86ICdiZXppZXJDdXJ2ZVRvJywgLy8gQmV6aWVyIGN1YmljIGN1cnZlXG4gICAgQ1NQTElORV9USFJVOiAnc3BsaW5lVGhydScsIC8vIENhdG11bGwtUm9tIHNwbGluZVxuICAgIEFSQzogJ2FyYycsIC8vIENpcmNsZVxuICAgIEVMTElQU0U6ICdlbGxpcHNlJ1xufTtcblxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxuXG4vLyBDcmVhdGUgcGF0aCB1c2luZyBzdHJhaWdodCBsaW5lcyB0byBjb25uZWN0IGFsbCBwb2ludHNcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24oIHZlY3RvcnMgKSB7XG5cbiAgICB0aGlzLm1vdmVUbyggdmVjdG9yc1sgMCBdLngsIHZlY3RvcnNbIDAgXS55ICk7XG5cbiAgICBmb3IgKCB2YXIgdiA9IDEsIHZsZW4gPSB2ZWN0b3JzLmxlbmd0aDsgdiA8IHZsZW47IHYrKyApIHtcblxuICAgICAgICB0aGlzLmxpbmVUbyggdmVjdG9yc1sgdiBdLngsIHZlY3RvcnNbIHYgXS55ICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIHN0YXJ0UGF0aCgpIGVuZFBhdGgoKT9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oIHgsIHkgKSB7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcbiAgICB0aGlzLmFjdGlvbnMucHVzaCgge1xuICAgICAgICBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLk1PVkVfVE8sXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5MaW5lQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSwgbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKSApO1xuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICB0aGlzLmFjdGlvbnMucHVzaCgge1xuICAgICAgICBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE8sXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHtcbiAgICAgICAgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5RVUFEUkFUSUNfQ1VSVkVfVE8sXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiggYUNQMXgsIGFDUDF5LFxuICAgIGFDUDJ4LCBhQ1AyeSxcbiAgICBhWCwgYVkgKSB7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICB0aGlzLmFjdGlvbnMucHVzaCgge1xuICAgICAgICBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkJFWklFUl9DVVJWRV9UTyxcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuICAgIC8vLS0tXG4gICAgdmFyIG5wdHMgPSBbIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSBdO1xuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBucHRzLCBwdHMgKTtcblxuICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICB0aGlzLmFjdGlvbnMucHVzaCgge1xuICAgICAgICBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVSxcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0gKTtcblxufTtcblxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24oIGFYLCBhWSwgYVJhZGl1cyxcbiAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gICAgdGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXG4gICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzYXJjID0gZnVuY3Rpb24oIGFYLCBhWSwgYVJhZGl1cyxcbiAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gICAgdGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gICAgdGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxufTtcblxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNlbGxpcHNlID0gZnVuY3Rpb24oIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cbiAgICB2YXIgYXJncyA9IFtcbiAgICAgICAgYVgsIGFZLFxuICAgICAgICB4UmFkaXVzLCB5UmFkaXVzLFxuICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLFxuICAgICAgICBhQ2xvY2t3aXNlLFxuICAgICAgICBhUm90YXRpb24gfHwgMCAvLyBhUm90YXRpb24gaXMgb3B0aW9uYWwuXG4gICAgXTtcbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICB2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcbiAgICBhcmdzLnB1c2goIGxhc3RQb2ludC54ICk7XG4gICAgYXJncy5wdXNoKCBsYXN0UG9pbnQueSApO1xuXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHtcbiAgICAgICAgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xuXG4gICAgaWYgKCAhZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkrKyApIHtcblxuICAgICAgICBwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XG5cbiAgICAgICAgLy9pZiggIXRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApIHRocm93IFwiRElFXCI7XG5cbiAgICB9XG5cbiAgICAvLyBpZiAoIGNsb3NlZFBhdGggKSB7XG4gICAgLy9cbiAgICAvLyBcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuICAgIC8vXG4gICAgLy8gfVxuXG4gICAgcmV0dXJuIHBvaW50cztcblxufTtcblxuLyogUmV0dXJuIGFuIGFycmF5IG9mIHZlY3RvcnMgYmFzZWQgb24gY29udG91ciBvZiB0aGUgcGF0aCAqL1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xuXG4gICAgaWYgKCB0aGlzLnVzZVNwYWNlZFBvaW50cyApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApO1xuXG4gICAgfVxuXG4gICAgZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEyO1xuXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgdmFyIGksIGlsLCBpdGVtLCBhY3Rpb24sIGFyZ3M7XG4gICAgdmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxuICAgICAgICBsYXN0ZSwgaixcbiAgICAgICAgdCwgdHgsIHR5O1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgaXRlbSA9IHRoaXMuYWN0aW9uc1sgaSBdO1xuXG4gICAgICAgIGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuICAgICAgICBhcmdzID0gaXRlbS5hcmdzO1xuXG4gICAgICAgIHN3aXRjaCAoIGFjdGlvbiApIHtcblxuICAgICAgICAgICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPOlxuXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxuXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5RVUFEUkFUSUNfQ1VSVkVfVE86XG5cbiAgICAgICAgICAgICAgICBjcHggPSBhcmdzWyAyIF07XG4gICAgICAgICAgICAgICAgY3B5ID0gYXJnc1sgMyBdO1xuXG4gICAgICAgICAgICAgICAgY3B4MSA9IGFyZ3NbIDAgXTtcbiAgICAgICAgICAgICAgICBjcHkxID0gYXJnc1sgMSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuICAgICAgICAgICAgICAgICAgICBjcHgwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ID0gaiAvIGRpdmlzaW9ucztcblxuICAgICAgICAgICAgICAgICAgICB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPOlxuXG4gICAgICAgICAgICAgICAgY3B4ID0gYXJnc1sgNCBdO1xuICAgICAgICAgICAgICAgIGNweSA9IGFyZ3NbIDUgXTtcblxuICAgICAgICAgICAgICAgIGNweDEgPSBhcmdzWyAwIF07XG4gICAgICAgICAgICAgICAgY3B5MSA9IGFyZ3NbIDEgXTtcblxuICAgICAgICAgICAgICAgIGNweDIgPSBhcmdzWyAyIF07XG4gICAgICAgICAgICAgICAgY3B5MiA9IGFyZ3NbIDMgXTtcblxuICAgICAgICAgICAgICAgIGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ID0gaiAvIGRpdmlzaW9ucztcblxuICAgICAgICAgICAgICAgICAgICB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVOlxuXG4gICAgICAgICAgICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF0sIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF0gKTtcbiAgICAgICAgICAgICAgICB2YXIgc3B0cyA9IFsgbGFzdCBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBkaXZpc2lvbnMgKiBhcmdzWyAwIF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgc3B0cyA9IHNwdHMuY29uY2F0KCBhcmdzWyAwIF0gKTtcblxuICAgICAgICAgICAgICAgIHZhciBzcGxpbmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIHNwdHMgKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIGogPSAxOyBqIDw9IG47IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggc3BsaW5lLmdldFBvaW50QXQoIGogLyBuICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkFSQzpcblxuICAgICAgICAgICAgICAgIHZhciBhWCA9IGFyZ3NbIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgYVkgPSBhcmdzWyAxIF0sXG4gICAgICAgICAgICAgICAgICAgIGFSYWRpdXMgPSBhcmdzWyAyIF0sXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlID0gYXJnc1sgMyBdLFxuICAgICAgICAgICAgICAgICAgICBhRW5kQW5nbGUgPSBhcmdzWyA0IF0sXG4gICAgICAgICAgICAgICAgICAgIGFDbG9ja3dpc2UgPSAhIWFyZ3NbIDUgXTtcblxuICAgICAgICAgICAgICAgIHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlO1xuICAgICAgICAgICAgICAgIHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcblxuICAgICAgICAgICAgICAgIGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ID0gaiAvIHRkaXZpc2lvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhYUNsb2Nrd2lzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDEgLSB0O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHggPSBhWCArIGFSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBhWSArIGFSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwb2ludHMpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRTpcblxuICAgICAgICAgICAgICAgIHZhciBhWCA9IGFyZ3NbIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgYVkgPSBhcmdzWyAxIF0sXG4gICAgICAgICAgICAgICAgICAgIHhSYWRpdXMgPSBhcmdzWyAyIF0sXG4gICAgICAgICAgICAgICAgICAgIHlSYWRpdXMgPSBhcmdzWyAzIF0sXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlID0gYXJnc1sgNCBdLFxuICAgICAgICAgICAgICAgICAgICBhRW5kQW5nbGUgPSBhcmdzWyA1IF0sXG4gICAgICAgICAgICAgICAgICAgIGFDbG9ja3dpc2UgPSAhIWFyZ3NbIDYgXSxcbiAgICAgICAgICAgICAgICAgICAgYVJvdGF0aW9uID0gYXJnc1sgNyBdO1xuXG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZTtcbiAgICAgICAgICAgICAgICB2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29zLCBzaW47XG4gICAgICAgICAgICAgICAgaWYgKCBhUm90YXRpb24gIT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoIGFSb3RhdGlvbiApO1xuICAgICAgICAgICAgICAgICAgICBzaW4gPSBNYXRoLnNpbiggYVJvdGF0aW9uICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdCA9IGogLyB0ZGl2aXNpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWFDbG9ja3dpc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAxIC0gdDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gYVggKyB4UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgICAgICAgICAgICAgICAgIHR5ID0gYVkgKyB5UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhUm90YXRpb24gIT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHR5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9ICggeCAtIGFYICkgKiBjb3MgLSAoIHkgLSBhWSApICogc2luICsgYVg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9ICggeCAtIGFYICkgKiBzaW4gKyAoIHkgLSBhWSApICogY29zICsgYVk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBvaW50cyk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9IC8vIGVuZCBzd2l0Y2hcblxuICAgIH1cblxuXG5cbiAgICAvLyBOb3JtYWxpemUgdG8gcmVtb3ZlIHRoZSBjbG9zaW5nIHBvaW50IGJ5IGRlZmF1bHQuXG4gICAgdmFyIGxhc3RQb2ludCA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcbiAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcbiAgICBpZiAoIE1hdGguYWJzKCBsYXN0UG9pbnQueCAtIHBvaW50c1sgMCBdLnggKSA8IEVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoIGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSApIDwgRVBTSUxPTiApXG4gICAgICAgIHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxICk7XG4gICAgaWYgKCBjbG9zZWRQYXRoICkge1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50cztcblxufTtcblxuLy9cbi8vIEJyZWFrcyBwYXRoIGludG8gc2hhcGVzXG4vL1xuLy9cdEFzc3VtcHRpb25zIChpZiBwYXJhbWV0ZXIgaXNDQ1c9PXRydWUgdGhlIG9wcG9zaXRlIGhvbGRzKTpcbi8vXHQtIHNvbGlkIHNoYXBlcyBhcmUgZGVmaW5lZCBjbG9ja3dpc2UgKENXKVxuLy9cdC0gaG9sZXMgYXJlIGRlZmluZWQgY291bnRlcmNsb2Nrd2lzZSAoQ0NXKVxuLy9cbi8vXHRJZiBwYXJhbWV0ZXIgbm9Ib2xlcz09dHJ1ZTpcbi8vICAtIGFsbCBzdWJQYXRocyBhcmUgcmVnYXJkZWQgYXMgc29saWQgc2hhcGVzXG4vLyAgLSBkZWZpbml0aW9uIG9yZGVyIENXL0NDVyBoYXMgbm8gcmVsZXZhbmNlXG4vL1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS50b1NoYXBlcyA9IGZ1bmN0aW9uKCBpc0NDVywgbm9Ib2xlcyApIHtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RTdWJwYXRocyggaW5BY3Rpb25zICkge1xuXG4gICAgICAgIHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xuXG4gICAgICAgIHZhciBzdWJQYXRocyA9IFtdLFxuICAgICAgICAgICAgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGluQWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICBpdGVtID0gaW5BY3Rpb25zWyBpIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSBpdGVtLmFyZ3M7XG4gICAgICAgICAgICBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcblxuICAgICAgICAgICAgaWYgKCBhY3Rpb24gPT09IFRIUkVFLlBhdGhBY3Rpb25zLk1PVkVfVE8gKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0UGF0aFsgYWN0aW9uIF0uYXBwbHkoIGxhc3RQYXRoLCBhcmdzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XG5cbiAgICAgICAgICAgIHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHN1YlBhdGhzKTtcblxuICAgICAgICByZXR1cm4gc3ViUGF0aHM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG4gICAgICAgICAgICB2YXIgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgICAgICAgIHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG4gICAgICAgICAgICB0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuICAgICAgICAgICAgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG4gICAgICAgIHJldHVybiBzaGFwZXM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbiggaW5QdCwgaW5Qb2x5Z29uICkge1xuXG4gICAgICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgICAgIHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcblxuICAgICAgICAvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuICAgICAgICAvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXG4gICAgICAgIC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcbiAgICAgICAgLy8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcbiAgICAgICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBlZGdlTG93UHQgPSBpblBvbHlnb25bIHAgXTtcbiAgICAgICAgICAgIHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XG5cbiAgICAgICAgICAgIHZhciBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcbiAgICAgICAgICAgIHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggZWRnZUR5ICkgPiBFUFNJTE9OICkge1xuXG4gICAgICAgICAgICAgICAgLy8gbm90IHBhcmFsbGVsXG4gICAgICAgICAgICAgICAgaWYgKCBlZGdlRHkgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcSBdO1xuICAgICAgICAgICAgICAgICAgICBlZGdlRHggPSAtZWRnZUR4O1xuICAgICAgICAgICAgICAgICAgICBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VEeSA9IC1lZGdlRHk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCAoIGluUHQueSA8IGVkZ2VMb3dQdC55ICkgfHwgKCBpblB0LnkgPiBlZGdlSGlnaFB0LnkgKSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpblB0LnkgPT09IGVkZ2VMb3dQdC55ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5QdC54ID09PSBlZGdlTG93UHQueCApIHJldHVybiB0cnVlOyAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcGVycEVkZ2UgPT09IDAgKSByZXR1cm4gdHJ1ZTsgLy8gaW5QdCBpcyBvbiBjb250b3VyID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwZXJwRWRnZSA8IDAgKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTsgLy8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG4gICAgICAgICAgICAgICAgaWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgY29udGludWU7IC8vIHBhcmFsbGVsXG4gICAgICAgICAgICAgICAgLy8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XG4gICAgICAgICAgICAgICAgaWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxuICAgICAgICAgICAgICAgICAgICAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApIHJldHVybiB0cnVlOyAvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuXG4gICAgfVxuXG5cbiAgICB2YXIgc3ViUGF0aHMgPSBleHRyYWN0U3VicGF0aHMoIHRoaXMuYWN0aW9ucyApO1xuICAgIGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xuXG4gICAgaWYgKCBub0hvbGVzID09PSB0cnVlICkgcmV0dXJuIHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG4gICAgdmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XG5cbiAgICBpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblxuICAgICAgICB0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcbiAgICAgICAgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgICAgdG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcbiAgICAgICAgdG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG4gICAgICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuICAgICAgICByZXR1cm4gc2hhcGVzO1xuXG4gICAgfVxuXG4gICAgdmFyIGhvbGVzRmlyc3QgPSAhVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcbiAgICBob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXG4gICAgdmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcbiAgICB2YXIgbmV3U2hhcGVzID0gW107XG4gICAgdmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcbiAgICB2YXIgbWFpbklkeCA9IDA7XG4gICAgdmFyIHRtcFBvaW50cztcblxuICAgIG5ld1NoYXBlc1sgbWFpbklkeCBdID0gdW5kZWZpbmVkO1xuICAgIG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG4gICAgdmFyIGksIGlsO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICB0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcbiAgICAgICAgdG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcbiAgICAgICAgc29saWQgPSBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XG4gICAgICAgIHNvbGlkID0gaXNDQ1cgPyAhc29saWQgOiBzb2xpZDtcblxuICAgICAgICBpZiAoIHNvbGlkICkge1xuXG4gICAgICAgICAgICBpZiAoICggIWhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1sgbWFpbklkeCBdICkgKSBtYWluSWR4Kys7XG5cbiAgICAgICAgICAgIG5ld1NoYXBlc1sgbWFpbklkeCBdID0ge1xuICAgICAgICAgICAgICAgIHM6IG5ldyBUSFJFRS5TaGFwZSgpLFxuICAgICAgICAgICAgICAgIHA6IHRtcFBvaW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcbiAgICAgICAgICAgIG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cbiAgICAgICAgICAgIGlmICggaG9sZXNGaXJzdCApIG1haW5JZHgrKztcbiAgICAgICAgICAgIG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXS5wdXNoKCB7XG4gICAgICAgICAgICAgICAgaDogdG1wUGF0aCxcbiAgICAgICAgICAgICAgICBwOiB0bXBQb2ludHNbIDAgXVxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cbiAgICBpZiAoICFuZXdTaGFwZXNbIDAgXSApIHJldHVybiB0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XG5cblxuICAgIGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgdmFyIGFtYmlndW91cyA9IGZhbHNlO1xuICAgICAgICB2YXIgdG9DaGFuZ2UgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCsrICkge1xuXG4gICAgICAgICAgICBiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcblxuICAgICAgICB9XG4gICAgICAgIGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XG4gICAgICAgICAgICBmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4KysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaG8gPSBzaG9bIGhJZHggXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzSWR4ICE9PSBzMklkeCApIHRvQ2hhbmdlLnB1c2goIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tczogc0lkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3M6IHMySWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGU6IGhJZHhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaG9sZV91bmFzc2lnbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1sgczJJZHggXS5wdXNoKCBobyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91cyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYW1iaWd1b3VzOiBcIiwgYW1iaWd1b3VzKTtcbiAgICAgICAgaWYgKCB0b0NoYW5nZS5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmICggIWFtYmlndW91cyApIG5ld1NoYXBlSG9sZXMgPSBiZXR0ZXJTaGFwZUhvbGVzO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciB0bXBIb2xlcywgaiwgamw7XG4gICAgZm9yICggaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgdG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xuICAgICAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcbiAgICAgICAgdG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XG4gICAgICAgIGZvciAoIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgIHRtcFNoYXBlLmhvbGVzLnB1c2goIHRtcEhvbGVzWyBqIF0uaCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG4gICAgcmV0dXJuIHNoYXBlcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG4gKiovXG5cbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblRIUkVFLlNoYXBlID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5QYXRoLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICB0aGlzLmhvbGVzID0gW107XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XG5USFJFRS5TaGFwZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJ1ZGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgIHZhciBleHRydWRlZCA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcbiAgICByZXR1cm4gZXh0cnVkZWQ7XG5cbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUubWFrZUdlb21ldHJ5ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzSG9sZXMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgdmFyIGksIGlsID0gdGhpcy5ob2xlcy5sZW5ndGgsXG4gICAgICAgIGhvbGVzUHRzID0gW107XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgaG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zLCB0aGlzLmJlbmRzICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gaG9sZXNQdHM7XG5cbn07XG5cbi8vIEdldCBwb2ludHMgb2YgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzSG9sZXMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgdmFyIGksIGlsID0gdGhpcy5ob2xlcy5sZW5ndGgsXG4gICAgICAgIGhvbGVzUHRzID0gW107XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgaG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0aGlzLmJlbmRzICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gaG9sZXNQdHM7XG5cbn07XG5cblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgc2hhcGU6IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucyApLFxuICAgICAgICBob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuICAgIH07XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIGlmICggdGhpcy51c2VTcGFjZWRQb2ludHMgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyggZGl2aXNpb25zICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKCBkaXZpc2lvbnMgKTtcblxufTtcblxuLy9cbi8vIFRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzV2l0aEJlbmQgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucywgYmVuZCApIHtcbi8vXG4vLyBcdHJldHVybiB7XG4vL1xuLy8gXHRcdHNoYXBlOiB0aGlzLnRyYW5zZm9ybSggYmVuZCwgZGl2aXNpb25zICksXG4vLyBcdFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucywgYmVuZCApXG4vL1xuLy8gXHR9O1xuLy9cbi8vIH07XG5cbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChzcGFjZWQgYnkgcmVndWxhciBkaXN0YW5jZSlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgICBzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zICksXG4gICAgICAgIGhvbGVzOiB0aGlzLmdldFNwYWNlZFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG4gICAgfTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0VXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuU2hhcGUuVXRpbHMgPSB7XG5cbiAgICB0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiggY29udG91ciwgaG9sZXMgKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWdQdDEsIGluU2VnUHQyLCBpbk90aGVyUHQgKSB7XG5cbiAgICAgICAgICAgIC8vIGluT3RoZXJQdCBuZWVkcyB0byBiZSBjb2xsaW5lYXIgdG8gdGhlIGluU2VnbWVudFxuICAgICAgICAgICAgaWYgKCBpblNlZ1B0MS54ICE9PSBpblNlZ1B0Mi54ICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpblNlZ1B0MS54IDwgaW5TZWdQdDIueCApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAoIGluU2VnUHQxLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQyLnggKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICggaW5TZWdQdDIueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDEueCApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpblNlZ1B0MS55IDwgaW5TZWdQdDIueSApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAoIGluU2VnUHQxLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQyLnkgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICggaW5TZWdQdDIueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDEueSApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluRXhjbHVkZUFkamFjZW50U2VncyApIHtcblxuICAgICAgICAgICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAgICAgICAgIHZhciBzZWcxZHggPSBpblNlZzFQdDIueCAtIGluU2VnMVB0MS54LFxuICAgICAgICAgICAgICAgIHNlZzFkeSA9IGluU2VnMVB0Mi55IC0gaW5TZWcxUHQxLnk7XG4gICAgICAgICAgICB2YXIgc2VnMmR4ID0gaW5TZWcyUHQyLnggLSBpblNlZzJQdDEueCxcbiAgICAgICAgICAgICAgICBzZWcyZHkgPSBpblNlZzJQdDIueSAtIGluU2VnMlB0MS55O1xuXG4gICAgICAgICAgICB2YXIgc2VnMXNlZzJkeCA9IGluU2VnMVB0MS54IC0gaW5TZWcyUHQxLng7XG4gICAgICAgICAgICB2YXIgc2VnMXNlZzJkeSA9IGluU2VnMVB0MS55IC0gaW5TZWcyUHQxLnk7XG5cbiAgICAgICAgICAgIHZhciBsaW1pdCA9IHNlZzFkeSAqIHNlZzJkeCAtIHNlZzFkeCAqIHNlZzJkeTtcbiAgICAgICAgICAgIHZhciBwZXJwU2VnMSA9IHNlZzFkeSAqIHNlZzFzZWcyZHggLSBzZWcxZHggKiBzZWcxc2VnMmR5O1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBsaW1pdCApID4gRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgICAgIC8vIG5vdCBwYXJhbGxlbFxuXG4gICAgICAgICAgICAgICAgdmFyIHBlcnBTZWcyO1xuICAgICAgICAgICAgICAgIGlmICggbGltaXQgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMSA8IDAgKSB8fCAoIHBlcnBTZWcxID4gbGltaXQgKSApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgcmV0dXJuIFtdO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHBlcnBTZWcyID4gMCApIHx8ICggcGVycFNlZzIgPCBsaW1pdCApICkgcmV0dXJuIFtdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaS5lLiB0byByZWR1Y2Ugcm91bmRpbmcgZXJyb3JzXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMT9cbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcyID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDEgXTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcyID09PSBsaW1pdCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQyIF07XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMj9cbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcxID09PSAwICkgcmV0dXJuIFsgaW5TZWcyUHQxIF07XG4gICAgICAgICAgICAgICAgaWYgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSByZXR1cm4gWyBpblNlZzJQdDIgXTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZWFsIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3JTZWcxID0gcGVycFNlZzIgLyBsaW1pdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGluU2VnMVB0MS54ICsgZmFjdG9yU2VnMSAqIHNlZzFkeCxcbiAgICAgICAgICAgICAgICAgICAgeTogaW5TZWcxUHQxLnkgKyBmYWN0b3JTZWcxICogc2VnMWR5XG4gICAgICAgICAgICAgICAgfSBdO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMSAhPT0gMCApIHx8XG4gICAgICAgICAgICAgICAgICAgICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPT0gc2VnMmR4ICogc2VnMXNlZzJkeSApICkgcmV0dXJuIFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgY29sbGluZWFyIG9yIGRlZ2VuZXJhdGVcbiAgICAgICAgICAgICAgICB2YXIgc2VnMVB0ID0gKCAoIHNlZzFkeCA9PT0gMCApICYmICggc2VnMWR5ID09PSAwICkgKTsgLy8gc2VnbWVudDEgaXMganVzdCBhIHBvaW50P1xuICAgICAgICAgICAgICAgIHZhciBzZWcyUHQgPSAoICggc2VnMmR4ID09PSAwICkgJiYgKCBzZWcyZHkgPT09IDAgKSApOyAvLyBzZWdtZW50MiBpcyBqdXN0IGEgcG9pbnQ/XG4gICAgICAgICAgICAgICAgLy8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBzZWcxUHQgJiYgc2VnMlB0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBpblNlZzFQdDEueCAhPT0gaW5TZWcyUHQxLnggKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCBpblNlZzFQdDEueSAhPT0gaW5TZWcyUHQxLnkgKSApIHJldHVybiBbXTsgLy8gdGhleSBhcmUgZGlzdGluY3QgIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDEgXTsgLy8gdGhleSBhcmUgdGhlIHNhbWUgcG9pbnRcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKCBzZWcxUHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluU2VnMVB0MSApICkgcmV0dXJuIFtdOyAvLyBidXQgbm90IGluIHNlZ21lbnQjMlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDEgXTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50IzIgIGlzIGEgc2luZ2xlIHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKCBzZWcyUHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApICkgcmV0dXJuIFtdOyAvLyBidXQgbm90IGluIHNlZ21lbnQjMVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzJQdDEgXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRoZXkgYXJlIGNvbGxpbmVhciBzZWdtZW50cywgd2hpY2ggbWlnaHQgb3ZlcmxhcFxuICAgICAgICAgICAgICAgIHZhciBzZWcxbWluLCBzZWcxbWF4LCBzZWcxbWluVmFsLCBzZWcxbWF4VmFsO1xuICAgICAgICAgICAgICAgIHZhciBzZWcybWluLCBzZWcybWF4LCBzZWcybWluVmFsLCBzZWcybWF4VmFsO1xuICAgICAgICAgICAgICAgIGlmICggc2VnMWR4ICE9PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluU2VnMVB0MS54IDwgaW5TZWcxUHQyLnggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluVmFsID0gaW5TZWcxUHQxLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi54O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluVmFsID0gaW5TZWcxUHQyLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heFZhbCA9IGluU2VnMVB0MS54O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblNlZzJQdDEueCA8IGluU2VnMlB0Mi54ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pblZhbCA9IGluU2VnMlB0MS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlZ21lbnRzIGFyZSBvbiBhIHZlcnRpY2FsIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblNlZzFQdDEueSA8IGluU2VnMVB0Mi55ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pblZhbCA9IGluU2VnMVB0MS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5TZWcyUHQxLnkgPCBpblNlZzJQdDIueSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4VmFsID0gaW5TZWcyUHQxLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggc2VnMW1pblZhbCA8PSBzZWcybWluVmFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8IHNlZzJtaW5WYWwgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBzZWcybWluIF07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApIHJldHVybiBbIHNlZzJtaW4sIHNlZzFtYXggXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgc2VnMm1pbiwgc2VnMm1heCBdO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1pblZhbCA+IHNlZzJtYXhWYWwgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1pblZhbCA9PT0gc2VnMm1heFZhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBzZWcxbWluIF07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApIHJldHVybiBbIHNlZzFtaW4sIHNlZzFtYXggXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgc2VnMW1pbiwgc2VnMm1heCBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVBbmdsZSggaW5WZXJ0ZXgsIGluTGVnRnJvbVB0LCBpbkxlZ1RvUHQsIGluT3RoZXJQdCApIHtcblxuICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIGxlZ3MgaXMgaW1wb3J0YW50XG5cbiAgICAgICAgICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGlvbiBvZiBhbGwgcG9pbnRzLCBzbyB0aGF0IFZlcnRleCBpcyBhdCAoMCwwKVxuICAgICAgICAgICAgdmFyIGxlZ0Zyb21QdFggPSBpbkxlZ0Zyb21QdC54IC0gaW5WZXJ0ZXgueCxcbiAgICAgICAgICAgICAgICBsZWdGcm9tUHRZID0gaW5MZWdGcm9tUHQueSAtIGluVmVydGV4Lnk7XG4gICAgICAgICAgICB2YXIgbGVnVG9QdFggPSBpbkxlZ1RvUHQueCAtIGluVmVydGV4LngsXG4gICAgICAgICAgICAgICAgbGVnVG9QdFkgPSBpbkxlZ1RvUHQueSAtIGluVmVydGV4Lnk7XG4gICAgICAgICAgICB2YXIgb3RoZXJQdFggPSBpbk90aGVyUHQueCAtIGluVmVydGV4LngsXG4gICAgICAgICAgICAgICAgb3RoZXJQdFkgPSBpbk90aGVyUHQueSAtIGluVmVydGV4Lnk7XG5cbiAgICAgICAgICAgIC8vIG1haW4gYW5nbGUgPjA6IDwgMTgwIGRlZy47IDA6IDE4MCBkZWcuOyA8MDogPiAxODAgZGVnLlxuICAgICAgICAgICAgdmFyIGZyb20ydG9BbmdsZSA9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcbiAgICAgICAgICAgIHZhciBmcm9tMm90aGVyQW5nbGUgPSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIGZyb20ydG9BbmdsZSApID4gRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgICAgIC8vIGFuZ2xlICE9IDE4MCBkZWcuXG5cbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIydG9BbmdsZSA9IG90aGVyUHRYICogbGVnVG9QdFkgLSBvdGhlclB0WSAqIGxlZ1RvUHRYO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IFwiICsgZnJvbTJ0b0FuZ2xlICsgXCIsIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICsgXCIsIG90aGVyMnRvOiBcIiArIG90aGVyMnRvQW5nbGUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYWluIGFuZ2xlIDwgMTgwIGRlZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApICYmICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhbmdsZSA9PSAxODAgZGVnLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBmcm9tMm90aGVyQW5nbGUgPiAwICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGNvbnRvdXIuY29uY2F0KCk7IC8vIHdvcmsgb24gdGhpcyBzaGFwZVxuICAgICAgICAgICAgdmFyIGhvbGU7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQ3V0TGluZUluc2lkZUFuZ2xlcyggaW5TaGFwZUlkeCwgaW5Ib2xlSWR4ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaG9sZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgc2hhcGUgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFNoYXBlSWR4ID0gc2hhcGUubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgIHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIHByZXZTaGFwZUlkeCA8IDAgKSBwcmV2U2hhcGVJZHggPSBsYXN0U2hhcGVJZHg7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNoYXBlSWR4ID0gaW5TaGFwZUlkeCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKCBuZXh0U2hhcGVJZHggPiBsYXN0U2hhcGVJZHggKSBuZXh0U2hhcGVJZHggPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBzaGFwZVsgaW5TaGFwZUlkeCBdLCBzaGFwZVsgcHJldlNoYXBlSWR4IF0sIHNoYXBlWyBuZXh0U2hhcGVJZHggXSwgaG9sZVsgaW5Ib2xlSWR4IF0gKTtcbiAgICAgICAgICAgICAgICBpZiAoICFpbnNpZGVBbmdsZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKFNoYXBlKTogXCIgKyBpblNoYXBlSWR4ICsgXCIsIFBvaW50OiBcIiArIGhvbGVbaW5Ib2xlSWR4XS54ICsgXCIvXCIgKyBob2xlW2luSG9sZUlkeF0ueSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzaGFwZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgaG9sZSBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgIHZhciBwcmV2SG9sZUlkeCA9IGluSG9sZUlkeCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKCBwcmV2SG9sZUlkeCA8IDAgKSBwcmV2SG9sZUlkeCA9IGxhc3RIb2xlSWR4O1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHRIb2xlSWR4ID0gaW5Ib2xlSWR4ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoIG5leHRIb2xlSWR4ID4gbGFzdEhvbGVJZHggKSBuZXh0SG9sZUlkeCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggaG9sZVsgaW5Ib2xlSWR4IF0sIGhvbGVbIHByZXZIb2xlSWR4IF0sIGhvbGVbIG5leHRIb2xlSWR4IF0sIHNoYXBlWyBpblNoYXBlSWR4IF0gKTtcbiAgICAgICAgICAgICAgICBpZiAoICFpbnNpZGVBbmdsZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKEhvbGUpOiBcIiArIGluSG9sZUlkeCArIFwiLCBQb2ludDogXCIgKyBzaGFwZVtpblNoYXBlSWR4XS54ICsgXCIvXCIgKyBzaGFwZVtpblNoYXBlSWR4XS55ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBzaGFwZSBlZGdlc1xuICAgICAgICAgICAgICAgIHZhciBzSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XG4gICAgICAgICAgICAgICAgZm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHgrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBuZXh0SWR4ID0gc0lkeCArIDE7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIHNoYXBlWyBzSWR4IF0sIHNoYXBlWyBuZXh0SWR4IF0sIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRlcEhvbGVzID0gW107XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdHNIb2xlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGhvbGUgZWRnZXNcbiAgICAgICAgICAgICAgICB2YXIgaWhJZHgsIGNoa0hvbGUsXG4gICAgICAgICAgICAgICAgICAgIGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKCBpaElkeCA9IDA7IGloSWR4IDwgaW5kZXBIb2xlcy5sZW5ndGg7IGloSWR4KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hrSG9sZSA9IGhvbGVzWyBpbmRlcEhvbGVzWyBpaElkeCBdIF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGhJZHggPSAwOyBoSWR4IDwgY2hrSG9sZS5sZW5ndGg7IGhJZHgrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkeCA9IGhJZHggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkeCAlPSBjaGtIb2xlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgY2hrSG9sZVsgaElkeCBdLCBjaGtIb2xlWyBuZXh0SWR4IF0sIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXG4gICAgICAgICAgICAgICAgc2hhcGVQdCwgaG9sZVB0LFxuICAgICAgICAgICAgICAgIGhvbGVJZHgsIGN1dEtleSwgZmFpbGVkQ3V0cyA9IFtdLFxuICAgICAgICAgICAgICAgIHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuICAgICAgICAgICAgICAgIHRtcEhvbGUxLCB0bXBIb2xlMjtcblxuICAgICAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpbmRlcEhvbGVzLnB1c2goIGggKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWluU2hhcGVJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcbiAgICAgICAgICAgIHdoaWxlICggaW5kZXBIb2xlcy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgICAgIGlmICggY291bnRlciA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIiArIGluZGVwSG9sZXMubGVuZ3RoICsgXCIsIFByb2JhYmx5IEhvbGUgb3V0c2lkZSBTaGFwZSFcIiApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3Igc2hhcGUtdmVydGV4IGFuZCBob2xlLXZlcnRleCxcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgICAgICAgIGZvciAoIHNoYXBlSW5kZXggPSBtaW5TaGFwZUluZGV4OyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoOyBzaGFwZUluZGV4KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2hhcGVQdCA9IHNoYXBlWyBzaGFwZUluZGV4IF07XG4gICAgICAgICAgICAgICAgICAgIGhvbGVJbmRleCA9IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGggPSAwOyBoIDwgaW5kZXBIb2xlcy5sZW5ndGg7IGgrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZUlkeCA9IGluZGVwSG9sZXNbIGggXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dEtleSA9IHNoYXBlUHQueCArIFwiOlwiICsgc2hhcGVQdC55ICsgXCI6XCIgKyBob2xlSWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmYWlsZWRDdXRzWyBjdXRLZXkgXSAhPT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGUgPSBob2xlc1sgaG9sZUlkeCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVQdCA9IGhvbGVbIGgyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBzaGFwZUluZGV4LCBoMiApICkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3RzU2hhcGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0c0hvbGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZUluZGV4ID0gaDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXBIb2xlcy5zcGxpY2UoIGgsIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4ICsgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFNoYXBlMiA9IHNoYXBlLnNsaWNlKCBzaGFwZUluZGV4ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wSG9sZTEgPSBob2xlLnNsaWNlKCBob2xlSW5kZXggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCArIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlID0gdG1wU2hhcGUxLmNvbmNhdCggdG1wSG9sZTEgKS5jb25jYXQoIHRtcEhvbGUyICkuY29uY2F0KCB0bXBTaGFwZTIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblNoYXBlSW5kZXggPSBzaGFwZUluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVidWcgb25seSwgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgY3V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdsb2JfQ3V0TGluZXMucHVzaCggWyBzaGFwZVB0LCBob2xlUHQgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaG9sZUluZGV4ID49IDAgKSBicmVhazsgLy8gaG9sZS12ZXJ0ZXggZm91bmRcblxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkQ3V0c1sgY3V0S2V5IF0gPSB0cnVlOyAvLyByZW1lbWJlciBmYWlsdXJlXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhvbGVJbmRleCA+PSAwICkgYnJlYWs7IC8vIGhvbGUtdmVydGV4IGZvdW5kXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlOyAvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGksIGlsLCBmLCBmYWNlLFxuICAgICAgICAgICAga2V5LCBpbmRleCxcbiAgICAgICAgICAgIGFsbFBvaW50c01hcCA9IHt9O1xuXG4gICAgICAgIC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cblxuICAgICAgICB2YXIgYWxscG9pbnRzID0gY29udG91ci5jb25jYXQoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGFsbHBvaW50cywgaG9sZXNbIGggXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xuXG4gICAgICAgIC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBhbGxwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAga2V5ID0gYWxscG9pbnRzWyBpIF0ueCArIFwiOlwiICsgYWxscG9pbnRzWyBpIF0ueTtcblxuICAgICAgICAgICAgaWYgKCBhbGxQb2ludHNNYXBbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuU2hhcGU6IER1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbGxQb2ludHNNYXBbIGtleSBdID0gaTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxuICAgICAgICB2YXIgc2hhcGVXaXRob3V0SG9sZXMgPSByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKTtcblxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gVEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlKCBzaGFwZVdpdGhvdXRIb2xlcywgZmFsc2UgKTsgLy8gVHJ1ZSByZXR1cm5zIGluZGljZXMgZm9yIHBvaW50cyBvZiBzcG9vbGVkIHNoYXBlXG4gICAgICAgIC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XG5cbiAgICAgICAgLy8gY2hlY2sgYWxsIGZhY2UgdmVydGljZXMgYWdhaW5zdCBhbGwgcG9pbnRzIG1hcFxuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICBmYWNlID0gdHJpYW5nbGVzWyBpIF07XG5cbiAgICAgICAgICAgIGZvciAoIGYgPSAwOyBmIDwgMzsgZisrICkge1xuXG4gICAgICAgICAgICAgICAga2V5ID0gZmFjZVsgZiBdLnggKyBcIjpcIiArIGZhY2VbIGYgXS55O1xuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VbIGYgXSA9IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmlhbmdsZXMuY29uY2F0KCk7XG5cbiAgICB9LFxuXG4gICAgaXNDbG9ja1dpc2U6IGZ1bmN0aW9uKCBwdHMgKSB7XG5cbiAgICAgICAgcmV0dXJuIFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBwdHMgKSA8IDA7XG5cbiAgICB9LFxuXG4gICAgLy8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuXG4gICAgLy8gUXVhZCBCZXppZXIgRnVuY3Rpb25zXG5cbiAgICBiMnAwOiBmdW5jdGlvbiggdCwgcCApIHtcblxuICAgICAgICB2YXIgayA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gayAqIGsgKiBwO1xuXG4gICAgfSxcblxuICAgIGIycDE6IGZ1bmN0aW9uKCB0LCBwICkge1xuXG4gICAgICAgIHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XG5cbiAgICB9LFxuXG4gICAgYjJwMjogZnVuY3Rpb24oIHQsIHAgKSB7XG5cbiAgICAgICAgcmV0dXJuIHQgKiB0ICogcDtcblxuICAgIH0sXG5cbiAgICBiMjogZnVuY3Rpb24oIHQsIHAwLCBwMSwgcDIgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYjJwMCggdCwgcDAgKSArIHRoaXMuYjJwMSggdCwgcDEgKSArIHRoaXMuYjJwMiggdCwgcDIgKTtcblxuICAgIH0sXG5cbiAgICAvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXG5cbiAgICBiM3AwOiBmdW5jdGlvbiggdCwgcCApIHtcblxuICAgICAgICB2YXIgayA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gayAqIGsgKiBrICogcDtcblxuICAgIH0sXG5cbiAgICBiM3AxOiBmdW5jdGlvbiggdCwgcCApIHtcblxuICAgICAgICB2YXIgayA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XG5cbiAgICB9LFxuXG4gICAgYjNwMjogZnVuY3Rpb24oIHQsIHAgKSB7XG5cbiAgICAgICAgdmFyIGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xuXG4gICAgfSxcblxuICAgIGIzcDM6IGZ1bmN0aW9uKCB0LCBwICkge1xuXG4gICAgICAgIHJldHVybiB0ICogdCAqIHQgKiBwO1xuXG4gICAgfSxcblxuICAgIGIzOiBmdW5jdGlvbiggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYjNwMCggdCwgcDAgKSArIHRoaXMuYjNwMSggdCwgcDEgKSArIHRoaXMuYjNwMiggdCwgcDIgKSArIHRoaXMuYjNwMyggdCwgcDMgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0TGluZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUgPSBmdW5jdGlvbiggdjEsIHYyICkge1xuXG4gICAgdGhpcy52MSA9IHYxO1xuICAgIHRoaXMudjIgPSB2MjtcblxufTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVDdXJ2ZTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHBvaW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xuICAgIHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cbiAgICByZXR1cm4gcG9pbnQ7XG5cbn07XG5cbi8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiggdSApIHtcblxuICAgIHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XG5cbn07XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHRhbmdlbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XG5cbiAgICByZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiggdjAsIHYxLCB2MiApIHtcblxuICAgIHRoaXMudjAgPSB2MDtcbiAgICB0aGlzLnYxID0gdjE7XG4gICAgdGhpcy52MiA9IHYyO1xuXG59O1xuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlO1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICB2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG4gICAgdmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG4gICAgcmV0dXJuIHZlY3RvcjtcblxufTtcblxuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcbiAgICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblxuICAgIC8vIHJldHVybnMgdW5pdCB2ZWN0b3JcblxuICAgIHJldHVybiB2ZWN0b3Iubm9ybWFsaXplKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuICAgIHRoaXMudjAgPSB2MDtcbiAgICB0aGlzLnYxID0gdjE7XG4gICAgdGhpcy52MiA9IHYyO1xuICAgIHRoaXMudjMgPSB2MztcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciB0eCwgdHk7XG5cbiAgICB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcbiAgICB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XG5cbn07XG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciB0eCwgdHk7XG5cbiAgICB0eCA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG4gICAgdHkgPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xuXG4gICAgdmFyIHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XG4gICAgdGFuZ2VudC5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB0YW5nZW50O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFNwbGluZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5TcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcblxuICAgIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxufTtcblxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGxpbmVDdXJ2ZTtcblxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuICAgIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICB2YXIgcG9pbnQwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG4gICAgdmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcbiAgICB2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcbiAgICB2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuICAgIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKTtcblxuICAgIHJldHVybiB2ZWN0b3I7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvRWxsaXBzZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEVsbGlwc2UgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuRWxsaXBzZUN1cnZlID0gZnVuY3Rpb24oIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG4gICAgdGhpcy5hWCA9IGFYO1xuICAgIHRoaXMuYVkgPSBhWTtcblxuICAgIHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XG4gICAgdGhpcy55UmFkaXVzID0geVJhZGl1cztcblxuICAgIHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZTtcbiAgICB0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcblxuICAgIHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG5cbiAgICB0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbiB8fCAwO1xuXG59O1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWxsaXBzZUN1cnZlO1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcblxuICAgIGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgIGlmICggZGVsdGFBbmdsZSA+IE1hdGguUEkgKiAyICkgZGVsdGFBbmdsZSAtPSBNYXRoLlBJICogMjtcblxuICAgIHZhciBhbmdsZTtcblxuICAgIGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICkge1xuXG4gICAgICAgIGFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgKyAoIDEgLSB0ICkgKiAoIE1hdGguUEkgKiAyIC0gZGVsdGFBbmdsZSApO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG4gICAgfVxuXG4gICAgdmFyIHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgdmFyIHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cbiAgICBpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xuXG4gICAgICAgIHZhciB0eCA9IHgsXG4gICAgICAgICAgICB0eSA9IHk7XG5cbiAgICAgICAgLy8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgICAgICB4ID0gKCB0eCAtIHRoaXMuYVggKSAqIGNvcyAtICggdHkgLSB0aGlzLmFZICkgKiBzaW4gKyB0aGlzLmFYO1xuICAgICAgICB5ID0gKCB0eCAtIHRoaXMuYVggKSAqIHNpbiArICggdHkgLSB0aGlzLmFZICkgKiBjb3MgKyB0aGlzLmFZO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQXJjQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0QXJjIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkFyY0N1cnZlID0gZnVuY3Rpb24oIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuICAgIFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxufTtcblxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRMaW5lM0RcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuTGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICAgIGZ1bmN0aW9uKCB2MSwgdjIgKSB7XG5cbiAgICAgICAgdGhpcy52MSA9IHYxO1xuICAgICAgICB0aGlzLnYyID0gdjI7XG5cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmVjdG9yLnN1YlZlY3RvcnMoIHRoaXMudjIsIHRoaXMudjEgKTsgLy8gZGlmZlxuICAgICAgICB2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIHQgKTtcbiAgICAgICAgdmVjdG9yLmFkZCggdGhpcy52MSApO1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFF1YWRyYXRpYyBCZXppZXIgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gICAgZnVuY3Rpb24oIHYwLCB2MSwgdjIgKSB7XG5cbiAgICAgICAgdGhpcy52MCA9IHYwO1xuICAgICAgICB0aGlzLnYxID0gdjE7XG4gICAgICAgIHRoaXMudjIgPSB2MjtcblxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG4gICAgICAgIHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcbiAgICAgICAgdmVjdG9yLnogPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiApO1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3ViaWMgQmV6aWVyIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gICAgZnVuY3Rpb24oIHYwLCB2MSwgdjIsIHYzICkge1xuXG4gICAgICAgIHRoaXMudjAgPSB2MDtcbiAgICAgICAgdGhpcy52MSA9IHYxO1xuICAgICAgICB0aGlzLnYyID0gdjI7XG4gICAgICAgIHRoaXMudjMgPSB2MztcblxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcbiAgICAgICAgdmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG4gICAgICAgIHZlY3Rvci56ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnosIHRoaXMudjMueiApO1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFNwbGluZSAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLlNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICAgIGZ1bmN0aW9uKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5TcGxpbmVDdXJ2ZTMgd2lsbCBiZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMnICk7XG4gICAgICAgIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XG5cbiAgICAgICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgICAgdmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG4gICAgICAgIHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgICAgIHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuICAgICAgICB2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICk7XG4gICAgICAgIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKTtcbiAgICAgICAgdmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICpcbiAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cbiAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXG4gKlxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG4gKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XG4gKi9cblxuVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXJcbiAgICAgICAgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgcHggPSBuZXcgQ3ViaWNQb2x5KCksXG4gICAgICAgIHB5ID0gbmV3IEN1YmljUG9seSgpLFxuICAgICAgICBweiA9IG5ldyBDdWJpY1BvbHkoKTtcblxuICAgIC8qXG5cdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cblx0IC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NDg5NzM2L2NhdG11bGwtcm9tLWN1cnZlLXdpdGgtbm8tY3VzcHMtYW5kLW5vLXNlbGYtaW50ZXJzZWN0aW9ucy9cblx0IC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cblx0VGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxuXHRidXQgZm9yIHRocmVlLmpzIGN1cnZlIHVzZSwgaXQgY291bGQgYmUgcG9zc2libGUgaW5saW5lZCBhbmQgZmxhdHRlbiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGxcblx0d2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuXHQqL1xuXG4gICAgZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG4gICAgICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG4gICAgICogc3VjaCB0aGF0XG4gICAgICogICBwKDApID0geDAsIHAoMSkgPSB4MVxuICAgICAqICBhbmRcbiAgICAgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXG4gICAgICovXG4gICAgQ3ViaWNQb2x5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oIHgwLCB4MSwgdDAsIHQxICkge1xuXG4gICAgICAgIHRoaXMuYzAgPSB4MDtcbiAgICAgICAgdGhpcy5jMSA9IHQwO1xuICAgICAgICB0aGlzLmMyID0gLTMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xuICAgICAgICB0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcblxuICAgIH07XG5cbiAgICBDdWJpY1BvbHkucHJvdG90eXBlLmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCB4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0MiApIHtcblxuICAgICAgICAvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXG4gICAgICAgIHZhciB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XG4gICAgICAgIHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XG5cbiAgICAgICAgLy8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXG4gICAgICAgIHQxICo9IGR0MTtcbiAgICAgICAgdDIgKj0gZHQxO1xuXG4gICAgICAgIC8vIGluaXRDdWJpY1BvbHlcbiAgICAgICAgdGhpcy5pbml0KCB4MSwgeDIsIHQxLCB0MiApO1xuXG4gICAgfTtcblxuICAgIC8vIHN0YW5kYXJkIENhdG11bGwtUm9tIHNwbGluZTogaW50ZXJwb2xhdGUgYmV0d2VlbiB4MSBhbmQgeDIgd2l0aCBwcmV2aW91cy9mb2xsb3dpbmcgcG9pbnRzIHgxL3g0XG4gICAgQ3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Q2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCB4MCwgeDEsIHgyLCB4MywgdGVuc2lvbiApIHtcblxuICAgICAgICB0aGlzLmluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcblxuICAgIH07XG5cbiAgICBDdWJpY1BvbHkucHJvdG90eXBlLmNhbGMgPSBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICB2YXIgdDIgPSB0ICogdDtcbiAgICAgICAgdmFyIHQzID0gdDIgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5jMCArIHRoaXMuYzEgKiB0ICsgdGhpcy5jMiAqIHQyICsgdGhpcy5jMyAqIHQzO1xuXG4gICAgfTtcblxuICAgIC8vIFN1YmNsYXNzIFRocmVlLmpzIGN1cnZlXG4gICAgcmV0dXJuIFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICAgICAgICBmdW5jdGlvbiggcCAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xuXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IHAgfHwgW107XG5cbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgICAgIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCBsO1xuXG4gICAgICAgICAgICBsID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCBsIDwgMiApIGNvbnNvbGUubG9nKCAnZHVoLCB5b3UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cycgKTtcblxuICAgICAgICAgICAgcG9pbnQgPSAoIGwgLSAxICkgKiB0O1xuICAgICAgICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgICAgICAgICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgICAgICAgICAgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xuXG4gICAgICAgICAgICAgICAgaW50UG9pbnQgPSBsIC0gMjtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSAxO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwMCwgcDEsIHAyLCBwMztcblxuICAgICAgICAgICAgaWYgKCBpbnRQb2ludCA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XG4gICAgICAgICAgICAgICAgdG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSApLmFkZCggcG9pbnRzWyAwIF0gKTtcbiAgICAgICAgICAgICAgICBwMCA9IHRtcDtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1sgaW50UG9pbnQgLSAxIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgICAgICAgICBwMiA9IHBvaW50c1sgaW50UG9pbnQgKyAxIF07XG5cbiAgICAgICAgICAgIGlmICggaW50UG9pbnQgKyAyIDwgbCApIHtcblxuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzWyBpbnRQb2ludCArIDIgXVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcbiAgICAgICAgICAgICAgICB0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDIgXSApO1xuICAgICAgICAgICAgICAgIHAzID0gdG1wO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpcy50eXBlID09PSB1bmRlZmluZWQgfHwgdGhpcy50eXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG4gICAgICAgICAgICAgICAgLy8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cbiAgICAgICAgICAgICAgICB2YXIgcG93ID0gdGhpcy50eXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xuICAgICAgICAgICAgICAgIHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xuICAgICAgICAgICAgICAgIHZhciBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xuICAgICAgICAgICAgICAgIHZhciBkdDIgPSBNYXRoLnBvdyggcDIuZGlzdGFuY2VUb1NxdWFyZWQoIHAzICksIHBvdyApO1xuXG4gICAgICAgICAgICAgICAgLy8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcbiAgICAgICAgICAgICAgICBpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XG4gICAgICAgICAgICAgICAgaWYgKCBkdDAgPCAxZS00ICkgZHQwID0gZHQxO1xuICAgICAgICAgICAgICAgIGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcblxuICAgICAgICAgICAgICAgIHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xuICAgICAgICAgICAgICAgIHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xuICAgICAgICAgICAgICAgIHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggdGhpcy50eXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGVuc2lvbiA9IHRoaXMudGVuc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy50ZW5zaW9uIDogMC41O1xuICAgICAgICAgICAgICAgIHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0ZW5zaW9uICk7XG4gICAgICAgICAgICAgICAgcHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRlbnNpb24gKTtcbiAgICAgICAgICAgICAgICBwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGVuc2lvbiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgICAgICAgcHguY2FsYyggd2VpZ2h0ICksXG4gICAgICAgICAgICAgICAgcHkuY2FsYyggd2VpZ2h0ICksXG4gICAgICAgICAgICAgICAgcHouY2FsYyggd2VpZ2h0IClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiB2O1xuXG4gICAgICAgIH1cblxuICAgICk7XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0Nsb3NlZFNwbGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDbG9zZWQgU3BsaW5lIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gICAgZnVuY3Rpb24oIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xuXG4gICAgICAgIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiggdCApIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDAgKSAqIHQ7IC8vIFRoaXMgbmVlZHMgdG8gYmUgZnJvbSAwLWxlbmd0aCArMVxuXG4gICAgICAgIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgICAgIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgICAgIGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICB2YXIgcG9pbnQwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgcG9pbnRzLmxlbmd0aCBdO1xuICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyAoIGludFBvaW50ICkgJSBwb2ludHMubGVuZ3RoIF07XG4gICAgICAgIHZhciBwb2ludDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBwb2ludHMubGVuZ3RoIF07XG4gICAgICAgIHZhciBwb2ludDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBwb2ludHMubGVuZ3RoIF07XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuICAgICAgICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG4gICAgICAgIHZlY3Rvci56ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKTtcblxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuXG4gICAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL0FuaW1hdGlvbkhhbmRsZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblRIUkVFLkFuaW1hdGlvbkhhbmRsZXIgPSB7XG5cbiAgICBMSU5FQVI6IDAsXG4gICAgQ0FUTVVMTFJPTTogMSxcbiAgICBDQVRNVUxMUk9NX0ZPUldBUkQ6IDIsXG5cbiAgICAvL1xuXG4gICAgYWRkOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApO1xuXG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIuZ2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7XG5cbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmUoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTtcblxuICAgIH0sXG5cbiAgICAvL1xuXG4gICAgYW5pbWF0aW9uczogW10sXG5cbiAgICBpbml0OiBmdW5jdGlvbiggZGF0YSApIHtcblxuICAgICAgICBpZiAoIGRhdGEuaW5pdGlhbGl6ZWQgPT09IHRydWUgKSByZXR1cm4gZGF0YTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGtleXNcblxuICAgICAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBkYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGgrKyApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgaysrICkge1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG1pbnVzIHRpbWVzXG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPSAwO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHF1YXRlcm5pb25zXG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICEoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCBpbnN0YW5jZW9mIFRIUkVFLlF1YXRlcm5pb24gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhdCA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5mcm9tQXJyYXkoIHF1YXQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwcmVwYXJlIG1vcnBoIHRhcmdldCBrZXlzXG5cbiAgICAgICAgICAgIGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aCAmJiBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgdXNlZFxuXG4gICAgICAgICAgICAgICAgdmFyIHVzZWRNb3JwaFRhcmdldHMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbSA9IDA7IG0gPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldE5hbWUgPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRNb3JwaFRhcmdldHNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS51c2VkTW9ycGhUYXJnZXRzID0gdXNlZE1vcnBoVGFyZ2V0cztcblxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGFsbCB1c2VkIG9uIGFsbCBmcmFtZXNcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbHVlbmNlcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gdXNlZE1vcnBoVGFyZ2V0cyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIG0gPSAwOyBtIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXSA9PT0gbW9ycGhUYXJnZXROYW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlc1sgbSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG0gPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlcyA9IGluZmx1ZW5jZXM7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgb24gdGhlIHNhbWUgdGltZVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgayA9IDE7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayAtIDEgXS50aW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5zcGxpY2UoIGssIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgay0tO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gc2V0IGluZGV4XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsrKyApIHtcblxuICAgICAgICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLmluZGV4ID0gaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24oIHJvb3QgKSB7XG5cbiAgICAgICAgdmFyIHBhcnNlUmVjdXJzZUhpZXJhcmNoeSA9IGZ1bmN0aW9uKCByb290LCBoaWVyYXJjaHkgKSB7XG5cbiAgICAgICAgICAgIGhpZXJhcmNoeS5wdXNoKCByb290ICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBjID0gMDsgYyA8IHJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBjKysgKVxuICAgICAgICAgICAgICAgIHBhcnNlUmVjdXJzZUhpZXJhcmNoeSggcm9vdC5jaGlsZHJlblsgYyBdLCBoaWVyYXJjaHkgKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldHVwIGhpZXJhcmNoeVxuXG4gICAgICAgIHZhciBoaWVyYXJjaHkgPSBbXTtcblxuICAgICAgICBpZiAoIHJvb3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGIgPSAwOyBiIDwgcm9vdC5za2VsZXRvbi5ib25lcy5sZW5ndGg7IGIrKyApIHtcblxuICAgICAgICAgICAgICAgIGhpZXJhcmNoeS5wdXNoKCByb290LnNrZWxldG9uLmJvbmVzWyBiIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHBhcnNlUmVjdXJzZUhpZXJhcmNoeSggcm9vdCwgaGllcmFyY2h5ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoaWVyYXJjaHk7XG5cbiAgICB9LFxuXG4gICAgcGxheTogZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBpZiAoIHRoaXMuYW5pbWF0aW9ucy5pbmRleE9mKCBhbmltYXRpb24gKSA9PT0gLTEgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKCBhbmltYXRpb24gKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICk7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oIGRlbHRhVGltZU1TICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zWyBpIF0ucmVzZXRCbGVuZFdlaWdodHMoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbIGkgXS51cGRhdGUoIGRlbHRhVGltZU1TICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5BbmltYXRpb24gPSBmdW5jdGlvbiggcm9vdCwgZGF0YSApIHtcblxuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5pbml0KCBkYXRhICk7XG4gICAgdGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCByb290ICk7XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMubG9vcCA9IHRydWU7XG4gICAgdGhpcy53ZWlnaHQgPSAwO1xuXG4gICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSO1xuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbixcblxuICAgIGtleVR5cGVzOiBbIFwicG9zXCIsIFwicm90XCIsIFwic2NsXCIgXSxcblxuICAgIHBsYXk6IGZ1bmN0aW9uKCBzdGFydFRpbWUsIHdlaWdodCApIHtcblxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgPyBzdGFydFRpbWUgOiAwO1xuICAgICAgICB0aGlzLndlaWdodCA9IHdlaWdodCAhPT0gdW5kZWZpbmVkID8gd2VpZ2h0IDogMTtcblxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGxheSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgICAgICAgVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5zdG9wKCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG9iamVjdC5hbmltYXRpb25DYWNoZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczoge30sXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbldlaWdodDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdGVybmlvbldlaWdodDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVXZWlnaHQ6IDAuMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9ucztcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25DYWNoZSA9IGFuaW1hdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgaWYgKCBhbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjbDogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBuZXh0S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3Q6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2w6IDBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxNYXRyaXg6IG9iamVjdC5tYXRyaXhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc1sgbmFtZSBdID0gYW5pbWF0aW9uQ2FjaGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IGtleXMgdG8gbWF0Y2ggb3VyIGN1cnJlbnQgdGltZVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0KysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMua2V5VHlwZXNbIHQgXTtcblxuICAgICAgICAgICAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIDEgKTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuICAgICAgICAgICAgICAgICAgICBwcmV2S2V5ID0gbmV4dEtleTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF0gPSBwcmV2S2V5O1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcmVzZXRCbGVuZFdlaWdodHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25DYWNoZSA9IG9iamVjdC5hbmltYXRpb25DYWNoZTtcblxuICAgICAgICAgICAgaWYgKCBhbmltYXRpb25DYWNoZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJsZW5kaW5nID0gYW5pbWF0aW9uQ2FjaGUuYmxlbmRpbmc7XG5cbiAgICAgICAgICAgICAgICBibGVuZGluZy5wb3NpdGlvbldlaWdodCA9IDAuMDtcbiAgICAgICAgICAgICAgICBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID0gMC4wO1xuICAgICAgICAgICAgICAgIGJsZW5kaW5nLnNjYWxlV2VpZ2h0ID0gMC4wO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwZGF0ZTogKCBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgbmV3VmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIG5ld1F1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgIC8vIENhdG11bGwtUm9tIHNwbGluZVxuXG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZUNhdG11bGxSb20gPSBmdW5jdGlvbiggcG9pbnRzLCBzY2FsZSApIHtcblxuICAgICAgICAgICAgdmFyIGMgPSBbXSxcbiAgICAgICAgICAgICAgICB2MyA9IFtdLFxuICAgICAgICAgICAgICAgIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXG4gICAgICAgICAgICAgICAgcGEsIHBiLCBwYywgcGQ7XG5cbiAgICAgICAgICAgIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogc2NhbGU7XG4gICAgICAgICAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgICAgICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgICAgICAgICBjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xuICAgICAgICAgICAgY1sgMSBdID0gaW50UG9pbnQ7XG4gICAgICAgICAgICBjWyAyIF0gPSBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gaW50UG9pbnQgOiBpbnRQb2ludCArIDE7XG4gICAgICAgICAgICBjWyAzIF0gPSBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gaW50UG9pbnQgOiBpbnRQb2ludCArIDI7XG5cbiAgICAgICAgICAgIHBhID0gcG9pbnRzWyBjWyAwIF0gXTtcbiAgICAgICAgICAgIHBiID0gcG9pbnRzWyBjWyAxIF0gXTtcbiAgICAgICAgICAgIHBjID0gcG9pbnRzWyBjWyAyIF0gXTtcbiAgICAgICAgICAgIHBkID0gcG9pbnRzWyBjWyAzIF0gXTtcblxuICAgICAgICAgICAgdzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG4gICAgICAgICAgICB3MyA9IHdlaWdodCAqIHcyO1xuXG4gICAgICAgICAgICB2M1sgMCBdID0gaW50ZXJwb2xhdGUoIHBhWyAwIF0sIHBiWyAwIF0sIHBjWyAwIF0sIHBkWyAwIF0sIHdlaWdodCwgdzIsIHczICk7XG4gICAgICAgICAgICB2M1sgMSBdID0gaW50ZXJwb2xhdGUoIHBhWyAxIF0sIHBiWyAxIF0sIHBjWyAxIF0sIHBkWyAxIF0sIHdlaWdodCwgdzIsIHczICk7XG4gICAgICAgICAgICB2M1sgMiBdID0gaW50ZXJwb2xhdGUoIHBhWyAyIF0sIHBiWyAyIF0sIHBjWyAyIF0sIHBkWyAyIF0sIHdlaWdodCwgdzIsIHczICk7XG5cbiAgICAgICAgICAgIHJldHVybiB2MztcblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzICkge1xuXG4gICAgICAgICAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcbiAgICAgICAgICAgICAgICB2MSA9ICggcDMgLSBwMSApICogMC41O1xuXG4gICAgICAgICAgICByZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLTMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBkZWx0YSApIHtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGEgKiB0aGlzLnRpbWVTY2FsZTtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLndlaWdodCA9PT0gMCApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuY3VycmVudFRpbWUgPiBkdXJhdGlvbiB8fCB0aGlzLmN1cnJlbnRUaW1lIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5sb29wICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmN1cnJlbnRUaW1lIDwgMCApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25DYWNoZSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5hbmltYXRpb25zWyB0aGlzLmRhdGEubmFtZSBdO1xuICAgICAgICAgICAgICAgIHZhciBibGVuZGluZyA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5ibGVuZGluZztcblxuICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBwb3Mvcm90L3NjbFxuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIHQgPSAwOyB0IDwgMzsgdCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBrZXlzXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmtleVR5cGVzWyB0IF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2S2V5ID0gYW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEtleSA9IGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggdGhpcy50aW1lU2NhbGUgPiAwICYmIG5leHRLZXkudGltZSA8PSB0aGlzLmN1cnJlbnRUaW1lICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICggdGhpcy50aW1lU2NhbGUgPCAwICYmIHByZXZLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZLZXkgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldktleSA9IG5leHRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9ICggdGhpcy5jdXJyZW50VGltZSAtIHByZXZLZXkudGltZSApIC8gKCBuZXh0S2V5LnRpbWUgLSBwcmV2S2V5LnRpbWUgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlhZWiA9IHByZXZLZXlbIHR5cGUgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRYWVogPSBuZXh0S2V5WyB0eXBlIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY2FsZSA8IDAgKSBzY2FsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NhbGUgPiAxICkgc2NhbGUgPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVycG9sYXRlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcInBvc1wiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmVjdG9yLnggPSBwcmV2WFlaWyAwIF0gKyAoIG5leHRYWVpbIDAgXSAtIHByZXZYWVpbIDAgXSApICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmVjdG9yLnkgPSBwcmV2WFlaWyAxIF0gKyAoIG5leHRYWVpbIDEgXSAtIHByZXZYWVpbIDEgXSApICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmVjdG9yLnogPSBwcmV2WFlaWyAyIF0gKyAoIG5leHRYWVpbIDIgXSAtIHByZXZYWVpbIDIgXSApICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5wb3NpdGlvbi5sZXJwKCBuZXdWZWN0b3IsIHByb3BvcnRpb25hbFdlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbIDAgXSA9IHRoaXMuZ2V0UHJldktleVdpdGgoIFwicG9zXCIsIGgsIHByZXZLZXkuaW5kZXggLSAxIClbIFwicG9zXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbIDEgXSA9IHByZXZYWVo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWyAyIF0gPSBuZXh0WFlaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sgMyBdID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJwb3NcIiwgaCwgbmV4dEtleS5pbmRleCArIDEgKVsgXCJwb3NcIiBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSAqIDAuMzMgKyAwLjMzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQb2ludCA9IGludGVycG9sYXRlQ2F0bXVsbFJvbSggcG9pbnRzLCBzY2FsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmxlbmRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBvYmplY3QucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWN0b3IueCA9IHZlY3Rvci54ICsgKCBjdXJyZW50UG9pbnRbIDAgXSAtIHZlY3Rvci54ICkgKiBwcm9wb3J0aW9uYWxXZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjdG9yLnkgPSB2ZWN0b3IueSArICggY3VycmVudFBvaW50WyAxIF0gLSB2ZWN0b3IueSApICogcHJvcG9ydGlvbmFsV2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlY3Rvci56ID0gdmVjdG9yLnogKyAoIGN1cnJlbnRQb2ludFsgMiBdIC0gdmVjdG9yLnogKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcndhcmRQb2ludCA9IGludGVycG9sYXRlQ2F0bXVsbFJvbSggcG9pbnRzLCBzY2FsZSAqIDEuMDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0KCBmb3J3YXJkUG9pbnRbIDAgXSwgZm9yd2FyZFBvaW50WyAxIF0sIGZvcndhcmRQb2ludFsgMiBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zdWIoIHZlY3RvciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQueSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKCB0YXJnZXQueCwgdGFyZ2V0LnogKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJvdGF0aW9uLnNldCggMCwgYW5nbGUsIDAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHR5cGUgPT09IFwicm90XCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIHByZXZYWVosIG5leHRYWVosIG5ld1F1YXQsIHNjYWxlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHBheWluZyB0aGUgY29zdCBvZiBhbiBhZGRpdGlvbmFsIHNsZXJwIGlmIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIG5ld1F1YXQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwKCBvYmplY3QucXVhdGVybmlvbiwgbmV3UXVhdCwgb2JqZWN0LnF1YXRlcm5pb24sIHByb3BvcnRpb25hbFdlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCB0eXBlID09PSBcInNjbFwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmVjdG9yLnogPSBwcmV2WFlaWyAyIF0gKyAoIG5leHRYWVpbIDIgXSAtIHByZXZYWVpbIDIgXSApICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5zY2FsZVdlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNjYWxlLmxlcnAoIG5ld1ZlY3RvciwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuZGluZy5zY2FsZVdlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfTtcblxuICAgIH0gKSgpLFxuXG4gICAgZ2V0TmV4dEtleVdpdGg6IGZ1bmN0aW9uKCB0eXBlLCBoLCBrZXkgKSB7XG5cbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcblxuICAgICAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cbiAgICAgICAgICAgIGtleSA9IGtleSA8IGtleXMubGVuZ3RoIC0gMSA/IGtleSA6IGtleXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggOyBrZXkgPCBrZXlzLmxlbmd0aDsga2V5KysgKSB7XG5cbiAgICAgICAgICAgIGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXG4gICAgfSxcblxuICAgIGdldFByZXZLZXlXaXRoOiBmdW5jdGlvbiggdHlwZSwgaCwga2V5ICkge1xuXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG5cbiAgICAgICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICAgICAgICBrZXkgPSBrZXkgPiAwID8ga2V5IDogMDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGZvciAoIDsga2V5ID49IDA7IGtleS0tICkge1xuXG4gICAgICAgICAgICBpZiAoIGtleXNbIGtleSBdWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL0tleUZyYW1lQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBraGFuZyBkdW9uZ1xuICogQGF1dGhvciBlcmlrIGtpdHNvblxuICovXG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cbiAgICB0aGlzLnJvb3QgPSBkYXRhLm5vZGU7XG4gICAgdGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5pbml0KCBkYXRhICk7XG4gICAgdGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCB0aGlzLnJvb3QgKTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLnRpbWVTY2FsZSA9IDAuMDAxO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcblxuICAgIC8vIGluaXRpYWxpemUgdG8gZmlyc3Qga2V5ZnJhbWVzXG5cbiAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLFxuICAgICAgICAgICAgc2lkcyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5zaWRzLFxuICAgICAgICAgICAgb2JqID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgICBpZiAoIGtleXMubGVuZ3RoICYmIHNpZHMgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBzID0gMDsgcyA8IHNpZHMubGVuZ3RoOyBzKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2lkID0gc2lkc1sgcyBdLFxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggc2lkLCBoLCAwICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG5leHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV4dC5hcHBseSggc2lkICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICAgICAgb2JqLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLktleUZyYW1lQW5pbWF0aW9uLFxuXG4gICAgcGxheTogZnVuY3Rpb24oIHN0YXJ0VGltZSApIHtcblxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgPyBzdGFydFRpbWUgOiAwO1xuXG4gICAgICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGtleSBjYWNoZVxuXG4gICAgICAgICAgICB2YXIgaCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgICAgIGZvciAoIGggPSAwOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgICAgICAgICAgIGlmICggbm9kZS5hbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5uZXh0S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeCA9IG9iamVjdC5tYXRyaXg7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBrZXlzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBrZXlzWyAwIF07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IGtleXNbIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IE1hdGgubWluKCBrZXlzWyAwIF0udGltZSwgdGhpcy5zdGFydFRpbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRUaW1lID0gTWF0aC5tYXgoIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdLnRpbWUsIHRoaXMuZW5kVGltZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5zdG9wKCB0aGlzICk7XG5cbiAgICAgICAgLy8gcmVzZXQgSklUIG1hdHJpeCBhbmQgcmVtb3ZlIGNhY2hlXG5cbiAgICAgICAgZm9yICggdmFyIGggPSAwOyBoIDwgdGhpcy5kYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGgrKyApIHtcblxuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgICAgICAgaWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBub2RlLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4O1xuXG4gICAgICAgICAgICAgICAgb3JpZ2luYWwuY29weSggb2JqLm1hdHJpeCApO1xuICAgICAgICAgICAgICAgIG9iai5tYXRyaXggPSBvcmlnaW5hbDtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLmFuaW1hdGlvbkNhY2hlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oIGRlbHRhICkge1xuXG4gICAgICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGEgKiB0aGlzLnRpbWVTY2FsZTtcblxuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCB0aGlzLmxvb3AgPT09IHRydWUgJiYgdGhpcy5jdXJyZW50VGltZSA+IGR1cmF0aW9uICkge1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICU9IGR1cmF0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIGR1cmF0aW9uICk7XG5cbiAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gbm9kZS5rZXlzLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlID0gbm9kZS5hbmltYXRpb25DYWNoZTtcblxuXG4gICAgICAgICAgICBpZiAoIGtleXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5O1xuICAgICAgICAgICAgICAgIHZhciBuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleTtcblxuICAgICAgICAgICAgICAgIGlmICggbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2S2V5ID0gbmV4dEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRLZXkgPSBrZXlzWyBwcmV2S2V5LmluZGV4ICsgMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZS5wcmV2S2V5ID0gcHJldktleTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IG5leHRLZXk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG5leHRLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIHRoaXMuY3VycmVudFRpbWUgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCBuZXh0S2V5LnRpbWUgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXROZXh0S2V5V2l0aDogZnVuY3Rpb24oIHNpZCwgaCwga2V5ICkge1xuXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG4gICAgICAgIGtleSA9IGtleSAlIGtleXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSsrICkge1xuXG4gICAgICAgICAgICBpZiAoIGtleXNbIGtleSBdLmhhc1RhcmdldCggc2lkICkgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1sga2V5IF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXNbIDAgXTtcblxuICAgIH0sXG5cbiAgICBnZXRQcmV2S2V5V2l0aDogZnVuY3Rpb24oIHNpZCwgaCwga2V5ICkge1xuXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG4gICAgICAgIGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBrZXkgPj0gMDsga2V5LS0gKSB7XG5cbiAgICAgICAgICAgIGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vTW9ycGhBbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKiBAYXV0aG9yIHdpbGx5LXZ2dSAvIGh0dHA6Ly93aWxseS12dnUuZ2l0aHViLmlvXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltYXRpb24gPSBmdW5jdGlvbiggbWVzaCApIHtcblxuICAgIHRoaXMubWVzaCA9IG1lc2g7XG4gICAgdGhpcy5mcmFtZXMgPSBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IDEwMDA7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RGcmFtZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk1vcnBoQW5pbWF0aW9uLFxuXG4gICAgcGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG4gICAgfSxcblxuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oIGRlbHRhICkge1xuXG4gICAgICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGE7XG5cbiAgICAgICAgaWYgKCB0aGlzLmxvb3AgPT09IHRydWUgJiYgdGhpcy5jdXJyZW50VGltZSA+IHRoaXMuZHVyYXRpb24gKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IE1hdGgubWluKCB0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmR1cmF0aW9uICk7XG5cbiAgICAgICAgdmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmZyYW1lcztcbiAgICAgICAgdmFyIGZyYW1lID0gTWF0aC5mbG9vciggdGhpcy5jdXJyZW50VGltZSAvIGZyYW1lVGltZSApO1xuXG4gICAgICAgIHZhciBpbmZsdWVuY2VzID0gdGhpcy5tZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgICAgICBpZiAoIGZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSApIHtcblxuICAgICAgICAgICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0RnJhbWUgXSA9IDA7XG4gICAgICAgICAgICBpbmZsdWVuY2VzWyB0aGlzLmN1cnJlbnRGcmFtZSBdID0gMTtcbiAgICAgICAgICAgIGluZmx1ZW5jZXNbIGZyYW1lIF0gPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmxhc3RGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1peCA9ICggdGhpcy5jdXJyZW50VGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG4gICAgICAgIGluZmx1ZW5jZXNbIGZyYW1lIF0gPSBtaXg7XG4gICAgICAgIGluZmx1ZW5jZXNbIHRoaXMubGFzdEZyYW1lIF0gPSAxIC0gbWl4O1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Cb3hHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xuICovXG5cblRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgICAgICBkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG4gICAgfTtcblxuICAgIHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcbiAgICB0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcbiAgICB0aGlzLmRlcHRoU2VnbWVudHMgPSBkZXB0aFNlZ21lbnRzIHx8IDE7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgZGVwdGhfaGFsZiA9IGRlcHRoIC8gMjtcblxuICAgIGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtMSwgLTEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoX2hhbGYsIDAgKTsgLy8gcHhcbiAgICBidWlsZFBsYW5lKCAneicsICd5JywgMSwgLTEsIGRlcHRoLCBoZWlnaHQsIC13aWR0aF9oYWxmLCAxICk7IC8vIG54XG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneicsIDEsIDEsIHdpZHRoLCBkZXB0aCwgaGVpZ2h0X2hhbGYsIDIgKTsgLy8gcHlcbiAgICBidWlsZFBsYW5lKCAneCcsICd6JywgMSwgLTEsIHdpZHRoLCBkZXB0aCwgLWhlaWdodF9oYWxmLCAzICk7IC8vIG55XG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneScsIDEsIC0xLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aF9oYWxmLCA0ICk7IC8vIHB6XG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneScsIC0xLCAtMSwgd2lkdGgsIGhlaWdodCwgLWRlcHRoX2hhbGYsIDUgKTsgLy8gbnpcblxuICAgIGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgICAgIHZhciB3LCBpeCwgaXksXG4gICAgICAgICAgICBncmlkWCA9IHNjb3BlLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICBncmlkWSA9IHNjb3BlLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMixcbiAgICAgICAgICAgIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIG9mZnNldCA9IHNjb3BlLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd4JyApICkge1xuXG4gICAgICAgICAgICB3ID0gJ3onO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd6JyApIHx8ICggdSA9PT0gJ3onICYmIHYgPT09ICd4JyApICkge1xuXG4gICAgICAgICAgICB3ID0gJ3knO1xuICAgICAgICAgICAgZ3JpZFkgPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoICggdSA9PT0gJ3onICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd6JyApICkge1xuXG4gICAgICAgICAgICB3ID0gJ3gnO1xuICAgICAgICAgICAgZ3JpZFggPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JpZFgxID0gZ3JpZFggKyAxLFxuICAgICAgICAgICAgZ3JpZFkxID0gZ3JpZFkgKyAxLFxuICAgICAgICAgICAgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFgsXG4gICAgICAgICAgICBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZLFxuICAgICAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICBub3JtYWxbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtMTtcblxuICAgICAgICBmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSsrICkge1xuXG4gICAgICAgICAgICBmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICAgICAgdmVjdG9yWyB1IF0gPSAoIGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGYgKSAqIHVkaXI7XG4gICAgICAgICAgICAgICAgdmVjdG9yWyB2IF0gPSAoIGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZiApICogdmRpcjtcbiAgICAgICAgICAgICAgICB2ZWN0b3JbIHcgXSA9IGRlcHRoO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUudmVydGljZXMucHVzaCggdmVjdG9yICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSsrICkge1xuXG4gICAgICAgICAgICBmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4KysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuICAgICAgICAgICAgICAgIHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcbiAgICAgICAgICAgICAgICB2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcbiAgICAgICAgICAgICAgICB2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xuICAgICAgICAgICAgICAgIHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEgKyBvZmZzZXQsIGIgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcbiAgICAgICAgICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICAgICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xuICAgICAgICAgICAgICAgIGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiICsgb2Zmc2V0LCBjICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcbiAgICAgICAgICAgICAgICBmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG59O1xuXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEdlb21ldHJ5O1xuXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGVwdGgsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5kZXB0aFNlZ21lbnRzXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuVEhSRUUuQ3ViZUdlb21ldHJ5ID0gVEhSRUUuQm94R2VvbWV0cnk7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBodWdoZXNcbiAqL1xuXG5USFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIH07XG5cbiAgICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG4gICAgc2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICkgOiA4O1xuXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgaSwgdXZzID0gW10sXG4gICAgICAgIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIGNlbnRlclVWID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAuNSwgMC41ICk7XG5cbiAgICB0aGlzLnZlcnRpY2VzLnB1c2goIGNlbnRlciApO1xuICAgIHV2cy5wdXNoKCBjZW50ZXJVViApO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkrKyApIHtcblxuICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cbiAgICAgICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuICAgICAgICB2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcbiAgICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gcmFkaXVzICsgMSApIC8gMiwgKCB2ZXJ0ZXgueSAvIHJhZGl1cyArIDEgKSAvIDIgKSApO1xuXG4gICAgfVxuXG4gICAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gICAgZm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkrKyApIHtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggaSwgaSArIDEsIDAsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGkgXS5jbG9uZSgpLCB1dnNbIGkgKyAxIF0uY2xvbmUoKSwgY2VudGVyVVYuY2xvbmUoKSBdICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUdlb21ldHJ5O1xuXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ2lyY2xlQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIH07XG5cbiAgICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG4gICAgc2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICkgOiA4O1xuXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgdmVydGljZXMgPSBzZWdtZW50cyArIDI7XG5cbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKiAzICk7XG4gICAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcbiAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKiAyICk7XG5cbiAgICAvLyBjZW50ZXIgZGF0YSBpcyBhbHJlYWR5IHplcm8sIGJ1dCBuZWVkIHRvIHNldCBhIGZldyBleHRyYXNcbiAgICBub3JtYWxzWyAzIF0gPSAxLjA7XG4gICAgdXZzWyAwIF0gPSAwLjU7XG4gICAgdXZzWyAxIF0gPSAwLjU7XG5cbiAgICBmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDI7IHMgPD0gc2VnbWVudHM7IHMrKywgaSArPSAzLCBpaSArPSAyICkge1xuXG4gICAgICAgIHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG4gICAgICAgIHBvc2l0aW9uc1sgaSBdID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICAgICAgcG9zaXRpb25zWyBpICsgMSBdID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuICAgICAgICBub3JtYWxzWyBpICsgMiBdID0gMTsgLy8gbm9ybWFsIHpcblxuICAgICAgICB1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcbiAgICAgICAgdXZzWyBpaSArIDEgXSA9ICggcG9zaXRpb25zWyBpICsgMSBdIC8gcmFkaXVzICsgMSApIC8gMjtcblxuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkrKyApIHtcblxuICAgICAgICBpbmRpY2VzLnB1c2goIGkgKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKCBpICsgMSApO1xuICAgICAgICBpbmRpY2VzLnB1c2goIDAgKTtcblxuICAgIH1cblxuICAgIHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggaW5kaWNlcyApLCAxICkgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5O1xuXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuICAgICAgICByYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgICAgICBvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcblxuICAgIHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XG4gICAgcmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IDEwMDtcblxuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgICBoZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG5cbiAgICBvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xuICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IDIgKiBNYXRoLlBJO1xuXG4gICAgdmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xuXG4gICAgdmFyIHgsIHksIHZlcnRpY2VzID0gW10sXG4gICAgICAgIHV2cyA9IFtdO1xuXG4gICAgZm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkrKyApIHtcblxuICAgICAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcbiAgICAgICAgdmFyIHV2c1JvdyA9IFtdO1xuXG4gICAgICAgIHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuICAgICAgICB2YXIgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XG5cbiAgICAgICAgZm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHgrKyApIHtcblxuICAgICAgICAgICAgdmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLnNpbiggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xuICAgICAgICAgICAgdmVydGV4LnkgPSAtdiAqIGhlaWdodCArIGhlaWdodEhhbGY7XG4gICAgICAgICAgICB2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgICAgICAgIHZlcnRpY2VzUm93LnB1c2goIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSApO1xuICAgICAgICAgICAgdXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG4gICAgICAgIHV2cy5wdXNoKCB1dnNSb3cgKTtcblxuICAgIH1cblxuICAgIHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG4gICAgdmFyIG5hLCBuYjtcblxuICAgIGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHgrKyApIHtcblxuICAgICAgICBpZiAoIHJhZGl1c1RvcCAhPT0gMCApIHtcblxuICAgICAgICAgICAgbmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4IF0gXS5jbG9uZSgpO1xuICAgICAgICAgICAgbmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggXSBdLmNsb25lKCk7XG4gICAgICAgICAgICBuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBuYS5zZXRZKCBNYXRoLnNxcnQoIG5hLnggKiBuYS54ICsgbmEueiAqIG5hLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XG4gICAgICAgIG5iLnNldFkoIE1hdGguc3FydCggbmIueCAqIG5iLnggKyBuYi56ICogbmIueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggXTtcbiAgICAgICAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG4gICAgICAgICAgICB2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcbiAgICAgICAgICAgIHZhciB2NCA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XG5cbiAgICAgICAgICAgIHZhciBuMSA9IG5hLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbjIgPSBuYS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIG4zID0gbmIuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBuNCA9IG5iLmNsb25lKCk7XG5cbiAgICAgICAgICAgIHZhciB1djEgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciB1djMgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciB1djQgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2NCwgWyBuMSwgbjIsIG40IF0gKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXY0IF0gKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYyLCB2MywgdjQsIFsgbjIuY2xvbmUoKSwgbjMsIG40LmNsb25lKCkgXSApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Mi5jbG9uZSgpLCB1djMsIHV2NC5jbG9uZSgpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB0b3AgY2FwXG5cbiAgICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzVG9wID4gMCApIHtcblxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCBoZWlnaHRIYWxmLCAwICkgKTtcblxuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyAwIF1bIHggXTtcbiAgICAgICAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyAwIF1bIHggKyAxIF07XG4gICAgICAgICAgICB2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG4gICAgICAgICAgICB2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuICAgICAgICAgICAgdmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuICAgICAgICAgICAgdmFyIHV2MSA9IHV2c1sgMCBdWyB4IF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciB1djIgPSB1dnNbIDAgXVsgeCArIDEgXS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMCApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMSApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGJvdHRvbSBjYXBcblxuICAgIGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNCb3R0b20gPiAwICkge1xuXG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC1oZWlnaHRIYWxmLCAwICkgKTtcblxuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdO1xuICAgICAgICAgICAgdmFyIHYyID0gdmVydGljZXNbIGhlaWdodFNlZ21lbnRzIF1bIHggXTtcbiAgICAgICAgICAgIHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgdmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0xLCAwICk7XG4gICAgICAgICAgICB2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTEsIDAgKTtcbiAgICAgICAgICAgIHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtMSwgMCApO1xuXG4gICAgICAgICAgICB2YXIgdXYxID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgdXYyID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciB1djMgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYyLngsIDEgKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdLCB1bmRlZmluZWQsIDIgKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DeWxpbmRlckdlb21ldHJ5O1xuXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXNUb3AsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXNCb3R0b20sXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMub3BlbkVuZGVkLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRWRnZXNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkVkZ2VzR2VvbWV0cnkgPSBmdW5jdGlvbiggZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICkge1xuXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhyZXNob2xkQW5nbGUgPSAoIHRocmVzaG9sZEFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IHRocmVzaG9sZEFuZ2xlIDogMTtcblxuICAgIHZhciB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhyZXNob2xkQW5nbGUgKSApO1xuXG4gICAgdmFyIGVkZ2UgPSBbIDAsIDAgXSxcbiAgICAgICAgaGFzaCA9IHt9O1xuICAgIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICByZXR1cm4gYSAtIGI7XG5cbiAgICB9O1xuXG4gICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICAgIHZhciBnZW9tZXRyeTI7XG5cbiAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkyID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgZ2VvbWV0cnkyID0gZ2VvbWV0cnkuY2xvbmUoKTtcblxuICAgIH1cblxuICAgIGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XG4gICAgZ2VvbWV0cnkyLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xuICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaisrICkge1xuXG4gICAgICAgICAgICBlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcbiAgICAgICAgICAgIGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xuICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuICAgICAgICAgICAgdmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgaGFzaFsga2V5IF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnQxOiBlZGdlWyAwIF0sXG4gICAgICAgICAgICAgICAgICAgIHZlcnQyOiBlZGdlWyAxIF0sXG4gICAgICAgICAgICAgICAgICAgIGZhY2UxOiBpLFxuICAgICAgICAgICAgICAgICAgICBmYWNlMjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXS5mYWNlMiA9IGk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gW107XG5cbiAgICBmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XG5cbiAgICAgICAgdmFyIGggPSBoYXNoWyBrZXkgXTtcblxuICAgICAgICBpZiAoIGguZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgaC5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBoLmZhY2UyIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDEgXTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDIgXTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggY29vcmRzICksIDMgKSApO1xuXG59O1xuXG5USFJFRS5FZGdlc0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0dlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9FeHRydWRlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcbiAqXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZVBhdGg+IC8vIDNkIHNwbGluZSBwYXRoIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmcuIChjcmVhdGVzIEZyYW1lcyBpZiAuZnJhbWVzIGFyZW4ndCBkZWZpbmVkKVxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcbiAqXG4gKiAgdXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKiovXG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgICBpZiAoIHR5cGVvZiggc2hhcGVzICkgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cbiAgICAgICAgc2hhcGVzID0gW107XG4gICAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xuXG4gICAgc2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG4gICAgdGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXG4gICAgLy8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXG4gICAgLy8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xuXG4gICAgLy90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcblxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gICAgdmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcblxuICAgIGZvciAoIHZhciBzID0gMDsgcyA8IHNsOyBzKysgKSB7XG5cbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG4gICAgICAgIHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiggc2hhcGUsIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgYW1vdW50ID0gb3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW1vdW50IDogMTAwO1xuXG4gICAgdmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXG4gICAgdmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxuICAgIHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xuXG4gICAgdmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXG5cbiAgICB2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cbiAgICB2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcblxuICAgIHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG4gICAgdmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblxuICAgIC8vIFVzZSBkZWZhdWx0IFdvcmxkVVZHZW5lcmF0b3IgaWYgbm8gVVYgZ2VuZXJhdG9ycyBhcmUgc3BlY2lmaWVkLlxuICAgIHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcblxuICAgIHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XG4gICAgaWYgKCBleHRydWRlUGF0aCApIHtcblxuICAgICAgICBleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xuXG4gICAgICAgIGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuICAgICAgICBiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXG5cbiAgICAgICAgLy8gU0VUVVAgVE5CIHZhcmlhYmxlc1xuXG4gICAgICAgIC8vIFJldXNlIFROQiBmcm9tIFR1YmVHZW9tdHJ5IGZvciBub3cuXG4gICAgICAgIC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cbiAgICAgICAgc3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBleHRydWRlUGF0aCwgc3RlcHMsIGZhbHNlICk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XG5cbiAgICAgICAgYmlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBwb3NpdGlvbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgfVxuXG4gICAgLy8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cbiAgICBpZiAoICFiZXZlbEVuYWJsZWQgKSB7XG5cbiAgICAgICAgYmV2ZWxTZWdtZW50cyA9IDA7XG4gICAgICAgIGJldmVsVGhpY2tuZXNzID0gMDtcbiAgICAgICAgYmV2ZWxTaXplID0gMDtcblxuICAgIH1cblxuICAgIC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxuXG4gICAgdmFyIGFob2xlLCBoLCBobDsgLy8gbG9vcGluZyBvZiBob2xlc1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICB2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cbiAgICB2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcbiAgICB2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuICAgIHZhciByZXZlcnNlID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG4gICAgaWYgKCByZXZlcnNlICkge1xuXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG4gICAgICAgIC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cbiAgICAgICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG4gICAgICAgICAgICBpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG4gICAgICAgICAgICAgICAgaG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXG5cbiAgICB9XG5cblxuICAgIHZhciBmYWNlcyA9IFRIUkVFLlNoYXBlLlV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG4gICAgLyogVmVydGljZXMgKi9cblxuICAgIHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cbiAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcblxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc2NhbGVQdDIoIHB0LCB2ZWMsIHNpemUgKSB7XG5cbiAgICAgICAgaWYgKCAhdmVjICkgY29uc29sZS5lcnJvciggXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFwiICk7XG5cbiAgICAgICAgcmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xuXG4gICAgfVxuXG4gICAgdmFyIGIsIGJzLCB0LCB6LFxuICAgICAgICB2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG5cbiAgICAvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XG5cblxuICAgIGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuICAgICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgICAvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXG4gICAgICAgIC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcbiAgICAgICAgLy8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXG4gICAgICAgIC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXG5cbiAgICAgICAgdmFyIHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnkgPSAxOyAvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XG5cbiAgICAgICAgLy8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxuICAgICAgICAvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxuXG4gICAgICAgIHZhciB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LFxuICAgICAgICAgICAgdl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcbiAgICAgICAgdmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsXG4gICAgICAgICAgICB2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xuXG4gICAgICAgIHZhciB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuICAgICAgICB2YXIgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuICAgICAgICBpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBFUFNJTE9OICkge1xuXG4gICAgICAgICAgICAvLyBub3QgY29sbGluZWFyXG5cbiAgICAgICAgICAgIC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXG4gICAgICAgICAgICB2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG4gICAgICAgICAgICB2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcblxuICAgICAgICAgICAgLy8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxuXG4gICAgICAgICAgICB2YXIgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcbiAgICAgICAgICAgIHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xuXG4gICAgICAgICAgICB2YXIgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcbiAgICAgICAgICAgIHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xuXG4gICAgICAgICAgICAvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG4gICAgICAgICAgICB2YXIgc2YgPSAoICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cbiAgICAgICAgICAgICAgICAgICAgKCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggKSAvXG4gICAgICAgICAgICAgICAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG4gICAgICAgICAgICAvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG4gICAgICAgICAgICB2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG4gICAgICAgICAgICB2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XG5cbiAgICAgICAgICAgIC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG4gICAgICAgICAgICAvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG4gICAgICAgICAgICB2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XG4gICAgICAgICAgICBpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIGNvbGxpbmVhciBlZGdlc1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7IC8vIGFzc3VtZXM6IG9wcG9zaXRlXG4gICAgICAgICAgICBpZiAoIHZfcHJldl94ID4gRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgICAgIGlmICggdl9uZXh0X3ggPiBFUFNJTE9OICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2X3ByZXZfeCA8IC1FUFNJTE9OICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdl9uZXh0X3ggPCAtRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBkaXJlY3Rpb25fZXEgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuICAgICAgICAgICAgICAgIHZfdHJhbnNfeCA9IC12X3ByZXZfeTtcbiAgICAgICAgICAgICAgICB2X3RyYW5zX3kgPSB2X3ByZXZfeDtcbiAgICAgICAgICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG4gICAgICAgICAgICAgICAgdl90cmFuc194ID0gdl9wcmV2X3g7XG4gICAgICAgICAgICAgICAgdl90cmFuc195ID0gdl9wcmV2X3k7XG4gICAgICAgICAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG4gICAgfVxuXG5cbiAgICB2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSsrLCBqKyssIGsrKyApIHtcblxuICAgICAgICBpZiAoIGogPT09IGlsICkgaiA9IDA7XG4gICAgICAgIGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuICAgICAgICAvLyAgKGopLS0tKGkpLS0tKGspXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG4gICAgICAgIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XG5cbiAgICB9XG5cbiAgICB2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSxcbiAgICAgICAgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXG4gICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG5cbiAgICAgICAgb25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkrKywgaisrLCBrKysgKSB7XG5cbiAgICAgICAgICAgIGlmICggaiA9PT0gaWwgKSBqID0gMDtcbiAgICAgICAgICAgIGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuICAgICAgICAgICAgLy8gIChqKS0tLShpKS0tLShrKVxuICAgICAgICAgICAgb25lSG9sZU1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuICAgICAgICB2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuICAgIGZvciAoIGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYisrICkge1xuXG4gICAgICAgIC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xuXG4gICAgICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICAgICAgeiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuXG4gICAgICAgIC8veiA9IGJldmVsVGhpY2tuZXNzICogdDtcbiAgICAgICAgYnMgPSBiZXZlbFNpemUgKiAoIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKSApOyAvLyBjdXJ2ZWRcbiAgICAgICAgLy9icyA9IGJldmVsU2l6ZSAqIHQ7IC8vIGxpbmVhclxuXG4gICAgICAgIC8vIGNvbnRyYWN0IHNoYXBlXG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXG4gICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgLXogKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXhwYW5kIGhvbGVzXG5cbiAgICAgICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuICAgICAgICAgICAgb25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgICAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCAteiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYnMgPSBiZXZlbFNpemU7XG5cbiAgICAvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCB2bGVuOyBpKysgKSB7XG5cbiAgICAgICAgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuICAgICAgICBpZiAoICFleHRydWRlQnlQYXRoICkge1xuXG4gICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cbiAgICAgICAgICAgIG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcbiAgICAgICAgICAgIGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuICAgICAgICAgICAgdiggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXG4gICAgLy8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG4gICAgdmFyIHM7XG5cbiAgICBmb3IgKCBzID0gMTsgcyA8PSBzdGVwczsgcysrICkge1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSsrICkge1xuXG4gICAgICAgICAgICB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoICFleHRydWRlQnlQYXRoICkge1xuXG4gICAgICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcblxuICAgICAgICAgICAgICAgIG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcbiAgICAgICAgICAgICAgICBiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xuXG4gICAgICAgICAgICAgICAgdiggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXG5cbiAgICAvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG4gICAgZm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGItLSApIHtcblxuICAgICAgICB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG4gICAgICAgIHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcbiAgICAgICAgLy9icyA9IGJldmVsU2l6ZSAqICggMS1NYXRoLnNpbiAoICggMSAtIHQgKSAqIE1hdGguUEkvMiApICk7XG4gICAgICAgIGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xuXG4gICAgICAgIC8vIGNvbnRyYWN0IHNoYXBlXG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksIGFtb3VudCArIHogKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXhwYW5kIGhvbGVzXG5cbiAgICAgICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuICAgICAgICAgICAgb25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgICAgICAgICAgICAgIGlmICggIWV4dHJ1ZGVCeVBhdGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksIGFtb3VudCArIHogKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiBGYWNlcyAqL1xuXG4gICAgLy8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuICAgIGJ1aWxkTGlkRmFjZXMoKTtcblxuICAgIC8vIFNpZGVzIGZhY2VzXG5cbiAgICBidWlsZFNpZGVGYWNlcygpO1xuXG5cbiAgICAvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXG5cbiAgICBmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xuXG4gICAgICAgIGlmICggYmV2ZWxFbmFibGVkICkge1xuXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cbiAgICAgICAgICAgIC8vIEJvdHRvbSBmYWNlc1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICAgICAgICAgIGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG4gICAgICAgICAgICAvLyBUb3AgZmFjZXNcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQm90dG9tIGZhY2VzXG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUb3AgZmFjZXNcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcblxuICAgIGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xuXG4gICAgICAgIHZhciBsYXllcm9mZnNldCA9IDA7XG4gICAgICAgIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcbiAgICAgICAgbGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuICAgICAgICAgICAgc2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuICAgICAgICAgICAgLy8sIHRydWVcbiAgICAgICAgICAgIGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG4gICAgICAgIHZhciBqLCBrO1xuICAgICAgICBpID0gY29udG91ci5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCAtLWkgPj0gMCApIHtcblxuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICBrID0gaSAtIDE7XG4gICAgICAgICAgICBpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHZhciBzID0gMCxcbiAgICAgICAgICAgICAgICBzbCA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cbiAgICAgICAgICAgIGZvciAoIHMgPSAwOyBzIDwgc2w7IHMrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBzbGVuMSA9IHZsZW4gKiBzO1xuICAgICAgICAgICAgICAgIHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxuICAgICAgICAgICAgICAgICAgICBiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG4gICAgICAgICAgICAgICAgICAgIGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcbiAgICAgICAgICAgICAgICAgICAgZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xuXG4gICAgICAgICAgICAgICAgZjQoIGEsIGIsIGMsIGQsIGNvbnRvdXIsIHMsIHNsLCBqLCBrICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XG5cbiAgICAgICAgc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZjMoIGEsIGIsIGMgKSB7XG5cbiAgICAgICAgYSArPSBzaGFwZXNPZmZzZXQ7XG4gICAgICAgIGIgKz0gc2hhcGVzT2Zmc2V0O1xuICAgICAgICBjICs9IHNoYXBlc09mZnNldDtcblxuICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMgKSApO1xuXG4gICAgICAgIHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xuXG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkLCB3YWxsQ29udG91ciwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApIHtcblxuICAgICAgICBhICs9IHNoYXBlc09mZnNldDtcbiAgICAgICAgYiArPSBzaGFwZXNPZmZzZXQ7XG4gICAgICAgIGMgKz0gc2hhcGVzT2Zmc2V0O1xuICAgICAgICBkICs9IHNoYXBlc09mZnNldDtcblxuICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXG4gICAgICAgIHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBhLCBiLCBjLCBkICk7XG5cbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAwIF0sIHV2c1sgMSBdLCB1dnNbIDMgXSBdICk7XG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMSBdLCB1dnNbIDIgXSwgdXZzWyAzIF0gXSApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcblxuICAgIGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgICB2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcbiAgICAgICAgdmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XG4gICAgICAgIHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYS54LCBhLnkgKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIGIueSApLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcbiAgICAgICAgXTtcblxuICAgIH0sXG5cbiAgICBnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICAgIHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuICAgICAgICB2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcbiAgICAgICAgdmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG4gICAgICAgIHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xuXG4gICAgICAgIGlmICggTWF0aC5hYnMoIGEueSAtIGIueSApIDwgMC4wMSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYS54LCAxIC0gYS56ICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGIueCwgMSAtIGIueiApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIDEgLSBjLnogKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggZC54LCAxIC0gZC56IClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYS55LCAxIC0gYS56ICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGIueSwgMSAtIGIueiApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLnksIDEgLSBjLnogKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggZC55LCAxIC0gZC56IClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgfVxuXG4gICAgfVxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU2hhcGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxuICpcbiAqIENyZWF0ZXMgYSBvbmUtc2lkZWQgcG9seWdvbmFsIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLiBTaW1pbGFyIHRvXG4gKiBFeHRydWRlR2VvbWV0cnkuXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqXG4gKlx0Y3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlcy4gTk9UIFVTRUQgQVQgVEhFIE1PTUVOVC5cbiAqXG4gKlx0bWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xuICpcdHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gKlxuICogfVxuICoqL1xuXG5USFJFRS5TaGFwZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTaGFwZUdlb21ldHJ5JztcblxuICAgIGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcblxuICAgIHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlR2VvbWV0cnk7XG5cbi8qKlxuICogQWRkIGFuIGFycmF5IG9mIHNoYXBlcyB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LlxuICovXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB0aGlzLmFkZFNoYXBlKCBzaGFwZXNbIGkgXSwgb3B0aW9ucyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiggc2hhcGUsIG9wdGlvbnMgKSB7XG5cbiAgICBpZiAoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICAgIHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgPT09IHVuZGVmaW5lZCA/IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yIDogb3B0aW9ucy5VVkdlbmVyYXRvcjtcblxuICAgIC8vXG5cbiAgICB2YXIgaSwgbCwgaG9sZTtcblxuICAgIHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICB2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cbiAgICB2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcbiAgICB2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuICAgIHZhciByZXZlcnNlID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG4gICAgaWYgKCByZXZlcnNlICkge1xuXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG4gICAgICAgIC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUuLi5cblxuICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgaG9sZSA9IGhvbGVzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcblxuICAgICAgICAgICAgICAgIGhvbGVzWyBpIF0gPSBob2xlLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXZlcnNlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICB2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuICAgIC8vIFZlcnRpY2VzXG5cbiAgICBmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICBob2xlID0gaG9sZXNbIGkgXTtcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGhvbGUgKTtcblxuICAgIH1cblxuICAgIC8vXG5cbiAgICB2YXIgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICB2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSsrICkge1xuXG4gICAgICAgIHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnQueCwgdmVydC55LCAwICkgKTtcblxuICAgIH1cblxuICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSsrICkge1xuXG4gICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgIHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xuICAgICAgICB2YXIgYiA9IGZhY2VbIDEgXSArIHNoYXBlc09mZnNldDtcbiAgICAgICAgdmFyIGMgPSBmYWNlWyAyIF0gKyBzaGFwZXNPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZnZW4uZ2VuZXJhdGVUb3BVViggdGhpcywgYSwgYiwgYyApICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cbi8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50c1xuLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxuLy8gc2VnbWVudHMgLSB0aGUgbnVtYmVyIG9mIGNpcmN1bWZlcmVuY2Ugc2VnbWVudHMgdG8gY3JlYXRlXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cbi8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXG4vLyAgICAyKnBpIGlzIGEgY2xvc2VkIGxhdGhlLCBsZXNzIHRoYW4gMlBJIGlzIGEgcG9ydGlvbi5cblxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgICAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoXG4gICAgfTtcblxuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgfHwgMTI7XG4gICAgcGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xuICAgIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCAyICogTWF0aC5QSTtcblxuICAgIHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XG4gICAgdmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDw9IGlsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcblxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCBwaGkgKSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbiggcGhpICk7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICB2YXIgcHQgPSBwb2ludHNbIGogXTtcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHZlcnRleC54ID0gYyAqIHB0LnggLSBzICogcHQueTtcbiAgICAgICAgICAgIHZlcnRleC55ID0gcyAqIHB0LnggKyBjICogcHQueTtcbiAgICAgICAgICAgIHZlcnRleC56ID0gcHQuejtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgbnAgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICB2YXIgYmFzZSA9IGogKyBucCAqIGk7XG4gICAgICAgICAgICB2YXIgYSA9IGJhc2U7XG4gICAgICAgICAgICB2YXIgYiA9IGJhc2UgKyBucDtcbiAgICAgICAgICAgIHZhciBjID0gYmFzZSArIDEgKyBucDtcbiAgICAgICAgICAgIHZhciBkID0gYmFzZSArIDE7XG5cbiAgICAgICAgICAgIHZhciB1MCA9IGkgKiBpbnZlcnNlU2VnbWVudHM7XG4gICAgICAgICAgICB2YXIgdjAgPSBqICogaW52ZXJzZVBvaW50TGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XG4gICAgICAgICAgICB2YXIgdjEgPSB2MCArIGludmVyc2VQb2ludExlbmd0aDtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxuXG4gICAgICAgICAgICBdICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjEgKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuICAgICAgICAgICAgXSApO1xuXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxhdGhlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gKi9cblxuVEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG4gICAgfTtcblxuICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xuXG59O1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUdlb21ldHJ5O1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTZWdtZW50c1xuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gKi9cblxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcblxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQbGFuZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG4gICAgfTtcblxuICAgIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICAgIHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cbiAgICB2YXIgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcbiAgICB2YXIgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG5cbiAgICB2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuICAgIHZhciBncmlkWTEgPSBncmlkWSArIDE7XG5cbiAgICB2YXIgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG4gICAgdmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cbiAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAzICk7XG4gICAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAzICk7XG4gICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDIgKTtcblxuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBvZmZzZXQyID0gMDtcblxuICAgIGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSsrICkge1xuXG4gICAgICAgIHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG4gICAgICAgIGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cbiAgICAgICAgICAgIHZlcnRpY2VzWyBvZmZzZXQgXSA9IHg7XG4gICAgICAgICAgICB2ZXJ0aWNlc1sgb2Zmc2V0ICsgMSBdID0gLXk7XG5cbiAgICAgICAgICAgIG5vcm1hbHNbIG9mZnNldCArIDIgXSA9IDE7XG5cbiAgICAgICAgICAgIHV2c1sgb2Zmc2V0MiBdID0gaXggLyBncmlkWDtcbiAgICAgICAgICAgIHV2c1sgb2Zmc2V0MiArIDEgXSA9IDEgLSAoIGl5IC8gZ3JpZFkgKTtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICBvZmZzZXQyICs9IDI7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gMDtcblxuICAgIHZhciBpbmRpY2VzID0gbmV3KCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBncmlkWCAqIGdyaWRZICogNiApO1xuXG4gICAgZm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkrKyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG4gICAgICAgICAgICB2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgICAgIHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgICAgICAgICB2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0IF0gPSBhO1xuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMSBdID0gYjtcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDIgXSA9IGQ7XG5cbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDMgXSA9IGI7XG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgKyA0IF0gPSBjO1xuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgNSBdID0gZDtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IDY7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG59O1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5O1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTZWdtZW50c1xuICAgICk7XG5cbiAgICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1JpbmdHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgS2FsZWIgTXVycGh5XG4gKi9cblxuVEhSRUUuUmluZ0dlb21ldHJ5ID0gZnVuY3Rpb24oIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcbiAgICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgICB0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuICAgICAgICBwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIH07XG5cbiAgICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDA7XG4gICAgb3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCA1MDtcblxuICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gICAgdGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xuICAgIHBoaVNlZ21lbnRzID0gcGhpU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApIDogODtcblxuICAgIHZhciBpLCBvLCB1dnMgPSBbXSxcbiAgICAgICAgcmFkaXVzID0gaW5uZXJSYWRpdXMsXG4gICAgICAgIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpKysgKSB7XG5cbiAgICAgICAgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cbiAgICAgICAgZm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzICsgMTsgbysrICkge1xuXG4gICAgICAgICAgICAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG4gICAgICAgICAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG4gICAgICAgICAgICB2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG4gICAgICAgICAgICB1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDIgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByYWRpdXMgKz0gcmFkaXVzU3RlcDtcblxuICAgIH1cblxuICAgIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHM7IGkrKyApIHtcblxuICAgICAgICAvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcblxuICAgICAgICB2YXIgdGhldGFTZWdtZW50ID0gaSAqICggdGhldGFTZWdtZW50cyArIDEgKTtcblxuICAgICAgICBmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHM7IG8rKyApIHtcblxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHNlZ21lbnRzIHBlciBjaXJjbGVcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xuXG4gICAgICAgICAgICB2YXIgdjEgPSBzZWdtZW50O1xuICAgICAgICAgICAgdmFyIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuICAgICAgICAgICAgdmFyIHYzID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgICAgICAgdjEgPSBzZWdtZW50O1xuICAgICAgICAgICAgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG4gICAgICAgICAgICB2MyA9IHNlZ21lbnQgKyAxO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUmluZ0dlb21ldHJ5O1xuXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUmluZ0dlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaW5uZXJSYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5vdXRlclJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5waGlTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NwaGVyZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIHBoaVN0YXJ0OiBwaGlTdGFydCxcbiAgICAgICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIH07XG5cbiAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlR2VvbWV0cnk7XG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucGhpU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5waGlMZW5ndGgsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVCdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICogYmFzZWQgb24gVEhSRUUuU3BoZXJlR2VvbWV0cnlcbiAqL1xuXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgIHBoaVN0YXJ0OiBwaGlTdGFydCxcbiAgICAgICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIH07XG5cbiAgICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG5cbiAgICB3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XG4gICAgaGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XG5cbiAgICBwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XG4gICAgcGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XG5cbiAgICB2YXIgdGhldGFFbmQgPSB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGg7XG5cbiAgICB2YXIgdmVydGV4Q291bnQgPSAoICggd2lkdGhTZWdtZW50cyArIDEgKSAqICggaGVpZ2h0U2VnbWVudHMgKyAxICkgKTtcblxuICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIHZhciBub3JtYWxzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICB2YXIgdXZzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcblxuICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIHZlcnRpY2VzID0gW10sXG4gICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmb3IgKCB2YXIgeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkrKyApIHtcblxuICAgICAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcblxuICAgICAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPD0gd2lkdGhTZWdtZW50czsgeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xuXG4gICAgICAgICAgICB2YXIgcHggPSAtcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcbiAgICAgICAgICAgIHZhciBweSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG4gICAgICAgICAgICB2YXIgcHogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXG4gICAgICAgICAgICBub3JtYWwuc2V0KCBweCwgcHksIHB6ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9ucy5zZXRYWVooIGluZGV4LCBweCwgcHksIHB6ICk7XG4gICAgICAgICAgICBub3JtYWxzLnNldFhZWiggaW5kZXgsIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcbiAgICAgICAgICAgIHV2cy5zZXRYWSggaW5kZXgsIHUsIDEgLSB2ICk7XG5cbiAgICAgICAgICAgIHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICk7XG5cbiAgICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkrKyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XG4gICAgICAgICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG4gICAgICAgICAgICB2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xuICAgICAgICAgICAgdmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cbiAgICAgICAgICAgIGlmICggeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggdjEsIHYyLCB2NCApO1xuICAgICAgICAgICAgaWYgKCB5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJICkgaW5kaWNlcy5wdXNoKCB2MiwgdjMsIHY0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBpbmRpY2VzICksIDEgKSApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbHMgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgdXZzICk7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnk7XG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucGhpU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5waGlMZW5ndGgsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXh0R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBjcmVhdGluZyAzRCB0ZXh0IGdlb21ldHJ5IGluIHRocmVlLmpzXG4gKlxuICogVGV4dCA9IDNEIFRleHRcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIHNpemU6IFx0XHRcdDxmbG9hdD4sIFx0Ly8gc2l6ZSBvZiB0aGUgdGV4dFxuICogIGhlaWdodDogXHRcdDxmbG9hdD4sIFx0Ly8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxuICogIGN1cnZlU2VnbWVudHM6IFx0PGludD4sXHRcdC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICpcbiAqICBmb250OiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBuYW1lXG4gKiAgd2VpZ2h0OiBcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgd2VpZ2h0IChub3JtYWwsIGJvbGQpXG4gKiAgc3R5bGU6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6XHQ8Ym9vbD4sXHRcdFx0Ly8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCBcdFx0Ly8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6XHRcdDxmbG9hdD4sIFx0XHQvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXG4gKiAgfVxuICpcbiAqL1xuXG4vKlx0VXNhZ2UgRXhhbXBsZXNcblxuXHQvLyBUZXh0R2VvbWV0cnkgd3JhcHBlclxuXG5cdHZhciB0ZXh0M2QgPSBuZXcgVGV4dEdlb21ldHJ5KCB0ZXh0LCBvcHRpb25zICk7XG5cblx0Ly8gQ29tcGxldGUgbWFubmVyXG5cblx0dmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIG9wdGlvbnMgKTtcblx0dmFyIHRleHQzZCA9IG5ldyBFeHRydWRlR2VvbWV0cnkoIHRleHRTaGFwZXMsIG9wdGlvbnMgKTtcblxuKi9cblxuXG5USFJFRS5UZXh0R2VvbWV0cnkgPSBmdW5jdGlvbiggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgdmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMgKTtcblxuICAgIC8vIHRyYW5zbGF0ZSBwYXJhbWV0ZXJzIHRvIEV4dHJ1ZGVHZW9tZXRyeSBBUElcblxuICAgIHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XG5cbiAgICAvLyBkZWZhdWx0c1xuXG4gICAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID0gMTA7XG4gICAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xuICAgIGlmICggcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID0gZmFsc2U7XG5cbiAgICBUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgdGV4dFNoYXBlcywgcGFyYW1ldGVycyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1RleHRHZW9tZXRyeSc7XG5cbn07XG5cblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVGV4dEdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XG4gKi9cblxuVEhSRUUuVG9ydXNHZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHR1YmU6IHR1YmUsXG4gICAgICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICAgICAgdHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgIGFyYzogYXJjXG4gICAgfTtcblxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG4gICAgdHViZSA9IHR1YmUgfHwgNDA7XG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xuICAgIGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuICAgIHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICB1dnMgPSBbXSxcbiAgICAgICAgbm9ybWFscyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG4gICAgICAgICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG4gICAgICAgICAgICBjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG4gICAgICAgICAgICBjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgdmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuICAgICAgICAgICAgdmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuICAgICAgICAgICAgdmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xuICAgICAgICAgICAgbm9ybWFscy5wdXNoKCB2ZXJ0ZXguY2xvbmUoKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xuICAgICAgICAgICAgdmFyIGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xuICAgICAgICAgICAgdmFyIGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG4gICAgICAgICAgICB2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkLCBbIG5vcm1hbHNbIGEgXS5jbG9uZSgpLCBub3JtYWxzWyBiIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgYSBdLmNsb25lKCksIHV2c1sgYiBdLmNsb25lKCksIHV2c1sgZCBdLmNsb25lKCkgXSApO1xuXG4gICAgICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBbIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBjIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgYiBdLmNsb25lKCksIHV2c1sgYyBdLmNsb25lKCksIHV2c1sgZCBdLmNsb25lKCkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XG5cblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnR1YmUsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnR1YnVsYXJTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmFyY1xuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzS25vdEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcbiAqL1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIHAsIHEsIGhlaWdodFNjYWxlICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHR1YmU6IHR1YmUsXG4gICAgICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICAgICAgdHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgIHA6IHAsXG4gICAgICAgIHE6IHEsXG4gICAgICAgIGhlaWdodFNjYWxlOiBoZWlnaHRTY2FsZVxuICAgIH07XG5cbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xuICAgIHR1YmUgPSB0dWJlIHx8IDQwO1xuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgNjQ7XG4gICAgdHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDg7XG4gICAgcCA9IHAgfHwgMjtcbiAgICBxID0gcSB8fCAzO1xuICAgIGhlaWdodFNjYWxlID0gaGVpZ2h0U2NhbGUgfHwgMTtcblxuICAgIHZhciBncmlkID0gbmV3IEFycmF5KCByYWRpYWxTZWdtZW50cyApO1xuICAgIHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGJpdGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArK2kgKSB7XG5cbiAgICAgICAgZ3JpZFsgaSBdID0gbmV3IEFycmF5KCB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICAgICAgdmFyIHUgPSBpIC8gcmFkaWFsU2VnbWVudHMgKiAyICogcCAqIE1hdGguUEk7XG4gICAgICAgIHZhciBwMSA9IGdldFBvcyggdSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xuICAgICAgICB2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XG4gICAgICAgIHRhbmcuc3ViVmVjdG9ycyggcDIsIHAxICk7XG4gICAgICAgIG4uYWRkVmVjdG9ycyggcDIsIHAxICk7XG5cbiAgICAgICAgYml0YW4uY3Jvc3NWZWN0b3JzKCB0YW5nLCBuICk7XG4gICAgICAgIG4uY3Jvc3NWZWN0b3JzKCBiaXRhbiwgdGFuZyApO1xuICAgICAgICBiaXRhbi5ub3JtYWxpemUoKTtcbiAgICAgICAgbi5ub3JtYWxpemUoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB0dWJ1bGFyU2VnbWVudHM7ICsraiApIHtcblxuICAgICAgICAgICAgdmFyIHYgPSBqIC8gdHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgICB2YXIgY3ggPSAtdHViZSAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXG4gICAgICAgICAgICB2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgICAgICAgdmFyIHBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBwb3MueCA9IHAxLnggKyBjeCAqIG4ueCArIGN5ICogYml0YW4ueDtcbiAgICAgICAgICAgIHBvcy55ID0gcDEueSArIGN4ICogbi55ICsgY3kgKiBiaXRhbi55O1xuICAgICAgICAgICAgcG9zLnogPSBwMS56ICsgY3ggKiBuLnogKyBjeSAqIGJpdGFuLno7XG5cbiAgICAgICAgICAgIGdyaWRbIGkgXVsgaiBdID0gdGhpcy52ZXJ0aWNlcy5wdXNoKCBwb3MgKSAtIDE7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsraSApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB0dWJ1bGFyU2VnbWVudHM7ICsraiApIHtcblxuICAgICAgICAgICAgdmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XG4gICAgICAgICAgICB2YXIganAgPSAoIGogKyAxICkgJSB0dWJ1bGFyU2VnbWVudHM7XG5cbiAgICAgICAgICAgIHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XG4gICAgICAgICAgICB2YXIgYiA9IGdyaWRbIGlwIF1bIGogXTtcbiAgICAgICAgICAgIHZhciBjID0gZ3JpZFsgaXAgXVsganAgXTtcbiAgICAgICAgICAgIHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG4gICAgICAgICAgICB2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgICAgICAgdmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgICAgICAgdmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG4gICAgICAgICAgICB2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgZnVuY3Rpb24gZ2V0UG9zKCB1LCBpbl9xLCBpbl9wLCByYWRpdXMsIGhlaWdodFNjYWxlICkge1xuXG4gICAgICAgIHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG4gICAgICAgIHZhciBzdSA9IE1hdGguc2luKCB1ICk7XG4gICAgICAgIHZhciBxdU92ZXJQID0gaW5fcSAvIGluX3AgKiB1O1xuICAgICAgICB2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG4gICAgICAgIHZhciB0eCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcbiAgICAgICAgdmFyIHR5ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xuICAgICAgICB2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk7XG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudHViZSxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudHVidWxhclNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnEsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTY2FsZVxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1R1YmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25vYnIxXG4gKlxuICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxuICpcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXG4gKlxuICogVXNlcyBwYXJhbGxlbCB0cmFuc3BvcnQgZnJhbWVzIGFzIGRlc2NyaWJlZCBpblxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXG4gKi9cblxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICAgICAgY2xvc2VkOiBjbG9zZWRcbiAgICB9O1xuXG4gICAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCA2NDtcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcbiAgICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XG4gICAgY2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xuICAgIHRhcGVyID0gdGFwZXIgfHwgVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXI7XG5cbiAgICB2YXIgZ3JpZCA9IFtdO1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcyxcblxuICAgICAgICB0YW5nZW50LFxuICAgICAgICBub3JtYWwsXG4gICAgICAgIGJpbm9ybWFsLFxuXG4gICAgICAgIG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcblxuICAgICAgICB1LCB2LCByLFxuXG4gICAgICAgIGN4LCBjeSxcbiAgICAgICAgcG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgaSwgaixcbiAgICAgICAgaXAsIGpwLFxuICAgICAgICBhLCBiLCBjLCBkLFxuICAgICAgICB1dmEsIHV2YiwgdXZjLCB1dmQ7XG5cbiAgICB2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSxcbiAgICAgICAgdGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHMsXG4gICAgICAgIG5vcm1hbHMgPSBmcmFtZXMubm9ybWFscyxcbiAgICAgICAgYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcblxuICAgIC8vIHByb3h5IGludGVybmFsc1xuICAgIHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcbiAgICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuICAgIHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xuXG4gICAgZnVuY3Rpb24gdmVydCggeCwgeSwgeiApIHtcblxuICAgICAgICByZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApIC0gMTtcblxuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdCB0aGUgZ3JpZFxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcblxuICAgICAgICBncmlkWyBpIF0gPSBbXTtcblxuICAgICAgICB1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgICAgIHBvcyA9IHBhdGguZ2V0UG9pbnRBdCggdSApO1xuXG4gICAgICAgIHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xuICAgICAgICBub3JtYWwgPSBub3JtYWxzWyBpIF07XG4gICAgICAgIGJpbm9ybWFsID0gYmlub3JtYWxzWyBpIF07XG5cbiAgICAgICAgciA9IHJhZGl1cyAqIHRhcGVyKCB1ICk7XG5cbiAgICAgICAgZm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaisrICkge1xuXG4gICAgICAgICAgICB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogMiAqIE1hdGguUEk7XG5cbiAgICAgICAgICAgIGN4ID0gLXIgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxuICAgICAgICAgICAgY3kgPSByICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgICAgICAgcG9zMi5jb3B5KCBwb3MgKTtcbiAgICAgICAgICAgIHBvczIueCArPSBjeCAqIG5vcm1hbC54ICsgY3kgKiBiaW5vcm1hbC54O1xuICAgICAgICAgICAgcG9zMi55ICs9IGN4ICogbm9ybWFsLnkgKyBjeSAqIGJpbm9ybWFsLnk7XG4gICAgICAgICAgICBwb3MyLnogKz0gY3ggKiBub3JtYWwueiArIGN5ICogYmlub3JtYWwuejtcblxuICAgICAgICAgICAgZ3JpZFsgaSBdWyBqIF0gPSB2ZXJ0KCBwb3MyLngsIHBvczIueSwgcG9zMi56ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKyApIHtcblxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqKysgKSB7XG5cbiAgICAgICAgICAgIGlwID0gKCBjbG9zZWQgKSA/ICggaSArIDEgKSAlIHNlZ21lbnRzIDogaSArIDE7XG4gICAgICAgICAgICBqcCA9ICggaiArIDEgKSAlIHJhZGlhbFNlZ21lbnRzO1xuXG4gICAgICAgICAgICBhID0gZ3JpZFsgaSBdWyBqIF07IC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXG4gICAgICAgICAgICBiID0gZ3JpZFsgaXAgXVsgaiBdO1xuICAgICAgICAgICAgYyA9IGdyaWRbIGlwIF1bIGpwIF07XG4gICAgICAgICAgICBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG4gICAgICAgICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcbiAgICAgICAgICAgIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICAgICAgICB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICAgICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlR1YmVHZW9tZXRyeTtcblxuVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXIgPSBmdW5jdGlvbiggdSApIHtcblxuICAgIHJldHVybiAxO1xuXG59O1xuXG5USFJFRS5UdWJlR2VvbWV0cnkuU2ludXNvaWRhbFRhcGVyID0gZnVuY3Rpb24oIHUgKSB7XG5cbiAgICByZXR1cm4gTWF0aC5zaW4oIE1hdGguUEkgKiB1ICk7XG5cbn07XG5cbi8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICkge1xuXG4gICAgdmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgICAgdGFuZ2VudHMgPSBbXSxcbiAgICAgICAgbm9ybWFscyA9IFtdLFxuICAgICAgICBiaW5vcm1hbHMgPSBbXSxcblxuICAgICAgICB2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBtYXQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG4gICAgICAgIG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcbiAgICAgICAgdGhldGEsXG4gICAgICAgIGVwc2lsb24gPSAwLjAwMDEsXG4gICAgICAgIHNtYWxsZXN0LFxuXG4gICAgICAgIHR4LCB0eSwgdHosXG4gICAgICAgIGksIHU7XG5cblxuICAgIC8vIGV4cG9zZSBpbnRlcm5hbHNcbiAgICB0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG4gICAgdGhpcy5ub3JtYWxzID0gbm9ybWFscztcbiAgICB0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuICAgIC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSsrICkge1xuXG4gICAgICAgIHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICAgICAgdGFuZ2VudHNbIGkgXSA9IHBhdGguZ2V0VGFuZ2VudEF0KCB1ICk7XG4gICAgICAgIHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XG5cbiAgICB9XG5cbiAgICBpbml0aWFsTm9ybWFsMygpO1xuXG4gICAgLypcblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XG5cdFx0Ly8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggbGFzdEJpbm9ybWFsLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xuXG5cdFx0Ly8gVGhpcyB1c2VzIHRoZSBGcmVuZXQtU2VycmV0IGZvcm11bGEgZm9yIGRlcml2aW5nIGJpbm9ybWFsXG5cdFx0dmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcblxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyggdDIsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGJpbm9ybWFsc1sgMCBdLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7IC8vIGxhc3QgYmlub3JtYWwgeCB0YW5nZW50XG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cdCovXG5cbiAgICBmdW5jdGlvbiBpbml0aWFsTm9ybWFsMygpIHtcblxuICAgICAgICAvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuICAgICAgICAvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc21hbGxlc3QgdGFuZ2VudCB4eXogY29tcG9uZW50XG5cbiAgICAgICAgbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgYmlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBzbWFsbGVzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xuICAgICAgICB0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcbiAgICAgICAgdHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XG5cbiAgICAgICAgaWYgKCB0eCA8PSBzbWFsbGVzdCApIHtcblxuICAgICAgICAgICAgc21hbGxlc3QgPSB0eDtcbiAgICAgICAgICAgIG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcblxuICAgICAgICAgICAgc21hbGxlc3QgPSB0eTtcbiAgICAgICAgICAgIG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0eiA8PSBzbWFsbGVzdCApIHtcblxuICAgICAgICAgICAgbm9ybWFsLnNldCggMCwgMCwgMSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICBub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcbiAgICAgICAgYmlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuICAgIH1cblxuXG4gICAgLy8gY29tcHV0ZSB0aGUgc2xvd2x5LXZhcnlpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcblxuICAgIGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XG5cbiAgICAgICAgbm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG4gICAgICAgIGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cbiAgICAgICAgdmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgLSAxIF0sIHRhbmdlbnRzWyBpIF0gKTtcblxuICAgICAgICBpZiAoIHZlYy5sZW5ndGgoKSA+IGVwc2lsb24gKSB7XG5cbiAgICAgICAgICAgIHZlYy5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcblxuICAgICAgICAgICAgbm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXG5cbiAgICBpZiAoIGNsb3NlZCApIHtcblxuICAgICAgICB0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICksIC0xLCAxICkgKTtcbiAgICAgICAgdGhldGEgLz0gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICAgICAgaWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSApID4gMCApIHtcblxuICAgICAgICAgICAgdGhldGEgPSAtdGhldGE7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XG5cbiAgICAgICAgICAgIC8vIHR3aXN0IGEgbGl0dGxlLi4uXG4gICAgICAgICAgICBub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcbiAgICAgICAgICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Qb2x5aGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24oIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07XG5cbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcbiAgICBkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgICAgICBwcmVwYXJlKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIHZlcnRpY2VzWyBpICsgMiBdICkgKTtcblxuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIHZhciBmYWNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqKysgKSB7XG5cbiAgICAgICAgdmFyIHYxID0gcFsgaW5kaWNlc1sgaSBdIF07XG4gICAgICAgIHZhciB2MiA9IHBbIGluZGljZXNbIGkgKyAxIF0gXTtcbiAgICAgICAgdmFyIHYzID0gcFsgaW5kaWNlc1sgaSArIDIgXSBdO1xuXG4gICAgICAgIGZhY2VzWyBqIF0gPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdLCB1bmRlZmluZWQsIGogKTtcblxuICAgIH1cblxuICAgIHZhciBjZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgc3ViZGl2aWRlKCBmYWNlc1sgaSBdLCBkZXRhaWwgKTtcblxuICAgIH1cblxuXG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgICAgIHZhciB4MCA9IHV2c1sgMCBdLng7XG4gICAgICAgIHZhciB4MSA9IHV2c1sgMSBdLng7XG4gICAgICAgIHZhciB4MiA9IHV2c1sgMiBdLng7XG5cbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KCB4MCwgTWF0aC5tYXgoIHgxLCB4MiApICk7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIE1hdGgubWluKCB4MSwgeDIgKSApO1xuXG4gICAgICAgIGlmICggbWF4ID4gMC45ICYmIG1pbiA8IDAuMSApIHtcblxuICAgICAgICAgICAgLy8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxuXG4gICAgICAgICAgICBpZiAoIHgwIDwgMC4yICkgdXZzWyAwIF0ueCArPSAxO1xuICAgICAgICAgICAgaWYgKCB4MSA8IDAuMiApIHV2c1sgMSBdLnggKz0gMTtcbiAgICAgICAgICAgIGlmICggeDIgPCAwLjIgKSB1dnNbIDIgXS54ICs9IDE7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvLyBBcHBseSByYWRpdXNcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cbiAgICB9XG5cblxuICAgIC8vIE1lcmdlIHZlcnRpY2VzXG5cbiAgICB0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cblxuICAgIC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZSggdmVjdG9yICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSB2ZWN0b3Iubm9ybWFsaXplKCkuY2xvbmUoKTtcbiAgICAgICAgdmVydGV4LmluZGV4ID0gdGhhdC52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKSAtIDE7XG5cbiAgICAgICAgLy8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxuXG4gICAgICAgIHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcbiAgICAgICAgdmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xuICAgICAgICB2ZXJ0ZXgudXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKTtcblxuICAgICAgICByZXR1cm4gdmVydGV4O1xuXG4gICAgfVxuXG5cbiAgICAvLyBBcHByb3hpbWF0ZSBhIGN1cnZlZCBmYWNlIHdpdGggcmVjdXJzaXZlbHkgc3ViLWRpdmlkZWQgdHJpYW5nbGVzLlxuXG4gICAgZnVuY3Rpb24gbWFrZSggdjEsIHYyLCB2MywgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgbWF0ZXJpYWxJbmRleCApO1xuICAgICAgICB0aGF0LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgICAgICBjZW50cm9pZC5jb3B5KCB2MSApLmFkZCggdjIgKS5hZGQoIHYzICkuZGl2aWRlU2NhbGFyKCAzICk7XG5cbiAgICAgICAgdmFyIGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XG5cbiAgICAgICAgdGhhdC5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuICAgICAgICAgICAgY29ycmVjdFVWKCB2MS51diwgdjEsIGF6aSApLFxuICAgICAgICAgICAgY29ycmVjdFVWKCB2Mi51diwgdjIsIGF6aSApLFxuICAgICAgICAgICAgY29ycmVjdFVWKCB2My51diwgdjMsIGF6aSApXG4gICAgICAgIF0gKTtcblxuICAgIH1cblxuXG4gICAgLy8gQW5hbHl0aWNhbGx5IHN1YmRpdmlkZSBhIGZhY2UgdG8gdGhlIHJlcXVpcmVkIGRldGFpbCBsZXZlbC5cblxuICAgIGZ1bmN0aW9uIHN1YmRpdmlkZSggZmFjZSwgZGV0YWlsICkge1xuXG4gICAgICAgIHZhciBjb2xzID0gTWF0aC5wb3coIDIsIGRldGFpbCApO1xuICAgICAgICB2YXIgYSA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYSBdICk7XG4gICAgICAgIHZhciBiID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcbiAgICAgICAgdmFyIGMgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmMgXSApO1xuICAgICAgICB2YXIgdiA9IFtdO1xuXG4gICAgICAgIHZhciBtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uLlxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8PSBjb2xzOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZbIGkgXSA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuICAgICAgICAgICAgdmFyIGJqID0gcHJlcGFyZSggYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcbiAgICAgICAgICAgIHZhciByb3dzID0gY29scyAtIGk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8PSByb3dzOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGogXSA9IGFqO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgaiBdID0gcHJlcGFyZSggYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzLlxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGNvbHM7IGkrKyApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMiAqICggY29scyAtIGkgKSAtIDE7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vciggaiAvIDIgKTtcblxuICAgICAgICAgICAgICAgIGlmICggaiAlIDIgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFrZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgayArIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgayBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1ha2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGsgKyAxIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpICsgMSBdWyBrICsgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSArIDEgXVsgayBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cbiAgICBmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtdmVjdG9yLnggKTtcblxuICAgIH1cblxuXG4gICAgLy8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG4gICAgZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMiggLXZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxuXG4gICAgZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xuXG4gICAgICAgIGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcbiAgICAgICAgaWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggYXppbXV0aCAvIDIgLyBNYXRoLlBJICsgMC41LCB1di55ICk7XG4gICAgICAgIHJldHVybiB1di5jbG9uZSgpO1xuXG4gICAgfVxuXG5cbn07XG5cblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnk7XG5cblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy52ZXJ0aWNlcyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmluZGljZXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5kZXRhaWxcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXG4gKi9cblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICB2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuICAgIHZhciByID0gMSAvIHQ7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXG5cbiAgICAgICAgLy8gKMKxMSwgwrExLCDCsTEpXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSxcbiAgICAgICAgMSwgLTEsIC0xLCAxLCAtMSwgMSxcbiAgICAgICAgMSwgMSwgLTEsIDEsIDEsIDEsXG5cbiAgICAgICAgLy8gKDAsIMKxMS/PhiwgwrHPhilcbiAgICAgICAgMCwgLXIsIC10LCAwLCAtciwgdCxcbiAgICAgICAgMCwgciwgLXQsIDAsIHIsIHQsXG5cbiAgICAgICAgLy8gKMKxMS/PhiwgwrHPhiwgMClcbiAgICAgICAgLXIsIC10LCAwLCAtciwgdCwgMCxcbiAgICAgICAgciwgLXQsIDAsIHIsIHQsIDAsXG5cbiAgICAgICAgLy8gKMKxz4YsIDAsIMKxMS/PhilcbiAgICAgICAgLXQsIDAsIC1yLCB0LCAwLCAtciwgLXQsIDAsIHIsIHQsIDAsIHJcbiAgICBdO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIDMsIDExLCA3LCAzLCA3LCAxNSwgMywgMTUsIDEzLFxuICAgICAgICA3LCAxOSwgMTcsIDcsIDE3LCA2LCA3LCA2LCAxNSxcbiAgICAgICAgMTcsIDQsIDgsIDE3LCA4LCAxMCwgMTcsIDEwLCA2LFxuICAgICAgICA4LCAwLCAxNiwgOCwgMTYsIDIsIDgsIDIsIDEwLFxuICAgICAgICAwLCAxMiwgMSwgMCwgMSwgMTgsIDAsIDE4LCAxNixcbiAgICAgICAgNiwgMTAsIDIsIDYsIDIsIDEzLCA2LCAxMywgMTUsXG4gICAgICAgIDIsIDE2LCAxOCwgMiwgMTgsIDMsIDIsIDMsIDEzLFxuICAgICAgICAxOCwgMSwgOSwgMTgsIDksIDExLCAxOCwgMTEsIDMsXG4gICAgICAgIDQsIDE0LCAxMiwgNCwgMTIsIDAsIDQsIDAsIDgsXG4gICAgICAgIDExLCA5LCA1LCAxMSwgNSwgMTksIDExLCAxOSwgNyxcbiAgICAgICAgMTksIDUsIDE0LCAxOSwgMTQsIDQsIDE5LCA0LCAxNyxcbiAgICAgICAgMSwgMTIsIDE0LCAxLCAxNCwgNSwgMSwgNSwgOVxuICAgIF07XG5cbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICB9O1xuXG59O1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeTtcblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5kZXRhaWxcbiAgICApO1xuXG4gICAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9JY29zYWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICovXG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICB2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gWyAtMSwgdCwgMCwgMSwgdCwgMCwgLTEsIC10LCAwLCAxLCAtdCwgMCxcbiAgICAgICAgMCwgLTEsIHQsIDAsIDEsIHQsIDAsIC0xLCAtdCwgMCwgMSwgLXQsXG4gICAgICAgIHQsIDAsIC0xLCB0LCAwLCAxLCAtdCwgMCwgLTEsIC10LCAwLCAxXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAwLCAxMSwgNSwgMCwgNSwgMSwgMCwgMSwgNywgMCwgNywgMTAsIDAsIDEwLCAxMSxcbiAgICAgICAgMSwgNSwgOSwgNSwgMTEsIDQsIDExLCAxMCwgMiwgMTAsIDcsIDYsIDcsIDEsIDgsXG4gICAgICAgIDMsIDksIDQsIDMsIDQsIDIsIDMsIDIsIDYsIDMsIDYsIDgsIDMsIDgsIDksXG4gICAgICAgIDQsIDksIDUsIDIsIDQsIDExLCA2LCAyLCAxMCwgOCwgNiwgNywgOSwgOCwgMVxuICAgIF07XG5cbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07XG5cbn07XG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5kZXRhaWxcbiAgICApO1xuXG4gICAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAgICAxLCAwLCAwLCAtMSwgMCwgMCwgMCwgMSwgMCwgMCwgLTEsIDAsIDAsIDAsIDEsIDAsIDAsIC0xXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAwLCAyLCA0LCAwLCA0LCAzLCAwLCAzLCA1LCAwLCA1LCAyLCAxLCAyLCA1LCAxLCA1LCAzLCAxLCAzLCA0LCAxLCA0LCAyXG4gICAgXTtcblxuICAgIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICAgIHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICB9O1xuXG59O1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeTtcblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICAgICk7XG5cbiAgICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgLTEsIDEsIC0xLCAtMVxuICAgIF07XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgICAgMiwgMSwgMCwgMCwgMywgMiwgMSwgMywgMCwgMiwgMywgMVxuICAgIF07XG5cbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07XG5cbn07XG5cblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5O1xuXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5kZXRhaWxcbiAgICApO1xuXG4gICAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QYXJhbWV0cmljR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogUGFyYW1ldHJpYyBTdXJmYWNlcyBHZW9tZXRyeVxuICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcbiAqXG4gKiBuZXcgVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5KCBwYXJhbWV0cmljRnVuY3Rpb24sIHVTZWdtZW50cywgeVNlZ2VtZW50cyApO1xuICpcbiAqL1xuXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgPSBmdW5jdGlvbiggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0dlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgc2xpY2VzOiBzbGljZXMsXG4gICAgICAgIHN0YWNrczogc3RhY2tzXG4gICAgfTtcblxuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcbiAgICB2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XG5cbiAgICB2YXIgaSwgaiwgcDtcbiAgICB2YXIgdSwgdjtcblxuICAgIHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDw9IHN0YWNrczsgaSsrICkge1xuXG4gICAgICAgIHYgPSBpIC8gc3RhY2tzO1xuXG4gICAgICAgIGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaisrICkge1xuXG4gICAgICAgICAgICB1ID0gaiAvIHNsaWNlcztcblxuICAgICAgICAgICAgcCA9IGZ1bmMoIHUsIHYgKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goIHAgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgYSwgYiwgYywgZDtcbiAgICB2YXIgdXZhLCB1dmIsIHV2YywgdXZkO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkrKyApIHtcblxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHNsaWNlczsgaisrICkge1xuXG4gICAgICAgICAgICBhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuICAgICAgICAgICAgYiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XG4gICAgICAgICAgICBjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xuICAgICAgICAgICAgZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xuXG4gICAgICAgICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuICAgICAgICAgICAgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuICAgICAgICAgICAgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG4gICAgICAgICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG5cbiAgICAgICAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICAgICAgICB1dnMucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgICAgICAgZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICAgICAgICAgIHV2cy5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzKTtcblxuICAgIC8vIG1hZ2ljIGJ1bGxldFxuICAgIC8vIHZhciBkaWZmID0gdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG4gICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZWQgJywgZGlmZiwgJyB2ZXJ0aWNlcyBieSBtZXJnaW5nJyk7XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5ID0gZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdmFyIGVkZ2UgPSBbIDAsIDAgXSxcbiAgICAgICAgaGFzaCA9IHt9O1xuICAgIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICByZXR1cm4gYSAtIGI7XG5cbiAgICB9O1xuXG4gICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG4gICAgICAgIHZhciBudW1FZGdlcyA9IDA7XG5cbiAgICAgICAgLy8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG4gICAgICAgIHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggNiAqIGZhY2VzLmxlbmd0aCApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcbiAgICAgICAgICAgICAgICBlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcbiAgICAgICAgICAgICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG4gICAgICAgICAgICAgICAgICAgIGhhc2hbIGtleSBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbnVtRWRnZXMrKztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGVkZ2VzWyAyICogaSArIGogXSBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcbiAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGV4Lng7XG4gICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRleC55O1xuICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICAgIH1cbiAgICBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAvLyBJbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXguYXJyYXk7XG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRyYXdjYWxscyA9IGdlb21ldHJ5LmRyYXdjYWxscztcbiAgICAgICAgICAgIHZhciBudW1FZGdlcyA9IDA7XG5cbiAgICAgICAgICAgIGlmICggZHJhd2NhbGxzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmFkZERyYXdDYWxsKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxuICAgICAgICAgICAgdmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCAyICogaW5kaWNlcy5sZW5ndGggKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIG8gPSAwLCBvbCA9IGRyYXdjYWxscy5sZW5ndGg7IG8gPCBvbDsgKytvICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyYXdjYWxsID0gZHJhd2NhbGxzWyBvIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBkcmF3Y2FsbC5zdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBkcmF3Y2FsbC5jb3VudDtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlWyAwIF0gPSBpbmRpY2VzWyBpICsgaiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVsgMSBdID0gaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgXSA9IGVkZ2VbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hbIGtleSBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1FZGdlcysrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMjsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDIgPSBlZGdlc1sgMiAqIGkgKyBqIF07XG5cbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzLmdldFgoIGluZGV4MiApO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXMuZ2V0WSggaW5kZXgyICk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlcy5nZXRaKCBpbmRleDIgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICAgICAgdmFyIG51bUVkZ2VzID0gdmVydGljZXMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgIHZhciBudW1UcmlzID0gbnVtRWRnZXMgLyAzO1xuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1UcmlzOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDEgPSA5ICogaSArIDMgKiBqO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGljZXNbIGluZGV4MSBdO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAyIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IDkgKiBpICsgMyAqICggKCBqICsgMSApICUgMyApO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMyBdID0gdmVydGljZXNbIGluZGV4MiBdO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgNCBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDUgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAyIF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BeGlzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BeGlzSGVscGVyID0gZnVuY3Rpb24oIHNpemUgKSB7XG5cbiAgICBzaXplID0gc2l6ZSB8fCAxO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuICAgICAgICAwLCAwLCAwLCBzaXplLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAwLCBzaXplLCAwLFxuICAgICAgICAwLCAwLCAwLCAwLCAwLCBzaXplXG4gICAgXSApO1xuXG4gICAgdmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAgICAgMSwgMCwgMCwgMSwgMC42LCAwLFxuICAgICAgICAwLCAxLCAwLCAwLjYsIDEsIDAsXG4gICAgICAgIDAsIDAsIDEsIDAsIDAuNiwgMVxuICAgIF0gKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9yc1xuICAgIH0gKTtcblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF4aXNIZWxwZXI7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0Fycm93SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqXG4gKiBDcmVhdGVzIGFuIGFycm93IGZvciB2aXN1YWxpemluZyBkaXJlY3Rpb25zXG4gKlxuICogUGFyYW1ldGVyczpcbiAqICBkaXIgLSBWZWN0b3IzXG4gKiAgb3JpZ2luIC0gVmVjdG9yM1xuICogIGxlbmd0aCAtIE51bWJlclxuICogIGNvbG9yIC0gY29sb3IgaW4gaGV4IHZhbHVlXG4gKiAgaGVhZExlbmd0aCAtIE51bWJlclxuICogIGhlYWRXaWR0aCAtIE51bWJlclxuICovXG5cblRIUkVFLkFycm93SGVscGVyID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICBsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXG4gICAgdmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcbiAgICBjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtMC41LCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XG5cbiAgICAgICAgLy8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xuICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMTtcbiAgICAgICAgaWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuICAgICAgICBpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xuXG4gICAgICAgIGlmICggaGVhZExlbmd0aCA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICAgICAgfSApICk7XG4gICAgICAgICAgICB0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hZGQoIHRoaXMubGluZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGNvbmVHZW9tZXRyeSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgfSApICk7XG4gICAgICAgIHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuICAgICAgICB0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XG4gICAgICAgIHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuXG4gICAgfVxuXG59KCkgKTtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BcnJvd0hlbHBlcjtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldERpcmVjdGlvbiA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHJhZGlhbnM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKCBkaXIgKSB7XG5cbiAgICAgICAgLy8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgICAgIGlmICggZGlyLnkgPiAwLjk5OTk5ICkge1xuXG4gICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZGlyLnkgPCAtMC45OTk5OSApIHtcblxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldCggMSwgMCwgMCwgMCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGF4aXMuc2V0KCBkaXIueiwgMCwgLWRpci54ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIHJhZGlhbnMgPSBNYXRoLmFjb3MoIGRpci55ICk7XG5cbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XG5cbiAgICBpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG4gICAgaWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cbiAgICBpZiAoIGhlYWRMZW5ndGggPCBsZW5ndGggKSB7XG4gICAgICAgIHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIGxlbmd0aCAtIGhlYWRMZW5ndGgsIDEgKTtcbiAgICAgICAgdGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cblxuICAgIHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG4gICAgdGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG4gICAgdGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICBpZiAoIHRoaXMubGluZSAhPT0gdW5kZWZpbmVkICkgdGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcbiAgICB0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogMHhmZmZmMDBcbiAgICB9ICkgKTtcblxuICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoIG9iamVjdCApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEhlbHBlcjtcblxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICBib3guc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XG5cbiAgICAgICAgaWYgKCBib3guZW1wdHkoKSApIHJldHVybjtcblxuICAgICAgICB2YXIgbWluID0gYm94Lm1pbjtcbiAgICAgICAgdmFyIG1heCA9IGJveC5tYXg7XG5cbiAgICAgICAgLypcblx0XHQgIDVfX19fNFxuXHRcdDEvX19fMC98XG5cdFx0fCA2X198Xzdcblx0XHQyL19fXzMvXG5cblx0XHQwOiBtYXgueCwgbWF4LnksIG1heC56XG5cdFx0MTogbWluLngsIG1heC55LCBtYXguelxuXHRcdDI6IG1pbi54LCBtaW4ueSwgbWF4Lnpcblx0XHQzOiBtYXgueCwgbWluLnksIG1heC56XG5cdFx0NDogbWF4LngsIG1heC55LCBtaW4uelxuXHRcdDU6IG1pbi54LCBtYXgueSwgbWluLnpcblx0XHQ2OiBtaW4ueCwgbWluLnksIG1pbi56XG5cdFx0NzogbWF4LngsIG1pbi55LCBtaW4uelxuXHRcdCovXG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcblxuICAgICAgICBhcnJheVsgMCBdID0gbWF4Lng7XG4gICAgICAgIGFycmF5WyAxIF0gPSBtYXgueTtcbiAgICAgICAgYXJyYXlbIDIgXSA9IG1heC56O1xuICAgICAgICBhcnJheVsgMyBdID0gbWluLng7XG4gICAgICAgIGFycmF5WyA0IF0gPSBtYXgueTtcbiAgICAgICAgYXJyYXlbIDUgXSA9IG1heC56O1xuICAgICAgICBhcnJheVsgNiBdID0gbWluLng7XG4gICAgICAgIGFycmF5WyA3IF0gPSBtaW4ueTtcbiAgICAgICAgYXJyYXlbIDggXSA9IG1heC56O1xuICAgICAgICBhcnJheVsgOSBdID0gbWF4Lng7XG4gICAgICAgIGFycmF5WyAxMCBdID0gbWluLnk7XG4gICAgICAgIGFycmF5WyAxMSBdID0gbWF4Lno7XG4gICAgICAgIGFycmF5WyAxMiBdID0gbWF4Lng7XG4gICAgICAgIGFycmF5WyAxMyBdID0gbWF4Lnk7XG4gICAgICAgIGFycmF5WyAxNCBdID0gbWluLno7XG4gICAgICAgIGFycmF5WyAxNSBdID0gbWluLng7XG4gICAgICAgIGFycmF5WyAxNiBdID0gbWF4Lnk7XG4gICAgICAgIGFycmF5WyAxNyBdID0gbWluLno7XG4gICAgICAgIGFycmF5WyAxOCBdID0gbWluLng7XG4gICAgICAgIGFycmF5WyAxOSBdID0gbWluLnk7XG4gICAgICAgIGFycmF5WyAyMCBdID0gbWluLno7XG4gICAgICAgIGFycmF5WyAyMSBdID0gbWF4Lng7XG4gICAgICAgIGFycmF5WyAyMiBdID0gbWluLnk7XG4gICAgICAgIGFycmF5WyAyMyBdID0gbWluLno7XG5cbiAgICAgICAgcG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICB9XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3VuZGluZ0JveEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cbi8vIGEgaGVscGVyIHRvIHNob3cgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFuIG9iamVjdFxuXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlciA9IGZ1bmN0aW9uKCBvYmplY3QsIGhleCApIHtcblxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICB0aGlzLmJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICB3aXJlZnJhbWU6IHRydWVcbiAgICB9ICkgKTtcblxufTtcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJvdW5kaW5nQm94SGVscGVyO1xuXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmJveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xuXG4gICAgdGhpcy5ib3guc2l6ZSggdGhpcy5zY2FsZSApO1xuXG4gICAgdGhpcy5ib3guY2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0NhbWVyYUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxuICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuICogXHQtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXG4gKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXG4gKi9cblxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24oIGNhbWVyYSApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgICAgIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9yc1xuICAgIH0gKTtcblxuICAgIHZhciBwb2ludE1hcCA9IHt9O1xuXG4gICAgLy8gY29sb3JzXG5cbiAgICB2YXIgaGV4RnJ1c3R1bSA9IDB4ZmZhYTAwO1xuICAgIHZhciBoZXhDb25lID0gMHhmZjAwMDA7XG4gICAgdmFyIGhleFVwID0gMHgwMGFhZmY7XG4gICAgdmFyIGhleFRhcmdldCA9IDB4ZmZmZmZmO1xuICAgIHZhciBoZXhDcm9zcyA9IDB4MzMzMzMzO1xuXG4gICAgLy8gbmVhclxuXG4gICAgYWRkTGluZSggXCJuMVwiLCBcIm4yXCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcIm4yXCIsIFwibjRcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwibjRcIiwgXCJuM1wiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJuM1wiLCBcIm4xXCIsIGhleEZydXN0dW0gKTtcblxuICAgIC8vIGZhclxuXG4gICAgYWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcImYyXCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwiZjRcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcblxuICAgIC8vIHNpZGVzXG5cbiAgICBhZGRMaW5lKCBcIm4xXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwibjJcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJuM1wiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcIm40XCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xuXG4gICAgLy8gY29uZVxuXG4gICAgYWRkTGluZSggXCJwXCIsIFwibjFcIiwgaGV4Q29uZSApO1xuICAgIGFkZExpbmUoIFwicFwiLCBcIm4yXCIsIGhleENvbmUgKTtcbiAgICBhZGRMaW5lKCBcInBcIiwgXCJuM1wiLCBoZXhDb25lICk7XG4gICAgYWRkTGluZSggXCJwXCIsIFwibjRcIiwgaGV4Q29uZSApO1xuXG4gICAgLy8gdXBcblxuICAgIGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xuICAgIGFkZExpbmUoIFwidTJcIiwgXCJ1M1wiLCBoZXhVcCApO1xuICAgIGFkZExpbmUoIFwidTNcIiwgXCJ1MVwiLCBoZXhVcCApO1xuXG4gICAgLy8gdGFyZ2V0XG5cbiAgICBhZGRMaW5lKCBcImNcIiwgXCJ0XCIsIGhleFRhcmdldCApO1xuICAgIGFkZExpbmUoIFwicFwiLCBcImNcIiwgaGV4Q3Jvc3MgKTtcblxuICAgIC8vIGNyb3NzXG5cbiAgICBhZGRMaW5lKCBcImNuMVwiLCBcImNuMlwiLCBoZXhDcm9zcyApO1xuICAgIGFkZExpbmUoIFwiY24zXCIsIFwiY240XCIsIGhleENyb3NzICk7XG5cbiAgICBhZGRMaW5lKCBcImNmMVwiLCBcImNmMlwiLCBoZXhDcm9zcyApO1xuICAgIGFkZExpbmUoIFwiY2YzXCIsIFwiY2Y0XCIsIGhleENyb3NzICk7XG5cbiAgICBmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBoZXggKSB7XG5cbiAgICAgICAgYWRkUG9pbnQoIGEsIGhleCApO1xuICAgICAgICBhZGRQb2ludCggYiwgaGV4ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG4gICAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG5cbiAgICAgICAgaWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBwb2ludE1hcFsgaWQgXSA9IFtdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBwb2ludE1hcFsgaWQgXS5wdXNoKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG5cbiAgICB9XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLm1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhSGVscGVyO1xuXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5LCBwb2ludE1hcDtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XG5cbiAgICB2YXIgc2V0UG9pbnQgPSBmdW5jdGlvbiggcG9pbnQsIHgsIHksIHogKSB7XG5cbiAgICAgICAgdmVjdG9yLnNldCggeCwgeSwgeiApLnVucHJvamVjdCggY2FtZXJhICk7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50TWFwWyBwb2ludCBdO1xuXG4gICAgICAgIGlmICggcG9pbnRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgICAgIHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblxuICAgICAgICB2YXIgdyA9IDEsXG4gICAgICAgICAgICBoID0gMTtcblxuICAgICAgICAvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG4gICAgICAgIC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XG5cbiAgICAgICAgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgICAgIC8vIGNlbnRlciAvIHRhcmdldFxuXG4gICAgICAgIHNldFBvaW50KCBcImNcIiwgMCwgMCwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwidFwiLCAwLCAwLCAxICk7XG5cbiAgICAgICAgLy8gbmVhclxuXG4gICAgICAgIHNldFBvaW50KCBcIm4xXCIsIC13LCAtaCwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwibjJcIiwgdywgLWgsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcIm4zXCIsIC13LCBoLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJuNFwiLCB3LCBoLCAtMSApO1xuXG4gICAgICAgIC8vIGZhclxuXG4gICAgICAgIHNldFBvaW50KCBcImYxXCIsIC13LCAtaCwgMSApO1xuICAgICAgICBzZXRQb2ludCggXCJmMlwiLCB3LCAtaCwgMSApO1xuICAgICAgICBzZXRQb2ludCggXCJmM1wiLCAtdywgaCwgMSApO1xuICAgICAgICBzZXRQb2ludCggXCJmNFwiLCB3LCBoLCAxICk7XG5cbiAgICAgICAgLy8gdXBcblxuICAgICAgICBzZXRQb2ludCggXCJ1MVwiLCB3ICogMC43LCBoICogMS4xLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJ1MlwiLCAtdyAqIDAuNywgaCAqIDEuMSwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwidTNcIiwgMCwgaCAqIDIsIC0xICk7XG5cbiAgICAgICAgLy8gY3Jvc3NcblxuICAgICAgICBzZXRQb2ludCggXCJjZjFcIiwgLXcsIDAsIDEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiY2YyXCIsIHcsIDAsIDEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiY2YzXCIsIDAsIC1oLCAxICk7XG4gICAgICAgIHNldFBvaW50KCBcImNmNFwiLCAwLCBoLCAxICk7XG5cbiAgICAgICAgc2V0UG9pbnQoIFwiY24xXCIsIC13LCAwLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJjbjJcIiwgdywgMCwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiY24zXCIsIDAsIC1oLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJjbjRcIiwgMCwgaCwgLTEgKTtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgfTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9EaXJlY3Rpb25hbExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gZnVuY3Rpb24oIGxpZ2h0LCBzaXplICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBzaXplID0gc2l6ZSB8fCAxO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC1zaXplLCBzaXplLCAwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplLCBzaXplLCAwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplLCAtc2l6ZSwgMCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLXNpemUsIC1zaXplLCAwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtc2l6ZSwgc2l6ZSwgMCApXG4gICAgKTtcblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBmb2c6IGZhbHNlXG4gICAgfSApO1xuICAgIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIHRoaXMubGlnaHRQbGFuZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICB0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XG5cbiAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICApO1xuXG4gICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgZm9nOiBmYWxzZVxuICAgIH0gKTtcbiAgICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICB0aGlzLnRhcmdldExpbmUgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgdGhpcy5hZGQoIHRoaXMudGFyZ2V0TGluZSApO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgIHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgICAgICB2My5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcblxuICAgICAgICB0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuICAgICAgICB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgICAgIHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc1sgMSBdLmNvcHkoIHYzICk7XG4gICAgICAgIHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yICk7XG5cbiAgICB9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0VkZ2VzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAcGFyYW0gb2JqZWN0IFRIUkVFLk1lc2ggd2hvc2UgZ2VvbWV0cnkgd2lsbCBiZSB1c2VkXG4gKiBAcGFyYW0gaGV4IGxpbmUgY29sb3JcbiAqIEBwYXJhbSB0aHJlc2hvbGRBbmdsZSB0aGUgbWluaW11bSBhbmdsZSAoaW4gZGVncmVlcyksXG4gKiBiZXR3ZWVuIHRoZSBmYWNlIG5vcm1hbHMgb2YgYWRqYWNlbnQgZmFjZXMsXG4gKiB0aGF0IGlzIHJlcXVpcmVkIHRvIHJlbmRlciBhbiBlZGdlLiBBIHZhbHVlIG9mIDEwIG1lYW5zXG4gKiBhbiBlZGdlIGlzIG9ubHkgcmVuZGVyZWQgaWYgdGhlIGFuZ2xlIGlzIGF0IGxlYXN0IDEwIGRlZ3JlZXMuXG4gKi9cblxuVEhSRUUuRWRnZXNIZWxwZXIgPSBmdW5jdGlvbiggb2JqZWN0LCBoZXgsIHRocmVzaG9sZEFuZ2xlICkge1xuXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgbmV3IFRIUkVFLkVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0gKSApO1xuXG4gICAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzSGVscGVyO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9GYWNlTm9ybWFsc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gICAgLy8gRmFjZU5vcm1hbHNIZWxwZXIgb25seSBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeVxuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICB0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cbiAgICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcblxuICAgIHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cbiAgICAvL1xuXG4gICAgdmFyIG5Ob3JtYWxzID0gMDtcblxuICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgIG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2VOb3JtYWxzSGVscGVyOiBvbmx5IFRIUkVFLkdlb21ldHJ5IGlzIHN1cHBvcnRlZC4gVXNlIFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIsIGluc3RlYWQuJyApO1xuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XG5cbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBsaW5ld2lkdGg6IHdpZHRoXG4gICAgfSApICk7XG5cbiAgICAvL1xuXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI7XG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICAgIG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgdmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cbiAgICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcblxuICAgICAgICAgICAgdjEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcbiAgICAgICAgICAgICAgICAuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxuICAgICAgICAgICAgICAgIC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXG4gICAgICAgICAgICAgICAgLmRpdmlkZVNjYWxhciggMyApXG4gICAgICAgICAgICAgICAgLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgdjIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn0oKSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9HcmlkSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5HcmlkSGVscGVyID0gZnVuY3Rpb24oIHNpemUsIHN0ZXAgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnNcbiAgICB9ICk7XG5cbiAgICB0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcbiAgICB0aGlzLmNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvciggMHg4ODg4ODggKTtcblxuICAgIGZvciAoIHZhciBpID0gLXNpemU7IGkgPD0gc2l6ZTsgaSArPSBzdGVwICkge1xuXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLXNpemUsIDAsIGkgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIDAsIGkgKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCAtc2l6ZSApLCBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgc2l6ZSApXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gaSA9PT0gMCA/IHRoaXMuY29sb3IxIDogdGhpcy5jb2xvcjI7XG5cbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cbiAgICB9XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbn07XG5cblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5HcmlkSGVscGVyO1xuXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiggY29sb3JDZW50ZXJMaW5lLCBjb2xvckdyaWQgKSB7XG5cbiAgICB0aGlzLmNvbG9yMS5zZXQoIGNvbG9yQ2VudGVyTGluZSApO1xuICAgIHRoaXMuY29sb3IyLnNldCggY29sb3JHcmlkICk7XG5cbiAgICB0aGlzLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9IZW1pc3BoZXJlTGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuY29sb3JzID0gWyBuZXcgVEhSRUUuQ29sb3IoKSwgbmV3IFRIUkVFLkNvbG9yKCkgXTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuICAgIGdlb21ldHJ5LnJvdGF0ZVgoIC1NYXRoLlBJIC8gMiApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IDg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIGdlb21ldHJ5LmZhY2VzWyBpIF0uY29sb3IgPSB0aGlzLmNvbG9yc1sgaSA8IDQgPyAwIDogMSBdO1xuXG4gICAgfVxuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyxcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlXG4gICAgfSApO1xuXG4gICAgdGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICB0aGlzLmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlcjtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY29sb3JzWyAwIF0uY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuICAgICAgICB0aGlzLmNvbG9yc1sgMSBdLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgICAgICB0aGlzLmxpZ2h0U3BoZXJlLmxvb2tBdCggdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpICk7XG4gICAgICAgIHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZSxcbiAgICAgICAgZm9nOiBmYWxzZVxuICAgIH0gKTtcbiAgICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgdGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgLypcblx0dmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xuXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cblx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xuXHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXG5cdHZhciBkID0gbGlnaHQuZGlzdGFuY2U7XG5cblx0aWYgKCBkID09PSAwLjAgKSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcblx0Ki9cblxufTtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0SGVscGVyO1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIC8qXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXHQqL1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Ta2VsZXRvbkhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgU2VhbiBHcmlmZmluIC8gaHR0cDovL3R3aXR0ZXIuY29tL3NncmlmXG4gKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLlNrZWxldG9uSGVscGVyID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgIHRoaXMuYm9uZXMgPSB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QgKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICB2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuICAgICAgICBpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMCwgMSApICk7XG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAxLCAwICkgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZW9tZXRyeS5keW5hbWljID0gdHJ1ZTtcblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyxcbiAgICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgfSApO1xuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgdGhpcy5yb290ID0gb2JqZWN0O1xuXG4gICAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNrZWxldG9uSGVscGVyO1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuZ2V0Qm9uZUxpc3QgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgdmFyIGJvbmVMaXN0ID0gW107XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cbiAgICAgICAgYm9uZUxpc3QucHVzaCggb2JqZWN0ICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgYm9uZUxpc3QucHVzaC5hcHBseSggYm9uZUxpc3QsIHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdC5jaGlsZHJlblsgaSBdICkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBib25lTGlzdDtcblxufTtcblxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICAgIHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkuZ2V0SW52ZXJzZSggdGhpcy5yb290Lm1hdHJpeFdvcmxkICk7XG5cbiAgICB2YXIgYm9uZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICB2YXIgaiA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgIHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG4gICAgICAgIGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG4gICAgICAgICAgICBib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG4gICAgICAgICAgICBib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cbiAgICAgICAgICAgIGogKz0gMjtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyID0gZnVuY3Rpb24oIGxpZ2h0ICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMSwgMSwgOCwgMSwgdHJ1ZSApO1xuXG4gICAgZ2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtMC41LCAwICk7XG4gICAgZ2VvbWV0cnkucm90YXRlWCggLU1hdGguUEkgLyAyICk7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICBmb2c6IGZhbHNlXG4gICAgfSApO1xuXG4gICAgdGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHRIZWxwZXI7XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHZlY3RvcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwMDtcbiAgICAgICAgdmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xuXG4gICAgICAgIHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XG5cbiAgICAgICAgdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICB2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuICAgICAgICB0aGlzLmNvbmUubG9va0F0KCB2ZWN0b3IyLnN1YiggdmVjdG9yICkgKTtcblxuICAgICAgICB0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgfTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgdGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZjAwMDA7XG5cbiAgICB2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gICAgLy9cblxuICAgIHZhciBuTm9ybWFscyA9IDA7XG5cbiAgICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICAgIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICBuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aCAqIDM7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgbk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudFxuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XG5cbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBsaW5ld2lkdGg6IHdpZHRoXG4gICAgfSApICk7XG5cbiAgICAvL1xuXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlcjtcblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICAgICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICAgIG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgdmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcblxuICAgICAgICAgICAgICAgICAgICB2MS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdjIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICAgICAgdmFyIG9iak5vcm0gPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgICAgICAgIC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG9ialBvcy5jb3VudDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2MS5zZXQoIG9ialBvcy5nZXRYKCBqICksIG9ialBvcy5nZXRZKCBqICksIG9ialBvcy5nZXRaKCBqICkgKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICB2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcblxuICAgICAgICAgICAgICAgIHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuICAgICAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59KCkgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvV2lyZWZyYW1lSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIgPSBmdW5jdGlvbiggb2JqZWN0LCBoZXggKSB7XG5cbiAgICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSApICk7XG5cbiAgICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVIZWxwZXI7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL0ltbWVkaWF0ZVJlbmRlck9iamVjdC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCByZW5kZXJDYWxsYmFjayApIHt9O1xuXG59O1xuXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9Nb3JwaEJsZW5kTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIHRoaXMuYW5pbWF0aW9uc01hcCA9IHt9O1xuICAgIHRoaXMuYW5pbWF0aW9uc0xpc3QgPSBbXTtcblxuICAgIC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cbiAgICAvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXG5cbiAgICB2YXIgbnVtRnJhbWVzID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xuXG4gICAgdmFyIG5hbWUgPSBcIl9fZGVmYXVsdFwiO1xuXG4gICAgdmFyIHN0YXJ0RnJhbWUgPSAwO1xuICAgIHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XG5cbiAgICB2YXIgZnBzID0gbnVtRnJhbWVzIC8gMTtcblxuICAgIHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgZnBzICk7XG4gICAgdGhpcy5zZXRBbmltYXRpb25XZWlnaHQoIG5hbWUsIDEgKTtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1vcnBoQmxlbmRNZXNoO1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24oIG5hbWUsIHN0YXJ0LCBlbmQsIGZwcyApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB7XG5cbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCxcblxuICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMSxcblxuICAgICAgICBmcHM6IGZwcyxcbiAgICAgICAgZHVyYXRpb246ICggZW5kIC0gc3RhcnQgKSAvIGZwcyxcblxuICAgICAgICBsYXN0RnJhbWU6IDAsXG4gICAgICAgIGN1cnJlbnRGcmFtZTogMCxcblxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIGRpcmVjdGlvbjogMSxcbiAgICAgICAgd2VpZ2h0OiAxLFxuXG4gICAgICAgIGRpcmVjdGlvbkJhY2t3YXJkczogZmFsc2UsXG4gICAgICAgIG1pcnJvcmVkTG9vcDogZmFsc2VcblxuICAgIH07XG5cbiAgICB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXSA9IGFuaW1hdGlvbjtcbiAgICB0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiggZnBzICkge1xuXG4gICAgdmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS87XG5cbiAgICB2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBtb3JwaCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdO1xuICAgICAgICB2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG4gICAgICAgIGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xuXG4gICAgICAgICAgICBpZiAoICFmcmFtZVJhbmdlc1sgbmFtZSBdICkgZnJhbWVSYW5nZXNbIG5hbWUgXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgZW5kOiAtSW5maW5pdHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xuICAgICAgICAgICAgaWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcblxuICAgICAgICAgICAgaWYgKCAhZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gZnJhbWVSYW5nZXMgKSB7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcbiAgICAgICAgdGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uRm9yd2FyZCA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XG4gICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uID0gLTE7XG4gICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTID0gZnVuY3Rpb24oIG5hbWUsIGZwcyApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi5mcHMgPSBmcHM7XG4gICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmZwcztcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oIG5hbWUsIGR1cmF0aW9uICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIGFuaW1hdGlvbi5mcHMgPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uKCBuYW1lLCB3ZWlnaHQgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24ud2VpZ2h0ID0gd2VpZ2h0O1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uKCBuYW1lLCB0aW1lICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSB0aW1lO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgdmFyIHRpbWUgPSAwO1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgdGltZSA9IGFuaW1hdGlvbi50aW1lO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWU7XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgdmFyIGR1cmF0aW9uID0gLTE7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBkdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuICAgIH1cblxuICAgIHJldHVybiBkdXJhdGlvbjtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi50aW1lID0gMDtcbiAgICAgICAgYW5pbWF0aW9uLmFjdGl2ZSA9IHRydWU7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCBkZWx0YSApIHtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcblxuICAgICAgICBpZiAoICFhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGZyYW1lVGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbiAvIGFuaW1hdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmRpcmVjdGlvbiAqIGRlbHRhO1xuXG4gICAgICAgIGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcblxuICAgICAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uICo9IC0xO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcblxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLnRpbWUgJSBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgICAgICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ZnJhbWUgPSBhbmltYXRpb24uc3RhcnQgKyBUSFJFRS5NYXRoLmNsYW1wKCBNYXRoLmZsb29yKCBhbmltYXRpb24udGltZSAvIGZyYW1lVGltZSApLCAwLCBhbmltYXRpb24ubGVuZ3RoIC0gMSApO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcblxuICAgICAgICBpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xuXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gMDtcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cbiAgICAgICAgICAgIGFuaW1hdGlvbi5sYXN0RnJhbWUgPSBhbmltYXRpb24uY3VycmVudEZyYW1lO1xuICAgICAgICAgICAgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSA9IGtleWZyYW1lO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWl4ID0gKCBhbmltYXRpb24udGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG4gICAgICAgIGlmICggYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyApIG1peCA9IDEgLSBtaXg7XG5cbiAgICAgICAgaWYgKCBhbmltYXRpb24uY3VycmVudEZyYW1lICE9PSBhbmltYXRpb24ubGFzdEZyYW1lICkge1xuXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gbWl4ICogd2VpZ2h0O1xuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9ICggMSAtIG1peCApICogd2VpZ2h0O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSB3ZWlnaHQ7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59OyIsIi8qIHNoYWRlci1wYXJ0aWNsZS1lbmdpbmUgMS4wLjBcbiAqIFxuICogKGMpIDIwMTUgTHVrZSBNb29keSAoaHR0cDovL3d3dy5naXRodWIuY29tL3NxdWFyZWZlZXQpXG4gKiAgICAgT3JpZ2luYWxseSBiYXNlZCBvbiBMZWUgU3RlbWtvc2tpJ3Mgb3JpZ2luYWwgd29yayAoaHR0cHM6Ly9naXRodWIuY29tL3N0ZW1rb3NraS9zdGVta29za2kuZ2l0aHViLmNvbS9ibG9iL21hc3Rlci9UaHJlZS5qcy9qcy9QYXJ0aWNsZUVuZ2luZS5qcykuXG4gKlxuICogc2hhZGVyLXBhcnRpY2xlLWVuZ2luZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAoU2VlIExJQ0VOU0UgYXQgcm9vdCBvZiB0aGlzIHJlcG9zaXRvcnkuKVxuICovXG52YXIgU1BFID0ge1xuICAgIGRpc3RyaWJ1dGlvbnM6IHtcbiAgICAgICAgQk9YOiAxLFxuICAgICAgICBTUEhFUkU6IDIsXG4gICAgICAgIERJU0M6IDNcbiAgICB9LFxuICAgIHZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoOiA0XG59O1xuXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcInNwZVwiLCBTUEUpIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZXhwb3J0cyAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBtb2R1bGUgJiYgKG1vZHVsZS5leHBvcnRzID0gU1BFKSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5jb21wb25lbnRTaXplID0gYyB8fCAxLCB0aGlzLnNpemUgPSBiIHx8IDEsIHRoaXMuVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gYSB8fCBGbG9hdDMyQXJyYXksIHRoaXMuYXJyYXkgPSBuZXcgYShiICogdGhpcy5jb21wb25lbnRTaXplKSwgdGhpcy5pbmRleE9mZnNldCA9IGQgfHwgMFxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIuY29uc3RydWN0b3IgPSBTUEUuVHlwZWRBcnJheUhlbHBlciwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGMgPSB0aGlzLmFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gYiB8fCAoYSAqPSB0aGlzLmNvbXBvbmVudFNpemUpLCBjID4gYSA/IHRoaXMuc2hyaW5rKGEpIDogYSA+IGMgPyB0aGlzLmdyb3coYSkgOiB2b2lkIGNvbnNvbGUuaW5mbyhcIlR5cGVkQXJyYXkgaXMgYWxyZWFkeSBvZiBzaXplOlwiLCBhICsgXCIuXCIsIFwiV2lsbCBub3QgcmVzaXplLlwiKVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNocmluayA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuc3ViYXJyYXkoMCwgYSksIHRoaXMuc2l6ZSA9IGEsIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5ncm93ID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiID0gdGhpcy5hcnJheSxcbiAgICAgICAgYyA9IG5ldyB0aGlzLlR5cGVkQXJyYXlDb25zdHJ1Y3RvcihhKTtcbiAgICByZXR1cm4gYy5zZXQoYiksIHRoaXMuYXJyYXkgPSBjLCB0aGlzLnNpemUgPSBhLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGEgKj0gdGhpcy5jb21wb25lbnRTaXplLCBiICo9IHRoaXMuY29tcG9uZW50U2l6ZTtcbiAgICBmb3IgKHZhciBjID0gW10sIGQgPSB0aGlzLmFycmF5LCBlID0gZC5sZW5ndGgsIGYgPSAwOyBlID4gZjsgKytmKVxuICAgICAgICAoYSA+IGYgfHwgZiA+PSBiKSAmJiBjLnB1c2goZFtmXSk7XG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbUFycmF5KDAsIGMpLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0RnJvbUFycmF5ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjID0gYi5sZW5ndGgsXG4gICAgICAgIGQgPSBhICsgYztcbiAgICByZXR1cm4gZCA+IHRoaXMuYXJyYXkubGVuZ3RoID8gdGhpcy5ncm93KGQpIDogZCA8IHRoaXMuYXJyYXkubGVuZ3RoICYmIHRoaXMuc2hyaW5rKGQpLCB0aGlzLmFycmF5LnNldChiLCB0aGlzLmluZGV4T2Zmc2V0ICsgYSksIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWMyID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLnNldFZlYzJDb21wb25lbnRzKGEsIGIueCwgYi55KVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzJDb21wb25lbnRzID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkID0gdGhpcy5hcnJheSxcbiAgICAgICAgZSA9IHRoaXMuaW5kZXhPZmZzZXQgKyBhICogdGhpcy5jb21wb25lbnRTaXplO1xuICAgIHJldHVybiBkW2VdID0gYiwgZFtlICsgMV0gPSBjLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjMyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5zZXRWZWMzQ29tcG9uZW50cyhhLCBiLngsIGIueSwgYi56KVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzNDb21wb25lbnRzID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBlID0gdGhpcy5hcnJheSxcbiAgICAgICAgZiA9IHRoaXMuaW5kZXhPZmZzZXQgKyBhICogdGhpcy5jb21wb25lbnRTaXplO1xuICAgIHJldHVybiBlW2ZdID0gYiwgZVtmICsgMV0gPSBjLCBlW2YgKyAyXSA9IGQsIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWM0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLnNldFZlYzRDb21wb25lbnRzKGEsIGIueCwgYi55LCBiLnosIGIudylcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWM0Q29tcG9uZW50cyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZiA9IHRoaXMuYXJyYXksXG4gICAgICAgIGcgPSB0aGlzLmluZGV4T2Zmc2V0ICsgYSAqIHRoaXMuY29tcG9uZW50U2l6ZTtcbiAgICByZXR1cm4gZltnXSA9IGIsIGZbZyArIDFdID0gYywgZltnICsgMl0gPSBkLCBmW2cgKyAzXSA9IGUsIHRoaXNcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRNYXQzID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLnNldEZyb21BcnJheSh0aGlzLmluZGV4T2Zmc2V0ICsgYSAqIHRoaXMuY29tcG9uZW50U2l6ZSwgYi5lbGVtZW50cylcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRNYXQ0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLnNldEZyb21BcnJheSh0aGlzLmluZGV4T2Zmc2V0ICsgYSAqIHRoaXMuY29tcG9uZW50U2l6ZSwgYi5lbGVtZW50cylcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5zZXRWZWMzQ29tcG9uZW50cyhhLCBiLnIsIGIuZywgYi5iKVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldE51bWJlciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5hcnJheVt0aGlzLmluZGV4T2Zmc2V0ICsgYSAqIHRoaXMuY29tcG9uZW50U2l6ZV0gPSBiLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuZ2V0VmFsdWVBdEluZGV4ID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLmFycmF5W3RoaXMuaW5kZXhPZmZzZXQgKyBhXVxufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLmdldENvbXBvbmVudFZhbHVlQXRJbmRleCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5hcnJheS5zdWJhcnJheSh0aGlzLmluZGV4T2Zmc2V0ICsgYSAqIHRoaXMuY29tcG9uZW50U2l6ZSk7XG59LCBTUEUuU2hhZGVyQXR0cmlidXRlID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkID0gU1BFLlNoYWRlckF0dHJpYnV0ZS50eXBlU2l6ZU1hcDtcbiAgICB0aGlzLnR5cGUgPSBcInN0cmluZ1wiID09IHR5cGVvZiBhICYmIGQuaGFzT3duUHJvcGVydHkoYSkgPyBhIDogXCJmXCIsIHRoaXMuY29tcG9uZW50U2l6ZSA9IGRbdGhpcy50eXBlXSwgdGhpcy5hcnJheVR5cGUgPSBjIHx8IEZsb2F0MzJBcnJheSwgdGhpcy50eXBlZEFycmF5ID0gbnVsbCwgdGhpcy5idWZmZXJBdHRyaWJ1dGUgPSBudWxsLCB0aGlzLmR5bmFtaWNCdWZmZXIgPSAhIWIsIHRoaXMudXBkYXRlTWluID0gMCwgdGhpcy51cGRhdGVNYXggPSAwXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLmNvbnN0cnVjdG9yID0gU1BFLlNoYWRlckF0dHJpYnV0ZSwgU1BFLlNoYWRlckF0dHJpYnV0ZS50eXBlU2l6ZU1hcCA9IHtcbiAgICBmOiAxLFxuICAgIHYyOiAyLFxuICAgIHYzOiAzLFxuICAgIHY0OiA0LFxuICAgIGM6IDMsXG4gICAgbTM6IDksXG4gICAgbTQ6IDE2XG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5zZXRVcGRhdGVSYW5nZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLnVwZGF0ZU1pbiA9IE1hdGgubWluKGEgKiB0aGlzLmNvbXBvbmVudFNpemUsIHRoaXMudXBkYXRlTWluICogdGhpcy5jb21wb25lbnRTaXplKSwgdGhpcy51cGRhdGVNYXggPSBNYXRoLm1heChiICogdGhpcy5jb21wb25lbnRTaXplLCB0aGlzLnVwZGF0ZU1heCAqIHRoaXMuY29tcG9uZW50U2l6ZSlcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLmZsYWdVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYSA9IHRoaXMuYnVmZmVyQXR0cmlidXRlLFxuICAgICAgICBiID0gYS51cGRhdGVSYW5nZTtcbiAgICBiLm9mZnNldCA9IHRoaXMudXBkYXRlTWluLCBiLmNvdW50ID0gTWF0aC5taW4odGhpcy51cGRhdGVNYXggLSB0aGlzLnVwZGF0ZU1pbiArIHRoaXMuY29tcG9uZW50U2l6ZSwgdGhpcy50eXBlZEFycmF5LmFycmF5Lmxlbmd0aCksIGEubmVlZHNVcGRhdGUgPSAhMFxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUucmVzZXRVcGRhdGVSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMudXBkYXRlTWluID0gMCwgdGhpcy51cGRhdGVNYXggPSAwO1xufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUucmVzZXREeW5hbWljID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5idWZmZXJBdHRyaWJ1dGUuZHluYW1pYyA9IHRoaXMuZHluYW1pY0J1ZmZlclxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMudHlwZWRBcnJheS5zcGxpY2UoYSwgYiksIHRoaXMuZm9yY2VVcGRhdGVBbGwoKVxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuZm9yY2VVcGRhdGVBbGwgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5hcnJheSA9IHRoaXMudHlwZWRBcnJheS5hcnJheSwgdGhpcy5idWZmZXJBdHRyaWJ1dGUudXBkYXRlUmFuZ2Uub2Zmc2V0ID0gMCwgdGhpcy5idWZmZXJBdHRyaWJ1dGUudXBkYXRlUmFuZ2UuY291bnQgPSAtMSwgdGhpcy5idWZmZXJBdHRyaWJ1dGUuZHluYW1pYyA9ICExLCB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9ICEwXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5fZW5zdXJlVHlwZWRBcnJheSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAobnVsbCA9PT0gdGhpcy50eXBlZEFycmF5IHx8IHRoaXMudHlwZWRBcnJheS5zaXplICE9PSBhICogdGhpcy5jb21wb25lbnRTaXplKSAmJiAobnVsbCAhPT0gdGhpcy50eXBlZEFycmF5ICYmIHRoaXMudHlwZWRBcnJheS5zaXplICE9PSBhID8gdGhpcy50eXBlZEFycmF5LnNldFNpemUoYSkgOiBudWxsID09PSB0aGlzLnR5cGVkQXJyYXkgJiYgKHRoaXMudHlwZWRBcnJheSA9IG5ldyBTUEUuVHlwZWRBcnJheUhlbHBlcih0aGlzLmFycmF5VHlwZSwgYSwgdGhpcy5jb21wb25lbnRTaXplKSkpXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5fY3JlYXRlQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLl9lbnN1cmVUeXBlZEFycmF5KGEpLCBudWxsICE9PSB0aGlzLmJ1ZmZlckF0dHJpYnV0ZSA/ICh0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5hcnJheSA9IHRoaXMudHlwZWRBcnJheS5hcnJheSxcbiAgICB2b2lkICh0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9ICEwKSkgOiAodGhpcy5idWZmZXJBdHRyaWJ1dGUgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMudHlwZWRBcnJheS5hcnJheSwgdGhpcy5jb21wb25lbnRTaXplKSwgdm9pZCAodGhpcy5idWZmZXJBdHRyaWJ1dGUuZHluYW1pYyA9IHRoaXMuZHluYW1pY0J1ZmZlcikpXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gbnVsbCA9PT0gdGhpcy50eXBlZEFycmF5ID8gMCA6IHRoaXMudHlwZWRBcnJheS5hcnJheS5sZW5ndGhcbn0sIFNQRS5zaGFkZXJDaHVua3MgPSB7XG4gICAgZGVmaW5lczogW1wiI2RlZmluZSBQQUNLRURfQ09MT1JfU0laRSAyNTYuMFwiLCBcIiNkZWZpbmUgUEFDS0VEX0NPTE9SX0RJVklTT1IgMjU1LjBcIl0uam9pbihcIlxcblwiKSxcbiAgICB1bmlmb3JtczogW1widW5pZm9ybSBmbG9hdCBkZWx0YVRpbWU7XCIsIFwidW5pZm9ybSBmbG9hdCBydW5UaW1lO1wiLCBcInVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XCIsIFwidW5pZm9ybSB2ZWM0IHRleHR1cmVBbmltYXRpb247XCIsIFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIl0uam9pbihcIlxcblwiKSxcbiAgICBhdHRyaWJ1dGVzOiBbXCJhdHRyaWJ1dGUgdmVjNCBhY2NlbGVyYXRpb247XCIsIFwiYXR0cmlidXRlIHZlYzMgdmVsb2NpdHk7XCIsIFwiYXR0cmlidXRlIHZlYzQgcm90YXRpb247XCIsIFwiYXR0cmlidXRlIHZlYzMgcm90YXRpb25DZW50ZXI7XCIsIFwiYXR0cmlidXRlIHZlYzQgcGFyYW1zO1wiLCBcImF0dHJpYnV0ZSB2ZWM0IHNpemU7XCIsIFwiYXR0cmlidXRlIHZlYzQgYW5nbGU7XCIsIFwiYXR0cmlidXRlIHZlYzQgY29sb3I7XCIsIFwiYXR0cmlidXRlIHZlYzQgb3BhY2l0eTtcIl0uam9pbihcIlxcblwiKSxcbiAgICB2YXJ5aW5nczogW1widmFyeWluZyB2ZWM0IHZDb2xvcjtcIiwgXCIjaWZkZWYgU0hPVUxEX1JPVEFURV9URVhUVVJFXCIsIFwiICAgIHZhcnlpbmcgZmxvYXQgdkFuZ2xlO1wiLCBcIiNlbmRpZlwiLCBcIiNpZmRlZiBTSE9VTERfQ0FMQ1VMQVRFX1NQUklURVwiLCBcIiAgICB2YXJ5aW5nIHZlYzQgdlNwcml0ZVNoZWV0O1wiLCBcIiNlbmRpZlwiXS5qb2luKFwiXFxuXCIpLFxuICAgIGJyYW5jaEF2b2lkYW5jZUZ1bmN0aW9uczogW1wiZmxvYXQgd2hlbl9ndChmbG9hdCB4LCBmbG9hdCB5KSB7XCIsIFwiICAgIHJldHVybiBtYXgoc2lnbih4IC0geSksIDAuMCk7XCIsIFwifVwiLCBcImZsb2F0IHdoZW5fbHQoZmxvYXQgeCwgZmxvYXQgeSkge1wiLCBcIiAgICByZXR1cm4gbWluKCBtYXgoMS4wIC0gc2lnbih4IC0geSksIDAuMCksIDEuMCApO1wiLCBcIn1cIiwgXCJmbG9hdCB3aGVuX2VxKCBmbG9hdCB4LCBmbG9hdCB5ICkge1wiLCBcIiAgICByZXR1cm4gMS4wIC0gYWJzKCBzaWduKCB4IC0geSApICk7XCIsIFwifVwiLCBcImZsb2F0IHdoZW5fZ2UoZmxvYXQgeCwgZmxvYXQgeSkge1wiLCBcIiAgcmV0dXJuIDEuMCAtIHdoZW5fbHQoeCwgeSk7XCIsIFwifVwiLCBcImZsb2F0IHdoZW5fbGUoZmxvYXQgeCwgZmxvYXQgeSkge1wiLCBcIiAgcmV0dXJuIDEuMCAtIHdoZW5fZ3QoeCwgeSk7XCIsIFwifVwiLCBcImZsb2F0IGFuZChmbG9hdCBhLCBmbG9hdCBiKSB7XCIsIFwiICAgIHJldHVybiBhICogYjtcIiwgXCJ9XCIsIFwiZmxvYXQgb3IoZmxvYXQgYSwgZmxvYXQgYikge1wiLCBcIiAgICByZXR1cm4gbWluKGEgKyBiLCAxLjApO1wiLCBcIn1cIl0uam9pbihcIlxcblwiKSxcbiAgICB1bnBhY2tDb2xvcjogW1widmVjMyB1bnBhY2tDb2xvciggaW4gZmxvYXQgaGV4ICkge1wiLCBcIiAgIHZlYzMgYyA9IHZlYzMoIDAuMCApO1wiLCBcIiAgIGZsb2F0IHIgPSBtb2QoIChoZXggLyBQQUNLRURfQ09MT1JfU0laRSAvIFBBQ0tFRF9DT0xPUl9TSVpFKSwgUEFDS0VEX0NPTE9SX1NJWkUgKTtcIiwgXCIgICBmbG9hdCBnID0gbW9kKCAoaGV4IC8gUEFDS0VEX0NPTE9SX1NJWkUpLCBQQUNLRURfQ09MT1JfU0laRSApO1wiLCBcIiAgIGZsb2F0IGIgPSBtb2QoIGhleCwgUEFDS0VEX0NPTE9SX1NJWkUgKTtcIiwgXCIgICBjLnIgPSByIC8gUEFDS0VEX0NPTE9SX0RJVklTT1I7XCIsIFwiICAgYy5nID0gZyAvIFBBQ0tFRF9DT0xPUl9ESVZJU09SO1wiLCBcIiAgIGMuYiA9IGIgLyBQQUNLRURfQ09MT1JfRElWSVNPUjtcIiwgXCIgICByZXR1cm4gYztcIiwgXCJ9XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgZmxvYXRPdmVyTGlmZXRpbWU6IFtcImZsb2F0IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBpbiBmbG9hdCBwb3NpdGlvbkluVGltZSwgaW4gdmVjNCBhdHRyICkge1wiLCBcIiAgICBoaWdocCBmbG9hdCB2YWx1ZSA9IDAuMDtcIiwgXCIgICAgZmxvYXQgZGVsdGFBZ2UgPSBwb3NpdGlvbkluVGltZSAqIGZsb2F0KCBWQUxVRV9PVkVSX0xJRkVUSU1FX0xFTkdUSCAtIDEgKTtcIiwgXCIgICAgZmxvYXQgZkluZGV4ID0gMC4wO1wiLCBcIiAgICBmbG9hdCBzaG91bGRBcHBseVZhbHVlID0gMC4wO1wiLCBcIiAgICB2YWx1ZSArPSBhdHRyWyAwIF0gKiB3aGVuX2VxKCBkZWx0YUFnZSwgMC4wICk7XCIsIFwiXCIsIFwiICAgIGZvciggaW50IGkgPSAwOyBpIDwgVkFMVUVfT1ZFUl9MSUZFVElNRV9MRU5HVEggLSAxOyArK2kgKSB7XCIsIFwiICAgICAgIGZJbmRleCA9IGZsb2F0KCBpICk7XCIsIFwiICAgICAgIHNob3VsZEFwcGx5VmFsdWUgPSBhbmQoIHdoZW5fZ3QoIGRlbHRhQWdlLCBmSW5kZXggKSwgd2hlbl9sZSggZGVsdGFBZ2UsIGZJbmRleCArIDEuMCApICk7XCIsIFwiICAgICAgIHZhbHVlICs9IHNob3VsZEFwcGx5VmFsdWUgKiBtaXgoIGF0dHJbIGkgXSwgYXR0clsgaSArIDEgXSwgZGVsdGFBZ2UgLSBmSW5kZXggKTtcIiwgXCIgICAgfVwiLCBcIlwiLCBcIiAgICByZXR1cm4gdmFsdWU7XCIsIFwifVwiXS5qb2luKFwiXFxuXCIpLFxuICAgIGNvbG9yT3ZlckxpZmV0aW1lOiBbXCJ2ZWMzIGdldENvbG9yT3ZlckxpZmV0aW1lKCBpbiBmbG9hdCBwb3NpdGlvbkluVGltZSwgaW4gdmVjMyBjb2xvcjEsIGluIHZlYzMgY29sb3IyLCBpbiB2ZWMzIGNvbG9yMywgaW4gdmVjMyBjb2xvcjQgKSB7XCIsIFwiICAgIHZlYzMgdmFsdWUgPSB2ZWMzKCAwLjAgKTtcIiwgXCIgICAgdmFsdWUueCA9IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgdmVjNCggY29sb3IxLngsIGNvbG9yMi54LCBjb2xvcjMueCwgY29sb3I0LnggKSApO1wiLCBcIiAgICB2YWx1ZS55ID0gZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIHBvc2l0aW9uSW5UaW1lLCB2ZWM0KCBjb2xvcjEueSwgY29sb3IyLnksIGNvbG9yMy55LCBjb2xvcjQueSApICk7XCIsIFwiICAgIHZhbHVlLnogPSBnZXRGbG9hdE92ZXJMaWZldGltZSggcG9zaXRpb25JblRpbWUsIHZlYzQoIGNvbG9yMS56LCBjb2xvcjIueiwgY29sb3IzLnosIGNvbG9yNC56ICkgKTtcIiwgXCIgICAgcmV0dXJuIHZhbHVlO1wiLCBcIn1cIl0uam9pbihcIlxcblwiKSxcbiAgICBwYXJhbUZldGNoaW5nRnVuY3Rpb25zOiBbXCJmbG9hdCBnZXRBbGl2ZSgpIHtcIiwgXCIgICByZXR1cm4gcGFyYW1zLng7XCIsIFwifVwiLCBcImZsb2F0IGdldEFnZSgpIHtcIiwgXCIgICByZXR1cm4gcGFyYW1zLnk7XCIsIFwifVwiLCBcImZsb2F0IGdldE1heEFnZSgpIHtcIiwgXCIgICByZXR1cm4gcGFyYW1zLno7XCIsIFwifVwiLCBcImZsb2F0IGdldFdpZ2dsZSgpIHtcIiwgXCIgICByZXR1cm4gcGFyYW1zLnc7XCIsIFwifVwiXS5qb2luKFwiXFxuXCIpLFxuICAgIGZvcmNlRmV0Y2hpbmdGdW5jdGlvbnM6IFtcInZlYzQgZ2V0UG9zaXRpb24oIGluIGZsb2F0IGFnZSApIHtcIiwgXCIgICByZXR1cm4gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLCBcIn1cIiwgXCJ2ZWMzIGdldFZlbG9jaXR5KCBpbiBmbG9hdCBhZ2UgKSB7XCIsIFwiICAgcmV0dXJuIHZlbG9jaXR5ICogYWdlO1wiLCBcIn1cIiwgXCJ2ZWMzIGdldEFjY2VsZXJhdGlvbiggaW4gZmxvYXQgYWdlICkge1wiLCBcIiAgIHJldHVybiBhY2NlbGVyYXRpb24ueHl6ICogYWdlO1wiLCBcIn1cIl0uam9pbihcIlxcblwiKSxcbiAgICByb3RhdGlvbkZ1bmN0aW9uczogW1wiI2lmZGVmIFNIT1VMRF9ST1RBVEVfUEFSVElDTEVTXCIsIFwiICAgbWF0NCBnZXRSb3RhdGlvbk1hdHJpeCggaW4gdmVjMyBheGlzLCBpbiBmbG9hdCBhbmdsZSkge1wiLCBcIiAgICAgICBheGlzID0gbm9ybWFsaXplKGF4aXMpO1wiLCBcIiAgICAgICBmbG9hdCBzID0gc2luKGFuZ2xlKTtcIiwgXCIgICAgICAgZmxvYXQgYyA9IGNvcyhhbmdsZSk7XCIsIFwiICAgICAgIGZsb2F0IG9jID0gMS4wIC0gYztcIiwgXCIgICAgICAgcmV0dXJuIG1hdDQob2MgKiBheGlzLnggKiBheGlzLnggKyBjLCAgICAgICAgICAgb2MgKiBheGlzLnggKiBheGlzLnkgLSBheGlzLnogKiBzLCAgb2MgKiBheGlzLnogKiBheGlzLnggKyBheGlzLnkgKiBzLCAgMC4wLFwiLCBcIiAgICAgICAgICAgICAgICAgICBvYyAqIGF4aXMueCAqIGF4aXMueSArIGF4aXMueiAqIHMsICBvYyAqIGF4aXMueSAqIGF4aXMueSArIGMsICAgICAgICAgICBvYyAqIGF4aXMueSAqIGF4aXMueiAtIGF4aXMueCAqIHMsICAwLjAsXCIsIFwiICAgICAgICAgICAgICAgICAgIG9jICogYXhpcy56ICogYXhpcy54IC0gYXhpcy55ICogcywgIG9jICogYXhpcy55ICogYXhpcy56ICsgYXhpcy54ICogcywgIG9jICogYXhpcy56ICogYXhpcy56ICsgYywgICAgICAgICAgIDAuMCxcIiwgXCIgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wKTtcIiwgXCIgICB9XCIsIFwiICAgdmVjMyBnZXRSb3RhdGlvbiggaW4gdmVjMyBwb3MsIGluIGZsb2F0IHBvc2l0aW9uSW5UaW1lICkge1wiLCBcIiAgICAgIHZlYzMgYXhpcyA9IHVucGFja0NvbG9yKCByb3RhdGlvbi54ICk7XCIsIFwiICAgICAgdmVjMyBjZW50ZXIgPSByb3RhdGlvbkNlbnRlcjtcIiwgXCIgICAgICB2ZWMzIHRyYW5zbGF0ZWQ7XCIsIFwiICAgICAgbWF0NCByb3RhdGlvbk1hdHJpeDtcIiwgXCIgICAgICBmbG9hdCBhbmdsZSA9IDAuMDtcIiwgXCIgICAgICBhbmdsZSArPSB3aGVuX2VxKCByb3RhdGlvbi56LCAwLjAgKSAqIHJvdGF0aW9uLnk7XCIsIFwiICAgICAgYW5nbGUgKz0gd2hlbl9ndCggcm90YXRpb24ueiwgMC4wICkgKiBtaXgoIDAuMCwgcm90YXRpb24ueSwgcG9zaXRpb25JblRpbWUgKTtcIiwgXCIgICAgICB0cmFuc2xhdGVkID0gcG9zIC0gcm90YXRpb25DZW50ZXI7XCIsIFwiICAgICAgcm90YXRpb25NYXRyaXggPSBnZXRSb3RhdGlvbk1hdHJpeCggYXhpcywgYW5nbGUgKTtcIiwgXCIgICAgICByZXR1cm4gdmVjMyggcm90YXRpb25NYXRyaXggKiB2ZWM0KCB0cmFuc2xhdGVkLCAwLjAgKSApIC0gY2VudGVyO1wiLCBcIiAgIH1cIiwgXCIjZW5kaWZcIl0uam9pbihcIlxcblwiKSxcbiAgICByb3RhdGVUZXh0dXJlOiBbXCIgICAgdmVjMiB2VXYgPSB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApO1wiLCBcIlwiLCBcIiAgICAjaWZkZWYgU0hPVUxEX1JPVEFURV9URVhUVVJFXCIsIFwiICAgICAgIGZsb2F0IHggPSBnbF9Qb2ludENvb3JkLnggLSAwLjU7XCIsIFwiICAgICAgIGZsb2F0IHkgPSAxLjAgLSBnbF9Qb2ludENvb3JkLnkgLSAwLjU7XCIsIFwiICAgICAgIGZsb2F0IGMgPSBjb3MoIC12QW5nbGUgKTtcIiwgXCIgICAgICAgZmxvYXQgcyA9IHNpbiggLXZBbmdsZSApO1wiLCBcIiAgICAgICB2VXYgPSB2ZWMyKCBjICogeCArIHMgKiB5ICsgMC41LCBjICogeSAtIHMgKiB4ICsgMC41ICk7XCIsIFwiICAgICNlbmRpZlwiLCBcIlwiLCBcIiAgICAjaWZkZWYgU0hPVUxEX0NBTENVTEFURV9TUFJJVEVcIiwgXCIgICAgICAgIGZsb2F0IGZyYW1lc1ggPSB2U3ByaXRlU2hlZXQueDtcIiwgXCIgICAgICAgIGZsb2F0IGZyYW1lc1kgPSB2U3ByaXRlU2hlZXQueTtcIiwgXCIgICAgICAgIGZsb2F0IGNvbHVtbk5vcm0gPSB2U3ByaXRlU2hlZXQuejtcIiwgXCIgICAgICAgIGZsb2F0IHJvd05vcm0gPSB2U3ByaXRlU2hlZXQudztcIiwgXCIgICAgICAgIHZVdi54ID0gZ2xfUG9pbnRDb29yZC54ICogZnJhbWVzWCArIGNvbHVtbk5vcm07XCIsIFwiICAgICAgICB2VXYueSA9IDEuMCAtIChnbF9Qb2ludENvb3JkLnkgKiBmcmFtZXNZICsgcm93Tm9ybSk7XCIsIFwiICAgICNlbmRpZlwiLCBcIlwiLCBcIiAgICB2ZWM0IHJvdGF0ZWRUZXh0dXJlID0gdGV4dHVyZTJEKCB0ZXh0dXJlLCB2VXYgKTtcIl0uam9pbihcIlxcblwiKVxufSwgU1BFLnNoYWRlcnMgPSB7XG4gICAgdmVydGV4OiBbU1BFLnNoYWRlckNodW5rcy5kZWZpbmVzLCBTUEUuc2hhZGVyQ2h1bmtzLnVuaWZvcm1zLCBTUEUuc2hhZGVyQ2h1bmtzLmF0dHJpYnV0ZXMsIFNQRS5zaGFkZXJDaHVua3MudmFyeWluZ3MsIFRIUkVFLlNoYWRlckNodW5rLmNvbW1vbiwgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsIFNQRS5zaGFkZXJDaHVua3MuYnJhbmNoQXZvaWRhbmNlRnVuY3Rpb25zLCBTUEUuc2hhZGVyQ2h1bmtzLnVucGFja0NvbG9yLCBTUEUuc2hhZGVyQ2h1bmtzLmZsb2F0T3ZlckxpZmV0aW1lLCBTUEUuc2hhZGVyQ2h1bmtzLmNvbG9yT3ZlckxpZmV0aW1lLCBTUEUuc2hhZGVyQ2h1bmtzLnBhcmFtRmV0Y2hpbmdGdW5jdGlvbnMsIFNQRS5zaGFkZXJDaHVua3MuZm9yY2VGZXRjaGluZ0Z1bmN0aW9ucywgU1BFLnNoYWRlckNodW5rcy5yb3RhdGlvbkZ1bmN0aW9ucywgXCJ2b2lkIG1haW4oKSB7XCIsIFwiICAgIGhpZ2hwIGZsb2F0IGFnZSA9IGdldEFnZSgpO1wiLCBcIiAgICBoaWdocCBmbG9hdCBhbGl2ZSA9IGdldEFsaXZlKCk7XCIsIFwiICAgIGhpZ2hwIGZsb2F0IG1heEFnZSA9IGdldE1heEFnZSgpO1wiLCBcIiAgICBoaWdocCBmbG9hdCBwb3NpdGlvbkluVGltZSA9IChhZ2UgLyBtYXhBZ2UpO1wiLCBcIiAgICBoaWdocCBmbG9hdCBpc0FsaXZlID0gd2hlbl9ndCggYWxpdmUsIDAuMCApO1wiLCBcIiAgICAjaWZkZWYgU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVNcIiwgXCIgICAgICAgIGZsb2F0IHdpZ2dsZUFtb3VudCA9IHBvc2l0aW9uSW5UaW1lICogZ2V0V2lnZ2xlKCk7XCIsIFwiICAgICAgICBmbG9hdCB3aWdnbGVTaW4gPSBpc0FsaXZlICogc2luKCB3aWdnbGVBbW91bnQgKTtcIiwgXCIgICAgICAgIGZsb2F0IHdpZ2dsZUNvcyA9IGlzQWxpdmUgKiBjb3MoIHdpZ2dsZUFtb3VudCApO1wiLCBcIiAgICAjZW5kaWZcIiwgXCIgICAgdmVjMyB2ZWwgPSBnZXRWZWxvY2l0eSggYWdlICk7XCIsIFwiICAgIHZlYzMgYWNjZWwgPSBnZXRBY2NlbGVyYXRpb24oIGFnZSApO1wiLCBcIiAgICB2ZWMzIGZvcmNlID0gdmVjMyggMC4wICk7XCIsIFwiICAgIHZlYzMgcG9zID0gdmVjMyggcG9zaXRpb24gKTtcIiwgXCIgICAgZmxvYXQgZHJhZyA9IDEuMCAtIChwb3NpdGlvbkluVGltZSAqIDAuNSkgKiBhY2NlbGVyYXRpb24udztcIiwgXCIgICAgZm9yY2UgKz0gdmVsO1wiLCBcIiAgICBmb3JjZSAqPSBkcmFnO1wiLCBcIiAgICBmb3JjZSArPSBhY2NlbCAqIGFnZTtcIiwgXCIgICAgcG9zICs9IGZvcmNlO1wiLCBcIiAgICAjaWZkZWYgU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVNcIiwgXCIgICAgICAgIHBvcy54ICs9IHdpZ2dsZVNpbjtcIiwgXCIgICAgICAgIHBvcy55ICs9IHdpZ2dsZUNvcztcIiwgXCIgICAgICAgIHBvcy56ICs9IHdpZ2dsZVNpbjtcIiwgXCIgICAgI2VuZGlmXCIsIFwiICAgICNpZmRlZiBTSE9VTERfUk9UQVRFX1BBUlRJQ0xFU1wiLCBcIiAgICAgICAgcG9zID0gZ2V0Um90YXRpb24oIHBvcywgcG9zaXRpb25JblRpbWUgKTtcIiwgXCIgICAgI2VuZGlmXCIsIFwiICAgIHZlYzQgbXZQb3MgPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MsIDEuMCApO1wiLCBcIiAgICBoaWdocCBmbG9hdCBwb2ludFNpemUgPSBnZXRGbG9hdE92ZXJMaWZldGltZSggcG9zaXRpb25JblRpbWUsIHNpemUgKSAqIGlzQWxpdmU7XCIsIFwiICAgICNpZmRlZiBIQVNfUEVSU1BFQ1RJVkVcIiwgXCIgICAgICAgIGZsb2F0IHBlcnNwZWN0aXZlID0gc2NhbGUgLyBsZW5ndGgoIG12UG9zLnh5eiApO1wiLCBcIiAgICAjZWxzZVwiLCBcIiAgICAgICAgZmxvYXQgcGVyc3BlY3RpdmUgPSAxLjA7XCIsIFwiICAgICNlbmRpZlwiLCBcIiAgICBmbG9hdCBwb2ludFNpemVQZXJzcGVjdGl2ZSA9IHBvaW50U2l6ZSAqIHBlcnNwZWN0aXZlO1wiLCBcIiAgICAjaWZkZWYgQ09MT1JJWkVcIiwgXCIgICAgICAgdmVjMyBjID0gaXNBbGl2ZSAqIGdldENvbG9yT3ZlckxpZmV0aW1lKFwiLCBcIiAgICAgICAgICAgcG9zaXRpb25JblRpbWUsXCIsIFwiICAgICAgICAgICB1bnBhY2tDb2xvciggY29sb3IueCApLFwiLCBcIiAgICAgICAgICAgdW5wYWNrQ29sb3IoIGNvbG9yLnkgKSxcIiwgXCIgICAgICAgICAgIHVucGFja0NvbG9yKCBjb2xvci56ICksXCIsIFwiICAgICAgICAgICB1bnBhY2tDb2xvciggY29sb3IudyApXCIsIFwiICAgICAgICk7XCIsIFwiICAgICNlbHNlXCIsIFwiICAgICAgIHZlYzMgYyA9IHZlYzMoMS4wKTtcIiwgXCIgICAgI2VuZGlmXCIsIFwiICAgIGZsb2F0IG8gPSBpc0FsaXZlICogZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIHBvc2l0aW9uSW5UaW1lLCBvcGFjaXR5ICk7XCIsIFwiICAgIHZDb2xvciA9IHZlYzQoIGMsIG8gKTtcIiwgXCIgICAgI2lmZGVmIFNIT1VMRF9ST1RBVEVfVEVYVFVSRVwiLCBcIiAgICAgICAgdkFuZ2xlID0gaXNBbGl2ZSAqIGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgYW5nbGUgKTtcIiwgXCIgICAgI2VuZGlmXCIsIFwiICAgICNpZmRlZiBTSE9VTERfQ0FMQ1VMQVRFX1NQUklURVwiLCBcIiAgICAgICAgZmxvYXQgZnJhbWVzWCA9IHRleHR1cmVBbmltYXRpb24ueDtcIiwgXCIgICAgICAgIGZsb2F0IGZyYW1lc1kgPSB0ZXh0dXJlQW5pbWF0aW9uLnk7XCIsIFwiICAgICAgICBmbG9hdCBsb29wQ291bnQgPSB0ZXh0dXJlQW5pbWF0aW9uLnc7XCIsIFwiICAgICAgICBmbG9hdCB0b3RhbEZyYW1lcyA9IHRleHR1cmVBbmltYXRpb24uejtcIiwgXCIgICAgICAgIGZsb2F0IGZyYW1lTnVtYmVyID0gbW9kKCAocG9zaXRpb25JblRpbWUgKiBsb29wQ291bnQpICogdG90YWxGcmFtZXMsIHRvdGFsRnJhbWVzICk7XCIsIFwiICAgICAgICBmbG9hdCBjb2x1bW4gPSBmbG9vcihtb2QoIGZyYW1lTnVtYmVyLCBmcmFtZXNYICkpO1wiLCBcIiAgICAgICAgZmxvYXQgcm93ID0gZmxvb3IoIChmcmFtZU51bWJlciAtIGNvbHVtbikgLyBmcmFtZXNYICk7XCIsIFwiICAgICAgICBmbG9hdCBjb2x1bW5Ob3JtID0gY29sdW1uIC8gZnJhbWVzWDtcIiwgXCIgICAgICAgIGZsb2F0IHJvd05vcm0gPSByb3cgLyBmcmFtZXNZO1wiLCBcIiAgICAgICAgdlNwcml0ZVNoZWV0LnggPSAxLjAgLyBmcmFtZXNYO1wiLCBcIiAgICAgICAgdlNwcml0ZVNoZWV0LnkgPSAxLjAgLyBmcmFtZXNZO1wiLCBcIiAgICAgICAgdlNwcml0ZVNoZWV0LnogPSBjb2x1bW5Ob3JtO1wiLCBcIiAgICAgICAgdlNwcml0ZVNoZWV0LncgPSByb3dOb3JtO1wiLCBcIiAgICAjZW5kaWZcIiwgXCIgICAgZ2xfUG9pbnRTaXplID0gcG9pbnRTaXplUGVyc3BlY3RpdmU7XCIsIFwiICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zO1wiLCBUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl92ZXJ0ZXgsIFwifVwiXS5qb2luKFwiXFxuXCIpLFxuICAgIGZyYWdtZW50OiBbU1BFLnNoYWRlckNodW5rcy51bmlmb3JtcywgVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLCBUSFJFRS5TaGFkZXJDaHVuay5mb2dfcGFyc19mcmFnbWVudCwgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCwgU1BFLnNoYWRlckNodW5rcy52YXJ5aW5ncywgU1BFLnNoYWRlckNodW5rcy5icmFuY2hBdm9pZGFuY2VGdW5jdGlvbnMsIFwidm9pZCBtYWluKCkge1wiLCBcIiAgICB2ZWMzIG91dGdvaW5nTGlnaHQgPSB2Q29sb3IueHl6O1wiLCBcIiAgICBcIiwgXCIgICAgI2lmZGVmIEFMUEhBVEVTVFwiLCBcIiAgICAgICBpZiAoIHZDb2xvci53IDwgZmxvYXQoQUxQSEFURVNUKSApIGRpc2NhcmQ7XCIsIFwiICAgICNlbmRpZlwiLCBTUEUuc2hhZGVyQ2h1bmtzLnJvdGF0ZVRleHR1cmUsIFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX2ZyYWdtZW50LCBcIiAgICBvdXRnb2luZ0xpZ2h0ID0gdkNvbG9yLnh5eiAqIHJvdGF0ZWRUZXh0dXJlLnh5ejtcIiwgVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX2ZyYWdtZW50LCBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0Lnh5eiwgcm90YXRlZFRleHR1cmUudyAqIHZDb2xvci53ICk7XCIsIFwifVwiXS5qb2luKFwiXFxuXCIpXG59LCBTUEUudXRpbHMgPSB7XG4gICAgdHlwZXM6IHtcbiAgICAgICAgQk9PTEVBTjogXCJib29sZWFuXCIsXG4gICAgICAgIFNUUklORzogXCJzdHJpbmdcIixcbiAgICAgICAgTlVNQkVSOiBcIm51bWJlclwiLFxuICAgICAgICBPQkpFQ1Q6IFwib2JqZWN0XCJcbiAgICB9LFxuICAgIGVuc3VyZVR5cGVkQXJnOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IGIgPyBhIDogY1xuICAgIH0sXG4gICAgZW5zdXJlQXJyYXlUeXBlZEFyZzogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSBhLmxlbmd0aCAtIDE7IGQgPj0gMDsgLS1kKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYVtkXSAhPT0gYilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZVR5cGVkQXJnKGEsIGIsIGMpXG4gICAgfSxcbiAgICBlbnN1cmVJbnN0YW5jZU9mOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBiICYmIGEgaW5zdGFuY2VvZiBiID8gYSA6IGM7XG4gICAgfSxcbiAgICBlbnN1cmVBcnJheUluc3RhbmNlT2Y6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gYS5sZW5ndGggLSAxOyBkID49IDA7IC0tZClcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBiICYmIGFbZF0gaW5zdGFuY2VvZiBiID09ICExKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5zdGFuY2VPZihhLCBiLCBjKVxuICAgIH0sXG4gICAgZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBiID0gYiB8fCAzLCBjID0gYyB8fCAzLCBBcnJheS5pc0FycmF5KGEuX3ZhbHVlKSA9PT0gITEgJiYgKGEuX3ZhbHVlID0gW2EuX3ZhbHVlXSksIEFycmF5LmlzQXJyYXkoYS5fc3ByZWFkKSA9PT0gITEgJiYgKGEuX3NwcmVhZCA9IFthLl9zcHJlYWRdKTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmNsYW1wKGEuX3ZhbHVlLmxlbmd0aCwgYiwgYyksXG4gICAgICAgICAgICBlID0gdGhpcy5jbGFtcChhLl9zcHJlYWQubGVuZ3RoLCBiLCBjKSxcbiAgICAgICAgICAgIGYgPSBNYXRoLm1heChkLCBlKTtcbiAgICAgICAgYS5fdmFsdWUubGVuZ3RoICE9PSBmICYmIChhLl92YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdGVBcnJheShhLl92YWx1ZSwgZikpLCBhLl9zcHJlYWQubGVuZ3RoICE9PSBmICYmIChhLl9zcHJlYWQgPSB0aGlzLmludGVycG9sYXRlQXJyYXkoYS5fc3ByZWFkLCBmKSlcbiAgICB9LFxuICAgIGludGVycG9sYXRlQXJyYXk6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGZvciAodmFyIGMgPSBhLmxlbmd0aCwgZCA9IFtcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFbMF0uY2xvbmUgPyBhWzBdLmNsb25lKCkgOiBhWzBdXSwgZSA9IChjIC0gMSkgLyAoYiAtIDEpLCBmID0gMTsgYiAtIDEgPiBmOyArK2YpIHtcbiAgICAgICAgICAgIHZhciBnID0gZiAqIGUsXG4gICAgICAgICAgICAgICAgaCA9IE1hdGguZmxvb3IoZyksXG4gICAgICAgICAgICAgICAgaSA9IE1hdGguY2VpbChnKSxcbiAgICAgICAgICAgICAgICBqID0gZyAtIGg7XG4gICAgICAgICAgICBkW2ZdID0gdGhpcy5sZXJwVHlwZUFnbm9zdGljKGFbaF0sIGFbaV0sIGopXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQucHVzaChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFbYyAtIDFdLmNsb25lID8gYVtjIC0gMV0uY2xvbmUoKSA6IGFbYyAtIDFdKSwgZFxuICAgIH0sXG4gICAgY2xhbXA6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChiLCBNYXRoLm1pbihhLCBjKSlcbiAgICB9LFxuICAgIHplcm9Ub0Vwc2lsb246IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBjID0gMWUtNSxcbiAgICAgICAgICAgIGQgPSBhO1xuICAgICAgICByZXR1cm4gZCA9IGIgPyBNYXRoLnJhbmRvbSgpICogYyAqIDEwIDogYywgMCA+IGEgJiYgYSA+IC1jICYmIChkID0gLWQpLCBkXG4gICAgfSxcbiAgICBsZXJwVHlwZUFnbm9zdGljOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZCxcbiAgICAgICAgICAgIGUgPSB0aGlzLnR5cGVzO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IGUuTlVNQkVSICYmIHR5cGVvZiBiID09PSBlLk5VTUJFUiA/IGEgKyAoYiAtIGEpICogYyA6IGEgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyICYmIGIgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyID8gKGQgPSBhLmNsb25lKCksIGQueCA9IHRoaXMubGVycChhLngsIGIueCwgYyksIGQueSA9IHRoaXMubGVycChhLnksIGIueSwgYyksIGQpIDogYSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgJiYgYiBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyAoZCA9IGEuY2xvbmUoKSwgZC54ID0gdGhpcy5sZXJwKGEueCwgYi54LCBjKSwgZC55ID0gdGhpcy5sZXJwKGEueSwgYi55LCBjKSwgZC56ID0gdGhpcy5sZXJwKGEueiwgYi56LCBjKSwgZCkgOiBhIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCAmJiBiIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCA/IChkID0gYS5jbG9uZSgpLCBkLnggPSB0aGlzLmxlcnAoYS54LCBiLngsIGMpLCBkLnkgPSB0aGlzLmxlcnAoYS55LCBiLnksIGMpLCBkLnogPSB0aGlzLmxlcnAoYS56LCBiLnosIGMpLCBkLncgPSB0aGlzLmxlcnAoYS53LCBiLncsIGMpLCBkKSA6IGEgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciAmJiBiIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyAoZCA9IGEuY2xvbmUoKSwgZC5yID0gdGhpcy5sZXJwKGEuciwgYi5yLCBjKSwgZC5nID0gdGhpcy5sZXJwKGEuZywgYi5nLCBjKSwgZC5iID0gdGhpcy5sZXJwKGEuYiwgYi5iLCBjKSwgZCkgOiB2b2lkIGNvbnNvbGUud2FybihcIkludmFsaWQgYXJndW1lbnQgdHlwZXMsIG9yIGFyZ3VtZW50IHR5cGVzIGRvIG5vdCBtYXRjaDpcIiwgYSwgYilcbiAgICB9LFxuICAgIGxlcnA6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiBhICsgKGIgLSBhKSAqIGNcbiAgICB9LFxuICAgIHJvdW5kVG9OZWFyZXN0TXVsdGlwbGU6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgcmV0dXJuIDAgPT09IGIgPyBhIDogKGMgPSBNYXRoLmFicyhhKSAlIGIsXG4gICAgICAgIDAgPT09IGMgPyBhIDogMCA+IGEgPyAtKE1hdGguYWJzKGEpIC0gYykgOiBhICsgYiAtIGMpXG4gICAgfSxcbiAgICBhcnJheVZhbHVlc0FyZUVxdWFsOiBmdW5jdGlvbihhKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGEubGVuZ3RoIC0gMTsgKytiKVxuICAgICAgICAgICAgaWYgKGFbYl0gIT09IGFbYiArIDFdKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgcmV0dXJuICEwXG4gICAgfSxcbiAgICByYW5kb21GbG9hdDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuIGEgKyBiICogKE1hdGgucmFuZG9tKCkgLSAuNSlcbiAgICB9LFxuICAgIHJhbmRvbVZlY3RvcjM6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBmID0gYy54ICsgKE1hdGgucmFuZG9tKCkgKiBkLnggLSAuNSAqIGQueCksXG4gICAgICAgICAgICBnID0gYy55ICsgKE1hdGgucmFuZG9tKCkgKiBkLnkgLSAuNSAqIGQueSksXG4gICAgICAgICAgICBoID0gYy56ICsgKE1hdGgucmFuZG9tKCkgKiBkLnogLSAuNSAqIGQueik7XG4gICAgICAgIGUgJiYgKGYgPSAuNSAqIC1lLnggKyB0aGlzLnJvdW5kVG9OZWFyZXN0TXVsdGlwbGUoZiwgZS54KSwgZyA9IC41ICogLWUueSArIHRoaXMucm91bmRUb05lYXJlc3RNdWx0aXBsZShnLCBlLnkpLCBoID0gLjUgKiAtZS56ICsgdGhpcy5yb3VuZFRvTmVhcmVzdE11bHRpcGxlKGgsIGUueikpLCBhLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoYiwgZiwgZywgaClcbiAgICB9LFxuICAgIHJhbmRvbUNvbG9yOiBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZSA9IGMuciArIE1hdGgucmFuZG9tKCkgKiBkLngsXG4gICAgICAgICAgICBmID0gYy5nICsgTWF0aC5yYW5kb20oKSAqIGQueSxcbiAgICAgICAgICAgIGcgPSBjLmIgKyBNYXRoLnJhbmRvbSgpICogZC56O1xuICAgICAgICBlID0gdGhpcy5jbGFtcChlLCAwLCAxKSwgZiA9IHRoaXMuY2xhbXAoZiwgMCwgMSksIGcgPSB0aGlzLmNsYW1wKGcsIDAsIDEpLCBhLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoYiwgZSwgZiwgZylcbiAgICB9LFxuICAgIHJhbmRvbUNvbG9yQXNIZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGEgPSBuZXcgVEhSRUUuQ29sb3I7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihiLCBjLCBkLCBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gZC5sZW5ndGgsIGcgPSBbXSwgaCA9IDA7IGYgPiBoOyArK2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGVbaF07XG4gICAgICAgICAgICAgICAgYS5jb3B5KGRbaF0pLCBhLnIgKz0gTWF0aC5yYW5kb20oKSAqIGkueCAtIC41ICogaS54LCBhLmcgKz0gTWF0aC5yYW5kb20oKSAqIGkueSAtIC41ICogaS55LCBhLmIgKz0gTWF0aC5yYW5kb20oKSAqIGkueiAtIC41ICogaS56LFxuICAgICAgICAgICAgICAgIGEuciA9IHRoaXMuY2xhbXAoYS5yLCAwLCAxKSwgYS5nID0gdGhpcy5jbGFtcChhLmcsIDAsIDEpLCBhLmIgPSB0aGlzLmNsYW1wKGEuYiwgMCwgMSksIGcucHVzaChhLmdldEhleCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi50eXBlZEFycmF5LnNldFZlYzRDb21wb25lbnRzKGMsIGdbMF0sIGdbMV0sIGdbMl0sIGdbM10pXG4gICAgICAgIH1cbiAgICB9KCksXG4gICAgcmFuZG9tVmVjdG9yM09uU3BoZXJlOiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgaSA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMSxcbiAgICAgICAgICAgIGogPSA2LjI4MzIgKiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgICAgayA9IE1hdGguc3FydCgxIC0gaSAqIGkpLFxuICAgICAgICAgICAgbCA9IHRoaXMucmFuZG9tRmxvYXQoZCwgZSksXG4gICAgICAgICAgICBtID0gMCxcbiAgICAgICAgICAgIG4gPSAwLFxuICAgICAgICAgICAgbyA9IDA7XG4gICAgICAgIGcgJiYgKGwgPSBNYXRoLnJvdW5kKGwgLyBnKSAqIGcpLCBtID0gayAqIE1hdGguY29zKGopICogbCwgbiA9IGsgKiBNYXRoLnNpbihqKSAqIGwsIG8gPSBpICogbCwgbSAqPSBmLngsIG4gKj0gZi55LCBvICo9IGYueiwgbSArPSBjLngsIG4gKz0gYy55LCBvICs9IGMueiwgYS50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKGIsIG0sIG4sIG8pXG4gICAgfSxcbiAgICBzZWVkZWRSYW5kb206IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgdmFyIGIgPSAxZTQgKiBNYXRoLnNpbihhKTtcbiAgICAgICAgcmV0dXJuIGIgLSAoMCB8IGIpXG4gICAgfSxcbiAgICByYW5kb21WZWN0b3IzT25EaXNjOiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgaCA9IDYuMjgzMiAqIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICBpID0gTWF0aC5hYnModGhpcy5yYW5kb21GbG9hdChkLCBlKSksXG4gICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgIGsgPSAwLFxuICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgIGcgJiYgKGkgPSBNYXRoLnJvdW5kKGkgLyBnKSAqIGcpLCBqID0gTWF0aC5jb3MoaCkgKiBpLCBrID0gTWF0aC5zaW4oaCkgKiBpLCBqICo9IGYueCwgayAqPSBmLnksIGogKz0gYy54LCBrICs9IGMueSwgbCArPSBjLnosIGEudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyhiLCBqLCBrLCBsKVxuICAgIH0sXG4gICAgcmFuZG9tRGlyZWN0aW9uVmVjdG9yM09uU3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBhID0gbmV3IFRIUkVFLlZlY3RvcjM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKSB7XG4gICAgICAgICAgICBhLmNvcHkoZyksIGEueCAtPSBkLCBhLnkgLT0gZSwgYS56IC09IGYsIGEubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoLXRoaXMucmFuZG9tRmxvYXQoaCwgaSkpLCBiLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoYywgYS54LCBhLnksIGEueik7XG4gICAgICAgIH1cbiAgICB9KCksXG4gICAgcmFuZG9tRGlyZWN0aW9uVmVjdG9yM09uRGlzYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgYSA9IG5ldyBUSFJFRS5WZWN0b3IzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge1xuICAgICAgICAgICAgYS5jb3B5KGcpLCBhLnggLT0gZCwgYS55IC09IGUsIGEueiAtPSBmLCBhLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKC10aGlzLnJhbmRvbUZsb2F0KGgsIGkpKSwgYi50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKGMsIGEueCwgYS55LCAwKVxuICAgICAgICB9XG4gICAgfSgpLFxuICAgIGdldFBhY2tlZFJvdGF0aW9uQXhpczogZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgYSA9IG5ldyBUSFJFRS5WZWN0b3IzLFxuICAgICAgICAgICAgYiA9IG5ldyBUSFJFRS5WZWN0b3IzLFxuICAgICAgICAgICAgYyA9IG5ldyBUSFJFRS5Db2xvcjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNvcHkoZCkubm9ybWFsaXplKCksIGIuY29weShlKS5ub3JtYWxpemUoKSwgYS54ICs9IC41ICogLWUueCArIE1hdGgucmFuZG9tKCkgKiBlLngsIGEueSArPSAuNSAqIC1lLnkgKyBNYXRoLnJhbmRvbSgpICogZS55LCBhLnogKz0gLjUgKiAtZS56ICsgTWF0aC5yYW5kb20oKSAqIGUueiwgYS54ID0gTWF0aC5hYnMoYS54KSwgYS55ID0gTWF0aC5hYnMoYS55KSwgYS56ID0gTWF0aC5hYnMoYS56KSwgYS5ub3JtYWxpemUoKSwgYy5zZXRSR0IoYS54LCBhLnksIGEueiksIGMuZ2V0SGV4KClcbiAgICAgICAgfVxuICAgIH0oKVxufSwgU1BFLkdyb3VwID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiID0gU1BFLnV0aWxzLFxuICAgICAgICBjID0gYi50eXBlcztcbiAgICBhID0gYi5lbnN1cmVUeXBlZEFyZyhhLCBjLk9CSkVDVCwge30pLCBhLnRleHR1cmUgPSBiLmVuc3VyZVR5cGVkQXJnKGEudGV4dHVyZSwgYy5PQkpFQ1QsIHt9KSwgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKSwgdGhpcy5maXhlZFRpbWVTdGVwID0gYi5lbnN1cmVUeXBlZEFyZyhhLmZpeGVkVGltZVN0ZXAsIGMuTlVNQkVSLCAuMDE2KSwgdGhpcy50ZXh0dXJlID0gYi5lbnN1cmVJbnN0YW5jZU9mKGEudGV4dHVyZS52YWx1ZSwgVEhSRUUuVGV4dHVyZSwgbnVsbCksIHRoaXMudGV4dHVyZUZyYW1lcyA9IGIuZW5zdXJlSW5zdGFuY2VPZihhLnRleHR1cmUuZnJhbWVzLCBUSFJFRS5WZWN0b3IyLCBuZXcgVEhSRUUuVmVjdG9yMigxLCAxKSksXG4gICAgdGhpcy50ZXh0dXJlRnJhbWVDb3VudCA9IGIuZW5zdXJlVHlwZWRBcmcoYS50ZXh0dXJlLmZyYW1lQ291bnQsIGMuTlVNQkVSLCB0aGlzLnRleHR1cmVGcmFtZXMueCAqIHRoaXMudGV4dHVyZUZyYW1lcy55KSwgdGhpcy50ZXh0dXJlTG9vcCA9IGIuZW5zdXJlVHlwZWRBcmcoYS50ZXh0dXJlLmxvb3AsIGMuTlVNQkVSLCAxKSwgdGhpcy50ZXh0dXJlRnJhbWVzLm1heChuZXcgVEhSRUUuVmVjdG9yMigxLCAxKSksIHRoaXMuaGFzUGVyc3BlY3RpdmUgPSBiLmVuc3VyZVR5cGVkQXJnKGEuaGFzUGVyc3BlY3RpdmUsIGMuQk9PTEVBTiwgITApLCB0aGlzLmNvbG9yaXplID0gYi5lbnN1cmVUeXBlZEFyZyhhLmNvbG9yaXplLCBjLkJPT0xFQU4sICEwKSwgdGhpcy5tYXhQYXJ0aWNsZUNvdW50ID0gYi5lbnN1cmVUeXBlZEFyZyhhLm1heFBhcnRpY2xlQ291bnQsIGMuTlVNQkVSLCBudWxsKSwgdGhpcy5ibGVuZGluZyA9IGIuZW5zdXJlVHlwZWRBcmcoYS5ibGVuZGluZywgYy5OVU1CRVIsIFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcpLCB0aGlzLnRyYW5zcGFyZW50ID0gYi5lbnN1cmVUeXBlZEFyZyhhLnRyYW5zcGFyZW50LCBjLkJPT0xFQU4sICEwKSwgdGhpcy5hbHBoYVRlc3QgPSBwYXJzZUZsb2F0KGIuZW5zdXJlVHlwZWRBcmcoYS5hbHBoYVRlc3QsIGMuTlVNQkVSLCAwKSksIHRoaXMuZGVwdGhXcml0ZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5kZXB0aFdyaXRlLCBjLkJPT0xFQU4sICExKSwgdGhpcy5kZXB0aFRlc3QgPSBiLmVuc3VyZVR5cGVkQXJnKGEuZGVwdGhUZXN0LCBjLkJPT0xFQU4sICEwKSwgdGhpcy5mb2cgPSBiLmVuc3VyZVR5cGVkQXJnKGEuZm9nLCBjLkJPT0xFQU4sICEwKSwgdGhpcy5zY2FsZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5zY2FsZSwgYy5OVU1CRVIsIDMwMCksIHRoaXMuZW1pdHRlcnMgPSBbXSwgdGhpcy5lbWl0dGVySURzID0gW10sIHRoaXMuX3Bvb2wgPSBbXSwgdGhpcy5fcG9vbENyZWF0aW9uU2V0dGluZ3MgPSBudWxsLCB0aGlzLl9jcmVhdGVOZXdXaGVuUG9vbEVtcHR5ID0gMCwgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID0gITEsIHRoaXMuX2F0dHJpYnV0ZXNOZWVkRHluYW1pY1Jlc2V0ID0gITEsXG4gICAgdGhpcy5wYXJ0aWNsZUNvdW50ID0gMCwgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgdGV4dHVyZToge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50ZXh0dXJlXG4gICAgICAgIH0sXG4gICAgICAgIHRleHR1cmVBbmltYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwidjRcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCh0aGlzLnRleHR1cmVGcmFtZXMueCwgdGhpcy50ZXh0dXJlRnJhbWVzLnksIHRoaXMudGV4dHVyZUZyYW1lQ291bnQsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMudGV4dHVyZUxvb3ApLCAxKSlcbiAgICAgICAgfSxcbiAgICAgICAgZm9nQ29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgZm9nTmVhcjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMTBcbiAgICAgICAgfSxcbiAgICAgICAgZm9nRmFyOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAyMDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9nRGVuc2l0eToge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogLjVcbiAgICAgICAgfSxcbiAgICAgICAgZGVsdGFUaW1lOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJ1blRpbWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2NhbGVcbiAgICAgICAgfVxuICAgIH0sIHRoaXMuZGVmaW5lcyA9IHtcbiAgICAgICAgSEFTX1BFUlNQRUNUSVZFOiB0aGlzLmhhc1BlcnNwZWN0aXZlLFxuICAgICAgICBDT0xPUklaRTogdGhpcy5jb2xvcml6ZSxcbiAgICAgICAgVkFMVUVfT1ZFUl9MSUZFVElNRV9MRU5HVEg6IFNQRS52YWx1ZU92ZXJMaWZldGltZUxlbmd0aCxcbiAgICAgICAgU0hPVUxEX1JPVEFURV9URVhUVVJFOiAhMSxcbiAgICAgICAgU0hPVUxEX1JPVEFURV9QQVJUSUNMRVM6ICExLFxuICAgICAgICBTSE9VTERfV0lHR0xFX1BBUlRJQ0xFUzogITEsXG4gICAgICAgIFNIT1VMRF9DQUxDVUxBVEVfU1BSSVRFOiB0aGlzLnRleHR1cmVGcmFtZXMueCA+IDEgfHwgdGhpcy50ZXh0dXJlRnJhbWVzLnkgPiAxXG4gICAgfSwgdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgICBwb3NpdGlvbjogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2M1wiLCAhMCksXG4gICAgICAgIGFjY2VsZXJhdGlvbjogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2NFwiLCAhMCksXG4gICAgICAgIHZlbG9jaXR5OiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInYzXCIsICEwKSxcbiAgICAgICAgcm90YXRpb246IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjRcIiwgITApLFxuICAgICAgICByb3RhdGlvbkNlbnRlcjogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2M1wiLCAhMCksXG4gICAgICAgIHBhcmFtczogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2NFwiLCAhMCksXG4gICAgICAgIHNpemU6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjRcIiwgITApLFxuICAgICAgICBhbmdsZTogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2NFwiLCAhMCksXG4gICAgICAgIGNvbG9yOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInY0XCIsICEwKSxcbiAgICAgICAgb3BhY2l0eTogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2NFwiLCAhMClcbiAgICB9LCB0aGlzLmF0dHJpYnV0ZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLCB0aGlzLmF0dHJpYnV0ZUNvdW50ID0gdGhpcy5hdHRyaWJ1dGVLZXlzLmxlbmd0aCwgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFNQRS5zaGFkZXJzLnZlcnRleCxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFNQRS5zaGFkZXJzLmZyYWdtZW50LFxuICAgICAgICBibGVuZGluZzogdGhpcy5ibGVuZGluZyxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgIGFscGhhVGVzdDogdGhpcy5hbHBoYVRlc3QsXG4gICAgICAgIGRlcHRoV3JpdGU6IHRoaXMuZGVwdGhXcml0ZSxcbiAgICAgICAgZGVwdGhUZXN0OiB0aGlzLmRlcHRoVGVzdCxcbiAgICAgICAgZGVmaW5lczogdGhpcy5kZWZpbmVzLFxuICAgICAgICBmb2c6IHRoaXMuZm9nXG4gICAgfSksIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnksIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCksIG51bGwgPT09IHRoaXMubWF4UGFydGljbGVDb3VudCAmJiBjb25zb2xlLndhcm4oXCJTUEUuR3JvdXA6IE5vIG1heFBhcnRpY2xlQ291bnQgc3BlY2lmaWVkLiBBZGRpbmcgZW1pdHRlcnMgYWZ0ZXIgcmVuZGVyaW5nIHdpbGwgcHJvYmFibHkgY2F1c2UgZXJyb3JzLlwiKVxufSwgU1BFLkdyb3VwLmNvbnN0cnVjdG9yID0gU1BFLkdyb3VwLCBTUEUuR3JvdXAucHJvdG90eXBlLl91cGRhdGVEZWZpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGEsXG4gICAgICAgIGIgPSB0aGlzLmVtaXR0ZXJzLFxuICAgICAgICBjID0gYi5sZW5ndGggLSAxLFxuICAgICAgICBkID0gdGhpcy5kZWZpbmVzO1xuICAgIGZvciAoYzsgYyA+PSAwOyAtLWMpXG4gICAgICAgIGEgPSBiW2NdLCBkLlNIT1VMRF9DQUxDVUxBVEVfU1BSSVRFIHx8IChkLlNIT1VMRF9ST1RBVEVfVEVYVFVSRSA9IGQuU0hPVUxEX1JPVEFURV9URVhUVVJFIHx8ICEhTWF0aC5tYXgoTWF0aC5tYXguYXBwbHkobnVsbCwgYS5hbmdsZS52YWx1ZSksIE1hdGgubWF4LmFwcGx5KG51bGwsIGEuYW5nbGUuc3ByZWFkKSkpLFxuICAgICAgICBkLlNIT1VMRF9ST1RBVEVfUEFSVElDTEVTID0gZC5TSE9VTERfUk9UQVRFX1BBUlRJQ0xFUyB8fCAhIU1hdGgubWF4KGEucm90YXRpb24uYW5nbGUsIGEucm90YXRpb24uYW5nbGVTcHJlYWQpLCBkLlNIT1VMRF9XSUdHTEVfUEFSVElDTEVTID0gZC5TSE9VTERfV0lHR0xFX1BBUlRJQ0xFUyB8fCAhIU1hdGgubWF4KGEud2lnZ2xlLnZhbHVlLCBhLndpZ2dsZS5zcHJlYWQpO1xuICAgIHRoaXMubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSAhMFxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5fYXBwbHlBdHRyaWJ1dGVzVG9HZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhLFxuICAgICAgICBiLFxuICAgICAgICBjID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICBkID0gdGhpcy5nZW9tZXRyeSxcbiAgICAgICAgZSA9IGQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBmIGluIGMpXG4gICAgICAgIGMuaGFzT3duUHJvcGVydHkoZikgJiYgKGEgPSBjW2ZdLCBiID0gZVtmXSwgYiA/IGIuYXJyYXkgPSBhLnR5cGVkQXJyYXkuYXJyYXkgOiBkLmFkZEF0dHJpYnV0ZShmLCBhLmJ1ZmZlckF0dHJpYnV0ZSksIGEuYnVmZmVyQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gITApO1xuICAgIHRoaXMuZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKDAsIHRoaXMucGFydGljbGVDb3VudClcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuYWRkRW1pdHRlciA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFNQRS5FbWl0dGVyID09ICExKVxuICAgICAgICByZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiYGVtaXR0ZXJgIGFyZ3VtZW50IG11c3QgYmUgaW5zdGFuY2Ugb2YgU1BFLkVtaXR0ZXIuIFdhcyBwcm92aWRlZCB3aXRoOlwiLCBhKTtcbiAgICBpZiAodGhpcy5lbWl0dGVySURzLmluZGV4T2YoYS51dWlkKSA+IC0xKVxuICAgICAgICByZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiRW1pdHRlciBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIGdyb3VwLiBXaWxsIG5vdCBhZGQgYWdhaW4uXCIpO1xuICAgIGlmIChudWxsICE9PSBhLmdyb3VwKVxuICAgICAgICByZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiRW1pdHRlciBhbHJlYWR5IGJlbG9uZ3MgdG8gYW5vdGhlciBncm91cC4gV2lsbCBub3QgYWRkIHRvIHJlcXVlc3RlZCBncm91cC5cIik7XG4gICAgdmFyIGIgPSB0aGlzLmF0dHJpYnV0ZXMsXG4gICAgICAgIGMgPSB0aGlzLnBhcnRpY2xlQ291bnQsXG4gICAgICAgIGQgPSBjICsgYS5wYXJ0aWNsZUNvdW50O1xuICAgIHRoaXMucGFydGljbGVDb3VudCA9IGQsIG51bGwgIT09IHRoaXMubWF4UGFydGljbGVDb3VudCAmJiB0aGlzLnBhcnRpY2xlQ291bnQgPiB0aGlzLm1heFBhcnRpY2xlQ291bnQgJiYgY29uc29sZS53YXJuKFwiU1BFLkdyb3VwOiBtYXhQYXJ0aWNsZUNvdW50IGV4Y2VlZGVkLiBSZXF1ZXN0aW5nXCIsIHRoaXMucGFydGljbGVDb3VudCwgXCJwYXJ0aWNsZXMsIGNhbiBzdXBwb3J0IG9ubHlcIiwgdGhpcy5tYXhQYXJ0aWNsZUNvdW50KSwgYS5fY2FsY3VsYXRlUFBTVmFsdWUoYS5tYXhBZ2UuX3ZhbHVlICsgYS5tYXhBZ2UuX3NwcmVhZCksIGEuX3NldEJ1ZmZlclVwZGF0ZVJhbmdlcyh0aGlzLmF0dHJpYnV0ZUtleXMpLCBhLl9zZXRBdHRyaWJ1dGVPZmZzZXQoYyksIGEuZ3JvdXAgPSB0aGlzLCBhLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgZSBpbiBiKVxuICAgICAgICBiLmhhc093blByb3BlcnR5KGUpICYmIGJbZV0uX2NyZWF0ZUJ1ZmZlckF0dHJpYnV0ZShudWxsICE9PSB0aGlzLm1heFBhcnRpY2xlQ291bnQgPyB0aGlzLm1heFBhcnRpY2xlQ291bnQgOiB0aGlzLnBhcnRpY2xlQ291bnQpO1xuICAgIGZvciAodmFyIGYgPSBjOyBkID4gZjsgKytmKVxuICAgICAgICBhLl9hc3NpZ25Qb3NpdGlvblZhbHVlKGYpLCBhLl9hc3NpZ25Gb3JjZVZhbHVlKGYsIFwidmVsb2NpdHlcIiksIGEuX2Fzc2lnbkZvcmNlVmFsdWUoZiwgXCJhY2NlbGVyYXRpb25cIiksIGEuX2Fzc2lnbkFic0xpZmV0aW1lVmFsdWUoZiwgXCJvcGFjaXR5XCIpLCBhLl9hc3NpZ25BYnNMaWZldGltZVZhbHVlKGYsIFwic2l6ZVwiKSwgYS5fYXNzaWduQW5nbGVWYWx1ZShmKSwgYS5fYXNzaWduUm90YXRpb25WYWx1ZShmKSwgYS5fYXNzaWduUGFyYW1zVmFsdWUoZiksIGEuX2Fzc2lnbkNvbG9yVmFsdWUoZik7XG4gICAgcmV0dXJuIHRoaXMuX2FwcGx5QXR0cmlidXRlc1RvR2VvbWV0cnkoKSwgdGhpcy5lbWl0dGVycy5wdXNoKGEpLCB0aGlzLmVtaXR0ZXJJRHMucHVzaChhLnV1aWQpLCB0aGlzLl91cGRhdGVEZWZpbmVzKGEpLCB0aGlzLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gITAsIHRoaXMuZ2VvbWV0cnkubmVlZHNVcGRhdGUgPSAhMCwgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID0gITAsXG4gICAgdGhpc1xufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5yZW1vdmVFbWl0dGVyID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiID0gdGhpcy5lbWl0dGVySURzLmluZGV4T2YoYS51dWlkKTtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFNQRS5FbWl0dGVyID09ICExKVxuICAgICAgICByZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiYGVtaXR0ZXJgIGFyZ3VtZW50IG11c3QgYmUgaW5zdGFuY2Ugb2YgU1BFLkVtaXR0ZXIuIFdhcyBwcm92aWRlZCB3aXRoOlwiLCBhKTtcbiAgICBpZiAoLTEgPT09IGIpXG4gICAgICAgIHJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJFbWl0dGVyIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgZ3JvdXAuIFdpbGwgbm90IHJlbW92ZS5cIik7XG4gICAgZm9yICh2YXIgYyA9IGEuYXR0cmlidXRlT2Zmc2V0LCBkID0gYyArIGEucGFydGljbGVDb3VudCwgZSA9IHRoaXMuYXR0cmlidXRlcy5wYXJhbXMudHlwZWRBcnJheSwgZiA9IGM7IGQgPiBmOyArK2YpXG4gICAgICAgIGUuYXJyYXlbNCAqIGZdID0gMCwgZS5hcnJheVs0ICogZiArIDFdID0gMDtcbiAgICB0aGlzLmVtaXR0ZXJzLnNwbGljZShiLCAxKSwgdGhpcy5lbWl0dGVySURzLnNwbGljZShiLCAxKTtcbiAgICBmb3IgKHZhciBnIGluIHRoaXMuYXR0cmlidXRlcylcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGcpICYmIHRoaXMuYXR0cmlidXRlc1tnXS5zcGxpY2UoYywgZCk7XG4gICAgdGhpcy5wYXJ0aWNsZUNvdW50IC09IGEucGFydGljbGVDb3VudCwgYS5fb25SZW1vdmUoKSwgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID0gITBcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuZ2V0RnJvbVBvb2wgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYSA9IHRoaXMuX3Bvb2wsXG4gICAgICAgIGIgPSB0aGlzLl9jcmVhdGVOZXdXaGVuUG9vbEVtcHR5O1xuICAgIHJldHVybiBhLmxlbmd0aCA/IGEucG9wKCkgOiBiID8gbmV3IFNQRS5FbWl0dGVyKHRoaXMuX3Bvb2xDcmVhdGlvblNldHRpbmdzKSA6IG51bGxcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUucmVsZWFzZUludG9Qb29sID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgU1BFLkVtaXR0ZXIgPT0gITEgPyB2b2lkIGNvbnNvbGUuZXJyb3IoXCJBcmd1bWVudCBpcyBub3QgaW5zdGFuY2VvZiBTUEUuRW1pdHRlcjpcIiwgYSkgOiAoYS5yZXNldCgpLFxuICAgIHRoaXMuX3Bvb2wudW5zaGlmdChhKSwgdGhpcylcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuZ2V0UG9vbCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLl9wb29sXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLmFkZFBvb2wgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGQ7XG4gICAgdGhpcy5fcG9vbENyZWF0aW9uU2V0dGluZ3MgPSBiLCB0aGlzLl9jcmVhdGVOZXdXaGVuUG9vbEVtcHR5ID0gISFjO1xuICAgIGZvciAodmFyIGUgPSAwOyBhID4gZTsgKytlKVxuICAgICAgICBkID0gQXJyYXkuaXNBcnJheShiKSA/IG5ldyBTUEUuRW1pdHRlcihiW2VdKSA6IG5ldyBTUEUuRW1pdHRlcihiKSwgdGhpcy5hZGRFbWl0dGVyKGQpLCB0aGlzLnJlbGVhc2VJbnRvUG9vbChkKTtcbiAgICByZXR1cm4gdGhpc1xufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5fdHJpZ2dlclNpbmdsZUVtaXR0ZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIgPSB0aGlzLmdldEZyb21Qb29sKCksXG4gICAgICAgIGMgPSB0aGlzO1xuICAgIHJldHVybiBudWxsID09PSBiID8gdm9pZCBjb25zb2xlLmxvZyhcIlNQRS5Hcm91cCBwb29sIHJhbiBvdXQuXCIpIDogKGEgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICYmIChiLnBvc2l0aW9uLnZhbHVlLmNvcHkoYSksIGIucG9zaXRpb24udmFsdWUgPSBiLnBvc2l0aW9uLnZhbHVlKSwgYi5lbmFibGUoKSwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgYi5kaXNhYmxlKCksIGMucmVsZWFzZUludG9Qb29sKGIpXG4gICAgfSwgMWUzICogKGIubWF4QWdlLnZhbHVlICsgYi5tYXhBZ2Uuc3ByZWFkKSksIHRoaXMpXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLnRyaWdnZXJQb29sRW1pdHRlciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSAmJiBhID4gMSlcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGEgPiBjOyArK2MpXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyU2luZ2xlRW1pdHRlcihiKTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX3RyaWdnZXJTaW5nbGVFbWl0dGVyKGIpO1xuICAgIHJldHVybiB0aGlzXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLl91cGRhdGVVbmlmb3JtcyA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLnVuaWZvcm1zLnJ1blRpbWUudmFsdWUgKz0gYSxcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhVGltZS52YWx1ZSA9IGFcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuX3Jlc2V0QnVmZmVyUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGEgPSB0aGlzLmF0dHJpYnV0ZUtleXMsXG4gICAgICAgIGIgPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMSxcbiAgICAgICAgYyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBmb3IgKGI7IGIgPj0gMDsgLS1iKVxuICAgICAgICBjW2FbYl1dLnJlc2V0VXBkYXRlUmFuZ2UoKVxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5fdXBkYXRlQnVmZmVycyA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYixcbiAgICAgICAgYyxcbiAgICAgICAgZCxcbiAgICAgICAgZSA9IHRoaXMuYXR0cmlidXRlS2V5cyxcbiAgICAgICAgZiA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxLFxuICAgICAgICBnID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICBoID0gYS5idWZmZXJVcGRhdGVSYW5nZXM7XG4gICAgZm9yIChmOyBmID49IDA7IC0tZilcbiAgICAgICAgYiA9IGVbZl0sIGMgPSBoW2JdLCBkID0gZ1tiXSwgZC5zZXRVcGRhdGVSYW5nZShjLm1pbiwgYy5tYXgpLCBkLmZsYWdVcGRhdGUoKVxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiLFxuICAgICAgICBjID0gdGhpcy5lbWl0dGVycyxcbiAgICAgICAgZCA9IGMubGVuZ3RoLFxuICAgICAgICBlID0gYSB8fCB0aGlzLmZpeGVkVGltZVN0ZXAsXG4gICAgICAgIGYgPSB0aGlzLmF0dHJpYnV0ZUtleXMsXG4gICAgICAgIGcgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVVuaWZvcm1zKGUpLCB0aGlzLl9yZXNldEJ1ZmZlclJhbmdlcygpLCAwICE9PSBkIHx8IHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCAhPT0gITEgfHwgdGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgIT09ICExKSB7XG4gICAgICAgIGZvciAodmFyIGgsIGIgPSAwOyBkID4gYjsgKytiKVxuICAgICAgICAgICAgaCA9IGNbYl0sIGgudGljayhlKSwgdGhpcy5fdXBkYXRlQnVmZmVycyhoKTtcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNOZWVkRHluYW1pY1Jlc2V0ID09PSAhMCkge1xuICAgICAgICAgICAgZm9yIChiID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDE7IGIgPj0gMDsgLS1iKVxuICAgICAgICAgICAgICAgIGdbZltiXV0ucmVzZXREeW5hbWljKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzTmVlZER5bmFtaWNSZXNldCA9ICExXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCA9PT0gITApIHtcbiAgICAgICAgICAgIGZvciAoYiA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxOyBiID49IDA7IC0tYilcbiAgICAgICAgICAgICAgICBnW2ZbYl1dLmZvcmNlVXBkYXRlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzTmVlZFJlZnJlc2ggPSAhMSwgdGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgPSAhMFxuICAgICAgICB9XG4gICAgfVxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpLCB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKSwgdGhpc1xufSwgU1BFLkVtaXR0ZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIgPSBTUEUudXRpbHMsXG4gICAgICAgIGMgPSBiLnR5cGVzLFxuICAgICAgICBkID0gU1BFLnZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoO1xuICAgIGEgPSBiLmVuc3VyZVR5cGVkQXJnKGEsIGMuT0JKRUNULCB7fSksIGEucG9zaXRpb24gPSBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24sIGMuT0JKRUNULCB7fSksIGEudmVsb2NpdHkgPSBiLmVuc3VyZVR5cGVkQXJnKGEudmVsb2NpdHksIGMuT0JKRUNULCB7fSksIGEuYWNjZWxlcmF0aW9uID0gYi5lbnN1cmVUeXBlZEFyZyhhLmFjY2VsZXJhdGlvbiwgYy5PQkpFQ1QsIHt9KSwgYS5yYWRpdXMgPSBiLmVuc3VyZVR5cGVkQXJnKGEucmFkaXVzLCBjLk9CSkVDVCwge30pLCBhLmRyYWcgPSBiLmVuc3VyZVR5cGVkQXJnKGEuZHJhZywgYy5PQkpFQ1QsIHt9KSwgYS5yb3RhdGlvbiA9IGIuZW5zdXJlVHlwZWRBcmcoYS5yb3RhdGlvbiwgYy5PQkpFQ1QsIHt9KSwgYS5jb2xvciA9IGIuZW5zdXJlVHlwZWRBcmcoYS5jb2xvciwgYy5PQkpFQ1QsIHt9KSwgYS5vcGFjaXR5ID0gYi5lbnN1cmVUeXBlZEFyZyhhLm9wYWNpdHksIGMuT0JKRUNULCB7fSksIGEuc2l6ZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5zaXplLCBjLk9CSkVDVCwge30pLCBhLmFuZ2xlID0gYi5lbnN1cmVUeXBlZEFyZyhhLmFuZ2xlLCBjLk9CSkVDVCwge30pLCBhLndpZ2dsZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS53aWdnbGUsIGMuT0JKRUNULCB7fSksIGEubWF4QWdlID0gYi5lbnN1cmVUeXBlZEFyZyhhLm1heEFnZSwgYy5PQkpFQ1QsIHt9KSwgYS5vblBhcnRpY2xlU3Bhd24gJiYgY29uc29sZS53YXJuKFwib25QYXJ0aWNsZVNwYXduIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSBzZXQgcHJvcGVydGllcyBkaXJlY3RseSB0byBhbHRlciB2YWx1ZXMgYXQgcnVudGltZS5cIiksXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKSwgdGhpcy50eXBlID0gYi5lbnN1cmVUeXBlZEFyZyhhLnR5cGUsIGMuTlVNQkVSLCBTUEUuZGlzdHJpYnV0aW9ucy5CT1gpLCB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnBvc2l0aW9uLnZhbHVlLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnBvc2l0aW9uLnNwcmVhZCwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfc3ByZWFkQ2xhbXA6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnBvc2l0aW9uLnNwcmVhZENsYW1wLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9kaXN0cmlidXRpb246IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5kaXN0cmlidXRpb24sIGMuTlVNQkVSLCB0aGlzLnR5cGUpLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgX3JhZGl1czogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhZGl1cywgYy5OVU1CRVIsIDEwKSxcbiAgICAgICAgX3JhZGl1c1NjYWxlOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5wb3NpdGlvbi5zY2FsZSwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMSwgMSkpLFxuICAgICAgICBfZGlzdHJpYnV0aW9uQ2xhbXA6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5kaXN0cmlidXRpb25DbGFtcCwgYy5OVU1CRVIsIDApXG4gICAgfSwgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZUluc3RhbmNlT2YoYS52ZWxvY2l0eS52YWx1ZSwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZUluc3RhbmNlT2YoYS52ZWxvY2l0eS5zcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX2Rpc3RyaWJ1dGlvbjogYi5lbnN1cmVUeXBlZEFyZyhhLnZlbG9jaXR5LmRpc3RyaWJ1dGlvbiwgYy5OVU1CRVIsIHRoaXMudHlwZSksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy5hY2NlbGVyYXRpb24gPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVJbnN0YW5jZU9mKGEuYWNjZWxlcmF0aW9uLnZhbHVlLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlSW5zdGFuY2VPZihhLmFjY2VsZXJhdGlvbi5zcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX2Rpc3RyaWJ1dGlvbjogYi5lbnN1cmVUeXBlZEFyZyhhLmFjY2VsZXJhdGlvbi5kaXN0cmlidXRpb24sIGMuTlVNQkVSLCB0aGlzLnR5cGUpLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMuZHJhZyA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZVR5cGVkQXJnKGEuZHJhZy52YWx1ZSwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZVR5cGVkQXJnKGEuZHJhZy5zcHJlYWQsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLndpZ2dsZSA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZVR5cGVkQXJnKGEud2lnZ2xlLnZhbHVlLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlVHlwZWRBcmcoYS53aWdnbGUuc3ByZWFkLCBjLk5VTUJFUiwgMClcbiAgICB9LCB0aGlzLnJvdGF0aW9uID0ge1xuICAgICAgICBfYXhpczogYi5lbnN1cmVJbnN0YW5jZU9mKGEucm90YXRpb24uYXhpcywgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCkpLFxuICAgICAgICBfYXhpc1NwcmVhZDogYi5lbnN1cmVJbnN0YW5jZU9mKGEucm90YXRpb24uYXhpc1NwcmVhZCwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfYW5nbGU6IGIuZW5zdXJlVHlwZWRBcmcoYS5yb3RhdGlvbi5hbmdsZSwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfYW5nbGVTcHJlYWQ6IGIuZW5zdXJlVHlwZWRBcmcoYS5yb3RhdGlvbi5hbmdsZVNwcmVhZCwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfc3RhdGljOiBiLmVuc3VyZVR5cGVkQXJnKGEucm90YXRpb25bXCJzdGF0aWNcIl0sIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICBfY2VudGVyOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5yb3RhdGlvbi5jZW50ZXIsIFRIUkVFLlZlY3RvcjMsIHRoaXMucG9zaXRpb24uX3ZhbHVlLmNsb25lKCkpLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMubWF4QWdlID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlVHlwZWRBcmcoYS5tYXhBZ2UudmFsdWUsIGMuTlVNQkVSLCAyKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVUeXBlZEFyZyhhLm1heEFnZS5zcHJlYWQsIGMuTlVNQkVSLCAwKVxuICAgIH0sIHRoaXMuY29sb3IgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVBcnJheUluc3RhbmNlT2YoYS5jb2xvci52YWx1ZSwgVEhSRUUuQ29sb3IsIG5ldyBUSFJFRS5Db2xvciksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlQXJyYXlJbnN0YW5jZU9mKGEuY29sb3Iuc3ByZWFkLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy5vcGFjaXR5ID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlQXJyYXlUeXBlZEFyZyhhLm9wYWNpdHkudmFsdWUsIGMuTlVNQkVSLCAxKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVBcnJheVR5cGVkQXJnKGEub3BhY2l0eS5zcHJlYWQsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLnNpemUgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVBcnJheVR5cGVkQXJnKGEuc2l6ZS52YWx1ZSwgYy5OVU1CRVIsIDEpLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZUFycmF5VHlwZWRBcmcoYS5zaXplLnNwcmVhZCwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMuYW5nbGUgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVBcnJheVR5cGVkQXJnKGEuYW5nbGUudmFsdWUsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVBcnJheVR5cGVkQXJnKGEuYW5nbGUuc3ByZWFkLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy5wYXJ0aWNsZUNvdW50ID0gYi5lbnN1cmVUeXBlZEFyZyhhLnBhcnRpY2xlQ291bnQsIGMuTlVNQkVSLCAxMDApLFxuICAgIHRoaXMuZHVyYXRpb24gPSBiLmVuc3VyZVR5cGVkQXJnKGEuZHVyYXRpb24sIGMuTlVNQkVSLCBudWxsKSwgdGhpcy5pc1N0YXRpYyA9IGIuZW5zdXJlVHlwZWRBcmcoYS5pc1N0YXRpYywgYy5CT09MRUFOLCAhMSksIHRoaXMuYWN0aXZlTXVsdGlwbGllciA9IGIuZW5zdXJlVHlwZWRBcmcoYS5hY3RpdmVNdWx0aXBsaWVyLCBjLk5VTUJFUiwgMSksIHRoaXMuZGlyZWN0aW9uID0gYi5lbnN1cmVUeXBlZEFyZyhhLmRpcmVjdGlvbiwgYy5OVU1CRVIsIDEpLCB0aGlzLmFsaXZlID0gYi5lbnN1cmVUeXBlZEFyZyhhLmFsaXZlLCBjLkJPT0xFQU4sICEwKSwgdGhpcy5wYXJ0aWNsZXNQZXJTZWNvbmQgPSAwLCB0aGlzLmFjdGl2YXRpb25JbmRleCA9IDAsIHRoaXMuYXR0cmlidXRlT2Zmc2V0ID0gMCwgdGhpcy5hdHRyaWJ1dGVFbmQgPSAwLCB0aGlzLmFnZSA9IDAsIHRoaXMuYWN0aXZlUGFydGljbGVDb3VudCA9IDAsIHRoaXMuZ3JvdXAgPSBudWxsLCB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsLCB0aGlzLnBhcmFtc0FycmF5ID0gbnVsbCwgdGhpcy5yZXNldEZsYWdzID0ge1xuICAgICAgICBwb3NpdGlvbjogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSkgfHwgYi5lbnN1cmVUeXBlZEFyZyhhLnJhZGl1cy5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICB2ZWxvY2l0eTogYi5lbnN1cmVUeXBlZEFyZyhhLnZlbG9jaXR5LnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIGFjY2VsZXJhdGlvbjogYi5lbnN1cmVUeXBlZEFyZyhhLmFjY2VsZXJhdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpIHx8IGIuZW5zdXJlVHlwZWRBcmcoYS5kcmFnLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIHJvdGF0aW9uOiBiLmVuc3VyZVR5cGVkQXJnKGEucm90YXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgcm90YXRpb25DZW50ZXI6IGIuZW5zdXJlVHlwZWRBcmcoYS5yb3RhdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICBzaXplOiBiLmVuc3VyZVR5cGVkQXJnKGEuc2l6ZS5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICBjb2xvcjogYi5lbnN1cmVUeXBlZEFyZyhhLmNvbG9yLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIG9wYWNpdHk6IGIuZW5zdXJlVHlwZWRBcmcoYS5vcGFjaXR5LnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIGFuZ2xlOiBiLmVuc3VyZVR5cGVkQXJnKGEuYW5nbGUucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMudXBkYXRlRmxhZ3MgPSB7fSwgdGhpcy51cGRhdGVDb3VudHMgPSB7fSwgdGhpcy51cGRhdGVNYXAgPSB7XG4gICAgICAgIG1heEFnZTogXCJwYXJhbXNcIixcbiAgICAgICAgcG9zaXRpb246IFwicG9zaXRpb25cIixcbiAgICAgICAgdmVsb2NpdHk6IFwidmVsb2NpdHlcIixcbiAgICAgICAgYWNjZWxlcmF0aW9uOiBcImFjY2VsZXJhdGlvblwiLFxuICAgICAgICBkcmFnOiBcImFjY2VsZXJhdGlvblwiLFxuICAgICAgICB3aWdnbGU6IFwicGFyYW1zXCIsXG4gICAgICAgIHJvdGF0aW9uOiBcInJvdGF0aW9uXCIsXG4gICAgICAgIHNpemU6IFwic2l6ZVwiLFxuICAgICAgICBjb2xvcjogXCJjb2xvclwiLFxuICAgICAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICAgICAgYW5nbGU6IFwiYW5nbGVcIlxuICAgIH07XG4gICAgZm9yICh2YXIgZSBpbiB0aGlzLnVwZGF0ZU1hcClcbiAgICAgICAgdGhpcy51cGRhdGVNYXAuaGFzT3duUHJvcGVydHkoZSkgJiYgKHRoaXMudXBkYXRlQ291bnRzW3RoaXMudXBkYXRlTWFwW2VdXSA9IDAsIHRoaXMudXBkYXRlRmxhZ3NbdGhpcy51cGRhdGVNYXBbZV1dID0gITEsIHRoaXMuX2NyZWF0ZUdldHRlclNldHRlcnModGhpc1tlXSwgZSkpO1xuICAgIHRoaXMuYnVmZmVyVXBkYXRlUmFuZ2VzID0ge30sIHRoaXMuYXR0cmlidXRlS2V5cyA9IG51bGwsIHRoaXMuYXR0cmlidXRlQ291bnQgPSAwLCBiLmVuc3VyZVZhbHVlT3ZlckxpZmV0aW1lQ29tcGxpYW5jZSh0aGlzLmNvbG9yLCBkLCBkKSwgYi5lbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2UodGhpcy5vcGFjaXR5LCBkLCBkKSwgYi5lbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2UodGhpcy5zaXplLCBkLCBkKSwgYi5lbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2UodGhpcy5hbmdsZSwgZCwgZClcbn0sIFNQRS5FbWl0dGVyLmNvbnN0cnVjdG9yID0gU1BFLkVtaXR0ZXIsIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fY3JlYXRlR2V0dGVyU2V0dGVycyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYyA9IHRoaXM7XG4gICAgZm9yICh2YXIgZCBpbiBhKVxuICAgICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShkKSkge1xuICAgICAgICAgICAgdmFyIGUgPSBkLnJlcGxhY2UoXCJfXCIsIFwiXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGUsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbYV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oZCksXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGMudXBkYXRlTWFwW2JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSB0aGlzW2FdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBTUEUudmFsdWVPdmVyTGlmZXRpbWVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIl9yb3RhdGlvbkNlbnRlclwiID09PSBhID8gKGMudXBkYXRlRmxhZ3Mucm90YXRpb25DZW50ZXIgPSAhMCwgYy51cGRhdGVDb3VudHMucm90YXRpb25DZW50ZXIgPSAwKSA6IFwiX3JhbmRvbWlzZVwiID09PSBhID8gYy5yZXNldEZsYWdzW2VdID0gZCA6IChjLnVwZGF0ZUZsYWdzW2VdID0gITAsIGMudXBkYXRlQ291bnRzW2VdID0gMCksIGMuZ3JvdXAuX3VwZGF0ZURlZmluZXMoKSwgdGhpc1thXSA9IGQsIEFycmF5LmlzQXJyYXkoZikgJiYgU1BFLnV0aWxzLmVuc3VyZVZhbHVlT3ZlckxpZmV0aW1lQ29tcGxpYW5jZShjW2JdLCBnLCBnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfShkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9zZXRCdWZmZXJVcGRhdGVSYW5nZXMgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5hdHRyaWJ1dGVLZXlzID0gYSwgdGhpcy5hdHRyaWJ1dGVDb3VudCA9IGEubGVuZ3RoO1xuICAgIGZvciAodmFyIGIgPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMTsgYiA+PSAwOyAtLWIpXG4gICAgICAgIHRoaXMuYnVmZmVyVXBkYXRlUmFuZ2VzW2FbYl1dID0ge1xuICAgICAgICAgICAgbWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICB9XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZVBQU1ZhbHVlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiID0gdGhpcy5wYXJ0aWNsZUNvdW50O1xuICAgIHRoaXMuZHVyYXRpb24gPyB0aGlzLnBhcnRpY2xlc1BlclNlY29uZCA9IGIgLyAoYSA8IHRoaXMuZHVyYXRpb24gPyBhIDogdGhpcy5kdXJhdGlvbikgOiB0aGlzLnBhcnRpY2xlc1BlclNlY29uZCA9IGIgLyBhXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX3NldEF0dHJpYnV0ZU9mZnNldCA9IGZ1bmN0aW9uKGEpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZU9mZnNldCA9IGEsIHRoaXMuYWN0aXZhdGlvbkluZGV4ID0gYSxcbiAgICB0aGlzLmFjdGl2YXRpb25FbmQgPSBhICsgdGhpcy5wYXJ0aWNsZUNvdW50XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnblZhbHVlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHN3aXRjaCAoYSkge1xuICAgIGNhc2UgXCJwb3NpdGlvblwiOlxuICAgICAgICB0aGlzLl9hc3NpZ25Qb3NpdGlvblZhbHVlKGIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwidmVsb2NpdHlcIjpcbiAgICBjYXNlIFwiYWNjZWxlcmF0aW9uXCI6XG4gICAgICAgIHRoaXMuX2Fzc2lnbkZvcmNlVmFsdWUoYiwgYSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzaXplXCI6XG4gICAgY2FzZSBcIm9wYWNpdHlcIjpcbiAgICAgICAgdGhpcy5fYXNzaWduQWJzTGlmZXRpbWVWYWx1ZShiLCBhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFuZ2xlXCI6XG4gICAgICAgIHRoaXMuX2Fzc2lnbkFuZ2xlVmFsdWUoYik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwYXJhbXNcIjpcbiAgICAgICAgdGhpcy5fYXNzaWduUGFyYW1zVmFsdWUoYik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyb3RhdGlvblwiOlxuICAgICAgICB0aGlzLl9hc3NpZ25Sb3RhdGlvblZhbHVlKGIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgdGhpcy5fYXNzaWduQ29sb3JWYWx1ZShiKVxuICAgIH1cbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduUG9zaXRpb25WYWx1ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYiA9IFNQRS5kaXN0cmlidXRpb25zLFxuICAgICAgICBjID0gU1BFLnV0aWxzLFxuICAgICAgICBkID0gdGhpcy5wb3NpdGlvbixcbiAgICAgICAgZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbixcbiAgICAgICAgZiA9IGQuX3ZhbHVlLFxuICAgICAgICBnID0gZC5fc3ByZWFkLFxuICAgICAgICBoID0gZC5fZGlzdHJpYnV0aW9uO1xuICAgIHN3aXRjaCAoaCkge1xuICAgIGNhc2UgYi5CT1g6XG4gICAgICAgIGMucmFuZG9tVmVjdG9yMyhlLCBhLCBmLCBnLCBkLl9zcHJlYWRDbGFtcCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgYi5TUEhFUkU6XG4gICAgICAgIGMucmFuZG9tVmVjdG9yM09uU3BoZXJlKGUsIGEsIGYsIGQuX3JhZGl1cywgZC5fc3ByZWFkLngsIGQuX3JhZGl1c1NjYWxlLCBkLl9zcHJlYWRDbGFtcC54LCBkLl9kaXN0cmlidXRpb25DbGFtcCB8fCB0aGlzLnBhcnRpY2xlQ291bnQpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIGIuRElTQzpcbiAgICAgICAgYy5yYW5kb21WZWN0b3IzT25EaXNjKGUsIGEsIGYsIGQuX3JhZGl1cywgZC5fc3ByZWFkLngsIGQuX3JhZGl1c1NjYWxlLCBkLl9zcHJlYWRDbGFtcC54KVxuICAgIH1cbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduRm9yY2VWYWx1ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYyxcbiAgICAgICAgZCxcbiAgICAgICAgZSxcbiAgICAgICAgZixcbiAgICAgICAgZyxcbiAgICAgICAgaCA9IFNQRS5kaXN0cmlidXRpb25zLFxuICAgICAgICBpID0gU1BFLnV0aWxzLFxuICAgICAgICBqID0gdGhpc1tiXSxcbiAgICAgICAgayA9IGouX3ZhbHVlLFxuICAgICAgICBsID0gai5fc3ByZWFkLFxuICAgICAgICBtID0gai5fZGlzdHJpYnV0aW9uO1xuICAgIHN3aXRjaCAobSkge1xuICAgIGNhc2UgaC5CT1g6XG4gICAgICAgIGkucmFuZG9tVmVjdG9yMyh0aGlzLmF0dHJpYnV0ZXNbYl0sIGEsIGssIGwpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIGguU1BIRVJFOlxuICAgICAgICBjID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLnR5cGVkQXJyYXkuYXJyYXksIGcgPSAzICogYSwgZCA9IGNbZ10sIGUgPSBjW2cgKyAxXSwgZiA9IGNbZyArIDJdLCBpLnJhbmRvbURpcmVjdGlvblZlY3RvcjNPblNwaGVyZSh0aGlzLmF0dHJpYnV0ZXNbYl0sIGEsIGQsIGUsIGYsIHRoaXMucG9zaXRpb24uX3ZhbHVlLCBqLl92YWx1ZS54LCBqLl9zcHJlYWQueCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgaC5ESVNDOlxuICAgICAgICBjID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLnR5cGVkQXJyYXkuYXJyYXksIGcgPSAzICogYSwgZCA9IGNbZ10sIGUgPSBjW2cgKyAxXSwgZiA9IGNbZyArIDJdLCBpLnJhbmRvbURpcmVjdGlvblZlY3RvcjNPbkRpc2ModGhpcy5hdHRyaWJ1dGVzW2JdLCBhLCBkLCBlLCBmLCB0aGlzLnBvc2l0aW9uLl92YWx1ZSwgai5fdmFsdWUueCwgai5fc3ByZWFkLngpXG4gICAgfVxuICAgIGlmIChcImFjY2VsZXJhdGlvblwiID09PSBiKSB7XG4gICAgICAgIHZhciBuID0gaS5jbGFtcChpLnJhbmRvbUZsb2F0KHRoaXMuZHJhZy5fdmFsdWUsIHRoaXMuZHJhZy5fc3ByZWFkKSwgMCwgMSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5hY2NlbGVyYXRpb24udHlwZWRBcnJheS5hcnJheVs0ICogYSArIDNdID0gblxuICAgIH1cbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduQWJzTGlmZXRpbWVWYWx1ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYyxcbiAgICAgICAgZCA9IHRoaXMuYXR0cmlidXRlc1tiXS50eXBlZEFycmF5LFxuICAgICAgICBlID0gdGhpc1tiXSxcbiAgICAgICAgZiA9IFNQRS51dGlscztcbiAgICBmLmFycmF5VmFsdWVzQXJlRXF1YWwoZS5fdmFsdWUpICYmIGYuYXJyYXlWYWx1ZXNBcmVFcXVhbChlLl9zcHJlYWQpID8gKGMgPSBNYXRoLmFicyhmLnJhbmRvbUZsb2F0KGUuX3ZhbHVlWzBdLCBlLl9zcHJlYWRbMF0pKSwgZC5zZXRWZWM0Q29tcG9uZW50cyhhLCBjLCBjLCBjLCBjKSkgOiBkLnNldFZlYzRDb21wb25lbnRzKGEsIE1hdGguYWJzKGYucmFuZG9tRmxvYXQoZS5fdmFsdWVbMF0sIGUuX3NwcmVhZFswXSkpLCBNYXRoLmFicyhmLnJhbmRvbUZsb2F0KGUuX3ZhbHVlWzFdLCBlLl9zcHJlYWRbMV0pKSwgTWF0aC5hYnMoZi5yYW5kb21GbG9hdChlLl92YWx1ZVsyXSwgZS5fc3ByZWFkWzJdKSksIE1hdGguYWJzKGYucmFuZG9tRmxvYXQoZS5fdmFsdWVbM10sIGUuX3NwcmVhZFszXSkpKTtcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduQW5nbGVWYWx1ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYixcbiAgICAgICAgYyA9IHRoaXMuYXR0cmlidXRlcy5hbmdsZS50eXBlZEFycmF5LFxuICAgICAgICBkID0gdGhpcy5hbmdsZSxcbiAgICAgICAgZSA9IFNQRS51dGlscztcbiAgICBlLmFycmF5VmFsdWVzQXJlRXF1YWwoZC5fdmFsdWUpICYmIGUuYXJyYXlWYWx1ZXNBcmVFcXVhbChkLl9zcHJlYWQpID8gKGIgPSBlLnJhbmRvbUZsb2F0KGQuX3ZhbHVlWzBdLCBkLl9zcHJlYWRbMF0pLCBjLnNldFZlYzRDb21wb25lbnRzKGEsIGIsIGIsIGIsIGIpKSA6IGMuc2V0VmVjNENvbXBvbmVudHMoYSwgZS5yYW5kb21GbG9hdChkLl92YWx1ZVswXSwgZC5fc3ByZWFkWzBdKSwgZS5yYW5kb21GbG9hdChkLl92YWx1ZVsxXSwgZC5fc3ByZWFkWzFdKSwgZS5yYW5kb21GbG9hdChkLl92YWx1ZVsyXSwgZC5fc3ByZWFkWzJdKSwgZS5yYW5kb21GbG9hdChkLl92YWx1ZVszXSwgZC5fc3ByZWFkWzNdKSlcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduUGFyYW1zVmFsdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLnBhcmFtcy50eXBlZEFycmF5LnNldFZlYzRDb21wb25lbnRzKGEsIHRoaXMuaXNTdGF0aWMgPyAxIDogMCwgMCwgTWF0aC5hYnMoU1BFLnV0aWxzLnJhbmRvbUZsb2F0KHRoaXMubWF4QWdlLl92YWx1ZSwgdGhpcy5tYXhBZ2UuX3NwcmVhZCkpLCBTUEUudXRpbHMucmFuZG9tRmxvYXQodGhpcy53aWdnbGUuX3ZhbHVlLCB0aGlzLndpZ2dsZS5fc3ByZWFkKSlcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduUm90YXRpb25WYWx1ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLmF0dHJpYnV0ZXMucm90YXRpb24udHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyhhLCBTUEUudXRpbHMuZ2V0UGFja2VkUm90YXRpb25BeGlzKHRoaXMucm90YXRpb24uX2F4aXMsIHRoaXMucm90YXRpb24uX2F4aXNTcHJlYWQpLCBTUEUudXRpbHMucmFuZG9tRmxvYXQodGhpcy5yb3RhdGlvbi5fYW5nbGUsIHRoaXMucm90YXRpb24uX2FuZ2xlU3ByZWFkKSwgdGhpcy5yb3RhdGlvbi5fc3RhdGljID8gMCA6IDEpLFxuICAgIHRoaXMuYXR0cmlidXRlcy5yb3RhdGlvbkNlbnRlci50eXBlZEFycmF5LnNldFZlYzMoYSwgdGhpcy5yb3RhdGlvbi5fY2VudGVyKVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25Db2xvclZhbHVlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFNQRS51dGlscy5yYW5kb21Db2xvckFzSGV4KHRoaXMuYXR0cmlidXRlcy5jb2xvciwgYSwgdGhpcy5jb2xvci5fdmFsdWUsIHRoaXMuY29sb3IuX3NwcmVhZClcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fcmVzZXRQYXJ0aWNsZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmb3IgKHZhciBiLCBjLCBkID0gdGhpcy5yZXNldEZsYWdzLCBlID0gdGhpcy51cGRhdGVGbGFncywgZiA9IHRoaXMudXBkYXRlQ291bnRzLCBnID0gdGhpcy5hdHRyaWJ1dGVLZXlzLCBoID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDE7IGggPj0gMDsgLS1oKVxuICAgICAgICBiID0gZ1toXSwgYyA9IGVbYl0sIChkW2JdID09PSAhMCB8fCBjID09PSAhMCkgJiYgKHRoaXMuX2Fzc2lnblZhbHVlKGIsIGEpLCB0aGlzLl91cGRhdGVBdHRyaWJ1dGVVcGRhdGVSYW5nZShiLCBhKSwgYyA9PT0gITAgJiYgZltiXSA9PT0gdGhpcy5wYXJ0aWNsZUNvdW50ID8gKGVbYl0gPSAhMSwgZltiXSA9IDApIDogMSA9PSBjICYmICsrZltiXSlcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fdXBkYXRlQXR0cmlidXRlVXBkYXRlUmFuZ2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGMgPSB0aGlzLmJ1ZmZlclVwZGF0ZVJhbmdlc1thXTtcbiAgICBjLm1pbiA9IE1hdGgubWluKGIsIGMubWluKSwgYy5tYXggPSBNYXRoLm1heChiLCBjLm1heClcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fcmVzZXRCdWZmZXJSYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYSxcbiAgICAgICAgYiA9IHRoaXMuYnVmZmVyVXBkYXRlUmFuZ2VzLFxuICAgICAgICBjID0gdGhpcy5idWZmZXJVcGRhdGVLZXlzLFxuICAgICAgICBkID0gdGhpcy5idWZmZXJVcGRhdGVDb3VudCAtIDE7XG4gICAgZm9yIChkOyBkID49IDA7IC0tZClcbiAgICAgICAgYSA9IGNbZF0sIGJbYV0ubWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBiW2FdLm1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9vblJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMucGFydGljbGVzUGVyU2Vjb25kID0gMCwgdGhpcy5hdHRyaWJ1dGVPZmZzZXQgPSAwLCB0aGlzLmFjdGl2YXRpb25JbmRleCA9IDAsIHRoaXMuYWN0aXZlUGFydGljbGVDb3VudCA9IDAsIHRoaXMuZ3JvdXAgPSBudWxsLCB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsLCB0aGlzLnBhcmFtc0FycmF5ID0gbnVsbCwgdGhpcy5hZ2UgPSAwXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2RlY3JlbWVudFBhcnRpY2xlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAtLXRoaXMuYWN0aXZlUGFydGljbGVDb3VudFxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9pbmNyZW1lbnRQYXJ0aWNsZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgKyt0aGlzLmFjdGl2ZVBhcnRpY2xlQ291bnRcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fY2hlY2tQYXJ0aWNsZUFnZXMgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZm9yICh2YXIgZSwgZiwgZywgaCwgaSA9IGIgLSAxOyBpID49IGE7IC0taSlcbiAgICAgICAgZSA9IDQgKiBpLCBoID0gY1tlXSwgMCAhPT0gaCAmJiAoZyA9IGNbZSArIDFdLCBmID0gY1tlICsgMl0sIDEgPT09IHRoaXMuZGlyZWN0aW9uID8gKGcgKz0gZCwgZyA+PSBmICYmIChnID0gMCwgaCA9IDAsIHRoaXMuX2RlY3JlbWVudFBhcnRpY2xlQ291bnQoKSkpIDogKGcgLT0gZCwgMCA+PSBnICYmIChnID0gZiwgaCA9IDAsIHRoaXMuX2RlY3JlbWVudFBhcnRpY2xlQ291bnQoKSkpLCBjW2VdID0gaCwgY1tlICsgMV0gPSBnLCB0aGlzLl91cGRhdGVBdHRyaWJ1dGVVcGRhdGVSYW5nZShcInBhcmFtc1wiLCBpKSlcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYWN0aXZhdGVQYXJ0aWNsZXMgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZm9yICh2YXIgZSwgZiwgZyA9IHRoaXMuZGlyZWN0aW9uLCBoID0gYTsgYiA+IGg7ICsraClcbiAgICAgICAgZSA9IDQgKiBoLCAoMCA9PSBjW2VdIHx8IDEgPT09IHRoaXMucGFydGljbGVDb3VudCkgJiYgKHRoaXMuX2luY3JlbWVudFBhcnRpY2xlQ291bnQoKSwgY1tlXSA9IDEsIHRoaXMuX3Jlc2V0UGFydGljbGUoaCksIGYgPSBkICogKGggLSBhKSwgY1tlICsgMV0gPSAtMSA9PT0gZyA/IGNbZSArIDJdIC0gZiA6IGYsIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZVVwZGF0ZVJhbmdlKFwicGFyYW1zXCIsIGgpKTtcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICghdGhpcy5pc1N0YXRpYykge1xuICAgICAgICBudWxsID09PSB0aGlzLnBhcmFtc0FycmF5ICYmICh0aGlzLnBhcmFtc0FycmF5ID0gdGhpcy5hdHRyaWJ1dGVzLnBhcmFtcy50eXBlZEFycmF5LmFycmF5KTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmF0dHJpYnV0ZU9mZnNldCxcbiAgICAgICAgICAgIGMgPSBiICsgdGhpcy5wYXJ0aWNsZUNvdW50LFxuICAgICAgICAgICAgZCA9IHRoaXMucGFyYW1zQXJyYXksXG4gICAgICAgICAgICBlID0gdGhpcy5wYXJ0aWNsZXNQZXJTZWNvbmQgKiB0aGlzLmFjdGl2ZU11bHRpcGxpZXIgKiBhLFxuICAgICAgICAgICAgZiA9IHRoaXMuYWN0aXZhdGlvbkluZGV4O1xuICAgICAgICBpZiAodGhpcy5fcmVzZXRCdWZmZXJSYW5nZXMoKSwgdGhpcy5fY2hlY2tQYXJ0aWNsZUFnZXMoYiwgYywgZCwgYSksIHRoaXMuYWxpdmUgPT09ICExKVxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgKHRoaXMuYWdlID0gMCk7XG4gICAgICAgIGlmIChudWxsICE9PSB0aGlzLmR1cmF0aW9uICYmIHRoaXMuYWdlID4gdGhpcy5kdXJhdGlvbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaXZlID0gITEsIHZvaWQgKHRoaXMuYWdlID0gMCk7XG4gICAgICAgIHZhciBnID0gMSA9PT0gdGhpcy5wYXJ0aWNsZUNvdW50ID8gZiA6IDAgfCBmLFxuICAgICAgICAgICAgaCA9IE1hdGgubWluKGcgKyBlLCB0aGlzLmFjdGl2YXRpb25FbmQpLFxuICAgICAgICAgICAgaSA9IGggLSB0aGlzLmFjdGl2YXRpb25JbmRleCB8IDAsXG4gICAgICAgICAgICBqID0gaSA+IDAgPyBhIC8gaSA6IDA7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlUGFydGljbGVzKGcsIGgsIGQsIGopLCB0aGlzLmFjdGl2YXRpb25JbmRleCArPSBlLCB0aGlzLmFjdGl2YXRpb25JbmRleCA+IGMgJiYgKHRoaXMuYWN0aXZhdGlvbkluZGV4ID0gYiksIHRoaXMuYWdlICs9IGFcbiAgICB9XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHRoaXMuYWdlID0gMCwgdGhpcy5hbGl2ZSA9ICExLCBhID09PSAhMCkge1xuICAgICAgICBmb3IgKHZhciBiLCBjID0gdGhpcy5hdHRyaWJ1dGVPZmZzZXQsIGQgPSBjICsgdGhpcy5wYXJ0aWNsZUNvdW50LCBlID0gdGhpcy5wYXJhbXNBcnJheSwgZiA9IHRoaXMuYXR0cmlidXRlcy5wYXJhbXMuYnVmZmVyQXR0cmlidXRlLCBnID0gZCAtIDE7IGcgPj0gYzsgLS1nKVxuICAgICAgICAgICAgYiA9IDQgKiBnLCBlW2JdID0gMCwgZVtiICsgMV0gPSAwO1xuICAgICAgICBmLnVwZGF0ZVJhbmdlLm9mZnNldCA9IDAsIGYudXBkYXRlUmFuZ2UuY291bnQgPSAtMSxcbiAgICAgICAgZi5uZWVkc1VwZGF0ZSA9ICEwXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuYWxpdmUgPSAhMCwgdGhpc1xufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5hbGl2ZSA9ICExLCB0aGlzXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIG51bGwgIT09IHRoaXMuZ3JvdXAgPyB0aGlzLmdyb3VwLnJlbW92ZUVtaXR0ZXIodGhpcykgOiBjb25zb2xlLmVycm9yKFwiRW1pdHRlciBkb2VzIG5vdCBiZWxvbmcgdG8gYSBncm91cCwgY2Fubm90IHJlbW92ZS5cIiksIHRoaXNcbn07XG4iLCIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUlBQTtBREFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBRGp5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUQzMm9DQSxJQUFBLGdEQUFBO0VBQUE7OztBQUFNOzs7RUFFUSxtQkFBQyxPQUFEOztNQUFDLFVBQVE7O0lBQ3JCLElBQUMsQ0FBQSxVQUFELEdBQWM7SUFDZCxJQUFDLENBQUEsZ0JBQUQsR0FBb0I7O01BQ3BCLE9BQU8sQ0FBQyxrQkFBc0IsT0FBTyxDQUFDLEtBQVgsR0FBc0Isd0JBQXRCLEdBQW9EOzs7TUFDL0UsT0FBTyxDQUFDLFFBQVM7OztNQUNqQixPQUFPLENBQUMsYUFBYzs7O01BQ3RCLE9BQU8sQ0FBQyxhQUFjOzs7TUFDdEIsT0FBTyxDQUFDLFdBQVk7OztNQUNwQixPQUFPLENBQUMsT0FBUTs7SUFDaEIsMkNBQU0sT0FBTjtJQUNBLElBQUMsQ0FBQSxLQUFLLENBQUMsVUFBUCxHQUFvQjtJQUNwQixJQUFDLENBQUEsS0FBSyxDQUFDLE9BQVAsR0FBaUI7RUFYTDs7c0JBYWIsUUFBQSxHQUFVLFNBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsUUFBbEI7O01BQWtCLFdBQVc7O0lBQ3RDLElBQUMsQ0FBQSxLQUFNLENBQUEsUUFBQSxDQUFQLEdBQXNCLFFBQUgsR0FBaUIsS0FBQSxHQUFNLElBQXZCLEdBQWlDO0lBQ3BELElBQUMsQ0FBQSxJQUFELENBQU0sU0FBQSxHQUFVLFFBQWhCLEVBQTRCLEtBQTVCO0lBQ0EsSUFBRyxJQUFDLENBQUEsVUFBSjthQUFvQixJQUFDLENBQUEsUUFBRCxDQUFBLEVBQXBCOztFQUhTOztzQkFLVixRQUFBLEdBQVUsU0FBQTtBQUNULFFBQUE7SUFBQSxtQkFBQSxHQUNDO01BQUEsVUFBQSxFQUFZLElBQUMsQ0FBQSxLQUFNLENBQUEsYUFBQSxDQUFuQjtNQUNBLFFBQUEsRUFBVSxJQUFDLENBQUEsS0FBTSxDQUFBLFdBQUEsQ0FEakI7TUFFQSxVQUFBLEVBQVksSUFBQyxDQUFBLEtBQU0sQ0FBQSxhQUFBLENBRm5CO01BR0EsVUFBQSxFQUFZLElBQUMsQ0FBQSxLQUFNLENBQUEsYUFBQSxDQUhuQjtNQUlBLFlBQUEsRUFBYyxJQUFDLENBQUEsS0FBTSxDQUFBLGVBQUEsQ0FKckI7TUFLQSxhQUFBLEVBQWUsSUFBQyxDQUFBLEtBQU0sQ0FBQSxnQkFBQSxDQUx0QjtNQU1BLFdBQUEsRUFBYSxJQUFDLENBQUEsS0FBTSxDQUFBLGNBQUEsQ0FOcEI7TUFPQSxhQUFBLEVBQWUsSUFBQyxDQUFBLEtBQU0sQ0FBQSxnQkFBQSxDQVB0QjtNQVFBLFdBQUEsRUFBYSxJQUFDLENBQUEsS0FBTSxDQUFBLGNBQUEsQ0FScEI7TUFTQSxhQUFBLEVBQWUsSUFBQyxDQUFBLEtBQU0sQ0FBQSxnQkFBQSxDQVR0QjtNQVVBLFVBQUEsRUFBWSxJQUFDLENBQUEsS0FBTSxDQUFBLGFBQUEsQ0FWbkI7TUFXQSxTQUFBLEVBQVcsSUFBQyxDQUFBLEtBQU0sQ0FBQSxZQUFBLENBWGxCO01BWUEsV0FBQSxFQUFhLElBQUMsQ0FBQSxLQUFNLENBQUEsY0FBQSxDQVpwQjs7SUFhRCxXQUFBLEdBQWM7SUFDZCxJQUFHLElBQUMsQ0FBQSxnQkFBSjtNQUEwQixXQUFXLENBQUMsS0FBWixHQUFvQixJQUFDLENBQUEsTUFBL0M7O0lBQ0EsSUFBQSxHQUFPLEtBQUssQ0FBQyxRQUFOLENBQWUsSUFBQyxDQUFBLElBQWhCLEVBQXNCLG1CQUF0QixFQUEyQyxXQUEzQztJQUNQLElBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQyxTQUFQLEtBQW9CLE9BQXZCO01BQ0MsSUFBQyxDQUFBLEtBQUQsR0FBUyxJQUFJLENBQUM7TUFDZCxJQUFDLENBQUEsQ0FBRCxHQUFLLElBQUMsQ0FBQSxDQUFELEdBQUcsSUFBQyxDQUFBLE1BRlY7S0FBQSxNQUFBO01BSUMsSUFBQyxDQUFBLEtBQUQsR0FBUyxJQUFJLENBQUMsTUFKZjs7V0FLQSxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUksQ0FBQztFQXZCTjs7RUF5QlYsU0FBQyxDQUFBLE1BQUQsQ0FBUSxVQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQTtJQUFKLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO01BQ0osSUFBQyxDQUFBLFVBQUQsR0FBYztNQUNkLElBQUcsSUFBQyxDQUFBLFVBQUo7ZUFBb0IsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQUFwQjs7SUFGSSxDQURMO0dBREQ7O0VBS0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxnQkFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUMsS0FBRDtNQUNKLElBQUMsQ0FBQSxVQUFELEdBQWM7TUFDZCxJQUFDLENBQUEsZ0JBQUQsR0FBb0I7TUFDcEIsSUFBRyxJQUFDLENBQUEsVUFBSjtlQUFvQixJQUFDLENBQUEsUUFBRCxDQUFBLEVBQXBCOztJQUhJLENBQUw7R0FERDs7RUFLQSxTQUFDLENBQUEsTUFBRCxDQUFRLGlCQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQyxPQUFEO01BQ0osSUFBQyxDQUFBLFFBQVEsQ0FBQyxlQUFWLEdBQTRCO01BQzVCLElBQUMsQ0FBQSxZQUFELEdBQWdCLENBQUM7YUFDakIsSUFBQyxDQUFBLEVBQUQsQ0FBSSxPQUFKLEVBQWEsU0FBQTtRQUFHLElBQWUsSUFBQyxDQUFBLFVBQWhCO2lCQUFBLElBQUMsQ0FBQSxRQUFELENBQUEsRUFBQTs7TUFBSCxDQUFiO0lBSEksQ0FBTDtHQUREOztFQUtBLFNBQUMsQ0FBQSxNQUFELENBQVEsTUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsUUFBUSxDQUFDO0lBQWIsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7TUFDSixJQUFDLENBQUEsUUFBUSxDQUFDLFdBQVYsR0FBd0I7TUFDeEIsSUFBQyxDQUFBLElBQUQsQ0FBTSxhQUFOLEVBQXFCLEtBQXJCO01BQ0EsSUFBRyxJQUFDLENBQUEsVUFBSjtlQUFvQixJQUFDLENBQUEsUUFBRCxDQUFBLEVBQXBCOztJQUhJLENBREw7R0FERDs7RUFNQSxTQUFDLENBQUEsTUFBRCxDQUFRLFlBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQztJQUFWLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxZQUFWLEVBQXdCLEtBQXhCO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsVUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFoQixDQUF3QixJQUF4QixFQUE2QixFQUE3QjtJQUFILENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxVQUFWLEVBQXNCLEtBQXRCLEVBQTZCLElBQTdCO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsWUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDO0lBQVYsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLFlBQVYsRUFBd0IsS0FBeEI7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxZQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFBVixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsWUFBVixFQUF3QixLQUF4QjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLFdBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQztJQUFWLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxXQUFWLEVBQXVCLEtBQXZCO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsYUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDO0lBQVYsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLGFBQVYsRUFBeUIsS0FBekI7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxTQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQyxLQUFEO01BQ0osSUFBQyxDQUFBLFFBQUQsQ0FBVSxZQUFWLEVBQXdCLEtBQXhCLEVBQStCLElBQS9CO01BQ0EsSUFBQyxDQUFBLFFBQUQsQ0FBVSxjQUFWLEVBQTBCLEtBQTFCLEVBQWlDLElBQWpDO01BQ0EsSUFBQyxDQUFBLFFBQUQsQ0FBVSxlQUFWLEVBQTJCLEtBQTNCLEVBQWtDLElBQWxDO2FBQ0EsSUFBQyxDQUFBLFFBQUQsQ0FBVSxhQUFWLEVBQXlCLEtBQXpCLEVBQWdDLElBQWhDO0lBSkksQ0FBTDtHQUREOztFQU1BLFNBQUMsQ0FBQSxNQUFELENBQVEsWUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFsQixDQUEwQixJQUExQixFQUErQixFQUEvQjtJQUFILENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxZQUFWLEVBQXdCLEtBQXhCLEVBQStCLElBQS9CO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsY0FBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDLFlBQVksQ0FBQyxPQUFwQixDQUE0QixJQUE1QixFQUFpQyxFQUFqQztJQUFILENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxjQUFWLEVBQTBCLEtBQTFCLEVBQWlDLElBQWpDO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsZUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDLGFBQWEsQ0FBQyxPQUFyQixDQUE2QixJQUE3QixFQUFrQyxFQUFsQztJQUFILENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxlQUFWLEVBQTJCLEtBQTNCLEVBQWtDLElBQWxDO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsYUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFuQixDQUEyQixJQUEzQixFQUFnQyxFQUFoQztJQUFILENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxhQUFWLEVBQXlCLEtBQXpCLEVBQWdDLElBQWhDO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsV0FBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsV0FBVixFQUF1QixLQUF2QjtJQUFYLENBQUw7R0FERDs7RUFFQSxTQUFDLENBQUEsTUFBRCxDQUFRLGVBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQztJQUFWLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxlQUFWLEVBQTJCLEtBQTNCO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsZUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDLGFBQWEsQ0FBQyxPQUFyQixDQUE2QixJQUE3QixFQUFrQyxFQUFsQztJQUFILENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxlQUFWLEVBQTJCLEtBQTNCLEVBQWtDLElBQWxDO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsUUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsSUFBSSxDQUFDO0lBQVQsQ0FBTDtHQUREOzs7O0dBOUd1Qjs7QUFpSHhCLGtCQUFBLEdBQXFCLFNBQUMsS0FBRCxFQUFRLEtBQVI7QUFHcEIsTUFBQTtFQUFBLENBQUEsR0FBUSxJQUFBLFNBQUEsQ0FDUDtJQUFBLElBQUEsRUFBTSxLQUFLLENBQUMsSUFBWjtJQUNBLEtBQUEsRUFBTyxLQUFLLENBQUMsS0FEYjtJQUVBLE1BQUEsRUFBUSxLQUFLLENBQUMsTUFGZDtJQUdBLElBQUEsRUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUgzQjtHQURPO0VBT1IsUUFBQSxHQUFXO0VBR1gsR0FBQSxHQUFNLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO0VBRzNCLEdBQUcsQ0FBQyxPQUFKLENBQVksU0FBQyxJQUFEO0FBR1gsUUFBQTtJQUFBLElBQVUsQ0FBQyxDQUFDLFFBQUYsQ0FBVyxJQUFYLEVBQWlCLElBQWpCLENBQVY7QUFBQSxhQUFBOztJQUdBLEdBQUEsR0FBTSxJQUFJLENBQUMsS0FBTCxDQUFXLElBQVg7SUFHTixJQUFBLEdBQU8sQ0FBQyxDQUFDLFNBQUYsQ0FBWSxHQUFJLENBQUEsQ0FBQSxDQUFoQjtJQUNQLEtBQUEsR0FBUSxHQUFJLENBQUEsQ0FBQSxDQUFFLENBQUMsT0FBUCxDQUFlLEdBQWYsRUFBbUIsRUFBbkI7SUFHUixJQUFHLENBQUMsVUFBRCxFQUFZLGVBQVosRUFBNEIsWUFBNUIsQ0FBeUMsQ0FBQyxPQUExQyxDQUFrRCxJQUFsRCxDQUFBLEdBQTBELENBQUMsQ0FBOUQ7TUFDQyxLQUFBLEdBQVEsUUFBQSxDQUFTLEtBQVQsRUFEVDs7V0FJQSxRQUFTLENBQUEsSUFBQSxDQUFULEdBQWlCO0VBakJOLENBQVo7RUFvQkEsSUFBRyxRQUFRLENBQUMsY0FBVCxDQUF3QixZQUF4QixDQUFIO0lBQ0MsUUFBUyxDQUFBLFlBQUEsQ0FBVCxHQUEwQixRQUFRLENBQUMsVUFBVCxHQUFzQixRQUFRLENBQUMsU0FEMUQ7R0FBQSxNQUFBO0lBR0MsUUFBUyxDQUFBLFlBQUEsQ0FBVCxHQUF5QixJQUgxQjs7QUFTQSxPQUFBLGVBQUE7O0lBQ0MsQ0FBRSxDQUFBLEdBQUEsQ0FBRixHQUFTO0FBRFY7RUFJQSxDQUFDLENBQUMsQ0FBRixJQUFPLENBQUMsQ0FBQyxDQUFDLFFBQUYsR0FBYSxDQUFDLENBQUMsVUFBaEIsQ0FBQSxHQUE4QixDQUFDLENBQUEsR0FBSSxDQUFDLENBQUMsVUFBUDtFQUNyQyxDQUFDLENBQUMsQ0FBRixJQUFPLENBQUMsQ0FBQyxRQUFGLEdBQWE7RUFDcEIsQ0FBQyxDQUFDLEtBQUYsSUFBVyxDQUFDLENBQUMsUUFBRixHQUFhO0VBSXhCLElBQUcsS0FBSDtJQUFjLEtBQUssQ0FBQyxPQUFOLEdBQWdCLEdBQTlCO0dBQUEsTUFBQTtJQUFzQyxLQUFLLENBQUMsT0FBTixDQUFBLEVBQXRDOztBQUVBLFNBQU87QUF6RGE7O0FBMkRyQixLQUFLLENBQUEsU0FBRSxDQUFBLGtCQUFQLEdBQTRCLFNBQUMsS0FBRDtTQUFXLGtCQUFBLENBQW1CLElBQW5CLEVBQXNCLEtBQXRCO0FBQVg7O0FBRTVCLGlCQUFBLEdBQW9CLFNBQUMsR0FBRCxFQUFNLEtBQU47QUFDbkIsTUFBQTtBQUFBO09BQUEsV0FBQTs7SUFDQyxJQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBWixLQUFvQixNQUF2QjttQkFDQyxHQUFJLENBQUEsSUFBQSxDQUFKLEdBQVksa0JBQUEsQ0FBbUIsS0FBbkIsRUFBMEIsS0FBMUIsR0FEYjtLQUFBLE1BQUE7MkJBQUE7O0FBREQ7O0FBRG1COztBQU9wQixLQUFLLENBQUEsU0FBRSxDQUFBLGdCQUFQLEdBQTBCLFNBQUMsVUFBRDtBQUN0QixNQUFBO0VBQUEsQ0FBQSxHQUFJLElBQUk7RUFDUixDQUFDLENBQUMsS0FBRixHQUFVLElBQUMsQ0FBQTtFQUNYLENBQUMsQ0FBQyxVQUFGLEdBQWUsSUFBQyxDQUFBO0VBQ2hCLENBQUMsQ0FBQyxNQUFGLENBQVMsQ0FBVCxFQUFXLFVBQVg7RUFDQSxJQUFDLENBQUEsT0FBRCxDQUFBO1NBQ0E7QUFOc0I7O0FBUTFCLE9BQU8sQ0FBQyxTQUFSLEdBQW9COztBQUNwQixPQUFPLENBQUMsaUJBQVIsR0FBNEI7Ozs7QUQzTDVCLE9BQU8sQ0FBQyxLQUFSLEdBQWdCOztBQUVoQixPQUFPLENBQUMsVUFBUixHQUFxQixTQUFBO1NBQ3BCLEtBQUEsQ0FBTSx1QkFBTjtBQURvQjs7QUFHckIsT0FBTyxDQUFDLE9BQVIsR0FBa0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAifQ==
