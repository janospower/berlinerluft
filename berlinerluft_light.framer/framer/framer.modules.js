require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"SPE-min":[function(require,module,exports){
/* shader-particle-engine 1.0.0
 * 
 * (c) 2015 Luke Moody (http://www.github.com/squarefeet)
 *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).
 *
 * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)
 */
var SPE = {
    distributions: {
        BOX: 1,
        SPHERE: 2,
        DISC: 3
    },
    valueOverLifetimeLength: 4
};
"function" == typeof define && define.amd ? define("spe", SPE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = SPE), SPE.TypedArrayHelper = function(a, b, c, d) {
    "use strict";
    this.componentSize = c || 1, this.size = b || 1, this.TypedArrayConstructor = a || Float32Array, this.array = new a(b * this.componentSize), this.indexOffset = d || 0
}, SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper, SPE.TypedArrayHelper.prototype.setSize = function(a, b) {
    "use strict";
    var c = this.array.length;
    return b || (a *= this.componentSize), c > a ? this.shrink(a) : a > c ? this.grow(a) : void console.info("TypedArray is already of size:", a + ".", "Will not resize.")
}, SPE.TypedArrayHelper.prototype.shrink = function(a) {
    "use strict";
    return this.array = this.array.subarray(0, a), this.size = a, this
}, SPE.TypedArrayHelper.prototype.grow = function(a) {
    "use strict";
    var b = this.array,
        c = new this.TypedArrayConstructor(a);
    return c.set(b), this.array = c, this.size = a, this
}, SPE.TypedArrayHelper.prototype.splice = function(a, b) {
    "use strict";
    a *= this.componentSize, b *= this.componentSize;
    for (var c = [], d = this.array, e = d.length, f = 0; e > f; ++f)
        (a > f || f >= b) && c.push(d[f]);
    return this.setFromArray(0, c), this
}, SPE.TypedArrayHelper.prototype.setFromArray = function(a, b) {
    "use strict";
    var c = b.length,
        d = a + c;
    return d > this.array.length ? this.grow(d) : d < this.array.length && this.shrink(d), this.array.set(b, this.indexOffset + a), this
}, SPE.TypedArrayHelper.prototype.setVec2 = function(a, b) {
    "use strict";
    return this.setVec2Components(a, b.x, b.y)
}, SPE.TypedArrayHelper.prototype.setVec2Components = function(a, b, c) {
    "use strict";
    var d = this.array,
        e = this.indexOffset + a * this.componentSize;
    return d[e] = b, d[e + 1] = c, this
}, SPE.TypedArrayHelper.prototype.setVec3 = function(a, b) {
    "use strict";
    return this.setVec3Components(a, b.x, b.y, b.z)
}, SPE.TypedArrayHelper.prototype.setVec3Components = function(a, b, c, d) {
    "use strict";
    var e = this.array,
        f = this.indexOffset + a * this.componentSize;
    return e[f] = b, e[f + 1] = c, e[f + 2] = d, this
}, SPE.TypedArrayHelper.prototype.setVec4 = function(a, b) {
    "use strict";
    return this.setVec4Components(a, b.x, b.y, b.z, b.w)
}, SPE.TypedArrayHelper.prototype.setVec4Components = function(a, b, c, d, e) {
    "use strict";
    var f = this.array,
        g = this.indexOffset + a * this.componentSize;
    return f[g] = b, f[g + 1] = c, f[g + 2] = d, f[g + 3] = e, this
}, SPE.TypedArrayHelper.prototype.setMat3 = function(a, b) {
    "use strict";
    return this.setFromArray(this.indexOffset + a * this.componentSize, b.elements)
}, SPE.TypedArrayHelper.prototype.setMat4 = function(a, b) {
    "use strict";
    return this.setFromArray(this.indexOffset + a * this.componentSize, b.elements)
}, SPE.TypedArrayHelper.prototype.setColor = function(a, b) {
    "use strict";
    return this.setVec3Components(a, b.r, b.g, b.b)
}, SPE.TypedArrayHelper.prototype.setNumber = function(a, b) {
    "use strict";
    return this.array[this.indexOffset + a * this.componentSize] = b, this
}, SPE.TypedArrayHelper.prototype.getValueAtIndex = function(a) {
    "use strict";
    return this.array[this.indexOffset + a]
}, SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(a) {
    "use strict";
    return this.array.subarray(this.indexOffset + a * this.componentSize);
}, SPE.ShaderAttribute = function(a, b, c) {
    "use strict";
    var d = SPE.ShaderAttribute.typeSizeMap;
    this.type = "string" == typeof a && d.hasOwnProperty(a) ? a : "f", this.componentSize = d[this.type], this.arrayType = c || Float32Array, this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!b, this.updateMin = 0, this.updateMax = 0
}, SPE.ShaderAttribute.constructor = SPE.ShaderAttribute, SPE.ShaderAttribute.typeSizeMap = {
    f: 1,
    v2: 2,
    v3: 3,
    v4: 4,
    c: 3,
    m3: 9,
    m4: 16
}, SPE.ShaderAttribute.prototype.setUpdateRange = function(a, b) {
    "use strict";
    this.updateMin = Math.min(a * this.componentSize, this.updateMin * this.componentSize), this.updateMax = Math.max(b * this.componentSize, this.updateMax * this.componentSize)
}, SPE.ShaderAttribute.prototype.flagUpdate = function() {
    "use strict";
    var a = this.bufferAttribute,
        b = a.updateRange;
    b.offset = this.updateMin, b.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), a.needsUpdate = !0
}, SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
    "use strict";
    this.updateMin = 0, this.updateMax = 0;
}, SPE.ShaderAttribute.prototype.resetDynamic = function() {
    "use strict";
    this.bufferAttribute.dynamic = this.dynamicBuffer
}, SPE.ShaderAttribute.prototype.splice = function(a, b) {
    "use strict";
    this.typedArray.splice(a, b), this.forceUpdateAll()
}, SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
    "use strict";
    this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.dynamic = !1, this.bufferAttribute.needsUpdate = !0
}, SPE.ShaderAttribute.prototype._ensureTypedArray = function(a) {
    "use strict";
    (null === this.typedArray || this.typedArray.size !== a * this.componentSize) && (null !== this.typedArray && this.typedArray.size !== a ? this.typedArray.setSize(a) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, a, this.componentSize)))
}, SPE.ShaderAttribute.prototype._createBufferAttribute = function(a) {
    "use strict";
    return this._ensureTypedArray(a), null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array,
    void (this.bufferAttribute.needsUpdate = !0)) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), void (this.bufferAttribute.dynamic = this.dynamicBuffer))
}, SPE.ShaderAttribute.prototype.getLength = function() {
    "use strict";
    return null === this.typedArray ? 0 : this.typedArray.array.length
}, SPE.shaderChunks = {
    defines: ["#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0"].join("\n"),
    uniforms: ["uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D texture;", "uniform vec4 textureAnimation;", "uniform float scale;"].join("\n"),
    attributes: ["attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;"].join("\n"),
    varyings: ["varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif"].join("\n"),
    branchAvoidanceFunctions: ["float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}"].join("\n"),
    unpackColor: ["vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}"].join("\n"),
    floatOverLifetime: ["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}"].join("\n"),
    colorOverLifetime: ["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}"].join("\n"),
    paramFetchingFunctions: ["float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}"].join("\n"),
    forceFetchingFunctions: ["vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}"].join("\n"),
    rotationFunctions: ["#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      vec3 axis = unpackColor( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = pos - rotationCenter;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return vec3( rotationMatrix * vec4( translated, 0.0 ) ) - center;", "   }", "#endif"].join("\n"),
    rotateTexture: ["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( texture, vUv );"].join("\n")
}, SPE.shaders = {
    vertex: [SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPos.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPos;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragment: [SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", THREE.ShaderChunk.fog_fragment, "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", "}"].join("\n")
}, SPE.utils = {
    types: {
        BOOLEAN: "boolean",
        STRING: "string",
        NUMBER: "number",
        OBJECT: "object"
    },
    ensureTypedArg: function(a, b, c) {
        "use strict";
        return typeof a === b ? a : c
    },
    ensureArrayTypedArg: function(a, b, c) {
        "use strict";
        if (Array.isArray(a)) {
            for (var d = a.length - 1; d >= 0; --d)
                if (typeof a[d] !== b)
                    return c;
            return a
        }
        return this.ensureTypedArg(a, b, c)
    },
    ensureInstanceOf: function(a, b, c) {
        "use strict";
        return void 0 !== b && a instanceof b ? a : c;
    },
    ensureArrayInstanceOf: function(a, b, c) {
        "use strict";
        if (Array.isArray(a)) {
            for (var d = a.length - 1; d >= 0; --d)
                if (void 0 !== b && a[d] instanceof b == !1)
                    return c;
            return a
        }
        return this.ensureInstanceOf(a, b, c)
    },
    ensureValueOverLifetimeCompliance: function(a, b, c) {
        "use strict";
        b = b || 3, c = c || 3, Array.isArray(a._value) === !1 && (a._value = [a._value]), Array.isArray(a._spread) === !1 && (a._spread = [a._spread]);
        var d = this.clamp(a._value.length, b, c),
            e = this.clamp(a._spread.length, b, c),
            f = Math.max(d, e);
        a._value.length !== f && (a._value = this.interpolateArray(a._value, f)), a._spread.length !== f && (a._spread = this.interpolateArray(a._spread, f))
    },
    interpolateArray: function(a, b) {
        "use strict";
        for (var c = a.length, d = ["function" == typeof a[0].clone ? a[0].clone() : a[0]], e = (c - 1) / (b - 1), f = 1; b - 1 > f; ++f) {
            var g = f * e,
                h = Math.floor(g),
                i = Math.ceil(g),
                j = g - h;
            d[f] = this.lerpTypeAgnostic(a[h], a[i], j)
        }
        return d.push("function" == typeof a[c - 1].clone ? a[c - 1].clone() : a[c - 1]), d
    },
    clamp: function(a, b, c) {
        "use strict";
        return Math.max(b, Math.min(a, c))
    },
    zeroToEpsilon: function(a, b) {
        "use strict";
        var c = 1e-5,
            d = a;
        return d = b ? Math.random() * c * 10 : c, 0 > a && a > -c && (d = -d), d
    },
    lerpTypeAgnostic: function(a, b, c) {
        "use strict";
        var d,
            e = this.types;
        return typeof a === e.NUMBER && typeof b === e.NUMBER ? a + (b - a) * c : a instanceof THREE.Vector2 && b instanceof THREE.Vector2 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d) : a instanceof THREE.Vector3 && b instanceof THREE.Vector3 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d.z = this.lerp(a.z, b.z, c), d) : a instanceof THREE.Vector4 && b instanceof THREE.Vector4 ? (d = a.clone(), d.x = this.lerp(a.x, b.x, c), d.y = this.lerp(a.y, b.y, c), d.z = this.lerp(a.z, b.z, c), d.w = this.lerp(a.w, b.w, c), d) : a instanceof THREE.Color && b instanceof THREE.Color ? (d = a.clone(), d.r = this.lerp(a.r, b.r, c), d.g = this.lerp(a.g, b.g, c), d.b = this.lerp(a.b, b.b, c), d) : void console.warn("Invalid argument types, or argument types do not match:", a, b)
    },
    lerp: function(a, b, c) {
        "use strict";
        return a + (b - a) * c
    },
    roundToNearestMultiple: function(a, b) {
        "use strict";
        var c = 0;
        return 0 === b ? a : (c = Math.abs(a) % b,
        0 === c ? a : 0 > a ? -(Math.abs(a) - c) : a + b - c)
    },
    arrayValuesAreEqual: function(a) {
        "use strict";
        for (var b = 0; b < a.length - 1; ++b)
            if (a[b] !== a[b + 1])
                return !1;
        return !0
    },
    randomFloat: function(a, b) {
        "use strict";
        return a + b * (Math.random() - .5)
    },
    randomVector3: function(a, b, c, d, e) {
        "use strict";
        var f = c.x + (Math.random() * d.x - .5 * d.x),
            g = c.y + (Math.random() * d.y - .5 * d.y),
            h = c.z + (Math.random() * d.z - .5 * d.z);
        e && (f = .5 * -e.x + this.roundToNearestMultiple(f, e.x), g = .5 * -e.y + this.roundToNearestMultiple(g, e.y), h = .5 * -e.z + this.roundToNearestMultiple(h, e.z)), a.typedArray.setVec3Components(b, f, g, h)
    },
    randomColor: function(a, b, c, d) {
        "use strict";
        var e = c.r + Math.random() * d.x,
            f = c.g + Math.random() * d.y,
            g = c.b + Math.random() * d.z;
        e = this.clamp(e, 0, 1), f = this.clamp(f, 0, 1), g = this.clamp(g, 0, 1), a.typedArray.setVec3Components(b, e, f, g)
    },
    randomColorAsHex: function() {
        "use strict";
        var a = new THREE.Color;
        return function(b, c, d, e) {
            for (var f = d.length, g = [], h = 0; f > h; ++h) {
                var i = e[h];
                a.copy(d[h]), a.r += Math.random() * i.x - .5 * i.x, a.g += Math.random() * i.y - .5 * i.y, a.b += Math.random() * i.z - .5 * i.z,
                a.r = this.clamp(a.r, 0, 1), a.g = this.clamp(a.g, 0, 1), a.b = this.clamp(a.b, 0, 1), g.push(a.getHex())
            }
            b.typedArray.setVec4Components(c, g[0], g[1], g[2], g[3])
        }
    }(),
    randomVector3OnSphere: function(a, b, c, d, e, f, g, h) {
        "use strict";
        var i = 2 * Math.random() - 1,
            j = 6.2832 * Math.random(),
            k = Math.sqrt(1 - i * i),
            l = this.randomFloat(d, e),
            m = 0,
            n = 0,
            o = 0;
        g && (l = Math.round(l / g) * g), m = k * Math.cos(j) * l, n = k * Math.sin(j) * l, o = i * l, m *= f.x, n *= f.y, o *= f.z, m += c.x, n += c.y, o += c.z, a.typedArray.setVec3Components(b, m, n, o)
    },
    seededRandom: function(a) {
        var b = 1e4 * Math.sin(a);
        return b - (0 | b)
    },
    randomVector3OnDisc: function(a, b, c, d, e, f, g) {
        "use strict";
        var h = 6.2832 * Math.random(),
            i = Math.abs(this.randomFloat(d, e)),
            j = 0,
            k = 0,
            l = 0;
        g && (i = Math.round(i / g) * g), j = Math.cos(h) * i, k = Math.sin(h) * i, j *= f.x, k *= f.y, j += c.x, k += c.y, l += c.z, a.typedArray.setVec3Components(b, j, k, l)
    },
    randomDirectionVector3OnSphere: function() {
        "use strict";
        var a = new THREE.Vector3;
        return function(b, c, d, e, f, g, h, i) {
            a.copy(g), a.x -= d, a.y -= e, a.z -= f, a.normalize().multiplyScalar(-this.randomFloat(h, i)), b.typedArray.setVec3Components(c, a.x, a.y, a.z);
        }
    }(),
    randomDirectionVector3OnDisc: function() {
        "use strict";
        var a = new THREE.Vector3;
        return function(b, c, d, e, f, g, h, i) {
            a.copy(g), a.x -= d, a.y -= e, a.z -= f, a.normalize().multiplyScalar(-this.randomFloat(h, i)), b.typedArray.setVec3Components(c, a.x, a.y, 0)
        }
    }(),
    getPackedRotationAxis: function() {
        "use strict";
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Color;
        return function(d, e) {
            return a.copy(d).normalize(), b.copy(e).normalize(), a.x += .5 * -e.x + Math.random() * e.x, a.y += .5 * -e.y + Math.random() * e.y, a.z += .5 * -e.z + Math.random() * e.z, a.x = Math.abs(a.x), a.y = Math.abs(a.y), a.z = Math.abs(a.z), a.normalize(), c.setRGB(a.x, a.y, a.z), c.getHex()
        }
    }()
}, SPE.Group = function(a) {
    "use strict";
    var b = SPE.utils,
        c = b.types;
    a = b.ensureTypedArg(a, c.OBJECT, {}), a.texture = b.ensureTypedArg(a.texture, c.OBJECT, {}), this.uuid = THREE.Math.generateUUID(), this.fixedTimeStep = b.ensureTypedArg(a.fixedTimeStep, c.NUMBER, .016), this.texture = b.ensureInstanceOf(a.texture.value, THREE.Texture, null), this.textureFrames = b.ensureInstanceOf(a.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1)),
    this.textureFrameCount = b.ensureTypedArg(a.texture.frameCount, c.NUMBER, this.textureFrames.x * this.textureFrames.y), this.textureLoop = b.ensureTypedArg(a.texture.loop, c.NUMBER, 1), this.textureFrames.max(new THREE.Vector2(1, 1)), this.hasPerspective = b.ensureTypedArg(a.hasPerspective, c.BOOLEAN, !0), this.colorize = b.ensureTypedArg(a.colorize, c.BOOLEAN, !0), this.maxParticleCount = b.ensureTypedArg(a.maxParticleCount, c.NUMBER, null), this.blending = b.ensureTypedArg(a.blending, c.NUMBER, THREE.AdditiveBlending), this.transparent = b.ensureTypedArg(a.transparent, c.BOOLEAN, !0), this.alphaTest = parseFloat(b.ensureTypedArg(a.alphaTest, c.NUMBER, 0)), this.depthWrite = b.ensureTypedArg(a.depthWrite, c.BOOLEAN, !1), this.depthTest = b.ensureTypedArg(a.depthTest, c.BOOLEAN, !0), this.fog = b.ensureTypedArg(a.fog, c.BOOLEAN, !0), this.scale = b.ensureTypedArg(a.scale, c.NUMBER, 300), this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !1,
    this.particleCount = 0, this.uniforms = {
        texture: {
            type: "t",
            value: this.texture
        },
        textureAnimation: {
            type: "v4",
            value: new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))
        },
        fogColor: {
            type: "c",
            value: null
        },
        fogNear: {
            type: "f",
            value: 10
        },
        fogFar: {
            type: "f",
            value: 200
        },
        fogDensity: {
            type: "f",
            value: .5
        },
        deltaTime: {
            type: "f",
            value: 0
        },
        runTime: {
            type: "f",
            value: 0
        },
        scale: {
            type: "f",
            value: this.scale
        }
    }, this.defines = {
        HAS_PERSPECTIVE: this.hasPerspective,
        COLORIZE: this.colorize,
        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,
        SHOULD_ROTATE_TEXTURE: !1,
        SHOULD_ROTATE_PARTICLES: !1,
        SHOULD_WIGGLE_PARTICLES: !1,
        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
    }, this.attributes = {
        position: new SPE.ShaderAttribute("v3", !0),
        acceleration: new SPE.ShaderAttribute("v4", !0),
        velocity: new SPE.ShaderAttribute("v3", !0),
        rotation: new SPE.ShaderAttribute("v4", !0),
        rotationCenter: new SPE.ShaderAttribute("v3", !0),
        params: new SPE.ShaderAttribute("v4", !0),
        size: new SPE.ShaderAttribute("v4", !0),
        angle: new SPE.ShaderAttribute("v4", !0),
        color: new SPE.ShaderAttribute("v4", !0),
        opacity: new SPE.ShaderAttribute("v4", !0)
    }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: SPE.shaders.vertex,
        fragmentShader: SPE.shaders.fragment,
        blending: this.blending,
        transparent: this.transparent,
        alphaTest: this.alphaTest,
        depthWrite: this.depthWrite,
        depthTest: this.depthTest,
        defines: this.defines,
        fog: this.fog
    }), this.geometry = new THREE.BufferGeometry, this.mesh = new THREE.Points(this.geometry, this.material), null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.")
}, SPE.Group.constructor = SPE.Group, SPE.Group.prototype._updateDefines = function() {
    "use strict";
    var a,
        b = this.emitters,
        c = b.length - 1,
        d = this.defines;
    for (c; c >= 0; --c)
        a = b[c], d.SHOULD_CALCULATE_SPRITE || (d.SHOULD_ROTATE_TEXTURE = d.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, a.angle.value), Math.max.apply(null, a.angle.spread))),
        d.SHOULD_ROTATE_PARTICLES = d.SHOULD_ROTATE_PARTICLES || !!Math.max(a.rotation.angle, a.rotation.angleSpread), d.SHOULD_WIGGLE_PARTICLES = d.SHOULD_WIGGLE_PARTICLES || !!Math.max(a.wiggle.value, a.wiggle.spread);
    this.material.needsUpdate = !0
}, SPE.Group.prototype._applyAttributesToGeometry = function() {
    "use strict";
    var a,
        b,
        c = this.attributes,
        d = this.geometry,
        e = d.attributes;
    for (var f in c)
        c.hasOwnProperty(f) && (a = c[f], b = e[f], b ? b.array = a.typedArray.array : d.addAttribute(f, a.bufferAttribute), a.bufferAttribute.needsUpdate = !0);
    this.geometry.setDrawRange(0, this.particleCount)
}, SPE.Group.prototype.addEmitter = function(a) {
    "use strict";
    if (a instanceof SPE.Emitter == !1)
        return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
    if (this.emitterIDs.indexOf(a.uuid) > -1)
        return void console.error("Emitter already exists in this group. Will not add again.");
    if (null !== a.group)
        return void console.error("Emitter already belongs to another group. Will not add to requested group.");
    var b = this.attributes,
        c = this.particleCount,
        d = c + a.particleCount;
    this.particleCount = d, null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), a._calculatePPSValue(a.maxAge._value + a.maxAge._spread), a._setBufferUpdateRanges(this.attributeKeys), a._setAttributeOffset(c), a.group = this, a.attributes = this.attributes;
    for (var e in b)
        b.hasOwnProperty(e) && b[e]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
    for (var f = c; d > f; ++f)
        a._assignPositionValue(f), a._assignForceValue(f, "velocity"), a._assignForceValue(f, "acceleration"), a._assignAbsLifetimeValue(f, "opacity"), a._assignAbsLifetimeValue(f, "size"), a._assignAngleValue(f), a._assignRotationValue(f), a._assignParamsValue(f), a._assignColorValue(f);
    return this._applyAttributesToGeometry(), this.emitters.push(a), this.emitterIDs.push(a.uuid), this._updateDefines(a), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0,
    this
}, SPE.Group.prototype.removeEmitter = function(a) {
    "use strict";
    var b = this.emitterIDs.indexOf(a.uuid);
    if (a instanceof SPE.Emitter == !1)
        return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
    if (-1 === b)
        return void console.error("Emitter does not exist in this group. Will not remove.");
    for (var c = a.attributeOffset, d = c + a.particleCount, e = this.attributes.params.typedArray, f = c; d > f; ++f)
        e.array[4 * f] = 0, e.array[4 * f + 1] = 0;
    this.emitters.splice(b, 1), this.emitterIDs.splice(b, 1);
    for (var g in this.attributes)
        this.attributes.hasOwnProperty(g) && this.attributes[g].splice(c, d);
    this.particleCount -= a.particleCount, a._onRemove(), this._attributesNeedRefresh = !0
}, SPE.Group.prototype.getFromPool = function() {
    "use strict";
    var a = this._pool,
        b = this._createNewWhenPoolEmpty;
    return a.length ? a.pop() : b ? new SPE.Emitter(this._poolCreationSettings) : null
}, SPE.Group.prototype.releaseIntoPool = function(a) {
    "use strict";
    return a instanceof SPE.Emitter == !1 ? void console.error("Argument is not instanceof SPE.Emitter:", a) : (a.reset(),
    this._pool.unshift(a), this)
}, SPE.Group.prototype.getPool = function() {
    "use strict";
    return this._pool
}, SPE.Group.prototype.addPool = function(a, b, c) {
    "use strict";
    var d;
    this._poolCreationSettings = b, this._createNewWhenPoolEmpty = !!c;
    for (var e = 0; a > e; ++e)
        d = Array.isArray(b) ? new SPE.Emitter(b[e]) : new SPE.Emitter(b), this.addEmitter(d), this.releaseIntoPool(d);
    return this
}, SPE.Group.prototype._triggerSingleEmitter = function(a) {
    "use strict";
    var b = this.getFromPool(),
        c = this;
    return null === b ? void console.log("SPE.Group pool ran out.") : (a instanceof THREE.Vector3 && (b.position.value.copy(a), b.position.value = b.position.value), b.enable(), setTimeout(function() {
        b.disable(), c.releaseIntoPool(b)
    }, 1e3 * (b.maxAge.value + b.maxAge.spread)), this)
}, SPE.Group.prototype.triggerPoolEmitter = function(a, b) {
    "use strict";
    if ("number" == typeof a && a > 1)
        for (var c = 0; a > c; ++c)
            this._triggerSingleEmitter(b);
    else
        this._triggerSingleEmitter(b);
    return this
}, SPE.Group.prototype._updateUniforms = function(a) {
    "use strict";
    this.uniforms.runTime.value += a,
    this.uniforms.deltaTime.value = a
}, SPE.Group.prototype._resetBufferRanges = function() {
    "use strict";
    var a = this.attributeKeys,
        b = this.attributeCount - 1,
        c = this.attributes;
    for (b; b >= 0; --b)
        c[a[b]].resetUpdateRange()
}, SPE.Group.prototype._updateBuffers = function(a) {
    "use strict";
    var b,
        c,
        d,
        e = this.attributeKeys,
        f = this.attributeCount - 1,
        g = this.attributes,
        h = a.bufferUpdateRanges;
    for (f; f >= 0; --f)
        b = e[f], c = h[b], d = g[b], d.setUpdateRange(c.min, c.max), d.flagUpdate()
}, SPE.Group.prototype.tick = function(a) {
    "use strict";
    var b,
        c = this.emitters,
        d = c.length,
        e = a || this.fixedTimeStep,
        f = this.attributeKeys,
        g = this.attributes;
    if (this._updateUniforms(e), this._resetBufferRanges(), 0 !== d || this._attributesNeedRefresh !== !1 || this._attributesNeedDynamicReset !== !1) {
        for (var h, b = 0; d > b; ++b)
            h = c[b], h.tick(e), this._updateBuffers(h);
        if (this._attributesNeedDynamicReset === !0) {
            for (b = this.attributeCount - 1; b >= 0; --b)
                g[f[b]].resetDynamic();
            this._attributesNeedDynamicReset = !1
        }
        if (this._attributesNeedRefresh === !0) {
            for (b = this.attributeCount - 1; b >= 0; --b)
                g[f[b]].forceUpdateAll();
            this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !0
        }
    }
}, SPE.Group.prototype.dispose = function() {
    "use strict";
    return this.geometry.dispose(), this.material.dispose(), this
}, SPE.Emitter = function(a) {
    "use strict";
    var b = SPE.utils,
        c = b.types,
        d = SPE.valueOverLifetimeLength;
    a = b.ensureTypedArg(a, c.OBJECT, {}), a.position = b.ensureTypedArg(a.position, c.OBJECT, {}), a.velocity = b.ensureTypedArg(a.velocity, c.OBJECT, {}), a.acceleration = b.ensureTypedArg(a.acceleration, c.OBJECT, {}), a.radius = b.ensureTypedArg(a.radius, c.OBJECT, {}), a.drag = b.ensureTypedArg(a.drag, c.OBJECT, {}), a.rotation = b.ensureTypedArg(a.rotation, c.OBJECT, {}), a.color = b.ensureTypedArg(a.color, c.OBJECT, {}), a.opacity = b.ensureTypedArg(a.opacity, c.OBJECT, {}), a.size = b.ensureTypedArg(a.size, c.OBJECT, {}), a.angle = b.ensureTypedArg(a.angle, c.OBJECT, {}), a.wiggle = b.ensureTypedArg(a.wiggle, c.OBJECT, {}), a.maxAge = b.ensureTypedArg(a.maxAge, c.OBJECT, {}), a.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."),
    this.uuid = THREE.Math.generateUUID(), this.type = b.ensureTypedArg(a.type, c.NUMBER, SPE.distributions.BOX), this.position = {
        _value: b.ensureInstanceOf(a.position.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.position.spread, THREE.Vector3, new THREE.Vector3),
        _spreadClamp: b.ensureInstanceOf(a.position.spreadClamp, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.position.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1),
        _radius: b.ensureTypedArg(a.position.radius, c.NUMBER, 10),
        _radiusScale: b.ensureInstanceOf(a.position.scale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),
        _distributionClamp: b.ensureTypedArg(a.position.distributionClamp, c.NUMBER, 0)
    }, this.velocity = {
        _value: b.ensureInstanceOf(a.velocity.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.velocity.spread, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.velocity.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.acceleration = {
        _value: b.ensureInstanceOf(a.acceleration.value, THREE.Vector3, new THREE.Vector3),
        _spread: b.ensureInstanceOf(a.acceleration.spread, THREE.Vector3, new THREE.Vector3),
        _distribution: b.ensureTypedArg(a.acceleration.distribution, c.NUMBER, this.type),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.drag = {
        _value: b.ensureTypedArg(a.drag.value, c.NUMBER, 0),
        _spread: b.ensureTypedArg(a.drag.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.wiggle = {
        _value: b.ensureTypedArg(a.wiggle.value, c.NUMBER, 0),
        _spread: b.ensureTypedArg(a.wiggle.spread, c.NUMBER, 0)
    }, this.rotation = {
        _axis: b.ensureInstanceOf(a.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)),
        _axisSpread: b.ensureInstanceOf(a.rotation.axisSpread, THREE.Vector3, new THREE.Vector3),
        _angle: b.ensureTypedArg(a.rotation.angle, c.NUMBER, 0),
        _angleSpread: b.ensureTypedArg(a.rotation.angleSpread, c.NUMBER, 0),
        _static: b.ensureTypedArg(a.rotation["static"], c.BOOLEAN, !1),
        _center: b.ensureInstanceOf(a.rotation.center, THREE.Vector3, this.position._value.clone()),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.maxAge = {
        _value: b.ensureTypedArg(a.maxAge.value, c.NUMBER, 2),
        _spread: b.ensureTypedArg(a.maxAge.spread, c.NUMBER, 0)
    }, this.color = {
        _value: b.ensureArrayInstanceOf(a.color.value, THREE.Color, new THREE.Color),
        _spread: b.ensureArrayInstanceOf(a.color.spread, THREE.Vector3, new THREE.Vector3),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.opacity = {
        _value: b.ensureArrayTypedArg(a.opacity.value, c.NUMBER, 1),
        _spread: b.ensureArrayTypedArg(a.opacity.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.size = {
        _value: b.ensureArrayTypedArg(a.size.value, c.NUMBER, 1),
        _spread: b.ensureArrayTypedArg(a.size.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.angle = {
        _value: b.ensureArrayTypedArg(a.angle.value, c.NUMBER, 0),
        _spread: b.ensureArrayTypedArg(a.angle.spread, c.NUMBER, 0),
        _randomise: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1)
    }, this.particleCount = b.ensureTypedArg(a.particleCount, c.NUMBER, 100),
    this.duration = b.ensureTypedArg(a.duration, c.NUMBER, null), this.isStatic = b.ensureTypedArg(a.isStatic, c.BOOLEAN, !1), this.activeMultiplier = b.ensureTypedArg(a.activeMultiplier, c.NUMBER, 1), this.direction = b.ensureTypedArg(a.direction, c.NUMBER, 1), this.alive = b.ensureTypedArg(a.alive, c.BOOLEAN, !0), this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.resetFlags = {
        position: b.ensureTypedArg(a.position.randomise, c.BOOLEAN, !1) || b.ensureTypedArg(a.radius.randomise, c.BOOLEAN, !1),
        velocity: b.ensureTypedArg(a.velocity.randomise, c.BOOLEAN, !1),
        acceleration: b.ensureTypedArg(a.acceleration.randomise, c.BOOLEAN, !1) || b.ensureTypedArg(a.drag.randomise, c.BOOLEAN, !1),
        rotation: b.ensureTypedArg(a.rotation.randomise, c.BOOLEAN, !1),
        rotationCenter: b.ensureTypedArg(a.rotation.randomise, c.BOOLEAN, !1),
        size: b.ensureTypedArg(a.size.randomise, c.BOOLEAN, !1),
        color: b.ensureTypedArg(a.color.randomise, c.BOOLEAN, !1),
        opacity: b.ensureTypedArg(a.opacity.randomise, c.BOOLEAN, !1),
        angle: b.ensureTypedArg(a.angle.randomise, c.BOOLEAN, !1)
    }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = {
        maxAge: "params",
        position: "position",
        velocity: "velocity",
        acceleration: "acceleration",
        drag: "acceleration",
        wiggle: "params",
        rotation: "rotation",
        size: "size",
        color: "color",
        opacity: "opacity",
        angle: "angle"
    };
    for (var e in this.updateMap)
        this.updateMap.hasOwnProperty(e) && (this.updateCounts[this.updateMap[e]] = 0, this.updateFlags[this.updateMap[e]] = !1, this._createGetterSetters(this[e], e));
    this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, b.ensureValueOverLifetimeCompliance(this.color, d, d), b.ensureValueOverLifetimeCompliance(this.opacity, d, d), b.ensureValueOverLifetimeCompliance(this.size, d, d), b.ensureValueOverLifetimeCompliance(this.angle, d, d)
}, SPE.Emitter.constructor = SPE.Emitter, SPE.Emitter.prototype._createGetterSetters = function(a, b) {
    "use strict";
    var c = this;
    for (var d in a)
        if (a.hasOwnProperty(d)) {
            var e = d.replace("_", "");
            Object.defineProperty(a, e, {
                get: function(a) {
                    return function() {
                        return this[a]
                    }
                }(d),
                set: function(a) {
                    return function(d) {
                        var e = c.updateMap[b],
                            f = this[a],
                            g = SPE.valueOverLifetimeLength;
                        "_rotationCenter" === a ? (c.updateFlags.rotationCenter = !0, c.updateCounts.rotationCenter = 0) : "_randomise" === a ? c.resetFlags[e] = d : (c.updateFlags[e] = !0, c.updateCounts[e] = 0), c.group._updateDefines(), this[a] = d, Array.isArray(f) && SPE.utils.ensureValueOverLifetimeCompliance(c[b], g, g)
                    }
                }(d)
            })
        }
}, SPE.Emitter.prototype._setBufferUpdateRanges = function(a) {
    "use strict";
    this.attributeKeys = a, this.attributeCount = a.length;
    for (var b = this.attributeCount - 1; b >= 0; --b)
        this.bufferUpdateRanges[a[b]] = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        }
}, SPE.Emitter.prototype._calculatePPSValue = function(a) {
    "use strict";
    var b = this.particleCount;
    this.duration ? this.particlesPerSecond = b / (a < this.duration ? a : this.duration) : this.particlesPerSecond = b / a
}, SPE.Emitter.prototype._setAttributeOffset = function(a) {
    this.attributeOffset = a, this.activationIndex = a,
    this.activationEnd = a + this.particleCount
}, SPE.Emitter.prototype._assignValue = function(a, b) {
    "use strict";
    switch (a) {
    case "position":
        this._assignPositionValue(b);
        break;
    case "velocity":
    case "acceleration":
        this._assignForceValue(b, a);
        break;
    case "size":
    case "opacity":
        this._assignAbsLifetimeValue(b, a);
        break;
    case "angle":
        this._assignAngleValue(b);
        break;
    case "params":
        this._assignParamsValue(b);
        break;
    case "rotation":
        this._assignRotationValue(b);
        break;
    case "color":
        this._assignColorValue(b)
    }
}, SPE.Emitter.prototype._assignPositionValue = function(a) {
    "use strict";
    var b = SPE.distributions,
        c = SPE.utils,
        d = this.position,
        e = this.attributes.position,
        f = d._value,
        g = d._spread,
        h = d._distribution;
    switch (h) {
    case b.BOX:
        c.randomVector3(e, a, f, g, d._spreadClamp);
        break;
    case b.SPHERE:
        c.randomVector3OnSphere(e, a, f, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x, d._distributionClamp || this.particleCount);
        break;
    case b.DISC:
        c.randomVector3OnDisc(e, a, f, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x)
    }
}, SPE.Emitter.prototype._assignForceValue = function(a, b) {
    "use strict";
    var c,
        d,
        e,
        f,
        g,
        h = SPE.distributions,
        i = SPE.utils,
        j = this[b],
        k = j._value,
        l = j._spread,
        m = j._distribution;
    switch (m) {
    case h.BOX:
        i.randomVector3(this.attributes[b], a, k, l);
        break;
    case h.SPHERE:
        c = this.attributes.position.typedArray.array, g = 3 * a, d = c[g], e = c[g + 1], f = c[g + 2], i.randomDirectionVector3OnSphere(this.attributes[b], a, d, e, f, this.position._value, j._value.x, j._spread.x);
        break;
    case h.DISC:
        c = this.attributes.position.typedArray.array, g = 3 * a, d = c[g], e = c[g + 1], f = c[g + 2], i.randomDirectionVector3OnDisc(this.attributes[b], a, d, e, f, this.position._value, j._value.x, j._spread.x)
    }
    if ("acceleration" === b) {
        var n = i.clamp(i.randomFloat(this.drag._value, this.drag._spread), 0, 1);
        this.attributes.acceleration.typedArray.array[4 * a + 3] = n
    }
}, SPE.Emitter.prototype._assignAbsLifetimeValue = function(a, b) {
    "use strict";
    var c,
        d = this.attributes[b].typedArray,
        e = this[b],
        f = SPE.utils;
    f.arrayValuesAreEqual(e._value) && f.arrayValuesAreEqual(e._spread) ? (c = Math.abs(f.randomFloat(e._value[0], e._spread[0])), d.setVec4Components(a, c, c, c, c)) : d.setVec4Components(a, Math.abs(f.randomFloat(e._value[0], e._spread[0])), Math.abs(f.randomFloat(e._value[1], e._spread[1])), Math.abs(f.randomFloat(e._value[2], e._spread[2])), Math.abs(f.randomFloat(e._value[3], e._spread[3])));
}, SPE.Emitter.prototype._assignAngleValue = function(a) {
    "use strict";
    var b,
        c = this.attributes.angle.typedArray,
        d = this.angle,
        e = SPE.utils;
    e.arrayValuesAreEqual(d._value) && e.arrayValuesAreEqual(d._spread) ? (b = e.randomFloat(d._value[0], d._spread[0]), c.setVec4Components(a, b, b, b, b)) : c.setVec4Components(a, e.randomFloat(d._value[0], d._spread[0]), e.randomFloat(d._value[1], d._spread[1]), e.randomFloat(d._value[2], d._spread[2]), e.randomFloat(d._value[3], d._spread[3]))
}, SPE.Emitter.prototype._assignParamsValue = function(a) {
    "use strict";
    this.attributes.params.typedArray.setVec4Components(a, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread))
}, SPE.Emitter.prototype._assignRotationValue = function(a) {
    "use strict";
    this.attributes.rotation.typedArray.setVec3Components(a, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1),
    this.attributes.rotationCenter.typedArray.setVec3(a, this.rotation._center)
}, SPE.Emitter.prototype._assignColorValue = function(a) {
    "use strict";
    SPE.utils.randomColorAsHex(this.attributes.color, a, this.color._value, this.color._spread)
}, SPE.Emitter.prototype._resetParticle = function(a) {
    "use strict";
    for (var b, c, d = this.resetFlags, e = this.updateFlags, f = this.updateCounts, g = this.attributeKeys, h = this.attributeCount - 1; h >= 0; --h)
        b = g[h], c = e[b], (d[b] === !0 || c === !0) && (this._assignValue(b, a), this._updateAttributeUpdateRange(b, a), c === !0 && f[b] === this.particleCount ? (e[b] = !1, f[b] = 0) : 1 == c && ++f[b])
}, SPE.Emitter.prototype._updateAttributeUpdateRange = function(a, b) {
    "use strict";
    var c = this.bufferUpdateRanges[a];
    c.min = Math.min(b, c.min), c.max = Math.max(b, c.max)
}, SPE.Emitter.prototype._resetBufferRanges = function() {
    "use strict";
    var a,
        b = this.bufferUpdateRanges,
        c = this.bufferUpdateKeys,
        d = this.bufferUpdateCount - 1;
    for (d; d >= 0; --d)
        a = c[d], b[a].min = Number.POSITIVE_INFINITY, b[a].max = Number.NEGATIVE_INFINITY
}, SPE.Emitter.prototype._onRemove = function() {
    "use strict";
    this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.age = 0
}, SPE.Emitter.prototype._decrementParticleCount = function() {
    "use strict";
    --this.activeParticleCount
}, SPE.Emitter.prototype._incrementParticleCount = function() {
    "use strict";
    ++this.activeParticleCount
}, SPE.Emitter.prototype._checkParticleAges = function(a, b, c, d) {
    "use strict";
    for (var e, f, g, h, i = b - 1; i >= a; --i)
        e = 4 * i, h = c[e], 0 !== h && (g = c[e + 1], f = c[e + 2], 1 === this.direction ? (g += d, g >= f && (g = 0, h = 0, this._decrementParticleCount())) : (g -= d, 0 >= g && (g = f, h = 0, this._decrementParticleCount())), c[e] = h, c[e + 1] = g, this._updateAttributeUpdateRange("params", i))
}, SPE.Emitter.prototype._activateParticles = function(a, b, c, d) {
    "use strict";
    for (var e, f, g = this.direction, h = a; b > h; ++h)
        e = 4 * h, (0 == c[e] || 1 === this.particleCount) && (this._incrementParticleCount(), c[e] = 1, this._resetParticle(h), f = d * (h - a), c[e + 1] = -1 === g ? c[e + 2] - f : f, this._updateAttributeUpdateRange("params", h));
}, SPE.Emitter.prototype.tick = function(a) {
    "use strict";
    if (!this.isStatic) {
        null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
        var b = this.attributeOffset,
            c = b + this.particleCount,
            d = this.paramsArray,
            e = this.particlesPerSecond * this.activeMultiplier * a,
            f = this.activationIndex;
        if (this._resetBufferRanges(), this._checkParticleAges(b, c, d, a), this.alive === !1)
            return void (this.age = 0);
        if (null !== this.duration && this.age > this.duration)
            return this.alive = !1, void (this.age = 0);
        var g = 1 === this.particleCount ? f : 0 | f,
            h = Math.min(g + e, this.activationEnd),
            i = h - this.activationIndex | 0,
            j = i > 0 ? a / i : 0;
        this._activateParticles(g, h, d, j), this.activationIndex += e, this.activationIndex > c && (this.activationIndex = b), this.age += a
    }
}, SPE.Emitter.prototype.reset = function(a) {
    "use strict";
    if (this.age = 0, this.alive = !1, a === !0) {
        for (var b, c = this.attributeOffset, d = c + this.particleCount, e = this.paramsArray, f = this.attributes.params.bufferAttribute, g = d - 1; g >= c; --g)
            b = 4 * g, e[b] = 0, e[b + 1] = 0;
        f.updateRange.offset = 0, f.updateRange.count = -1,
        f.needsUpdate = !0
    }
    return this
}, SPE.Emitter.prototype.enable = function() {
    "use strict";
    return this.alive = !0, this
}, SPE.Emitter.prototype.disable = function() {
    "use strict";
    return this.alive = !1, this
}, SPE.Emitter.prototype.remove = function() {
    "use strict";
    return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this
};

},{}],"THREE-r72":[function(require,module,exports){
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = {
    REVISION: '72'
};

//

if ( typeof define === 'function' && define.amd ) {

    define( 'three', THREE );

}
else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

    module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

    // Missing in Android stock browser.

    ( function() {

        var lastTime = 0;
        var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

        for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x ) {

            self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
            self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

        }

        if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

            self.requestAnimationFrame = function( callback ) {

                var currTime = Date.now(),
                    timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
                var id = self.setTimeout( function() {

                    callback( currTime + timeToCall );

                }, timeToCall );
                lastTime = currTime + timeToCall;
                return id;

            };

        }

        if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

            self.cancelAnimationFrame = function( id ) {

                self.clearTimeout( id );

            };

        }

    }() );

}

if ( Math.sign === undefined ) {

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    Math.sign = function( x ) {

        return ( x < 0 ) ? -1 : ( x > 0 ) ? 1 : +x;

    };

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    Object.defineProperty( Function.prototype, 'name', {

        get: function() {

            return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

        }

    } );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// DEPRECATED

THREE.Projector = function() {

    console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    this.projectVector = function( vector, camera ) {

        console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
        vector.project( camera );

    };

    this.unprojectVector = function( vector, camera ) {

        console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
        vector.unproject( camera );

    };

    this.pickingRay = function( vector, camera ) {

        console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    };

};

THREE.CanvasRenderer = function() {

    console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    this.domElement = document.createElement( 'canvas' );
    this.clear = function() {};
    this.render = function() {};
    this.setClearColor = function() {};
    this.setSize = function() {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function( color ) {

    if ( arguments.length === 3 ) {

        return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

    }

    return this.set( color );

};

THREE.Color.prototype = {

    constructor: THREE.Color,

    r: 1,
    g: 1,
    b: 1,

    set: function( value ) {

        if ( value instanceof THREE.Color ) {

            this.copy( value );

        }
        else if ( typeof value === 'number' ) {

            this.setHex( value );

        }
        else if ( typeof value === 'string' ) {

            this.setStyle( value );

        }

        return this;

    },

    setHex: function( hex ) {

        hex = Math.floor( hex );

        this.r = ( hex >> 16 & 255 ) / 255;
        this.g = ( hex >> 8 & 255 ) / 255;
        this.b = ( hex & 255 ) / 255;

        return this;

    },

    setRGB: function( r, g, b ) {

        this.r = r;
        this.g = g;
        this.b = b;

        return this;

    },

    setHSL: function() {

        function hue2rgb( p, q, t ) {

            if ( t < 0 ) t += 1;
            if ( t > 1 ) t -= 1;
            if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
            if ( t < 1 / 2 ) return q;
            if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
            return p;

        }

        return function( h, s, l ) {

            // h,s,l ranges are in 0.0 - 1.0
            h = THREE.Math.euclideanModulo( h, 1 );
            s = THREE.Math.clamp( s, 0, 1 );
            l = THREE.Math.clamp( l, 0, 1 );

            if ( s === 0 ) {

                this.r = this.g = this.b = l;

            }
            else {

                var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
                var q = ( 2 * l ) - p;

                this.r = hue2rgb( q, p, h + 1 / 3 );
                this.g = hue2rgb( q, p, h );
                this.b = hue2rgb( q, p, h - 1 / 3 );

            }

            return this;

        };

    }(),

    setStyle: function( style ) {

        var parseAlpha = function( strAlpha ) {

            var alpha = parseFloat( strAlpha );

            if ( alpha < 1 ) {

                console.warn( 'THREE.Color: Alpha component of color ' + style + ' will be ignored.' );

            }

            return alpha;

        }


        var m;

        if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

            // rgb / hsl

            var color;
            var name = m[ 1 ];
            var components = m[ 2 ];

            switch ( name ) {

                case 'rgb':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*$/.exec( components ) ) {

                        // rgb(255,0,0)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

                        // rgb(100%,0%,0%)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

                        return this;

                    }

                    break;

                case 'rgba':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // rgba(255,0,0,0.5)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
                        parseAlpha( color[ 4 ] );

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // rgba(100%,0%,0%,0.5)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
                        parseAlpha( color[ 4 ] );

                        return this;

                    }

                    break;

                case 'hsl':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

                        // hsl(120,50%,50%)
                        var h = parseFloat( color[ 1 ] );
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;

                        return this.setHSL( h, s, l );

                    }

                    break;

                case 'hsla':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

                        // hsla(120,50%,50%,0.5)
                        var h = parseFloat( color[ 1 ] );
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;
                        parseAlpha( color[ 4 ] );

                        return this.setHSL( h, s, l );

                    }

                    break;

            }

        }
        else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

            // hex color

            var hex = m[ 1 ];
            var size = hex.length;

            if ( size === 3 ) {

                // #ff0
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

                return this;

            }
            else if ( size === 6 ) {

                // #ff0000
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

                return this;

            }

        }

        if ( style && style.length > 0 ) {

            // color keywords
            var hex = THREE.ColorKeywords[ style ];

            if ( hex !== undefined ) {

                // red
                this.setHex( hex );

            }
            else {

                // unknown color
                console.warn( 'THREE.Color: Unknown color ' + style );

            }

        }

        return this;

    },

    clone: function() {

        return new this.constructor( this.r, this.g, this.b );

    },

    copy: function( color ) {

        this.r = color.r;
        this.g = color.g;
        this.b = color.b;

        return this;

    },

    copyGammaToLinear: function( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        this.r = Math.pow( color.r, gammaFactor );
        this.g = Math.pow( color.g, gammaFactor );
        this.b = Math.pow( color.b, gammaFactor );

        return this;

    },

    copyLinearToGamma: function( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

        this.r = Math.pow( color.r, safeInverse );
        this.g = Math.pow( color.g, safeInverse );
        this.b = Math.pow( color.b, safeInverse );

        return this;

    },

    convertGammaToLinear: function() {

        var r = this.r,
            g = this.g,
            b = this.b;

        this.r = r * r;
        this.g = g * g;
        this.b = b * b;

        return this;

    },

    convertLinearToGamma: function() {

        this.r = Math.sqrt( this.r );
        this.g = Math.sqrt( this.g );
        this.b = Math.sqrt( this.b );

        return this;

    },

    getHex: function() {

        return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    },

    getHexString: function() {

        return ( '000000' + this.getHex().toString( 16 ) ).slice( -6 );

    },

    getHSL: function( optionalTarget ) {

        // h,s,l ranges are in 0.0 - 1.0

        var hsl = optionalTarget || {
            h: 0,
            s: 0,
            l: 0
        };

        var r = this.r,
            g = this.g,
            b = this.b;

        var max = Math.max( r, g, b );
        var min = Math.min( r, g, b );

        var hue, saturation;
        var lightness = ( min + max ) / 2.0;

        if ( min === max ) {

            hue = 0;
            saturation = 0;

        }
        else {

            var delta = max - min;

            saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

            switch ( max ) {

                case r:
                    hue = ( g - b ) / delta + ( g < b ? 6 : 0 );
                    break;
                case g:
                    hue = ( b - r ) / delta + 2;
                    break;
                case b:
                    hue = ( r - g ) / delta + 4;
                    break;

            }

            hue /= 6;

        }

        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;

        return hsl;

    },

    getStyle: function() {

        return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    },

    offsetHSL: function( h, s, l ) {

        var hsl = this.getHSL();

        hsl.h += h;
        hsl.s += s;
        hsl.l += l;

        this.setHSL( hsl.h, hsl.s, hsl.l );

        return this;

    },

    add: function( color ) {

        this.r += color.r;
        this.g += color.g;
        this.b += color.b;

        return this;

    },

    addColors: function( color1, color2 ) {

        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;

        return this;

    },

    addScalar: function( s ) {

        this.r += s;
        this.g += s;
        this.b += s;

        return this;

    },

    multiply: function( color ) {

        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;

        return this;

    },

    multiplyScalar: function( s ) {

        this.r *= s;
        this.g *= s;
        this.b *= s;

        return this;

    },

    lerp: function( color, alpha ) {

        this.r += ( color.r - this.r ) * alpha;
        this.g += ( color.g - this.g ) * alpha;
        this.b += ( color.b - this.b ) * alpha;

        return this;

    },

    equals: function( c ) {

        return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    },

    fromArray: function( array ) {

        this.r = array[ 0 ];
        this.g = array[ 1 ];
        this.b = array[ 2 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.r;
        array[ offset + 1 ] = this.g;
        array[ offset + 2 ] = this.b;

        return array;

    }

};

THREE.ColorKeywords = {
    'aliceblue': 0xF0F8FF,
    'antiquewhite': 0xFAEBD7,
    'aqua': 0x00FFFF,
    'aquamarine': 0x7FFFD4,
    'azure': 0xF0FFFF,
    'beige': 0xF5F5DC,
    'bisque': 0xFFE4C4,
    'black': 0x000000,
    'blanchedalmond': 0xFFEBCD,
    'blue': 0x0000FF,
    'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A,
    'burlywood': 0xDEB887,
    'cadetblue': 0x5F9EA0,
    'chartreuse': 0x7FFF00,
    'chocolate': 0xD2691E,
    'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED,
    'cornsilk': 0xFFF8DC,
    'crimson': 0xDC143C,
    'cyan': 0x00FFFF,
    'darkblue': 0x00008B,
    'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B,
    'darkgray': 0xA9A9A9,
    'darkgreen': 0x006400,
    'darkgrey': 0xA9A9A9,
    'darkkhaki': 0xBDB76B,
    'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F,
    'darkorange': 0xFF8C00,
    'darkorchid': 0x9932CC,
    'darkred': 0x8B0000,
    'darksalmon': 0xE9967A,
    'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B,
    'darkslategray': 0x2F4F4F,
    'darkslategrey': 0x2F4F4F,
    'darkturquoise': 0x00CED1,
    'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493,
    'deepskyblue': 0x00BFFF,
    'dimgray': 0x696969,
    'dimgrey': 0x696969,
    'dodgerblue': 0x1E90FF,
    'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0,
    'forestgreen': 0x228B22,
    'fuchsia': 0xFF00FF,
    'gainsboro': 0xDCDCDC,
    'ghostwhite': 0xF8F8FF,
    'gold': 0xFFD700,
    'goldenrod': 0xDAA520,
    'gray': 0x808080,
    'green': 0x008000,
    'greenyellow': 0xADFF2F,
    'grey': 0x808080,
    'honeydew': 0xF0FFF0,
    'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C,
    'indigo': 0x4B0082,
    'ivory': 0xFFFFF0,
    'khaki': 0xF0E68C,
    'lavender': 0xE6E6FA,
    'lavenderblush': 0xFFF0F5,
    'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD,
    'lightblue': 0xADD8E6,
    'lightcoral': 0xF08080,
    'lightcyan': 0xE0FFFF,
    'lightgoldenrodyellow': 0xFAFAD2,
    'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90,
    'lightgrey': 0xD3D3D3,
    'lightpink': 0xFFB6C1,
    'lightsalmon': 0xFFA07A,
    'lightseagreen': 0x20B2AA,
    'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899,
    'lightslategrey': 0x778899,
    'lightsteelblue': 0xB0C4DE,
    'lightyellow': 0xFFFFE0,
    'lime': 0x00FF00,
    'limegreen': 0x32CD32,
    'linen': 0xFAF0E6,
    'magenta': 0xFF00FF,
    'maroon': 0x800000,
    'mediumaquamarine': 0x66CDAA,
    'mediumblue': 0x0000CD,
    'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB,
    'mediumseagreen': 0x3CB371,
    'mediumslateblue': 0x7B68EE,
    'mediumspringgreen': 0x00FA9A,
    'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585,
    'midnightblue': 0x191970,
    'mintcream': 0xF5FFFA,
    'mistyrose': 0xFFE4E1,
    'moccasin': 0xFFE4B5,
    'navajowhite': 0xFFDEAD,
    'navy': 0x000080,
    'oldlace': 0xFDF5E6,
    'olive': 0x808000,
    'olivedrab': 0x6B8E23,
    'orange': 0xFFA500,
    'orangered': 0xFF4500,
    'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA,
    'palegreen': 0x98FB98,
    'paleturquoise': 0xAFEEEE,
    'palevioletred': 0xDB7093,
    'papayawhip': 0xFFEFD5,
    'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F,
    'pink': 0xFFC0CB,
    'plum': 0xDDA0DD,
    'powderblue': 0xB0E0E6,
    'purple': 0x800080,
    'red': 0xFF0000,
    'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1,
    'saddlebrown': 0x8B4513,
    'salmon': 0xFA8072,
    'sandybrown': 0xF4A460,
    'seagreen': 0x2E8B57,
    'seashell': 0xFFF5EE,
    'sienna': 0xA0522D,
    'silver': 0xC0C0C0,
    'skyblue': 0x87CEEB,
    'slateblue': 0x6A5ACD,
    'slategray': 0x708090,
    'slategrey': 0x708090,
    'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F,
    'steelblue': 0x4682B4,
    'tan': 0xD2B48C,
    'teal': 0x008080,
    'thistle': 0xD8BFD8,
    'tomato': 0xFF6347,
    'turquoise': 0x40E0D0,
    'violet': 0xEE82EE,
    'wheat': 0xF5DEB3,
    'white': 0xFFFFFF,
    'whitesmoke': 0xF5F5F5,
    'yellow': 0xFFFF00,
    'yellowgreen': 0x9ACD32
};

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function( x, y, z, w ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

    constructor: THREE.Quaternion,

    get x() {

        return this._x;

    },

    set x( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y() {

        return this._y;

    },

    set y( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z() {

        return this._z;

    },

    set z( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get w() {

        return this._w;

    },

    set w( value ) {

        this._w = value;
        this.onChangeCallback();

    },

    set: function( x, y, z, w ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;

        this.onChangeCallback();

        return this;

    },

    clone: function() {

        return new this.constructor( this._x, this._y, this._z, this._w );

    },

    copy: function( quaternion ) {

        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;

        this.onChangeCallback();

        return this;

    },

    setFromEuler: function( euler, update ) {

        if ( euler instanceof THREE.Euler === false ) {

            throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m

        var c1 = Math.cos( euler._x / 2 );
        var c2 = Math.cos( euler._y / 2 );
        var c3 = Math.cos( euler._z / 2 );
        var s1 = Math.sin( euler._x / 2 );
        var s2 = Math.sin( euler._y / 2 );
        var s3 = Math.sin( euler._z / 2 );

        var order = euler.order;

        if ( order === 'XYZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'YXZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }
        else if ( order === 'ZXY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'ZYX' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }
        else if ( order === 'YZX' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        }
        else if ( order === 'XZY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromAxisAngle: function( axis, angle ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

        // assumes axis is normalized

        var halfAngle = angle / 2,
            s = Math.sin( halfAngle );

        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos( halfAngle );

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements,

            m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ],
            m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ],
            m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {

            s = 0.5 / Math.sqrt( trace + 1.0 );

            this._w = 0.25 / s;
            this._x = ( m32 - m23 ) * s;
            this._y = ( m13 - m31 ) * s;
            this._z = ( m21 - m12 ) * s;

        }
        else if ( m11 > m22 && m11 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            this._w = ( m32 - m23 ) / s;
            this._x = 0.25 * s;
            this._y = ( m12 + m21 ) / s;
            this._z = ( m13 + m31 ) / s;

        }
        else if ( m22 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            this._w = ( m13 - m31 ) / s;
            this._x = ( m12 + m21 ) / s;
            this._y = 0.25 * s;
            this._z = ( m23 + m32 ) / s;

        }
        else {

            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            this._w = ( m21 - m12 ) / s;
            this._x = ( m13 + m31 ) / s;
            this._y = ( m23 + m32 ) / s;
            this._z = 0.25 * s;

        }

        this.onChangeCallback();

        return this;

    },

    setFromUnitVectors: function() {

        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

        // assumes direction vectors vFrom and vTo are normalized

        var v1, r;

        var EPS = 0.000001;

        return function( vFrom, vTo ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            r = vFrom.dot( vTo ) + 1;

            if ( r < EPS ) {

                r = 0;

                if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

                    v1.set( -vFrom.y, vFrom.x, 0 );

                }
                else {

                    v1.set( 0, -vFrom.z, vFrom.y );

                }

            }
            else {

                v1.crossVectors( vFrom, vTo );

            }

            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;

            this.normalize();

            return this;

        }

    }(),

    inverse: function() {

        this.conjugate().normalize();

        return this;

    },

    conjugate: function() {

        this._x *= -1;
        this._y *= -1;
        this._z *= -1;

        this.onChangeCallback();

        return this;

    },

    dot: function( v ) {

        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    },

    lengthSq: function() {

        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    },

    length: function() {

        return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    },

    normalize: function() {

        var l = this.length();

        if ( l === 0 ) {

            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;

        }
        else {

            l = 1 / l;

            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;

        }

        this.onChangeCallback();

        return this;

    },

    multiply: function( q, p ) {

        if ( p !== undefined ) {

            console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
            return this.multiplyQuaternions( q, p );

        }

        return this.multiplyQuaternions( this, q );

    },

    multiplyQuaternions: function( a, b ) {

        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

        var qax = a._x,
            qay = a._y,
            qaz = a._z,
            qaw = a._w;
        var qbx = b._x,
            qby = b._y,
            qbz = b._z,
            qbw = b._w;

        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        this.onChangeCallback();

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
        return vector.applyQuaternion( this );

    },

    slerp: function( qb, t ) {

        if ( t === 0 ) return this;
        if ( t === 1 ) return this.copy( qb );

        var x = this._x,
            y = this._y,
            z = this._z,
            w = this._w;

        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

        if ( cosHalfTheta < 0 ) {

            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;

            cosHalfTheta = -cosHalfTheta;

        }
        else {

            this.copy( qb );

        }

        if ( cosHalfTheta >= 1.0 ) {

            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;

            return this;

        }

        var halfTheta = Math.acos( cosHalfTheta );
        var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

        if ( Math.abs( sinHalfTheta ) < 0.001 ) {

            this._w = 0.5 * ( w + this._w );
            this._x = 0.5 * ( x + this._x );
            this._y = 0.5 * ( y + this._y );
            this._z = 0.5 * ( z + this._z );

            return this;

        }

        var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
            ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        this._w = ( w * ratioA + this._w * ratioB );
        this._x = ( x * ratioA + this._x * ratioB );
        this._y = ( y * ratioA + this._y * ratioB );
        this._z = ( z * ratioA + this._z * ratioB );

        this.onChangeCallback();

        return this;

    },

    equals: function( quaternion ) {

        return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this._x = array[ offset ];
        this._y = array[ offset + 1 ];
        this._z = array[ offset + 2 ];
        this._w = array[ offset + 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._w;

        return array;

    },

    onChange: function( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function() {}

};

THREE.Quaternion.slerp = function( qa, qb, qm, t ) {

    return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function( x, y ) {

    this.x = x || 0;
    this.y = y || 0;

};

THREE.Vector2.prototype = {

    constructor: THREE.Vector2,

    set: function( x, y ) {

        this.x = x;
        this.y = y;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;

        return this;

    },

    multiply: function( v ) {

        this.x *= v.x;
        this.y *= v.y;

        return this;

    },

    multiplyScalar: function( s ) {

        this.x *= s;
        this.y *= s;

        return this;

    },

    divide: function( v ) {

        this.x /= v.x;
        this.y /= v.y;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;

        }

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector2();
                max = new THREE.Vector2();

            }

            min.set( minVal, minVal );
            max.set( maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    distanceTo: function( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function( v ) {

        var dx = this.x - v.x,
            dy = this.y - v.y;
        return dx * dx + dy * dy;

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];

        return this;

    }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function( x, y, z ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

};

THREE.Vector3.prototype = {

    constructor: THREE.Vector3,

    set: function( x, y, z ) {

        this.x = x;
        this.y = y;
        this.z = z;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setZ: function( z ) {

        this.z = z;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y, this.z );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;
        this.z += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;

        return this;

    },

    multiply: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
            return this.multiplyVectors( v, w );

        }

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;

        return this;

    },

    multiplyScalar: function( scalar ) {

        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;

        return this;

    },

    multiplyVectors: function( a, b ) {

        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;

        return this;

    },

    applyEuler: function() {

        var quaternion;

        return function applyEuler( euler ) {

            if ( euler instanceof THREE.Euler === false ) {

                console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

            }

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromEuler( euler ) );

            return this;

        };

    }(),

    applyAxisAngle: function() {

        var quaternion;

        return function applyAxisAngle( axis, angle ) {

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

            return this;

        };

    }(),

    applyMatrix3: function( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
        this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
        this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

        return this;

    },

    applyMatrix4: function( m ) {

        // input: THREE.Matrix4 affine matrix

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ];
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ];
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

        return this;

    },

    applyProjection: function( m ) {

        // input: THREE.Matrix4 projection matrix

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;
        var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

        this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * d;
        this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * d;
        this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

        return this;

    },

    applyQuaternion: function( q ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vector

        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return this;

    },

    project: function() {

        var matrix;

        return function project( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
            return this.applyProjection( matrix );

        };

    }(),

    unproject: function() {

        var matrix;

        return function unproject( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
            return this.applyProjection( matrix );

        };

    }(),

    transformDirection: function( m ) {

        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction

        var x = this.x,
            y = this.y,
            z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

        this.normalize();

        return this;

    },

    divide: function( v ) {

        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;
            this.z = 0;

        }

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        if ( this.z > v.z ) {

            this.z = v.z;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        if ( this.z < v.z ) {

            this.z = v.z;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        if ( this.z < min.z ) {

            this.z = min.z;

        }
        else if ( this.z > max.z ) {

            this.z = max.z;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector3();
                max = new THREE.Vector3();

            }

            min.set( minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y + this.z * this.z;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    cross: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
            return this.crossVectors( v, w );

        }

        var x = this.x,
            y = this.y,
            z = this.z;

        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;

        return this;

    },

    crossVectors: function( a, b ) {

        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;

    },

    projectOnVector: function() {

        var v1, dot;

        return function projectOnVector( vector ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( vector ).normalize();

            dot = this.dot( v1 );

            return this.copy( v1 ).multiplyScalar( dot );

        };

    }(),

    projectOnPlane: function() {

        var v1;

        return function projectOnPlane( planeNormal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( this ).projectOnVector( planeNormal );

            return this.sub( v1 );

        }

    }(),

    reflect: function() {

        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length

        var v1;

        return function reflect( normal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

        }

    }(),

    angleTo: function( v ) {

        var theta = this.dot( v ) / ( this.length() * v.length() );

        // clamp, to handle numerical problems

        return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

    },

    distanceTo: function( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function( v ) {

        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;

        return dx * dx + dy * dy + dz * dz;

    },

    setEulerFromRotationMatrix: function( m, order ) {

        console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

    },

    setEulerFromQuaternion: function( q, order ) {

        console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

    },

    getPositionFromMatrix: function( m ) {

        console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

        return this.setFromMatrixPosition( m );

    },

    getScaleFromMatrix: function( m ) {

        console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

        return this.setFromMatrixScale( m );

    },

    getColumnFromMatrix: function( index, matrix ) {

        console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

        return this.setFromMatrixColumn( index, matrix );

    },

    setFromMatrixPosition: function( m ) {

        this.x = m.elements[ 12 ];
        this.y = m.elements[ 13 ];
        this.z = m.elements[ 14 ];

        return this;

    },

    setFromMatrixScale: function( m ) {

        var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
        var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
        var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

        this.x = sx;
        this.y = sy;
        this.z = sz;

        return this;

    },

    setFromMatrixColumn: function( index, matrix ) {

        var offset = index * 4;

        var me = matrix.elements;

        this.x = me[ offset ];
        this.y = me[ offset + 1 ];
        this.z = me[ offset + 2 ];

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];

        return this;

    }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function( x, y, z, w ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

    constructor: THREE.Vector4,

    set: function( x, y, z, w ) {

        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;

    },

    setX: function( x ) {

        this.x = x;

        return this;

    },

    setY: function( y ) {

        this.y = y;

        return this;

    },

    setZ: function( z ) {

        this.z = z;

        return this;

    },

    setW: function( w ) {

        this.w = w;

        return this;

    },

    setComponent: function( index, value ) {

        switch ( index ) {

            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function( index ) {

        switch ( index ) {

            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function() {

        return new this.constructor( this.x, this.y, this.z, this.w );

    },

    copy: function( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = ( v.w !== undefined ) ? v.w : 1;

        return this;

    },

    add: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;

        return this;

    },

    addScalar: function( s ) {

        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;

        return this;

    },

    addVectors: function( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;

        return this;

    },

    addScaledVector: function( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;

        return this;

    },

    sub: function( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;

        return this;

    },

    subScalar: function( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;

        return this;

    },

    subVectors: function( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;

        return this;

    },

    multiplyScalar: function( scalar ) {

        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;

        return this;

    },

    applyMatrix4: function( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
        this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

        return this;

    },

    divideScalar: function( scalar ) {

        if ( scalar !== 0 ) {

            var invScalar = 1 / scalar;

            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;
            this.w *= invScalar;

        }
        else {

            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;

        }

        return this;

    },

    setAxisAngleFromQuaternion: function( q ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

        // q is assumed to be normalized

        this.w = 2 * Math.acos( q.w );

        var s = Math.sqrt( 1 - q.w * q.w );

        if ( s < 0.0001 ) {

            this.x = 1;
            this.y = 0;
            this.z = 0;

        }
        else {

            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;

        }

        return this;

    },

    setAxisAngleFromRotationMatrix: function( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var angle, x, y, z, // variables for result
            epsilon = 0.01, // margin to allow for rounding errors
            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees

            te = m.elements,

            m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ],
            m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ],
            m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ];

        if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) {

            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms

            if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

                // this singularity is identity matrix so angle = 0

                this.set( 1, 0, 0, 0 );

                return this; // zero angle, arbitrary axis

            }

            // otherwise this singularity is angle = 180

            angle = Math.PI;

            var xx = ( m11 + 1 ) / 2;
            var yy = ( m22 + 1 ) / 2;
            var zz = ( m33 + 1 ) / 2;
            var xy = ( m12 + m21 ) / 4;
            var xz = ( m13 + m31 ) / 4;
            var yz = ( m23 + m32 ) / 4;

            if ( ( xx > yy ) && ( xx > zz ) ) {

                // m11 is the largest diagonal term

                if ( xx < epsilon ) {

                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;

                }
                else {

                    x = Math.sqrt( xx );
                    y = xy / x;
                    z = xz / x;

                }

            }
            else if ( yy > zz ) {

                // m22 is the largest diagonal term

                if ( yy < epsilon ) {

                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;

                }
                else {

                    y = Math.sqrt( yy );
                    x = xy / y;
                    z = yz / y;

                }

            }
            else {

                // m33 is the largest diagonal term so base result on this

                if ( zz < epsilon ) {

                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;

                }
                else {

                    z = Math.sqrt( zz );
                    x = xz / z;
                    y = yz / z;

                }

            }

            this.set( x, y, z, angle );

            return this; // return 180 deg rotation

        }

        // as we have reached here there are no singularities so we can handle normally

        var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

        if ( Math.abs( s ) < 0.001 ) s = 1;

        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case

        this.x = ( m32 - m23 ) / s;
        this.y = ( m13 - m31 ) / s;
        this.z = ( m21 - m12 ) / s;
        this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

        return this;

    },

    min: function( v ) {

        if ( this.x > v.x ) {

            this.x = v.x;

        }

        if ( this.y > v.y ) {

            this.y = v.y;

        }

        if ( this.z > v.z ) {

            this.z = v.z;

        }

        if ( this.w > v.w ) {

            this.w = v.w;

        }

        return this;

    },

    max: function( v ) {

        if ( this.x < v.x ) {

            this.x = v.x;

        }

        if ( this.y < v.y ) {

            this.y = v.y;

        }

        if ( this.z < v.z ) {

            this.z = v.z;

        }

        if ( this.w < v.w ) {

            this.w = v.w;

        }

        return this;

    },

    clamp: function( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        if ( this.x < min.x ) {

            this.x = min.x;

        }
        else if ( this.x > max.x ) {

            this.x = max.x;

        }

        if ( this.y < min.y ) {

            this.y = min.y;

        }
        else if ( this.y > max.y ) {

            this.y = max.y;

        }

        if ( this.z < min.z ) {

            this.z = min.z;

        }
        else if ( this.z > max.z ) {

            this.z = max.z;

        }

        if ( this.w < min.w ) {

            this.w = min.w;

        }
        else if ( this.w > max.w ) {

            this.w = max.w;

        }

        return this;

    },

    clampScalar: function() {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector4();
                max = new THREE.Vector4();

            }

            min.set( minVal, minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function() {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function() {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function() {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function() {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

    negate: function() {

        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;

        return this;

    },

    dot: function( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    },

    lengthSq: function() {

        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    },

    length: function() {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    },

    normalize: function() {

        return this.divideScalar( this.length() );

    },

    setLength: function( l ) {

        var oldLength = this.length();

        if ( oldLength !== 0 && l !== oldLength ) {

            this.multiplyScalar( l / oldLength );

        }

        return this;

    },

    lerp: function( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;
        this.w += ( v.w - this.w ) * alpha;

        return this;

    },

    lerpVectors: function( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    },

    fromArray: function( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];
        this.w = array[ offset + 3 ];

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;
        array[ offset + 3 ] = this.w;

        return array;

    },

    fromAttribute: function( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];
        this.w = attribute.array[ index + 3 ];

        return this;

    }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function( x, y, z, order ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

    constructor: THREE.Euler,

    get x() {

        return this._x;

    },

    set x( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y() {

        return this._y;

    },

    set y( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z() {

        return this._z;

    },

    set z( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get order() {

        return this._order;

    },

    set order( value ) {

        this._order = value;
        this.onChangeCallback();

    },

    set: function( x, y, z, order ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;

        this.onChangeCallback();

        return this;

    },

    clone: function() {

        return new this.constructor( this._x, this._y, this._z, this._order );

    },

    copy: function( euler ) {

        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function( m, order, update ) {

        var clamp = THREE.Math.clamp;

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements;
        var m11 = te[ 0 ],
            m12 = te[ 4 ],
            m13 = te[ 8 ];
        var m21 = te[ 1 ],
            m22 = te[ 5 ],
            m23 = te[ 9 ];
        var m31 = te[ 2 ],
            m32 = te[ 6 ],
            m33 = te[ 10 ];

        order = order || this._order;

        if ( order === 'XYZ' ) {

            this._y = Math.asin( clamp( m13, -1, 1 ) );

            if ( Math.abs( m13 ) < 0.99999 ) {

                this._x = Math.atan2( -m23, m33 );
                this._z = Math.atan2( -m12, m11 );

            }
            else {

                this._x = Math.atan2( m32, m22 );
                this._z = 0;

            }

        }
        else if ( order === 'YXZ' ) {

            this._x = Math.asin( -clamp( m23, -1, 1 ) );

            if ( Math.abs( m23 ) < 0.99999 ) {

                this._y = Math.atan2( m13, m33 );
                this._z = Math.atan2( m21, m22 );

            }
            else {

                this._y = Math.atan2( -m31, m11 );
                this._z = 0;

            }

        }
        else if ( order === 'ZXY' ) {

            this._x = Math.asin( clamp( m32, -1, 1 ) );

            if ( Math.abs( m32 ) < 0.99999 ) {

                this._y = Math.atan2( -m31, m33 );
                this._z = Math.atan2( -m12, m22 );

            }
            else {

                this._y = 0;
                this._z = Math.atan2( m21, m11 );

            }

        }
        else if ( order === 'ZYX' ) {

            this._y = Math.asin( -clamp( m31, -1, 1 ) );

            if ( Math.abs( m31 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m33 );
                this._z = Math.atan2( m21, m11 );

            }
            else {

                this._x = 0;
                this._z = Math.atan2( -m12, m22 );

            }

        }
        else if ( order === 'YZX' ) {

            this._z = Math.asin( clamp( m21, -1, 1 ) );

            if ( Math.abs( m21 ) < 0.99999 ) {

                this._x = Math.atan2( -m23, m22 );
                this._y = Math.atan2( -m31, m11 );

            }
            else {

                this._x = 0;
                this._y = Math.atan2( m13, m33 );

            }

        }
        else if ( order === 'XZY' ) {

            this._z = Math.asin( -clamp( m12, -1, 1 ) );

            if ( Math.abs( m12 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m22 );
                this._y = Math.atan2( m13, m11 );

            }
            else {

                this._x = Math.atan2( -m23, m33 );
                this._y = 0;

            }

        }
        else {

            console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

        }

        this._order = order;

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromQuaternion: function() {

        var matrix;

        return function( q, order, update ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();
            matrix.makeRotationFromQuaternion( q );
            this.setFromRotationMatrix( matrix, order, update );

            return this;

        };

    }(),

    setFromVector3: function( v, order ) {

        return this.set( v.x, v.y, v.z, order || this._order );

    },

    reorder: function() {

        // WARNING: this discards revolution information -bhouston

        var q = new THREE.Quaternion();

        return function( newOrder ) {

            q.setFromEuler( this );
            this.setFromQuaternion( q, newOrder );

        };

    }(),

    equals: function( euler ) {

        return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    },

    fromArray: function( array ) {

        this._x = array[ 0 ];
        this._y = array[ 1 ];
        this._z = array[ 2 ];
        if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._order;

        return array;

    },

    toVector3: function( optionalResult ) {

        if ( optionalResult ) {

            return optionalResult.set( this._x, this._y, this._z );

        }
        else {

            return new THREE.Vector3( this._x, this._y, this._z );

        }

    },

    onChange: function( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function() {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function( start, end ) {

    this.start = ( start !== undefined ) ? start : new THREE.Vector3();
    this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

    constructor: THREE.Line3,

    set: function( start, end ) {

        this.start.copy( start );
        this.end.copy( end );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( line ) {

        this.start.copy( line.start );
        this.end.copy( line.end );

        return this;

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    },

    delta: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.end, this.start );

    },

    distanceSq: function() {

        return this.start.distanceToSquared( this.end );

    },

    distance: function() {

        return this.start.distanceTo( this.end );

    },

    at: function( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    closestPointToPointParameter: function() {

        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();

        return function( point, clampToLine ) {

            startP.subVectors( point, this.start );
            startEnd.subVectors( this.end, this.start );

            var startEnd2 = startEnd.dot( startEnd );
            var startEnd_startP = startEnd.dot( startP );

            var t = startEnd_startP / startEnd2;

            if ( clampToLine ) {

                t = THREE.Math.clamp( t, 0, 1 );

            }

            return t;

        };

    }(),

    closestPointToPoint: function( point, clampToLine, optionalTarget ) {

        var t = this.closestPointToPointParameter( point, clampToLine );

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    applyMatrix4: function( matrix ) {

        this.start.applyMatrix4( matrix );
        this.end.applyMatrix4( matrix );

        return this;

    },

    equals: function( line ) {

        return line.start.equals( this.start ) && line.end.equals( this.end );

    }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.Box2.prototype = {

    constructor: THREE.Box2,

    set: function( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i++ ) {

            this.expandByPoint( points[ i ] )

        }

        return this;

    },

    setFromCenterAndSize: function() {

        var v1 = new THREE.Vector2();

        return function( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function() {

        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;

        return this;

    },

    empty: function() {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function( scalar ) {

        this.min.addScalar( -scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ) {

            return false;

        }

        return true;

    },

    containsBox: function( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

            return true;

        }

        return false;

    },

    getParameter: function( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector2();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ), ( point.y - this.min.y ) / ( this.max.y - this.min.y )
        );

    },

    isIntersectionBox: function( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ) {

            return false;

        }

        return true;

    },

    clampPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function() {

        var v1 = new THREE.Vector2();

        return function( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    intersect: function( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    translate: function( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.Box3.prototype = {

    constructor: THREE.Box3,

    set: function( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i++ ) {

            this.expandByPoint( points[ i ] );

        }

        return this;

    },

    setFromCenterAndSize: function() {

        var v1 = new THREE.Vector3();

        return function( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    setFromObject: function() {

        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms

        var v1 = new THREE.Vector3();

        return function( object ) {

            var scope = this;

            object.updateMatrixWorld( true );

            this.makeEmpty();

            object.traverse( function( node ) {

                var geometry = node.geometry;

                if ( geometry !== undefined ) {

                    if ( geometry instanceof THREE.Geometry ) {

                        var vertices = geometry.vertices;

                        for ( var i = 0, il = vertices.length; i < il; i++ ) {

                            v1.copy( vertices[ i ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }
                    else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

                        var positions = geometry.attributes[ 'position' ].array;

                        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                            v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }

                }

            } );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function() {

        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;

        return this;

    },

    empty: function() {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    },

    center: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function( scalar ) {

        this.min.addScalar( -scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ||
            point.z < this.min.z || point.z > this.max.z ) {

            return false;

        }

        return true;

    },

    containsBox: function( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
            ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

            return true;

        }

        return false;

    },

    getParameter: function( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector3();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ), ( point.y - this.min.y ) / ( this.max.y - this.min.y ), ( point.z - this.min.z ) / ( this.max.z - this.min.z )
        );

    },

    isIntersectionBox: function( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ||
            box.max.z < this.min.z || box.min.z > this.max.z ) {

            return false;

        }

        return true;

    },

    clampPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function() {

        var v1 = new THREE.Vector3();

        return function( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    getBoundingSphere: function() {

        var v1 = new THREE.Vector3();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Sphere();

            result.center = this.center();
            result.radius = this.size( v1 ).length() * 0.5;

            return result;

        };

    }(),

    intersect: function( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    applyMatrix4: function() {

        var points = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];

        return function( matrix ) {

            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
            points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
            points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
            points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
            points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
            points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
            points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
            points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

            this.makeEmpty();
            this.setFromPoints( points );

            return this;

        };

    }(),

    translate: function( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function() {

    this.elements = new Float32Array( [

        1, 0, 0,
        0, 1, 0,
        0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix3.prototype = {

    constructor: THREE.Matrix3,

    set: function( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

        var te = this.elements;

        te[ 0 ] = n11;
        te[ 3 ] = n12;
        te[ 6 ] = n13;
        te[ 1 ] = n21;
        te[ 4 ] = n22;
        te[ 7 ] = n23;
        te[ 2 ] = n31;
        te[ 5 ] = n32;
        te[ 8 ] = n33;

        return this;

    },

    identity: function() {

        this.set(

            1, 0, 0,
            0, 1, 0,
            0, 0, 1

        );

        return this;

    },

    clone: function() {

        return new this.constructor().fromArray( this.elements );

    },

    copy: function( m ) {

        var me = m.elements;

        this.set(

            me[ 0 ], me[ 3 ], me[ 6 ],
            me[ 1 ], me[ 4 ], me[ 7 ],
            me[ 2 ], me[ 5 ], me[ 8 ]

        );

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
        return vector.applyMatrix3( this );

    },

    multiplyVector3Array: function( a ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function() {

        var v1;

        return function( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix3( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function() {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i++, j++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix3( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    multiplyScalar: function( s ) {

        var te = this.elements;

        te[ 0 ] *= s;
        te[ 3 ] *= s;
        te[ 6 ] *= s;
        te[ 1 ] *= s;
        te[ 4 ] *= s;
        te[ 7 ] *= s;
        te[ 2 ] *= s;
        te[ 5 ] *= s;
        te[ 8 ] *= s;

        return this;

    },

    determinant: function() {

        var te = this.elements;

        var a = te[ 0 ],
            b = te[ 1 ],
            c = te[ 2 ],
            d = te[ 3 ],
            e = te[ 4 ],
            f = te[ 5 ],
            g = te[ 6 ],
            h = te[ 7 ],
            i = te[ 8 ];

        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    },

    getInverse: function( matrix, throwOnInvertible ) {

        // input: THREE.Matrix4
        // ( based on http://code.google.com/p/webgl-mjs/ )

        var me = matrix.elements;
        var te = this.elements;

        te[ 0 ] = me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
        te[ 1 ] = -me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
        te[ 2 ] = me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
        te[ 3 ] = -me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
        te[ 4 ] = me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
        te[ 5 ] = -me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
        te[ 6 ] = me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
        te[ 7 ] = -me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
        te[ 8 ] = me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

        // no inverse

        if ( det === 0 ) {

            var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            }
            else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1.0 / det );

        return this;

    },

    transpose: function() {

        var tmp, m = this.elements;

        tmp = m[ 1 ];
        m[ 1 ] = m[ 3 ];
        m[ 3 ] = tmp;
        tmp = m[ 2 ];
        m[ 2 ] = m[ 6 ];
        m[ 6 ] = tmp;
        tmp = m[ 5 ];
        m[ 5 ] = m[ 7 ];
        m[ 7 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ] = te[ 8 ];

        return array;

    },

    getNormalMatrix: function( m ) {

        // input: THREE.Matrix4

        this.getInverse( m ).transpose();

        return this;

    },

    transposeIntoArray: function( r ) {

        var m = this.elements;

        r[ 0 ] = m[ 0 ];
        r[ 1 ] = m[ 3 ];
        r[ 2 ] = m[ 6 ];
        r[ 3 ] = m[ 1 ];
        r[ 4 ] = m[ 4 ];
        r[ 5 ] = m[ 7 ];
        r[ 6 ] = m[ 2 ];
        r[ 7 ] = m[ 5 ];
        r[ 8 ] = m[ 8 ];

        return this;

    },

    fromArray: function( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function() {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ],
            te[ 3 ], te[ 4 ], te[ 5 ],
            te[ 6 ], te[ 7 ], te[ 8 ]
        ];

    }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function() {

    this.elements = new Float32Array( [

        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix4.prototype = {

    constructor: THREE.Matrix4,

    set: function( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

        var te = this.elements;

        te[ 0 ] = n11;
        te[ 4 ] = n12;
        te[ 8 ] = n13;
        te[ 12 ] = n14;
        te[ 1 ] = n21;
        te[ 5 ] = n22;
        te[ 9 ] = n23;
        te[ 13 ] = n24;
        te[ 2 ] = n31;
        te[ 6 ] = n32;
        te[ 10 ] = n33;
        te[ 14 ] = n34;
        te[ 3 ] = n41;
        te[ 7 ] = n42;
        te[ 11 ] = n43;
        te[ 15 ] = n44;

        return this;

    },

    identity: function() {

        this.set(

            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    clone: function() {

        return new THREE.Matrix4().fromArray( this.elements );

    },

    copy: function( m ) {

        this.elements.set( m.elements );

        return this;

    },

    extractPosition: function( m ) {

        console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
        return this.copyPosition( m );

    },

    copyPosition: function( m ) {

        var te = this.elements;
        var me = m.elements;

        te[ 12 ] = me[ 12 ];
        te[ 13 ] = me[ 13 ];
        te[ 14 ] = me[ 14 ];

        return this;

    },

    extractBasis: function( xAxis, yAxis, zAxis ) {

        var te = this.elements;

        xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
        yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
        zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

        return this;

    },

    makeBasis: function( xAxis, yAxis, zAxis ) {

        this.set(
            xAxis.x, yAxis.x, zAxis.x, 0,
            xAxis.y, yAxis.y, zAxis.y, 0,
            xAxis.z, yAxis.z, zAxis.z, 0,
            0, 0, 0, 1
        );

        return this;

    },

    extractRotation: function() {

        var v1;

        return function( m ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            var te = this.elements;
            var me = m.elements;

            var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
            var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
            var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

            te[ 0 ] = me[ 0 ] * scaleX;
            te[ 1 ] = me[ 1 ] * scaleX;
            te[ 2 ] = me[ 2 ] * scaleX;

            te[ 4 ] = me[ 4 ] * scaleY;
            te[ 5 ] = me[ 5 ] * scaleY;
            te[ 6 ] = me[ 6 ] * scaleY;

            te[ 8 ] = me[ 8 ] * scaleZ;
            te[ 9 ] = me[ 9 ] * scaleZ;
            te[ 10 ] = me[ 10 ] * scaleZ;

            return this;

        };

    }(),

    makeRotationFromEuler: function( euler ) {

        if ( euler instanceof THREE.Euler === false ) {

            console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        var te = this.elements;

        var x = euler.x,
            y = euler.y,
            z = euler.z;
        var a = Math.cos( x ),
            b = Math.sin( x );
        var c = Math.cos( y ),
            d = Math.sin( y );
        var e = Math.cos( z ),
            f = Math.sin( z );

        if ( euler.order === 'XYZ' ) {

            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = -c * f;
            te[ 8 ] = d;

            te[ 1 ] = af + be * d;
            te[ 5 ] = ae - bf * d;
            te[ 9 ] = -b * c;

            te[ 2 ] = bf - ae * d;
            te[ 6 ] = be + af * d;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'YXZ' ) {

            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;

            te[ 0 ] = ce + df * b;
            te[ 4 ] = de * b - cf;
            te[ 8 ] = a * d;

            te[ 1 ] = a * f;
            te[ 5 ] = a * e;
            te[ 9 ] = -b;

            te[ 2 ] = cf * b - de;
            te[ 6 ] = df + ce * b;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'ZXY' ) {

            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;

            te[ 0 ] = ce - df * b;
            te[ 4 ] = -a * f;
            te[ 8 ] = de + cf * b;

            te[ 1 ] = cf + de * b;
            te[ 5 ] = a * e;
            te[ 9 ] = df - ce * b;

            te[ 2 ] = -a * d;
            te[ 6 ] = b;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'ZYX' ) {

            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = be * d - af;
            te[ 8 ] = ae * d + bf;

            te[ 1 ] = c * f;
            te[ 5 ] = bf * d + ae;
            te[ 9 ] = af * d - be;

            te[ 2 ] = -d;
            te[ 6 ] = b * c;
            te[ 10 ] = a * c;

        }
        else if ( euler.order === 'YZX' ) {

            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = bd - ac * f;
            te[ 8 ] = bc * f + ad;

            te[ 1 ] = f;
            te[ 5 ] = a * e;
            te[ 9 ] = -b * e;

            te[ 2 ] = -d * e;
            te[ 6 ] = ad * f + bc;
            te[ 10 ] = ac - bd * f;

        }
        else if ( euler.order === 'XZY' ) {

            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = -f;
            te[ 8 ] = d * e;

            te[ 1 ] = ac * f + bd;
            te[ 5 ] = a * e;
            te[ 9 ] = ad * f - bc;

            te[ 2 ] = bc * f - ad;
            te[ 6 ] = b * e;
            te[ 10 ] = bd * f + ac;

        }

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    setRotationFromQuaternion: function( q ) {

        console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

        return this.makeRotationFromQuaternion( q );

    },

    makeRotationFromQuaternion: function( q ) {

        var te = this.elements;

        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        te[ 0 ] = 1 - ( yy + zz );
        te[ 4 ] = xy - wz;
        te[ 8 ] = xz + wy;

        te[ 1 ] = xy + wz;
        te[ 5 ] = 1 - ( xx + zz );
        te[ 9 ] = yz - wx;

        te[ 2 ] = xz - wy;
        te[ 6 ] = yz + wx;
        te[ 10 ] = 1 - ( xx + yy );

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    lookAt: function() {

        var x, y, z;

        return function( eye, target, up ) {

            if ( x === undefined ) x = new THREE.Vector3();
            if ( y === undefined ) y = new THREE.Vector3();
            if ( z === undefined ) z = new THREE.Vector3();

            var te = this.elements;

            z.subVectors( eye, target ).normalize();

            if ( z.length() === 0 ) {

                z.z = 1;

            }

            x.crossVectors( up, z ).normalize();

            if ( x.length() === 0 ) {

                z.x += 0.0001;
                x.crossVectors( up, z ).normalize();

            }

            y.crossVectors( z, x );


            te[ 0 ] = x.x;
            te[ 4 ] = y.x;
            te[ 8 ] = z.x;
            te[ 1 ] = x.y;
            te[ 5 ] = y.y;
            te[ 9 ] = z.y;
            te[ 2 ] = x.z;
            te[ 6 ] = y.z;
            te[ 10 ] = z.z;

            return this;

        };

    }(),

    multiply: function( m, n ) {

        if ( n !== undefined ) {

            console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
            return this.multiplyMatrices( m, n );

        }

        return this.multiplyMatrices( this, m );

    },

    multiplyMatrices: function( a, b ) {

        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;

        var a11 = ae[ 0 ],
            a12 = ae[ 4 ],
            a13 = ae[ 8 ],
            a14 = ae[ 12 ];
        var a21 = ae[ 1 ],
            a22 = ae[ 5 ],
            a23 = ae[ 9 ],
            a24 = ae[ 13 ];
        var a31 = ae[ 2 ],
            a32 = ae[ 6 ],
            a33 = ae[ 10 ],
            a34 = ae[ 14 ];
        var a41 = ae[ 3 ],
            a42 = ae[ 7 ],
            a43 = ae[ 11 ],
            a44 = ae[ 15 ];

        var b11 = be[ 0 ],
            b12 = be[ 4 ],
            b13 = be[ 8 ],
            b14 = be[ 12 ];
        var b21 = be[ 1 ],
            b22 = be[ 5 ],
            b23 = be[ 9 ],
            b24 = be[ 13 ];
        var b31 = be[ 2 ],
            b32 = be[ 6 ],
            b33 = be[ 10 ],
            b34 = be[ 14 ];
        var b41 = be[ 3 ],
            b42 = be[ 7 ],
            b43 = be[ 11 ],
            b44 = be[ 15 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

        te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

        return this;

    },

    multiplyToArray: function( a, b, r ) {

        var te = this.elements;

        this.multiplyMatrices( a, b );

        r[ 0 ] = te[ 0 ];
        r[ 1 ] = te[ 1 ];
        r[ 2 ] = te[ 2 ];
        r[ 3 ] = te[ 3 ];
        r[ 4 ] = te[ 4 ];
        r[ 5 ] = te[ 5 ];
        r[ 6 ] = te[ 6 ];
        r[ 7 ] = te[ 7 ];
        r[ 8 ] = te[ 8 ];
        r[ 9 ] = te[ 9 ];
        r[ 10 ] = te[ 10 ];
        r[ 11 ] = te[ 11 ];
        r[ 12 ] = te[ 12 ];
        r[ 13 ] = te[ 13 ];
        r[ 14 ] = te[ 14 ];
        r[ 15 ] = te[ 15 ];

        return this;

    },

    multiplyScalar: function( s ) {

        var te = this.elements;

        te[ 0 ] *= s;
        te[ 4 ] *= s;
        te[ 8 ] *= s;
        te[ 12 ] *= s;
        te[ 1 ] *= s;
        te[ 5 ] *= s;
        te[ 9 ] *= s;
        te[ 13 ] *= s;
        te[ 2 ] *= s;
        te[ 6 ] *= s;
        te[ 10 ] *= s;
        te[ 14 ] *= s;
        te[ 3 ] *= s;
        te[ 7 ] *= s;
        te[ 11 ] *= s;
        te[ 15 ] *= s;

        return this;

    },

    multiplyVector3: function( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
        return vector.applyProjection( this );

    },

    multiplyVector4: function( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    multiplyVector3Array: function( a ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function() {

        var v1;

        return function( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix4( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function() {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i++, j++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix4( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    rotateAxis: function( v ) {

        console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

        v.transformDirection( this );

    },

    crossVector: function( vector ) {

        console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    determinant: function() {

        var te = this.elements;

        var n11 = te[ 0 ],
            n12 = te[ 4 ],
            n13 = te[ 8 ],
            n14 = te[ 12 ];
        var n21 = te[ 1 ],
            n22 = te[ 5 ],
            n23 = te[ 9 ],
            n24 = te[ 13 ];
        var n31 = te[ 2 ],
            n32 = te[ 6 ],
            n33 = te[ 10 ],
            n34 = te[ 14 ];
        var n41 = te[ 3 ],
            n42 = te[ 7 ],
            n43 = te[ 11 ],
            n44 = te[ 15 ];

        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

        return (
            n41 * ( +n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34 ) +
            n42 * ( +n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31 ) +
            n43 * ( +n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31 ) +
            n44 * ( -n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31 )

        );

    },

    transpose: function() {

        var te = this.elements;
        var tmp;

        tmp = te[ 1 ];
        te[ 1 ] = te[ 4 ];
        te[ 4 ] = tmp;
        tmp = te[ 2 ];
        te[ 2 ] = te[ 8 ];
        te[ 8 ] = tmp;
        tmp = te[ 6 ];
        te[ 6 ] = te[ 9 ];
        te[ 9 ] = tmp;

        tmp = te[ 3 ];
        te[ 3 ] = te[ 12 ];
        te[ 12 ] = tmp;
        tmp = te[ 7 ];
        te[ 7 ] = te[ 13 ];
        te[ 13 ] = tmp;
        tmp = te[ 11 ];
        te[ 11 ] = te[ 14 ];
        te[ 14 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];
        array[ offset + 3 ] = te[ 3 ];

        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];
        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];

        array[ offset + 8 ] = te[ 8 ];
        array[ offset + 9 ] = te[ 9 ];
        array[ offset + 10 ] = te[ 10 ];
        array[ offset + 11 ] = te[ 11 ];

        array[ offset + 12 ] = te[ 12 ];
        array[ offset + 13 ] = te[ 13 ];
        array[ offset + 14 ] = te[ 14 ];
        array[ offset + 15 ] = te[ 15 ];

        return array;

    },

    getPosition: function() {

        var v1;

        return function() {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

            var te = this.elements;
            return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

        };

    }(),

    setPosition: function( v ) {

        var te = this.elements;

        te[ 12 ] = v.x;
        te[ 13 ] = v.y;
        te[ 14 ] = v.z;

        return this;

    },

    getInverse: function( m, throwOnInvertible ) {

        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements;
        var me = m.elements;

        var n11 = me[ 0 ],
            n12 = me[ 4 ],
            n13 = me[ 8 ],
            n14 = me[ 12 ];
        var n21 = me[ 1 ],
            n22 = me[ 5 ],
            n23 = me[ 9 ],
            n24 = me[ 13 ];
        var n31 = me[ 2 ],
            n32 = me[ 6 ],
            n33 = me[ 10 ],
            n34 = me[ 14 ];
        var n41 = me[ 3 ],
            n42 = me[ 7 ],
            n43 = me[ 11 ],
            n44 = me[ 15 ];

        te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

        var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

        if ( det === 0 ) {

            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            }
            else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1 / det );

        return this;

    },

    translate: function( v ) {

        console.error( 'THREE.Matrix4: .translate() has been removed.' );

    },

    rotateX: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

    },

    rotateY: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

    },

    rotateZ: function( angle ) {

        console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

    },

    rotateByAxis: function( axis, angle ) {

        console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

    },

    scale: function( v ) {

        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;

        te[ 0 ] *= x;
        te[ 4 ] *= y;
        te[ 8 ] *= z;
        te[ 1 ] *= x;
        te[ 5 ] *= y;
        te[ 9 ] *= z;
        te[ 2 ] *= x;
        te[ 6 ] *= y;
        te[ 10 ] *= z;
        te[ 3 ] *= x;
        te[ 7 ] *= y;
        te[ 11 ] *= z;

        return this;

    },

    getMaxScaleOnAxis: function() {

        var te = this.elements;

        var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
        var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
        var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

        return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

    },

    makeTranslation: function( x, y, z ) {

        this.set(

            1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationX: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            1, 0, 0, 0,
            0, c, -s, 0,
            0, s, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationY: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            c, 0, s, 0,
            0, 1, 0, 0, -s, 0, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationZ: function( theta ) {

        var c = Math.cos( theta ),
            s = Math.sin( theta );

        this.set(

            c, -s, 0, 0,
            s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationAxis: function( axis, angle ) {

        // Based on http://www.gamedev.net/reference/articles/article1199.asp

        var c = Math.cos( angle );
        var s = Math.sin( angle );
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;

        this.set(

            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeScale: function( x, y, z ) {

        this.set(

            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1

        );

        return this;

    },

    compose: function( position, quaternion, scale ) {

        this.makeRotationFromQuaternion( quaternion );
        this.scale( scale );
        this.setPosition( position );

        return this;

    },

    decompose: function() {

        var vector, matrix;

        return function( position, quaternion, scale ) {

            if ( vector === undefined ) vector = new THREE.Vector3();
            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            var te = this.elements;

            var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
            var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
            var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if ( det < 0 ) {

                sx = -sx;

            }

            position.x = te[ 12 ];
            position.y = te[ 13 ];
            position.z = te[ 14 ];

            // scale the rotation part

            matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;

            matrix.elements[ 0 ] *= invSX;
            matrix.elements[ 1 ] *= invSX;
            matrix.elements[ 2 ] *= invSX;

            matrix.elements[ 4 ] *= invSY;
            matrix.elements[ 5 ] *= invSY;
            matrix.elements[ 6 ] *= invSY;

            matrix.elements[ 8 ] *= invSZ;
            matrix.elements[ 9 ] *= invSZ;
            matrix.elements[ 10 ] *= invSZ;

            quaternion.setFromRotationMatrix( matrix );

            scale.x = sx;
            scale.y = sy;
            scale.z = sz;

            return this;

        };

    }(),

    makeFrustum: function( left, right, bottom, top, near, far ) {

        var te = this.elements;
        var x = 2 * near / ( right - left );
        var y = 2 * near / ( top - bottom );

        var a = ( right + left ) / ( right - left );
        var b = ( top + bottom ) / ( top - bottom );
        var c = -( far + near ) / ( far - near );
        var d = -2 * far * near / ( far - near );

        te[ 0 ] = x;
        te[ 4 ] = 0;
        te[ 8 ] = a;
        te[ 12 ] = 0;
        te[ 1 ] = 0;
        te[ 5 ] = y;
        te[ 9 ] = b;
        te[ 13 ] = 0;
        te[ 2 ] = 0;
        te[ 6 ] = 0;
        te[ 10 ] = c;
        te[ 14 ] = d;
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = -1;
        te[ 15 ] = 0;

        return this;

    },

    makePerspective: function( fov, aspect, near, far ) {

        var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;

        return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    },

    makeOrthographic: function( left, right, top, bottom, near, far ) {

        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;

        var x = ( right + left ) / w;
        var y = ( top + bottom ) / h;
        var z = ( far + near ) / p;

        te[ 0 ] = 2 / w;
        te[ 4 ] = 0;
        te[ 8 ] = 0;
        te[ 12 ] = -x;
        te[ 1 ] = 0;
        te[ 5 ] = 2 / h;
        te[ 9 ] = 0;
        te[ 13 ] = -y;
        te[ 2 ] = 0;
        te[ 6 ] = 0;
        te[ 10 ] = -2 / p;
        te[ 14 ] = -z;
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    equals: function( matrix ) {

        var te = this.elements;
        var me = matrix.elements;

        for ( var i = 0; i < 16; i++ ) {

            if ( te[ i ] !== me[ i ] ) return false;

        }

        return true;

    },

    fromArray: function( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function() {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
            te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
            te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
            te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
        ];

    }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function( origin, direction ) {

    this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
    this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

    constructor: THREE.Ray,

    set: function( origin, direction ) {

        this.origin.copy( origin );
        this.direction.copy( direction );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( ray ) {

        this.origin.copy( ray.origin );
        this.direction.copy( ray.direction );

        return this;

    },

    at: function( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    },

    recast: function() {

        var v1 = new THREE.Vector3();

        return function( t ) {

            this.origin.copy( this.at( t, v1 ) );

            return this;

        };

    }(),

    closestPointToPoint: function( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        result.subVectors( point, this.origin );
        var directionDistance = result.dot( this.direction );

        if ( directionDistance < 0 ) {

            return result.copy( this.origin );

        }

        return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    },

    distanceToPoint: function( point ) {

        return Math.sqrt( this.distanceSqToPoint( point ) );

    },

    distanceSqToPoint: function() {

        var v1 = new THREE.Vector3();

        return function( point ) {

            var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

            // point behind the ray

            if ( directionDistance < 0 ) {

                return this.origin.distanceToSquared( point );

            }

            v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

            return v1.distanceToSquared( point );

        };

    }(),

    distanceSqToSegment: function() {

        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();

        return function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

            // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment

            segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
            segDir.copy( v1 ).sub( v0 ).normalize();
            diff.copy( this.origin ).sub( segCenter );

            var segExtent = v0.distanceTo( v1 ) * 0.5;
            var a01 = -this.direction.dot( segDir );
            var b0 = diff.dot( this.direction );
            var b1 = -diff.dot( segDir );
            var c = diff.lengthSq();
            var det = Math.abs( 1 - a01 * a01 );
            var s0, s1, sqrDist, extDet;

            if ( det > 0 ) {

                // The ray and segment are not parallel.

                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;

                if ( s0 >= 0 ) {

                    if ( s1 >= -extDet ) {

                        if ( s1 <= extDet ) {

                            // region 0
                            // Minimum at interior points of ray and segment.

                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

                        }
                        else {

                            // region 1

                            s1 = segExtent;
                            s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                            sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                        }

                    }
                    else {

                        // region 5

                        s1 = -segExtent;
                        s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }
                else {

                    if ( s1 <= -extDet ) {

                        // region 4

                        s0 = Math.max( 0, -( -a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? -segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }
                    else if ( s1 <= extDet ) {

                        // region 3

                        s0 = 0;
                        s1 = Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = s1 * ( s1 + 2 * b1 ) + c;

                    }
                    else {

                        // region 2

                        s0 = Math.max( 0, -( a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                        sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }

            }
            else {

                // Ray and segment are parallel.

                s1 = ( a01 > 0 ) ? -segExtent : segExtent;
                s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

            if ( optionalPointOnRay ) {

                optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

            }

            if ( optionalPointOnSegment ) {

                optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

            }

            return sqrDist;

        };

    }(),


    isIntersectionSphere: function( sphere ) {

        return this.distanceToPoint( sphere.center ) <= sphere.radius;

    },

    intersectSphere: function() {

        // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

        var v1 = new THREE.Vector3();

        return function( sphere, optionalTarget ) {

            v1.subVectors( sphere.center, this.origin );

            var tca = v1.dot( this.direction );

            var d2 = v1.dot( v1 ) - tca * tca;

            var radius2 = sphere.radius * sphere.radius;

            if ( d2 > radius2 ) return null;

            var thc = Math.sqrt( radius2 - d2 );

            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;

            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;

            // test to see if both t0 and t1 are behind the ray - if so, return null
            if ( t0 < 0 && t1 < 0 ) return null;

            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if ( t0 < 0 ) return this.at( t1, optionalTarget );

            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at( t0, optionalTarget );

        }

    }(),

    isIntersectionPlane: function( plane ) {

        // check if the ray lies on the plane first

        var distToPoint = plane.distanceToPoint( this.origin );

        if ( distToPoint === 0 ) {

            return true;

        }

        var denominator = plane.normal.dot( this.direction );

        if ( denominator * distToPoint < 0 ) {

            return true;

        }

        // ray origin is behind the plane (and is pointing behind it)

        return false;

    },

    distanceToPlane: function( plane ) {

        var denominator = plane.normal.dot( this.direction );
        if ( denominator === 0 ) {

            // line is coplanar, return origin
            if ( plane.distanceToPoint( this.origin ) === 0 ) {

                return 0;

            }

            // Null is preferable to undefined since undefined means.... it is undefined

            return null;

        }

        var t = -( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

        // Return if the ray never intersects the plane

        return t >= 0 ? t : null;

    },

    intersectPlane: function( plane, optionalTarget ) {

        var t = this.distanceToPlane( plane );

        if ( t === null ) {

            return null;

        }

        return this.at( t, optionalTarget );

    },

    isIntersectionBox: function() {

        var v = new THREE.Vector3();

        return function( box ) {

            return this.intersectBox( box, v ) !== null;

        };

    }(),

    intersectBox: function( box, optionalTarget ) {

        // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

        var tmin, tmax, tymin, tymax, tzmin, tzmax;

        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;

        var origin = this.origin;

        if ( invdirx >= 0 ) {

            tmin = ( box.min.x - origin.x ) * invdirx;
            tmax = ( box.max.x - origin.x ) * invdirx;

        }
        else {

            tmin = ( box.max.x - origin.x ) * invdirx;
            tmax = ( box.min.x - origin.x ) * invdirx;

        }

        if ( invdiry >= 0 ) {

            tymin = ( box.min.y - origin.y ) * invdiry;
            tymax = ( box.max.y - origin.y ) * invdiry;

        }
        else {

            tymin = ( box.max.y - origin.y ) * invdiry;
            tymax = ( box.min.y - origin.y ) * invdiry;

        }

        if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

        if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

        if ( invdirz >= 0 ) {

            tzmin = ( box.min.z - origin.z ) * invdirz;
            tzmax = ( box.max.z - origin.z ) * invdirz;

        }
        else {

            tzmin = ( box.max.z - origin.z ) * invdirz;
            tzmax = ( box.min.z - origin.z ) * invdirz;

        }

        if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

        if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

        if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

        //return point closest to the ray (positive side)

        if ( tmax < 0 ) return null;

        return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    },

    intersectTriangle: function() {

        // Compute the offset origin, edges, and normal.
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();

        return function( a, b, c, backfaceCulling, optionalTarget ) {

            // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

            edge1.subVectors( b, a );
            edge2.subVectors( c, a );
            normal.crossVectors( edge1, edge2 );

            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot( normal );
            var sign;

            if ( DdN > 0 ) {

                if ( backfaceCulling ) return null;
                sign = 1;

            }
            else if ( DdN < 0 ) {

                sign = -1;
                DdN = -DdN;

            }
            else {

                return null;

            }

            diff.subVectors( this.origin, a );
            var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

            // b1 < 0, no intersection
            if ( DdQxE2 < 0 ) {

                return null;

            }

            var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

            // b2 < 0, no intersection
            if ( DdE1xQ < 0 ) {

                return null;

            }

            // b1+b2 > 1, no intersection
            if ( DdQxE2 + DdE1xQ > DdN ) {

                return null;

            }

            // Line intersects triangle, check if ray does.
            var QdN = -sign * diff.dot( normal );

            // t < 0, no intersection
            if ( QdN < 0 ) {

                return null;

            }

            // Ray intersects triangle.
            return this.at( QdN / DdN, optionalTarget );

        };

    }(),

    applyMatrix4: function( matrix4 ) {

        this.direction.add( this.origin ).applyMatrix4( matrix4 );
        this.origin.applyMatrix4( matrix4 );
        this.direction.sub( this.origin );
        this.direction.normalize();

        return this;

    },

    equals: function( ray ) {

        return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function( center, radius ) {

    this.center = ( center !== undefined ) ? center : new THREE.Vector3();
    this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

    constructor: THREE.Sphere,

    set: function( center, radius ) {

        this.center.copy( center );
        this.radius = radius;

        return this;

    },

    setFromPoints: function() {

        var box = new THREE.Box3();

        return function( points, optionalCenter ) {

            var center = this.center;

            if ( optionalCenter !== undefined ) {

                center.copy( optionalCenter );

            }
            else {

                box.setFromPoints( points ).center( center );

            }

            var maxRadiusSq = 0;

            for ( var i = 0, il = points.length; i < il; i++ ) {

                maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

            }

            this.radius = Math.sqrt( maxRadiusSq );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( sphere ) {

        this.center.copy( sphere.center );
        this.radius = sphere.radius;

        return this;

    },

    empty: function() {

        return ( this.radius <= 0 );

    },

    containsPoint: function( point ) {

        return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    },

    distanceToPoint: function( point ) {

        return ( point.distanceTo( this.center ) - this.radius );

    },

    intersectsSphere: function( sphere ) {

        var radiusSum = this.radius + sphere.radius;

        return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    },

    clampPoint: function( point, optionalTarget ) {

        var deltaLengthSq = this.center.distanceToSquared( point );

        var result = optionalTarget || new THREE.Vector3();
        result.copy( point );

        if ( deltaLengthSq > ( this.radius * this.radius ) ) {

            result.sub( this.center ).normalize();
            result.multiplyScalar( this.radius ).add( this.center );

        }

        return result;

    },

    getBoundingBox: function( optionalTarget ) {

        var box = optionalTarget || new THREE.Box3();

        box.set( this.center, this.center );
        box.expandByScalar( this.radius );

        return box;

    },

    applyMatrix4: function( matrix ) {

        this.center.applyMatrix4( matrix );
        this.radius = this.radius * matrix.getMaxScaleOnAxis();

        return this;

    },

    translate: function( offset ) {

        this.center.add( offset );

        return this;

    },

    equals: function( sphere ) {

        return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function( p0, p1, p2, p3, p4, p5 ) {

    this.planes = [

        ( p0 !== undefined ) ? p0 : new THREE.Plane(), ( p1 !== undefined ) ? p1 : new THREE.Plane(), ( p2 !== undefined ) ? p2 : new THREE.Plane(), ( p3 !== undefined ) ? p3 : new THREE.Plane(), ( p4 !== undefined ) ? p4 : new THREE.Plane(), ( p5 !== undefined ) ? p5 : new THREE.Plane()

    ];

};

THREE.Frustum.prototype = {

    constructor: THREE.Frustum,

    set: function( p0, p1, p2, p3, p4, p5 ) {

        var planes = this.planes;

        planes[ 0 ].copy( p0 );
        planes[ 1 ].copy( p1 );
        planes[ 2 ].copy( p2 );
        planes[ 3 ].copy( p3 );
        planes[ 4 ].copy( p4 );
        planes[ 5 ].copy( p5 );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( frustum ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i++ ) {

            planes[ i ].copy( frustum.planes[ i ] );

        }

        return this;

    },

    setFromMatrix: function( m ) {

        var planes = this.planes;
        var me = m.elements;
        var me0 = me[ 0 ],
            me1 = me[ 1 ],
            me2 = me[ 2 ],
            me3 = me[ 3 ];
        var me4 = me[ 4 ],
            me5 = me[ 5 ],
            me6 = me[ 6 ],
            me7 = me[ 7 ];
        var me8 = me[ 8 ],
            me9 = me[ 9 ],
            me10 = me[ 10 ],
            me11 = me[ 11 ];
        var me12 = me[ 12 ],
            me13 = me[ 13 ],
            me14 = me[ 14 ],
            me15 = me[ 15 ];

        planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
        planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
        planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
        planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
        planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
        planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

        return this;

    },

    intersectsObject: function() {

        var sphere = new THREE.Sphere();

        return function( object ) {

            var geometry = object.geometry;

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( object.matrixWorld );

            return this.intersectsSphere( sphere );

        };

    }(),

    intersectsSphere: function( sphere ) {

        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;

        for ( var i = 0; i < 6; i++ ) {

            var distance = planes[ i ].distanceToPoint( center );

            if ( distance < negRadius ) {

                return false;

            }

        }

        return true;

    },

    intersectsBox: function() {

        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();

        return function( box ) {

            var planes = this.planes;

            for ( var i = 0; i < 6; i++ ) {

                var plane = planes[ i ];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint( p1 );
                var d2 = plane.distanceToPoint( p2 );

                // if both outside plane, no intersection

                if ( d1 < 0 && d2 < 0 ) {

                    return false;

                }

            }

            return true;

        };

    }(),


    containsPoint: function( point ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i++ ) {

            if ( planes[ i ].distanceToPoint( point ) < 0 ) {

                return false;

            }

        }

        return true;

    }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function( normal, constant ) {

    this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
    this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

    constructor: THREE.Plane,

    set: function( normal, constant ) {

        this.normal.copy( normal );
        this.constant = constant;

        return this;

    },

    setComponents: function( x, y, z, w ) {

        this.normal.set( x, y, z );
        this.constant = w;

        return this;

    },

    setFromNormalAndCoplanarPoint: function( normal, point ) {

        this.normal.copy( normal );
        this.constant = -point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

        return this;

    },

    setFromCoplanarPoints: function() {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();

        return function( a, b, c ) {

            var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

            this.setFromNormalAndCoplanarPoint( normal, a );

            return this;

        };

    }(),

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( plane ) {

        this.normal.copy( plane.normal );
        this.constant = plane.constant;

        return this;

    },

    normalize: function() {

        // Note: will lead to a divide by zero if the plane is invalid.

        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar( inverseNormalLength );
        this.constant *= inverseNormalLength;

        return this;

    },

    negate: function() {

        this.constant *= -1;
        this.normal.negate();

        return this;

    },

    distanceToPoint: function( point ) {

        return this.normal.dot( point ) + this.constant;

    },

    distanceToSphere: function( sphere ) {

        return this.distanceToPoint( sphere.center ) - sphere.radius;

    },

    projectPoint: function( point, optionalTarget ) {

        return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    },

    orthoPoint: function( point, optionalTarget ) {

        var perpendicularMagnitude = this.distanceToPoint( point );

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    },

    isIntersectionLine: function( line ) {

        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

        var startSign = this.distanceToPoint( line.start );
        var endSign = this.distanceToPoint( line.end );

        return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    },

    intersectLine: function() {

        var v1 = new THREE.Vector3();

        return function( line, optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            var direction = line.delta( v1 );

            var denominator = this.normal.dot( direction );

            if ( denominator === 0 ) {

                // line is coplanar, return origin
                if ( this.distanceToPoint( line.start ) === 0 ) {

                    return result.copy( line.start );

                }

                // Unsure if this is the correct method to handle this case.
                return undefined;

            }

            var t = -( line.start.dot( this.normal ) + this.constant ) / denominator;

            if ( t < 0 || t > 1 ) {

                return undefined;

            }

            return result.copy( direction ).multiplyScalar( t ).add( line.start );

        };

    }(),


    coplanarPoint: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( -this.constant );

    },

    applyMatrix4: function() {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();

        return function( matrix, optionalNormalMatrix ) {

            // compute new normal based on theory here:
            // http://www.songho.ca/opengl/gl_normaltransform.html
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
            var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

            var newCoplanarPoint = this.coplanarPoint( v2 );
            newCoplanarPoint.applyMatrix4( matrix );

            this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

            return this;

        };

    }(),

    translate: function( offset ) {

        this.constant = this.constant - offset.dot( this.normal );

        return this;

    },

    equals: function( plane ) {

        return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

    generateUUID: function() {

        // http://www.broofa.com/Tools/Math.uuid.htm

        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
        var uuid = new Array( 36 );
        var rnd = 0,
            r;

        return function() {

            for ( var i = 0; i < 36; i++ ) {

                if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

                    uuid[ i ] = '-';

                }
                else if ( i === 14 ) {

                    uuid[ i ] = '4';

                }
                else {

                    if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

                }

            }

            return uuid.join( '' );

        };

    }(),

    // Clamp value to range <a, b>

    clamp: function( x, a, b ) {

        return ( x < a ) ? a : ( ( x > b ) ? b : x );

    },

    // Clamp value to range <a, inf)

    clampBottom: function( x, a ) {

        return x < a ? a : x;

    },

    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation

    euclideanModulo: function( n, m ) {

        return ( ( n % m ) + m ) % m;

    },

    // Linear mapping from range <a1, a2> to range <b1, b2>

    mapLinear: function( x, a1, a2, b1, b2 ) {

        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    },

    // http://en.wikipedia.org/wiki/Smoothstep

    smoothstep: function( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * ( 3 - 2 * x );

    },

    smootherstep: function( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    },

    // Random float from <0, 1> with 16 bits of randomness
    // (standard Math.random() creates repetitive patterns when applied over larger space)

    random16: function() {

        return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

    },

    // Random integer from <low, high> interval

    randInt: function( low, high ) {

        return low + Math.floor( Math.random() * ( high - low + 1 ) );

    },

    // Random float from <low, high> interval

    randFloat: function( low, high ) {

        return low + Math.random() * ( high - low );

    },

    // Random float from <-range/2, range/2> interval

    randFloatSpread: function( range ) {

        return range * ( 0.5 - Math.random() );

    },

    degToRad: function() {

        var degreeToRadiansFactor = Math.PI / 180;

        return function( degrees ) {

            return degrees * degreeToRadiansFactor;

        };

    }(),

    radToDeg: function() {

        var radianToDegreesFactor = 180 / Math.PI;

        return function( radians ) {

            return radians * radianToDegreesFactor;

        };

    }(),

    isPowerOfTwo: function( value ) {

        return ( value & ( value - 1 ) ) === 0 && value !== 0;

    },

    nextPowerOfTwo: function( value ) {

        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;

        return value;

    }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function( points ) {

    this.points = points;

    var c = [],
        v3 = {
            x: 0,
            y: 0,
            z: 0
        },
        point, intPoint, weight, w2, w3,
        pa, pb, pc, pd;

    this.initFromArray = function( a ) {

        this.points = [];

        for ( var i = 0; i < a.length; i++ ) {

            this.points[ i ] = {
                x: a[ i ][ 0 ],
                y: a[ i ][ 1 ],
                z: a[ i ][ 2 ]
            };

        }

    };

    this.getPoint = function( k ) {

        point = ( this.points.length - 1 ) * k;
        intPoint = Math.floor( point );
        weight = point - intPoint;

        c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
        c[ 1 ] = intPoint;
        c[ 2 ] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[ 3 ] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

        pa = this.points[ c[ 0 ] ];
        pb = this.points[ c[ 1 ] ];
        pc = this.points[ c[ 2 ] ];
        pd = this.points[ c[ 3 ] ];

        w2 = weight * weight;
        w3 = weight * w2;

        v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
        v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
        v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

        return v3;

    };

    this.getControlPointsArray = function() {

        var i, p, l = this.points.length,
            coords = [];

        for ( i = 0; i < l; i++ ) {

            p = this.points[ i ];
            coords[ i ] = [ p.x, p.y, p.z ];

        }

        return coords;

    };

    // approximate length by summing linear segments

    this.getLength = function( nSubDivisions ) {

        var i, index, nSamples, position,
            point = 0,
            intPoint = 0,
            oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;

        // first point has 0 length

        chunkLengths[ 0 ] = 0;

        if ( !nSubDivisions ) nSubDivisions = 100;

        nSamples = this.points.length * nSubDivisions;

        oldPosition.copy( this.points[ 0 ] );

        for ( i = 1; i < nSamples; i++ ) {

            index = i / nSamples;

            position = this.getPoint( index );
            tmpVec.copy( position );

            totalLength += tmpVec.distanceTo( oldPosition );

            oldPosition.copy( position );

            point = ( this.points.length - 1 ) * index;
            intPoint = Math.floor( point );

            if ( intPoint !== oldIntPoint ) {

                chunkLengths[ intPoint ] = totalLength;
                oldIntPoint = intPoint;

            }

        }

        // last point ends with total length

        chunkLengths[ chunkLengths.length ] = totalLength;

        return {
            chunks: chunkLengths,
            total: totalLength
        };

    };

    this.reparametrizeByArcLength = function( samplingCoef ) {

        var i, j,
            index, indexCurrent, indexNext,
            realDistance,
            sampling, position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();

        newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

        for ( i = 1; i < this.points.length; i++ ) {

            //tmpVec.copy( this.points[ i - 1 ] );
            //linearDistance = tmpVec.distanceTo( this.points[ i ] );

            realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

            sampling = Math.ceil( samplingCoef * realDistance / sl.total );

            indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
            indexNext = i / ( this.points.length - 1 );

            for ( j = 1; j < sampling - 1; j++ ) {

                index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

                position = this.getPoint( index );
                newpoints.push( tmpVec.copy( position ).clone() );

            }

            newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

        }

        this.points = newpoints;

    };

    // Catmull-Rom

    function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

        var v0 = ( p2 - p0 ) * 0.5,
            v1 = ( p3 - p1 ) * 0.5;

        return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( -3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function( a, b, c ) {

    this.a = ( a !== undefined ) ? a : new THREE.Vector3();
    this.b = ( b !== undefined ) ? b : new THREE.Vector3();
    this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

    var v0 = new THREE.Vector3();

    return function( a, b, c, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        result.subVectors( c, b );
        v0.subVectors( a, b );
        result.cross( v0 );

        var resultLengthSq = result.lengthSq();
        if ( resultLengthSq > 0 ) {

            return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

        }

        return result.set( 0, 0, 0 );

    };

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function( point, a, b, c, optionalTarget ) {

        v0.subVectors( c, a );
        v1.subVectors( b, a );
        v2.subVectors( point, a );

        var dot00 = v0.dot( v0 );
        var dot01 = v0.dot( v1 );
        var dot02 = v0.dot( v2 );
        var dot11 = v1.dot( v1 );
        var dot12 = v1.dot( v2 );

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        var result = optionalTarget || new THREE.Vector3();

        // collinear or singular triangle
        if ( denom === 0 ) {

            // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return result.set( -2, -1, -1 );

        }

        var invDenom = 1 / denom;
        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        // barycentric coordinates must always sum to 1
        return result.set( 1 - u - v, v, u );

    };

}();

THREE.Triangle.containsPoint = function() {

    var v1 = new THREE.Vector3();

    return function( point, a, b, c ) {

        var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

        return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    };

}();

THREE.Triangle.prototype = {

    constructor: THREE.Triangle,

    set: function( a, b, c ) {

        this.a.copy( a );
        this.b.copy( b );
        this.c.copy( c );

        return this;

    },

    setFromPointsAndIndices: function( points, i0, i1, i2 ) {

        this.a.copy( points[ i0 ] );
        this.b.copy( points[ i1 ] );
        this.c.copy( points[ i2 ] );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( triangle ) {

        this.a.copy( triangle.a );
        this.b.copy( triangle.b );
        this.c.copy( triangle.c );

        return this;

    },

    area: function() {

        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();

        return function() {

            v0.subVectors( this.c, this.b );
            v1.subVectors( this.a, this.b );

            return v0.cross( v1 ).length() * 0.5;

        };

    }(),

    midpoint: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    },

    normal: function( optionalTarget ) {

        return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

    },

    plane: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Plane();

        return result.setFromCoplanarPoints( this.a, this.b, this.c );

    },

    barycoordFromPoint: function( point, optionalTarget ) {

        return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    },

    containsPoint: function( point ) {

        return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

    },

    equals: function( triangle ) {

        return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function( autoStart ) {

    this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;

    this.running = false;

};

THREE.Clock.prototype = {

    constructor: THREE.Clock,

    start: function() {

        this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();

        this.oldTime = this.startTime;
        this.running = true;

    },

    stop: function() {

        this.getElapsedTime();
        this.running = false;

    },

    getElapsedTime: function() {

        this.getDelta();
        return this.elapsedTime;

    },

    getDelta: function() {

        var diff = 0;

        if ( this.autoStart && !this.running ) {

            this.start();

        }

        if ( this.running ) {

            var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();

            diff = 0.001 * ( newTime - this.oldTime );
            this.oldTime = newTime;

            this.elapsedTime += diff;

        }

        return diff;

    }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function() {};

THREE.EventDispatcher.prototype = {

    constructor: THREE.EventDispatcher,

    apply: function( object ) {

        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

    },

    addEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) this._listeners = {};

        var listeners = this._listeners;

        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === -1 ) {

            listeners[ type ].push( listener );

        }

    },

    hasEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) return false;

        var listeners = this._listeners;

        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1 ) {

            return true;

        }

        return false;

    },

    removeEventListener: function( type, listener ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ type ];

        if ( listenerArray !== undefined ) {

            var index = listenerArray.indexOf( listener );

            if ( index !== -1 ) {

                listenerArray.splice( index, 1 );

            }

        }

    },

    dispatchEvent: function( event ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];

        if ( listenerArray !== undefined ) {

            event.target = this;

            var array = [];
            var length = listenerArray.length;

            for ( var i = 0; i < length; i++ ) {

                array[ i ] = listenerArray[ i ];

            }

            for ( var i = 0; i < length; i++ ) {

                array[ i ].call( this, event );

            }

        }

    }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function( THREE ) {

    THREE.Raycaster = function( origin, direction, near, far ) {

        this.ray = new THREE.Ray( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)

        this.near = near || 0;
        this.far = far || Infinity;

        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };

        Object.defineProperties( this.params, {
            PointCloud: {
                get: function() {
                    console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
                    return this.Points;
                }
            }
        } );

    };

    function descSort( a, b ) {

        return a.distance - b.distance;

    }

    var intersectObject = function( object, raycaster, intersects, recursive ) {

        if ( object.visible === false ) return;

        object.raycast( raycaster, intersects );

        if ( recursive === true ) {

            var children = object.children;

            for ( var i = 0, l = children.length; i < l; i++ ) {

                intersectObject( children[ i ], raycaster, intersects, true );

            }

        }

    };

    //

    THREE.Raycaster.prototype = {

        constructor: THREE.Raycaster,

        linePrecision: 1,

        set: function( origin, direction ) {

            // direction is assumed to be normalized (for accurate distance calculations)

            this.ray.set( origin, direction );

        },

        setFromCamera: function( coords, camera ) {

            if ( camera instanceof THREE.PerspectiveCamera ) {

                this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
                this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

            }
            else if ( camera instanceof THREE.OrthographicCamera ) {

                this.ray.origin.set( coords.x, coords.y, -1 ).unproject( camera );
                this.ray.direction.set( 0, 0, -1 ).transformDirection( camera.matrixWorld );

            }
            else {

                console.error( 'THREE.Raycaster: Unsupported camera type.' );

            }

        },

        intersectObject: function( object, recursive ) {

            var intersects = [];

            intersectObject( object, this, intersects, recursive );

            intersects.sort( descSort );

            return intersects;

        },

        intersectObjects: function( objects, recursive ) {

            var intersects = [];

            if ( Array.isArray( objects ) === false ) {

                console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
                return intersects;

            }

            for ( var i = 0, l = objects.length; i < l; i++ ) {

                intersectObject( objects[ i ], this, intersects, recursive );

            }

            intersects.sort( descSort );

            return intersects;

        }

    };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.Object3DIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Object3D';

    this.parent = null;
    this.children = [];

    this.up = THREE.Object3D.DefaultUp.clone();

    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3( 1, 1, 1 );

    var onRotationChange = function() {

        quaternion.setFromEuler( rotation, false );

    };

    var onQuaternionChange = function() {

        rotation.setFromQuaternion( quaternion, undefined, false );

    };

    rotation.onChange( onRotationChange );
    quaternion.onChange( onQuaternionChange );

    Object.defineProperties( this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new THREE.Matrix4()
        },
        normalMatrix: {
            value: new THREE.Matrix3()
        }
    } );

    this.rotationAutoUpdate = true;

    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();

    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;

    this.visible = true;

    this.castShadow = false;
    this.receiveShadow = false;

    this.frustumCulled = true;
    this.renderOrder = 0;

    this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

    constructor: THREE.Object3D,

    get eulerOrder() {

        console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

        return this.rotation.order;

    },

    set eulerOrder( value ) {

        console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

        this.rotation.order = value;

    },

    get useQuaternion() {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set useQuaternion( value ) {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set renderDepth( value ) {

        console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

    },

    applyMatrix: function( matrix ) {

        this.matrix.multiplyMatrices( matrix, this.matrix );

        this.matrix.decompose( this.position, this.quaternion, this.scale );

    },

    setRotationFromAxisAngle: function( axis, angle ) {

        // assumes axis is normalized

        this.quaternion.setFromAxisAngle( axis, angle );

    },

    setRotationFromEuler: function( euler ) {

        this.quaternion.setFromEuler( euler, true );

    },

    setRotationFromMatrix: function( m ) {

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        this.quaternion.setFromRotationMatrix( m );

    },

    setRotationFromQuaternion: function( q ) {

        // assumes q is normalized

        this.quaternion.copy( q );

    },

    rotateOnAxis: function() {

        // rotate object on axis in object space
        // axis is assumed to be normalized

        var q1 = new THREE.Quaternion();

        return function( axis, angle ) {

            q1.setFromAxisAngle( axis, angle );

            this.quaternion.multiply( q1 );

            return this;

        };

    }(),

    rotateX: function() {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateY: function() {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateZ: function() {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    translateOnAxis: function() {

        // translate object by distance along axis in object space
        // axis is assumed to be normalized

        var v1 = new THREE.Vector3();

        return function( axis, distance ) {

            v1.copy( axis ).applyQuaternion( this.quaternion );

            this.position.add( v1.multiplyScalar( distance ) );

            return this;

        };

    }(),

    translate: function( distance, axis ) {

        console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
        return this.translateOnAxis( axis, distance );

    },

    translateX: function() {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateY: function() {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateZ: function() {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    localToWorld: function( vector ) {

        return vector.applyMatrix4( this.matrixWorld );

    },

    worldToLocal: function() {

        var m1 = new THREE.Matrix4();

        return function( vector ) {

            return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

        };

    }(),

    lookAt: function() {

        // This routine does not support objects with rotated and/or translated parent(s)

        var m1 = new THREE.Matrix4();

        return function( vector ) {

            m1.lookAt( vector, this.position, this.up );

            this.quaternion.setFromRotationMatrix( m1 );

        };

    }(),

    add: function( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i++ ) {

                this.add( arguments[ i ] );

            }

            return this;

        }

        if ( object === this ) {

            console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
            return this;

        }

        if ( object instanceof THREE.Object3D ) {

            if ( object.parent !== null ) {

                object.parent.remove( object );

            }

            object.parent = this;
            object.dispatchEvent( {
                type: 'added'
            } );

            this.children.push( object );

        }
        else {

            console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

        }

        return this;

    },

    remove: function( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i++ ) {

                this.remove( arguments[ i ] );

            }

        }

        var index = this.children.indexOf( object );

        if ( index !== -1 ) {

            object.parent = null;

            object.dispatchEvent( {
                type: 'removed'
            } );

            this.children.splice( index, 1 );

        }

    },

    getChildByName: function( name ) {

        console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
        return this.getObjectByName( name );

    },

    getObjectById: function( id ) {

        return this.getObjectByProperty( 'id', id );

    },

    getObjectByName: function( name ) {

        return this.getObjectByProperty( 'name', name );

    },

    getObjectByProperty: function( name, value ) {

        if ( this[ name ] === value ) return this;

        for ( var i = 0, l = this.children.length; i < l; i++ ) {

            var child = this.children[ i ];
            var object = child.getObjectByProperty( name, value );

            if ( object !== undefined ) {

                return object;

            }

        }

        return undefined;

    },

    getWorldPosition: function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.updateMatrixWorld( true );

        return result.setFromMatrixPosition( this.matrixWorld );

    },

    getWorldQuaternion: function() {

        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Quaternion();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, result, scale );

            return result;

        };

    }(),

    getWorldRotation: function() {

        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Euler();

            this.getWorldQuaternion( quaternion );

            return result.setFromQuaternion( quaternion, this.rotation.order, false );

        };

    }(),

    getWorldScale: function() {

        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, quaternion, result );

            return result;

        };

    }(),

    getWorldDirection: function() {

        var quaternion = new THREE.Quaternion();

        return function( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.getWorldQuaternion( quaternion );

            return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

        };

    }(),

    raycast: function() {},

    traverse: function( callback ) {

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            children[ i ].traverse( callback );

        }

    },

    traverseVisible: function( callback ) {

        if ( this.visible === false ) return;

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            children[ i ].traverseVisible( callback );

        }

    },

    traverseAncestors: function( callback ) {

        var parent = this.parent;

        if ( parent !== null ) {

            callback( parent );

            parent.traverseAncestors( callback );

        }

    },

    updateMatrix: function() {

        this.matrix.compose( this.position, this.quaternion, this.scale );

        this.matrixWorldNeedsUpdate = true;

    },

    updateMatrixWorld: function( force ) {

        if ( this.matrixAutoUpdate === true ) this.updateMatrix();

        if ( this.matrixWorldNeedsUpdate === true || force === true ) {

            if ( this.parent === null ) {

                this.matrixWorld.copy( this.matrix );

            }
            else {

                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

            }

            this.matrixWorldNeedsUpdate = false;

            force = true;

        }

        // update children

        for ( var i = 0, l = this.children.length; i < l; i++ ) {

            this.children[ i ].updateMatrixWorld( force );

        }

    },

    toJSON: function( meta ) {

        var isRootObject = ( meta === undefined );

        var data = {};

        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if ( isRootObject ) {

            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            };

            data.metadata = {
                version: 4.4,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };

        }

        // standard Object3D serialization

        data.uuid = this.uuid;
        data.type = this.type;

        if ( this.name !== '' ) data.name = this.name;
        if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
        if ( this.visible !== true ) data.visible = this.visible;

        data.matrix = this.matrix.toArray();

        if ( this.children.length > 0 ) {

            data.children = [];

            for ( var i = 0; i < this.children.length; i++ ) {

                data.children.push( this.children[ i ].toJSON( meta ).object );

            }

        }

        var output = {};

        if ( isRootObject ) {

            var geometries = extractFromCache( meta.geometries );
            var materials = extractFromCache( meta.materials );
            var textures = extractFromCache( meta.textures );
            var images = extractFromCache( meta.images );

            if ( geometries.length > 0 ) output.geometries = geometries;
            if ( materials.length > 0 ) output.materials = materials;
            if ( textures.length > 0 ) output.textures = textures;
            if ( images.length > 0 ) output.images = images;

        }

        output.object = data;

        return output;

        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache( cache ) {

            var values = [];
            for ( var key in cache ) {

                var data = cache[ key ];
                delete data.metadata;
                values.push( data );

            }
            return values;

        }

    },

    clone: function( recursive ) {

        return new this.constructor().copy( this, recursive );

    },

    copy: function( source, recursive ) {

        if ( recursive === undefined ) recursive = true;

        this.name = source.name;

        this.up.copy( source.up );

        this.position.copy( source.position );
        this.quaternion.copy( source.quaternion );
        this.scale.copy( source.scale );

        this.rotationAutoUpdate = source.rotationAutoUpdate;

        this.matrix.copy( source.matrix );
        this.matrixWorld.copy( source.matrixWorld );

        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

        this.visible = source.visible;

        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;

        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;

        this.userData = JSON.parse( JSON.stringify( source.userData ) );

        if ( recursive === true ) {

            for ( var i = 0; i < source.children.length; i++ ) {

                var child = source.children[ i ];
                this.add( child.clone() );

            }

        }

        return this;

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function( a, b, c, normal, color, materialIndex ) {

    this.a = a;
    this.b = b;
    this.c = c;

    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
    this.vertexNormals = Array.isArray( normal ) ? normal : [];

    this.color = color instanceof THREE.Color ? color : new THREE.Color();
    this.vertexColors = Array.isArray( color ) ? color : [];

    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

    constructor: THREE.Face3,

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.a = source.a;
        this.b = source.b;
        this.c = source.c;

        this.normal.copy( source.normal );
        this.color.copy( source.color );

        this.materialIndex = source.materialIndex;

        for ( var i = 0, il = source.vertexNormals.length; i < il; i++ ) {

            this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

        }

        for ( var i = 0, il = source.vertexColors.length; i < il; i++ ) {

            this.vertexColors[ i ] = source.vertexColors[ i ].clone();

        }

        return this;

    }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function( a, b, c, d, normal, color, materialIndex ) {

    console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function( array, itemSize ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.itemSize = itemSize;

    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };

    this.version = 0;

};

THREE.BufferAttribute.prototype = {

    constructor: THREE.BufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.array.length / this.itemSize;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    setDynamic: function( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function( source ) {

        this.array = new source.array.constructor( source.array );
        this.itemSize = source.itemSize;

        this.dynamic = source.dynamic;

        return this;

    },

    copyAt: function( index1, attribute, index2 ) {

        index1 *= this.itemSize;
        index2 *= attribute.itemSize;

        for ( var i = 0, l = this.itemSize; i < l; i++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    copyArray: function( array ) {

        this.array.set( array );

        return this;

    },

    copyColorsArray: function( colors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = colors.length; i < l; i++ ) {

            var color = colors[ i ];

            if ( color === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
                color = new THREE.Color();

            }

            array[ offset++ ] = color.r;
            array[ offset++ ] = color.g;
            array[ offset++ ] = color.b;

        }

        return this;

    },

    copyIndicesArray: function( indices ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = indices.length; i < l; i++ ) {

            var index = indices[ i ];

            array[ offset++ ] = index.a;
            array[ offset++ ] = index.b;
            array[ offset++ ] = index.c;

        }

        return this;

    },

    copyVector2sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
                vector = new THREE.Vector2();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;

        }

        return this;

    },

    copyVector3sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
                vector = new THREE.Vector3();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;
            array[ offset++ ] = vector.z;

        }

        return this;

    },

    copyVector4sArray: function( vectors ) {

        var array = this.array,
            offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
                vector = new THREE.Vector4();

            }

            array[ offset++ ] = vector.x;
            array[ offset++ ] = vector.y;
            array[ offset++ ] = vector.z;
            array[ offset++ ] = vector.w;

        }

        return this;

    },

    set: function( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    getX: function( index ) {

        return this.array[ index * this.itemSize ];

    },

    setX: function( index, x ) {

        this.array[ index * this.itemSize ] = x;

        return this;

    },

    getY: function( index ) {

        return this.array[ index * this.itemSize + 1 ];

    },

    setY: function( index, y ) {

        this.array[ index * this.itemSize + 1 ] = y;

        return this;

    },

    getZ: function( index ) {

        return this.array[ index * this.itemSize + 2 ];

    },

    setZ: function( index, z ) {

        this.array[ index * this.itemSize + 2 ] = z;

        return this;

    },

    getW: function( index ) {

        return this.array[ index * this.itemSize + 3 ];

    },

    setW: function( index, w ) {

        this.array[ index * this.itemSize + 3 ] = w;

        return this;

    },

    setXY: function( index, x, y ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function( index, x, y, z ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function( index, x, y, z, w ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;
        this.array[ index + 3 ] = w;

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    }

};

//

THREE.Int8Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function( array, itemSize ) {

    return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function( array, itemSize ) {

    console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function( array, itemSize, meshPerAttribute ) {

    THREE.BufferAttribute.call( this, array, itemSize );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function( source ) {

    THREE.BufferAttribute.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function( array, stride ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.stride = stride;

    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };

    this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

    constructor: THREE.InterleavedBuffer,

    get length() {

        return this.array.length;

    },

    get count() {

        return this.array.length / this.stride;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    setDynamic: function( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function( source ) {

        this.array = new source.array.constructor( source.array );
        this.stride = source.stride;
        this.dynamic = source.dynamic;

    },

    copyAt: function( index1, attribute, index2 ) {

        index1 *= this.stride;
        index2 *= attribute.stride;

        for ( var i = 0, l = this.stride; i < l; i++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    set: function( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    clone: function() {

        return new this.constructor().copy( this );

    }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function( array, stride, meshPerAttribute ) {

    THREE.InterleavedBuffer.call( this, array, stride );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function( source ) {

    THREE.InterleavedBuffer.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function( interleavedBuffer, itemSize, offset ) {

    this.uuid = THREE.Math.generateUUID();

    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

    constructor: THREE.InterleavedBufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.data.array.length / this.data.stride;

    },

    setX: function( index, x ) {

        this.data.array[ index * this.data.stride + this.offset ] = x;

        return this;

    },

    setY: function( index, y ) {

        this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

        return this;

    },

    setZ: function( index, z ) {

        this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

        return this;

    },

    setW: function( index, w ) {

        this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

        return this;

    },

    getX: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset ];

    },

    getY: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 1 ];

    },

    getZ: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 2 ];

    },

    getW: function( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 3 ];

    },

    setXY: function( index, x, y ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function( index, x, y, z ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function( index, x, y, z, w ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;
        this.data.array[ index + 3 ] = w;

        return this;

    }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Geometry';

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];

    this.morphTargets = [];
    this.morphColors = [];
    this.morphNormals = [];

    this.skinWeights = [];
    this.skinIndices = [];

    this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.elementsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

    constructor: THREE.Geometry,

    applyMatrix: function( matrix ) {

        var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        for ( var i = 0, il = this.vertices.length; i < il; i++ ) {

            var vertex = this.vertices[ i ];
            vertex.applyMatrix4( matrix );

        }

        for ( var i = 0, il = this.faces.length; i < il; i++ ) {

            var face = this.faces[ i ];
            face.normal.applyMatrix3( normalMatrix ).normalize();

            for ( var j = 0, jl = face.vertexNormals.length; j < jl; j++ ) {

                face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

            }

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;

    },

    rotateX: function() {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function() {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function() {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function() {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function() {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function() {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    fromBufferGeometry: function( geometry ) {

        var scope = this;

        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;

        var vertices = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

        if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];

        for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

            scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

            if ( normals !== undefined ) {

                tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

            }

            if ( colors !== undefined ) {

                scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

            }

            if ( uvs !== undefined ) {

                tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

            }

            if ( uvs2 !== undefined ) {

                tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

            }

        }

        var addFace = function( a, b, c ) {

            var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
            var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

            var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

            scope.faces.push( face );

            if ( uvs !== undefined ) {

                scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

            }

            if ( uvs2 !== undefined ) {

                scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

            }

        };

        if ( indices !== undefined ) {

            var groups = geometry.groups;

            if ( groups.length > 0 ) {

                for ( var i = 0; i < groups.length; i++ ) {

                    var group = groups[ i ];

                    var start = group.start;
                    var count = group.count;

                    for ( var j = start, jl = start + count; j < jl; j += 3 ) {

                        addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

                    }

                }

            }
            else {

                for ( var i = 0; i < indices.length; i += 3 ) {

                    addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                }

            }

        }
        else {

            for ( var i = 0; i < vertices.length / 3; i += 3 ) {

                addFace( i, i + 1, i + 2 );

            }

        }

        this.computeFaceNormals();

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        return this;

    },

    center: function() {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    normalize: function() {

        this.computeBoundingSphere();

        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;

        var s = radius === 0 ? 1 : 1.0 / radius;

        var matrix = new THREE.Matrix4();
        matrix.set(
            s, 0, 0, -s * center.x,
            0, s, 0, -s * center.y,
            0, 0, s, -s * center.z,
            0, 0, 0, 1
        );

        this.applyMatrix( matrix );

        return this;

    },

    computeFaceNormals: function() {

        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();

        for ( var f = 0, fl = this.faces.length; f < fl; f++ ) {

            var face = this.faces[ f ];

            var vA = this.vertices[ face.a ];
            var vB = this.vertices[ face.b ];
            var vC = this.vertices[ face.c ];

            cb.subVectors( vC, vB );
            ab.subVectors( vA, vB );
            cb.cross( ab );

            cb.normalize();

            face.normal.copy( cb );

        }

    },

    computeVertexNormals: function( areaWeighted ) {

        var v, vl, f, fl, face, vertices;

        vertices = new Array( this.vertices.length );

        for ( v = 0, vl = this.vertices.length; v < vl; v++ ) {

            vertices[ v ] = new THREE.Vector3();

        }

        if ( areaWeighted ) {

            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm

            var vA, vB, vC;
            var cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                vA = this.vertices[ face.a ];
                vB = this.vertices[ face.b ];
                vC = this.vertices[ face.c ];

                cb.subVectors( vC, vB );
                ab.subVectors( vA, vB );
                cb.cross( ab );

                vertices[ face.a ].add( cb );
                vertices[ face.b ].add( cb );
                vertices[ face.c ].add( cb );

            }

        }
        else {

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                vertices[ face.a ].add( face.normal );
                vertices[ face.b ].add( face.normal );
                vertices[ face.c ].add( face.normal );

            }

        }

        for ( v = 0, vl = this.vertices.length; v < vl; v++ ) {

            vertices[ v ].normalize();

        }

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                vertexNormals[ 0 ].copy( vertices[ face.a ] );
                vertexNormals[ 1 ].copy( vertices[ face.b ] );
                vertexNormals[ 2 ].copy( vertices[ face.c ] );

            }
            else {

                vertexNormals[ 0 ] = vertices[ face.a ].clone();
                vertexNormals[ 1 ] = vertices[ face.b ].clone();
                vertexNormals[ 2 ] = vertices[ face.c ].clone();

            }

        }

    },

    computeMorphNormals: function() {

        var i, il, f, fl, face;

        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            if ( !face.__originalFaceNormal ) {

                face.__originalFaceNormal = face.normal.clone();

            }
            else {

                face.__originalFaceNormal.copy( face.normal );

            }

            if ( !face.__originalVertexNormals ) face.__originalVertexNormals = [];

            for ( i = 0, il = face.vertexNormals.length; i < il; i++ ) {

                if ( !face.__originalVertexNormals[ i ] ) {

                    face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

                }
                else {

                    face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

                }

            }

        }

        // use temp geometry to compute face and vertex normals for each morph

        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;

        for ( i = 0, il = this.morphTargets.length; i < il; i++ ) {

            // create on first access

            if ( !this.morphNormals[ i ] ) {

                this.morphNormals[ i ] = {};
                this.morphNormals[ i ].faceNormals = [];
                this.morphNormals[ i ].vertexNormals = [];

                var dstNormalsFace = this.morphNormals[ i ].faceNormals;
                var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

                var faceNormal, vertexNormals;

                for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                    faceNormal = new THREE.Vector3();
                    vertexNormals = {
                        a: new THREE.Vector3(),
                        b: new THREE.Vector3(),
                        c: new THREE.Vector3()
                    };

                    dstNormalsFace.push( faceNormal );
                    dstNormalsVertex.push( vertexNormals );

                }

            }

            var morphNormals = this.morphNormals[ i ];

            // set vertices to morph target

            tmpGeo.vertices = this.morphTargets[ i ].vertices;

            // compute morph normals

            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();

            // store morph normals

            var faceNormal, vertexNormals;

            for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

                face = this.faces[ f ];

                faceNormal = morphNormals.faceNormals[ f ];
                vertexNormals = morphNormals.vertexNormals[ f ];

                faceNormal.copy( face.normal );

                vertexNormals.a.copy( face.vertexNormals[ 0 ] );
                vertexNormals.b.copy( face.vertexNormals[ 1 ] );
                vertexNormals.c.copy( face.vertexNormals[ 2 ] );

            }

        }

        // restore original normals

        for ( f = 0, fl = this.faces.length; f < fl; f++ ) {

            face = this.faces[ f ];

            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;

        }

    },

    computeTangents: function() {

        console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    },

    computeLineDistances: function() {

        var d = 0;
        var vertices = this.vertices;

        for ( var i = 0, il = vertices.length; i < il; i++ ) {

            if ( i > 0 ) {

                d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

            }

            this.lineDistances[ i ] = d;

        }

    },

    computeBoundingBox: function() {

        if ( this.boundingBox === null ) {

            this.boundingBox = new THREE.Box3();

        }

        this.boundingBox.setFromPoints( this.vertices );

    },

    computeBoundingSphere: function() {

        if ( this.boundingSphere === null ) {

            this.boundingSphere = new THREE.Sphere();

        }

        this.boundingSphere.setFromPoints( this.vertices );

    },

    merge: function( geometry, matrix, materialIndexOffset ) {

        if ( geometry instanceof THREE.Geometry === false ) {

            console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
            return;

        }

        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[ 0 ],
            uvs2 = geometry.faceVertexUvs[ 0 ];

        if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

        if ( matrix !== undefined ) {

            normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        }

        // vertices

        for ( var i = 0, il = vertices2.length; i < il; i++ ) {

            var vertex = vertices2[ i ];

            var vertexCopy = vertex.clone();

            if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

            vertices1.push( vertexCopy );

        }

        // faces

        for ( i = 0, il = faces2.length; i < il; i++ ) {

            var face = faces2[ i ],
                faceCopy, normal, color,
                faceVertexNormals = face.vertexNormals,
                faceVertexColors = face.vertexColors;

            faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
            faceCopy.normal.copy( face.normal );

            if ( normalMatrix !== undefined ) {

                faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

            }

            for ( var j = 0, jl = faceVertexNormals.length; j < jl; j++ ) {

                normal = faceVertexNormals[ j ].clone();

                if ( normalMatrix !== undefined ) {

                    normal.applyMatrix3( normalMatrix ).normalize();

                }

                faceCopy.vertexNormals.push( normal );

            }

            faceCopy.color.copy( face.color );

            for ( var j = 0, jl = faceVertexColors.length; j < jl; j++ ) {

                color = faceVertexColors[ j ];
                faceCopy.vertexColors.push( color.clone() );

            }

            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

            faces1.push( faceCopy );

        }

        // uvs

        for ( i = 0, il = uvs2.length; i < il; i++ ) {

            var uv = uvs2[ i ],
                uvCopy = [];

            if ( uv === undefined ) {

                continue;

            }

            for ( var j = 0, jl = uv.length; j < jl; j++ ) {

                uvCopy.push( uv[ j ].clone() );

            }

            uvs1.push( uvCopy );

        }

    },

    mergeMesh: function( mesh ) {

        if ( mesh instanceof THREE.Mesh === false ) {

            console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
            return;

        }

        mesh.matrixAutoUpdate && mesh.updateMatrix();

        this.merge( mesh.geometry, mesh.matrix );

    },

    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */

    mergeVertices: function() {

        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [],
            changes = [];

        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow( 10, precisionPoints );
        var i, il, face;
        var indices, j, jl;

        for ( i = 0, il = this.vertices.length; i < il; i++ ) {

            v = this.vertices[ i ];
            key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

            if ( verticesMap[ key ] === undefined ) {

                verticesMap[ key ] = i;
                unique.push( this.vertices[ i ] );
                changes[ i ] = unique.length - 1;

            }
            else {

                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                changes[ i ] = changes[ verticesMap[ key ] ];

            }

        }


        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];

        for ( i = 0, il = this.faces.length; i < il; i++ ) {

            face = this.faces[ i ];

            face.a = changes[ face.a ];
            face.b = changes[ face.b ];
            face.c = changes[ face.c ];

            indices = [ face.a, face.b, face.c ];

            var dupIndex = -1;

            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for ( var n = 0; n < 3; n++ ) {

                if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

                    dupIndex = n;
                    faceIndicesToRemove.push( i );
                    break;

                }

            }

        }

        for ( i = faceIndicesToRemove.length - 1; i >= 0; i-- ) {

            var idx = faceIndicesToRemove[ i ];

            this.faces.splice( idx, 1 );

            for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j++ ) {

                this.faceVertexUvs[ j ].splice( idx, 1 );

            }

        }

        // Use unique set of vertices

        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;

    },

    toJSON: function() {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };

        // standard Geometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        var vertices = [];

        for ( var i = 0; i < this.vertices.length; i++ ) {

            var vertex = this.vertices[ i ];
            vertices.push( vertex.x, vertex.y, vertex.z );

        }

        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};

        for ( var i = 0; i < this.faces.length; i++ ) {

            var face = this.faces[ i ];

            var hasMaterial = false; // face.materialIndex !== undefined;
            var hasFaceUv = false; // deprecated
            var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;

            var faceType = 0;

            faceType = setBit( faceType, 0, 0 );
            faceType = setBit( faceType, 1, hasMaterial );
            faceType = setBit( faceType, 2, hasFaceUv );
            faceType = setBit( faceType, 3, hasFaceVertexUv );
            faceType = setBit( faceType, 4, hasFaceNormal );
            faceType = setBit( faceType, 5, hasFaceVertexNormal );
            faceType = setBit( faceType, 6, hasFaceColor );
            faceType = setBit( faceType, 7, hasFaceVertexColor );

            faces.push( faceType );
            faces.push( face.a, face.b, face.c );

            if ( hasFaceVertexUv ) {

                var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

                faces.push(
                    getUvIndex( faceVertexUvs[ 0 ] ),
                    getUvIndex( faceVertexUvs[ 1 ] ),
                    getUvIndex( faceVertexUvs[ 2 ] )
                );

            }

            if ( hasFaceNormal ) {

                faces.push( getNormalIndex( face.normal ) );

            }

            if ( hasFaceVertexNormal ) {

                var vertexNormals = face.vertexNormals;

                faces.push(
                    getNormalIndex( vertexNormals[ 0 ] ),
                    getNormalIndex( vertexNormals[ 1 ] ),
                    getNormalIndex( vertexNormals[ 2 ] )
                );

            }

            if ( hasFaceColor ) {

                faces.push( getColorIndex( face.color ) );

            }

            if ( hasFaceVertexColor ) {

                var vertexColors = face.vertexColors;

                faces.push(
                    getColorIndex( vertexColors[ 0 ] ),
                    getColorIndex( vertexColors[ 1 ] ),
                    getColorIndex( vertexColors[ 2 ] )
                );

            }

        }

        function setBit( value, position, enabled ) {

            return enabled ? value | ( 1 << position ) : value & ( ~( 1 << position ) );

        }

        function getNormalIndex( normal ) {

            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

            if ( normalsHash[ hash ] !== undefined ) {

                return normalsHash[ hash ];

            }

            normalsHash[ hash ] = normals.length / 3;
            normals.push( normal.x, normal.y, normal.z );

            return normalsHash[ hash ];

        }

        function getColorIndex( color ) {

            var hash = color.r.toString() + color.g.toString() + color.b.toString();

            if ( colorsHash[ hash ] !== undefined ) {

                return colorsHash[ hash ];

            }

            colorsHash[ hash ] = colors.length;
            colors.push( color.getHex() );

            return colorsHash[ hash ];

        }

        function getUvIndex( uv ) {

            var hash = uv.x.toString() + uv.y.toString();

            if ( uvsHash[ hash ] !== undefined ) {

                return uvsHash[ hash ];

            }

            uvsHash[ hash ] = uvs.length / 2;
            uvs.push( uv.x, uv.y );

            return uvsHash[ hash ];

        }

        data.data = {};

        data.data.vertices = vertices;
        data.data.normals = normals;
        if ( colors.length > 0 ) data.data.colors = colors;
        if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
        data.data.faces = faces;

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];

        var vertices = source.vertices;

        for ( var i = 0, il = vertices.length; i < il; i++ ) {

            this.vertices.push( vertices[ i ].clone() );

        }

        var faces = source.faces;

        for ( var i = 0, il = faces.length; i < il; i++ ) {

            this.faces.push( faces[ i ].clone() );

        }

        for ( var i = 0, il = source.faceVertexUvs.length; i < il; i++ ) {

            var faceVertexUvs = source.faceVertexUvs[ i ];

            if ( this.faceVertexUvs[ i ] === undefined ) {

                this.faceVertexUvs[ i ] = [];

            }

            for ( var j = 0, jl = faceVertexUvs.length; j < jl; j++ ) {

                var uvs = faceVertexUvs[ j ],
                    uvsCopy = [];

                for ( var k = 0, kl = uvs.length; k < kl; k++ ) {

                    var uv = uvs[ k ];

                    uvsCopy.push( uv.clone() );

                }

                this.faceVertexUvs[ i ].push( uvsCopy );

            }

        }

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'DirectGeometry';

    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];

    this.groups = [];

    this.morphTargets = {};

    this.skinWeights = [];
    this.skinIndices = [];

    // this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

    constructor: THREE.DirectGeometry,

    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

    computeFaceNormals: function() {

        console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    },

    computeVertexNormals: function() {

        console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    },

    computeGroups: function( geometry ) {

        var group;
        var groups = [];
        var materialIndex;

        var faces = geometry.faces;

        for ( var i = 0; i < faces.length; i++ ) {

            var face = faces[ i ];

            // materials

            if ( face.materialIndex !== materialIndex ) {

                materialIndex = face.materialIndex;

                if ( group !== undefined ) {

                    group.count = ( i * 3 ) - group.start;
                    groups.push( group );

                }

                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };

            }

        }

        if ( group !== undefined ) {

            group.count = ( i * 3 ) - group.start;
            groups.push( group );

        }

        this.groups = groups;

    },

    fromGeometry: function( geometry ) {

        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;

        var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

        // morphs

        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;

        if ( morphTargetsLength > 0 ) {

            var morphTargetsPosition = [];

            for ( var i = 0; i < morphTargetsLength; i++ ) {

                morphTargetsPosition[ i ] = [];

            }

            this.morphTargets.position = morphTargetsPosition;

        }

        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;

        if ( morphNormalsLength > 0 ) {

            var morphTargetsNormal = [];

            for ( var i = 0; i < morphNormalsLength; i++ ) {

                morphTargetsNormal[ i ] = [];

            }

            this.morphTargets.normal = morphTargetsNormal;

        }

        // skins

        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;

        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;

        //

        for ( var i = 0; i < faces.length; i++ ) {

            var face = faces[ i ];

            this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

            }
            else {

                var normal = face.normal;

                this.normals.push( normal, normal, normal );

            }

            var vertexColors = face.vertexColors;

            if ( vertexColors.length === 3 ) {

                this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

            }
            else {

                var color = face.color;

                this.colors.push( color, color, color );

            }

            if ( hasFaceVertexUv === true ) {

                var vertexUvs = faceVertexUvs[ 0 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                }
                else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

                    this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            if ( hasFaceVertexUv2 === true ) {

                var vertexUvs = faceVertexUvs[ 1 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                }
                else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

                    this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            // morphs

            for ( var j = 0; j < morphTargetsLength; j++ ) {

                var morphTarget = morphTargets[ j ].vertices;

                morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

            }

            for ( var j = 0; j < morphNormalsLength; j++ ) {

                var morphNormal = morphNormals[ j ].vertexNormals[ i ];

                morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

            }

            // skins

            if ( hasSkinIndices ) {

                this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

            }

            if ( hasSkinWeights ) {

                this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

            }

        }

        this.computeGroups( geometry );

        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.GeometryIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'BufferGeometry';

    this.index = null;
    this.attributes = {};

    this.morphAttributes = {};

    this.groups = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    this.drawRange = {
        start: 0,
        count: Infinity
    };

};

THREE.BufferGeometry.prototype = {

    constructor: THREE.BufferGeometry,

    addIndex: function( index ) {

        console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
        this.setIndex( index );

    },

    getIndex: function() {

        return this.index;

    },

    setIndex: function( index ) {

        this.index = index;

    },

    addAttribute: function( name, attribute ) {

        if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

            console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

            this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

            return;

        }

        if ( name === 'index' ) {

            console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
            this.setIndex( attribute );

        }

        this.attributes[ name ] = attribute;

    },

    getAttribute: function( name ) {

        return this.attributes[ name ];

    },

    removeAttribute: function( name ) {

        delete this.attributes[ name ];

    },

    get drawcalls() {

        console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
        return this.groups;

    },

    get offsets() {

        console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
        return this.groups;

    },

    addDrawCall: function( start, count, indexOffset ) {

        if ( indexOffset !== undefined ) {

            console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

        }

        console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
        this.addGroup( start, count );

    },

    clearDrawCalls: function() {

        console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
        this.clearGroups();

    },

    addGroup: function( start, count, materialIndex ) {

        this.groups.push( {

            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0

        } );

    },

    clearGroups: function() {

        this.groups = [];

    },

    setDrawRange: function( start, count ) {

        this.drawRange.start = start;
        this.drawRange.count = count;

    },

    applyMatrix: function( matrix ) {

        var position = this.attributes.position;

        if ( position !== undefined ) {

            matrix.applyToVector3Array( position.array );
            position.needsUpdate = true;

        }

        var normal = this.attributes.normal;

        if ( normal !== undefined ) {

            var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

            normalMatrix.applyToVector3Array( normal.array );
            normal.needsUpdate = true;

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

    },

    rotateX: function() {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function() {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function() {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function() {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function() {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function() {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    center: function() {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    setFromObject: function( object ) {

        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

        var geometry = object.geometry;

        if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

            var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
            var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

            this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
            this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

            if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

                var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

                this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

            }

            if ( geometry.boundingSphere !== null ) {

                this.boundingSphere = geometry.boundingSphere.clone();

            }

            if ( geometry.boundingBox !== null ) {

                this.boundingBox = geometry.boundingBox.clone();

            }

        }
        else if ( object instanceof THREE.Mesh ) {

            if ( geometry instanceof THREE.Geometry ) {

                this.fromGeometry( geometry );

            }

        }

        return this;

    },

    updateFromObject: function( object ) {

        var geometry = object.geometry;

        if ( object instanceof THREE.Mesh ) {

            var direct = geometry.__directGeometry;

            if ( direct === undefined ) {

                return this.fromGeometry( geometry );

            }

            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;

            geometry = direct;

        }

        if ( geometry.verticesNeedUpdate === true ) {

            var attribute = this.attributes.position;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.vertices );
                attribute.needsUpdate = true;

            }

            geometry.verticesNeedUpdate = false;

        }

        if ( geometry.normalsNeedUpdate === true ) {

            var attribute = this.attributes.normal;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.normals );
                attribute.needsUpdate = true;

            }

            geometry.normalsNeedUpdate = false;

        }

        if ( geometry.colorsNeedUpdate === true ) {

            var attribute = this.attributes.color;

            if ( attribute !== undefined ) {

                attribute.copyColorsArray( geometry.colors );
                attribute.needsUpdate = true;

            }

            geometry.colorsNeedUpdate = false;

        }

        if ( geometry.lineDistancesNeedUpdate ) {

            var attribute = this.attributes.lineDistance;

            if ( attribute !== undefined ) {

                attribute.copyArray( geometry.lineDistances );
                attribute.needsUpdate = true;

            }

            geometry.lineDistancesNeedUpdate = false;

        }

        if ( geometry.groupsNeedUpdate ) {

            geometry.computeGroups( object.geometry );
            this.groups = geometry.groups;

            geometry.groupsNeedUpdate = false;

        }

        return this;

    },

    fromGeometry: function( geometry ) {

        geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

        return this.fromDirectGeometry( geometry.__directGeometry );

    },

    fromDirectGeometry: function( geometry ) {

        var positions = new Float32Array( geometry.vertices.length * 3 );
        this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

        if ( geometry.normals.length > 0 ) {

            var normals = new Float32Array( geometry.normals.length * 3 );
            this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

        }

        if ( geometry.colors.length > 0 ) {

            var colors = new Float32Array( geometry.colors.length * 3 );
            this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

        }

        if ( geometry.uvs.length > 0 ) {

            var uvs = new Float32Array( geometry.uvs.length * 2 );
            this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

        }

        if ( geometry.uvs2.length > 0 ) {

            var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
            this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

        }

        if ( geometry.indices.length > 0 ) {

            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
            var indices = new TypeArray( geometry.indices.length * 3 );
            this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

        }

        // groups

        this.groups = geometry.groups;

        // morphs

        for ( var name in geometry.morphTargets ) {

            var array = [];
            var morphTargets = geometry.morphTargets[ name ];

            for ( var i = 0, l = morphTargets.length; i < l; i++ ) {

                var morphTarget = morphTargets[ i ];

                var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

                array.push( attribute.copyVector3sArray( morphTarget ) );

            }

            this.morphAttributes[ name ] = array;

        }

        // skinning

        if ( geometry.skinIndices.length > 0 ) {

            var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
            this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

        }

        if ( geometry.skinWeights.length > 0 ) {

            var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
            this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

        }

        //

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        return this;

    },

    computeBoundingBox: function() {

        var vector = new THREE.Vector3();

        return function() {

            if ( this.boundingBox === null ) {

                this.boundingBox = new THREE.Box3();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                var bb = this.boundingBox;
                bb.makeEmpty();

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    bb.expandByPoint( vector );

                }

            }

            if ( positions === undefined || positions.length === 0 ) {

                this.boundingBox.min.set( 0, 0, 0 );
                this.boundingBox.max.set( 0, 0, 0 );

            }

            if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

                console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

            }

        };

    }(),

    computeBoundingSphere: function() {

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();

        return function() {

            if ( this.boundingSphere === null ) {

                this.boundingSphere = new THREE.Sphere();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                box.makeEmpty();

                var center = this.boundingSphere.center;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    box.expandByPoint( vector );

                }

                box.center( center );

                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                var maxRadiusSq = 0;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

                }

                this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

                if ( isNaN( this.boundingSphere.radius ) ) {

                    console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

                }

            }

        };

    }(),

    computeFaceNormals: function() {

        // backwards compatibility

    },

    computeVertexNormals: function() {

        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;

        if ( attributes.position ) {

            var positions = attributes.position.array;

            if ( attributes.normal === undefined ) {

                this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

            }
            else {

                // reset existing normals to zero

                var normals = attributes.normal.array;

                for ( var i = 0, il = normals.length; i < il; i++ ) {

                    normals[ i ] = 0;

                }

            }

            var normals = attributes.normal.array;

            var vA, vB, vC,

                pA = new THREE.Vector3(),
                pB = new THREE.Vector3(),
                pC = new THREE.Vector3(),

                cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            // indexed elements

            if ( index ) {

                var indices = index.array;

                if ( groups.length === 0 ) {

                    this.addGroup( 0, indices.length );

                }

                for ( var j = 0, jl = groups.length; j < jl; ++j ) {

                    var group = groups[ j ];

                    var start = group.start;
                    var count = group.count;

                    for ( var i = start, il = start + count; i < il; i += 3 ) {

                        vA = indices[ i + 0 ] * 3;
                        vB = indices[ i + 1 ] * 3;
                        vC = indices[ i + 2 ] * 3;

                        pA.fromArray( positions, vA );
                        pB.fromArray( positions, vB );
                        pC.fromArray( positions, vC );

                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );

                        normals[ vA ] += cb.x;
                        normals[ vA + 1 ] += cb.y;
                        normals[ vA + 2 ] += cb.z;

                        normals[ vB ] += cb.x;
                        normals[ vB + 1 ] += cb.y;
                        normals[ vB + 2 ] += cb.z;

                        normals[ vC ] += cb.x;
                        normals[ vC + 1 ] += cb.y;
                        normals[ vC + 2 ] += cb.z;

                    }

                }

            }
            else {

                // non-indexed elements (unconnected triangle soup)

                for ( var i = 0, il = positions.length; i < il; i += 9 ) {

                    pA.fromArray( positions, i );
                    pB.fromArray( positions, i + 3 );
                    pC.fromArray( positions, i + 6 );

                    cb.subVectors( pC, pB );
                    ab.subVectors( pA, pB );
                    cb.cross( ab );

                    normals[ i ] = cb.x;
                    normals[ i + 1 ] = cb.y;
                    normals[ i + 2 ] = cb.z;

                    normals[ i + 3 ] = cb.x;
                    normals[ i + 4 ] = cb.y;
                    normals[ i + 5 ] = cb.z;

                    normals[ i + 6 ] = cb.x;
                    normals[ i + 7 ] = cb.y;
                    normals[ i + 8 ] = cb.z;

                }

            }

            this.normalizeNormals();

            attributes.normal.needsUpdate = true;

        }

    },

    computeTangents: function() {

        console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

    },

    computeOffsets: function( size ) {

        console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' )

    },

    merge: function( geometry, offset ) {

        if ( geometry instanceof THREE.BufferGeometry === false ) {

            console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
            return;

        }

        if ( offset === undefined ) offset = 0;

        var attributes = this.attributes;

        for ( var key in attributes ) {

            if ( geometry.attributes[ key ] === undefined ) continue;

            var attribute1 = attributes[ key ];
            var attributeArray1 = attribute1.array;

            var attribute2 = geometry.attributes[ key ];
            var attributeArray2 = attribute2.array;

            var attributeSize = attribute2.itemSize;

            for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++ ) {

                attributeArray1[ j ] = attributeArray2[ i ];

            }

        }

        return this;

    },

    normalizeNormals: function() {

        var normals = this.attributes.normal.array;

        var x, y, z, n;

        for ( var i = 0, il = normals.length; i < il; i += 3 ) {

            x = normals[ i ];
            y = normals[ i + 1 ];
            z = normals[ i + 2 ];

            n = 1.0 / Math.sqrt( x * x + y * y + z * z );

            normals[ i ] *= n;
            normals[ i + 1 ] *= n;
            normals[ i + 2 ] *= n;

        }

    },

    toJSON: function() {

        var data = {
            metadata: {
                version: 4.4,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };

        // standard BufferGeometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        data.data = {
            attributes: {}
        };

        var index = this.index;

        if ( index !== null ) {

            var array = Array.prototype.slice.call( index.array );

            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };

        }

        var attributes = this.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];

            var array = Array.prototype.slice.call( attribute.array );

            data.data.attributes[ key ] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array
            };

        }

        var groups = this.groups;

        if ( groups.length > 0 ) {

            data.data.groups = JSON.parse( JSON.stringify( groups ) );

        }

        var boundingSphere = this.boundingSphere;

        if ( boundingSphere !== null ) {

            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };

        }

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        var index = source.index;

        if ( index !== null ) {

            this.setIndex( index.clone() );

        }

        var attributes = source.attributes;

        for ( var name in attributes ) {

            var attribute = attributes[ name ];
            this.addAttribute( name, attribute.clone() );

        }

        var groups = source.groups;

        for ( var i = 0, l = groups.length; i < l; i++ ) {

            var group = groups[ i ];
            this.addGroup( group.start, group.count );

        }

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function() {

    THREE.BufferGeometry.call( this );

    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function( start, count, instances ) {

    this.groups.push( {

        start: start,
        count: count,
        instances: instances

    } );

};

THREE.InstancedBufferGeometry.prototype.copy = function( source ) {

    var index = source.index;

    if ( index !== null ) {

        this.setIndex( index.clone() );

    }

    var attributes = source.attributes;

    for ( var name in attributes ) {

        var attribute = attributes[ name ];
        this.addAttribute( name, attribute.clone() );

    }

    var groups = source.groups;

    for ( var i = 0, l = groups.length; i < l; i++ ) {

        var group = groups[ i ];
        this.addGroup( group.start, group.count, group.instances );

    }

    return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Camera = function() {

    THREE.Object3D.call( this );

    this.type = 'Camera';

    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function() {

    var quaternion = new THREE.Quaternion();

    return function( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.getWorldQuaternion( quaternion );

        return result.set( 0, 0, -1 ).applyQuaternion( quaternion );

    };

}();

THREE.Camera.prototype.lookAt = function() {

    // This routine does not support cameras with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function( vector ) {

        m1.lookAt( this.position, vector, this.up );

        this.quaternion.setFromRotationMatrix( m1 );

    };

}();

THREE.Camera.prototype.clone = function() {

    return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.matrixWorldInverse.copy( source.matrixWorldInverse );
    this.projectionMatrix.copy( source.projectionMatrix );

    return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function( near, far, cubeResolution ) {

    THREE.Object3D.call( this );

    this.type = 'CubeCamera';

    var fov = 90,
        aspect = 1;

    var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPX.up.set( 0, -1, 0 );
    cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
    this.add( cameraPX );

    var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNX.up.set( 0, -1, 0 );
    cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
    this.add( cameraNX );

    var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPY.up.set( 0, 0, 1 );
    cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
    this.add( cameraPY );

    var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNY.up.set( 0, 0, -1 );
    cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
    this.add( cameraNY );

    var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPZ.up.set( 0, -1, 0 );
    cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
    this.add( cameraPZ );

    var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNZ.up.set( 0, -1, 0 );
    cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
    this.add( cameraNZ );

    this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    } );

    this.updateCubeMap = function( renderer, scene ) {

        if ( this.parent === null ) this.updateMatrixWorld();

        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.generateMipmaps;

        renderTarget.generateMipmaps = false;

        renderTarget.activeCubeFace = 0;
        renderer.render( scene, cameraPX, renderTarget );

        renderTarget.activeCubeFace = 1;
        renderer.render( scene, cameraNX, renderTarget );

        renderTarget.activeCubeFace = 2;
        renderer.render( scene, cameraPY, renderTarget );

        renderTarget.activeCubeFace = 3;
        renderer.render( scene, cameraNY, renderTarget );

        renderTarget.activeCubeFace = 4;
        renderer.render( scene, cameraPZ, renderTarget );

        renderTarget.generateMipmaps = generateMipmaps;

        renderTarget.activeCubeFace = 5;
        renderer.render( scene, cameraNZ, renderTarget );

        renderer.setRenderTarget( null );

    };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function( left, right, top, bottom, near, far ) {

    THREE.Camera.call( this );

    this.type = 'OrthographicCamera';

    this.zoom = 1;

    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;

    this.near = ( near !== undefined ) ? near : 0.1;
    this.far = ( far !== undefined ) ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {

    var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    var cx = ( this.right + this.left ) / 2;
    var cy = ( this.top + this.bottom ) / 2;

    this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.OrthographicCamera.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function( fov, aspect, near, far ) {

    THREE.Camera.call( this );

    this.type = 'PerspectiveCamera';

    this.zoom = 1;

    this.fov = fov !== undefined ? fov : 50;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function( focalLength, frameHeight ) {

    if ( frameHeight === undefined ) frameHeight = 24;

    this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
    this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function( fullWidth, fullHeight, x, y, width, height ) {

    this.fullWidth = fullWidth;
    this.fullHeight = fullHeight;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {

    var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

    if ( this.fullWidth ) {

        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs( right - left );
        var height = Math.abs( top - bottom );

        this.projectionMatrix.makeFrustum(
            left + this.x * width / this.fullWidth,
            left + ( this.x + this.width ) * width / this.fullWidth,
            top - ( this.y + this.height ) * height / this.fullHeight,
            top - this.y * height / this.fullHeight,
            this.near,
            this.far
        );

    }
    else {

        this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

    }

};

THREE.PerspectiveCamera.prototype.copy = function( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.fov = source.fov;
    this.aspect = source.aspect;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.fov = this.fov;
    data.object.aspect = this.aspect;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function( color ) {

    THREE.Object3D.call( this );

    this.type = 'Light';

    this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.color.copy( source.color );

    return this;

};
// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function( color ) {

    THREE.Light.call( this, color );

    this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();

    return data;

};

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function( color, intensity ) {

    THREE.Light.call( this, color );

    this.type = 'DirectionalLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;

    this.castShadow = false;
    this.onlyShadow = false;

    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5000;

    this.shadowCameraLeft = -500;
    this.shadowCameraRight = 500;
    this.shadowCameraTop = 500;
    this.shadowCameraBottom = -500;

    this.shadowCameraVisible = false;

    this.shadowBias = 0;
    this.shadowDarkness = 0.5;

    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;

    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.target = source.target.clone();

    this.castShadow = source.castShadow;
    this.onlyShadow = source.onlyShadow;

    this.shadowCameraNear = source.shadowCameraNear;
    this.shadowCameraFar = source.shadowCameraFar;

    this.shadowCameraLeft = source.shadowCameraLeft;
    this.shadowCameraRight = source.shadowCameraRight;
    this.shadowCameraTop = source.shadowCameraTop;
    this.shadowCameraBottom = source.shadowCameraBottom;

    this.shadowCameraVisible = source.shadowCameraVisible;

    this.shadowBias = source.shadowBias;
    this.shadowDarkness = source.shadowDarkness;

    this.shadowMapWidth = source.shadowMapWidth;
    this.shadowMapHeight = source.shadowMapHeight;

    return this;

};

THREE.DirectionalLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;

    return data;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function( skyColor, groundColor, intensity ) {

    THREE.Light.call( this, skyColor );

    this.type = 'HemisphereLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.groundColor = new THREE.Color( groundColor );
    this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.groundColor.copy( source.groundColor );
    this.intensity = source.intensity;

    return this;

};

THREE.HemisphereLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.groundColor = this.groundColor.getHex();
    data.object.intensity = this.intensity;

    return data;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function( color, intensity, distance, decay ) {

    THREE.Light.call( this, color );

    this.type = 'PointLight';

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.decay = source.decay;

    return this;

};

THREE.PointLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    data.object.distance = this.distance;
    data.object.decay = this.decay;

    return data;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function( color, intensity, distance, angle, exponent, decay ) {

    THREE.Light.call( this, color );

    this.type = 'SpotLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    this.exponent = ( exponent !== undefined ) ? exponent : 10;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

    this.castShadow = false;
    this.onlyShadow = false;

    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5000;
    this.shadowCameraFov = 50;

    this.shadowCameraVisible = false;

    this.shadowBias = 0;
    this.shadowDarkness = 0.5;

    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;

    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.angle = source.angle;
    this.exponent = source.exponent;
    this.decay = source.decay;

    this.target = source.target.clone();

    this.castShadow = source.castShadow;
    this.onlyShadow = source.onlyShadow;

    this.shadowCameraNear = source.shadowCameraNear;
    this.shadowCameraFar = source.shadowCameraFar;
    this.shadowCameraFov = source.shadowCameraFov;

    this.shadowCameraVisible = source.shadowCameraVisible;

    this.shadowBias = source.shadowBias;
    this.shadowDarkness = source.shadowDarkness;

    this.shadowMapWidth = source.shadowMapWidth;
    this.shadowMapHeight = source.shadowMapHeight;

    return this;
}

THREE.SpotLight.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    data.object.distance = this.distance;
    data.object.angle = this.angle;
    data.object.exponent = this.exponent;
    data.object.decay = this.decay;

    return data;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

    enabled: false,

    files: {},

    add: function( key, file ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Adding key:', key );

        this.files[ key ] = file;

    },

    get: function( key ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Checking key:', key );

        return this.files[ key ];

    },

    remove: function( key ) {

        delete this.files[ key ];

    },

    clear: function() {

        this.files = {};

    }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function() {

    this.onLoadStart = function() {};
    this.onLoadProgress = function() {};
    this.onLoadComplete = function() {};

};

THREE.Loader.prototype = {

    constructor: THREE.Loader,

    crossOrigin: undefined,

    extractUrlBase: function( url ) {

        var parts = url.split( '/' );

        if ( parts.length === 1 ) return './';

        parts.pop();

        return parts.join( '/' ) + '/';

    },

    initMaterials: function( materials, texturePath, crossOrigin ) {

        var array = [];

        for ( var i = 0; i < materials.length; ++i ) {

            array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

        }

        return array;

    },

    createMaterial: ( function() {

        var imageLoader;

        return function createMaterial( m, texturePath, crossOrigin ) {

            var scope = this;

            if ( crossOrigin === undefined && scope.crossOrigin !== undefined ) crossOrigin = scope.crossOrigin;

            if ( imageLoader === undefined ) imageLoader = new THREE.ImageLoader();

            function nearest_pow2( n ) {

                var l = Math.log( n ) / Math.LN2;
                return Math.pow( 2, Math.round( l ) );

            }

            function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

                var fullPath = texturePath + sourceFile;

                var texture;

                var loader = THREE.Loader.Handlers.get( fullPath );

                if ( loader !== null ) {

                    texture = loader.load( fullPath );

                }
                else {

                    texture = new THREE.Texture();

                    loader = imageLoader;
                    loader.setCrossOrigin( crossOrigin );
                    loader.load( fullPath, function( image ) {

                        if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
                            THREE.Math.isPowerOfTwo( image.height ) === false ) {

                            var width = nearest_pow2( image.width );
                            var height = nearest_pow2( image.height );

                            var canvas = document.createElement( 'canvas' );
                            canvas.width = width;
                            canvas.height = height;

                            var context = canvas.getContext( '2d' );
                            context.drawImage( image, 0, 0, width, height );

                            texture.image = canvas;

                        }
                        else {

                            texture.image = image;

                        }

                        texture.needsUpdate = true;

                    } );

                }

                texture.sourceFile = sourceFile;

                if ( repeat ) {

                    texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

                    if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
                    if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

                }

                if ( offset ) {

                    texture.offset.set( offset[ 0 ], offset[ 1 ] );

                }

                if ( wrap ) {

                    var wrapMap = {
                        'repeat': THREE.RepeatWrapping,
                        'mirror': THREE.MirroredRepeatWrapping
                    };

                    if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
                    if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

                }

                if ( anisotropy ) {

                    texture.anisotropy = anisotropy;

                }

                where[ name ] = texture;

            }

            function rgb2hex( rgb ) {

                return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

            }

            // defaults

            var mtype = 'MeshLambertMaterial';
            var mpars = {};

            // parameters from model file

            if ( m.shading ) {

                var shading = m.shading.toLowerCase();

                if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
                else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

            }

            if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

                mpars.blending = THREE[ m.blending ];

            }

            if ( m.transparent !== undefined ) {

                mpars.transparent = m.transparent;

            }

            if ( m.opacity !== undefined && m.opacity < 1.0 ) {

                mpars.transparent = true;

            }

            if ( m.depthTest !== undefined ) {

                mpars.depthTest = m.depthTest;

            }

            if ( m.depthWrite !== undefined ) {

                mpars.depthWrite = m.depthWrite;

            }

            if ( m.visible !== undefined ) {

                mpars.visible = m.visible;

            }

            if ( m.flipSided !== undefined ) {

                mpars.side = THREE.BackSide;

            }

            if ( m.doubleSided !== undefined ) {

                mpars.side = THREE.DoubleSide;

            }

            if ( m.wireframe !== undefined ) {

                mpars.wireframe = m.wireframe;

            }

            if ( m.vertexColors !== undefined ) {

                if ( m.vertexColors === 'face' ) {

                    mpars.vertexColors = THREE.FaceColors;

                }
                else if ( m.vertexColors ) {

                    mpars.vertexColors = THREE.VertexColors;

                }

            }

            // colors

            if ( m.colorDiffuse ) {

                mpars.color = rgb2hex( m.colorDiffuse );

            }
            else if ( m.DbgColor ) {

                mpars.color = m.DbgColor;

            }

            if ( m.colorEmissive ) {

                mpars.emissive = rgb2hex( m.colorEmissive );

            }

            if ( mtype === 'MeshPhongMaterial' ) {

                if ( m.colorSpecular ) {

                    mpars.specular = rgb2hex( m.colorSpecular );

                }

                if ( m.specularCoef ) {

                    mpars.shininess = m.specularCoef;

                }

            }

            // modifiers

            if ( m.transparency !== undefined ) {

                console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
                m.opacity = m.transparency;

            }

            if ( m.opacity !== undefined ) {

                mpars.opacity = m.opacity;

            }

            // textures

            if ( texturePath ) {

                if ( m.mapDiffuse ) {

                    create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

                }

                if ( m.mapLight ) {

                    create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

                }

                if ( m.mapAO ) {

                    create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

                }

                if ( m.mapBump ) {

                    create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

                }

                if ( m.mapNormal ) {

                    create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

                }

                if ( m.mapSpecular ) {

                    create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

                }

                if ( m.mapAlpha ) {

                    create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

                }

            }

            //

            if ( m.mapBumpScale ) {

                mpars.bumpScale = m.mapBumpScale;

            }

            if ( m.mapNormalFactor ) {

                mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

            }

            var material = new THREE[ mtype ]( mpars );

            if ( m.DbgName !== undefined ) material.name = m.DbgName;

            return material;

        };

    } )()

};

THREE.Loader.Handlers = {

    handlers: [],

    add: function( regex, loader ) {

        this.handlers.push( regex, loader );

    },

    get: function( file ) {

        for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

            var regex = this.handlers[ i ];
            var loader = this.handlers[ i + 1 ];

            if ( regex.test( file ) ) {

                return loader;

            }

        }

        return null;

    }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

    constructor: THREE.XHRLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function() {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var request = new XMLHttpRequest();
        request.open( 'GET', url, true );

        request.addEventListener( 'load', function( event ) {

            THREE.Cache.add( url, this.response );

            if ( onLoad ) onLoad( this.response );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            request.addEventListener( 'progress', function( event ) {

                onProgress( event );

            }, false );

        }

        request.addEventListener( 'error', function( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
        if ( this.responseType !== undefined ) request.responseType = this.responseType;
        if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

        request.send( null );

        scope.manager.itemStart( url );

        return request;

    },

    setResponseType: function( value ) {

        this.responseType = value;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setWithCredentials: function( value ) {

        this.withCredentials = value;

    }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

    constructor: THREE.ImageLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function() {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var image = document.createElement( 'img' );

        image.addEventListener( 'load', function( event ) {

            THREE.Cache.add( url, this );

            if ( onLoad ) onLoad( this );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            image.addEventListener( 'progress', function( event ) {

                onProgress( event );

            }, false );

        }

        image.addEventListener( 'error', function( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

        scope.manager.itemStart( url );

        image.src = url;

        return image;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function( manager ) {

    if ( typeof manager === 'boolean' ) {

        console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
        manager = undefined;

    }

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

    constructor: THREE.JSONLoader,

    // Deprecated

    get statusDomElement() {

        if ( this._statusDomElement === undefined ) {

            this._statusDomElement = document.createElement( 'div' );

        }

        console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
        return this._statusDomElement;

    },

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setWithCredentials( this.withCredentials );
        loader.load( url, function( text ) {

            var json = JSON.parse( text );
            var metadata = json.metadata;

            if ( metadata !== undefined ) {

                if ( metadata.type === 'object' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
                    return;

                }

                if ( metadata.type === 'scene' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
                    return;

                }

            }

            var object = scope.parse( json, texturePath );
            onLoad( object.geometry, object.materials );

        } );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setTexturePath: function( value ) {

        this.texturePath = value;

    },

    parse: function( json, texturePath ) {

        var geometry = new THREE.Geometry(),
            scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

        parseModel( scale );

        parseSkin();
        parseMorphing( scale );

        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();

        function parseModel( scale ) {

            function isBitSet( value, position ) {

                return value & ( 1 << position );

            }

            var i, j, fi,

                offset, zLength,

                colorIndex, normalIndex, uvIndex, materialIndex,

                type,
                isQuad,
                hasMaterial,
                hasFaceVertexUv,
                hasFaceNormal, hasFaceVertexNormal,
                hasFaceColor, hasFaceVertexColor,

                vertex, face, faceA, faceB, hex, normal,

                uvLayer, uv, u, v,

                faces = json.faces,
                vertices = json.vertices,
                normals = json.normals,
                colors = json.colors,

                nUvLayers = 0;

            if ( json.uvs !== undefined ) {

                // disregard empty arrays

                for ( i = 0; i < json.uvs.length; i++ ) {

                    if ( json.uvs[ i ].length ) nUvLayers++;

                }

                for ( i = 0; i < nUvLayers; i++ ) {

                    geometry.faceVertexUvs[ i ] = [];

                }

            }

            offset = 0;
            zLength = vertices.length;

            while ( offset < zLength ) {

                vertex = new THREE.Vector3();

                vertex.x = vertices[ offset++ ] * scale;
                vertex.y = vertices[ offset++ ] * scale;
                vertex.z = vertices[ offset++ ] * scale;

                geometry.vertices.push( vertex );

            }

            offset = 0;
            zLength = faces.length;

            while ( offset < zLength ) {

                type = faces[ offset++ ];


                isQuad = isBitSet( type, 0 );
                hasMaterial = isBitSet( type, 1 );
                hasFaceVertexUv = isBitSet( type, 3 );
                hasFaceNormal = isBitSet( type, 4 );
                hasFaceVertexNormal = isBitSet( type, 5 );
                hasFaceColor = isBitSet( type, 6 );
                hasFaceVertexColor = isBitSet( type, 7 );

                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                if ( isQuad ) {

                    faceA = new THREE.Face3();
                    faceA.a = faces[ offset ];
                    faceA.b = faces[ offset + 1 ];
                    faceA.c = faces[ offset + 3 ];

                    faceB = new THREE.Face3();
                    faceB.a = faces[ offset + 1 ];
                    faceB.b = faces[ offset + 2 ];
                    faceB.c = faces[ offset + 3 ];

                    offset += 4;

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset++ ];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];
                            geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                            for ( j = 0; j < 4; j++ ) {

                                uvIndex = faces[ offset++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset++ ] * 3;

                        faceA.normal.set(
                            normals[ normalIndex++ ],
                            normals[ normalIndex++ ],
                            normals[ normalIndex ]
                        );

                        faceB.normal.copy( faceA.normal );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 4; i++ ) {

                            normalIndex = faces[ offset++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex++ ],
                                normals[ normalIndex++ ],
                                normals[ normalIndex ]
                            );


                            if ( i !== 2 ) faceA.vertexNormals.push( normal );
                            if ( i !== 0 ) faceB.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset++ ];
                        hex = colors[ colorIndex ];

                        faceA.color.setHex( hex );
                        faceB.color.setHex( hex );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 4; i++ ) {

                            colorIndex = faces[ offset++ ];
                            hex = colors[ colorIndex ];

                            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
                            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

                        }

                    }

                    geometry.faces.push( faceA );
                    geometry.faces.push( faceB );

                }
                else {

                    face = new THREE.Face3();
                    face.a = faces[ offset++ ];
                    face.b = faces[ offset++ ];
                    face.c = faces[ offset++ ];

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset++ ];
                        face.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];

                            for ( j = 0; j < 3; j++ ) {

                                uvIndex = faces[ offset++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                geometry.faceVertexUvs[ i ][ fi ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset++ ] * 3;

                        face.normal.set(
                            normals[ normalIndex++ ],
                            normals[ normalIndex++ ],
                            normals[ normalIndex ]
                        );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 3; i++ ) {

                            normalIndex = faces[ offset++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex++ ],
                                normals[ normalIndex++ ],
                                normals[ normalIndex ]
                            );

                            face.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset++ ];
                        face.color.setHex( colors[ colorIndex ] );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 3; i++ ) {

                            colorIndex = faces[ offset++ ];
                            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

                        }

                    }

                    geometry.faces.push( face );

                }

            }

        };

        function parseSkin() {

            var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

            if ( json.skinWeights ) {

                for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

                    var x = json.skinWeights[ i ];
                    var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
                    var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
                    var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

                    geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

                }

            }

            if ( json.skinIndices ) {

                for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

                    var a = json.skinIndices[ i ];
                    var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
                    var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
                    var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

                    geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

                }

            }

            geometry.bones = json.bones;

            if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

                console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                    geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

            }


            // could change this to json.animations[0] or remove completely

            geometry.animation = json.animation;
            geometry.animations = json.animations;

        };

        function parseMorphing( scale ) {

            if ( json.morphTargets !== undefined ) {

                var i, l, v, vl, dstVertices, srcVertices;

                for ( i = 0, l = json.morphTargets.length; i < l; i++ ) {

                    geometry.morphTargets[ i ] = {};
                    geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
                    geometry.morphTargets[ i ].vertices = [];

                    dstVertices = geometry.morphTargets[ i ].vertices;
                    srcVertices = json.morphTargets[ i ].vertices;

                    for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

                        var vertex = new THREE.Vector3();
                        vertex.x = srcVertices[ v ] * scale;
                        vertex.y = srcVertices[ v + 1 ] * scale;
                        vertex.z = srcVertices[ v + 2 ] * scale;

                        dstVertices.push( vertex );

                    }

                }

            }

            if ( json.morphColors !== undefined ) {

                var i, l, c, cl, dstColors, srcColors, color;

                for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

                    geometry.morphColors[ i ] = {};
                    geometry.morphColors[ i ].name = json.morphColors[ i ].name;
                    geometry.morphColors[ i ].colors = [];

                    dstColors = geometry.morphColors[ i ].colors;
                    srcColors = json.morphColors[ i ].colors;

                    for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

                        color = new THREE.Color( 0xffaa00 );
                        color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
                        dstColors.push( color );

                    }

                }

            }

        };

        if ( json.materials === undefined || json.materials.length === 0 ) {

            return {
                geometry: geometry
            };

        }
        else {

            var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

            return {
                geometry: geometry,
                materials: materials
            };

        }

    }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function( onLoad, onProgress, onError ) {

    var scope = this;

    var isLoading = false,
        itemsLoaded = 0,
        itemsTotal = 0;

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function( url ) {

        itemsTotal++;

        if ( isLoading === false ) {

            if ( scope.onStart !== undefined ) {

                scope.onStart( url, itemsLoaded, itemsTotal );

            }

        }

        isLoading = true;

    };

    this.itemEnd = function( url ) {

        itemsLoaded++;

        if ( scope.onProgress !== undefined ) {

            scope.onProgress( url, itemsLoaded, itemsTotal );

        }

        if ( itemsLoaded === itemsTotal ) {

            isLoading = false;

            if ( scope.onLoad !== undefined ) {

                scope.onLoad();

            }

        }

    };

    this.itemError = function( url ) {

        if ( scope.onError !== undefined ) {

            scope.onError( url );

        }

    };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

    constructor: THREE.BufferGeometryLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    parse: function( json ) {

        var geometry = new THREE.BufferGeometry();

        var index = json.data.index;

        if ( index !== undefined ) {

            var typedArray = new self[ index.type ]( index.array );
            geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

        }

        var attributes = json.data.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];
            var typedArray = new self[ attribute.type ]( attribute.array );

            geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

        }

        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

        if ( groups !== undefined ) {

            for ( var i = 0, n = groups.length; i !== n; ++i ) {

                var group = groups[ i ];

                geometry.addGroup( group.start, group.count );

            }

        }

        var boundingSphere = json.data.boundingSphere;

        if ( boundingSphere !== undefined ) {

            var center = new THREE.Vector3();

            if ( boundingSphere.center !== undefined ) {

                center.fromArray( boundingSphere.center );

            }

            geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

        }

        return geometry;

    }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.textures = {};

};

THREE.MaterialLoader.prototype = {

    constructor: THREE.MaterialLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    setTextures: function( value ) {

        this.textures = value;

    },

    getTexture: function( name ) {

        var textures = this.textures;

        if ( textures[ name ] === undefined ) {

            console.warn( 'THREE.MaterialLoader: Undefined texture', name );

        }

        return textures[ name ];

    },

    parse: function( json ) {

        var material = new THREE[ json.type ];
        material.uuid = json.uuid;

        if ( json.name !== undefined ) material.name = json.name;
        if ( json.color !== undefined ) material.color.setHex( json.color );
        if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
        if ( json.specular !== undefined ) material.specular.setHex( json.specular );
        if ( json.shininess !== undefined ) material.shininess = json.shininess;
        if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
        if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
        if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
        if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
        if ( json.shading !== undefined ) material.shading = json.shading;
        if ( json.blending !== undefined ) material.blending = json.blending;
        if ( json.side !== undefined ) material.side = json.side;
        if ( json.opacity !== undefined ) material.opacity = json.opacity;
        if ( json.transparent !== undefined ) material.transparent = json.transparent;
        if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
        if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
        if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
        if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
        if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

        // for PointsMaterial
        if ( json.size !== undefined ) material.size = json.size;
        if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

        // maps

        if ( json.map !== undefined ) material.map = this.getTexture( json.map );

        if ( json.alphaMap !== undefined ) {

            material.alphaMap = this.getTexture( json.alphaMap );
            material.transparent = true;

        }

        if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
        if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

        if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
        if ( json.normalScale ) material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

        if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
        if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
        if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

        if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

        if ( json.envMap !== undefined ) {

            material.envMap = this.getTexture( json.envMap );
            material.combine = THREE.MultiplyOperation;

        }

        if ( json.reflectivity ) material.reflectivity = json.reflectivity;

        if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
        if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

        if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
        if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

        // MeshFaceMaterial

        if ( json.materials !== undefined ) {

            for ( var i = 0, l = json.materials.length; i < l; i++ ) {

                material.materials.push( this.parse( json.materials[ i ] ) );

            }

        }

        return material;

    }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

    constructor: THREE.ObjectLoader,

    load: function( url, onLoad, onProgress, onError ) {

        if ( this.texturePath === '' ) {

            this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

        }

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( text ) {

            scope.parse( JSON.parse( text ), onLoad );

        }, onProgress, onError );

    },

    setTexturePath: function( value ) {

        this.texturePath = value;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    },

    parse: function( json, onLoad ) {

        var geometries = this.parseGeometries( json.geometries );

        var images = this.parseImages( json.images, function() {

            if ( onLoad !== undefined ) onLoad( object );

        } );

        var textures = this.parseTextures( json.textures, images );
        var materials = this.parseMaterials( json.materials, textures );
        var object = this.parseObject( json.object, geometries, materials );

        if ( json.images === undefined || json.images.length === 0 ) {

            if ( onLoad !== undefined ) onLoad( object );

        }

        return object;

    },

    parseGeometries: function( json ) {

        var geometries = {};

        if ( json !== undefined ) {

            var geometryLoader = new THREE.JSONLoader();
            var bufferGeometryLoader = new THREE.BufferGeometryLoader();

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var geometry;
                var data = json[ i ];

                switch ( data.type ) {

                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':

                        geometry = new THREE[ data.type ](
                            data.width,
                            data.height,
                            data.widthSegments,
                            data.heightSegments
                        );

                        break;

                    case 'BoxGeometry':
                    case 'CubeGeometry': // backwards compatible

                        geometry = new THREE.BoxGeometry(
                            data.width,
                            data.height,
                            data.depth,
                            data.widthSegments,
                            data.heightSegments,
                            data.depthSegments
                        );

                        break;

                    case 'CircleBufferGeometry':

                        geometry = new THREE.CircleBufferGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CircleGeometry':

                        geometry = new THREE.CircleGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CylinderGeometry':

                        geometry = new THREE.CylinderGeometry(
                            data.radiusTop,
                            data.radiusBottom,
                            data.height,
                            data.radialSegments,
                            data.heightSegments,
                            data.openEnded,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereGeometry':

                        geometry = new THREE.SphereGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereBufferGeometry':

                        geometry = new THREE.SphereBufferGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'DodecahedronGeometry':

                        geometry = new THREE.DodecahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'IcosahedronGeometry':

                        geometry = new THREE.IcosahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'OctahedronGeometry':

                        geometry = new THREE.OctahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'TetrahedronGeometry':

                        geometry = new THREE.TetrahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'RingGeometry':

                        geometry = new THREE.RingGeometry(
                            data.innerRadius,
                            data.outerRadius,
                            data.thetaSegments,
                            data.phiSegments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'TorusGeometry':

                        geometry = new THREE.TorusGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.arc
                        );

                        break;

                    case 'TorusKnotGeometry':

                        geometry = new THREE.TorusKnotGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.p,
                            data.q,
                            data.heightScale
                        );

                        break;

                    case 'TextGeometry':

                        geometry = new THREE.TextGeometry(
                            data.text,
                            data.data
                        );

                        break;

                    case 'BufferGeometry':

                        geometry = bufferGeometryLoader.parse( data );

                        break;

                    case 'Geometry':

                        geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

                        break;

                    default:

                        console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

                        continue;

                }

                geometry.uuid = data.uuid;

                if ( data.name !== undefined ) geometry.name = data.name;

                geometries[ data.uuid ] = geometry;

            }

        }

        return geometries;

    },

    parseMaterials: function( json, textures ) {

        var materials = {};

        if ( json !== undefined ) {

            var loader = new THREE.MaterialLoader();
            loader.setTextures( textures );

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var material = loader.parse( json[ i ] );
                materials[ material.uuid ] = material;

            }

        }

        return materials;

    },

    parseImages: function( json, onLoad ) {

        var scope = this;
        var images = {};

        function loadImage( url ) {

            scope.manager.itemStart( url );

            return loader.load( url, function() {

                scope.manager.itemEnd( url );

            } );

        }

        if ( json !== undefined && json.length > 0 ) {

            var manager = new THREE.LoadingManager( onLoad );

            var loader = new THREE.ImageLoader( manager );
            loader.setCrossOrigin( this.crossOrigin );

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var image = json[ i ];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

                images[ image.uuid ] = loadImage( path );

            }

        }

        return images;

    },

    parseTextures: function( json, images ) {

        function parseConstant( value ) {

            if ( typeof( value ) === 'number' ) return value;

            console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

            return THREE[ value ];

        }

        var textures = {};

        if ( json !== undefined ) {

            for ( var i = 0, l = json.length; i < l; i++ ) {

                var data = json[ i ];

                if ( data.image === undefined ) {

                    console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

                }

                if ( images[ data.image ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

                }

                var texture = new THREE.Texture( images[ data.image ] );
                texture.needsUpdate = true;

                texture.uuid = data.uuid;

                if ( data.name !== undefined ) texture.name = data.name;
                if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
                if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
                if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
                if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
                if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
                if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
                if ( Array.isArray( data.wrap ) ) {

                    texture.wrapS = parseConstant( data.wrap[ 0 ] );
                    texture.wrapT = parseConstant( data.wrap[ 1 ] );

                }

                textures[ data.uuid ] = texture;

            }

        }

        return textures;

    },

    parseObject: function() {

        var matrix = new THREE.Matrix4();

        return function( data, geometries, materials ) {

            var object;

            var getGeometry = function( name ) {

                if ( geometries[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

                }

                return geometries[ name ];

            };

            var getMaterial = function( name ) {

                if ( materials[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined material', name );

                }

                return materials[ name ];

            };

            switch ( data.type ) {

                case 'Scene':

                    object = new THREE.Scene();

                    break;

                case 'PerspectiveCamera':

                    object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

                    break;

                case 'OrthographicCamera':

                    object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

                    break;

                case 'AmbientLight':

                    object = new THREE.AmbientLight( data.color );

                    break;

                case 'DirectionalLight':

                    object = new THREE.DirectionalLight( data.color, data.intensity );

                    break;

                case 'PointLight':

                    object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

                    break;

                case 'SpotLight':

                    object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

                    break;

                case 'HemisphereLight':

                    object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

                    break;

                case 'Mesh':

                    object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'LOD':

                    object = new THREE.LOD();

                    break;

                case 'Line':

                    object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

                    break;

                case 'PointCloud':
                case 'Points':

                    object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'Sprite':

                    object = new THREE.Sprite( getMaterial( data.material ) );

                    break;

                case 'Group':

                    object = new THREE.Group();

                    break;

                default:

                    object = new THREE.Object3D();

            }

            object.uuid = data.uuid;

            if ( data.name !== undefined ) object.name = data.name;
            if ( data.matrix !== undefined ) {

                matrix.fromArray( data.matrix );
                matrix.decompose( object.position, object.quaternion, object.scale );

            }
            else {

                if ( data.position !== undefined ) object.position.fromArray( data.position );
                if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
                if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

            }

            if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
            if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

            if ( data.visible !== undefined ) object.visible = data.visible;
            if ( data.userData !== undefined ) object.userData = data.userData;

            if ( data.children !== undefined ) {

                for ( var child in data.children ) {

                    object.add( this.parseObject( data.children[ child ], geometries, materials ) );

                }

            }

            if ( data.type === 'LOD' ) {

                var levels = data.levels;

                for ( var l = 0; l < levels.length; l++ ) {

                    var level = levels[ l ];
                    var child = object.getObjectByProperty( 'uuid', level.object );

                    if ( child !== undefined ) {

                        object.addLevel( child, level.distance );

                    }

                }

            }

            return object;

        }

    }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

    constructor: THREE.TextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.ImageLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function( image ) {

            var texture = new THREE.Texture( image );
            texture.needsUpdate = true;

            if ( onLoad !== undefined ) {

                onLoad( texture );

            }

        }, onProgress, onError );

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

    constructor: THREE.BinaryTextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texture = new THREE.DataTexture();

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        loader.load( url, function( buffer ) {

            var texData = scope._parser( buffer );

            if ( !texData ) return;

            if ( undefined !== texData.image ) {

                texture.image = texData.image;

            }
            else if ( undefined !== texData.data ) {

                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;

            }

            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

            if ( undefined !== texData.format ) {

                texture.format = texData.format;

            }
            if ( undefined !== texData.type ) {

                texture.type = texData.type;

            }

            if ( undefined !== texData.mipmaps ) {

                texture.mipmaps = texData.mipmaps;

            }

            if ( 1 === texData.mipmapCount ) {

                texture.minFilter = THREE.LinearFilter;

            }

            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture, texData );

        }, onProgress, onError );


        return texture;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

    constructor: THREE.CompressedTextureLoader,

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var images = [];

        var texture = new THREE.CompressedTexture();
        texture.image = images;

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        if ( Array.isArray( url ) ) {

            var loaded = 0;

            var loadTexture = function( i ) {

                loader.load( url[ i ], function( buffer ) {

                    var texDatas = scope._parser( buffer, true );

                    images[ i ] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };

                    loaded += 1;

                    if ( loaded === 6 ) {

                        if ( texDatas.mipmapCount === 1 )
                            texture.minFilter = THREE.LinearFilter;

                        texture.format = texDatas.format;
                        texture.needsUpdate = true;

                        if ( onLoad ) onLoad( texture );

                    }

                }, onProgress, onError );

            };

            for ( var i = 0, il = url.length; i < il; ++i ) {

                loadTexture( i );

            }

        }
        else {

            // compressed cubemap texture stored in a single DDS file

            loader.load( url, function( buffer ) {

                var texDatas = scope._parser( buffer, true );

                if ( texDatas.isCubemap ) {

                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                    for ( var f = 0; f < faces; f++ ) {

                        images[ f ] = {
                            mipmaps: []
                        };

                        for ( var i = 0; i < texDatas.mipmapCount; i++ ) {

                            images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
                            images[ f ].format = texDatas.format;
                            images[ f ].width = texDatas.width;
                            images[ f ].height = texDatas.height;

                        }

                    }

                }
                else {

                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;

                }

                if ( texDatas.mipmapCount === 1 ) {

                    texture.minFilter = THREE.LinearFilter;

                }

                texture.format = texDatas.format;
                texture.needsUpdate = true;

                if ( onLoad ) onLoad( texture );

            }, onProgress, onError );

        }

        return texture;

    },

    setCrossOrigin: function( value ) {

        this.crossOrigin = value;

    }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function() {

    Object.defineProperty( this, 'id', {
        value: THREE.MaterialIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Material';

    this.side = THREE.FrontSide;

    this.opacity = 1;
    this.transparent = false;

    this.blending = THREE.NormalBlending;

    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;

    this.depthFunc = THREE.LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;

    this.colorWrite = true;

    this.precision = null; // override the renderer's default precision for this material

    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;

    this.alphaTest = 0;

    this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    this.visible = true;

    this._needsUpdate = true;

};

THREE.Material.prototype = {

    constructor: THREE.Material,

    get needsUpdate() {

        return this._needsUpdate;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.update();

        this._needsUpdate = value;

    },

    setValues: function( values ) {

        if ( values === undefined ) return;

        for ( var key in values ) {

            var newValue = values[ key ];

            if ( newValue === undefined ) {

                console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
                continue;

            }

            var currentValue = this[ key ];

            if ( currentValue === undefined ) {

                console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
                continue;

            }

            if ( currentValue instanceof THREE.Color ) {

                currentValue.set( newValue );

            }
            else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

                currentValue.copy( newValue );

            }
            else if ( key === 'overdraw' ) {

                // ensure overdraw is backwards-compatible with legacy boolean type
                this[ key ] = Number( newValue );

            }
            else {

                this[ key ] = newValue;

            }

        }

    },

    toJSON: function( meta ) {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };

        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
        if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
        if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
        if ( this.shininess !== undefined ) data.shininess = this.shininess;

        if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
        if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
        if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
        if ( this.bumpMap instanceof THREE.Texture ) {

            data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
            data.bumpScale = this.bumpScale;

        }
        if ( this.normalMap instanceof THREE.Texture ) {

            data.normalMap = this.normalMap.toJSON( meta ).uuid;
            data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

        }
        if ( this.displacementMap instanceof THREE.Texture ) {

            data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;

        }
        if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
        if ( this.envMap instanceof THREE.Texture ) {

            data.envMap = this.envMap.toJSON( meta ).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap

        }

        if ( this.size !== undefined ) data.size = this.size;
        if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

        if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
        if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
        if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
        if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

        if ( this.opacity < 1 ) data.opacity = this.opacity;
        if ( this.transparent === true ) data.transparent = this.transparent;
        if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
        if ( this.wireframe === true ) data.wireframe = this.wireframe;
        if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

        return data;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.name = source.name;

        this.side = source.side;

        this.opacity = source.opacity;
        this.transparent = source.transparent;

        this.blending = source.blending;

        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;

        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;

        this.precision = source.precision;

        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;

        this.alphaTest = source.alphaTest;

        this.overdraw = source.overdraw;

        this.visible = source.visible;

        return this;

    },

    update: function() {

        this.dispatchEvent( {
            type: 'update'
        } );

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    },

    // Deprecated

    get wrapAround() {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    set wrapAround( boolean ) {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    get wrapRGB() {

        console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
        return new THREE.Color();

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineBasicMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineDashedMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;

    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;

    this.vertexColors = false;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;

    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshBasicMaterial';

    this.color = new THREE.Color( 0xffffff ); // emissive

    this.map = null;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshLambertMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );

    this.map = null;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );

    this.map = source.map;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshPhongMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );
    this.specular = new THREE.Color( 0x111111 );
    this.shininess = 30;

    this.metal = false;

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissiveMap = null;

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new THREE.Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );
    this.specular.copy( source.specular );
    this.shininess = source.shininess;

    this.metal = source.metal;

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissiveMap = source.emissiveMap;

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshDepthMaterial';

    this.morphTargets = false;
    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function( parameters ) {

    THREE.Material.call( this, parameters );

    this.type = 'MeshNormalMaterial';

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function( materials ) {

    this.uuid = THREE.Math.generateUUID();

    this.type = 'MultiMaterial';

    this.materials = materials instanceof Array ? materials : [];

    this.visible = true;

};

THREE.MultiMaterial.prototype = {

    constructor: THREE.MultiMaterial,

    toJSON: function() {

        var output = {
            metadata: {
                version: 4.2,
                type: 'material',
                generator: 'MaterialExporter'
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };

        for ( var i = 0, l = this.materials.length; i < l; i++ ) {

            output.materials.push( this.materials[ i ].toJSON() );

        }

        output.visible = this.visible;

        return output;

    },

    clone: function() {

        var material = new this.constructor();

        for ( var i = 0; i < this.materials.length; i++ ) {

            material.materials.push( this.materials[ i ].clone() );

        }

        material.visible = this.visible;

        return material;

    }

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'PointsMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.map = null;

    this.size = 1;
    this.sizeAttenuation = true;

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function( parameters ) {

    console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function( parameters ) {

    console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function( parameters ) {

    console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'ShaderMaterial';

    this.defines = {};
    this.uniforms = {};

    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    this.shading = THREE.SmoothShading;

    this.linewidth = 1;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false; // set to use scene fog

    this.lights = false; // set to use scene lights

    this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

    this.skinning = false; // set to use skinning attribute streams

    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals

    this.derivatives = false; // set to use derivatives

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [ 1, 1, 1 ],
        'uv': [ 0, 0 ],
        'uv2': [ 0, 0 ]
    };

    this.index0AttributeName = undefined;

    if ( parameters !== undefined ) {

        if ( parameters.attributes !== undefined ) {

            console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

        }

        this.setValues( parameters );

    }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;

    this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

    this.attributes = source.attributes;
    this.defines = source.defines;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    this.fog = source.fog;

    this.lights = source.lights;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;

    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    this.derivatives = source.derivatives;

    return this;

};

THREE.ShaderMaterial.prototype.toJSON = function( meta ) {

    var data = THREE.Material.prototype.toJSON.call( this, meta );

    data.uniforms = this.uniforms;
    data.attributes = this.attributes;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;

    return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function( parameters ) {

    THREE.ShaderMaterial.call( this, parameters );

    this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function( parameters ) {

    THREE.Material.call( this );

    this.type = 'SpriteMaterial';

    this.color = new THREE.Color( 0xffffff );
    this.map = null;

    this.rotation = 0;

    this.fog = false;

    // set parameters

    this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.map = source.map;

    this.rotation = source.rotation;

    this.fog = source.fog;

    return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    Object.defineProperty( this, 'id', {
        value: THREE.TextureIdCount++
    } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.sourceFile = '';

    this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];

    this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    this.format = format !== undefined ? format : THREE.RGBAFormat;
    this.type = type !== undefined ? type : THREE.UnsignedByteType;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    this.version = 0;
    this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

    constructor: THREE.Texture,

    set needsUpdate( value ) {

        if ( value === true ) this.version++;

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.image = source.image;
        this.mipmaps = source.mipmaps.slice( 0 );

        this.mapping = source.mapping;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.format = source.format;
        this.type = source.type;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;

        return this;

    },

    toJSON: function( meta ) {

        if ( meta.textures[ this.uuid ] !== undefined ) {

            return meta.textures[ this.uuid ];

        }

        function getDataURL( image ) {

            var canvas;

            if ( image.toDataURL !== undefined ) {

                canvas = image;

            }
            else {

                canvas = document.createElement( 'canvas' );
                canvas.width = image.width;
                canvas.height = image.height;

                canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {

                return canvas.toDataURL( 'image/jpeg', 0.6 );

            }
            else {

                return canvas.toDataURL( 'image/png' );

            }

        }

        var output = {
            metadata: {
                version: 4.4,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },

            uuid: this.uuid,
            name: this.name,

            mapping: this.mapping,

            repeat: [ this.repeat.x, this.repeat.y ],
            offset: [ this.offset.x, this.offset.y ],
            wrap: [ this.wrapS, this.wrapT ],

            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };

        if ( this.image !== undefined ) {

            // TODO: Move to THREE.Image

            var image = this.image;

            if ( image.uuid === undefined ) {

                image.uuid = THREE.Math.generateUUID(); // UGH

            }

            if ( meta.images[ image.uuid ] === undefined ) {

                meta.images[ image.uuid ] = {
                    uuid: image.uuid,
                    url: getDataURL( image )
                };

            }

            output.image = image.uuid;

        }

        meta.textures[ this.uuid ] = output;

        return output;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    },

    transformUv: function( uv ) {

        if ( this.mapping !== THREE.UVMapping ) return;

        uv.multiply( this.repeat );
        uv.add( this.offset );

        if ( uv.x < 0 || uv.x > 1 ) {

            switch ( this.wrapS ) {

                case THREE.RepeatWrapping:

                    uv.x = uv.x - Math.floor( uv.x );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

                        uv.x = Math.ceil( uv.x ) - uv.x;

                    }
                    else {

                        uv.x = uv.x - Math.floor( uv.x );

                    }
                    break;

            }

        }

        if ( uv.y < 0 || uv.y > 1 ) {

            switch ( this.wrapT ) {

                case THREE.RepeatWrapping:

                    uv.y = uv.y - Math.floor( uv.y );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

                        uv.y = Math.ceil( uv.y ) - uv.y;

                    }
                    else {

                        uv.y = uv.y - Math.floor( uv.y );

                    }
                    break;

            }

        }

        if ( this.flipY ) {

            uv.y = 1 - uv.y;

        }

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

    THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.images = images;
    this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function( source ) {

    THREE.Texture.prototype.copy.call( this, source );

    this.images = source.images;

    return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;

    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    this.flipY = false;

    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = {
        data: data,
        width: width,
        height: height
    };

    this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

    this.flipY = false;
    this.generateMipmaps = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.generateMipmaps = false;

    var scope = this;

    var update = function() {

        requestAnimationFrame( update );

        if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

            scope.needsUpdate = true;

        }

    };

    update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function() {

    THREE.Object3D.call( this );

    this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Points';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.PointsMaterial( {
        color: Math.random() * 0xffffff
    } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();

    return function raycast( raycaster, intersects ) {

        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.Points.threshold;

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();

        function testPoint( point, index ) {

            var rayPointDistanceSq = ray.distanceSqToPoint( point );

            if ( rayPointDistanceSq < localThresholdSq ) {

                var intersectPoint = ray.closestPointToPoint( point );
                intersectPoint.applyMatrix4( object.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectPoint );

                if ( distance < raycaster.near || distance > raycaster.far ) return;

                intersects.push( {

                    distance: distance,
                    distanceToRay: Math.sqrt( rayPointDistanceSq ),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object

                } );

            }

        }

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if ( index !== null ) {

                var indices = index.array;

                for ( var i = 0, il = indices.length; i < il; i++ ) {

                    var a = indices[ i ];

                    position.fromArray( positions, a * 3 );

                    testPoint( position, a );

                }

            }
            else {

                for ( var i = 0, l = positions.length / 3; i < l; i++ ) {

                    position.fromArray( positions, i * 3 );

                    testPoint( position, i );

                }

            }

        }
        else {

            var vertices = geometry.vertices;

            for ( var i = 0, l = vertices.length; i < l; i++ ) {

                testPoint( vertices[ i ], i );

            }

        }

    };

}() );

THREE.Points.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Points.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// Backwards compatibility

THREE.PointCloud = function( geometry, material ) {

    console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function( geometry, material ) {

    console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function( geometry, material, mode ) {

    if ( mode === 1 ) {

        console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
        return new THREE.LineSegments( geometry, material );

    }

    THREE.Object3D.call( this );

    this.type = 'Line';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.LineBasicMaterial( {
        color: Math.random() * 0xffffff
    } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    return function raycast( raycaster, intersects ) {

        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;

        var geometry = this.geometry;

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        // Checking boundingSphere distance to ray

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this instanceof THREE.LineSegments ? 2 : 1;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

                    var a = indices[ i ];
                    var b = indices[ i + 1 ];

                    vStart.fromArray( positions, a * 3 );
                    vEnd.fromArray( positions, b * 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }
            else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

                    vStart.fromArray( positions, 3 * i );
                    vEnd.fromArray( positions, 3 * i + 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }

        }
        else if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;
            var nbVertices = vertices.length;

            for ( var i = 0; i < nbVertices - 1; i += step ) {

                var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

                if ( distSq > precisionSq ) continue;

                interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                var distance = raycaster.ray.origin.distanceTo( interRay );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                intersects.push( {

                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Line.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Line.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function( geometry, material ) {

    THREE.Line.call( this, geometry, material );

    this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Mesh';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( {
        color: Math.random() * 0xffffff
    } );

    this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function() {

    if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

        this.morphTargetBase = -1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};

        for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++ ) {

            this.morphTargetInfluences.push( 0 );
            this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

        }

    }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function( name ) {

    if ( this.morphTargetDictionary[ name ] !== undefined ) {

        return this.morphTargetDictionary[ name ];

    }

    console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

    return 0;

};


THREE.Mesh.prototype.raycast = ( function() {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var tempA = new THREE.Vector3();
    var tempB = new THREE.Vector3();
    var tempC = new THREE.Vector3();

    var uvA = new THREE.Vector2();
    var uvB = new THREE.Vector2();
    var uvC = new THREE.Vector2();

    var barycoord = new THREE.Vector3();

    var intersectionPoint = new THREE.Vector3();
    var intersectionPointWorld = new THREE.Vector3();

    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

        uv1.multiplyScalar( barycoord.x );
        uv2.multiplyScalar( barycoord.y );
        uv3.multiplyScalar( barycoord.z );

        uv1.add( uv2 ).add( uv3 );

        return uv1.clone();

    }

    return function raycast( raycaster, intersects ) {

        var geometry = this.geometry;
        var material = this.material;

        if ( material === undefined ) return;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        // Check boundingBox before continuing

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var a, b, c;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                    a = indices[ i ];
                    b = indices[ i + 1 ];
                    c = indices[ i + 2 ];

                    vA.fromArray( positions, a * 3 );
                    vB.fromArray( positions, b * 3 );
                    vC.fromArray( positions, c * 3 );

                    if ( material.side === THREE.BackSide ) {

                        if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

                    }
                    else {

                        if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                    }

                    intersectionPointWorld.copy( intersectionPoint );
                    intersectionPointWorld.applyMatrix4( this.matrixWorld );

                    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    var uv;

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;
                        uvA.fromArray( uvs, a * 2 );
                        uvB.fromArray( uvs, b * 2 );
                        uvC.fromArray( uvs, c * 2 );
                        uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

                    }

                    intersects.push( {

                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        uv: uv,
                        face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
                        faceIndex: Math.floor( i / 3 ), // triangle number in indices buffer semantics
                        object: this

                    } );

                }

            }
            else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length; i < l; i += 9 ) {

                    vA.fromArray( positions, i );
                    vB.fromArray( positions, i + 3 );
                    vC.fromArray( positions, i + 6 );

                    if ( material.side === THREE.BackSide ) {

                        if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

                    }
                    else {

                        if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                    }

                    intersectionPointWorld.copy( intersectionPoint );
                    intersectionPointWorld.applyMatrix4( this.matrixWorld );

                    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    var uv;

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;
                        uvA.fromArray( uvs, i );
                        uvB.fromArray( uvs, i + 2 );
                        uvC.fromArray( uvs, i + 4 );
                        uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

                    }

                    a = i / 3;
                    b = a + 1;
                    c = a + 2;

                    intersects.push( {

                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        uv: uv,
                        face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
                        index: a, // triangle number in positions buffer semantics
                        object: this

                    } );

                }

            }

        }
        else if ( geometry instanceof THREE.Geometry ) {

            var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
            var materials = isFaceMaterial === true ? material.materials : null;

            var vertices = geometry.vertices;
            var faces = geometry.faces;

            for ( var f = 0, fl = faces.length; f < fl; f++ ) {

                var face = faces[ f ];
                var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

                if ( faceMaterial === undefined ) continue;

                a = vertices[ face.a ];
                b = vertices[ face.b ];
                c = vertices[ face.c ];

                if ( faceMaterial.morphTargets === true ) {

                    var morphTargets = geometry.morphTargets;
                    var morphInfluences = this.morphTargetInfluences;

                    vA.set( 0, 0, 0 );
                    vB.set( 0, 0, 0 );
                    vC.set( 0, 0, 0 );

                    for ( var t = 0, tl = morphTargets.length; t < tl; t++ ) {

                        var influence = morphInfluences[ t ];

                        if ( influence === 0 ) continue;

                        var targets = morphTargets[ t ].vertices;

                        vA.addScaledVector( tempA.subVectors( targets[ face.a ], a ), influence );
                        vB.addScaledVector( tempB.subVectors( targets[ face.b ], b ), influence );
                        vC.addScaledVector( tempC.subVectors( targets[ face.c ], c ), influence );

                    }

                    vA.add( a );
                    vB.add( b );
                    vC.add( c );

                    a = vA;
                    b = vB;
                    c = vC;

                }

                if ( faceMaterial.side === THREE.BackSide ) {

                    if ( ray.intersectTriangle( c, b, a, true, intersectionPoint ) === null ) continue;

                }
                else {

                    if ( ray.intersectTriangle( a, b, c, faceMaterial.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

                }

                intersectionPointWorld.copy( intersectionPoint );
                intersectionPointWorld.applyMatrix4( this.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                var uv;

                if ( geometry.faceVertexUvs[ 0 ].length > 0 ) {

                    var uvs = geometry.faceVertexUvs[ 0 ][ f ];
                    uvA.copy( uvs[ 0 ] );
                    uvB.copy( uvs[ 1 ] );
                    uvC.copy( uvs[ 2 ] );
                    uv = uvIntersection( intersectionPoint, a, b, c, uvA, uvB, uvC );

                }

                intersects.push( {

                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    uv: uv,
                    face: face,
                    faceIndex: f,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Mesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Mesh.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta geometries cache
    if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

    }

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

    }

    data.object.geometry = this.geometry.uuid;
    data.object.material = this.material.uuid;

    return data;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function( skin ) {

    THREE.Object3D.call( this );

    this.type = 'Bone';

    this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.skin = source.skin;

    return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function( bones, boneInverses, useVertexTexture ) {

    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    this.identityMatrix = new THREE.Matrix4();

    // copy the bone array

    bones = bones || [];

    this.bones = bones.slice( 0 );

    // create a bone texture or an array of floats

    if ( this.useVertexTexture ) {

        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


        var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
        size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
        size = Math.max( size, 4 );

        this.boneTextureWidth = size;
        this.boneTextureHeight = size;

        this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
        this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

    }
    else {

        this.boneMatrices = new Float32Array( 16 * this.bones.length );

    }

    // use the supplied bone inverses or calculate the inverses

    if ( boneInverses === undefined ) {

        this.calculateInverses();

    }
    else {

        if ( this.bones.length === boneInverses.length ) {

            this.boneInverses = boneInverses.slice( 0 );

        }
        else {

            console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

            this.boneInverses = [];

            for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

                this.boneInverses.push( new THREE.Matrix4() );

            }

        }

    }

};

THREE.Skeleton.prototype.calculateInverses = function() {

    this.boneInverses = [];

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        var inverse = new THREE.Matrix4();

        if ( this.bones[ b ] ) {

            inverse.getInverse( this.bones[ b ].matrixWorld );

        }

        this.boneInverses.push( inverse );

    }

};

THREE.Skeleton.prototype.pose = function() {

    var bone;

    // recover the bind-time world matrices

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            bone.matrixWorld.getInverse( this.boneInverses[ b ] );

        }

    }

    // compute the local matrices, positions, rotations and scales

    for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            if ( bone.parent ) {

                bone.matrix.getInverse( bone.parent.matrixWorld );
                bone.matrix.multiply( bone.matrixWorld );

            }
            else {

                bone.matrix.copy( bone.matrixWorld );

            }

            bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

        }

    }

};

THREE.Skeleton.prototype.update = ( function() {

    var offsetMatrix = new THREE.Matrix4();

    return function update() {

        // flatten bone matrices to array

        for ( var b = 0, bl = this.bones.length; b < bl; b++ ) {

            // compute the offset between the current and the original transform

            var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

            offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
            offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

        }

        if ( this.useVertexTexture ) {

            this.boneTexture.needsUpdate = true;

        }

    };

} )();

THREE.Skeleton.prototype.clone = function() {

    return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function( geometry, material, useVertexTexture ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'SkinnedMesh';

    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();

    // init bones

    // TODO: remove bone creation as there is no reason (other than
    // convenience) for THREE.SkinnedMesh to do this.

    var bones = [];

    if ( this.geometry && this.geometry.bones !== undefined ) {

        var bone, gbone;

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

            gbone = this.geometry.bones[ b ];

            bone = new THREE.Bone( this );
            bones.push( bone );

            bone.name = gbone.name;
            bone.position.fromArray( gbone.pos );
            bone.quaternion.fromArray( gbone.rotq );
            if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

        }

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

            gbone = this.geometry.bones[ b ];

            if ( gbone.parent !== -1 ) {

                bones[ gbone.parent ].add( bones[ b ] );

            }
            else {

                this.add( bones[ b ] );

            }

        }

    }

    this.normalizeSkinWeights();

    this.updateMatrixWorld( true );
    this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

    this.skeleton = skeleton;

    if ( bindMatrix === undefined ) {

        this.updateMatrixWorld( true );

        this.skeleton.calculateInverses();

        bindMatrix = this.matrixWorld;

    }

    this.bindMatrix.copy( bindMatrix );
    this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function() {

    this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {

    if ( this.geometry instanceof THREE.Geometry ) {

        for ( var i = 0; i < this.geometry.skinIndices.length; i++ ) {

            var sw = this.geometry.skinWeights[ i ];

            var scale = 1.0 / sw.lengthManhattan();

            if ( scale !== Infinity ) {

                sw.multiplyScalar( scale );

            }
            else {

                sw.set( 1 ); // this will be normalized by the shader anyway

            }

        }

    }
    else {

        // skinning weights assumed to be normalized for THREE.BufferGeometry

    }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

    THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

    if ( this.bindMode === "attached" ) {

        this.bindMatrixInverse.getInverse( this.matrixWorld );

    }
    else if ( this.bindMode === "detached" ) {

        this.bindMatrixInverse.getInverse( this.bindMatrix );

    }
    else {

        console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    }

};

THREE.SkinnedMesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'MorphAnimMesh';

    // API

    this.duration = 1000; // milliseconds
    this.mirroredLoop = false;
    this.time = 0;

    // internals

    this.lastKeyframe = 0;
    this.currentKeyframe = 0;

    this.direction = 1;
    this.directionBackwards = false;

    this.setFrameRange( 0, geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function( start, end ) {

    this.startKeyframe = start;
    this.endKeyframe = end;

    this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function() {

    this.direction = 1;
    this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {

    this.direction = -1;
    this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function() {

    var geometry = this.geometry;

    if ( !geometry.animations ) geometry.animations = {};

    var firstAnimation, animations = geometry.animations;

    var pattern = /([a-z]+)_?(\d+)/;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i++ ) {

        var morph = geometry.morphTargets[ i ];
        var parts = morph.name.match( pattern );

        if ( parts && parts.length > 1 ) {

            var label = parts[ 1 ];

            if ( !animations[ label ] ) animations[ label ] = {
                start: Infinity,
                end: -Infinity
            };

            var animation = animations[ label ];

            if ( i < animation.start ) animation.start = i;
            if ( i > animation.end ) animation.end = i;

            if ( !firstAnimation ) firstAnimation = label;

        }

    }

    geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function( label, start, end ) {

    if ( !this.geometry.animations ) this.geometry.animations = {};

    this.geometry.animations[ label ] = {
        start: start,
        end: end
    };

};

THREE.MorphAnimMesh.prototype.playAnimation = function( label, fps ) {

    var animation = this.geometry.animations[ label ];

    if ( animation ) {

        this.setFrameRange( animation.start, animation.end );
        this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
        this.time = 0;

    }
    else {

        console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

    }

};

THREE.MorphAnimMesh.prototype.updateAnimation = function( delta ) {

    var frameTime = this.duration / this.length;

    this.time += this.direction * delta;

    if ( this.mirroredLoop ) {

        if ( this.time > this.duration || this.time < 0 ) {

            this.direction *= -1;

            if ( this.time > this.duration ) {

                this.time = this.duration;
                this.directionBackwards = true;

            }

            if ( this.time < 0 ) {

                this.time = 0;
                this.directionBackwards = false;

            }

        }

    }
    else {

        this.time = this.time % this.duration;

        if ( this.time < 0 ) this.time += this.duration;

    }

    var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

    var influences = this.morphTargetInfluences;

    if ( keyframe !== this.currentKeyframe ) {

        influences[ this.lastKeyframe ] = 0;
        influences[ this.currentKeyframe ] = 1;
        influences[ keyframe ] = 0;

        this.lastKeyframe = this.currentKeyframe;
        this.currentKeyframe = keyframe;

    }

    var mix = ( this.time % frameTime ) / frameTime;

    if ( this.directionBackwards ) {

        mix = 1 - mix;

    }

    influences[ this.currentKeyframe ] = mix;
    influences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function( a, b, t ) {

    var influences = this.morphTargetInfluences;

    for ( var i = 0, l = influences.length; i < l; i++ ) {

        influences[ i ] = 0;

    }

    if ( a > -1 ) influences[ a ] = 1 - t;
    if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.copy = function( source ) {

    THREE.Mesh.prototype.copy.call( this, source );

    this.duration = source.duration;
    this.mirroredLoop = source.mirroredLoop;
    this.time = source.time;

    this.lastKeyframe = source.lastKeyframe;
    this.currentKeyframe = source.currentKeyframe;

    this.direction = source.direction;
    this.directionBackwards = source.directionBackwards;

    return this;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function() {

    THREE.Object3D.call( this );

    this.type = 'LOD';

    Object.defineProperties( this, {
        levels: {
            enumerable: true,
            value: []
        },
        objects: {
            get: function() {

                console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
                return this.levels;

            }
        }
    } );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function( object, distance ) {

    if ( distance === undefined ) distance = 0;

    distance = Math.abs( distance );

    var levels = this.levels;

    for ( var l = 0; l < levels.length; l++ ) {

        if ( distance < levels[ l ].distance ) {

            break;

        }

    }

    levels.splice( l, 0, {
        distance: distance,
        object: object
    } );

    this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function( distance ) {

    var levels = this.levels;

    for ( var i = 1, l = levels.length; i < l; i++ ) {

        if ( distance < levels[ i ].distance ) {

            break;

        }

    }

    return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function() {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( matrixPosition );

        this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    };

}() );

THREE.LOD.prototype.update = function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function update( camera ) {

        var levels = this.levels;

        if ( levels.length > 1 ) {

            v1.setFromMatrixPosition( camera.matrixWorld );
            v2.setFromMatrixPosition( this.matrixWorld );

            var distance = v1.distanceTo( v2 );

            levels[ 0 ].object.visible = true;

            for ( var i = 1, l = levels.length; i < l; i++ ) {

                if ( distance >= levels[ i ].distance ) {

                    levels[ i - 1 ].object.visible = false;
                    levels[ i ].object.visible = true;

                }
                else {

                    break;

                }

            }

            for ( ; i < l; i++ ) {

                levels[ i ].object.visible = false;

            }

        }

    };

}();

THREE.LOD.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source, false );

    var levels = source.levels;

    for ( var i = 0, l = levels.length; i < l; i++ ) {

        var level = levels[ i ];

        this.addLevel( level.object.clone(), level.distance );

    }

    return this;

};

THREE.LOD.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.levels = [];

    var levels = this.levels;

    for ( var i = 0, l = levels.length; i < l; i++ ) {

        var level = levels[ i ];

        data.object.levels.push( {
            object: level.object.uuid,
            distance: level.distance
        } );

    }

    return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function() {

    var indices = new Uint16Array( [ 0, 1, 2, 0, 2, 3 ] );
    var vertices = new Float32Array( [ -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0 ] );
    var uvs = new Float32Array( [ 0, 0, 1, 0, 1, 1, 0, 1 ] );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    return function Sprite( material ) {

        THREE.Object3D.call( this );

        this.type = 'Sprite';

        this.geometry = geometry;
        this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

    };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function() {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
        var guessSizeSq = this.scale.x * this.scale.y;

        if ( distanceSq > guessSizeSq ) {

            return;

        }

        intersects.push( {

            distance: Math.sqrt( distanceSq ),
            point: this.position,
            face: null,
            object: this

        } );

    };

}() );

THREE.Sprite.prototype.clone = function() {

    return new this.constructor( this.material ).copy( this );

};

THREE.Sprite.prototype.toJSON = function( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    // only serialize if not in meta materials cache
    if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON();

    }

    data.object.material = this.material.uuid;

    return data;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function( texture, size, distance, blending, color ) {

    THREE.Object3D.call( this );

    this.lensFlares = [];

    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;

    if ( texture !== undefined ) {

        this.add( texture, size, distance, blending, color );

    }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function( texture, size, distance, blending, color, opacity ) {

    if ( size === undefined ) size = -1;
    if ( distance === undefined ) distance = 0;
    if ( opacity === undefined ) opacity = 1;
    if ( color === undefined ) color = new THREE.Color( 0xffffff );
    if ( blending === undefined ) blending = THREE.NormalBlending;

    distance = Math.min( distance, Math.max( 0, distance ) );

    this.lensFlares.push( {
        texture: texture, // THREE.Texture
        size: size, // size in pixels (-1 = use texture.width)
        distance: distance, // distance (0-1) from light source (0=at light source)
        x: 0,
        y: 0,
        z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back
        scale: 1, // scale
        rotation: 0, // rotation
        opacity: opacity, // opacity
        color: color, // color
        blending: blending // blending
    } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function() {

    var f, fl = this.lensFlares.length;
    var flare;
    var vecX = -this.positionScreen.x * 2;
    var vecY = -this.positionScreen.y * 2;

    for ( f = 0; f < fl; f++ ) {

        flare = this.lensFlares[ f ];

        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;

        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    }

};

THREE.LensFlare.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.positionScreen.copy( source.positionScreen );
    this.customUpdateCallback = source.customUpdateCallback;

    for ( var i = 0, l = source.lensFlares.length; i < l; i++ ) {

        this.lensFlares.push( source.lensFlares[ i ] );

    }

    return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function() {

    THREE.Object3D.call( this );

    this.type = 'Scene';

    this.fog = null;
    this.overrideMaterial = null;

    this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    if ( source.fog !== null ) this.fog = source.fog.clone();
    if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;

    return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function( color, near, far ) {

    this.name = '';

    this.color = new THREE.Color( color );

    this.near = ( near !== undefined ) ? near : 1;
    this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function() {

    return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function( color, density ) {

    this.name = '';

    this.color = new THREE.Color( color );
    this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function() {

    return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment' ] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment' ] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment' ] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment' ] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment' ] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex' ] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex' ] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment' ] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment' ] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex' ] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex' ] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common' ] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n	// Original approximation by Christophe Schlick '94\n	//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n	// geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n	// factor of 1/PI in distribution term omitted\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	//float dotNL = saturate( dot( normal, lightDir ) );\n	//float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex' ] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment' ] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment' ] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment' ] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment' ] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment' ] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment' ] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment' ] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex' ] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex' ] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment' ] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n			// specular\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += lightColor;\n\n		// specular (sky term only)\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex' ] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment' ] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment' ] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment' ] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment' ] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment' ] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment' ] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment' ] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex' ] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment' ] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n		#endif\n\n	}\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex' ] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex' ] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex' ] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex' ] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex' ] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment' ] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment' ] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex' ] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

    merge: function( uniforms ) {

        var merged = {};

        for ( var u = 0; u < uniforms.length; u++ ) {

            var tmp = this.clone( uniforms[ u ] );

            for ( var p in tmp ) {

                merged[ p ] = tmp[ p ];

            }

        }

        return merged;

    },

    clone: function( uniforms_src ) {

        var uniforms_dst = {};

        for ( var u in uniforms_src ) {

            uniforms_dst[ u ] = {};

            for ( var p in uniforms_src[ u ] ) {

                var parameter_src = uniforms_src[ u ][ p ];

                if ( parameter_src instanceof THREE.Color ||
                    parameter_src instanceof THREE.Vector2 ||
                    parameter_src instanceof THREE.Vector3 ||
                    parameter_src instanceof THREE.Vector4 ||
                    parameter_src instanceof THREE.Matrix3 ||
                    parameter_src instanceof THREE.Matrix4 ||
                    parameter_src instanceof THREE.Texture ) {

                    uniforms_dst[ u ][ p ] = parameter_src.clone();

                }
                else if ( Array.isArray( parameter_src ) ) {

                    uniforms_dst[ u ][ p ] = parameter_src.slice();

                }
                else {

                    uniforms_dst[ u ][ p ] = parameter_src;

                }

            }

        }

        return uniforms_dst;

    }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

    common: {

        "diffuse": {
            type: "c",
            value: new THREE.Color( 0xeeeeee )
        },
        "opacity": {
            type: "f",
            value: 1.0
        },

        "map": {
            type: "t",
            value: null
        },
        "offsetRepeat": {
            type: "v4",
            value: new THREE.Vector4( 0, 0, 1, 1 )
        },

        "specularMap": {
            type: "t",
            value: null
        },
        "alphaMap": {
            type: "t",
            value: null
        },

        "envMap": {
            type: "t",
            value: null
        },
        "flipEnvMap": {
            type: "f",
            value: -1
        },
        "reflectivity": {
            type: "f",
            value: 1.0
        },
        "refractionRatio": {
            type: "f",
            value: 0.98
        }

    },

    aomap: {

        "aoMap": {
            type: "t",
            value: null
        },
        "aoMapIntensity": {
            type: "f",
            value: 1
        },

    },

    lightmap: {

        "lightMap": {
            type: "t",
            value: null
        },
        "lightMapIntensity": {
            type: "f",
            value: 1
        },

    },

    emissivemap: {

        "emissiveMap": {
            type: "t",
            value: null
        },

    },

    bumpmap: {

        "bumpMap": {
            type: "t",
            value: null
        },
        "bumpScale": {
            type: "f",
            value: 1
        }

    },

    normalmap: {

        "normalMap": {
            type: "t",
            value: null
        },
        "normalScale": {
            type: "v2",
            value: new THREE.Vector2( 1, 1 )
        }

    },

    displacementmap: {

        "displacementMap": {
            type: "t",
            value: null
        },
        "displacementScale": {
            type: "f",
            value: 1
        },
        "displacementBias": {
            type: "f",
            value: 0
        }

    },

    fog: {

        "fogDensity": {
            type: "f",
            value: 0.00025
        },
        "fogNear": {
            type: "f",
            value: 1
        },
        "fogFar": {
            type: "f",
            value: 2000
        },
        "fogColor": {
            type: "c",
            value: new THREE.Color( 0xffffff )
        }

    },

    lights: {

        "ambientLightColor": {
            type: "fv",
            value: []
        },

        "directionalLightDirection": {
            type: "fv",
            value: []
        },
        "directionalLightColor": {
            type: "fv",
            value: []
        },

        "hemisphereLightDirection": {
            type: "fv",
            value: []
        },
        "hemisphereLightSkyColor": {
            type: "fv",
            value: []
        },
        "hemisphereLightGroundColor": {
            type: "fv",
            value: []
        },

        "pointLightColor": {
            type: "fv",
            value: []
        },
        "pointLightPosition": {
            type: "fv",
            value: []
        },
        "pointLightDistance": {
            type: "fv1",
            value: []
        },
        "pointLightDecay": {
            type: "fv1",
            value: []
        },

        "spotLightColor": {
            type: "fv",
            value: []
        },
        "spotLightPosition": {
            type: "fv",
            value: []
        },
        "spotLightDirection": {
            type: "fv",
            value: []
        },
        "spotLightDistance": {
            type: "fv1",
            value: []
        },
        "spotLightAngleCos": {
            type: "fv1",
            value: []
        },
        "spotLightExponent": {
            type: "fv1",
            value: []
        },
        "spotLightDecay": {
            type: "fv1",
            value: []
        }

    },

    points: {

        "psColor": {
            type: "c",
            value: new THREE.Color( 0xeeeeee )
        },
        "opacity": {
            type: "f",
            value: 1.0
        },
        "size": {
            type: "f",
            value: 1.0
        },
        "scale": {
            type: "f",
            value: 1.0
        },
        "map": {
            type: "t",
            value: null
        },
        "offsetRepeat": {
            type: "v4",
            value: new THREE.Vector4( 0, 0, 1, 1 )
        },

        "fogDensity": {
            type: "f",
            value: 0.00025
        },
        "fogNear": {
            type: "f",
            value: 1
        },
        "fogFar": {
            type: "f",
            value: 2000
        },
        "fogColor": {
            type: "c",
            value: new THREE.Color( 0xffffff )
        }

    },

    shadowmap: {

        "shadowMap": {
            type: "tv",
            value: []
        },
        "shadowMapSize": {
            type: "v2v",
            value: []
        },

        "shadowBias": {
            type: "fv1",
            value: []
        },
        "shadowDarkness": {
            type: "fv1",
            value: []
        },

        "shadowMatrix": {
            type: "m4v",
            value: []
        }

    }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

    'basic': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],

            "	#ifdef USE_ENVMAP",

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "	#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],

            "	outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ], // TODO: Shadows on an otherwise unlit surface doesn't make sense.

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'lambert': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive": {
                    type: "c",
                    value: new THREE.Color( 0x000000 )
                }
            }

        ] ),

        vertexShader: [

            "#define LAMBERT",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform float opacity;",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],

            "	#ifdef DOUBLE_SIDED",

            "		if ( gl_FrontFacing )",
            "			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
            "		else",
            "			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

            "	#else",

            "		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

            "	#endif",

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'phong': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "lightmap" ],
            THREE.UniformsLib[ "emissivemap" ],
            THREE.UniformsLib[ "bumpmap" ],
            THREE.UniformsLib[ "normalmap" ],
            THREE.UniformsLib[ "displacementmap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive": {
                    type: "c",
                    value: new THREE.Color( 0x000000 )
                },
                "specular": {
                    type: "c",
                    value: new THREE.Color( 0x111111 )
                },
                "shininess": {
                    type: "f",
                    value: 30
                }
            }

        ] ),

        vertexShader: [

            "#define PHONG",

            "varying vec3 vViewPosition;",

            "#ifndef FLAT_SHADED",

            "	varying vec3 vNormal;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

            "	vNormal = normalize( transformedNormal );",

            "#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "displacementmap_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "	vViewPosition = - mvPosition.xyz;",

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_phong_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "#define PHONG",

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "lightmap_pars_fragment" ],
            THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
            THREE.ShaderChunk[ "normalmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = ambientLightColor;",
            "	vec3 totalEmissiveLight = emissive;",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "lightmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],
            THREE.ShaderChunk[ "emissivemap_fragment" ],

            THREE.ShaderChunk[ "lights_phong_fragment" ],

            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'points': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "points" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            "uniform float size;",
            "uniform float scale;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

            "	#ifdef USE_SIZEATTENUATION",
            "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
            "	#else",
            "		gl_PointSize = size;",
            "	#endif",

            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],
            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 psColor;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "map_particle_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( psColor, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_particle_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "shadowmap_fragment" ],
            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'dashed': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],

            {
                "scale": {
                    type: "f",
                    value: 1
                },
                "dashSize": {
                    type: "f",
                    value: 1
                },
                "totalSize": {
                    type: "f",
                    value: 2
                }
            }

        ] ),

        vertexShader: [

            "uniform float scale;",
            "attribute float lineDistance;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vLineDistance = scale * lineDistance;",

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            "uniform float dashSize;",
            "uniform float totalSize;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

            "		discard;",

            "	}",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'depth': {

        uniforms: {

            "mNear": {
                type: "f",
                value: 1.0
            },
            "mFar": {
                type: "f",
                value: 2000.0
            },
            "opacity": {
                type: "f",
                value: 1.0
            }

        },

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float mNear;",
            "uniform float mFar;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

            "	#else",

            "		float depth = gl_FragCoord.z / gl_FragCoord.w;",

            "	#endif",

            "	float color = 1.0 - smoothstep( mNear, mFar, depth );",
            "	gl_FragColor = vec4( vec3( color ), opacity );",

            "}"

        ].join( "\n" )

    },

    'normal': {

        uniforms: {

            "opacity": {
                type: "f",
                value: 1.0
            }

        },

        vertexShader: [

            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vNormal = normalize( normalMatrix * normal );",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float opacity;",
            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

    'cube': {

        uniforms: {
            "tCube": {
                type: "t",
                value: null
            },
            "tFlip": {
                type: "f",
                value: -1
            }
        },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform samplerCube tCube;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

    'equirect': {

        uniforms: {
            "tEquirect": {
                type: "t",
                value: null
            },
            "tFlip": {
                type: "f",
                value: -1
            }
        },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform sampler2D tEquirect;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            // "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            "vec3 direction = normalize( vWorldPosition );",
            "vec2 sampleUV;",
            "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
            "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
            "gl_FragColor = texture2D( tEquirect, sampleUV );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* Depth encoding into RGBA texture
     *
     * based on SpiderGL shadow map example
     * http://spidergl.org/example.php?id=6
     *
     * originally from
     * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
     *
     * see also
     * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
     */

    'depthRGBA': {

        uniforms: {},

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "skinbase_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "vec4 pack_depth( const in float depth ) {",

            "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
            "	res -= res.xxyz * bit_mask;",
            "	return res;",

            "}",

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

            "	#else",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

            "	#endif",

            //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
            //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
            //"gl_FragData[ 0 ] = pack_depth( z );",
            //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

            "}"

        ].join( "\n" )

    }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function( parameters ) {

    console.log( 'THREE.WebGLRenderer', THREE.REVISION );

    parameters = parameters || {};

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
        _context = parameters.context !== undefined ? parameters.context : null,

        _width = _canvas.width,
        _height = _canvas.height,

        pixelRatio = 1,

        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

        _clearColor = new THREE.Color( 0x000000 ),
        _clearAlpha = 0;

    var lights = [];

    var opaqueObjects = [];
    var opaqueObjectsLastIndex = -1;
    var transparentObjects = [];
    var transparentObjectsLastIndex = -1;

    var opaqueImmediateObjects = [];
    var opaqueImmediateObjectsLastIndex = -1;
    var transparentImmediateObjects = [];
    var transparentImmediateObjectsLastIndex = -1;

    var morphInfluences = new Float32Array( 8 );


    var sprites = [];
    var lensFlares = [];

    // public properties

    this.domElement = _canvas;
    this.context = null;

    // clearing

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;

    // scene graph

    this.sortObjects = true;

    // physically based shading

    this.gammaFactor = 2.0; // for backwards compatibility
    this.gammaInput = false;
    this.gammaOutput = false;

    // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;

    // flags

    this.autoScaleCubemaps = true;

    // internal properties

    var _this = this,

        // internal state cache

        _currentProgram = null,
        _currentFramebuffer = null,
        _currentMaterialId = -1,
        _currentGeometryProgram = '',
        _currentCamera = null,

        _usedTextureUnits = 0,

        _viewportX = 0,
        _viewportY = 0,
        _viewportWidth = _canvas.width,
        _viewportHeight = _canvas.height,
        _currentWidth = 0,
        _currentHeight = 0,

        // frustum

        _frustum = new THREE.Frustum(),

        // camera matrices cache

        _projScreenMatrix = new THREE.Matrix4(),

        _vector3 = new THREE.Vector3(),

        // light arrays cache

        _direction = new THREE.Vector3(),

        _lightsNeedUpdate = true,

        _lights = {

            ambient: [ 0, 0, 0 ],
            directional: {
                length: 0,
                colors: [],
                positions: []
            },
            point: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                decays: []
            },
            spot: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                directions: [],
                anglesCos: [],
                exponents: [],
                decays: []
            },
            hemi: {
                length: 0,
                skyColors: [],
                groundColors: [],
                positions: []
            }

        },

        // info

        _infoMemory = {

            geometries: 0,
            textures: 0

        },

        _infoRender = {

            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0

        };

    this.info = {

        render: _infoRender,
        memory: _infoMemory,
        programs: null

    };


    // initialize

    var _gl;

    try {

        var attributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer
        };

        _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

        if ( _gl === null ) {

            if ( _canvas.getContext( 'webgl' ) !== null ) {

                throw 'Error creating WebGL context with your selected attributes.';

            }
            else {

                throw 'Error creating WebGL context.';

            }

        }

        _canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    }
    catch ( error ) {

        console.error( 'THREE.WebGLRenderer: ' + error );

    }

    var extensions = new THREE.WebGLExtensions( _gl );

    extensions.get( 'OES_texture_float' );
    extensions.get( 'OES_texture_float_linear' );
    extensions.get( 'OES_texture_half_float' );
    extensions.get( 'OES_texture_half_float_linear' );
    extensions.get( 'OES_standard_derivatives' );
    extensions.get( 'ANGLE_instanced_arrays' );

    if ( extensions.get( 'OES_element_index_uint' ) ) {

        THREE.BufferGeometry.MaxIndex = 4294967296;

    }

    var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

    var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
    var properties = new THREE.WebGLProperties();
    var objects = new THREE.WebGLObjects( _gl, properties, this.info );
    var programCache = new THREE.WebGLPrograms( this, capabilities );

    this.info.programs = programCache.programs;

    var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
    var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    //

    function glClearColor( r, g, b, a ) {

        if ( _premultipliedAlpha === true ) {

            r *= a;
            g *= a;
            b *= a;

        }

        _gl.clearColor( r, g, b, a );

    }

    function setDefaultGLState() {

        state.init();

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    }

    function resetGLState() {

        _currentProgram = null;
        _currentCamera = null;

        _currentGeometryProgram = '';
        _currentMaterialId = -1;

        _lightsNeedUpdate = true;

        state.reset();

    }

    setDefaultGLState();

    this.context = _gl;
    this.capabilities = capabilities;
    this.extensions = extensions;
    this.state = state;

    // shadow map

    var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

    this.shadowMap = shadowMap;


    // Plugins

    var spritePlugin = new THREE.SpritePlugin( this, sprites );
    var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

    // API

    this.getContext = function() {

        return _gl;

    };

    this.getContextAttributes = function() {

        return _gl.getContextAttributes();

    };

    this.forceContextLoss = function() {

        extensions.get( 'WEBGL_lose_context' ).loseContext();

    };

    this.getMaxAnisotropy = ( function() {

        var value;

        return function getMaxAnisotropy() {

            if ( value !== undefined ) return value;

            var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

            if ( extension !== null ) {

                value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

            }
            else {

                value = 0;

            }

            return value;

        }

    } )();

    this.getPrecision = function() {

        return capabilities.precision;

    };

    this.getPixelRatio = function() {

        return pixelRatio;

    };

    this.setPixelRatio = function( value ) {

        if ( value !== undefined ) pixelRatio = value;

    };

    this.getSize = function() {

        return {
            width: _width,
            height: _height
        };

    };

    this.setSize = function( width, height, updateStyle ) {

        _width = width;
        _height = height;

        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;

        if ( updateStyle !== false ) {

            _canvas.style.width = width + 'px';
            _canvas.style.height = height + 'px';

        }

        this.setViewport( 0, 0, width, height );

    };

    this.setViewport = function( x, y, width, height ) {

        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;

        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    };

    this.setScissor = function( x, y, width, height ) {

        _gl.scissor(
            x * pixelRatio,
            y * pixelRatio,
            width * pixelRatio,
            height * pixelRatio
        );

    };

    this.enableScissorTest = function( boolean ) {

        state.setScissorTest( boolean );

    };

    // Clearing

    this.getClearColor = function() {

        return _clearColor;

    };

    this.setClearColor = function( color, alpha ) {

        _clearColor.set( color );

        _clearAlpha = alpha !== undefined ? alpha : 1;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.getClearAlpha = function() {

        return _clearAlpha;

    };

    this.setClearAlpha = function( alpha ) {

        _clearAlpha = alpha;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.clear = function( color, depth, stencil ) {

        var bits = 0;

        if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
        if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
        if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

        _gl.clear( bits );

    };

    this.clearColor = function() {

        _gl.clear( _gl.COLOR_BUFFER_BIT );

    };

    this.clearDepth = function() {

        _gl.clear( _gl.DEPTH_BUFFER_BIT );

    };

    this.clearStencil = function() {

        _gl.clear( _gl.STENCIL_BUFFER_BIT );

    };

    this.clearTarget = function( renderTarget, color, depth, stencil ) {

        this.setRenderTarget( renderTarget );
        this.clear( color, depth, stencil );

    };

    // Reset

    this.resetGLState = resetGLState;

    this.dispose = function() {

        _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    };

    // Events

    function onContextLost( event ) {

        event.preventDefault();

        resetGLState();
        setDefaultGLState();

        properties.clear();

    };

    function onTextureDispose( event ) {

        var texture = event.target;

        texture.removeEventListener( 'dispose', onTextureDispose );

        deallocateTexture( texture );

        _infoMemory.textures--;


    }

    function onRenderTargetDispose( event ) {

        var renderTarget = event.target;

        renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

        deallocateRenderTarget( renderTarget );

        _infoMemory.textures--;

    }

    function onMaterialDispose( event ) {

        var material = event.target;

        material.removeEventListener( 'dispose', onMaterialDispose );

        deallocateMaterial( material );

    }

    // Buffer deallocation

    function deallocateTexture( texture ) {

        var textureProperties = properties.get( texture );

        if ( texture.image && textureProperties.__image__webglTextureCube ) {

            // cube texture

            _gl.deleteTexture( textureProperties.__image__webglTextureCube );

        }
        else {

            // 2D texture

            if ( textureProperties.__webglInit === undefined ) return;

            _gl.deleteTexture( textureProperties.__webglTexture );

        }

        // remove all webgl properties
        properties.delete( texture );

    }

    function deallocateRenderTarget( renderTarget ) {

        var renderTargetProperties = properties.get( renderTarget );

        if ( !renderTarget || renderTargetProperties.__webglTexture === undefined ) return;

        _gl.deleteTexture( renderTargetProperties.__webglTexture );

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            for ( var i = 0; i < 6; i++ ) {

                _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
                _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

            }

        }
        else {

            _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
            _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

        }

        properties.delete( renderTarget );

    }

    function deallocateMaterial( material ) {

        releaseMaterialProgramReference( material );

        properties.delete( material );

    }


    function releaseMaterialProgramReference( material ) {

        var programInfo = properties.get( material ).program;

        material.program = undefined;

        if ( programInfo !== undefined ) {

            programCache.releaseProgram( programInfo );
        }

    }

    // Buffer rendering

    this.renderBufferImmediate = function( object, program, material ) {

        state.initAttributes();

        var buffers = properties.get( object );

        if ( object.hasPositions && !buffers.position ) buffers.position = _gl.createBuffer();
        if ( object.hasNormals && !buffers.normal ) buffers.normal = _gl.createBuffer();
        if ( object.hasUvs && !buffers.uv ) buffers.uv = _gl.createBuffer();
        if ( object.hasColors && !buffers.color ) buffers.color = _gl.createBuffer();

        var attributes = program.getAttributes();

        if ( object.hasPositions ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.position );
            _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasNormals ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

            if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

                for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

                    var array = object.normalArray;

                    var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
                    var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
                    var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

                    array[ i + 0 ] = nx;
                    array[ i + 1 ] = ny;
                    array[ i + 2 ] = nz;

                    array[ i + 3 ] = nx;
                    array[ i + 4 ] = ny;
                    array[ i + 5 ] = nz;

                    array[ i + 6 ] = nx;
                    array[ i + 7 ] = ny;
                    array[ i + 8 ] = nz;

                }

            }

            _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.normal );

            _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasUvs && material.map ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.uv );

            _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.color );

            _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

        }

        state.disableUnusedAttributes();

        _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

        object.count = 0;

    };

    this.renderBufferDirect = function( camera, lights, fog, geometry, material, object, group ) {

        setMaterial( material );

        var program = setProgram( camera, lights, fog, material, object );

        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

        if ( geometryProgram !== _currentGeometryProgram ) {

            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;

        }

        // morph targets

        var morphTargetInfluences = object.morphTargetInfluences;

        if ( morphTargetInfluences !== undefined ) {

            var activeInfluences = [];

            for ( var i = 0, l = morphTargetInfluences.length; i < l; i++ ) {

                var influence = morphTargetInfluences[ i ];
                activeInfluences.push( [ influence, i ] );

            }

            activeInfluences.sort( numericalSort );

            if ( activeInfluences.length > 8 ) {

                activeInfluences.length = 8;

            }

            var morphAttributes = geometry.morphAttributes;

            for ( var i = 0, l = activeInfluences.length; i < l; i++ ) {

                var influence = activeInfluences[ i ];
                morphInfluences[ i ] = influence[ 0 ];

                if ( influence[ 0 ] !== 0 ) {

                    var index = influence[ 1 ];

                    if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
                    if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

                }
                else {

                    if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
                    if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

                }

            }

            var uniforms = program.getUniforms();

            if ( uniforms.morphTargetInfluences !== null ) {

                _gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

            }

            updateBuffers = true;

        }

        //

        var index = geometry.index;
        var position = geometry.attributes.position;

        if ( material.wireframe === true ) {

            index = objects.getWireframeAttribute( geometry );

        }

        var renderer;

        if ( index !== null ) {

            renderer = indexedBufferRenderer;
            renderer.setIndex( index );

        }
        else {

            renderer = bufferRenderer;

        }

        if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry );

            if ( index !== null ) {

                _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

            }

        }

        if ( group === undefined ) {

            var count;

            if ( index !== null ) {
                count = index.count;

            }
            else if ( position instanceof THREE.InterleavedBufferAttribute ) {

                count = position.data.array.length / 3;

            }
            else {
                count = position.count;

            }

            var drawRange = geometry.drawRange;

            group = {
                start: drawRange.start,
                count: Math.min( drawRange.count, count )
            };

        }

        if ( object instanceof THREE.Mesh ) {

            if ( material.wireframe === true ) {

                state.setLineWidth( material.wireframeLinewidth * pixelRatio );
                renderer.setMode( _gl.LINES );

            }
            else {

                renderer.setMode( _gl.TRIANGLES );

            }

            if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

                renderer.renderInstances( geometry );

            }
            else {

                renderer.render( group.start, group.count );

            }

        }
        else if ( object instanceof THREE.Line ) {

            var lineWidth = material.linewidth;

            if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

            state.setLineWidth( lineWidth * pixelRatio );

            if ( object instanceof THREE.LineSegments ) {

                renderer.setMode( _gl.LINES );

            }
            else {

                renderer.setMode( _gl.LINE_STRIP );

            }

            renderer.render( group.start, group.count );

        }
        else if ( object instanceof THREE.Points ) {
            renderer.setMode( _gl.POINTS );
            renderer.render( group.start, group.count );

        }

    };

    function setupVertexAttributes( material, program, geometry, startIndex ) {

        var extension;

        if ( geometry instanceof THREE.InstancedBufferGeometry ) {

            extension = extensions.get( 'ANGLE_instanced_arrays' );

            if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

            }

        }

        if ( startIndex === undefined ) startIndex = 0;

        state.initAttributes();

        var geometryAttributes = geometry.attributes;

        var programAttributes = program.getAttributes();

        var materialDefaultAttributeValues = material.defaultAttributeValues;

        for ( var name in programAttributes ) {

            var programAttribute = programAttributes[ name ];

            if ( programAttribute >= 0 ) {

                var geometryAttribute = geometryAttributes[ name ];

                if ( geometryAttribute !== undefined ) {

                    state.enableAttribute( programAttribute );

                    var size = geometryAttribute.itemSize;
                    var buffer = objects.getAttributeBuffer( geometryAttribute );

                    if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

                        if ( data instanceof THREE.InstancedInterleavedBuffer ) {

                            if ( extension === null ) {

                                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                                return;

                            }

                            extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;

                            }

                        }

                    }
                    else {

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

                        if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

                            if ( extension === null ) {

                                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                                return;

                            }

                            extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                            }

                        }

                    }

                }
                else if ( materialDefaultAttributeValues !== undefined ) {

                    var value = materialDefaultAttributeValues[ name ];

                    if ( value !== undefined ) {

                        switch ( value.length ) {

                            case 2:
                                _gl.vertexAttrib2fv( programAttribute, value );
                                break;

                            case 3:
                                _gl.vertexAttrib3fv( programAttribute, value );
                                break;

                            case 4:
                                _gl.vertexAttrib4fv( programAttribute, value );
                                break;

                            default:
                                _gl.vertexAttrib1fv( programAttribute, value );

                        }

                    }

                }

            }

        }

        state.disableUnusedAttributes();

    }

    // Sorting

    function numericalSort( a, b ) {

        return b[ 0 ] - a[ 0 ];

    }

    function painterSortStable( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        }
        else if ( a.material.id !== b.material.id ) {

            return a.material.id - b.material.id;

        }
        else if ( a.z !== b.z ) {

            return a.z - b.z;

        }
        else {

            return a.id - b.id;

        }

    }

    function reversePainterSortStable( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        }
        if ( a.z !== b.z ) {

            return b.z - a.z;

        }
        else {

            return a.id - b.id;

        }

    }

    // Rendering

    this.render = function( scene, camera, renderTarget, forceClear ) {

        if ( camera instanceof THREE.Camera === false ) {

            console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
            return;

        }

        var fog = scene.fog;

        // reset caching for this frame

        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;

        // update scene graph

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

        // update camera matrices and frustum

        if ( camera.parent === null ) camera.updateMatrixWorld();

        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        _frustum.setFromMatrix( _projScreenMatrix );

        lights.length = 0;

        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;

        opaqueImmediateObjectsLastIndex = -1;
        transparentImmediateObjectsLastIndex = -1;

        sprites.length = 0;
        lensFlares.length = 0;

        projectObject( scene );

        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;

        opaqueImmediateObjects.length = opaqueImmediateObjectsLastIndex + 1;
        transparentImmediateObjects.length = transparentImmediateObjectsLastIndex + 1;

        if ( _this.sortObjects === true ) {

            opaqueObjects.sort( painterSortStable );
            transparentObjects.sort( reversePainterSortStable );

        }

        //

        shadowMap.render( scene, camera );

        //

        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;

        this.setRenderTarget( renderTarget );

        if ( this.autoClear || forceClear ) {

            this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

        }

        //

        if ( scene.overrideMaterial ) {

            var overrideMaterial = scene.overrideMaterial;

            renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
            renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

            renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog, overrideMaterial );
            renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog, overrideMaterial );

        }
        else {

            // opaque pass (front-to-back order)

            state.setBlending( THREE.NoBlending );

            renderObjects( opaqueObjects, camera, lights, fog );
            renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog );

            // transparent pass (back-to-front order)

            renderObjects( transparentObjects, camera, lights, fog );
            renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog );

        }

        // custom render plugins (post pass)

        spritePlugin.render( scene, camera );
        lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

        // Generate mipmap if we're using any kind of mipmap filtering

        if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

            updateRenderTargetMipmap( renderTarget );

        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render

        state.setDepthTest( true );
        state.setDepthWrite( true );
        state.setColorWrite( true );

        // _gl.finish();

    };

    function pushImmediateRenderItem( object ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( object.material.transparent ) {

            array = transparentImmediateObjects;
            index = ++transparentImmediateObjectsLastIndex;

        }
        else {

            array = opaqueImmediateObjects;
            index = ++opaqueImmediateObjectsLastIndex;

        }

        // recycle existing position or grow the array

        if ( index < array.length ) {

            array[ index ] = object;

        }
        else {

            // assert( index === array.length );
            array.push( object );

        }


    }

    function pushRenderItem( object, geometry, material, z, group ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( material.transparent ) {

            array = transparentObjects;
            index = ++transparentObjectsLastIndex;

        }
        else {

            array = opaqueObjects;
            index = ++opaqueObjectsLastIndex;

        }

        // recycle existing render item or grow the array

        var renderItem = array[ index ];

        if ( renderItem !== undefined ) {

            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = _vector3.z;
            renderItem.group = group;

        }
        else {

            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: _vector3.z,
                group: group
            };

            // assert( index === array.length );
            array.push( renderItem );

        }

    }

    function projectObject( object ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Light ) {

            lights.push( object );

        }
        else if ( object instanceof THREE.Sprite ) {

            sprites.push( object );

        }
        else if ( object instanceof THREE.LensFlare ) {

            lensFlares.push( object );

        }
        else if ( object instanceof THREE.ImmediateRenderObject ) {

            pushImmediateRenderItem( object );

        }
        else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object instanceof THREE.SkinnedMesh ) {

                object.skeleton.update();

            }

            if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                var material = object.material;

                if ( material.visible === true ) {

                    if ( _this.sortObjects === true ) {

                        _vector3.setFromMatrixPosition( object.matrixWorld );
                        _vector3.applyProjection( _projScreenMatrix );

                    }

                    var geometry = objects.update( object );

                    if ( material instanceof THREE.MeshFaceMaterial ) {

                        var groups = geometry.groups;
                        var materials = material.materials;

                        for ( var i = 0, l = groups.length; i < l; i++ ) {

                            var group = groups[ i ];
                            var groupMaterial = materials[ group.materialIndex ];

                            if ( groupMaterial.visible === true ) {

                                pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

                            }

                        }

                    }
                    else {

                        pushRenderItem( object, geometry, material, _vector3.z );

                    }

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            projectObject( children[ i ] );

        }

    }

    function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

        for ( var i = 0, l = renderList.length; i < l; i++ ) {

            var renderItem = renderList[ i ];

            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            _this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

        }

    }

    function renderObjectsImmediate( renderList, camera, lights, fog, overrideMaterial ) {

        var material = overrideMaterial;

        for ( var i = 0, l = renderList.length; i < l; i++ ) {

            var object = renderList[ i ];

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            if ( overrideMaterial === undefined ) material = object.material;

            setMaterial( material );

            var program = setProgram( camera, lights, fog, material, object );

            _currentGeometryProgram = '';

            object.render( function( object ) {

                _this.renderBufferImmediate( object, program, material );

            } );

        }

    }

    function initMaterial( material, lights, fog, object ) {

        var materialProperties = properties.get( material );

        var parameters = programCache.getParameters( material, lights, fog, object );
        var code = programCache.getProgramCode( material, parameters );

        var program = materialProperties.program;
        var programChange = true;

        if ( program === undefined ) {

            // new material
            material.addEventListener( 'dispose', onMaterialDispose );

        }
        else if ( program.code !== code ) {

            // changed glsl or parameters
            releaseMaterialProgramReference( material );

        }
        else if ( parameters.shaderID !== undefined ) {

            // same glsl and uniform list
            return;

        }
        else {

            // only rebuild uniform list
            programChange = false;

        }

        if ( programChange ) {

            if ( parameters.shaderID ) {

                var shader = THREE.ShaderLib[ parameters.shaderID ];

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };

            }
            else {

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };

            }

            material.__webglShader = materialProperties.__webglShader;

            program = programCache.acquireProgram( material, parameters, code );

            materialProperties.program = program;
            material.program = program;

        }

        var attributes = program.getAttributes();

        if ( material.morphTargets ) {

            material.numSupportedMorphTargets = 0;

            for ( var i = 0; i < _this.maxMorphTargets; i++ ) {

                if ( attributes[ 'morphTarget' + i ] >= 0 ) {

                    material.numSupportedMorphTargets++;

                }

            }

        }

        if ( material.morphNormals ) {

            material.numSupportedMorphNormals = 0;

            for ( i = 0; i < _this.maxMorphNormals; i++ ) {

                if ( attributes[ 'morphNormal' + i ] >= 0 ) {

                    material.numSupportedMorphNormals++;

                }

            }

        }

        materialProperties.uniformsList = [];

        var uniformLocations = materialProperties.program.getUniforms();

        for ( var u in materialProperties.__webglShader.uniforms ) {

            var location = uniformLocations[ u ];

            if ( location ) {

                materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

            }

        }

    }

    function setMaterial( material ) {

        setMaterialFaces( material );

        if ( material.transparent === true ) {

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

        }
        else {

            state.setBlending( THREE.NoBlending );

        }

        state.setDepthFunc( material.depthFunc );
        state.setDepthTest( material.depthTest );
        state.setDepthWrite( material.depthWrite );
        state.setColorWrite( material.colorWrite );
        state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    }

    function setMaterialFaces( material ) {

        material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
        state.setFlipSided( material.side === THREE.BackSide );

    }

    function setProgram( camera, lights, fog, material, object ) {

        _usedTextureUnits = 0;

        var materialProperties = properties.get( material );

        if ( material.needsUpdate || !materialProperties.program ) {

            initMaterial( material, lights, fog, object );
            material.needsUpdate = false;

        }

        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;

        var program = materialProperties.program,
            p_uniforms = program.getUniforms(),
            m_uniforms = materialProperties.__webglShader.uniforms;

        if ( program.id !== _currentProgram ) {

            _gl.useProgram( program.program );
            _currentProgram = program.id;

            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;

        }

        if ( material.id !== _currentMaterialId ) {

            if ( _currentMaterialId === -1 ) refreshLights = true;
            _currentMaterialId = material.id;

            refreshMaterial = true;

        }

        if ( refreshProgram || camera !== _currentCamera ) {

            _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

            if ( capabilities.logarithmicDepthBuffer ) {

                _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

            }


            if ( camera !== _currentCamera ) _currentCamera = camera;

            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)

            if ( material instanceof THREE.ShaderMaterial ||
                material instanceof THREE.MeshPhongMaterial ||
                material.envMap ) {

                if ( p_uniforms.cameraPosition !== undefined ) {

                    _vector3.setFromMatrixPosition( camera.matrixWorld );
                    _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

                }

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.ShaderMaterial ||
                material.skinning ) {

                if ( p_uniforms.viewMatrix !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

                }

            }

        }

        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // not sure why, but otherwise weird things happen

        if ( material.skinning ) {

            if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

            }

            if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

            }

            if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

                if ( p_uniforms.boneTexture !== undefined ) {

                    var textureUnit = getTextureUnit();

                    _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
                    _this.setTexture( object.skeleton.boneTexture, textureUnit );

                }

                if ( p_uniforms.boneTextureWidth !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

                }

                if ( p_uniforms.boneTextureHeight !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

                }

            }
            else if ( object.skeleton && object.skeleton.boneMatrices ) {

                if ( p_uniforms.boneGlobalMatrices !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

                }

            }

        }

        if ( refreshMaterial ) {

            // refresh uniforms common to several materials

            if ( fog && material.fog ) {

                refreshUniformsFog( m_uniforms, fog );

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material.lights ) {

                if ( _lightsNeedUpdate ) {

                    refreshLights = true;
                    setupLights( lights, camera );
                    _lightsNeedUpdate = false;

                }

                if ( refreshLights ) {

                    refreshUniformsLights( m_uniforms, _lights );
                    markUniformsLightsNeedsUpdate( m_uniforms, true );

                }
                else {

                    markUniformsLightsNeedsUpdate( m_uniforms, false );

                }

            }

            if ( material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsCommon( m_uniforms, material );

            }

            // refresh single material specific uniforms

            if ( material instanceof THREE.LineBasicMaterial ) {

                refreshUniformsLine( m_uniforms, material );

            }
            else if ( material instanceof THREE.LineDashedMaterial ) {

                refreshUniformsLine( m_uniforms, material );
                refreshUniformsDash( m_uniforms, material );

            }
            else if ( material instanceof THREE.PointsMaterial ) {

                refreshUniformsParticle( m_uniforms, material );

            }
            else if ( material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsPhong( m_uniforms, material );

            }
            else if ( material instanceof THREE.MeshDepthMaterial ) {

                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;

            }
            else if ( material instanceof THREE.MeshNormalMaterial ) {

                m_uniforms.opacity.value = material.opacity;

            }

            if ( object.receiveShadow && !material._shadowPass ) {

                refreshUniformsShadow( m_uniforms, lights );

            }

            // load common uniforms

            loadUniformsGeneric( materialProperties.uniformsList );

        }

        loadUniformsMatrices( p_uniforms, object );

        if ( p_uniforms.modelMatrix !== undefined ) {

            _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

        }

        return program;

    }

    // Uniforms (refresh uniforms objects)

    function refreshUniformsCommon( uniforms, material ) {

        uniforms.opacity.value = material.opacity;

        uniforms.diffuse.value = material.color;

        if ( material.emissive ) {

            uniforms.emissive.value = material.emissive;

        }

        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

        if ( material.aoMap ) {

            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;

        }

        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if ( material.map ) {

            uvScaleMap = material.map;

        }
        else if ( material.specularMap ) {

            uvScaleMap = material.specularMap;

        }
        else if ( material.displacementMap ) {

            uvScaleMap = material.displacementMap;

        }
        else if ( material.normalMap ) {

            uvScaleMap = material.normalMap;

        }
        else if ( material.bumpMap ) {

            uvScaleMap = material.bumpMap;

        }
        else if ( material.alphaMap ) {

            uvScaleMap = material.alphaMap;

        }
        else if ( material.emissiveMap ) {

            uvScaleMap = material.emissiveMap;

        }

        if ( uvScaleMap !== undefined ) {

            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;

    }

    function refreshUniformsLine( uniforms, material ) {

        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;

    }

    function refreshUniformsDash( uniforms, material ) {

        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;

    }

    function refreshUniformsParticle( uniforms, material ) {

        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

        uniforms.map.value = material.map;

        if ( material.map !== null ) {

            var offset = material.map.offset;
            var repeat = material.map.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

    }

    function refreshUniformsFog( uniforms, fog ) {

        uniforms.fogColor.value = fog.color;

        if ( fog instanceof THREE.Fog ) {

            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;

        }
        else if ( fog instanceof THREE.FogExp2 ) {

            uniforms.fogDensity.value = fog.density;

        }

    }

    function refreshUniformsPhong( uniforms, material ) {

        uniforms.specular.value = material.specular;
        uniforms.shininess.value = material.shininess;

        if ( material.lightMap ) {

            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;

        }

        if ( material.emissiveMap ) {

            uniforms.emissiveMap.value = material.emissiveMap;

        }

        if ( material.bumpMap ) {

            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;

        }

        if ( material.normalMap ) {

            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy( material.normalScale );

        }

        if ( material.displacementMap ) {

            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;

        }

    }

    function refreshUniformsLights( uniforms, lights ) {

        uniforms.ambientLightColor.value = lights.ambient;

        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;

        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;

        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;

        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;

    }

    // If uniforms are marked as clean, they don't need to be loaded to the GPU.

    function markUniformsLightsNeedsUpdate( uniforms, value ) {

        uniforms.ambientLightColor.needsUpdate = value;

        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;

        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;

        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;

        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;

    }

    function refreshUniformsShadow( uniforms, lights ) {

        if ( uniforms.shadowMatrix ) {

            var j = 0;

            for ( var i = 0, il = lights.length; i < il; i++ ) {

                var light = lights[ i ];

                if ( !light.castShadow ) continue;

                if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight ) ) {

                    uniforms.shadowMap.value[ j ] = light.shadowMap;
                    uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

                    uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

                    uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
                    uniforms.shadowBias.value[ j ] = light.shadowBias;

                    j++;

                }

            }

        }

    }

    // Uniforms (load to GPU)

    function loadUniformsMatrices( uniforms, object ) {

        _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

        if ( uniforms.normalMatrix ) {

            _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

        }

    }

    function getTextureUnit() {

        var textureUnit = _usedTextureUnits;

        if ( textureUnit >= capabilities.maxTextures ) {

            console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

        }

        _usedTextureUnits += 1;

        return textureUnit;

    }

    function loadUniformsGeneric( uniforms ) {

        var texture, textureUnit;

        for ( var j = 0, jl = uniforms.length; j < jl; j++ ) {

            var uniform = uniforms[ j ][ 0 ];

            // needsUpdate property is not added to all uniforms.
            if ( uniform.needsUpdate === false ) continue;

            var type = uniform.type;
            var value = uniform.value;
            var location = uniforms[ j ][ 1 ];

            switch ( type ) {

                case '1i':
                    _gl.uniform1i( location, value );
                    break;

                case '1f':
                    _gl.uniform1f( location, value );
                    break;

                case '2f':
                    _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
                    break;

                case '3f':
                    _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
                    break;

                case '4f':
                    _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
                    break;

                case '1iv':
                    _gl.uniform1iv( location, value );
                    break;

                case '3iv':
                    _gl.uniform3iv( location, value );
                    break;

                case '1fv':
                    _gl.uniform1fv( location, value );
                    break;

                case '2fv':
                    _gl.uniform2fv( location, value );
                    break;

                case '3fv':
                    _gl.uniform3fv( location, value );
                    break;

                case '4fv':
                    _gl.uniform4fv( location, value );
                    break;

                case 'Matrix3fv':
                    _gl.uniformMatrix3fv( location, false, value );
                    break;

                case 'Matrix4fv':
                    _gl.uniformMatrix4fv( location, false, value );
                    break;

                    //

                case 'i':

                    // single integer
                    _gl.uniform1i( location, value );

                    break;

                case 'f':

                    // single float
                    _gl.uniform1f( location, value );

                    break;

                case 'v2':

                    // single THREE.Vector2
                    _gl.uniform2f( location, value.x, value.y );

                    break;

                case 'v3':

                    // single THREE.Vector3
                    _gl.uniform3f( location, value.x, value.y, value.z );

                    break;

                case 'v4':

                    // single THREE.Vector4
                    _gl.uniform4f( location, value.x, value.y, value.z, value.w );

                    break;

                case 'c':

                    // single THREE.Color
                    _gl.uniform3f( location, value.r, value.g, value.b );

                    break;

                case 'iv1':

                    // flat array of integers (JS or typed array)
                    _gl.uniform1iv( location, value );

                    break;

                case 'iv':

                    // flat array of integers with 3 x N size (JS or typed array)
                    _gl.uniform3iv( location, value );

                    break;

                case 'fv1':

                    // flat array of floats (JS or typed array)
                    _gl.uniform1fv( location, value );

                    break;

                case 'fv':

                    // flat array of floats with 3 x N size (JS or typed array)
                    _gl.uniform3fv( location, value );

                    break;

                case 'v2v':

                    // array of THREE.Vector2

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 2 * value.length );

                    }

                    for ( var i = 0, i2 = 0, il = value.length; i < il; i++, i2 += 2 ) {

                        uniform._array[ i2 + 0 ] = value[ i ].x;
                        uniform._array[ i2 + 1 ] = value[ i ].y;

                    }

                    _gl.uniform2fv( location, uniform._array );

                    break;

                case 'v3v':

                    // array of THREE.Vector3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 3 * value.length );

                    }

                    for ( var i = 0, i3 = 0, il = value.length; i < il; i++, i3 += 3 ) {

                        uniform._array[ i3 + 0 ] = value[ i ].x;
                        uniform._array[ i3 + 1 ] = value[ i ].y;
                        uniform._array[ i3 + 2 ] = value[ i ].z;

                    }

                    _gl.uniform3fv( location, uniform._array );

                    break;

                case 'v4v':

                    // array of THREE.Vector4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 4 * value.length );

                    }

                    for ( var i = 0, i4 = 0, il = value.length; i < il; i++, i4 += 4 ) {

                        uniform._array[ i4 + 0 ] = value[ i ].x;
                        uniform._array[ i4 + 1 ] = value[ i ].y;
                        uniform._array[ i4 + 2 ] = value[ i ].z;
                        uniform._array[ i4 + 3 ] = value[ i ].w;

                    }

                    _gl.uniform4fv( location, uniform._array );

                    break;

                case 'm3':

                    // single THREE.Matrix3
                    _gl.uniformMatrix3fv( location, false, value.elements );

                    break;

                case 'm3v':

                    // array of THREE.Matrix3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 9 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

                    }

                    _gl.uniformMatrix3fv( location, false, uniform._array );

                    break;

                case 'm4':

                    // single THREE.Matrix4
                    _gl.uniformMatrix4fv( location, false, value.elements );

                    break;

                case 'm4v':

                    // array of THREE.Matrix4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 16 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

                    }

                    _gl.uniformMatrix4fv( location, false, uniform._array );

                    break;

                case 't':

                    // single THREE.Texture (2d or cube)

                    texture = value;
                    textureUnit = getTextureUnit();

                    _gl.uniform1i( location, textureUnit );

                    if ( !texture ) continue;

                    if ( texture instanceof THREE.CubeTexture ||
                        ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

                        // CompressedTexture can have Array in image :/

                        setCubeTexture( texture, textureUnit );

                    }
                    else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

                        setCubeTextureDynamic( texture, textureUnit );

                    }
                    else {

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                case 'tv':

                    // array of THREE.Texture (2d)

                    if ( uniform._array === undefined ) {

                        uniform._array = [];

                    }

                    for ( var i = 0, il = uniform.value.length; i < il; i++ ) {

                        uniform._array[ i ] = getTextureUnit();

                    }

                    _gl.uniform1iv( location, uniform._array );

                    for ( var i = 0, il = uniform.value.length; i < il; i++ ) {

                        texture = uniform.value[ i ];
                        textureUnit = uniform._array[ i ];

                        if ( !texture ) continue;

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                default:

                    console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

            }

        }

    }

    function setColorLinear( array, offset, color, intensity ) {

        array[ offset + 0 ] = color.r * intensity;
        array[ offset + 1 ] = color.g * intensity;
        array[ offset + 2 ] = color.b * intensity;

    }

    function setupLights( lights, camera ) {

        var l, ll, light,
            r = 0,
            g = 0,
            b = 0,
            color, skyColor, groundColor,
            intensity,
            distance,

            zlights = _lights,

            viewMatrix = camera.matrixWorldInverse,

            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,

            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,

            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,

            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,

            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,

            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,

            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;

        for ( l = 0, ll = lights.length; l < ll; l++ ) {

            light = lights[ l ];

            if ( light.onlyShadow ) continue;

            color = light.color;
            intensity = light.intensity;
            distance = light.distance;

            if ( light instanceof THREE.AmbientLight ) {

                if ( !light.visible ) continue;

                r += color.r;
                g += color.g;
                b += color.b;

            }
            else if ( light instanceof THREE.DirectionalLight ) {

                dirCount += 1;

                if ( !light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                dirOffset = dirLength * 3;

                dirPositions[ dirOffset + 0 ] = _direction.x;
                dirPositions[ dirOffset + 1 ] = _direction.y;
                dirPositions[ dirOffset + 2 ] = _direction.z;

                setColorLinear( dirColors, dirOffset, color, intensity );

                dirLength += 1;

            }
            else if ( light instanceof THREE.PointLight ) {

                pointCount += 1;

                if ( !light.visible ) continue;

                pointOffset = pointLength * 3;

                setColorLinear( pointColors, pointOffset, color, intensity );

                _vector3.setFromMatrixPosition( light.matrixWorld );
                _vector3.applyMatrix4( viewMatrix );

                pointPositions[ pointOffset + 0 ] = _vector3.x;
                pointPositions[ pointOffset + 1 ] = _vector3.y;
                pointPositions[ pointOffset + 2 ] = _vector3.z;

                // distance is 0 if decay is 0, because there is no attenuation at all.
                pointDistances[ pointLength ] = distance;
                pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                pointLength += 1;

            }
            else if ( light instanceof THREE.SpotLight ) {

                spotCount += 1;

                if ( !light.visible ) continue;

                spotOffset = spotLength * 3;

                setColorLinear( spotColors, spotOffset, color, intensity );

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.copy( _direction ).applyMatrix4( viewMatrix );

                spotPositions[ spotOffset + 0 ] = _vector3.x;
                spotPositions[ spotOffset + 1 ] = _vector3.y;
                spotPositions[ spotOffset + 2 ] = _vector3.z;

                spotDistances[ spotLength ] = distance;

                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                spotDirections[ spotOffset + 0 ] = _direction.x;
                spotDirections[ spotOffset + 1 ] = _direction.y;
                spotDirections[ spotOffset + 2 ] = _direction.z;

                spotAnglesCos[ spotLength ] = Math.cos( light.angle );
                spotExponents[ spotLength ] = light.exponent;
                spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                spotLength += 1;

            }
            else if ( light instanceof THREE.HemisphereLight ) {

                hemiCount += 1;

                if ( !light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _direction.transformDirection( viewMatrix );

                hemiOffset = hemiLength * 3;

                hemiPositions[ hemiOffset + 0 ] = _direction.x;
                hemiPositions[ hemiOffset + 1 ] = _direction.y;
                hemiPositions[ hemiOffset + 2 ] = _direction.z;

                skyColor = light.color;
                groundColor = light.groundColor;

                setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
                setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

                hemiLength += 1;

            }

        }

        // null eventual remains from removed lights
        // (this is to avoid if in shader)

        for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l++ ) dirColors[ l ] = 0.0;
        for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l++ ) pointColors[ l ] = 0.0;
        for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l++ ) spotColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l++ ) hemiSkyColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l++ ) hemiGroundColors[ l ] = 0.0;

        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;

        zlights.ambient[ 0 ] = r;
        zlights.ambient[ 1 ] = g;
        zlights.ambient[ 2 ] = b;

    }

    // GL state setting

    this.setFaceCulling = function( cullFace, frontFaceDirection ) {

        if ( cullFace === THREE.CullFaceNone ) {

            state.disable( _gl.CULL_FACE );

        }
        else {

            if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

                _gl.frontFace( _gl.CW );

            }
            else {

                _gl.frontFace( _gl.CCW );

            }

            if ( cullFace === THREE.CullFaceBack ) {

                _gl.cullFace( _gl.BACK );

            }
            else if ( cullFace === THREE.CullFaceFront ) {

                _gl.cullFace( _gl.FRONT );

            }
            else {

                _gl.cullFace( _gl.FRONT_AND_BACK );

            }

            state.enable( _gl.CULL_FACE );

        }

    };

    // Textures

    function setTextureParameters( textureType, texture, isImagePowerOfTwo ) {

        var extension;

        if ( isImagePowerOfTwo ) {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

        }
        else {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

            if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

            }

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

            if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

            }

        }

        extension = extensions.get( 'EXT_texture_filter_anisotropic' );

        if ( extension ) {

            if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
            if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

            if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

                _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
                properties.get( texture ).__currentAnisotropy = texture.anisotropy;

            }

        }

    }

    function uploadTexture( textureProperties, texture, slot ) {

        if ( textureProperties.__webglInit === undefined ) {

            textureProperties.__webglInit = true;

            texture.__webglInit = true;

            texture.addEventListener( 'dispose', onTextureDispose );

            textureProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
        _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
        _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

        texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

        var image = texture.image,
            isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
            glFormat = paramThreeToGL( texture.format ),
            glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

        var mipmap, mipmaps = texture.mipmaps;

        if ( texture instanceof THREE.DataTexture ) {

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

                texture.generateMipmaps = false;

            }
            else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

            }

        }
        else if ( texture instanceof THREE.CompressedTexture ) {

            for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                mipmap = mipmaps[ i ];

                if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                    if ( state.getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                        state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                    }
                    else {

                        console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

                    }

                }
                else {

                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

            }

        }
        else {

            // regular Texture (image, video, canvas)

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

                }

                texture.generateMipmaps = false;

            }
            else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

            }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

        textureProperties.__version = texture.version;

        if ( texture.onUpdate ) texture.onUpdate( texture );

    }

    this.setTexture = function( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

            var image = texture.image;

            if ( image === undefined ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
                return;

            }

            if ( image.complete === false ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
                return;

            }

            uploadTexture( textureProperties, texture, slot );
            return;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    };

    function clampToMaxSize( image, maxSize ) {

        if ( image.width > maxSize || image.height > maxSize ) {

            // Warning: Scaling through the canvas will only work with images that use
            // premultiplied alpha.

            var scale = maxSize / Math.max( image.width, image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = Math.floor( image.width * scale );
            canvas.height = Math.floor( image.height * scale );

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

            console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

            return canvas;

        }

        return image;

    }

    function setCubeTexture( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.image.length === 6 ) {

            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

                if ( !textureProperties.__image__webglTextureCube ) {

                    texture.addEventListener( 'dispose', onTextureDispose );

                    textureProperties.__image__webglTextureCube = _gl.createTexture();

                    _infoMemory.textures++;

                }

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

                _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

                var isCompressed = texture instanceof THREE.CompressedTexture;
                var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

                var cubeImage = [];

                for ( var i = 0; i < 6; i++ ) {

                    if ( _this.autoScaleCubemaps && !isCompressed && !isDataTexture ) {

                        cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

                    }
                    else {

                        cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

                    }

                }

                var image = cubeImage[ 0 ],
                    isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
                    glFormat = paramThreeToGL( texture.format ),
                    glType = paramThreeToGL( texture.type );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

                for ( var i = 0; i < 6; i++ ) {

                    if ( !isCompressed ) {

                        if ( isDataTexture ) {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

                        }
                        else {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

                        }

                    }
                    else {

                        var mipmap, mipmaps = cubeImage[ i ].mipmaps;

                        for ( var j = 0, jl = mipmaps.length; j < jl; j++ ) {

                            mipmap = mipmaps[ j ];

                            if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                                if ( state.getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                                    state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                                }
                                else {

                                    console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                                }

                            }
                            else {

                                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                            }

                        }

                    }

                }

                if ( texture.generateMipmaps && isImagePowerOfTwo ) {

                    _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

                }

                textureProperties.__version = texture.version;

                if ( texture.onUpdate ) texture.onUpdate( texture );

            }
            else {

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

            }

        }

    }

    function setCubeTextureDynamic( texture, slot ) {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    }

    // Render targets

    function setupFrameBuffer( framebuffer, renderTarget, textureTarget ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget ).__webglTexture, 0 );

    }

    function setupRenderBuffer( renderbuffer, renderTarget ) {

        _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

        if ( renderTarget.depthBuffer && !renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            /* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/

        }
        else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

        }
        else {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

        }

    }

    this.setRenderTarget = function( renderTarget ) {

        var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

        if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
            if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

            renderTargetProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures++;

            // Setup texture, create render and frame buffers

            var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
                glFormat = paramThreeToGL( renderTarget.format ),
                glType = paramThreeToGL( renderTarget.type );

            if ( isCube ) {

                renderTargetProperties.__webglFramebuffer = [];
                renderTargetProperties.__webglRenderbuffer = [];

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

                for ( var i = 0; i < 6; i++ ) {

                    renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
                    renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

                    state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                    setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

                }

                if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

            }
            else {

                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

                if ( renderTarget.shareDepthFrom ) {

                    renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

                }
                else {

                    renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

                }

                state.bindTexture( _gl.TEXTURE_2D, renderTargetProperties.__webglTexture );
                setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

                if ( renderTarget.shareDepthFrom ) {

                    if ( renderTarget.depthBuffer && !renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }
                    else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }

                }
                else {

                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

                }

                if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

            }

            // Release everything

            if ( isCube ) {

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

            }
            else {

                state.bindTexture( _gl.TEXTURE_2D, null );

            }

            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( isCube ) {

                framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

            }
            else {

                framebuffer = renderTargetProperties.__webglFramebuffer;

            }

            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        }
        else {

            framebuffer = null;

            width = _viewportWidth;
            height = _viewportHeight;

            vx = _viewportX;
            vy = _viewportY;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        _currentWidth = width;
        _currentHeight = height;

    };

    this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

        if ( !( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
            return;

        }

        if ( properties.get( renderTarget ).__webglFramebuffer ) {

            if ( renderTarget.format !== THREE.RGBAFormat ) {

                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
                return;

            }

            var restore = false;

            if ( properties.get( renderTarget ).__webglFramebuffer !== _currentFramebuffer ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, properties.get( renderTarget ).__webglFramebuffer );

                restore = true;

            }

            if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

                _gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

            }
            else {

                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

            }

            if ( restore ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

            }

        }

    };

    function updateRenderTargetMipmap( renderTarget ) {

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( renderTarget ).__webglTexture );
            _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
            state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

        }
        else {

            state.bindTexture( _gl.TEXTURE_2D, properties.get( renderTarget ).__webglTexture );
            _gl.generateMipmap( _gl.TEXTURE_2D );
            state.bindTexture( _gl.TEXTURE_2D, null );

        }

    }

    // Fallback filters for non-power-of-2 textures

    function filterFallback( f ) {

        if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

            return _gl.NEAREST;

        }

        return _gl.LINEAR;

    }

    // Map three.js constants to WebGL constants

    function paramThreeToGL( p ) {

        var extension;

        if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
        if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
        if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

        if ( p === THREE.NearestFilter ) return _gl.NEAREST;
        if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
        if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

        if ( p === THREE.LinearFilter ) return _gl.LINEAR;
        if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
        if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

        if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
        if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
        if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
        if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

        if ( p === THREE.ByteType ) return _gl.BYTE;
        if ( p === THREE.ShortType ) return _gl.SHORT;
        if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
        if ( p === THREE.IntType ) return _gl.INT;
        if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
        if ( p === THREE.FloatType ) return _gl.FLOAT;

        extension = extensions.get( 'OES_texture_half_float' );

        if ( extension !== null ) {

            if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

        }

        if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
        if ( p === THREE.RGBFormat ) return _gl.RGB;
        if ( p === THREE.RGBAFormat ) return _gl.RGBA;
        if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
        if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

        if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
        if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
        if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

        if ( p === THREE.ZeroFactor ) return _gl.ZERO;
        if ( p === THREE.OneFactor ) return _gl.ONE;
        if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
        if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
        if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
        if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
        if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
        if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

        if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
        if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
        if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

        extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

        }

        extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

        }

        extension = extensions.get( 'EXT_blend_minmax' );

        if ( extension !== null ) {

            if ( p === THREE.MinEquation ) return extension.MIN_EXT;
            if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

        }

        return 0;

    }

    // DEPRECATED

    this.supportsFloatTextures = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
        return extensions.get( 'OES_texture_float' );

    };

    this.supportsHalfFloatTextures = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
        return extensions.get( 'OES_texture_half_float' );

    };

    this.supportsStandardDerivatives = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
        return extensions.get( 'OES_standard_derivatives' );

    };

    this.supportsCompressedTextureS3TC = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_s3tc' );

    };

    this.supportsCompressedTexturePVRTC = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    };

    this.supportsBlendMinMax = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
        return extensions.get( 'EXT_blend_minmax' );

    };

    this.supportsVertexTextures = function() {

        return capabilities.vertexTextures;

    };

    this.supportsInstancedArrays = function() {

        console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
        return extensions.get( 'ANGLE_instanced_arrays' );

    };

    //

    this.initMaterial = function() {

        console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

    };

    this.addPrePlugin = function() {

        console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

    };

    this.addPostPlugin = function() {

        console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

    };

    this.updateShadowMap = function() {

        console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

    };

    Object.defineProperties( this, {
        shadowMapEnabled: {
            get: function() {

                return shadowMap.enabled;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
                shadowMap.enabled = value;

            }
        },
        shadowMapType: {
            get: function() {

                return shadowMap.type;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
                shadowMap.type = value;

            }
        },
        shadowMapCullFace: {
            get: function() {

                return shadowMap.cullFace;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
                shadowMap.cullFace = value;

            }
        },
        shadowMapDebug: {
            get: function() {

                return shadowMap.debug;

            },
            set: function( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
                shadowMap.debug = value;

            }
        }
    } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function( width, height, options ) {

    this.uuid = THREE.Math.generateUUID();

    this.width = width;
    this.height = height;

    options = options || {};

    this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
    this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
    this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

    this.generateMipmaps = true;

    this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

    constructor: THREE.WebGLRenderTarget,

    setSize: function( width, height ) {

        if ( this.width !== width || this.height !== height ) {

            this.width = width;
            this.height = height;

            this.dispose();

        }

    },

    clone: function() {

        return new this.constructor().copy( this );

    },

    copy: function( source ) {

        this.width = source.width;
        this.height = source.height;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.format = source.format;
        this.type = source.type;

        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;

        this.generateMipmaps = source.generateMipmaps;

        this.shareDepthFrom = source.shareDepthFrom;

        return this;

    },

    dispose: function() {

        this.dispatchEvent( {
            type: 'dispose'
        } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function( width, height, options ) {

    THREE.WebGLRenderTarget.call( this, width, height, options );

    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLBufferRenderer = function( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var traceCount = 0;

    function render( start, count ) {
        if ( traceCount === 0 ) {
            traceCount = 1;
        }

        _gl.drawArrays( mode, start, count );

        _infoRender.calls++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var position = geometry.attributes.position;

        if ( position instanceof THREE.InterleavedBufferAttribute ) {

            extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

        }
        else {

            extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

        }

    }

    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLIndexedBufferRenderer = function( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var type, size;

    function setIndex( index ) {

        if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

            type = _gl.UNSIGNED_INT;
            size = 4;

        }
        else {

            type = _gl.UNSIGNED_SHORT;
            size = 2;

        }

    }

    function render( start, count ) {

        _gl.drawElements( mode, count, type, start * size );

        _infoRender.calls++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var index = geometry.index;

        extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

    }

    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLExtensions = function( gl ) {

    var extensions = {};

    this.get = function( name ) {

        if ( extensions[ name ] !== undefined ) {

            return extensions[ name ];

        }

        var extension;

        switch ( name ) {

            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
                break;

            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
                break;

            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
                break;

            default:
                extension = gl.getExtension( name );

        }

        if ( extension === null ) {

            console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

        }

        extensions[ name ] = extension;

        return extension;

    };

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function( gl, extensions, parameters ) {

    function getMaxPrecision( precision ) {

        if ( precision === 'highp' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

                return 'highp';

            }

            precision = 'mediump';

        }

        if ( precision === 'mediump' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

                return 'mediump';

            }

        }

        return 'lowp';

    }

    this.getMaxPrecision = getMaxPrecision;

    this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
    this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

    this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    this.vertexTextures = this.maxVertexTextures > 0;
    this.floatFragmentTextures = !!extensions.get( 'OES_texture_float' );
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

    var _maxPrecision = getMaxPrecision( this.precision );

    if ( _maxPrecision !== this.precision ) {

        console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
        this.precision = _maxPrecision;

    }

    if ( this.logarithmicDepthBuffer ) {

        this.logarithmicDepthBuffer = !!extensions.get( 'EXT_frag_depth' );

    }

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLGeometries = function( gl, properties, info ) {

    var geometries = {};

    function get( object ) {

        var geometry = object.geometry;

        if ( geometries[ geometry.id ] !== undefined ) {

            return geometries[ geometry.id ];

        }

        geometry.addEventListener( 'dispose', onGeometryDispose );

        var buffergeometry;

        if ( geometry instanceof THREE.BufferGeometry ) {

            buffergeometry = geometry;

        }
        else if ( geometry instanceof THREE.Geometry ) {

            if ( geometry._bufferGeometry === undefined ) {

                geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

            }

            buffergeometry = geometry._bufferGeometry;

        }

        geometries[ geometry.id ] = buffergeometry;

        info.memory.geometries++;

        return buffergeometry;

    }

    function onGeometryDispose( event ) {

        var geometry = event.target;
        var buffergeometry = geometries[ geometry.id ];

        deleteAttributes( buffergeometry.attributes );

        geometry.removeEventListener( 'dispose', onGeometryDispose );

        delete geometries[ geometry.id ];

        var property = properties.get( geometry );
        if ( property.wireframe ) deleteAttribute( property.wireframe );

        info.memory.geometries--;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function deleteAttribute( attribute ) {

        var buffer = getAttributeBuffer( attribute );

        if ( buffer !== undefined ) {

            gl.deleteBuffer( buffer );
            removeAttributeBuffer( attribute );

        }

    }

    function deleteAttributes( attributes ) {

        for ( var name in attributes ) {

            deleteAttribute( attributes[ name ] );

        }

    }

    function removeAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            properties.delete( attribute.data );

        }
        else {

            properties.delete( attribute );

        }

    }

    this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLObjects = function( gl, properties, info ) {

    var geometries = new THREE.WebGLGeometries( gl, properties, info );

    //

    function update( object ) {

        // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

        var geometry = geometries.get( object );

        if ( object.geometry instanceof THREE.Geometry ) {

            geometry.updateFromObject( object );

        }

        var index = geometry.index;
        var attributes = geometry.attributes;

        if ( index !== null ) {

            updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

        }

        for ( var name in attributes ) {

            updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

        }

        // morph targets

        var morphAttributes = geometry.morphAttributes;

        for ( var name in morphAttributes ) {

            var array = morphAttributes[ name ];

            for ( var i = 0, l = array.length; i < l; i++ ) {

                updateAttribute( array[ i ], gl.ARRAY_BUFFER );

            }

        }

        return geometry;

    }

    function updateAttribute( attribute, bufferType ) {

        var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

        var attributeProperties = properties.get( data );

        if ( attributeProperties.__webglBuffer === undefined ) {
            createBuffer( attributeProperties, data, bufferType );

        }
        else if ( attributeProperties.version !== data.version ) {

            updateBuffer( attributeProperties, data, bufferType );

        }

    }

    function createBuffer( attributeProperties, data, bufferType ) {

        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        gl.bufferData( bufferType, data.array, usage );

        attributeProperties.version = data.version;

    }

    function updateBuffer( attributeProperties, data, bufferType ) {

        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        if ( data.dynamic === false || data.updateRange.count === -1 ) {

            // Not using update ranges
            gl.bufferSubData( bufferType, 0, data.array );

        }
        else if ( data.updateRange.count === 0 ) {

            console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

        }
        else {
            gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

            data.updateRange.count = 0; // reset range

        }

        attributeProperties.version = data.version;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function getWireframeAttribute( geometry ) {

        var property = properties.get( geometry );

        if ( property.wireframe !== undefined ) {

            return property.wireframe;

        }

        var indices = [];

        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;

        // console.time( 'wireframe' );

        if ( index !== null ) {

            var edges = {};
            var array = index.array;

            for ( var i = 0, l = array.length; i < l; i += 3 ) {

                var a = array[ i + 0 ];
                var b = array[ i + 1 ];
                var c = array[ i + 2 ];

                if ( checkEdge( edges, a, b ) ) indices.push( a, b );
                if ( checkEdge( edges, b, c ) ) indices.push( b, c );
                if ( checkEdge( edges, c, a ) ) indices.push( c, a );

            }

        }
        else {

            var array = attributes.position.array;

            for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

                var a = i + 0;
                var b = i + 1;
                var c = i + 2;

                indices.push( a, b, b, c, c, a );

            }

        }

        // console.timeEnd( 'wireframe' );

        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

        updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

        property.wireframe = attribute;

        return attribute;

    }

    function checkEdge( edges, a, b ) {

        if ( a > b ) {

            var tmp = a;
            a = b;
            b = tmp;

        }

        var list = edges[ a ];

        if ( list === undefined ) {

            edges[ a ] = [ b ];
            return true;

        }
        else if ( list.indexOf( b ) === -1 ) {

            list.push( b );
            return true;

        }

        return false;

    }

    this.getAttributeBuffer = getAttributeBuffer;
    this.getWireframeAttribute = getWireframeAttribute;

    this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function() {

    var programIdCount = 0;

    function generateDefines( defines ) {

        var chunks = [];

        for ( var name in defines ) {

            var value = defines[ name ];

            if ( value === false ) continue;

            chunks.push( '#define ' + name + ' ' + value );

        }

        return chunks.join( '\n' );

    }

    function fetchUniformLocations( gl, program, identifiers ) {

        var uniforms = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

        for ( var i = 0; i < n; i++ ) {

            var info = gl.getActiveUniform( program, i );
            var name = info.name;
            var location = gl.getUniformLocation( program, name );

            // console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

            var suffixPos = name.lastIndexOf( '[0]' );
            if ( suffixPos !== -1 && suffixPos === name.length - 3 ) {

                uniforms[ name.substr( 0, suffixPos ) ] = location;

            }

            uniforms[ name ] = location;

        }

        return uniforms;

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

        var attributes = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

        for ( var i = 0; i < n; i++ ) {

            var info = gl.getActiveAttrib( program, i );
            var name = info.name;

            // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

            attributes[ name ] = gl.getAttribLocation( program, name );

        }

        return attributes;

    }

    function filterEmptyLine( string ) {

        return string !== '';

    }

    return function WebGLProgram( renderer, code, material, parameters ) {

        var gl = renderer.context;

        var defines = material.defines;

        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;

        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

        if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

        }
        else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

        }

        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

        if ( parameters.envMap ) {

            switch ( material.envMap.mapping ) {

                case THREE.CubeReflectionMapping:
                case THREE.CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;

                case THREE.EquirectangularReflectionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;

                case THREE.SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;

            }

            switch ( material.envMap.mapping ) {

                case THREE.CubeRefractionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;

            }

            switch ( material.combine ) {

                case THREE.MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;

                case THREE.MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;

                case THREE.AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;

            }

        }

        var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

        // console.log( 'building new program ' );

        //

        var customDefines = generateDefines( defines );

        //

        var program = gl.createProgram();

        var prefixVertex, prefixFragment;

        if ( material instanceof THREE.RawShaderMaterial ) {

            prefixVertex = '';
            prefixFragment = '';

        }
        else {

            prefixVertex = [

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                '#define MAX_BONES ' + parameters.maxBones,

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',

                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',

                '#ifdef USE_COLOR',

                '	attribute vec3 color;',

                '#endif',

                '#ifdef USE_MORPHTARGETS',

                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',

                '	#ifdef USE_MORPHNORMALS',

                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',

                '	#else',

                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',

                '	#endif',

                '#endif',

                '#ifdef USE_SKINNING',

                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',

                '#endif',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

            prefixFragment = [

                parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '', ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.metal ? '#define METAL' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

        }

        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;

        var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
        var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

        gl.attachShader( program, glVertexShader );
        gl.attachShader( program, glFragmentShader );

        // Force a particular attribute to index 0.

        if ( material.index0AttributeName !== undefined ) {

            gl.bindAttribLocation( program, 0, material.index0AttributeName );

        }
        else if ( parameters.morphTargets === true ) {

            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation( program, 0, 'position' );

        }

        gl.linkProgram( program );

        var programLog = gl.getProgramInfoLog( program );
        var vertexLog = gl.getShaderInfoLog( glVertexShader );
        var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

        var runnable = true;
        var haveDiagnostics = true;

        if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

            runnable = false;

            console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

        }
        else if ( programLog !== '' ) {

            console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

        }
        else if ( vertexLog === '' || fragmentLog === '' ) {

            haveDiagnostics = false;

        }

        if ( haveDiagnostics ) {

            this.diagnostics = {

                runnable: runnable,
                material: material,

                programLog: programLog,

                vertexShader: {

                    log: vertexLog,
                    prefix: prefixVertex

                },

                fragmentShader: {

                    log: fragmentLog,
                    prefix: prefixFragment

                }

            };

        }

        // clean up

        gl.deleteShader( glVertexShader );
        gl.deleteShader( glFragmentShader );

        // set up caching for uniform locations

        var cachedUniforms;

        this.getUniforms = function() {

            if ( cachedUniforms === undefined ) {

                cachedUniforms = fetchUniformLocations( gl, program );

            }

            return cachedUniforms;

        };

        // set up caching for attribute locations

        var cachedAttributes;

        this.getAttributes = function() {

            if ( cachedAttributes === undefined ) {

                cachedAttributes = fetchAttributeLocations( gl, program );

            }

            return cachedAttributes;

        };

        // free resource

        this.destroy = function() {

            gl.deleteProgram( program );
            this.program = undefined;

        };

        // DEPRECATED

        Object.defineProperties( this, {

            uniforms: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
                    return this.getUniforms();

                }
            },

            attributes: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
                    return this.getAttributes();

                }
            }

        } );


        //

        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;

        return this;

    };

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function( renderer, capabilities ) {

    var programs = [];

    var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
    };

    var parameterNames = [
        "precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
        "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "specularMap",
        "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
        "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
        "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
        "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
        "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled",
        "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
        "flipSided"
    ];


    function allocateBones( object ) {

        if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

            return 1024;

        }
        else {

            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)

            var nVertexUniforms = capabilities.maxVertexUniforms;
            var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

            var maxBones = nVertexMatrices;

            if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

                maxBones = Math.min( object.skeleton.bones.length, maxBones );

                if ( maxBones < object.skeleton.bones.length ) {

                    console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

                }

            }

            return maxBones;

        }

    }

    function allocateLights( lights ) {

        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;

        for ( var l = 0, ll = lights.length; l < ll; l++ ) {

            var light = lights[ l ];

            if ( light.onlyShadow || light.visible === false ) continue;

            if ( light instanceof THREE.DirectionalLight ) dirLights++;
            if ( light instanceof THREE.PointLight ) pointLights++;
            if ( light instanceof THREE.SpotLight ) spotLights++;
            if ( light instanceof THREE.HemisphereLight ) hemiLights++;

        }

        return {
            'directional': dirLights,
            'point': pointLights,
            'spot': spotLights,
            'hemi': hemiLights
        };

    }

    function allocateShadows( lights ) {

        var maxShadows = 0;

        for ( var l = 0, ll = lights.length; l < ll; l++ ) {

            var light = lights[ l ];

            if ( !light.castShadow ) continue;

            if ( light instanceof THREE.SpotLight ) maxShadows++;
            if ( light instanceof THREE.DirectionalLight ) maxShadows++;

        }

        return maxShadows;

    }

    this.getParameters = function( material, lights, fog, object ) {

        var shaderID = shaderIDs[ material.type ];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)

        var maxLightCount = allocateLights( lights );
        var maxShadows = allocateShadows( lights );
        var maxBones = allocateBones( object );
        var precision = renderer.getPrecision();

        if ( material.precision !== null ) {

            precision = capabilities.getMaxPrecision( material.precision );

            if ( precision !== material.precision ) {

                console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

            }

        }

        var parameters = {

            shaderID: shaderID,

            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,

            map: !!material.map,
            envMap: !!material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            displacementMap: !!material.displacementMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,

            combine: material.combine,

            vertexColors: material.vertexColors,

            fog: fog,
            useFog: material.fog,
            fogExp: fog instanceof THREE.FogExp2,

            flatShading: material.shading === THREE.FlatShading,

            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: renderer.logarithmicDepthBuffer,

            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,

            maxDirLights: maxLightCount.directional,
            maxPointLights: maxLightCount.point,
            maxSpotLights: maxLightCount.spot,
            maxHemiLights: maxLightCount.hemi,

            maxShadows: maxShadows,
            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && maxShadows > 0,
            shadowMapType: renderer.shadowMap.type,
            shadowMapDebug: renderer.shadowMap.debug,

            alphaTest: material.alphaTest,
            metal: material.metal,
            doubleSided: material.side === THREE.DoubleSide,
            flipSided: material.side === THREE.BackSide

        };

        return parameters;

    };

    this.getProgramCode = function( material, parameters ) {

        var chunks = [];

        if ( parameters.shaderID ) {

            chunks.push( parameters.shaderID );

        }
        else {

            chunks.push( material.fragmentShader );
            chunks.push( material.vertexShader );

        }

        if ( material.defines !== undefined ) {

            for ( var name in material.defines ) {

                chunks.push( name );
                chunks.push( material.defines[ name ] );

            }

        }

        for ( var i = 0; i < parameterNames.length; i++ ) {

            var parameterName = parameterNames[ i ];
            chunks.push( parameterName );
            chunks.push( parameters[ parameterName ] );

        }

        return chunks.join();

    };

    this.acquireProgram = function( material, parameters, code ) {

        var program;

        // Check if code has been already compiled
        for ( var p = 0, pl = programs.length; p < pl; p++ ) {

            var programInfo = programs[ p ];

            if ( programInfo.code === code ) {

                program = programInfo;
                ++program.usedTimes;

                break;

            }

        }

        if ( program === undefined ) {

            program = new THREE.WebGLProgram( renderer, code, material, parameters );
            programs.push( program );

        }

        return program;

    };

    this.releaseProgram = function( program ) {

        if ( --program.usedTimes === 0 ) {

            // Remove from unordered set
            var i = programs.indexOf( program );
            programs[ i ] = programs[ programs.length - 1 ];
            programs.pop();

            // Free WebGL resources
            program.destroy();

        }

    };

    // Exposed for resource monitoring & error feedback via renderer.info:
    this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
 * @author fordacious / fordacious.github.io
 */

THREE.WebGLProperties = function() {

    var properties = {};

    this.get = function( object ) {

        var uuid = object.uuid;
        var map = properties[ uuid ];

        if ( map === undefined ) {

            map = {};
            properties[ uuid ] = map;

        }

        return map;

    };

    this.delete = function( object ) {

        delete properties[ object.uuid ];

    };

    this.clear = function() {

        properties = {};

    };

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function() {

    var addLineNumbers = function( string ) {

        var lines = string.split( '\n' );

        for ( var i = 0; i < lines.length; i++ ) {

            lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

        }

        return lines.join( '\n' );

    };

    return function WebGLShader( gl, type, string ) {

        var shader = gl.createShader( type );

        gl.shaderSource( shader, string );
        gl.compileShader( shader );

        if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

            console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

        }

        if ( gl.getShaderInfoLog( shader ) !== '' ) {

            console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

        }

        // --enable-privileged-webgl-extension
        // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

        return shader;

    };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function( _renderer, _lights, _objects ) {

    var _gl = _renderer.context,
        _state = _renderer.state,
        _frustum = new THREE.Frustum(),
        _projScreenMatrix = new THREE.Matrix4(),

        _min = new THREE.Vector3(),
        _max = new THREE.Vector3(),

        _matrixPosition = new THREE.Vector3(),

        _renderList = [];

    // init

    var depthShader = THREE.ShaderLib[ "depthRGBA" ];
    var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

    var _depthMaterial = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader
    } );

    var _depthMaterialMorph = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true
    } );

    var _depthMaterialSkin = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        skinning: true
    } );

    var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true,
        skinning: true
    } );

    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;

    //

    var scope = this;

    this.enabled = false;

    this.autoUpdate = true;
    this.needsUpdate = false;

    this.type = THREE.PCFShadowMap;
    this.cullFace = THREE.CullFaceFront;

    this.render = function( scene, camera ) {

        if ( scope.enabled === false ) return;
        if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

        // set GL state for depth map

        _gl.clearColor( 1, 1, 1, 1 );
        _state.disable( _gl.BLEND );

        _state.enable( _gl.CULL_FACE );
        _gl.frontFace( _gl.CCW );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.FRONT );

        }
        else {

            _gl.cullFace( _gl.BACK );

        }

        _state.setDepthTest( true );

        // render depth map

        for ( var i = 0, il = _lights.length; i < il; i++ ) {

            var light = _lights[ i ];

            if ( !light.castShadow ) continue;

            if ( !light.shadowMap ) {

                var shadowFilter = THREE.LinearFilter;

                if ( scope.type === THREE.PCFSoftShadowMap ) {

                    shadowFilter = THREE.NearestFilter;

                }

                var pars = {
                    minFilter: shadowFilter,
                    magFilter: shadowFilter,
                    format: THREE.RGBAFormat
                };

                light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
                light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

                light.shadowMatrix = new THREE.Matrix4();

            }

            if ( !light.shadowCamera ) {

                if ( light instanceof THREE.SpotLight ) {

                    light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

                }
                else if ( light instanceof THREE.DirectionalLight ) {

                    light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

                }
                else {

                    console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
                    continue;

                }

                scene.add( light.shadowCamera );

                if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

            }

            if ( light.shadowCameraVisible && !light.cameraHelper ) {

                light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
                scene.add( light.cameraHelper );

            }

            var shadowMap = light.shadowMap;
            var shadowMatrix = light.shadowMatrix;
            var shadowCamera = light.shadowCamera;

            //

            shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
            _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
            shadowCamera.lookAt( _matrixPosition );
            shadowCamera.updateMatrixWorld();

            shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

            //

            if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
            if ( light.shadowCameraVisible ) light.cameraHelper.update();

            // compute shadow matrix

            shadowMatrix.set(
                0.5, 0.0, 0.0, 0.5,
                0.0, 0.5, 0.0, 0.5,
                0.0, 0.0, 0.5, 0.5,
                0.0, 0.0, 0.0, 1.0
            );

            shadowMatrix.multiply( shadowCamera.projectionMatrix );
            shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

            // update camera matrices and frustum

            _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
            _frustum.setFromMatrix( _projScreenMatrix );

            // render shadow map

            _renderer.setRenderTarget( shadowMap );
            _renderer.clear();

            // set object matrices & frustum culling

            _renderList.length = 0;

            projectObject( scene, shadowCamera );


            // render regular objects

            for ( var j = 0, jl = _renderList.length; j < jl; j++ ) {

                var object = _renderList[ j ];
                var geometry = _objects.update( object );
                var material = object.material;

                if ( material instanceof THREE.MeshFaceMaterial ) {

                    var groups = geometry.groups;
                    var materials = material.materials;

                    for ( var k = 0, kl = groups.length; k < kl; k++ ) {

                        var group = groups[ k ];
                        var groupMaterial = materials[ group.materialIndex ];

                        if ( groupMaterial.visible === true ) {

                            _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, groupMaterial ), object, group );

                        }

                    }

                }
                else {

                    _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, material ), object );

                }

            }

        }

        // restore GL state

        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();

        _renderer.setClearColor( clearColor, clearAlpha );
        _state.enable( _gl.BLEND );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.BACK );

        }

        _renderer.resetGLState();

        scope.needsUpdate = false;

    };

    function getDepthMaterial( object, material ) {

        var geometry = object.geometry;

        var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
        var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

        var depthMaterial;

        if ( object.customDepthMaterial ) {

            depthMaterial = object.customDepthMaterial;

        }
        else if ( useSkinning ) {

            depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

        }
        else if ( useMorphing ) {

            depthMaterial = _depthMaterialMorph;

        }
        else {

            depthMaterial = _depthMaterial;

        }

        depthMaterial.visible = material.visible;
        depthMaterial.wireframe = material.wireframe;
        depthMaterial.wireframeLinewidth = material.wireframeLinewidth;

        return depthMaterial;

    }

    function projectObject( object, camera ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

                var material = object.material;

                if ( material.visible === true ) {

                    object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
                    _renderList.push( object );

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i++ ) {

            projectObject( children[ i ], camera );

        }

    }

};

// File:src/renderers/webgl/WebGLState.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLState = function( gl, extensions, paramThreeToGL ) {

    var _this = this;

    var newAttributes = new Uint8Array( 16 );
    var enabledAttributes = new Uint8Array( 16 );

    var capabilities = {};

    var compressedTextureFormats = null;

    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;

    var currentDepthFunc = null;
    var currentDepthWrite = null;

    var currentColorWrite = null;

    var currentFlipSided = null;

    var currentLineWidth = null;

    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;

    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    var currentTextureSlot = undefined;
    var currentBoundTextures = {};

    this.init = function() {

        gl.clearColor( 0, 0, 0, 1 );
        gl.clearDepth( 1 );
        gl.clearStencil( 0 );

        this.enable( gl.DEPTH_TEST );
        gl.depthFunc( gl.LEQUAL );

        gl.frontFace( gl.CCW );
        gl.cullFace( gl.BACK );
        this.enable( gl.CULL_FACE );

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

    };

    this.initAttributes = function() {

        for ( var i = 0, l = newAttributes.length; i < l; i++ ) {

            newAttributes[ i ] = 0;

        }

    };

    this.enableAttribute = function( attribute ) {

        newAttributes[ attribute ] = 1;

        if ( enabledAttributes[ attribute ] === 0 ) {

            gl.enableVertexAttribArray( attribute );
            enabledAttributes[ attribute ] = 1;

        }

    };

    this.disableUnusedAttributes = function() {

        for ( var i = 0, l = enabledAttributes.length; i < l; i++ ) {

            if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

    };

    this.enable = function( id ) {

        if ( capabilities[ id ] !== true ) {

            gl.enable( id );
            capabilities[ id ] = true;

        }

    };

    this.disable = function( id ) {

        if ( capabilities[ id ] !== false ) {

            gl.disable( id );
            capabilities[ id ] = false;

        }

    };

    this.getCompressedTextureFormats = function() {

        if ( compressedTextureFormats === null ) {

            compressedTextureFormats = [];

            if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
                extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

                var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

                for ( var i = 0; i < formats.length; i++ ) {

                    compressedTextureFormats.push( formats[ i ] );

                }

            }

        }

        return compressedTextureFormats;

    };

    this.setBlending = function( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

        if ( blending !== currentBlending ) {

            if ( blending === THREE.NoBlending ) {

                this.disable( gl.BLEND );

            }
            else if ( blending === THREE.AdditiveBlending ) {

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

            }
            else if ( blending === THREE.SubtractiveBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

            }
            else if ( blending === THREE.MultiplyBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

            }
            else if ( blending === THREE.CustomBlending ) {

                this.enable( gl.BLEND );

            }
            else {

                this.enable( gl.BLEND );
                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

            }

            currentBlending = blending;

        }

        if ( blending === THREE.CustomBlending ) {

            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;

            if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

                gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;

            }

            if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

                gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;

            }

        }
        else {

            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;

        }

    };

    this.setDepthFunc = function( depthFunc ) {

        if ( currentDepthFunc !== depthFunc ) {

            if ( depthFunc ) {

                switch ( depthFunc ) {

                    case THREE.NeverDepth:

                        gl.depthFunc( gl.NEVER );
                        break;

                    case THREE.AlwaysDepth:

                        gl.depthFunc( gl.ALWAYS );
                        break;

                    case THREE.LessDepth:

                        gl.depthFunc( gl.LESS );
                        break;

                    case THREE.LessEqualDepth:

                        gl.depthFunc( gl.LEQUAL );
                        break;

                    case THREE.EqualDepth:

                        gl.depthFunc( gl.EQUAL );
                        break;

                    case THREE.GreaterEqualDepth:

                        gl.depthFunc( gl.GEQUAL );
                        break;

                    case THREE.GreaterDepth:

                        gl.depthFunc( gl.GREATER );
                        break;

                    case THREE.NotEqualDepth:

                        gl.depthFunc( gl.NOTEQUAL );
                        break;

                    default:

                        gl.depthFunc( gl.LEQUAL );

                }

            }
            else {

                gl.depthFunc( gl.LEQUAL );

            }

            currentDepthFunc = depthFunc;

        }

    };

    this.setDepthTest = function( depthTest ) {

        if ( depthTest ) {

            this.enable( gl.DEPTH_TEST );

        }
        else {

            this.disable( gl.DEPTH_TEST );

        }

    };

    this.setDepthWrite = function( depthWrite ) {

        if ( currentDepthWrite !== depthWrite ) {

            gl.depthMask( depthWrite );
            currentDepthWrite = depthWrite;

        }

    };

    this.setColorWrite = function( colorWrite ) {

        if ( currentColorWrite !== colorWrite ) {

            gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
            currentColorWrite = colorWrite;

        }

    };

    this.setFlipSided = function( flipSided ) {

        if ( currentFlipSided !== flipSided ) {

            if ( flipSided ) {

                gl.frontFace( gl.CW );

            }
            else {

                gl.frontFace( gl.CCW );

            }

            currentFlipSided = flipSided;

        }

    };

    this.setLineWidth = function( width ) {

        if ( width !== currentLineWidth ) {

            gl.lineWidth( width );

            currentLineWidth = width;

        }

    };

    this.setPolygonOffset = function( polygonOffset, factor, units ) {

        if ( polygonOffset ) {

            this.enable( gl.POLYGON_OFFSET_FILL );

        }
        else {

            this.disable( gl.POLYGON_OFFSET_FILL );

        }

        if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

            gl.polygonOffset( factor, units );

            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;

        }

    };

    this.setScissorTest = function( scissorTest ) {

        if ( scissorTest ) {

            this.enable( gl.SCISSOR_TEST );

        }
        else {

            this.disable( gl.SCISSOR_TEST );

        }

    };

    // texture

    this.activeTexture = function( webglSlot ) {

        if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

        if ( currentTextureSlot !== webglSlot ) {

            gl.activeTexture( webglSlot );
            currentTextureSlot = webglSlot;

        }

    }

    this.bindTexture = function( webglType, webglTexture ) {

        if ( currentTextureSlot === undefined ) {

            _this.activeTexture();

        }

        var boundTexture = currentBoundTextures[ currentTextureSlot ];

        if ( boundTexture === undefined ) {

            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[ currentTextureSlot ] = boundTexture;

        }

        if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

            gl.bindTexture( webglType, webglTexture );

            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;

        }

    };

    this.compressedTexImage2D = function() {

        try {

            gl.compressedTexImage2D.apply( gl, arguments );

        }
        catch ( error ) {

            console.error( error );

        }

    };

    this.texImage2D = function() {

        try {

            gl.texImage2D.apply( gl, arguments );

        }
        catch ( error ) {

            console.error( error );

        }

    };

    //

    this.reset = function() {

        for ( var i = 0; i < enabledAttributes.length; i++ ) {

            if ( enabledAttributes[ i ] === 1 ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

        capabilities = {};

        compressedTextureFormats = null;

        currentBlending = null;

        currentDepthWrite = null;
        currentColorWrite = null;

        currentFlipSided = null;

    };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function( renderer, flares ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var hasVertexTexture;

    var tempTexture, occlusionTexture;

    var init = function() {

        var vertices = new Float32Array( [ -1, -1, 0, 0,
            1, -1, 1, 0,
            1, 1, 1, 1, -1, 1, 0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        // buffers

        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        // textures

        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();

        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

        var shader;

        if ( hasVertexTexture ) {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "uniform sampler2D occlusionMap;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if( renderType == 2 ) {",

                    "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

                    "vVisibility =        visibility.r / 9.0;",
                    "vVisibility *= 1.0 - visibility.g / 9.0;",
                    "vVisibility *=       visibility.b / 9.0;",
                    "vVisibility *= 1.0 - visibility.a / 9.0;",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    // pink square

                    "if( renderType == 0 ) {",

                    "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

                    // restore

                    "} else if( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * vVisibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }
        else {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if( renderType == 2 ) {",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "precision mediump float;",

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform sampler2D occlusionMap;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",

                    "void main() {",

                    // pink square

                    "if( renderType == 0 ) {",

                    "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

                    // restore

                    "} else if( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
                    "visibility = ( 1.0 - visibility / 4.0 );",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * visibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }

        program = createProgram( shader );

        attributes = {
            vertex: gl.getAttribLocation( program, "position" ),
            uv: gl.getAttribLocation( program, "uv" )
        };

        uniforms = {
            renderType: gl.getUniformLocation( program, "renderType" ),
            map: gl.getUniformLocation( program, "map" ),
            occlusionMap: gl.getUniformLocation( program, "occlusionMap" ),
            opacity: gl.getUniformLocation( program, "opacity" ),
            color: gl.getUniformLocation( program, "color" ),
            scale: gl.getUniformLocation( program, "scale" ),
            rotation: gl.getUniformLocation( program, "rotation" ),
            screenPosition: gl.getUniformLocation( program, "screenPosition" )
        };

    };

    /*
     * Render lens flares
     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
     *         reads these back and calculates occlusion.
     */

    this.render = function( scene, camera, viewportWidth, viewportHeight ) {

        if ( flares.length === 0 ) return;

        var tempPosition = new THREE.Vector3();

        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;

        var size = 16 / viewportHeight,
            scale = new THREE.Vector2( size * invAspect, size );

        var screenPosition = new THREE.Vector3( 1, 1, 0 ),
            screenPositionPixels = new THREE.Vector2( 1, 1 );

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.vertex );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        // loop through all lens flares to update their occlusion and positions
        // setup gl and common used attribs/uniforms

        gl.uniform1i( uniforms.occlusionMap, 0 );
        gl.uniform1i( uniforms.map, 1 );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        state.disable( gl.CULL_FACE );
        gl.depthMask( false );

        for ( var i = 0, l = flares.length; i < l; i++ ) {

            size = 16 / viewportHeight;
            scale.set( size * invAspect, size );

            // calc object screen position

            var flare = flares[ i ];

            tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

            tempPosition.applyMatrix4( camera.matrixWorldInverse );
            tempPosition.applyProjection( camera.projectionMatrix );

            // setup arrays for gl programs

            screenPosition.copy( tempPosition );

            screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
            screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

            // screen cull

            if ( hasVertexTexture || (
                screenPositionPixels.x > 0 &&
                screenPositionPixels.x < viewportWidth &&
                screenPositionPixels.y > 0 &&
                screenPositionPixels.y < viewportHeight ) ) {

                // save current RGB to temp texture

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, null );
                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // render pink quad

                gl.uniform1i( uniforms.renderType, 0 );
                gl.uniform2f( uniforms.scale, scale.x, scale.y );
                gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

                state.disable( gl.BLEND );
                state.enable( gl.DEPTH_TEST );

                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // copy result to occlusionMap

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // restore graphics

                gl.uniform1i( uniforms.renderType, 1 );
                state.disable( gl.DEPTH_TEST );

                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // update object positions

                flare.positionScreen.copy( screenPosition );

                if ( flare.customUpdateCallback ) {

                    flare.customUpdateCallback( flare );

                }
                else {

                    flare.updateLensFlares();

                }

                // render flares

                gl.uniform1i( uniforms.renderType, 2 );
                state.enable( gl.BLEND );

                for ( var j = 0, jl = flare.lensFlares.length; j < jl; j++ ) {

                    var sprite = flare.lensFlares[ j ];

                    if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;

                        size = sprite.size * sprite.scale / viewportHeight;

                        scale.x = size * invAspect;
                        scale.y = size;

                        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
                        gl.uniform2f( uniforms.scale, scale.x, scale.y );
                        gl.uniform1f( uniforms.rotation, sprite.rotation );

                        gl.uniform1f( uniforms.opacity, sprite.opacity );
                        gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

                        state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
                        renderer.setTexture( sprite.texture, 1 );

                        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

                    }

                }

            }

        }

        // restore gl

        state.enable( gl.CULL_FACE );
        state.enable( gl.DEPTH_TEST );
        gl.depthMask( true );

        renderer.resetGLState();

    };

    function createProgram( shader ) {

        var program = gl.createProgram();

        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
        var vertexShader = gl.createShader( gl.VERTEX_SHADER );

        var prefix = "precision " + renderer.getPrecision() + " float;\n";

        gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
        gl.shaderSource( vertexShader, prefix + shader.vertexShader );

        gl.compileShader( fragmentShader );
        gl.compileShader( vertexShader );

        gl.attachShader( program, fragmentShader );
        gl.attachShader( program, vertexShader );

        gl.linkProgram( program );

        return program;

    }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function( renderer, sprites ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;

    var texture;

    // decompose matrixWorld

    var spritePosition = new THREE.Vector3();
    var spriteRotation = new THREE.Quaternion();
    var spriteScale = new THREE.Vector3();

    var init = function() {

        var vertices = new Float32Array( [ -0.5, -0.5, 0, 0,
            0.5, -0.5, 1, 0,
            0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        program = createProgram();

        attributes = {
            position: gl.getAttribLocation( program, 'position' ),
            uv: gl.getAttribLocation( program, 'uv' )
        };

        uniforms = {
            uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
            uvScale: gl.getUniformLocation( program, 'uvScale' ),

            rotation: gl.getUniformLocation( program, 'rotation' ),
            scale: gl.getUniformLocation( program, 'scale' ),

            color: gl.getUniformLocation( program, 'color' ),
            map: gl.getUniformLocation( program, 'map' ),
            opacity: gl.getUniformLocation( program, 'opacity' ),

            modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
            projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

            fogType: gl.getUniformLocation( program, 'fogType' ),
            fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
            fogNear: gl.getUniformLocation( program, 'fogNear' ),
            fogFar: gl.getUniformLocation( program, 'fogFar' ),
            fogColor: gl.getUniformLocation( program, 'fogColor' ),

            alphaTest: gl.getUniformLocation( program, 'alphaTest' )
        };

        var canvas = document.createElement( 'canvas' );
        canvas.width = 8;
        canvas.height = 8;

        var context = canvas.getContext( '2d' );
        context.fillStyle = 'white';
        context.fillRect( 0, 0, 8, 8 );

        texture = new THREE.Texture( canvas );
        texture.needsUpdate = true;

    };

    this.render = function( scene, camera ) {

        if ( sprites.length === 0 ) return;

        // setup gl

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.position );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        state.disable( gl.CULL_FACE );
        state.enable( gl.BLEND );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

        state.activeTexture( gl.TEXTURE0 );
        gl.uniform1i( uniforms.map, 0 );

        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;

        if ( fog ) {

            gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

            if ( fog instanceof THREE.Fog ) {

                gl.uniform1f( uniforms.fogNear, fog.near );
                gl.uniform1f( uniforms.fogFar, fog.far );

                gl.uniform1i( uniforms.fogType, 1 );
                oldFogType = 1;
                sceneFogType = 1;

            }
            else if ( fog instanceof THREE.FogExp2 ) {

                gl.uniform1f( uniforms.fogDensity, fog.density );

                gl.uniform1i( uniforms.fogType, 2 );
                oldFogType = 2;
                sceneFogType = 2;

            }

        }
        else {

            gl.uniform1i( uniforms.fogType, 0 );
            oldFogType = 0;
            sceneFogType = 0;

        }


        // update positions and sort

        for ( var i = 0, l = sprites.length; i < l; i++ ) {

            var sprite = sprites[ i ];

            sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
            sprite.z = -sprite.modelViewMatrix.elements[ 14 ];

        }

        sprites.sort( painterSortStable );

        // render all sprites

        var scale = [];

        for ( var i = 0, l = sprites.length; i < l; i++ ) {

            var sprite = sprites[ i ];
            var material = sprite.material;

            gl.uniform1f( uniforms.alphaTest, material.alphaTest );
            gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

            sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

            scale[ 0 ] = spriteScale.x;
            scale[ 1 ] = spriteScale.y;

            var fogType = 0;

            if ( scene.fog && material.fog ) {

                fogType = sceneFogType;

            }

            if ( oldFogType !== fogType ) {

                gl.uniform1i( uniforms.fogType, fogType );
                oldFogType = fogType;

            }

            if ( material.map !== null ) {

                gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
                gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

            }
            else {

                gl.uniform2f( uniforms.uvOffset, 0, 0 );
                gl.uniform2f( uniforms.uvScale, 1, 1 );

            }

            gl.uniform1f( uniforms.opacity, material.opacity );
            gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

            gl.uniform1f( uniforms.rotation, material.rotation );
            gl.uniform2fv( uniforms.scale, scale );

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
            state.setDepthTest( material.depthTest );
            state.setDepthWrite( material.depthWrite );

            if ( material.map && material.map.image && material.map.image.width ) {

                renderer.setTexture( material.map, 0 );

            }
            else {

                renderer.setTexture( texture, 0 );

            }

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

        }

        // restore gl

        state.enable( gl.CULL_FACE );

        renderer.resetGLState();

    };

    function createProgram() {

        var program = gl.createProgram();

        var vertexShader = gl.createShader( gl.VERTEX_SHADER );
        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

        gl.shaderSource( vertexShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform float rotation;',
            'uniform vec2 scale;',
            'uniform vec2 uvOffset;',
            'uniform vec2 uvScale;',

            'attribute vec2 position;',
            'attribute vec2 uv;',

            'varying vec2 vUV;',

            'void main() {',

            'vUV = uvOffset + uv * uvScale;',

            'vec2 alignedPosition = position * scale;',

            'vec2 rotatedPosition;',
            'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
            'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

            'vec4 finalPosition;',

            'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
            'finalPosition.xy += rotatedPosition;',
            'finalPosition = projectionMatrix * finalPosition;',

            'gl_Position = finalPosition;',

            '}'

        ].join( '\n' ) );

        gl.shaderSource( fragmentShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform vec3 color;',
            'uniform sampler2D map;',
            'uniform float opacity;',

            'uniform int fogType;',
            'uniform vec3 fogColor;',
            'uniform float fogDensity;',
            'uniform float fogNear;',
            'uniform float fogFar;',
            'uniform float alphaTest;',

            'varying vec2 vUV;',

            'void main() {',

            'vec4 texture = texture2D( map, vUV );',

            'if ( texture.a < alphaTest ) discard;',

            'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

            'if ( fogType > 0 ) {',

            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
            'float fogFactor = 0.0;',

            'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

            '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

            '}',

            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

            '}',

            '}'

        ].join( '\n' ) );

        gl.compileShader( vertexShader );
        gl.compileShader( fragmentShader );

        gl.attachShader( program, vertexShader );
        gl.attachShader( program, fragmentShader );

        gl.linkProgram( program );

        return program;

    }

    function painterSortStable( a, b ) {

        if ( a.z !== b.z ) {

            return b.z - a.z;

        }
        else {

            return b.id - a.id;

        }

    }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

    merge: function( geometry1, geometry2, materialIndexOffset ) {

        console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

        var matrix;

        if ( geometry2 instanceof THREE.Mesh ) {

            geometry2.matrixAutoUpdate && geometry2.updateMatrix();

            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;

        }

        geometry1.merge( geometry2, matrix, materialIndexOffset );

    },

    center: function( geometry ) {

        console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
        return geometry.center();

    }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

    crossOrigin: undefined,

    loadTexture: function( url, mapping, onLoad, onError ) {

        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;

        var texture = new THREE.Texture( undefined, mapping );

        loader.load( url, function( image ) {

            texture.image = image;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

        }, undefined, function( event ) {

            if ( onError ) onError( event );

        } );

        texture.sourceFile = url;

        return texture;

    },

    loadTextureCube: function( array, mapping, onLoad, onError ) {

        var images = [];

        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;

        var texture = new THREE.CubeTexture( images, mapping );

        var loaded = 0;

        var loadTexture = function( i ) {

            loader.load( array[ i ], function( image ) {

                texture.images[ i ] = image;

                loaded += 1;

                if ( loaded === 6 ) {

                    texture.needsUpdate = true;

                    if ( onLoad ) onLoad( texture );

                }

            }, undefined, onError );

        };

        for ( var i = 0, il = array.length; i < il; ++i ) {

            loadTexture( i );

        }

        return texture;

    },

    loadCompressedTexture: function() {

        console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

    },

    loadCompressedTextureCube: function() {

        console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

    },

    getNormalMap: function( image, depth ) {

        // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

        var cross = function( a, b ) {

            return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

        };

        var subtract = function( a, b ) {

            return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

        };

        var normalize = function( a ) {

            var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
            return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

        };

        depth = depth | 1;

        var width = image.width;
        var height = image.height;

        var canvas = document.createElement( 'canvas' );
        canvas.width = width;
        canvas.height = height;

        var context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0 );

        var data = context.getImageData( 0, 0, width, height ).data;
        var imageData = context.createImageData( width, height );
        var output = imageData.data;

        for ( var x = 0; x < width; x++ ) {

            for ( var y = 0; y < height; y++ ) {

                var ly = y - 1 < 0 ? 0 : y - 1;
                var uy = y + 1 > height - 1 ? height - 1 : y + 1;
                var lx = x - 1 < 0 ? 0 : x - 1;
                var ux = x + 1 > width - 1 ? width - 1 : x + 1;

                var points = [];
                var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
                points.push( [ -1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
                points.push( [ -1, -1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
                points.push( [ 0, -1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
                points.push( [ 1, -1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
                points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
                points.push( [ -1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

                var normals = [];
                var num_points = points.length;

                for ( var i = 0; i < num_points; i++ ) {

                    var v1 = points[ i ];
                    var v2 = points[ ( i + 1 ) % num_points ];
                    v1 = subtract( v1, origin );
                    v2 = subtract( v2, origin );
                    normals.push( normalize( cross( v1, v2 ) ) );

                }

                var normal = [ 0, 0, 0 ];

                for ( var i = 0; i < normals.length; i++ ) {

                    normal[ 0 ] += normals[ i ][ 0 ];
                    normal[ 1 ] += normals[ i ][ 1 ];
                    normal[ 2 ] += normals[ i ][ 2 ];

                }

                normal[ 0 ] /= normals.length;
                normal[ 1 ] /= normals.length;
                normal[ 2 ] /= normals.length;

                var idx = ( y * width + x ) * 4;

                output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
                output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
                output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
                output[ idx + 3 ] = 255;

            }

        }

        context.putImageData( imageData, 0, 0 );

        return canvas;

    },

    generateDataTexture: function( width, height, color ) {

        var size = width * height;
        var data = new Uint8Array( 3 * size );

        var r = Math.floor( color.r * 255 );
        var g = Math.floor( color.g * 255 );
        var b = Math.floor( color.b * 255 );

        for ( var i = 0; i < size; i++ ) {

            data[ i * 3 ] = r;
            data[ i * 3 + 1 ] = g;
            data[ i * 3 + 2 ] = b;

        }

        var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
        texture.needsUpdate = true;

        return texture;

    }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

    createMultiMaterialObject: function( geometry, materials ) {

        var group = new THREE.Group();

        for ( var i = 0, l = materials.length; i < l; i++ ) {

            group.add( new THREE.Mesh( geometry, materials[ i ] ) );

        }

        return group;

    },

    detach: function( child, parent, scene ) {

        child.applyMatrix( parent.matrixWorld );
        parent.remove( child );
        scene.add( child );

    },

    attach: function( child, scene, parent ) {

        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse( parent.matrixWorld );
        child.applyMatrix( matrixWorldInverse );

        scene.remove( child );
        parent.add( child );

    }

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

    faces: {},

    // Just for now. face[weight][style]

    face: 'helvetiker',
    weight: 'normal',
    style: 'normal',
    size: 150,
    divisions: 10,

    getFace: function() {

        try {

            return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

        }
        catch ( e ) {

            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

        }

    },

    loadFace: function( data ) {

        var family = data.familyName.toLowerCase();

        var ThreeFont = this;

        ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

        ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        return data;

    },

    drawText: function( text ) {

        // RenderText

        var i,
            face = this.getFace(),
            scale = this.size / face.resolution,
            offset = 0,
            chars = String( text ).split( '' ),
            length = chars.length;

        var fontPaths = [];

        for ( i = 0; i < length; i++ ) {

            var path = new THREE.Path();

            var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
            offset += ret.offset;

            fontPaths.push( ret.path );

        }

        // get the width

        var width = offset / 2;
        //
        // for ( p = 0; p < allPts.length; p++ ) {
        //
        // 	allPts[ p ].x -= width;
        //
        // }

        //var extract = this.extractPoints( allPts, characterPts );
        //extract.contour = allPts;

        //extract.paths = fontPaths;
        //extract.offset = width;

        return {
            paths: fontPaths,
            offset: width
        };

    },




    extractGlyphPoints: function( c, face, scale, offset, path ) {

        var pts = [];

        var i, i2, divisions,
            outline, action, length,
            scaleX, scaleY,
            x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
            laste,
            glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

        if ( !glyph ) return;

        if ( glyph.o ) {

            outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
            length = outline.length;

            scaleX = scale;
            scaleY = scale;

            for ( i = 0; i < length; ) {

                action = outline[ i++ ];

                //console.log( action );

                switch ( action ) {

                    case 'm':

                        // Move To

                        x = outline[ i++ ] * scaleX + offset;
                        y = outline[ i++ ] * scaleY;

                        path.moveTo( x, y );
                        break;

                    case 'l':

                        // Line To

                        x = outline[ i++ ] * scaleX + offset;
                        y = outline[ i++ ] * scaleY;
                        path.lineTo( x, y );
                        break;

                    case 'q':

                        // QuadraticCurveTo

                        cpx = outline[ i++ ] * scaleX + offset;
                        cpy = outline[ i++ ] * scaleY;
                        cpx1 = outline[ i++ ] * scaleX + offset;
                        cpy1 = outline[ i++ ] * scaleY;

                        path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2++ ) {

                                var t = i2 / divisions;
                                THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
                                THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

                            }

                        }

                        break;

                    case 'b':

                        // Cubic Bezier Curve

                        cpx = outline[ i++ ] * scaleX + offset;
                        cpy = outline[ i++ ] * scaleY;
                        cpx1 = outline[ i++ ] * scaleX + offset;
                        cpy1 = outline[ i++ ] * scaleY;
                        cpx2 = outline[ i++ ] * scaleX + offset;
                        cpy2 = outline[ i++ ] * scaleY;

                        path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2++ ) {

                                var t = i2 / divisions;
                                THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
                                THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

                            }

                        }

                        break;

                }

            }

        }



        return {
            offset: glyph.ha * scale,
            path: path
        };

    }

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

    // Parameters

    parameters = parameters || {};

    var size = parameters.size !== undefined ? parameters.size : 100;
    var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

    var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
    var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
    var style = parameters.style !== undefined ? parameters.style : 'normal';

    THREE.FontUtils.size = size;
    THREE.FontUtils.divisions = curveSegments;

    THREE.FontUtils.face = font;
    THREE.FontUtils.weight = weight;
    THREE.FontUtils.style = style;

    // Get a Font data json object

    var data = THREE.FontUtils.drawText( text );

    var paths = data.paths;
    var shapes = [];

    for ( var p = 0, pl = paths.length; p < pl; p++ ) {

        Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    }

    return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

    var EPSILON = 0.0000000001;

    // takes in an contour array and returns

    var process = function( contour, indices ) {

        var n = contour.length;

        if ( n < 3 ) return null;

        var result = [],
            verts = [],
            vertIndices = [];

        /* we want a counter-clockwise polygon in verts */

        var u, v, w;

        if ( area( contour ) > 0.0 ) {

            for ( v = 0; v < n; v++ ) verts[ v ] = v;

        }
        else {

            for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

        }

        var nv = n;

        /*  remove nv - 2 vertices, creating 1 triangle every time */

        var count = 2 * nv; /* error detection */

        for ( v = nv - 1; nv > 2; ) {

            /* if we loop, it is probably a non-simple polygon */

            if ( ( count-- ) <= 0 ) {

                //** Triangulate: ERROR - probable bad polygon!

                //throw ( "Warning, unable to triangulate polygon!" );
                //return null;
                // Sometimes warning is fine, especially polygons are triangulated in reverse.
                console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

                if ( indices ) return vertIndices;
                return result;

            }

            /* three consecutive vertices in current polygon, <u,v,w> */

            u = v;
            if ( nv <= u ) u = 0; /* previous */
            v = u + 1;
            if ( nv <= v ) v = 0; /* new v    */
            w = v + 1;
            if ( nv <= w ) w = 0; /* next     */

            if ( snip( contour, u, v, w, nv, verts ) ) {

                var a, b, c, s, t;

                /* true names of the vertices */

                a = verts[ u ];
                b = verts[ v ];
                c = verts[ w ];

                /* output Triangle */

                result.push( [ contour[ a ],
                    contour[ b ],
                    contour[ c ]
                ] );


                vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

                /* remove v from the remaining polygon */

                for ( s = v, t = v + 1; t < nv; s++, t++ ) {

                    verts[ s ] = verts[ t ];

                }

                nv--;

                /* reset error detection counter */

                count = 2 * nv;

            }

        }

        if ( indices ) return vertIndices;
        return result;

    };

    // calculate area of the contour polygon

    var area = function( contour ) {

        var n = contour.length;
        var a = 0.0;

        for ( var p = n - 1, q = 0; q < n; p = q++ ) {

            a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

        }

        return a * 0.5;

    };

    var snip = function( contour, u, v, w, n, verts ) {

        var p;
        var ax, ay, bx, by;
        var cx, cy, px, py;

        ax = contour[ verts[ u ] ].x;
        ay = contour[ verts[ u ] ].y;

        bx = contour[ verts[ v ] ].x;
        by = contour[ verts[ v ] ].y;

        cx = contour[ verts[ w ] ].x;
        cy = contour[ verts[ w ] ].y;

        if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

        var aX, aY, bX, bY, cX, cY;
        var apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;

        aX = cx - bx;
        aY = cy - by;
        bX = ax - cx;
        bY = ay - cy;
        cX = bx - ax;
        cY = by - ay;

        for ( p = 0; p < n; p++ ) {

            px = contour[ verts[ p ] ].x;
            py = contour[ verts[ p ] ].y;

            if ( ( ( px === ax ) && ( py === ay ) ) ||
                ( ( px === bx ) && ( py === by ) ) ||
                ( ( px === cx ) && ( py === cy ) ) ) continue;

            apx = px - ax;
            apy = py - ay;
            bpx = px - bx;
            bpy = py - by;
            cpx = px - cx;
            cpy = py - cy;

            // see if p is inside triangle abc

            aCROSSbp = aX * bpy - aY * bpx;
            cCROSSap = cX * apy - cY * apx;
            bCROSScp = bX * cpy - bY * cpx;

            if ( ( aCROSSbp >= -EPSILON ) && ( bCROSScp >= -EPSILON ) && ( cCROSSap >= -EPSILON ) ) return false;

        }

        return true;

    };


    namespace.Triangulate = process;
    namespace.Triangulate.area = area;

    return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API

THREE.typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
};
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function( listener ) {

    THREE.Object3D.call( this );

    this.type = 'Audio';

    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind( this );

    this.gain = this.context.createGain();
    this.gain.connect( this.context.destination );

    this.panner = this.context.createPanner();
    this.panner.connect( this.gain );

    this.autoplay = false;

    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function( file ) {

    var scope = this;

    var request = new XMLHttpRequest();
    request.open( 'GET', file, true );
    request.responseType = 'arraybuffer';
    request.onload = function( e ) {

        scope.context.decodeAudioData( this.response, function( buffer ) {

            scope.source.buffer = buffer;

            if ( scope.autoplay ) scope.play();

        } );

    };
    request.send();

    return this;

};

THREE.Audio.prototype.play = function() {

    if ( this.isPlaying === true ) {

        console.warn( 'THREE.Audio: Audio is already playing.' );
        return;

    }

    var source = this.context.createBufferSource();

    source.buffer = this.source.buffer;
    source.loop = this.source.loop;
    source.onended = this.source.onended;
    source.start( 0, this.startTime );
    source.playbackRate.value = this.playbackRate;

    this.isPlaying = true;

    this.source = source;

    this.connect();

};

THREE.Audio.prototype.pause = function() {

    this.source.stop();
    this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function() {

    this.source.stop();
    this.startTime = 0;

};

THREE.Audio.prototype.connect = function() {

    if ( this.filter !== undefined ) {

        this.source.connect( this.filter );
        this.filter.connect( this.panner );

    }
    else {

        this.source.connect( this.panner );

    }

};

THREE.Audio.prototype.disconnect = function() {

    if ( this.filter !== undefined ) {

        this.source.disconnect( this.filter );
        this.filter.disconnect( this.panner );

    }
    else {

        this.source.disconnect( this.panner );

    }

};

THREE.Audio.prototype.setFilter = function( value ) {

    if ( this.isPlaying === true ) {

        this.disconnect();
        this.filter = value;
        this.connect();

    }
    else {

        this.filter = value;

    }

};

THREE.Audio.prototype.getFilter = function() {

    return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function( value ) {

    this.playbackRate = value;

    if ( this.isPlaying === true ) {

        this.source.playbackRate.value = this.playbackRate;

    }

};

THREE.Audio.prototype.getPlaybackRate = function() {

    return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

    this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function( value ) {

    this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function() {

    return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function( value ) {

    this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function() {

    return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function( value ) {

    this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function() {

    return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function( value ) {

    this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function() {

    return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function() {

    var position = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        position.setFromMatrixPosition( this.matrixWorld );

        this.panner.setPosition( position.x, position.y, position.z );

    };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function() {

    THREE.Object3D.call( this );

    this.type = 'AudioListener';

    this.context = new( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function() {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();

    var orientation = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        var listener = this.context.listener;
        var up = this.up;

        this.matrixWorld.decompose( position, quaternion, scale );

        orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );

        listener.setPosition( position.x, position.y, position.z );
        listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function() {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function( t ) {

    console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function( u ) {

    var t = this.getUtoTmapping( u );
    return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function( divisions ) {

    if ( !divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d++ ) {

        pts.push( this.getPoint( d / divisions ) );

    }

    return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function( divisions ) {

    if ( !divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d++ ) {

        pts.push( this.getPointAt( d / divisions ) );

    }

    return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function() {

    var lengths = this.getLengths();
    return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function( divisions ) {

    if ( !divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    if ( this.cacheArcLengths && ( this.cacheArcLengths.length === divisions + 1 ) && !this.needsUpdate ) {

        //console.log( "cached", this.cacheArcLengths );
        return this.cacheArcLengths;

    }

    this.needsUpdate = false;

    var cache = [];
    var current, last = this.getPoint( 0 );
    var p, sum = 0;

    cache.push( 0 );

    for ( p = 1; p <= divisions; p++ ) {

        current = this.getPoint( p / divisions );
        sum += current.distanceTo( last );
        cache.push( sum );
        last = current;

    }

    this.cacheArcLengths = cache;

    return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {

    this.needsUpdate = true;
    this.getLengths();

};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

THREE.Curve.prototype.getUtoTmapping = function( u, distance ) {

    var arcLengths = this.getLengths();

    var i = 0,
        il = arcLengths.length;

    var targetArcLength; // The targeted u distance value to get

    if ( distance ) {

        targetArcLength = distance;

    }
    else {

        targetArcLength = u * arcLengths[ il - 1 ];

    }

    //var time = Date.now();

    // binary search for the index with largest value smaller than target u distance

    var low = 0,
        high = il - 1,
        comparison;

    while ( low <= high ) {

        i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

        comparison = arcLengths[ i ] - targetArcLength;

        if ( comparison < 0 ) {

            low = i + 1;

        }
        else if ( comparison > 0 ) {

            high = i - 1;

        }
        else {

            high = i;
            break;

            // DONE

        }

    }

    i = high;

    //console.log('b' , i, low, high, Date.now()- time);

    if ( arcLengths[ i ] === targetArcLength ) {

        var t = i / ( il - 1 );
        return t;

    }

    // we could get finer grain at lengths, or use simple interpolation between two points

    var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il - 1 );

    return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

    var delta = 0.0001;
    var t1 = t - delta;
    var t2 = t + delta;

    // Capping in case of danger

    if ( t1 < 0 ) t1 = 0;
    if ( t2 > 1 ) t2 = 1;

    var pt1 = this.getPoint( t1 );
    var pt2 = this.getPoint( t2 );

    var vec = pt2.clone().sub( pt1 );
    return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function( u ) {

    var t = this.getUtoTmapping( u );
    return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

    tangentQuadraticBezier: function( t, p0, p1, p2 ) {

        return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    },

    // Puay Bing, thanks for helping with this derivative!

    tangentCubicBezier: function( t, p0, p1, p2, p3 ) {

        return -3 * p0 * ( 1 - t ) * ( 1 - t ) +
            3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
            6 * t * p2 * ( 1 - t ) - 3 * t * t * p2 +
            3 * t * t * p3;

    },

    tangentSpline: function( t, p0, p1, p2, p3 ) {

        // To check if my formulas are correct

        var h00 = 6 * t * t - 6 * t; // derived from 2t^3 − 3t^2 + 1
        var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
        var h01 = -6 * t * t + 6 * t; // − 2t3 + 3t2
        var h11 = 3 * t * t - 2 * t; // t3 − t2

        return h00 + h10 + h01 + h11;

    },

    // Catmull-Rom

    interpolate: function( p0, p1, p2, p3, t ) {

        var v0 = ( p2 - p0 ) * 0.5;
        var v1 = ( p3 - p1 ) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function( constructor, getPointFunc ) {

    constructor.prototype = Object.create( THREE.Curve.prototype );
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;

    return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function() {

    this.curves = [];
    this.bends = [];

    this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function( curve ) {

    this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
    // TODO
    // If the ending of curve is not connected to the starting
    // or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {

    // TODO Test
    // and verify for vector3 (needs to implement equals)
    // Add a line curve if start and end of lines are not connected
    var startPoint = this.curves[ 0 ].getPoint( 0 );
    var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    if ( !startPoint.equals( endPoint ) ) {

        this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

    }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0,
        diff, curve;

    // To think about boundaries points.

    while ( i < curveLengths.length ) {

        if ( curveLengths[ i ] >= d ) {

            diff = curveLengths[ i ] - d;
            curve = this.curves[ i ];

            var u = 1 - diff / curve.getLength();

            return curve.getPointAt( u );

        }

        i++;

    }

    return null;

    // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

    var lens = this.getCurveLengths();
    return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

    // We use cache values if curves and cache array are same length

    if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

        return this.cacheLengths;

    }

    // Get length of sub-curve
    // Push sums into cached array

    var lengths = [],
        sums = 0;
    var i, il = this.curves.length;

    for ( i = 0; i < il; i++ ) {

        sums += this.curves[ i ].getLength();
        lengths.push( sums );

    }

    this.cacheLengths = lengths;

    return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function() {

    var points = this.getPoints();

    var maxX, maxY, maxZ;
    var minX, minY, minZ;

    maxX = maxY = Number.NEGATIVE_INFINITY;
    minX = minY = Number.POSITIVE_INFINITY;

    var p, i, il, sum;

    var v3 = points[ 0 ] instanceof THREE.Vector3;

    sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

    for ( i = 0, il = points.length; i < il; i++ ) {

        p = points[ i ];

        if ( p.x > maxX ) maxX = p.x;
        else if ( p.x < minX ) minX = p.x;

        if ( p.y > maxY ) maxY = p.y;
        else if ( p.y < minY ) minY = p.y;

        if ( v3 ) {

            if ( p.z > maxZ ) maxZ = p.z;
            else if ( p.z < minZ ) minZ = p.z;

        }

        sum.add( p );

    }

    var ret = {

        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY

    };

    if ( v3 ) {

        ret.maxZ = maxZ;
        ret.minZ = minZ;

    }

    return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

    var pts = this.getPoints( divisions, true );
    return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

    var pts = this.getSpacedPoints( divisions, true );
    return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < points.length; i++ ) {

        geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0 ) );

    }

    return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function( bendpath ) {

    this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

    var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
    var i, il;

    if ( !bends ) {

        bends = this.bends;

    }

    for ( i = 0, il = bends.length; i < il; i++ ) {

        oldPts = this.getWrapPoints( oldPts, bends[ i ] );

    }

    return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

    var oldPts = this.getSpacedPoints( segments );

    var i, il;

    if ( !bends ) {

        bends = this.bends;

    }

    for ( i = 0, il = bends.length; i < il; i++ ) {

        oldPts = this.getWrapPoints( oldPts, bends[ i ] );

    }

    return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function( oldPts, path ) {

    var bounds = this.getBoundingBox();

    var i, il, p, oldX, oldY, xNorm;

    for ( i = 0, il = oldPts.length; i < il; i++ ) {

        p = oldPts[ i ];

        oldX = p.x;
        oldY = p.y;

        xNorm = oldX / bounds.maxX;

        // If using actual distance, for length > path, requires line extrusions
        //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

        xNorm = path.getUtoTmapping( xNorm, oldX );

        // check for out of bounds?

        var pathPt = path.getPoint( xNorm );
        var normal = path.getTangent( xNorm );
        normal.set( -normal.y, normal.x ).multiplyScalar( oldY );

        p.x = pathPt.x + normal.x;
        p.y = pathPt.y + normal.y;

    }

    return oldPts;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function( points ) {

    THREE.CurvePath.call( this );

    this.actions = [];

    if ( points ) {

        this.fromPoints( points );

    }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {

    MOVE_TO: 'moveTo',
    LINE_TO: 'lineTo',
    QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
    BEZIER_CURVE_TO: 'bezierCurveTo', // Bezier cubic curve
    CSPLINE_THRU: 'splineThru', // Catmull-Rom spline
    ARC: 'arc', // Circle
    ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function( vectors ) {

    this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    for ( var v = 1, vlen = vectors.length; v < vlen; v++ ) {

        this.lineTo( vectors[ v ].x, vectors[ v ].y );

    }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function( x, y ) {

    var args = Array.prototype.slice.call( arguments );
    this.actions.push( {
        action: THREE.PathActions.MOVE_TO,
        args: args
    } );

};

THREE.Path.prototype.lineTo = function( x, y ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.LINE_TO,
        args: args
    } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCPx, aCPy ),
        new THREE.Vector2( aX, aY ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: args
    } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
    aCP2x, aCP2y,
    aX, aY ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCP1x, aCP1y ),
        new THREE.Vector2( aCP2x, aCP2y ),
        new THREE.Vector2( aX, aY ) );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: args
    } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

    var args = Array.prototype.slice.call( arguments );
    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];
    //---
    var npts = [ new THREE.Vector2( x0, y0 ) ];
    Array.prototype.push.apply( npts, pts );

    var curve = new THREE.SplineCurve( npts );
    this.curves.push( curve );

    this.actions.push( {
        action: THREE.PathActions.CSPLINE_THRU,
        args: args
    } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function( aX, aY, aRadius,
    aStartAngle, aEndAngle, aClockwise ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absarc( aX + x0, aY + y0, aRadius,
        aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.absarc = function( aX, aY, aRadius,
    aStartAngle, aEndAngle, aClockwise ) {

    this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.ellipse = function( aX, aY, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absellipse( aX + x0, aY + y0, xRadius, yRadius,
        aStartAngle, aEndAngle, aClockwise, aRotation );

};


THREE.Path.prototype.absellipse = function( aX, aY, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var args = [
        aX, aY,
        xRadius, yRadius,
        aStartAngle, aEndAngle,
        aClockwise,
        aRotation || 0 // aRotation is optional.
    ];
    var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
        aStartAngle, aEndAngle, aClockwise, aRotation );
    this.curves.push( curve );

    var lastPoint = curve.getPoint( 1 );
    args.push( lastPoint.x );
    args.push( lastPoint.y );

    this.actions.push( {
        action: THREE.PathActions.ELLIPSE,
        args: args
    } );

};

THREE.Path.prototype.getSpacedPoints = function( divisions, closedPath ) {

    if ( !divisions ) divisions = 40;

    var points = [];

    for ( var i = 0; i < divisions; i++ ) {

        points.push( this.getPoint( i / divisions ) );

        //if( !this.getPoint( i / divisions ) ) throw "DIE";

    }

    // if ( closedPath ) {
    //
    // 	points.push( points[ 0 ] );
    //
    // }

    return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

    if ( this.useSpacedPoints ) {

        return this.getSpacedPoints( divisions, closedPath );

    }

    divisions = divisions || 12;

    var points = [];

    var i, il, item, action, args;
    var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
        laste, j,
        t, tx, ty;

    for ( i = 0, il = this.actions.length; i < il; i++ ) {

        item = this.actions[ i ];

        action = item.action;
        args = item.args;

        switch ( action ) {

            case THREE.PathActions.MOVE_TO:

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case THREE.PathActions.LINE_TO:

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case THREE.PathActions.QUADRATIC_CURVE_TO:

                cpx = args[ 2 ];
                cpy = args[ 3 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                }
                else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }

                for ( j = 1; j <= divisions; j++ ) {

                    t = j / divisions;

                    tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
                    ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case THREE.PathActions.BEZIER_CURVE_TO:

                cpx = args[ 4 ];
                cpy = args[ 5 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                cpx2 = args[ 2 ];
                cpy2 = args[ 3 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                }
                else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }


                for ( j = 1; j <= divisions; j++ ) {

                    t = j / divisions;

                    tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
                    ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case THREE.PathActions.CSPLINE_THRU:

                laste = this.actions[ i - 1 ].args;

                var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
                var spts = [ last ];

                var n = divisions * args[ 0 ].length;

                spts = spts.concat( args[ 0 ] );

                var spline = new THREE.SplineCurve( spts );

                for ( j = 1; j <= n; j++ ) {

                    points.push( spline.getPointAt( j / n ) );

                }

                break;

            case THREE.PathActions.ARC:

                var aX = args[ 0 ],
                    aY = args[ 1 ],
                    aRadius = args[ 2 ],
                    aStartAngle = args[ 3 ],
                    aEndAngle = args[ 4 ],
                    aClockwise = !!args[ 5 ];

                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                for ( j = 1; j <= tdivisions; j++ ) {

                    t = j / tdivisions;

                    if ( !aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + aRadius * Math.cos( angle );
                    ty = aY + aRadius * Math.sin( angle );

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

            case THREE.PathActions.ELLIPSE:

                var aX = args[ 0 ],
                    aY = args[ 1 ],
                    xRadius = args[ 2 ],
                    yRadius = args[ 3 ],
                    aStartAngle = args[ 4 ],
                    aEndAngle = args[ 5 ],
                    aClockwise = !!args[ 6 ],
                    aRotation = args[ 7 ];


                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                var cos, sin;
                if ( aRotation !== 0 ) {

                    cos = Math.cos( aRotation );
                    sin = Math.sin( aRotation );

                }

                for ( j = 1; j <= tdivisions; j++ ) {

                    t = j / tdivisions;

                    if ( !aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + xRadius * Math.cos( angle );
                    ty = aY + yRadius * Math.sin( angle );

                    if ( aRotation !== 0 ) {

                        var x = tx,
                            y = ty;

                        // Rotate the point about the center of the ellipse.
                        tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
                        ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

                    }

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

        } // end switch

    }



    // Normalize to remove the closing point by default.
    var lastPoint = points[ points.length - 1 ];
    var EPSILON = 0.0000000001;
    if ( Math.abs( lastPoint.x - points[ 0 ].x ) < EPSILON &&
        Math.abs( lastPoint.y - points[ 0 ].y ) < EPSILON )
        points.splice( points.length - 1, 1 );
    if ( closedPath ) {

        points.push( points[ 0 ] );

    }

    return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

    function extractSubpaths( inActions ) {

        var i, il, item, action, args;

        var subPaths = [],
            lastPath = new THREE.Path();

        for ( i = 0, il = inActions.length; i < il; i++ ) {

            item = inActions[ i ];

            args = item.args;
            action = item.action;

            if ( action === THREE.PathActions.MOVE_TO ) {

                if ( lastPath.actions.length !== 0 ) {

                    subPaths.push( lastPath );
                    lastPath = new THREE.Path();

                }

            }

            lastPath[ action ].apply( lastPath, args );

        }

        if ( lastPath.actions.length !== 0 ) {

            subPaths.push( lastPath );

        }

        // console.log(subPaths);

        return subPaths;

    }

    function toShapesNoHoles( inSubpaths ) {

        var shapes = [];

        for ( var i = 0, il = inSubpaths.length; i < il; i++ ) {

            var tmpPath = inSubpaths[ i ];

            var tmpShape = new THREE.Shape();
            tmpShape.actions = tmpPath.actions;
            tmpShape.curves = tmpPath.curves;

            shapes.push( tmpShape );

        }

        //console.log("shape", shapes);

        return shapes;

    }

    function isPointInsidePolygon( inPt, inPolygon ) {

        var EPSILON = 0.0000000001;

        var polyLen = inPolygon.length;

        // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line
        var inside = false;
        for ( var p = polyLen - 1, q = 0; q < polyLen; p = q++ ) {

            var edgeLowPt = inPolygon[ p ];
            var edgeHighPt = inPolygon[ q ];

            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;

            if ( Math.abs( edgeDy ) > EPSILON ) {

                // not parallel
                if ( edgeDy < 0 ) {

                    edgeLowPt = inPolygon[ q ];
                    edgeDx = -edgeDx;
                    edgeHighPt = inPolygon[ p ];
                    edgeDy = -edgeDy;

                }
                if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) continue;

                if ( inPt.y === edgeLowPt.y ) {

                    if ( inPt.x === edgeLowPt.x ) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!

                }
                else {

                    var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
                    if ( perpEdge === 0 ) return true; // inPt is on contour ?
                    if ( perpEdge < 0 ) continue;
                    inside = !inside; // true intersection left of inPt

                }

            }
            else {

                // parallel or collinear
                if ( inPt.y !== edgeLowPt.y ) continue; // parallel
                // edge lies on the same horizontal line as inPt
                if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
                    ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) ) return true; // inPt: Point on contour !
                // continue;

            }

        }

        return inside;

    }


    var subPaths = extractSubpaths( this.actions );
    if ( subPaths.length === 0 ) return [];

    if ( noHoles === true ) return toShapesNoHoles( subPaths );


    var solid, tmpPath, tmpShape, shapes = [];

    if ( subPaths.length === 1 ) {

        tmpPath = subPaths[ 0 ];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push( tmpShape );
        return shapes;

    }

    var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
    holesFirst = isCCW ? !holesFirst : holesFirst;

    // console.log("Holes first", holesFirst);

    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;

    newShapes[ mainIdx ] = undefined;
    newShapeHoles[ mainIdx ] = [];

    var i, il;

    for ( i = 0, il = subPaths.length; i < il; i++ ) {

        tmpPath = subPaths[ i ];
        tmpPoints = tmpPath.getPoints();
        solid = THREE.Shape.Utils.isClockWise( tmpPoints );
        solid = isCCW ? !solid : solid;

        if ( solid ) {

            if ( ( !holesFirst ) && ( newShapes[ mainIdx ] ) ) mainIdx++;

            newShapes[ mainIdx ] = {
                s: new THREE.Shape(),
                p: tmpPoints
            };
            newShapes[ mainIdx ].s.actions = tmpPath.actions;
            newShapes[ mainIdx ].s.curves = tmpPath.curves;

            if ( holesFirst ) mainIdx++;
            newShapeHoles[ mainIdx ] = [];

            //console.log('cw', i);

        }
        else {

            newShapeHoles[ mainIdx ].push( {
                h: tmpPath,
                p: tmpPoints[ 0 ]
            } );

            //console.log('ccw', i);

        }

    }

    // only Holes? -> probably all Shapes with wrong orientation
    if ( !newShapes[ 0 ] ) return toShapesNoHoles( subPaths );


    if ( newShapes.length > 1 ) {

        var ambiguous = false;
        var toChange = [];

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {

            betterShapeHoles[ sIdx ] = [];

        }
        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {

            var sho = newShapeHoles[ sIdx ];
            for ( var hIdx = 0; hIdx < sho.length; hIdx++ ) {

                var ho = sho[ hIdx ];
                var hole_unassigned = true;
                for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx++ ) {

                    if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

                        if ( sIdx !== s2Idx ) toChange.push( {
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        } );
                        if ( hole_unassigned ) {

                            hole_unassigned = false;
                            betterShapeHoles[ s2Idx ].push( ho );

                        }
                        else {

                            ambiguous = true;

                        }

                    }

                }
                if ( hole_unassigned ) {

                    betterShapeHoles[ sIdx ].push( ho );

                }

            }

        }
        // console.log("ambiguous: ", ambiguous);
        if ( toChange.length > 0 ) {

            // console.log("to change: ", toChange);
            if ( !ambiguous ) newShapeHoles = betterShapeHoles;

        }

    }

    var tmpHoles, j, jl;
    for ( i = 0, il = newShapes.length; i < il; i++ ) {

        tmpShape = newShapes[ i ].s;
        shapes.push( tmpShape );
        tmpHoles = newShapeHoles[ i ];
        for ( j = 0, jl = tmpHoles.length; j < jl; j++ ) {

            tmpShape.holes.push( tmpHoles[ j ].h );

        }

    }

    //console.log("shape", shapes);

    return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function() {

    THREE.Path.apply( this, arguments );
    this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function( options ) {

    var extruded = new THREE.ExtrudeGeometry( this, options );
    return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function( options ) {

    var geometry = new THREE.ShapeGeometry( this, options );
    return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function( divisions ) {

    var i, il = this.holes.length,
        holesPts = [];

    for ( i = 0; i < il; i++ ) {

        holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

    }

    return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function( divisions ) {

    var i, il = this.holes.length,
        holesPts = [];

    for ( i = 0; i < il; i++ ) {

        holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

    }

    return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function( divisions ) {

    return {

        shape: this.getTransformedPoints( divisions ),
        holes: this.getPointsHoles( divisions )

    };

};

THREE.Shape.prototype.extractPoints = function( divisions ) {

    if ( this.useSpacedPoints ) {

        return this.extractAllSpacedPoints( divisions );

    }

    return this.extractAllPoints( divisions );

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function( divisions ) {

    return {

        shape: this.getTransformedSpacedPoints( divisions ),
        holes: this.getSpacedPointsHoles( divisions )

    };

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

    triangulateShape: function( contour, holes ) {

        function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

            // inOtherPt needs to be collinear to the inSegment
            if ( inSegPt1.x !== inSegPt2.x ) {

                if ( inSegPt1.x < inSegPt2.x ) {

                    return ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

                }
                else {

                    return ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

                }

            }
            else {

                if ( inSegPt1.y < inSegPt2.y ) {

                    return ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

                }
                else {

                    return ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

                }

            }

        }

        function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

            var EPSILON = 0.0000000001;

            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
                seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
                seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

            var limit = seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

            if ( Math.abs( limit ) > EPSILON ) {

                // not parallel

                var perpSeg2;
                if ( limit > 0 ) {

                    if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) return [];

                }
                else {

                    if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) return [];

                }

                // i.e. to reduce rounding errors
                // intersection at endpoint of segment#1?
                if ( perpSeg2 === 0 ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) ) return [];
                    return [ inSeg1Pt1 ];

                }
                if ( perpSeg2 === limit ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) ) return [];
                    return [ inSeg1Pt2 ];

                }
                // intersection at endpoint of segment#2?
                if ( perpSeg1 === 0 ) return [ inSeg2Pt1 ];
                if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

                // return real intersection point
                var factorSeg1 = perpSeg2 / limit;
                return [ {
                    x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                    y: inSeg1Pt1.y + factorSeg1 * seg1dy
                } ];

            }
            else {

                // parallel or collinear
                if ( ( perpSeg1 !== 0 ) ||
                    ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) return [];

                // they are collinear or degenerate
                var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) ); // segment1 is just a point?
                var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) ); // segment2 is just a point?
                // both segments are points
                if ( seg1Pt && seg2Pt ) {

                    if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
                        ( inSeg1Pt1.y !== inSeg2Pt1.y ) ) return []; // they are distinct  points
                    return [ inSeg1Pt1 ]; // they are the same point

                }
                // segment#1  is a single point
                if ( seg1Pt ) {

                    if ( !point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) ) return []; // but not in segment#2
                    return [ inSeg1Pt1 ];

                }
                // segment#2  is a single point
                if ( seg2Pt ) {

                    if ( !point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) ) return []; // but not in segment#1
                    return [ inSeg2Pt1 ];

                }

                // they are collinear segments, which might overlap
                var seg1min, seg1max, seg1minVal, seg1maxVal;
                var seg2min, seg2max, seg2minVal, seg2maxVal;
                if ( seg1dx !== 0 ) {

                    // the segments are NOT on a vertical line
                    if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.x;

                    }
                    else {

                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.x;

                    }
                    if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.x;

                    }
                    else {

                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.x;

                    }

                }
                else {

                    // the segments are on a vertical line
                    if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.y;

                    }
                    else {

                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.y;

                    }
                    if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.y;

                    }
                    else {

                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.y;

                    }

                }
                if ( seg1minVal <= seg2minVal ) {

                    if ( seg1maxVal < seg2minVal ) return [];
                    if ( seg1maxVal === seg2minVal ) {

                        if ( inExcludeAdjacentSegs ) return [];
                        return [ seg2min ];

                    }
                    if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
                    return [ seg2min, seg2max ];

                }
                else {

                    if ( seg1minVal > seg2maxVal ) return [];
                    if ( seg1minVal === seg2maxVal ) {

                        if ( inExcludeAdjacentSegs ) return [];
                        return [ seg1min ];

                    }
                    if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
                    return [ seg1min, seg2max ];

                }

            }

        }

        function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

            // The order of legs is important

            var EPSILON = 0.0000000001;

            // translation of all points, so that Vertex is at (0,0)
            var legFromPtX = inLegFromPt.x - inVertex.x,
                legFromPtY = inLegFromPt.y - inVertex.y;
            var legToPtX = inLegToPt.x - inVertex.x,
                legToPtY = inLegToPt.y - inVertex.y;
            var otherPtX = inOtherPt.x - inVertex.x,
                otherPtY = inOtherPt.y - inVertex.y;

            // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
            var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

            if ( Math.abs( from2toAngle ) > EPSILON ) {

                // angle != 180 deg.

                var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

                if ( from2toAngle > 0 ) {

                    // main angle < 180 deg.
                    return ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

                }
                else {

                    // main angle > 180 deg.
                    return ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

                }

            }
            else {

                // angle == 180 deg.
                // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                return ( from2otherAngle > 0 );

            }

        }


        function removeHoles( contour, holes ) {

            var shape = contour.concat(); // work on this shape
            var hole;

            function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

                // Check if hole point lies within angle around shape point
                var lastShapeIdx = shape.length - 1;

                var prevShapeIdx = inShapeIdx - 1;
                if ( prevShapeIdx < 0 ) prevShapeIdx = lastShapeIdx;

                var nextShapeIdx = inShapeIdx + 1;
                if ( nextShapeIdx > lastShapeIdx ) nextShapeIdx = 0;

                var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
                if ( !insideAngle ) {

                    // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                    return false;

                }

                // Check if shape point lies within angle around hole point
                var lastHoleIdx = hole.length - 1;

                var prevHoleIdx = inHoleIdx - 1;
                if ( prevHoleIdx < 0 ) prevHoleIdx = lastHoleIdx;

                var nextHoleIdx = inHoleIdx + 1;
                if ( nextHoleIdx > lastHoleIdx ) nextHoleIdx = 0;

                insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
                if ( !insideAngle ) {

                    // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
                    return false;

                }

                return true;

            }

            function intersectsShapeEdge( inShapePt, inHolePt ) {

                // checks for intersections with shape edges
                var sIdx, nextIdx, intersection;
                for ( sIdx = 0; sIdx < shape.length; sIdx++ ) {

                    nextIdx = sIdx + 1;
                    nextIdx %= shape.length;
                    intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
                    if ( intersection.length > 0 ) return true;

                }

                return false;

            }

            var indepHoles = [];

            function intersectsHoleEdge( inShapePt, inHolePt ) {

                // checks for intersections with hole edges
                var ihIdx, chkHole,
                    hIdx, nextIdx, intersection;
                for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx++ ) {

                    chkHole = holes[ indepHoles[ ihIdx ] ];
                    for ( hIdx = 0; hIdx < chkHole.length; hIdx++ ) {

                        nextIdx = hIdx + 1;
                        nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
                        if ( intersection.length > 0 ) return true;

                    }

                }
                return false;

            }

            var holeIndex, shapeIndex,
                shapePt, holePt,
                holeIdx, cutKey, failedCuts = [],
                tmpShape1, tmpShape2,
                tmpHole1, tmpHole2;

            for ( var h = 0, hl = holes.length; h < hl; h++ ) {

                indepHoles.push( h );

            }

            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while ( indepHoles.length > 0 ) {

                counter--;
                if ( counter < 0 ) {

                    console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
                    break;

                }

                // search for shape-vertex and hole-vertex,
                // which can be connected without intersections
                for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++ ) {

                    shapePt = shape[ shapeIndex ];
                    holeIndex = -1;

                    // search for hole which can be reached without intersections
                    for ( var h = 0; h < indepHoles.length; h++ ) {

                        holeIdx = indepHoles[ h ];

                        // prevent multiple checks
                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                        if ( failedCuts[ cutKey ] !== undefined ) continue;

                        hole = holes[ holeIdx ];
                        for ( var h2 = 0; h2 < hole.length; h2++ ) {

                            holePt = hole[ h2 ];
                            if ( !isCutLineInsideAngles( shapeIndex, h2 ) ) continue;
                            if ( intersectsShapeEdge( shapePt, holePt ) ) continue;
                            if ( intersectsHoleEdge( shapePt, holePt ) ) continue;

                            holeIndex = h2;
                            indepHoles.splice( h, 1 );

                            tmpShape1 = shape.slice( 0, shapeIndex + 1 );
                            tmpShape2 = shape.slice( shapeIndex );
                            tmpHole1 = hole.slice( holeIndex );
                            tmpHole2 = hole.slice( 0, holeIndex + 1 );

                            shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

                            minShapeIndex = shapeIndex;

                            // Debug only, to show the selected cuts
                            // glob_CutLines.push( [ shapePt, holePt ] );

                            break;

                        }
                        if ( holeIndex >= 0 ) break; // hole-vertex found

                        failedCuts[ cutKey ] = true; // remember failure

                    }
                    if ( holeIndex >= 0 ) break; // hole-vertex found

                }

            }

            return shape; /* shape with no holes */

        }


        var i, il, f, face,
            key, index,
            allPointsMap = {};

        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

        var allpoints = contour.concat();

        for ( var h = 0, hl = holes.length; h < hl; h++ ) {

            Array.prototype.push.apply( allpoints, holes[ h ] );

        }

        //console.log( "allpoints",allpoints, allpoints.length );

        // prepare all points map

        for ( i = 0, il = allpoints.length; i < il; i++ ) {

            key = allpoints[ i ].x + ":" + allpoints[ i ].y;

            if ( allPointsMap[ key ] !== undefined ) {

                console.warn( "THREE.Shape: Duplicate point", key );

            }

            allPointsMap[ key ] = i;

        }

        // remove holes by cutting paths to holes and adding them to the shape
        var shapeWithoutHoles = removeHoles( contour, holes );

        var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
        //console.log( "triangles",triangles, triangles.length );

        // check all face vertices against all points map

        for ( i = 0, il = triangles.length; i < il; i++ ) {

            face = triangles[ i ];

            for ( f = 0; f < 3; f++ ) {

                key = face[ f ].x + ":" + face[ f ].y;

                index = allPointsMap[ key ];

                if ( index !== undefined ) {

                    face[ f ] = index;

                }

            }

        }

        return triangles.concat();

    },

    isClockWise: function( pts ) {

        return THREE.FontUtils.Triangulate.area( pts ) < 0;

    },

    // Bezier Curves formulas obtained from
    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    // Quad Bezier Functions

    b2p0: function( t, p ) {

        var k = 1 - t;
        return k * k * p;

    },

    b2p1: function( t, p ) {

        return 2 * ( 1 - t ) * t * p;

    },

    b2p2: function( t, p ) {

        return t * t * p;

    },

    b2: function( t, p0, p1, p2 ) {

        return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

    },

    // Cubic Bezier Functions

    b3p0: function( t, p ) {

        var k = 1 - t;
        return k * k * k * p;

    },

    b3p1: function( t, p ) {

        var k = 1 - t;
        return 3 * k * k * t * p;

    },

    b3p2: function( t, p ) {

        var k = 1 - t;
        return 3 * k * t * t * p;

    },

    b3p3: function( t, p ) {

        return t * t * t * p;

    },

    b3: function( t, p0, p1, p2, p3 ) {

        return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) + this.b3p3( t, p3 );

    }

};

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function( t ) {

    var point = this.v2.clone().sub( this.v1 );
    point.multiplyScalar( t ).add( this.v1 );

    return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function( u ) {

    return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

    var tangent = this.v2.clone().sub( this.v1 );

    return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function( t ) {

    var vector = new THREE.Vector2();

    vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

    return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

    var vector = new THREE.Vector2();

    vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

    // returns unit vector

    return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function( t ) {

    var tx, ty;

    tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

    return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

    var tx, ty;

    tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

    var tangent = new THREE.Vector2( tx, ty );
    tangent.normalize();

    return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function( points /* array of Vector2 */ ) {

    this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var vector = new THREE.Vector2();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

    return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    this.aX = aX;
    this.aY = aY;

    this.xRadius = xRadius;
    this.yRadius = yRadius;

    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;

    this.aClockwise = aClockwise;

    this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function( t ) {

    var deltaAngle = this.aEndAngle - this.aStartAngle;

    if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
    if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

    var angle;

    if ( this.aClockwise === true ) {

        angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

    }
    else {

        angle = this.aStartAngle + t * deltaAngle;

    }

    var x = this.aX + this.xRadius * Math.cos( angle );
    var y = this.aY + this.yRadius * Math.sin( angle );

    if ( this.aRotation !== 0 ) {

        var cos = Math.cos( this.aRotation );
        var sin = Math.sin( this.aRotation );

        var tx = x,
            ty = y;

        // Rotate the point about the center of the ellipse.
        x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
        y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

    }

    return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

    function( v1, v2 ) {

        this.v1 = v1;
        this.v2 = v2;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.subVectors( this.v2, this.v1 ); // diff
        vector.multiplyScalar( t );
        vector.add( this.v1 );

        return vector;

    }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

    function( v0, v1, v2 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
        vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
        vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

        return vector;

    }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

    function( v0, v1, v2, v3 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;

    },

    function( t ) {

        var vector = new THREE.Vector3();

        vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
        vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
        vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

        return vector;

    }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

    function( points /* array of Vector3 */ ) {

        console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
        this.points = ( points == undefined ) ? [] : points;

    },

    function( t ) {

        var points = this.points;
        var point = ( points.length - 1 ) * t;

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
        var point1 = points[ intPoint ];
        var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
        var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

        var vector = new THREE.Vector3();

        vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
        vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
        vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

        return vector;

    }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

    var
        tmp = new THREE.Vector3(),
        px = new CubicPoly(),
        py = new CubicPoly(),
        pz = new CubicPoly();

    /*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

    function CubicPoly() {

    }

    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

        this.c0 = x0;
        this.c1 = t0;
        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    };

    CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

        // compute tangents when parameterized in [t1,t2]
        var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
        var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;

        // initCubicPoly
        this.init( x1, x2, t1, t2 );

    };

    // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

        this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    };

    CubicPoly.prototype.calc = function( t ) {

        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    };

    // Subclass Three.js curve
    return THREE.Curve.create(

        function( p /* array of Vector3 */ ) {

            this.points = p || [];

        },

        function( t ) {

            var points = this.points,
                point, intPoint, weight, l;

            l = points.length;

            if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

            point = ( l - 1 ) * t;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            if ( weight === 0 && intPoint === l - 1 ) {

                intPoint = l - 2;
                weight = 1;

            }

            var p0, p1, p2, p3;

            if ( intPoint === 0 ) {

                // extrapolate first point
                tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
                p0 = tmp;

            }
            else {

                p0 = points[ intPoint - 1 ];

            }

            p1 = points[ intPoint ];
            p2 = points[ intPoint + 1 ];

            if ( intPoint + 2 < l ) {

                p3 = points[ intPoint + 2 ]

            }
            else {

                // extrapolate last point
                tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
                p3 = tmp;

            }

            if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

                // init Centripetal / Chordal Catmull-Rom
                var pow = this.type === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
                var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
                var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

                // safety check for repeated points
                if ( dt1 < 1e-4 ) dt1 = 1.0;
                if ( dt0 < 1e-4 ) dt0 = dt1;
                if ( dt2 < 1e-4 ) dt2 = dt1;

                px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
                py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
                pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

            }
            else if ( this.type === 'catmullrom' ) {

                var tension = this.tension !== undefined ? this.tension : 0.5;
                px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
                py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
                pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

            }

            var v = new THREE.Vector3(
                px.calc( weight ),
                py.calc( weight ),
                pz.calc( weight )
            );

            return v;

        }

    );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

    function( points /* array of Vector3 */ ) {

        this.points = ( points == undefined ) ? [] : points;

    },

    function( t ) {

        var points = this.points;
        var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

        var point0 = points[ ( intPoint - 1 ) % points.length ];
        var point1 = points[ ( intPoint ) % points.length ];
        var point2 = points[ ( intPoint + 1 ) % points.length ];
        var point3 = points[ ( intPoint + 2 ) % points.length ];

        var vector = new THREE.Vector3();

        vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
        vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
        vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

        return vector;

    }

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2,

    //

    add: function() {

        console.warn( 'THREE.AnimationHandler.add() has been deprecated.' );

    },
    get: function() {

        console.warn( 'THREE.AnimationHandler.get() has been deprecated.' );

    },
    remove: function() {

        console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );

    },

    //

    animations: [],

    init: function( data ) {

        if ( data.initialized === true ) return data;

        // loop through all keys

        for ( var h = 0; h < data.hierarchy.length; h++ ) {

            for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                // remove minus times

                if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

                    data.hierarchy[ h ].keys[ k ].time = 0;

                }

                // create quaternions

                if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
                    !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

                    var quat = data.hierarchy[ h ].keys[ k ].rot;
                    data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

                }

            }

            // prepare morph target keys

            if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

                // get all used

                var usedMorphTargets = {};

                for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                    for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m++ ) {

                        var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
                        usedMorphTargets[ morphTargetName ] = -1;

                    }

                }

                data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


                // set all used on all frames

                for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                    var influences = {};

                    for ( var morphTargetName in usedMorphTargets ) {

                        for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m++ ) {

                            if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

                                influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
                                break;

                            }

                        }

                        if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

                            influences[ morphTargetName ] = 0;

                        }

                    }

                    data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

                }

            }


            // remove all keys that are on the same time

            for ( var k = 1; k < data.hierarchy[ h ].keys.length; k++ ) {

                if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

                    data.hierarchy[ h ].keys.splice( k, 1 );
                    k--;

                }

            }


            // set index

            for ( var k = 0; k < data.hierarchy[ h ].keys.length; k++ ) {

                data.hierarchy[ h ].keys[ k ].index = k;

            }

        }

        data.initialized = true;

        return data;

    },

    parse: function( root ) {

        var parseRecurseHierarchy = function( root, hierarchy ) {

            hierarchy.push( root );

            for ( var c = 0; c < root.children.length; c++ )
                parseRecurseHierarchy( root.children[ c ], hierarchy );

        };

        // setup hierarchy

        var hierarchy = [];

        if ( root instanceof THREE.SkinnedMesh ) {

            for ( var b = 0; b < root.skeleton.bones.length; b++ ) {

                hierarchy.push( root.skeleton.bones[ b ] );

            }

        }
        else {

            parseRecurseHierarchy( root, hierarchy );

        }

        return hierarchy;

    },

    play: function( animation ) {

        if ( this.animations.indexOf( animation ) === -1 ) {

            this.animations.push( animation );

        }

    },

    stop: function( animation ) {

        var index = this.animations.indexOf( animation );

        if ( index !== -1 ) {

            this.animations.splice( index, 1 );

        }

    },

    update: function( deltaTimeMS ) {

        for ( var i = 0; i < this.animations.length; i++ ) {

            this.animations[ i ].resetBlendWeights();

        }

        for ( var i = 0; i < this.animations.length; i++ ) {

            this.animations[ i ].update( deltaTimeMS );

        }

    }

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function( root, data ) {

    this.root = root;
    this.data = THREE.AnimationHandler.init( data );
    this.hierarchy = THREE.AnimationHandler.parse( root );

    this.currentTime = 0;
    this.timeScale = 1;

    this.isPlaying = false;
    this.loop = true;
    this.weight = 0;

    this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype = {

    constructor: THREE.Animation,

    keyTypes: [ "pos", "rot", "scl" ],

    play: function( startTime, weight ) {

        this.currentTime = startTime !== undefined ? startTime : 0;
        this.weight = weight !== undefined ? weight : 1;

        this.isPlaying = true;

        this.reset();

        THREE.AnimationHandler.play( this );

    },

    stop: function() {

        this.isPlaying = false;

        THREE.AnimationHandler.stop( this );

    },

    reset: function() {

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];

            if ( object.animationCache === undefined ) {

                object.animationCache = {
                    animations: {},
                    blending: {
                        positionWeight: 0.0,
                        quaternionWeight: 0.0,
                        scaleWeight: 0.0
                    }
                };

            }

            var name = this.data.name;
            var animations = object.animationCache.animations;
            var animationCache = animations[ name ];

            if ( animationCache === undefined ) {

                animationCache = {
                    prevKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    nextKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    originalMatrix: object.matrix
                };

                animations[ name ] = animationCache;

            }

            // Get keys to match our current time

            for ( var t = 0; t < 3; t++ ) {

                var type = this.keyTypes[ t ];

                var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
                var nextKey = this.getNextKeyWith( type, h, 1 );

                while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                    prevKey = nextKey;
                    nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

                }

                animationCache.prevKey[ type ] = prevKey;
                animationCache.nextKey[ type ] = nextKey;

            }

        }

    },

    resetBlendWeights: function() {

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];
            var animationCache = object.animationCache;

            if ( animationCache !== undefined ) {

                var blending = animationCache.blending;

                blending.positionWeight = 0.0;
                blending.quaternionWeight = 0.0;
                blending.scaleWeight = 0.0;

            }

        }

    },

    update: ( function() {

        var points = [];
        var target = new THREE.Vector3();
        var newVector = new THREE.Vector3();
        var newQuat = new THREE.Quaternion();

        // Catmull-Rom spline

        var interpolateCatmullRom = function( points, scale ) {

            var c = [],
                v3 = [],
                point, intPoint, weight, w2, w3,
                pa, pb, pc, pd;

            point = ( points.length - 1 ) * scale;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
            c[ 1 ] = intPoint;
            c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
            c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

            pa = points[ c[ 0 ] ];
            pb = points[ c[ 1 ] ];
            pc = points[ c[ 2 ] ];
            pd = points[ c[ 3 ] ];

            w2 = weight * weight;
            w3 = weight * w2;

            v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
            v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
            v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

            return v3;

        };

        var interpolate = function( p0, p1, p2, p3, t, t2, t3 ) {

            var v0 = ( p2 - p0 ) * 0.5,
                v1 = ( p3 - p1 ) * 0.5;

            return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( -3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

        };

        return function( delta ) {

            if ( this.isPlaying === false ) return;

            this.currentTime += delta * this.timeScale;

            if ( this.weight === 0 )
                return;

            //

            var duration = this.data.length;

            if ( this.currentTime > duration || this.currentTime < 0 ) {

                if ( this.loop ) {

                    this.currentTime %= duration;

                    if ( this.currentTime < 0 )
                        this.currentTime += duration;

                    this.reset();

                }
                else {

                    this.stop();

                }

            }

            for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

                var object = this.hierarchy[ h ];
                var animationCache = object.animationCache.animations[ this.data.name ];
                var blending = object.animationCache.blending;

                // loop through pos/rot/scl

                for ( var t = 0; t < 3; t++ ) {

                    // get keys

                    var type = this.keyTypes[ t ];
                    var prevKey = animationCache.prevKey[ type ];
                    var nextKey = animationCache.nextKey[ type ];

                    if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
                        ( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

                        prevKey = this.data.hierarchy[ h ].keys[ 0 ];
                        nextKey = this.getNextKeyWith( type, h, 1 );

                        while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                            prevKey = nextKey;
                            nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

                        }

                        animationCache.prevKey[ type ] = prevKey;
                        animationCache.nextKey[ type ] = nextKey;

                    }

                    var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

                    var prevXYZ = prevKey[ type ];
                    var nextXYZ = nextKey[ type ];

                    if ( scale < 0 ) scale = 0;
                    if ( scale > 1 ) scale = 1;

                    // interpolate

                    if ( type === "pos" ) {

                        if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

                            newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
                            newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
                            newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

                            // blend
                            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
                            object.position.lerp( newVector, proportionalWeight );
                            blending.positionWeight += this.weight;

                        }
                        else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
                            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                            points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
                            points[ 1 ] = prevXYZ;
                            points[ 2 ] = nextXYZ;
                            points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

                            scale = scale * 0.33 + 0.33;

                            var currentPoint = interpolateCatmullRom( points, scale );
                            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
                            blending.positionWeight += this.weight;

                            // blend

                            var vector = object.position;

                            vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
                            vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
                            vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

                            if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                                var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

                                target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
                                target.sub( vector );
                                target.y = 0;
                                target.normalize();

                                var angle = Math.atan2( target.x, target.z );
                                object.rotation.set( 0, angle, 0 );

                            }

                        }

                    }
                    else if ( type === "rot" ) {

                        THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

                        // Avoid paying the cost of an additional slerp if we don't have to
                        if ( blending.quaternionWeight === 0 ) {

                            object.quaternion.copy( newQuat );
                            blending.quaternionWeight = this.weight;

                        }
                        else {

                            var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
                            THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
                            blending.quaternionWeight += this.weight;

                        }

                    }
                    else if ( type === "scl" ) {

                        newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
                        newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
                        newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

                        var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
                        object.scale.lerp( newVector, proportionalWeight );
                        blending.scaleWeight += this.weight;

                    }

                }

            }

            return true;

        };

    } )(),

    getNextKeyWith: function( type, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;

        if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

            key = key < keys.length - 1 ? key : keys.length - 1;

        }
        else {

            key = key % keys.length;

        }

        for ( ; key < keys.length; key++ ) {

            if ( keys[ key ][ type ] !== undefined ) {

                return keys[ key ];

            }

        }

        return this.data.hierarchy[ h ].keys[ 0 ];

    },

    getPrevKeyWith: function( type, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;

        if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
            this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

            key = key > 0 ? key : 0;

        }
        else {

            key = key >= 0 ? key : key + keys.length;

        }


        for ( ; key >= 0; key-- ) {

            if ( keys[ key ][ type ] !== undefined ) {

                return keys[ key ];

            }

        }

        return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

    }

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function( data ) {

    this.root = data.node;
    this.data = THREE.AnimationHandler.init( data );
    this.hierarchy = THREE.AnimationHandler.parse( this.root );
    this.currentTime = 0;
    this.timeScale = 0.001;
    this.isPlaying = false;
    this.isPaused = true;
    this.loop = true;

    // initialize to first keyframes

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

        var keys = this.data.hierarchy[ h ].keys,
            sids = this.data.hierarchy[ h ].sids,
            obj = this.hierarchy[ h ];

        if ( keys.length && sids ) {

            for ( var s = 0; s < sids.length; s++ ) {

                var sid = sids[ s ],
                    next = this.getNextKeyWith( sid, h, 0 );

                if ( next ) {

                    next.apply( sid );

                }

            }

            obj.matrixAutoUpdate = false;
            this.data.hierarchy[ h ].node.updateMatrix();
            obj.matrixWorldNeedsUpdate = true;

        }

    }

};

THREE.KeyFrameAnimation.prototype = {

    constructor: THREE.KeyFrameAnimation,

    play: function( startTime ) {

        this.currentTime = startTime !== undefined ? startTime : 0;

        if ( this.isPlaying === false ) {

            this.isPlaying = true;

            // reset key cache

            var h, hl = this.hierarchy.length,
                object,
                node;

            for ( h = 0; h < hl; h++ ) {

                object = this.hierarchy[ h ];
                node = this.data.hierarchy[ h ];

                if ( node.animationCache === undefined ) {

                    node.animationCache = {};
                    node.animationCache.prevKey = null;
                    node.animationCache.nextKey = null;
                    node.animationCache.originalMatrix = object.matrix;

                }

                var keys = this.data.hierarchy[ h ].keys;

                if ( keys.length ) {

                    node.animationCache.prevKey = keys[ 0 ];
                    node.animationCache.nextKey = keys[ 1 ];

                    this.startTime = Math.min( keys[ 0 ].time, this.startTime );
                    this.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );

                }

            }

            this.update( 0 );

        }

        this.isPaused = false;

        THREE.AnimationHandler.play( this );

    },

    stop: function() {

        this.isPlaying = false;
        this.isPaused = false;

        THREE.AnimationHandler.stop( this );

        // reset JIT matrix and remove cache

        for ( var h = 0; h < this.data.hierarchy.length; h++ ) {

            var obj = this.hierarchy[ h ];
            var node = this.data.hierarchy[ h ];

            if ( node.animationCache !== undefined ) {

                var original = node.animationCache.originalMatrix;

                original.copy( obj.matrix );
                obj.matrix = original;

                delete node.animationCache;

            }

        }

    },

    update: function( delta ) {

        if ( this.isPlaying === false ) return;

        this.currentTime += delta * this.timeScale;

        //

        var duration = this.data.length;

        if ( this.loop === true && this.currentTime > duration ) {

            this.currentTime %= duration;

        }

        this.currentTime = Math.min( this.currentTime, duration );

        for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

            var object = this.hierarchy[ h ];
            var node = this.data.hierarchy[ h ];

            var keys = node.keys,
                animationCache = node.animationCache;


            if ( keys.length ) {

                var prevKey = animationCache.prevKey;
                var nextKey = animationCache.nextKey;

                if ( nextKey.time <= this.currentTime ) {

                    while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

                        prevKey = nextKey;
                        nextKey = keys[ prevKey.index + 1 ];

                    }

                    animationCache.prevKey = prevKey;
                    animationCache.nextKey = nextKey;

                }

                if ( nextKey.time >= this.currentTime ) {

                    prevKey.interpolate( nextKey, this.currentTime );

                }
                else {

                    prevKey.interpolate( nextKey, nextKey.time );

                }

                this.data.hierarchy[ h ].node.updateMatrix();
                object.matrixWorldNeedsUpdate = true;

            }

        }

    },

    getNextKeyWith: function( sid, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;
        key = key % keys.length;

        for ( ; key < keys.length; key++ ) {

            if ( keys[ key ].hasTarget( sid ) ) {

                return keys[ key ];

            }

        }

        return keys[ 0 ];

    },

    getPrevKeyWith: function( sid, h, key ) {

        var keys = this.data.hierarchy[ h ].keys;
        key = key >= 0 ? key : key + keys.length;

        for ( ; key >= 0; key-- ) {

            if ( keys[ key ].hasTarget( sid ) ) {

                return keys[ key ];

            }

        }

        return keys[ keys.length - 1 ];

    }

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author willy-vvu / http://willy-vvu.github.io
 */

THREE.MorphAnimation = function( mesh ) {

    this.mesh = mesh;
    this.frames = mesh.morphTargetInfluences.length;
    this.currentTime = 0;
    this.duration = 1000;
    this.loop = true;
    this.lastFrame = 0;
    this.currentFrame = 0;

    this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

    constructor: THREE.MorphAnimation,

    play: function() {

        this.isPlaying = true;

    },

    pause: function() {

        this.isPlaying = false;

    },

    update: function( delta ) {

        if ( this.isPlaying === false ) return;

        this.currentTime += delta;

        if ( this.loop === true && this.currentTime > this.duration ) {

            this.currentTime %= this.duration;

        }

        this.currentTime = Math.min( this.currentTime, this.duration );

        var frameTime = this.duration / this.frames;
        var frame = Math.floor( this.currentTime / frameTime );

        var influences = this.mesh.morphTargetInfluences;

        if ( frame !== this.currentFrame ) {

            influences[ this.lastFrame ] = 0;
            influences[ this.currentFrame ] = 1;
            influences[ frame ] = 0;

            this.lastFrame = this.currentFrame;
            this.currentFrame = frame;

        }

        var mix = ( this.currentTime % frameTime ) / frameTime;

        influences[ frame ] = mix;
        influences[ this.lastFrame ] = 1 - mix;

    }

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    THREE.Geometry.call( this );

    this.type = 'BoxGeometry';

    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };

    this.widthSegments = widthSegments || 1;
    this.heightSegments = heightSegments || 1;
    this.depthSegments = depthSegments || 1;

    var scope = this;

    var width_half = width / 2;
    var height_half = height / 2;
    var depth_half = depth / 2;

    buildPlane( 'z', 'y', -1, -1, depth, height, width_half, 0 ); // px
    buildPlane( 'z', 'y', 1, -1, depth, height, -width_half, 1 ); // nx
    buildPlane( 'x', 'z', 1, 1, width, depth, height_half, 2 ); // py
    buildPlane( 'x', 'z', 1, -1, width, depth, -height_half, 3 ); // ny
    buildPlane( 'x', 'y', 1, -1, width, height, depth_half, 4 ); // pz
    buildPlane( 'x', 'y', -1, -1, width, height, -depth_half, 5 ); // nz

    function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

        var w, ix, iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;

        if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

            w = 'z';

        }
        else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

            w = 'y';
            gridY = scope.depthSegments;

        }
        else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

            w = 'x';
            gridX = scope.depthSegments;

        }

        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();

        normal[ w ] = depth > 0 ? 1 : -1;

        for ( iy = 0; iy < gridY1; iy++ ) {

            for ( ix = 0; ix < gridX1; ix++ ) {

                var vector = new THREE.Vector3();
                vector[ u ] = ( ix * segment_width - width_half ) * udir;
                vector[ v ] = ( iy * segment_height - height_half ) * vdir;
                vector[ w ] = depth;

                scope.vertices.push( vector );

            }

        }

        for ( iy = 0; iy < gridY; iy++ ) {

            for ( ix = 0; ix < gridX; ix++ ) {

                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * ( iy + 1 );
                var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
                var d = ( ix + 1 ) + gridX1 * iy;

                var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
                var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
                var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
                var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

                var face = new THREE.Face3( a + offset, b + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

                face = new THREE.Face3( b + offset, c + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

            }

        }

    }

    this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function() {

    var geometry = new THREE.BoxGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.depth,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.depthSegments
    );

    return geometry;

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function( radius, segments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CircleGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var i, uvs = [],
        center = new THREE.Vector3(),
        centerUV = new THREE.Vector2( 0.5, 0.5 );

    this.vertices.push( center );
    uvs.push( centerUV );

    for ( i = 0; i <= segments; i++ ) {

        var vertex = new THREE.Vector3();
        var segment = thetaStart + i / segments * thetaLength;

        vertex.x = radius * Math.cos( segment );
        vertex.y = radius * Math.sin( segment );

        this.vertices.push( vertex );
        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 1; i <= segments; i++ ) {

        this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
        this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function() {

    var geometry = new THREE.CircleGeometry(
        this.parameters.radius,
        this.parameters.segments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function( radius, segments, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'CircleBufferGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var vertices = segments + 2;

    var positions = new Float32Array( vertices * 3 );
    var normals = new Float32Array( vertices * 3 );
    var uvs = new Float32Array( vertices * 2 );

    // center data is already zero, but need to set a few extras
    normals[ 3 ] = 1.0;
    uvs[ 0 ] = 0.5;
    uvs[ 1 ] = 0.5;

    for ( var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2 ) {

        var segment = thetaStart + s / segments * thetaLength;

        positions[ i ] = radius * Math.cos( segment );
        positions[ i + 1 ] = radius * Math.sin( segment );

        normals[ i + 2 ] = 1; // normal z

        uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
        uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    }

    var indices = [];

    for ( var i = 1; i <= segments; i++ ) {

        indices.push( i );
        indices.push( i + 1 );
        indices.push( 0 );

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.CircleBufferGeometry(
        this.parameters.radius,
        this.parameters.segments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CylinderGeometry';

    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;

    radialSegments = radialSegments || 8;
    heightSegments = heightSegments || 1;

    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

    var heightHalf = height / 2;

    var x, y, vertices = [],
        uvs = [];

    for ( y = 0; y <= heightSegments; y++ ) {

        var verticesRow = [];
        var uvsRow = [];

        var v = y / heightSegments;
        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

        for ( x = 0; x <= radialSegments; x++ ) {

            var u = x / radialSegments;

            var vertex = new THREE.Vector3();
            vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
            vertex.y = -v * height + heightHalf;
            vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

            this.vertices.push( vertex );

            verticesRow.push( this.vertices.length - 1 );
            uvsRow.push( new THREE.Vector2( u, 1 - v ) );

        }

        vertices.push( verticesRow );
        uvs.push( uvsRow );

    }

    var tanTheta = ( radiusBottom - radiusTop ) / height;
    var na, nb;

    for ( x = 0; x < radialSegments; x++ ) {

        if ( radiusTop !== 0 ) {

            na = this.vertices[ vertices[ 0 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

        }
        else {

            na = this.vertices[ vertices[ 1 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

        }

        na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
        nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

        for ( y = 0; y < heightSegments; y++ ) {

            var v1 = vertices[ y ][ x ];
            var v2 = vertices[ y + 1 ][ x ];
            var v3 = vertices[ y + 1 ][ x + 1 ];
            var v4 = vertices[ y ][ x + 1 ];

            var n1 = na.clone();
            var n2 = na.clone();
            var n3 = nb.clone();
            var n4 = nb.clone();

            var uv1 = uvs[ y ][ x ].clone();
            var uv2 = uvs[ y + 1 ][ x ].clone();
            var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
            var uv4 = uvs[ y ][ x + 1 ].clone();

            this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

            this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

        }

    }

    // top cap

    if ( openEnded === false && radiusTop > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x++ ) {

            var v1 = vertices[ 0 ][ x ];
            var v2 = vertices[ 0 ][ x + 1 ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, 1, 0 );
            var n2 = new THREE.Vector3( 0, 1, 0 );
            var n3 = new THREE.Vector3( 0, 1, 0 );

            var uv1 = uvs[ 0 ][ x ].clone();
            var uv2 = uvs[ 0 ][ x + 1 ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 0 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    // bottom cap

    if ( openEnded === false && radiusBottom > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, -heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x++ ) {

            var v1 = vertices[ heightSegments ][ x + 1 ];
            var v2 = vertices[ heightSegments ][ x ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, -1, 0 );
            var n2 = new THREE.Vector3( 0, -1, 0 );
            var n3 = new THREE.Vector3( 0, -1, 0 );

            var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
            var uv2 = uvs[ heightSegments ][ x ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 1 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function() {

    var geometry = new THREE.CylinderGeometry(
        this.parameters.radiusTop,
        this.parameters.radiusBottom,
        this.parameters.height,
        this.parameters.radialSegments,
        this.parameters.heightSegments,
        this.parameters.openEnded,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function( geometry, thresholdAngle ) {

    THREE.BufferGeometry.call( this );

    thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

    var edge = [ 0, 0 ],
        hash = {};
    var sortFunction = function( a, b ) {

        return a - b;

    };

    var keys = [ 'a', 'b', 'c' ];

    var geometry2;

    if ( geometry instanceof THREE.BufferGeometry ) {

        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry( geometry );

    }
    else {

        geometry2 = geometry.clone();

    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();

    var vertices = geometry2.vertices;
    var faces = geometry2.faces;

    for ( var i = 0, l = faces.length; i < l; i++ ) {

        var face = faces[ i ];

        for ( var j = 0; j < 3; j++ ) {

            edge[ 0 ] = face[ keys[ j ] ];
            edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

                hash[ key ] = {
                    vert1: edge[ 0 ],
                    vert2: edge[ 1 ],
                    face1: i,
                    face2: undefined
                };

            }
            else {

                hash[ key ].face2 = i;

            }

        }

    }

    var coords = [];

    for ( var key in hash ) {

        var h = hash[ key ];

        if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

            var vertex = vertices[ h.vert1 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

            vertex = vertices[ h.vert2 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

        }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function( shapes, options ) {

    if ( typeof( shapes ) === "undefined" ) {

        shapes = [];
        return;

    }

    THREE.Geometry.call( this );

    this.type = 'ExtrudeGeometry';

    shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

    // can't really use automatic vertex normals
    // as then front and back sides get smoothed too
    // should do separate smoothing just for sides

    //this.computeVertexNormals();

    //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function( shapes, options ) {

    var sl = shapes.length;

    for ( var s = 0; s < sl; s++ ) {

        var shape = shapes[ s ];
        this.addShape( shape, options );

    }

};

THREE.ExtrudeGeometry.prototype.addShape = function( shape, options ) {

    var amount = options.amount !== undefined ? options.amount : 100;

    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var steps = options.steps !== undefined ? options.steps : 1;

    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;

    // Use default WorldUVGenerator if no UV generators are specified.
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

    var splineTube, binormal, normal, position2;
    if ( extrudePath ) {

        extrudePts = extrudePath.getSpacedPoints( steps );

        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion

        // SETUP TNB variables

        // Reuse TNB from TubeGeomtry for now.
        // TODO1 - have a .isClosed in spline?

        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();

    }

    // Safeguards if bevels are not enabled

    if ( !bevelEnabled ) {

        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;

    }

    // Variables initialization

    var ahole, h, hl; // looping of holes
    var scope = this;

    var shapesOffset = this.vertices.length;

    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = !THREE.Shape.Utils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];

            if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

                holes[ h ] = ahole.reverse();

            }

        }

        reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    }


    var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for ( h = 0, hl = holes.length; h < hl; h++ ) {

        ahole = holes[ h ];

        vertices = vertices.concat( ahole );

    }


    function scalePt2( pt, vec, size ) {

        if ( !vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

        return vec.clone().multiplyScalar( size ).add( pt );

    }

    var b, bs, t, z,
        vert, vlen = vertices.length,
        face, flen = faces.length;


    // Find directions for point movement


    function getBevelVec( inPt, inPrev, inNext ) {

        var EPSILON = 0.0000000001;

        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.

        var v_trans_x, v_trans_y, shrink_by = 1; // resulting translation vector for inPt

        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;

        var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

        // check for collinear edges
        var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

        if ( Math.abs( collinear0 ) > EPSILON ) {

            // not collinear

            // length of vectors for normalizing

            var v_prev_len = Math.sqrt( v_prev_lensq );
            var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

            // shift adjacent points by unit vectors to the left

            var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
            var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

            var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
            var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

            // scaling factor for v_prev to intersection point

            var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
                    ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
                ( v_prev_x * v_next_y - v_prev_y * v_next_x );

            // vector from inPt to intersection point

            v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
            v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

            // Don't normalize!, otherwise sharp corners become ugly
            //  but prevent crazy spikes
            var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
            if ( v_trans_lensq <= 2 ) {

                return new THREE.Vector2( v_trans_x, v_trans_y );

            }
            else {

                shrink_by = Math.sqrt( v_trans_lensq / 2 );

            }

        }
        else {

            // handle special case of collinear edges

            var direction_eq = false; // assumes: opposite
            if ( v_prev_x > EPSILON ) {

                if ( v_next_x > EPSILON ) {

                    direction_eq = true;

                }

            }
            else {

                if ( v_prev_x < -EPSILON ) {

                    if ( v_next_x < -EPSILON ) {

                        direction_eq = true;

                    }

                }
                else {

                    if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

                        direction_eq = true;

                    }

                }

            }

            if ( direction_eq ) {

                // console.log("Warning: lines are a straight sequence");
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt( v_prev_lensq );

            }
            else {

                // console.log("Warning: lines are a straight spike");
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt( v_prev_lensq / 2 );

            }

        }

        return new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    }


    var contourMovements = [];

    for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++ ) {

        if ( j === il ) j = 0;
        if ( k === il ) k = 0;

        //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    }

    var holesMovements = [],
        oneHoleMovements, verticesMovements = contourMovements.concat();

    for ( h = 0, hl = holes.length; h < hl; h++ ) {

        ahole = holes[ h ];

        oneHoleMovements = [];

        for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++ ) {

            if ( j === il ) j = 0;
            if ( k === il ) k = 0;

            //  (j)---(i)---(k)
            oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

        }

        holesMovements.push( oneHoleMovements );
        verticesMovements = verticesMovements.concat( oneHoleMovements );

    }


    // Loop bevelSegments, 1 for the front, 1 for the back

    for ( b = 0; b < bevelSegments; b++ ) {

        //for ( b = bevelSegments; b > 0; b -- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );

        //z = bevelThickness * t;
        bs = bevelSize * ( Math.sin( t * Math.PI / 2 ) ); // curved
        //bs = bevelSize * t; // linear

        // contract shape

        for ( i = 0, il = contour.length; i < il; i++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

            v( vert.x, vert.y, -z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                v( vert.x, vert.y, -z );

            }

        }

    }

    bs = bevelSize;

    // Back facing vertices

    for ( i = 0; i < vlen; i++ ) {

        vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

        if ( !extrudeByPath ) {

            v( vert.x, vert.y, 0 );

        }
        else {

            // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

            normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
            binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

            position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

            v( position2.x, position2.y, position2.z );

        }

    }

    // Add stepped vertices...
    // Including front facing vertices

    var s;

    for ( s = 1; s <= steps; s++ ) {

        for ( i = 0; i < vlen; i++ ) {

            vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

            if ( !extrudeByPath ) {

                v( vert.x, vert.y, amount / steps * s );

            }
            else {

                // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
                binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

                position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

                v( position2.x, position2.y, position2.z );

            }

        }

    }


    // Add bevel segments planes

    //for ( b = 1; b <= bevelSegments; b ++ ) {
    for ( b = bevelSegments - 1; b >= 0; b-- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );
        //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
        bs = bevelSize * Math.sin( t * Math.PI / 2 );

        // contract shape

        for ( i = 0, il = contour.length; i < il; i++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
            v( vert.x, vert.y, amount + z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                if ( !extrudeByPath ) {

                    v( vert.x, vert.y, amount + z );

                }
                else {

                    v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

                }

            }

        }

    }

    /* Faces */

    // Top and bottom faces

    buildLidFaces();

    // Sides faces

    buildSideFaces();


    /////  Internal functions

    function buildLidFaces() {

        if ( bevelEnabled ) {

            var layer = 0; // steps + 1
            var offset = vlen * layer;

            // Bottom faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

            }

            layer = steps + bevelSegments * 2;
            offset = vlen * layer;

            // Top faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

            }

        }
        else {

            // Bottom faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 2 ], face[ 1 ], face[ 0 ] );

            }

            // Top faces

            for ( i = 0; i < flen; i++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

            }

        }

    }

    // Create faces for the z-sides of the shape

    function buildSideFaces() {

        var layeroffset = 0;
        sidewalls( contour, layeroffset );
        layeroffset += contour.length;

        for ( h = 0, hl = holes.length; h < hl; h++ ) {

            ahole = holes[ h ];
            sidewalls( ahole, layeroffset );

            //, true
            layeroffset += ahole.length;

        }

    }

    function sidewalls( contour, layeroffset ) {

        var j, k;
        i = contour.length;

        while ( --i >= 0 ) {

            j = i;
            k = i - 1;
            if ( k < 0 ) k = contour.length - 1;

            //console.log('b', i,j, i-1, k,vertices.length);

            var s = 0,
                sl = steps + bevelSegments * 2;

            for ( s = 0; s < sl; s++ ) {

                var slen1 = vlen * s;
                var slen2 = vlen * ( s + 1 );

                var a = layeroffset + j + slen1,
                    b = layeroffset + k + slen1,
                    c = layeroffset + k + slen2,
                    d = layeroffset + j + slen2;

                f4( a, b, c, d, contour, s, sl, j, k );

            }

        }

    }


    function v( x, y, z ) {

        scope.vertices.push( new THREE.Vector3( x, y, z ) );

    }

    function f3( a, b, c ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, c ) );

        var uvs = uvgen.generateTopUV( scope, a, b, c );

        scope.faceVertexUvs[ 0 ].push( uvs );

    }

    function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, d ) );
        scope.faces.push( new THREE.Face3( b, c, d ) );

        var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

        scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
        scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

    generateTopUV: function( geometry, indexA, indexB, indexC ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];

        return [
            new THREE.Vector2( a.x, a.y ),
            new THREE.Vector2( b.x, b.y ),
            new THREE.Vector2( c.x, c.y )
        ];

    },

    generateSideWallUV: function( geometry, indexA, indexB, indexC, indexD ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];
        var d = vertices[ indexD ];

        if ( Math.abs( a.y - b.y ) < 0.01 ) {

            return [
                new THREE.Vector2( a.x, 1 - a.z ),
                new THREE.Vector2( b.x, 1 - b.z ),
                new THREE.Vector2( c.x, 1 - c.z ),
                new THREE.Vector2( d.x, 1 - d.z )
            ];

        }
        else {

            return [
                new THREE.Vector2( a.y, 1 - a.z ),
                new THREE.Vector2( b.y, 1 - b.z ),
                new THREE.Vector2( c.y, 1 - c.z ),
                new THREE.Vector2( d.y, 1 - d.z )
            ];

        }

    }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function( shapes, options ) {

    THREE.Geometry.call( this );

    this.type = 'ShapeGeometry';

    if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function( shapes, options ) {

    for ( var i = 0, l = shapes.length; i < l; i++ ) {

        this.addShape( shapes[ i ], options );

    }

    return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function( shape, options ) {

    if ( options === undefined ) options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    //

    var i, l, hole;

    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = !THREE.Shape.Utils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe...

        for ( i = 0, l = holes.length; i < l; i++ ) {

            hole = holes[ i ];

            if ( THREE.Shape.Utils.isClockWise( hole ) ) {

                holes[ i ] = hole.reverse();

            }

        }

        reverse = false;

    }

    var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

    // Vertices

    for ( i = 0, l = holes.length; i < l; i++ ) {

        hole = holes[ i ];
        vertices = vertices.concat( hole );

    }

    //

    var vert, vlen = vertices.length;
    var face, flen = faces.length;

    for ( i = 0; i < vlen; i++ ) {

        vert = vertices[ i ];

        this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

    }

    for ( i = 0; i < flen; i++ ) {

        face = faces[ i ];

        var a = face[ 0 ] + shapesOffset;
        var b = face[ 1 ] + shapesOffset;
        var c = face[ 2 ] + shapesOffset;

        this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
        this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function( points, segments, phiStart, phiLength ) {

    THREE.Geometry.call( this );

    this.type = 'LatheGeometry';

    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };

    segments = segments || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || 2 * Math.PI;

    var inversePointLength = 1.0 / ( points.length - 1 );
    var inverseSegments = 1.0 / segments;

    for ( var i = 0, il = segments; i <= il; i++ ) {

        var phi = phiStart + i * inverseSegments * phiLength;

        var c = Math.cos( phi ),
            s = Math.sin( phi );

        for ( var j = 0, jl = points.length; j < jl; j++ ) {

            var pt = points[ j ];

            var vertex = new THREE.Vector3();

            vertex.x = c * pt.x - s * pt.y;
            vertex.y = s * pt.x + c * pt.y;
            vertex.z = pt.z;

            this.vertices.push( vertex );

        }

    }

    var np = points.length;

    for ( var i = 0, il = segments; i < il; i++ ) {

        for ( var j = 0, jl = points.length - 1; j < jl; j++ ) {

            var base = j + np * i;
            var a = base;
            var b = base + np;
            var c = base + 1 + np;
            var d = base + 1;

            var u0 = i * inverseSegments;
            var v0 = j * inversePointLength;
            var u1 = u0 + inverseSegments;
            var v1 = v0 + inversePointLength;

            this.faces.push( new THREE.Face3( a, b, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u0, v0 ),
                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u0, v1 )

            ] );

            this.faces.push( new THREE.Face3( b, c, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u1, v1 ),
                new THREE.Vector2( u0, v1 )

            ] );


        }

    }

    this.mergeVertices();
    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function( width, height, widthSegments, heightSegments ) {

    THREE.Geometry.call( this );

    this.type = 'PlaneGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function() {

    var geometry = new THREE.PlaneGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.widthSegments,
        this.parameters.heightSegments
    );

    return geometry;

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function( width, height, widthSegments, heightSegments ) {

    THREE.BufferGeometry.call( this );

    this.type = 'PlaneBufferGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    var width_half = width / 2;
    var height_half = height / 2;

    var gridX = Math.floor( widthSegments ) || 1;
    var gridY = Math.floor( heightSegments ) || 1;

    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;

    var segment_width = width / gridX;
    var segment_height = height / gridY;

    var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    var normals = new Float32Array( gridX1 * gridY1 * 3 );
    var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    var offset = 0;
    var offset2 = 0;

    for ( var iy = 0; iy < gridY1; iy++ ) {

        var y = iy * segment_height - height_half;

        for ( var ix = 0; ix < gridX1; ix++ ) {

            var x = ix * segment_width - width_half;

            vertices[ offset ] = x;
            vertices[ offset + 1 ] = -y;

            normals[ offset + 2 ] = 1;

            uvs[ offset2 ] = ix / gridX;
            uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

            offset += 3;
            offset2 += 2;

        }

    }

    offset = 0;

    var indices = new( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    for ( var iy = 0; iy < gridY; iy++ ) {

        for ( var ix = 0; ix < gridX; ix++ ) {

            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * ( iy + 1 );
            var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
            var d = ( ix + 1 ) + gridX1 * iy;

            indices[ offset ] = a;
            indices[ offset + 1 ] = b;
            indices[ offset + 2 ] = d;

            indices[ offset + 3 ] = b;
            indices[ offset + 4 ] = c;
            indices[ offset + 5 ] = d;

            offset += 6;

        }

    }

    this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.PlaneBufferGeometry(
        this.parameters.width,
        this.parameters.height,
        this.parameters.widthSegments,
        this.parameters.heightSegments
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'RingGeometry';

    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    innerRadius = innerRadius || 0;
    outerRadius = outerRadius || 50;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

    var i, o, uvs = [],
        radius = innerRadius,
        radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

    for ( i = 0; i < phiSegments + 1; i++ ) {

        // concentric circles inside ring

        for ( o = 0; o < thetaSegments + 1; o++ ) {

            // number of segments per circle

            var vertex = new THREE.Vector3();
            var segment = thetaStart + o / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos( segment );
            vertex.y = radius * Math.sin( segment );

            this.vertices.push( vertex );
            uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

        }

        radius += radiusStep;

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 0; i < phiSegments; i++ ) {

        // concentric circles inside ring

        var thetaSegment = i * ( thetaSegments + 1 );

        for ( o = 0; o < thetaSegments; o++ ) {

            // number of segments per circle

            var segment = o + thetaSegment;

            var v1 = segment;
            var v2 = segment + thetaSegments + 1;
            var v3 = segment + thetaSegments + 2;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

            v1 = segment;
            v2 = segment + thetaSegments + 2;
            v3 = segment + 1;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

        }

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function() {

    var geometry = new THREE.RingGeometry(
        this.parameters.innerRadius,
        this.parameters.outerRadius,
        this.parameters.thetaSegments,
        this.parameters.phiSegments,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'SphereGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function() {

    var geometry = new THREE.SphereGeometry(
        this.parameters.radius,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.phiStart,
        this.parameters.phiLength,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    return geometry;

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'SphereBufferGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;

    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    var thetaEnd = thetaStart + thetaLength;

    var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    var index = 0,
        vertices = [],
        normal = new THREE.Vector3();

    for ( var y = 0; y <= heightSegments; y++ ) {

        var verticesRow = [];

        var v = y / heightSegments;

        for ( var x = 0; x <= widthSegments; x++ ) {

            var u = x / widthSegments;

            var px = -radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
            var py = radius * Math.cos( thetaStart + v * thetaLength );
            var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

            normal.set( px, py, pz ).normalize();

            positions.setXYZ( index, px, py, pz );
            normals.setXYZ( index, normal.x, normal.y, normal.z );
            uvs.setXY( index, u, 1 - v );

            verticesRow.push( index );

            index++;

        }

        vertices.push( verticesRow );

    }

    var indices = [];

    for ( var y = 0; y < heightSegments; y++ ) {

        for ( var x = 0; x < widthSegments; x++ ) {

            var v1 = vertices[ y ][ x + 1 ];
            var v2 = vertices[ y ][ x ];
            var v3 = vertices[ y + 1 ][ x ];
            var v4 = vertices[ y + 1 ][ x + 1 ];

            if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
            if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

        }

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', positions );
    this.addAttribute( 'normal', normals );
    this.addAttribute( 'uv', uvs );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function() {

    var geometry = new THREE.SphereBufferGeometry(
        this.parameters.radius,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.phiStart,
        this.parameters.phiLength,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function( text, parameters ) {

    parameters = parameters || {};

    var textShapes = THREE.FontUtils.generateShapes( text, parameters );

    // translate parameters to ExtrudeGeometry API

    parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    // defaults

    if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    THREE.ExtrudeGeometry.call( this, textShapes, parameters );

    this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function( radius, tube, radialSegments, tubularSegments, arc ) {

    THREE.Geometry.call( this );

    this.type = 'TorusGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var center = new THREE.Vector3(),
        uvs = [],
        normals = [];

    for ( var j = 0; j <= radialSegments; j++ ) {

        for ( var i = 0; i <= tubularSegments; i++ ) {

            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            center.x = radius * Math.cos( u );
            center.y = radius * Math.sin( u );

            var vertex = new THREE.Vector3();
            vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            vertex.z = tube * Math.sin( v );

            this.vertices.push( vertex );

            uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
            normals.push( vertex.clone().sub( center ).normalize() );

        }

    }

    for ( var j = 1; j <= radialSegments; j++ ) {

        for ( var i = 1; i <= tubularSegments; i++ ) {

            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

            face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

        }

    }

    this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function() {

    var geometry = new THREE.TorusGeometry(
        this.parameters.radius,
        this.parameters.tube,
        this.parameters.radialSegments,
        this.parameters.tubularSegments,
        this.parameters.arc
    );

    return geometry;

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

    THREE.Geometry.call( this );

    this.type = 'TorusKnotGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 64;
    tubularSegments = tubularSegments || 8;
    p = p || 2;
    q = q || 3;
    heightScale = heightScale || 1;

    var grid = new Array( radialSegments );
    var tang = new THREE.Vector3();
    var n = new THREE.Vector3();
    var bitan = new THREE.Vector3();

    for ( var i = 0; i < radialSegments; ++i ) {

        grid[ i ] = new Array( tubularSegments );
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos( u, q, p, radius, heightScale );
        var p2 = getPos( u + 0.01, q, p, radius, heightScale );
        tang.subVectors( p2, p1 );
        n.addVectors( p2, p1 );

        bitan.crossVectors( tang, n );
        n.crossVectors( bitan, tang );
        bitan.normalize();
        n.normalize();

        for ( var j = 0; j < tubularSegments; ++j ) {

            var v = j / tubularSegments * 2 * Math.PI;
            var cx = -tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            var cy = tube * Math.sin( v );

            var pos = new THREE.Vector3();
            pos.x = p1.x + cx * n.x + cy * bitan.x;
            pos.y = p1.y + cx * n.y + cy * bitan.y;
            pos.z = p1.z + cx * n.z + cy * bitan.z;

            grid[ i ][ j ] = this.vertices.push( pos ) - 1;

        }

    }

    for ( var i = 0; i < radialSegments; ++i ) {

        for ( var j = 0; j < tubularSegments; ++j ) {

            var ip = ( i + 1 ) % radialSegments;
            var jp = ( j + 1 ) % tubularSegments;

            var a = grid[ i ][ j ];
            var b = grid[ ip ][ j ];
            var c = grid[ ip ][ jp ];
            var d = grid[ i ][ jp ];

            var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
            var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
            var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
            var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

    function getPos( u, in_q, in_p, radius, heightScale ) {

        var cu = Math.cos( u );
        var su = Math.sin( u );
        var quOverP = in_q / in_p * u;
        var cs = Math.cos( quOverP );

        var tx = radius * ( 2 + cs ) * 0.5 * cu;
        var ty = radius * ( 2 + cs ) * su * 0.5;
        var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

        return new THREE.Vector3( tx, ty, tz );

    }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function() {

    var geometry = new THREE.TorusKnotGeometry(
        this.parameters.radius,
        this.parameters.tube,
        this.parameters.radialSegments,
        this.parameters.tubularSegments,
        this.parameters.p,
        this.parameters.q,
        this.parameters.heightScale
    );

    return geometry;

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed, taper ) {

    THREE.Geometry.call( this );

    this.type = 'TubeGeometry';

    this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };

    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || THREE.TubeGeometry.NoTaper;

    var grid = [];

    var scope = this,

        tangent,
        normal,
        binormal,

        numpoints = segments + 1,

        u, v, r,

        cx, cy,
        pos, pos2 = new THREE.Vector3(),
        i, j,
        ip, jp,
        a, b, c, d,
        uva, uvb, uvc, uvd;

    var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
        tangents = frames.tangents,
        normals = frames.normals,
        binormals = frames.binormals;

    // proxy internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    function vert( x, y, z ) {

        return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

    }

    // construct the grid

    for ( i = 0; i < numpoints; i++ ) {

        grid[ i ] = [];

        u = i / ( numpoints - 1 );

        pos = path.getPointAt( u );

        tangent = tangents[ i ];
        normal = normals[ i ];
        binormal = binormals[ i ];

        r = radius * taper( u );

        for ( j = 0; j < radialSegments; j++ ) {

            v = j / radialSegments * 2 * Math.PI;

            cx = -r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            cy = r * Math.sin( v );

            pos2.copy( pos );
            pos2.x += cx * normal.x + cy * binormal.x;
            pos2.y += cx * normal.y + cy * binormal.y;
            pos2.z += cx * normal.z + cy * binormal.z;

            grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

        }

    }


    // construct the mesh

    for ( i = 0; i < segments; i++ ) {

        for ( j = 0; j < radialSegments; j++ ) {

            ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
            jp = ( j + 1 ) % radialSegments;

            a = grid[ i ][ j ]; // *** NOT NECESSARILY PLANAR ! ***
            b = grid[ ip ][ j ];
            c = grid[ ip ][ jp ];
            d = grid[ i ][ jp ];

            uva = new THREE.Vector2( i / segments, j / radialSegments );
            uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
            uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
            uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function( u ) {

    return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function( u ) {

    return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function( path, segments, closed ) {

    var normal = new THREE.Vector3(),

        tangents = [],
        normals = [],
        binormals = [],

        vec = new THREE.Vector3(),
        mat = new THREE.Matrix4(),

        numpoints = segments + 1,
        theta,
        epsilon = 0.0001,
        smallest,

        tx, ty, tz,
        i, u;


    // expose internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    // compute the tangent vectors for each segment on the path

    for ( i = 0; i < numpoints; i++ ) {

        u = i / ( numpoints - 1 );

        tangents[ i ] = path.getTangentAt( u );
        tangents[ i ].normalize();

    }

    initialNormal3();

    /*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

    function initialNormal3() {

        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the smallest tangent xyz component

        normals[ 0 ] = new THREE.Vector3();
        binormals[ 0 ] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs( tangents[ 0 ].x );
        ty = Math.abs( tangents[ 0 ].y );
        tz = Math.abs( tangents[ 0 ].z );

        if ( tx <= smallest ) {

            smallest = tx;
            normal.set( 1, 0, 0 );

        }

        if ( ty <= smallest ) {

            smallest = ty;
            normal.set( 0, 1, 0 );

        }

        if ( tz <= smallest ) {

            normal.set( 0, 0, 1 );

        }

        vec.crossVectors( tangents[ 0 ], normal ).normalize();

        normals[ 0 ].crossVectors( tangents[ 0 ], vec );
        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    }


    // compute the slowly-varying normal and binormal vectors for each segment on the path

    for ( i = 1; i < numpoints; i++ ) {

        normals[ i ] = normals[ i - 1 ].clone();

        binormals[ i ] = binormals[ i - 1 ].clone();

        vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

        if ( vec.length() > epsilon ) {

            vec.normalize();

            theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

            normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

        }

        binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }


    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    if ( closed ) {

        theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), -1, 1 ) );
        theta /= ( numpoints - 1 );

        if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

            theta = -theta;

        }

        for ( i = 1; i < numpoints; i++ ) {

            // twist a little...
            normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

        }

    }

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.PolyhedronGeometry = function( vertices, indices, radius, detail ) {

    THREE.Geometry.call( this );

    this.type = 'PolyhedronGeometry';

    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };

    radius = radius || 1;
    detail = detail || 0;

    var that = this;

    for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

        prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    }

    var p = this.vertices;

    var faces = [];

    for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j++ ) {

        var v1 = p[ indices[ i ] ];
        var v2 = p[ indices[ i + 1 ] ];
        var v3 = p[ indices[ i + 2 ] ];

        faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

    }

    var centroid = new THREE.Vector3();

    for ( var i = 0, l = faces.length; i < l; i++ ) {

        subdivide( faces[ i ], detail );

    }


    // Handle case when face straddles the seam

    for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i++ ) {

        var uvs = this.faceVertexUvs[ 0 ][ i ];

        var x0 = uvs[ 0 ].x;
        var x1 = uvs[ 1 ].x;
        var x2 = uvs[ 2 ].x;

        var max = Math.max( x0, Math.max( x1, x2 ) );
        var min = Math.min( x0, Math.min( x1, x2 ) );

        if ( max > 0.9 && min < 0.1 ) {

            // 0.9 is somewhat arbitrary

            if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
            if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
            if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

        }

    }


    // Apply radius

    for ( var i = 0, l = this.vertices.length; i < l; i++ ) {

        this.vertices[ i ].multiplyScalar( radius );

    }


    // Merge vertices

    this.mergeVertices();

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


    // Project vector onto sphere's surface

    function prepare( vector ) {

        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push( vertex ) - 1;

        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

        var u = azimuth( vector ) / 2 / Math.PI + 0.5;
        var v = inclination( vector ) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2( u, 1 - v );

        return vertex;

    }


    // Approximate a curved face with recursively sub-divided triangles.

    function make( v1, v2, v3, materialIndex ) {

        var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
        that.faces.push( face );

        centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

        var azi = azimuth( centroid );

        that.faceVertexUvs[ 0 ].push( [
            correctUV( v1.uv, v1, azi ),
            correctUV( v2.uv, v2, azi ),
            correctUV( v3.uv, v3, azi )
        ] );

    }


    // Analytically subdivide a face to the required detail level.

    function subdivide( face, detail ) {

        var cols = Math.pow( 2, detail );
        var a = prepare( that.vertices[ face.a ] );
        var b = prepare( that.vertices[ face.b ] );
        var c = prepare( that.vertices[ face.c ] );
        var v = [];

        var materialIndex = face.materialIndex;

        // Construct all of the vertices for this subdivision.

        for ( var i = 0; i <= cols; i++ ) {

            v[ i ] = [];

            var aj = prepare( a.clone().lerp( c, i / cols ) );
            var bj = prepare( b.clone().lerp( c, i / cols ) );
            var rows = cols - i;

            for ( var j = 0; j <= rows; j++ ) {

                if ( j === 0 && i === cols ) {

                    v[ i ][ j ] = aj;

                }
                else {

                    v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

                }

            }

        }

        // Construct all of the faces.

        for ( var i = 0; i < cols; i++ ) {

            for ( var j = 0; j < 2 * ( cols - i ) - 1; j++ ) {

                var k = Math.floor( j / 2 );

                if ( j % 2 === 0 ) {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        v[ i ][ k ],
                        materialIndex
                    );

                }
                else {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        materialIndex
                    );

                }

            }

        }

    }


    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth( vector ) {

        return Math.atan2( vector.z, -vector.x );

    }


    // Angle above the XZ plane.

    function inclination( vector ) {

        return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    }


    // Texture fixing helper. Spheres have some odd behaviours.

    function correctUV( uv, vector, azimuth ) {

        if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
        if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
        return uv.clone();

    }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function() {

    var geometry = new THREE.PolyhedronGeometry(
        this.parameters.vertices,
        this.parameters.indices,
        this.parameters.radius,
        this.parameters.detail
    );

    return geometry.copy( this );

};

THREE.PolyhedronGeometry.prototype.copy = function( source ) {

    THREE.Geometry.prototype.copy.call( this, source );
    return this;

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    var r = 1 / t;

    var vertices = [

        // (±1, ±1, ±1)
        -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1,
        1, -1, -1, 1, -1, 1,
        1, 1, -1, 1, 1, 1,

        // (0, ±1/φ, ±φ)
        0, -r, -t, 0, -r, t,
        0, r, -t, 0, r, t,

        // (±1/φ, ±φ, 0)
        -r, -t, 0, -r, t, 0,
        r, -t, 0, r, t, 0,

        // (±φ, 0, ±1/φ)
        -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r
    ];

    var indices = [
        3, 11, 7, 3, 7, 15, 3, 15, 13,
        7, 19, 17, 7, 17, 6, 7, 6, 15,
        17, 4, 8, 17, 8, 10, 17, 10, 6,
        8, 0, 16, 8, 16, 2, 8, 2, 10,
        0, 12, 1, 0, 1, 18, 0, 18, 16,
        6, 10, 2, 6, 2, 13, 6, 13, 15,
        2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3,
        4, 14, 12, 4, 12, 0, 4, 0, 8,
        11, 9, 5, 11, 5, 19, 11, 19, 7,
        19, 5, 14, 19, 14, 4, 19, 4, 17,
        1, 12, 14, 1, 14, 5, 1, 5, 9
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'DodecahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.DodecahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
        0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
        t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
    ];

    var indices = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
        1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
        3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'IcosahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.IcosahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function( radius, detail ) {

    var vertices = [
        1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1
    ];

    var indices = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'OctahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.OctahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function( radius, detail ) {

    var vertices = [
        1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
    ];

    var indices = [
        2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'TetrahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function() {

    var geometry = new THREE.TetrahedronGeometry(
        this.parameters.radius,
        this.parameters.detail
    );

    geometry.copy( this );

    return geometry;

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function( func, slices, stacks ) {

    THREE.Geometry.call( this );

    this.type = 'ParametricGeometry';

    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };

    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[ 0 ];

    var i, j, p;
    var u, v;

    var sliceCount = slices + 1;

    for ( i = 0; i <= stacks; i++ ) {

        v = i / stacks;

        for ( j = 0; j <= slices; j++ ) {

            u = j / slices;

            p = func( u, v );
            verts.push( p );

        }

    }

    var a, b, c, d;
    var uva, uvb, uvc, uvd;

    for ( i = 0; i < stacks; i++ ) {

        for ( j = 0; j < slices; j++ ) {

            a = i * sliceCount + j;
            b = i * sliceCount + j + 1;
            c = ( i + 1 ) * sliceCount + j + 1;
            d = ( i + 1 ) * sliceCount + j;

            uva = new THREE.Vector2( j / slices, i / stacks );
            uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
            uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
            uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

            faces.push( new THREE.Face3( a, b, d ) );
            uvs.push( [ uva, uvb, uvd ] );

            faces.push( new THREE.Face3( b, c, d ) );
            uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    // console.log(this);

    // magic bullet
    // var diff = this.mergeVertices();
    // console.log('removed ', diff, ' vertices by merging');

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function( geometry ) {

    THREE.BufferGeometry.call( this );

    var edge = [ 0, 0 ],
        hash = {};
    var sortFunction = function( a, b ) {

        return a - b;

    };

    var keys = [ 'a', 'b', 'c' ];

    if ( geometry instanceof THREE.Geometry ) {

        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;

        // allocate maximal size
        var edges = new Uint32Array( 6 * faces.length );

        for ( var i = 0, l = faces.length; i < l; i++ ) {

            var face = faces[ i ];

            for ( var j = 0; j < 3; j++ ) {

                edge[ 0 ] = face[ keys[ j ] ];
                edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
                edge.sort( sortFunction );

                var key = edge.toString();

                if ( hash[ key ] === undefined ) {

                    edges[ 2 * numEdges ] = edge[ 0 ];
                    edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                    hash[ key ] = true;
                    numEdges++;

                }

            }

        }

        var coords = new Float32Array( numEdges * 2 * 3 );

        for ( var i = 0, l = numEdges; i < l; i++ ) {

            for ( var j = 0; j < 2; j++ ) {

                var vertex = vertices[ edges[ 2 * i + j ] ];

                var index = 6 * i + 3 * j;
                coords[ index + 0 ] = vertex.x;
                coords[ index + 1 ] = vertex.y;
                coords[ index + 2 ] = vertex.z;

            }

        }

        this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }
    else if ( geometry instanceof THREE.BufferGeometry ) {

        if ( geometry.index !== null ) {

            // Indexed BufferGeometry

            var indices = geometry.index.array;
            var vertices = geometry.attributes.position;
            var drawcalls = geometry.drawcalls;
            var numEdges = 0;

            if ( drawcalls.length === 0 ) {

                geometry.addDrawCall( 0, indices.length );

            }

            // allocate maximal size
            var edges = new Uint32Array( 2 * indices.length );

            for ( var o = 0, ol = drawcalls.length; o < ol; ++o ) {

                var drawcall = drawcalls[ o ];

                var start = drawcall.start;
                var count = drawcall.count;

                for ( var i = start, il = start + count; i < il; i += 3 ) {

                    for ( var j = 0; j < 3; j++ ) {

                        edge[ 0 ] = indices[ i + j ];
                        edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
                        edge.sort( sortFunction );

                        var key = edge.toString();

                        if ( hash[ key ] === undefined ) {

                            edges[ 2 * numEdges ] = edge[ 0 ];
                            edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                            hash[ key ] = true;
                            numEdges++;

                        }

                    }

                }

            }

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numEdges; i < l; i++ ) {

                for ( var j = 0; j < 2; j++ ) {

                    var index = 6 * i + 3 * j;
                    var index2 = edges[ 2 * i + j ];

                    coords[ index + 0 ] = vertices.getX( index2 );
                    coords[ index + 1 ] = vertices.getY( index2 );
                    coords[ index + 2 ] = vertices.getZ( index2 );

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }
        else {

            // non-indexed BufferGeometry

            var vertices = geometry.attributes.position.array;
            var numEdges = vertices.length / 3;
            var numTris = numEdges / 3;

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numTris; i < l; i++ ) {

                for ( var j = 0; j < 3; j++ ) {

                    var index = 18 * i + 6 * j;

                    var index1 = 9 * i + 3 * j;
                    coords[ index + 0 ] = vertices[ index1 ];
                    coords[ index + 1 ] = vertices[ index1 + 1 ];
                    coords[ index + 2 ] = vertices[ index1 + 2 ];

                    var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
                    coords[ index + 3 ] = vertices[ index2 ];
                    coords[ index + 4 ] = vertices[ index2 + 1 ];
                    coords[ index + 5 ] = vertices[ index2 + 2 ];

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }

    }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function( size ) {

    size = size || 1;

    var vertices = new Float32Array( [
        0, 0, 0, size, 0, 0,
        0, 0, 0, 0, size, 0,
        0, 0, 0, 0, 0, size
    ] );

    var colors = new Float32Array( [
        1, 0, 0, 1, 0.6, 0,
        0, 1, 0, 0.6, 1, 0,
        0, 0, 1, 0, 0.6, 1
    ] );

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors
    } );

    THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function() {

    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

    var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, -0.5, 0 );

    return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

        // dir is assumed to be normalized

        THREE.Object3D.call( this );

        if ( color === undefined ) color = 0xffff00;
        if ( length === undefined ) length = 1;
        if ( headLength === undefined ) headLength = 0.2 * length;
        if ( headWidth === undefined ) headWidth = 0.2 * headLength;

        this.position.copy( origin );

        if ( headLength < length ) {
            this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( {
                color: color
            } ) );
            this.line.matrixAutoUpdate = false;
            this.add( this.line );
        }

        this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( {
            color: color
        } ) );
        this.cone.matrixAutoUpdate = false;
        this.add( this.cone );

        this.setDirection( dir );
        this.setLength( length, headLength, headWidth );

    }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function() {

    var axis = new THREE.Vector3();
    var radians;

    return function setDirection( dir ) {

        // dir is assumed to be normalized

        if ( dir.y > 0.99999 ) {

            this.quaternion.set( 0, 0, 0, 1 );

        }
        else if ( dir.y < -0.99999 ) {

            this.quaternion.set( 1, 0, 0, 0 );

        }
        else {

            axis.set( dir.z, 0, -dir.x ).normalize();

            radians = Math.acos( dir.y );

            this.quaternion.setFromAxisAngle( axis, radians );

        }

    };

}() );

THREE.ArrowHelper.prototype.setLength = function( length, headLength, headWidth ) {

    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    if ( headLength < length ) {
        this.line.scale.set( 1, length - headLength, 1 );
        this.line.updateMatrix();
    }

    this.cone.scale.set( headWidth, headLength, headWidth );
    this.cone.position.y = length;
    this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function( color ) {

    if ( this.line !== undefined ) this.line.material.color.set( color );
    this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function( object ) {

    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    var positions = new Float32Array( 8 * 3 );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: 0xffff00
    } ) );

    if ( object !== undefined ) {

        this.update( object );

    }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function() {

    var box = new THREE.Box3();

    return function( object ) {

        box.setFromObject( object );

        if ( box.empty() ) return;

        var min = box.min;
        var max = box.max;

        /*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

        var position = this.geometry.attributes.position;
        var array = position.array;

        array[ 0 ] = max.x;
        array[ 1 ] = max.y;
        array[ 2 ] = max.z;
        array[ 3 ] = min.x;
        array[ 4 ] = max.y;
        array[ 5 ] = max.z;
        array[ 6 ] = min.x;
        array[ 7 ] = min.y;
        array[ 8 ] = max.z;
        array[ 9 ] = max.x;
        array[ 10 ] = min.y;
        array[ 11 ] = max.z;
        array[ 12 ] = max.x;
        array[ 13 ] = max.y;
        array[ 14 ] = min.z;
        array[ 15 ] = min.x;
        array[ 16 ] = max.y;
        array[ 17 ] = min.z;
        array[ 18 ] = min.x;
        array[ 19 ] = min.y;
        array[ 20 ] = min.z;
        array[ 21 ] = max.x;
        array[ 22 ] = min.y;
        array[ 23 ] = min.z;

        position.needsUpdate = true;

        this.geometry.computeBoundingSphere();

    }

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0x888888;

    this.object = object;

    this.box = new THREE.Box3();

    THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( {
        color: color,
        wireframe: true
    } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function() {

    this.box.setFromObject( this.object );

    this.box.size( this.scale );

    this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function( camera ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( {
        color: 0xffffff,
        vertexColors: THREE.FaceColors
    } );

    var pointMap = {};

    // colors

    var hexFrustum = 0xffaa00;
    var hexCone = 0xff0000;
    var hexUp = 0x00aaff;
    var hexTarget = 0xffffff;
    var hexCross = 0x333333;

    // near

    addLine( "n1", "n2", hexFrustum );
    addLine( "n2", "n4", hexFrustum );
    addLine( "n4", "n3", hexFrustum );
    addLine( "n3", "n1", hexFrustum );

    // far

    addLine( "f1", "f2", hexFrustum );
    addLine( "f2", "f4", hexFrustum );
    addLine( "f4", "f3", hexFrustum );
    addLine( "f3", "f1", hexFrustum );

    // sides

    addLine( "n1", "f1", hexFrustum );
    addLine( "n2", "f2", hexFrustum );
    addLine( "n3", "f3", hexFrustum );
    addLine( "n4", "f4", hexFrustum );

    // cone

    addLine( "p", "n1", hexCone );
    addLine( "p", "n2", hexCone );
    addLine( "p", "n3", hexCone );
    addLine( "p", "n4", hexCone );

    // up

    addLine( "u1", "u2", hexUp );
    addLine( "u2", "u3", hexUp );
    addLine( "u3", "u1", hexUp );

    // target

    addLine( "c", "t", hexTarget );
    addLine( "p", "c", hexCross );

    // cross

    addLine( "cn1", "cn2", hexCross );
    addLine( "cn3", "cn4", hexCross );

    addLine( "cf1", "cf2", hexCross );
    addLine( "cf3", "cf4", hexCross );

    function addLine( a, b, hex ) {

        addPoint( a, hex );
        addPoint( b, hex );

    }

    function addPoint( id, hex ) {

        geometry.vertices.push( new THREE.Vector3() );
        geometry.colors.push( new THREE.Color( hex ) );

        if ( pointMap[ id ] === undefined ) {

            pointMap[ id ] = [];

        }

        pointMap[ id ].push( geometry.vertices.length - 1 );

    }

    THREE.LineSegments.call( this, geometry, material );

    this.camera = camera;
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;

    this.pointMap = pointMap;

    this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function() {

    var geometry, pointMap;

    var vector = new THREE.Vector3();
    var camera = new THREE.Camera();

    var setPoint = function( point, x, y, z ) {

        vector.set( x, y, z ).unproject( camera );

        var points = pointMap[ point ];

        if ( points !== undefined ) {

            for ( var i = 0, il = points.length; i < il; i++ ) {

                geometry.vertices[ points[ i ] ].copy( vector );

            }

        }

    };

    return function() {

        geometry = this.geometry;
        pointMap = this.pointMap;

        var w = 1,
            h = 1;

        // we need just camera projection matrix
        // world matrix must be identity

        camera.projectionMatrix.copy( this.camera.projectionMatrix );

        // center / target

        setPoint( "c", 0, 0, -1 );
        setPoint( "t", 0, 0, 1 );

        // near

        setPoint( "n1", -w, -h, -1 );
        setPoint( "n2", w, -h, -1 );
        setPoint( "n3", -w, h, -1 );
        setPoint( "n4", w, h, -1 );

        // far

        setPoint( "f1", -w, -h, 1 );
        setPoint( "f2", w, -h, 1 );
        setPoint( "f3", -w, h, 1 );
        setPoint( "f4", w, h, 1 );

        // up

        setPoint( "u1", w * 0.7, h * 1.1, -1 );
        setPoint( "u2", -w * 0.7, h * 1.1, -1 );
        setPoint( "u3", 0, h * 2, -1 );

        // cross

        setPoint( "cf1", -w, 0, 1 );
        setPoint( "cf2", w, 0, 1 );
        setPoint( "cf3", 0, -h, 1 );
        setPoint( "cf4", 0, h, 1 );

        setPoint( "cn1", -w, 0, -1 );
        setPoint( "cn2", w, 0, -1 );
        setPoint( "cn3", 0, -h, -1 );
        setPoint( "cn4", 0, h, -1 );

        geometry.verticesNeedUpdate = true;

    };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function( light, size ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    size = size || 1;

    var geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3( -size, size, 0 ),
        new THREE.Vector3( size, size, 0 ),
        new THREE.Vector3( size, -size, 0 ),
        new THREE.Vector3( -size, -size, 0 ),
        new THREE.Vector3( -size, size, 0 )
    );

    var material = new THREE.LineBasicMaterial( {
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.lightPlane = new THREE.Line( geometry, material );
    this.add( this.lightPlane );

    geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3(),
        new THREE.Vector3()
    );

    material = new THREE.LineBasicMaterial( {
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine = new THREE.Line( geometry, material );
    this.add( this.targetLine );

    this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function() {

    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v3 = new THREE.Vector3();

    return function() {

        v1.setFromMatrixPosition( this.light.matrixWorld );
        v2.setFromMatrixPosition( this.light.target.matrixWorld );
        v3.subVectors( v2, v1 );

        this.lightPlane.lookAt( v3 );
        this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

        this.targetLine.geometry.vertices[ 1 ].copy( v3 );
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy( this.lightPlane.material.color );

    };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function( object, hex, thresholdAngle ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( {
        color: color
    } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.FaceNormalsHelper = function( object, size, hex, linewidth ) {

    // FaceNormalsHelper only supports THREE.Geometry

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length;

    }
    else {

        console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: color,
        linewidth: width
    } ) );

    //

    this.matrixAutoUpdate = false;
    this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        var vertices = objGeometry.vertices;

        var faces = objGeometry.faces;

        var idx = 0;

        for ( var i = 0, l = faces.length; i < l; i++ ) {

            var face = faces[ i ];

            var normal = face.normal;

            v1.copy( vertices[ face.a ] )
                .add( vertices[ face.b ] )
                .add( vertices[ face.c ] )
                .divideScalar( 3 )
                .applyMatrix4( matrixWorld );

            v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

            position.setXYZ( idx, v1.x, v1.y, v1.z );

            idx = idx + 1;

            position.setXYZ( idx, v2.x, v2.y, v2.z );

            idx = idx + 1;

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function( size, step ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors
    } );

    this.color1 = new THREE.Color( 0x444444 );
    this.color2 = new THREE.Color( 0x888888 );

    for ( var i = -size; i <= size; i += step ) {

        geometry.vertices.push(
            new THREE.Vector3( -size, 0, i ), new THREE.Vector3( size, 0, i ),
            new THREE.Vector3( i, 0, -size ), new THREE.Vector3( i, 0, size )
        );

        var color = i === 0 ? this.color1 : this.color2;

        geometry.colors.push( color, color, color, color );

    }

    THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

    this.color1.set( colorCenterLine );
    this.color2.set( colorGrid );

    this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function( light, sphereSize ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.colors = [ new THREE.Color(), new THREE.Color() ];

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    geometry.rotateX( -Math.PI / 2 );

    for ( var i = 0, il = 8; i < il; i++ ) {

        geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    }

    var material = new THREE.MeshBasicMaterial( {
        vertexColors: THREE.FaceColors,
        wireframe: true
    } );

    this.lightSphere = new THREE.Mesh( geometry, material );
    this.add( this.lightSphere );

    this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function() {

    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function() {

    var vector = new THREE.Vector3();

    return function() {

        this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
        this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

        this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
        this.lightSphere.geometry.colorsNeedUpdate = true;

    }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function( light, sphereSize ) {

    this.light = light;
    this.light.updateMatrixWorld();

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    var material = new THREE.MeshBasicMaterial( {
        wireframe: true,
        fog: false
    } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    THREE.Mesh.call( this, geometry, material );

    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;

    /*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function() {

    this.geometry.dispose();
    this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function() {

    this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    /*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function( object ) {

    this.bones = this.getBoneList( object );

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < this.bones.length; i++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            geometry.vertices.push( new THREE.Vector3() );
            geometry.vertices.push( new THREE.Vector3() );
            geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
            geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

        }

    }

    geometry.dynamic = true;

    var material = new THREE.LineBasicMaterial( {
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
    } );

    THREE.LineSegments.call( this, geometry, material );

    this.root = object;

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

    this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

    var boneList = [];

    if ( object instanceof THREE.Bone ) {

        boneList.push( object );

    }

    for ( var i = 0; i < object.children.length; i++ ) {

        boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    }

    return boneList;

};

THREE.SkeletonHelper.prototype.update = function() {

    var geometry = this.geometry;

    var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

    var boneMatrix = new THREE.Matrix4();

    var j = 0;

    for ( var i = 0; i < this.bones.length; i++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
            geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
            geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

            j += 2;

        }

    }

    geometry.verticesNeedUpdate = true;

    geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.SpotLightHelper = function( light ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

    geometry.translate( 0, -0.5, 0 );
    geometry.rotateX( -Math.PI / 2 );

    var material = new THREE.MeshBasicMaterial( {
        wireframe: true,
        fog: false
    } );

    this.cone = new THREE.Mesh( geometry, material );
    this.add( this.cone );

    this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function() {

    this.cone.geometry.dispose();
    this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function() {

    var vector = new THREE.Vector3();
    var vector2 = new THREE.Vector3();

    return function() {

        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan( this.light.angle );

        this.cone.scale.set( coneWidth, coneWidth, coneLength );

        vector.setFromMatrixPosition( this.light.matrixWorld );
        vector2.setFromMatrixPosition( this.light.target.matrixWorld );

        this.cone.lookAt( vector2.sub( vector ) );

        this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.VertexNormalsHelper = function( object, size, hex, linewidth ) {

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xff0000;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length * 3;

    }
    else if ( objGeometry instanceof THREE.BufferGeometry ) {

        nNormals = objGeometry.attributes.normal.count

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( {
        color: color,
        linewidth: width
    } ) );

    //

    this.matrixAutoUpdate = false;

    this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function() {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        var keys = [ 'a', 'b', 'c' ];

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        if ( objGeometry instanceof THREE.Geometry ) {

            var vertices = objGeometry.vertices;

            var faces = objGeometry.faces;

            var idx = 0;

            for ( var i = 0, l = faces.length; i < l; i++ ) {

                var face = faces[ i ];

                for ( var j = 0, jl = face.vertexNormals.length; j < jl; j++ ) {

                    var vertex = vertices[ face[ keys[ j ] ] ];

                    var normal = face.vertexNormals[ j ];

                    v1.copy( vertex ).applyMatrix4( matrixWorld );

                    v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                    position.setXYZ( idx, v1.x, v1.y, v1.z );

                    idx = idx + 1;

                    position.setXYZ( idx, v2.x, v2.y, v2.z );

                    idx = idx + 1;

                }

            }

        }
        else if ( objGeometry instanceof THREE.BufferGeometry ) {

            var objPos = objGeometry.attributes.position;

            var objNorm = objGeometry.attributes.normal;

            var idx = 0;

            // for simplicity, ignore index and drawcalls, and render every normal

            for ( var j = 0, jl = objPos.count; j < jl; j++ ) {

                v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

                v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

                v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                position.setXYZ( idx, v1.x, v1.y, v1.z );

                idx = idx + 1;

                position.setXYZ( idx, v2.x, v2.y, v2.z );

                idx = idx + 1;

            }

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( {
        color: color
    } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function() {

    THREE.Object3D.call( this );

    this.render = function( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.animationsMap = {};
    this.animationsList = [];

    // prepare default animation
    // (all frames played together in 1 second)

    var numFrames = this.geometry.morphTargets.length;

    var name = "__default";

    var startFrame = 0;
    var endFrame = numFrames - 1;

    var fps = numFrames / 1;

    this.createAnimation( name, startFrame, endFrame, fps );
    this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function( name, start, end, fps ) {

    var animation = {

        start: start,
        end: end,

        length: end - start + 1,

        fps: fps,
        duration: ( end - start ) / fps,

        lastFrame: 0,
        currentFrame: 0,

        active: false,

        time: 0,
        direction: 1,
        weight: 1,

        directionBackwards: false,
        mirroredLoop: false

    };

    this.animationsMap[ name ] = animation;
    this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function( fps ) {

    var pattern = /([a-z]+)_?(\d+)/;

    var firstAnimation, frameRanges = {};

    var geometry = this.geometry;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i++ ) {

        var morph = geometry.morphTargets[ i ];
        var chunks = morph.name.match( pattern );

        if ( chunks && chunks.length > 1 ) {

            var name = chunks[ 1 ];

            if ( !frameRanges[ name ] ) frameRanges[ name ] = {
                start: Infinity,
                end: -Infinity
            };

            var range = frameRanges[ name ];

            if ( i < range.start ) range.start = i;
            if ( i > range.end ) range.end = i;

            if ( !firstAnimation ) firstAnimation = name;

        }

    }

    for ( var name in frameRanges ) {

        var range = frameRanges[ name ];
        this.createAnimation( name, range.start, range.end, fps );

    }

    this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = 1;
        animation.directionBackwards = false;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = -1;
        animation.directionBackwards = true;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function( name, fps ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.fps = fps;
        animation.duration = ( animation.end - animation.start ) / animation.fps;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function( name, duration ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.duration = duration;
        animation.fps = ( animation.end - animation.start ) / animation.duration;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function( name, weight ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.weight = weight;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function( name, time ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = time;

    }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function( name ) {

    var time = 0;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        time = animation.time;

    }

    return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function( name ) {

    var duration = -1;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        duration = animation.duration;

    }

    return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = 0;
        animation.active = true;

    }
    else {

        console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.active = false;

    }

};

THREE.MorphBlendMesh.prototype.update = function( delta ) {

    for ( var i = 0, il = this.animationsList.length; i < il; i++ ) {

        var animation = this.animationsList[ i ];

        if ( !animation.active ) continue;

        var frameTime = animation.duration / animation.length;

        animation.time += animation.direction * delta;

        if ( animation.mirroredLoop ) {

            if ( animation.time > animation.duration || animation.time < 0 ) {

                animation.direction *= -1;

                if ( animation.time > animation.duration ) {

                    animation.time = animation.duration;
                    animation.directionBackwards = true;

                }

                if ( animation.time < 0 ) {

                    animation.time = 0;
                    animation.directionBackwards = false;

                }

            }

        }
        else {

            animation.time = animation.time % animation.duration;

            if ( animation.time < 0 ) animation.time += animation.duration;

        }

        var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
        var weight = animation.weight;

        if ( keyframe !== animation.currentFrame ) {

            this.morphTargetInfluences[ animation.lastFrame ] = 0;
            this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

            this.morphTargetInfluences[ keyframe ] = 0;

            animation.lastFrame = animation.currentFrame;
            animation.currentFrame = keyframe;

        }

        var mix = ( animation.time % frameTime ) / frameTime;

        if ( animation.directionBackwards ) mix = 1 - mix;

        if ( animation.currentFrame !== animation.lastFrame ) {

            this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
            this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

        }
        else {

            this.morphTargetInfluences[ animation.currentFrame ] = weight;

        }

    }

};
},{}],"TextLayer":[function(require,module,exports){
var TextLayer, convertTextLayers, convertToTextLayer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

TextLayer = (function(superClass) {
  extend(TextLayer, superClass);

  function TextLayer(options) {
    if (options == null) {
      options = {};
    }
    this.doAutoSize = false;
    this.doAutoSizeHeight = false;
    if (options.backgroundColor == null) {
      options.backgroundColor = options.setup ? "hsla(60, 90%, 47%, .4)" : "transparent";
    }
    if (options.color == null) {
      options.color = "red";
    }
    if (options.lineHeight == null) {
      options.lineHeight = 1.25;
    }
    if (options.fontFamily == null) {
      options.fontFamily = "Helvetica";
    }
    if (options.fontSize == null) {
      options.fontSize = 20;
    }
    if (options.text == null) {
      options.text = "Use layer.text to add text";
    }
    TextLayer.__super__.constructor.call(this, options);
    this.style.whiteSpace = "pre-line";
    this.style.outline = "none";
  }

  TextLayer.prototype.setStyle = function(property, value, pxSuffix) {
    if (pxSuffix == null) {
      pxSuffix = false;
    }
    this.style[property] = pxSuffix ? value + "px" : value;
    this.emit("change:" + property, value);
    if (this.doAutoSize) {
      return this.calcSize();
    }
  };

  TextLayer.prototype.calcSize = function() {
    var constraints, size, sizeAffectingStyles;
    sizeAffectingStyles = {
      lineHeight: this.style["line-height"],
      fontSize: this.style["font-size"],
      fontWeight: this.style["font-weight"],
      paddingTop: this.style["padding-top"],
      paddingRight: this.style["padding-right"],
      paddingBottom: this.style["padding-bottom"],
      paddingLeft: this.style["padding-left"],
      textTransform: this.style["text-transform"],
      borderWidth: this.style["border-width"],
      letterSpacing: this.style["letter-spacing"],
      fontFamily: this.style["font-family"],
      fontStyle: this.style["font-style"],
      fontVariant: this.style["font-variant"]
    };
    constraints = {};
    if (this.doAutoSizeHeight) {
      constraints.width = this.width;
    }
    size = Utils.textSize(this.text, sizeAffectingStyles, constraints);
    if (this.style.textAlign === "right") {
      this.width = size.width;
      this.x = this.x - this.width;
    } else {
      this.width = size.width;
    }
    return this.height = size.height;
  };

  TextLayer.define("autoSize", {
    get: function() {
      return this.doAutoSize;
    },
    set: function(value) {
      this.doAutoSize = value;
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("autoSizeHeight", {
    set: function(value) {
      this.doAutoSize = value;
      this.doAutoSizeHeight = value;
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("contentEditable", {
    set: function(boolean) {
      this._element.contentEditable = boolean;
      this.ignoreEvents = !boolean;
      return this.on("input", function() {
        if (this.doAutoSize) {
          return this.calcSize();
        }
      });
    }
  });

  TextLayer.define("text", {
    get: function() {
      return this._element.textContent;
    },
    set: function(value) {
      this._element.textContent = value;
      this.emit("change:text", value);
      if (this.doAutoSize) {
        return this.calcSize();
      }
    }
  });

  TextLayer.define("fontFamily", {
    get: function() {
      return this.style.fontFamily;
    },
    set: function(value) {
      return this.setStyle("fontFamily", value);
    }
  });

  TextLayer.define("fontSize", {
    get: function() {
      return this.style.fontSize.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("fontSize", value, true);
    }
  });

  TextLayer.define("lineHeight", {
    get: function() {
      return this.style.lineHeight;
    },
    set: function(value) {
      return this.setStyle("lineHeight", value);
    }
  });

  TextLayer.define("fontWeight", {
    get: function() {
      return this.style.fontWeight;
    },
    set: function(value) {
      return this.setStyle("fontWeight", value);
    }
  });

  TextLayer.define("fontStyle", {
    get: function() {
      return this.style.fontStyle;
    },
    set: function(value) {
      return this.setStyle("fontStyle", value);
    }
  });

  TextLayer.define("fontVariant", {
    get: function() {
      return this.style.fontVariant;
    },
    set: function(value) {
      return this.setStyle("fontVariant", value);
    }
  });

  TextLayer.define("padding", {
    set: function(value) {
      this.setStyle("paddingTop", value, true);
      this.setStyle("paddingRight", value, true);
      this.setStyle("paddingBottom", value, true);
      return this.setStyle("paddingLeft", value, true);
    }
  });

  TextLayer.define("paddingTop", {
    get: function() {
      return this.style.paddingTop.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingTop", value, true);
    }
  });

  TextLayer.define("paddingRight", {
    get: function() {
      return this.style.paddingRight.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingRight", value, true);
    }
  });

  TextLayer.define("paddingBottom", {
    get: function() {
      return this.style.paddingBottom.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingBottom", value, true);
    }
  });

  TextLayer.define("paddingLeft", {
    get: function() {
      return this.style.paddingLeft.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("paddingLeft", value, true);
    }
  });

  TextLayer.define("textAlign", {
    set: function(value) {
      return this.setStyle("textAlign", value);
    }
  });

  TextLayer.define("textTransform", {
    get: function() {
      return this.style.textTransform;
    },
    set: function(value) {
      return this.setStyle("textTransform", value);
    }
  });

  TextLayer.define("letterSpacing", {
    get: function() {
      return this.style.letterSpacing.replace("px", "");
    },
    set: function(value) {
      return this.setStyle("letterSpacing", value, true);
    }
  });

  TextLayer.define("length", {
    get: function() {
      return this.text.length;
    }
  });

  return TextLayer;

})(Layer);

convertToTextLayer = function(layer, debug) {
  var css, key, styleObj, t, val;
  t = new TextLayer({
    name: layer.name,
    frame: layer.frame,
    parent: layer.parent,
    text: layer._info.metadata.string
  });
  styleObj = {};
  css = layer._info.metadata.css;
  css.forEach(function(rule) {
    var arr, prop, value;
    if (_.includes(rule, '/*')) {
      return;
    }
    arr = rule.split(': ');
    prop = _.camelCase(arr[0]);
    value = arr[1].replace(';', '');
    if (["fontSize", "letterSpacing", "lineHeight"].indexOf(prop) > -1) {
      value = parseInt(value);
    }
    return styleObj[prop] = value;
  });
  if (styleObj.hasOwnProperty("lineHeight")) {
    styleObj["lineHeight"] = styleObj.lineHeight / styleObj.fontSize;
  } else {
    styleObj["lineHeight"] = 1.3;
  }
  for (key in styleObj) {
    val = styleObj[key];
    t[key] = val;
  }
  t.y -= (t.fontSize / t.lineHeight) / (4 - t.lineHeight);
  t.x -= t.fontSize * 0.07;
  t.width += t.fontSize * 0.5;
  if (debug) {
    layer.opacity = .5;
  } else {
    layer.destroy();
  }
  return t;
};

Layer.prototype.convertToTextLayer = function(debug) {
  return convertToTextLayer(this, debug);
};

convertTextLayers = function(obj, debug) {
  var layer, prop, results;
  results = [];
  for (prop in obj) {
    layer = obj[prop];
    if (layer._info.kind === "text") {
      results.push(obj[prop] = convertToTextLayer(layer, debug));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

Layer.prototype.frameAsTextLayer = function(properties) {
  var t;
  t = new TextLayer;
  t.frame = this.frame;
  t.superLayer = this.superLayer;
  _.extend(t, properties);
  this.destroy();
  return t;
};

exports.TextLayer = TextLayer;

exports.convertTextLayers = convertTextLayers;


},{}],"myModule":[function(require,module,exports){
exports.myVar = "myVariable";

exports.myFunction = function() {
  return print("myFunction is running");
};

exports.myArray = [1, 2, 3];


},{}]},{},[])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWVyLm1vZHVsZXMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL1VzZXJzL1BoaWxpbmUgU2NoZWxsL0RvY3VtZW50cy9TdHVkaXVtL0hUVy9iZXJsaW5lcmx1ZnQvYmVybGluZXJsdWZ0X2xpZ2h0LmZyYW1lci9tb2R1bGVzL215TW9kdWxlLmNvZmZlZSIsIi4uLy4uLy4uLy4uLy4uL1VzZXJzL1BoaWxpbmUgU2NoZWxsL0RvY3VtZW50cy9TdHVkaXVtL0hUVy9iZXJsaW5lcmx1ZnQvYmVybGluZXJsdWZ0X2xpZ2h0LmZyYW1lci9tb2R1bGVzL1RleHRMYXllci5jb2ZmZWUiLCIuLi8uLi8uLi8uLi8uLi9Vc2Vycy9QaGlsaW5lIFNjaGVsbC9Eb2N1bWVudHMvU3R1ZGl1bS9IVFcvYmVybGluZXJsdWZ0L2JlcmxpbmVybHVmdF9saWdodC5mcmFtZXIvbW9kdWxlcy9USFJFRS1yNzIuanMiLCIuLi8uLi8uLi8uLi8uLi9Vc2Vycy9QaGlsaW5lIFNjaGVsbC9Eb2N1bWVudHMvU3R1ZGl1bS9IVFcvYmVybGluZXJsdWZ0L2JlcmxpbmVybHVmdF9saWdodC5mcmFtZXIvbW9kdWxlcy9TUEUubWluLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIjIEFkZCB0aGUgZm9sbG93aW5nIGxpbmUgdG8geW91ciBwcm9qZWN0IGluIEZyYW1lciBTdHVkaW8uIFxuIyBteU1vZHVsZSA9IHJlcXVpcmUgXCJteU1vZHVsZVwiXG4jIFJlZmVyZW5jZSB0aGUgY29udGVudHMgYnkgbmFtZSwgbGlrZSBteU1vZHVsZS5teUZ1bmN0aW9uKCkgb3IgbXlNb2R1bGUubXlWYXJcblxuZXhwb3J0cy5teVZhciA9IFwibXlWYXJpYWJsZVwiXG5cbmV4cG9ydHMubXlGdW5jdGlvbiA9IC0+XG5cdHByaW50IFwibXlGdW5jdGlvbiBpcyBydW5uaW5nXCJcblxuZXhwb3J0cy5teUFycmF5ID0gWzEsIDIsIDNdIiwiIyBUT0RPOiBSZW5hbWUgdGhpcyBjbGFzcyBzbyB0aGVyZSBhcmVuJ3QgbmFtZXNwYWNlIGNvbmZsaWN0cy5cbmNsYXNzIFRleHRMYXllciBleHRlbmRzIExheWVyXG5cdFx0XG5cdGNvbnN0cnVjdG9yOiAob3B0aW9ucz17fSkgLT5cblx0XHRAZG9BdXRvU2l6ZSA9IGZhbHNlXG5cdFx0QGRvQXV0b1NpemVIZWlnaHQgPSBmYWxzZVxuXHRcdG9wdGlvbnMuYmFja2dyb3VuZENvbG9yID89IGlmIG9wdGlvbnMuc2V0dXAgdGhlbiBcImhzbGEoNjAsIDkwJSwgNDclLCAuNClcIiBlbHNlIFwidHJhbnNwYXJlbnRcIlxuXHRcdG9wdGlvbnMuY29sb3IgPz0gXCJyZWRcIlxuXHRcdG9wdGlvbnMubGluZUhlaWdodCA/PSAxLjI1XG5cdFx0b3B0aW9ucy5mb250RmFtaWx5ID89IFwiSGVsdmV0aWNhXCJcblx0XHRvcHRpb25zLmZvbnRTaXplID89IDIwXG5cdFx0b3B0aW9ucy50ZXh0ID89IFwiVXNlIGxheWVyLnRleHQgdG8gYWRkIHRleHRcIlxuXHRcdHN1cGVyIG9wdGlvbnNcblx0XHRAc3R5bGUud2hpdGVTcGFjZSA9IFwicHJlLWxpbmVcIiAjIGFsbG93IFxcbiBpbiAudGV4dFxuXHRcdEBzdHlsZS5vdXRsaW5lID0gXCJub25lXCIgIyBubyBib3JkZXIgd2hlbiBzZWxlY3RlZFxuXHRcdFxuXHRzZXRTdHlsZTogKHByb3BlcnR5LCB2YWx1ZSwgcHhTdWZmaXggPSBmYWxzZSkgLT5cblx0XHRAc3R5bGVbcHJvcGVydHldID0gaWYgcHhTdWZmaXggdGhlbiB2YWx1ZStcInB4XCIgZWxzZSB2YWx1ZVxuXHRcdEBlbWl0KFwiY2hhbmdlOiN7cHJvcGVydHl9XCIsIHZhbHVlKVxuXHRcdGlmIEBkb0F1dG9TaXplIHRoZW4gQGNhbGNTaXplKClcblx0XHRcblx0Y2FsY1NpemU6IC0+XG5cdFx0c2l6ZUFmZmVjdGluZ1N0eWxlcyA9XG5cdFx0XHRsaW5lSGVpZ2h0OiBAc3R5bGVbXCJsaW5lLWhlaWdodFwiXVxuXHRcdFx0Zm9udFNpemU6IEBzdHlsZVtcImZvbnQtc2l6ZVwiXVxuXHRcdFx0Zm9udFdlaWdodDogQHN0eWxlW1wiZm9udC13ZWlnaHRcIl1cblx0XHRcdHBhZGRpbmdUb3A6IEBzdHlsZVtcInBhZGRpbmctdG9wXCJdXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IEBzdHlsZVtcInBhZGRpbmctcmlnaHRcIl1cblx0XHRcdHBhZGRpbmdCb3R0b206IEBzdHlsZVtcInBhZGRpbmctYm90dG9tXCJdXG5cdFx0XHRwYWRkaW5nTGVmdDogQHN0eWxlW1wicGFkZGluZy1sZWZ0XCJdXG5cdFx0XHR0ZXh0VHJhbnNmb3JtOiBAc3R5bGVbXCJ0ZXh0LXRyYW5zZm9ybVwiXVxuXHRcdFx0Ym9yZGVyV2lkdGg6IEBzdHlsZVtcImJvcmRlci13aWR0aFwiXVxuXHRcdFx0bGV0dGVyU3BhY2luZzogQHN0eWxlW1wibGV0dGVyLXNwYWNpbmdcIl1cblx0XHRcdGZvbnRGYW1pbHk6IEBzdHlsZVtcImZvbnQtZmFtaWx5XCJdXG5cdFx0XHRmb250U3R5bGU6IEBzdHlsZVtcImZvbnQtc3R5bGVcIl1cblx0XHRcdGZvbnRWYXJpYW50OiBAc3R5bGVbXCJmb250LXZhcmlhbnRcIl1cblx0XHRjb25zdHJhaW50cyA9IHt9XG5cdFx0aWYgQGRvQXV0b1NpemVIZWlnaHQgdGhlbiBjb25zdHJhaW50cy53aWR0aCA9IEB3aWR0aFxuXHRcdHNpemUgPSBVdGlscy50ZXh0U2l6ZSBAdGV4dCwgc2l6ZUFmZmVjdGluZ1N0eWxlcywgY29uc3RyYWludHNcblx0XHRpZiBAc3R5bGUudGV4dEFsaWduIGlzIFwicmlnaHRcIlxuXHRcdFx0QHdpZHRoID0gc2l6ZS53aWR0aFxuXHRcdFx0QHggPSBAeC1Ad2lkdGhcblx0XHRlbHNlXG5cdFx0XHRAd2lkdGggPSBzaXplLndpZHRoXG5cdFx0QGhlaWdodCA9IHNpemUuaGVpZ2h0XG5cblx0QGRlZmluZSBcImF1dG9TaXplXCIsXG5cdFx0Z2V0OiAtPiBAZG9BdXRvU2l6ZVxuXHRcdHNldDogKHZhbHVlKSAtPiBcblx0XHRcdEBkb0F1dG9TaXplID0gdmFsdWVcblx0XHRcdGlmIEBkb0F1dG9TaXplIHRoZW4gQGNhbGNTaXplKClcblx0QGRlZmluZSBcImF1dG9TaXplSGVpZ2h0XCIsXG5cdFx0c2V0OiAodmFsdWUpIC0+IFxuXHRcdFx0QGRvQXV0b1NpemUgPSB2YWx1ZVxuXHRcdFx0QGRvQXV0b1NpemVIZWlnaHQgPSB2YWx1ZVxuXHRcdFx0aWYgQGRvQXV0b1NpemUgdGhlbiBAY2FsY1NpemUoKVxuXHRAZGVmaW5lIFwiY29udGVudEVkaXRhYmxlXCIsXG5cdFx0c2V0OiAoYm9vbGVhbikgLT5cblx0XHRcdEBfZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBib29sZWFuXG5cdFx0XHRAaWdub3JlRXZlbnRzID0gIWJvb2xlYW5cblx0XHRcdEBvbiBcImlucHV0XCIsIC0+IEBjYWxjU2l6ZSgpIGlmIEBkb0F1dG9TaXplXG5cdEBkZWZpbmUgXCJ0ZXh0XCIsXG5cdFx0Z2V0OiAtPiBAX2VsZW1lbnQudGV4dENvbnRlbnRcblx0XHRzZXQ6ICh2YWx1ZSkgLT5cblx0XHRcdEBfZWxlbWVudC50ZXh0Q29udGVudCA9IHZhbHVlXG5cdFx0XHRAZW1pdChcImNoYW5nZTp0ZXh0XCIsIHZhbHVlKVxuXHRcdFx0aWYgQGRvQXV0b1NpemUgdGhlbiBAY2FsY1NpemUoKVxuXHRAZGVmaW5lIFwiZm9udEZhbWlseVwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5mb250RmFtaWx5XG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcImZvbnRGYW1pbHlcIiwgdmFsdWUpXG5cdEBkZWZpbmUgXCJmb250U2l6ZVwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5mb250U2l6ZS5yZXBsYWNlKFwicHhcIixcIlwiKVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJmb250U2l6ZVwiLCB2YWx1ZSwgdHJ1ZSlcblx0QGRlZmluZSBcImxpbmVIZWlnaHRcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUubGluZUhlaWdodCBcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwibGluZUhlaWdodFwiLCB2YWx1ZSlcblx0QGRlZmluZSBcImZvbnRXZWlnaHRcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUuZm9udFdlaWdodCBcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwiZm9udFdlaWdodFwiLCB2YWx1ZSlcblx0QGRlZmluZSBcImZvbnRTdHlsZVwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5mb250U3R5bGVcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwiZm9udFN0eWxlXCIsIHZhbHVlKVxuXHRAZGVmaW5lIFwiZm9udFZhcmlhbnRcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUuZm9udFZhcmlhbnRcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwiZm9udFZhcmlhbnRcIiwgdmFsdWUpXG5cdEBkZWZpbmUgXCJwYWRkaW5nXCIsXG5cdFx0c2V0OiAodmFsdWUpIC0+IFxuXHRcdFx0QHNldFN0eWxlKFwicGFkZGluZ1RvcFwiLCB2YWx1ZSwgdHJ1ZSlcblx0XHRcdEBzZXRTdHlsZShcInBhZGRpbmdSaWdodFwiLCB2YWx1ZSwgdHJ1ZSlcblx0XHRcdEBzZXRTdHlsZShcInBhZGRpbmdCb3R0b21cIiwgdmFsdWUsIHRydWUpXG5cdFx0XHRAc2V0U3R5bGUoXCJwYWRkaW5nTGVmdFwiLCB2YWx1ZSwgdHJ1ZSlcblx0QGRlZmluZSBcInBhZGRpbmdUb3BcIiwgXG5cdFx0Z2V0OiAtPiBAc3R5bGUucGFkZGluZ1RvcC5yZXBsYWNlKFwicHhcIixcIlwiKVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJwYWRkaW5nVG9wXCIsIHZhbHVlLCB0cnVlKVxuXHRAZGVmaW5lIFwicGFkZGluZ1JpZ2h0XCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLnBhZGRpbmdSaWdodC5yZXBsYWNlKFwicHhcIixcIlwiKVxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJwYWRkaW5nUmlnaHRcIiwgdmFsdWUsIHRydWUpXG5cdEBkZWZpbmUgXCJwYWRkaW5nQm90dG9tXCIsIFxuXHRcdGdldDogLT4gQHN0eWxlLnBhZGRpbmdCb3R0b20ucmVwbGFjZShcInB4XCIsXCJcIilcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwicGFkZGluZ0JvdHRvbVwiLCB2YWx1ZSwgdHJ1ZSlcblx0QGRlZmluZSBcInBhZGRpbmdMZWZ0XCIsXG5cdFx0Z2V0OiAtPiBAc3R5bGUucGFkZGluZ0xlZnQucmVwbGFjZShcInB4XCIsXCJcIilcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwicGFkZGluZ0xlZnRcIiwgdmFsdWUsIHRydWUpXG5cdEBkZWZpbmUgXCJ0ZXh0QWxpZ25cIixcblx0XHRzZXQ6ICh2YWx1ZSkgLT4gQHNldFN0eWxlKFwidGV4dEFsaWduXCIsIHZhbHVlKVxuXHRAZGVmaW5lIFwidGV4dFRyYW5zZm9ybVwiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS50ZXh0VHJhbnNmb3JtIFxuXHRcdHNldDogKHZhbHVlKSAtPiBAc2V0U3R5bGUoXCJ0ZXh0VHJhbnNmb3JtXCIsIHZhbHVlKVxuXHRAZGVmaW5lIFwibGV0dGVyU3BhY2luZ1wiLCBcblx0XHRnZXQ6IC0+IEBzdHlsZS5sZXR0ZXJTcGFjaW5nLnJlcGxhY2UoXCJweFwiLFwiXCIpXG5cdFx0c2V0OiAodmFsdWUpIC0+IEBzZXRTdHlsZShcImxldHRlclNwYWNpbmdcIiwgdmFsdWUsIHRydWUpXG5cdEBkZWZpbmUgXCJsZW5ndGhcIiwgXG5cdFx0Z2V0OiAtPiBAdGV4dC5sZW5ndGhcblxuY29udmVydFRvVGV4dExheWVyID0gKGxheWVyLCBkZWJ1ZykgLT5cblxuXHQjIENyZWF0ZSBhIHRleHQgbGF5ZXIgd2l0aCBhbGwgdGhlIGJhc2ljIHByb3BlcnRpZXMuXG5cdHQgPSBuZXcgVGV4dExheWVyXG5cdFx0bmFtZTogbGF5ZXIubmFtZVxuXHRcdGZyYW1lOiBsYXllci5mcmFtZVxuXHRcdHBhcmVudDogbGF5ZXIucGFyZW50XG5cdFx0dGV4dDogbGF5ZXIuX2luZm8ubWV0YWRhdGEuc3RyaW5nXG5cblx0IyBPYmplY3QgZm9yIHN0eWxlIHByb3BzLlxuXHRzdHlsZU9iaiA9IHt9XG5cdFxuXHQjIEdldCBDU1MgZnJvbSBtZXRhZGF0YS5cblx0Y3NzID0gbGF5ZXIuX2luZm8ubWV0YWRhdGEuY3NzXG5cblx0IyBHbyB0aHJvdWdoIGVhY2ggcnVsZVxuXHRjc3MuZm9yRWFjaCAocnVsZSkgLT5cblxuXHRcdCMgRGl0Y2ggdGhlIGR1bWIgbGF5ZXIgbmFtZS5cblx0XHRyZXR1cm4gaWYgXy5pbmNsdWRlcyBydWxlLCAnLyonXG5cdFx0XG5cdFx0IyBTcGxpdCB0aGUga2V5IGFuZCB2YWx1ZSBvdXRcblx0XHRhcnIgPSBydWxlLnNwbGl0KCc6ICcpXG5cdFx0XG5cdFx0I0Zvcm1hdCB0aGUga2V5IGFuZCB2YWx1ZSBwcm9wZXJseVxuXHRcdHByb3AgPSBfLmNhbWVsQ2FzZShhcnJbMF0pXG5cdFx0dmFsdWUgPSBhcnJbMV0ucmVwbGFjZSgnOycsJycpXG5cdFx0XG5cdFx0I0NvbnZlcnQgdG8gbnVtYmVycyBmb3IgbnVtZXJpYyBwcm9wZXJ0aWVzXG5cdFx0aWYgW1wiZm9udFNpemVcIixcImxldHRlclNwYWNpbmdcIixcImxpbmVIZWlnaHRcIl0uaW5kZXhPZihwcm9wKSA+IC0xXG5cdFx0XHR2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKSBcblxuXHRcdCMgU2V0IHRoZSBrZXkgYW5kIHZhbHVlIGluIHN0eWxlT2JqXG5cdFx0c3R5bGVPYmpbcHJvcF0gPSB2YWx1ZVxuXHRcdFxuXHQjIFNldCB0aGUgbGluZS1oZWlnaHQgYXMgYSBwcm9wb3J0aW9uIGluc3RlYWQgb2YgcGl4ZWwgdmFsdWUuXG5cdGlmIHN0eWxlT2JqLmhhc093blByb3BlcnR5KFwibGluZUhlaWdodFwiKVxuXHRcdHN0eWxlT2JqW1wibGluZUhlaWdodFwiXSA9ICBzdHlsZU9iai5saW5lSGVpZ2h0IC8gc3R5bGVPYmouZm9udFNpemVcblx0ZWxzZVxuXHRcdHN0eWxlT2JqW1wibGluZUhlaWdodFwiXSA9IDEuM1xuIFx0XHQjIFRPRE86IEZpbmQgYSB3YXkgdG8gcHJvcGVybHkgc2V0IHRleHQgbGluZS1oZWlnaHQgZm9yIGF1dG8gdmFsdWVzIGluIFNrZXRjaC5cbiBcdFx0IyBDdXJyZW50bHkgYXV0byBsaW5lLWhlaWdodHMgdmFyeSBieSBmb250LCBzbyB0aGlzIGlzIGp1c3Qgc2V0dGluZyBhIGZhbGxiYWNrIGFyYml0cmFyaWx5LlxuXHRcblx0XG5cdCMgU2V0IHRoZSBwcm9wZXJ0aWVzIGZvciBldmVyeSBrZXkgaW4gc3R5bGVPYmpcblx0Zm9yIGtleSwgdmFsIG9mIHN0eWxlT2JqXG5cdFx0dFtrZXldID0gdmFsXG5cblx0IyBPZmZzZXRzIHRvIGNvbXBlbnNhdGUgZm9yIFNrZXRjaCdzIHBhZGRpbmcuXG5cdHQueSAtPSAodC5mb250U2l6ZSAvIHQubGluZUhlaWdodCkgLyAoNCAtIHQubGluZUhlaWdodClcblx0dC54IC09IHQuZm9udFNpemUgKiAwLjA3XG5cdHQud2lkdGggKz0gdC5mb250U2l6ZSAqIDAuNVxuXG5cdCMgU2V0IHVwIGRlYnVnOiBpZiB0cnVlLCBpdCBkb2Vzbid0IGRlc3Ryb3kgdGhlIGxheWVyIHNvIHlvdSBjYW5cblx0IyBtYW51YWxseSBwb3NpdGlvbiBsaW5lLWhlaWdodCBhbmQgc3R1ZmYuICBIZWxwZnVsLlxuXHRpZiBkZWJ1ZyB0aGVuIGxheWVyLm9wYWNpdHkgPSAuNSBlbHNlIGxheWVyLmRlc3Ryb3koKVxuXHRcblx0cmV0dXJuIHRcblxuTGF5ZXI6OmNvbnZlcnRUb1RleHRMYXllciA9IChkZWJ1ZykgLT4gY29udmVydFRvVGV4dExheWVyKEAsIGRlYnVnKVxuXG5jb252ZXJ0VGV4dExheWVycyA9IChvYmosIGRlYnVnKSAtPlxuXHRmb3IgcHJvcCxsYXllciBvZiBvYmpcblx0XHRpZiBsYXllci5faW5mby5raW5kIGlzIFwidGV4dFwiXG5cdFx0XHRvYmpbcHJvcF0gPSBjb252ZXJ0VG9UZXh0TGF5ZXIobGF5ZXIsIGRlYnVnKVxuXG5cbiMgQmFja3dhcmRzIGNvbXBhYmlsaXR5LiBSZXBsYWNlZCBieSBjb252ZXJ0VG9UZXh0TGF5ZXIoKVxuTGF5ZXI6OmZyYW1lQXNUZXh0TGF5ZXIgPSAocHJvcGVydGllcykgLT5cbiAgICB0ID0gbmV3IFRleHRMYXllclxuICAgIHQuZnJhbWUgPSBAZnJhbWVcbiAgICB0LnN1cGVyTGF5ZXIgPSBAc3VwZXJMYXllclxuICAgIF8uZXh0ZW5kIHQscHJvcGVydGllc1xuICAgIEBkZXN0cm95KClcbiAgICB0XG5cbmV4cG9ydHMuVGV4dExheWVyID0gVGV4dExheWVyXG5leHBvcnRzLmNvbnZlcnRUZXh0TGF5ZXJzID0gY29udmVydFRleHRMYXllcnNcbiIsIi8vIEZpbGU6c3JjL1RocmVlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG52YXIgVEhSRUUgPSB7XG4gICAgUkVWSVNJT046ICc3Midcbn07XG5cbi8vXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXG4gICAgZGVmaW5lKCAndGhyZWUnLCBUSFJFRSApO1xuXG59XG5lbHNlIGlmICggJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBleHBvcnRzICYmICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlICkge1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcblxufVxuXG5cbi8vIHBvbHlmaWxsc1xuXG5pZiAoIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgfHwgc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgLy8gTWlzc2luZyBpbiBBbmRyb2lkIHN0b2NrIGJyb3dzZXIuXG5cbiAgICAoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgICAgIHZhciB2ZW5kb3JzID0gWyAnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJyBdO1xuXG4gICAgICAgIGZvciAoIHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4ICkge1xuXG4gICAgICAgICAgICBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHNlbGZbIHZlbmRvcnNbIHggXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XG4gICAgICAgICAgICBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gc2VsZlsgdmVuZG9yc1sgeCBdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJyBdIHx8IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCAmJiBzZWxmLnNldFRpbWVvdXQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoIDAsIDE2IC0gKCBjdXJyVGltZSAtIGxhc3RUaW1lICkgKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBzZWxmLnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBjdXJyVGltZSArIHRpbWVUb0NhbGwgKTtcblxuICAgICAgICAgICAgICAgIH0sIHRpbWVUb0NhbGwgKTtcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuY2xlYXJUaW1lb3V0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggaWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCggaWQgKTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICB9KCkgKTtcblxufVxuXG5pZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXG5cbiAgICBNYXRoLnNpZ24gPSBmdW5jdGlvbiggeCApIHtcblxuICAgICAgICByZXR1cm4gKCB4IDwgMCApID8gLTEgOiAoIHggPiAwICkgPyAxIDogK3g7XG5cbiAgICB9O1xuXG59XG5cbmlmICggRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIC8vIE1pc3NpbmcgaW4gSUU5LTExLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLm1hdGNoKCAvXlxccypmdW5jdGlvblxccyooXFxTKilcXHMqXFwoLyApWyAxIF07XG5cbiAgICAgICAgfVxuXG4gICAgfSApO1xuXG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50LmJ1dHRvblxuXG5USFJFRS5NT1VTRSA9IHtcbiAgICBMRUZUOiAwLFxuICAgIE1JRERMRTogMSxcbiAgICBSSUdIVDogMlxufTtcblxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXG5cblRIUkVFLkN1bGxGYWNlTm9uZSA9IDA7XG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XG5USFJFRS5DdWxsRmFjZUZyb250QmFjayA9IDM7XG5cblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5cbi8vIFNIQURPV0lORyBUWVBFU1xuXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xuVEhSRUUuUENGU29mdFNoYWRvd01hcCA9IDI7XG5cbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xuXG4vLyBzaWRlXG5cblRIUkVFLkZyb250U2lkZSA9IDA7XG5USFJFRS5CYWNrU2lkZSA9IDE7XG5USFJFRS5Eb3VibGVTaWRlID0gMjtcblxuLy8gc2hhZGluZ1xuXG5USFJFRS5GbGF0U2hhZGluZyA9IDE7XG5USFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcblxuLy8gY29sb3JzXG5cblRIUkVFLk5vQ29sb3JzID0gMDtcblRIUkVFLkZhY2VDb2xvcnMgPSAxO1xuVEhSRUUuVmVydGV4Q29sb3JzID0gMjtcblxuLy8gYmxlbmRpbmcgbW9kZXNcblxuVEhSRUUuTm9CbGVuZGluZyA9IDA7XG5USFJFRS5Ob3JtYWxCbGVuZGluZyA9IDE7XG5USFJFRS5BZGRpdGl2ZUJsZW5kaW5nID0gMjtcblRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuVEhSRUUuTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG5USFJFRS5DdXN0b21CbGVuZGluZyA9IDU7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBlcXVhdGlvbnNcbi8vIChudW1iZXJzIHN0YXJ0IGZyb20gMTAwIG5vdCB0byBjbGFzaCB3aXRoIG90aGVyXG4vLyBtYXBwaW5ncyB0byBPcGVuR0wgY29uc3RhbnRzIGRlZmluZWQgaW4gVGV4dHVyZS5qcylcblxuVEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XG5USFJFRS5TdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xuVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XG5USFJFRS5NaW5FcXVhdGlvbiA9IDEwMztcblRIUkVFLk1heEVxdWF0aW9uID0gMTA0O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xuXG5USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xuVEhSRUUuU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG5USFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG5USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgc291cmNlIGZhY3RvcnNcblxuLy9USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuLy9USFJFRS5PbmVGYWN0b3IgPSAyMDE7XG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xuLy9USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuLy9USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcblRIUkVFLkRzdENvbG9yRmFjdG9yID0gMjA4O1xuVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5cbi8vIGRlcHRoIG1vZGVzXG5cblRIUkVFLk5ldmVyRGVwdGggPSAwO1xuVEhSRUUuQWx3YXlzRGVwdGggPSAxO1xuVEhSRUUuTGVzc0RlcHRoID0gMjtcblRIUkVFLkxlc3NFcXVhbERlcHRoID0gMztcblRIUkVFLkVxdWFsRGVwdGggPSA0O1xuVEhSRUUuR3JlYXRlckVxdWFsRGVwdGggPSA1O1xuVEhSRUUuR3JlYXRlckRlcHRoID0gNjtcblRIUkVFLk5vdEVxdWFsRGVwdGggPSA3O1xuXG5cbi8vIFRFWFRVUkUgQ09OU1RBTlRTXG5cblRIUkVFLk11bHRpcGx5T3BlcmF0aW9uID0gMDtcblRIUkVFLk1peE9wZXJhdGlvbiA9IDE7XG5USFJFRS5BZGRPcGVyYXRpb24gPSAyO1xuXG4vLyBNYXBwaW5nIG1vZGVzXG5cblRIUkVFLlVWTWFwcGluZyA9IDMwMDtcblxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xuVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuXG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcblRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuXG5USFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcblxuLy8gV3JhcHBpbmcgbW9kZXNcblxuVEhSRUUuUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcblxuLy8gRmlsdGVyc1xuXG5USFJFRS5OZWFyZXN0RmlsdGVyID0gMTAwMztcblRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuVEhSRUUuTGluZWFyRmlsdGVyID0gMTAwNjtcblRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcblxuLy8gRGF0YSB0eXBlc1xuXG5USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblRIUkVFLkJ5dGVUeXBlID0gMTAxMDtcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XG5USFJFRS5VbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG5USFJFRS5JbnRUeXBlID0gMTAxMztcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XG5USFJFRS5GbG9hdFR5cGUgPSAxMDE1O1xuVEhSRUUuSGFsZkZsb2F0VHlwZSA9IDEwMjU7XG5cbi8vIFBpeGVsIHR5cGVzXG5cbi8vVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5USFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE2O1xuVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxNztcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxODtcblxuLy8gUGl4ZWwgZm9ybWF0c1xuXG5USFJFRS5BbHBoYUZvcm1hdCA9IDEwMTk7XG5USFJFRS5SR0JGb3JtYXQgPSAxMDIwO1xuVEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XG5USFJFRS5MdW1pbmFuY2VGb3JtYXQgPSAxMDIyO1xuVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDIzO1xuLy8gVEhSRUUuUkdCRUZvcm1hdCBoYW5kbGVkIGFzIFRIUkVFLlJHQkFGb3JtYXQgaW4gc2hhZGVyc1xuVEhSRUUuUkdCRUZvcm1hdCA9IFRIUkVFLlJHQkFGb3JtYXQ7IC8vMTAyNDtcblxuLy8gRERTIC8gU1QzQyBDb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xuXG5USFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XG5USFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMjAwMztcblRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XG5cblxuLy8gUFZSVEMgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAwO1xuVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xuVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcblRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDM7XG5cblxuLy8gREVQUkVDQVRFRFxuXG5USFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbigpIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3IgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9Qcm9qZWN0b3IuanMuJyApO1xuXG4gICAgdGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24oIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG4gICAgICAgIHZlY3Rvci5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLicgKTtcbiAgICAgICAgdmVjdG9yLnVucHJvamVjdCggY2FtZXJhICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24oIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xuXG4gICAgfTtcblxufTtcblxuVEhSRUUuQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL0NhbnZhc1JlbmRlcmVyLmpzJyApO1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbigpIHt9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0NvbG9yLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXRSR0IoIGFyZ3VtZW50c1sgMCBdLCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldCggY29sb3IgKTtcblxufTtcblxuVEhSRUUuQ29sb3IucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkNvbG9yLFxuXG4gICAgcjogMSxcbiAgICBnOiAxLFxuICAgIGI6IDEsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY29weSggdmFsdWUgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xuXG4gICAgICAgICAgICB0aGlzLnNldEhleCggdmFsdWUgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xuXG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRIZXg6IGZ1bmN0aW9uKCBoZXggKSB7XG5cbiAgICAgICAgaGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XG5cbiAgICAgICAgdGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcbiAgICAgICAgdGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xuICAgICAgICB0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFJHQjogZnVuY3Rpb24oIHIsIGcsIGIgKSB7XG5cbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgdGhpcy5iID0gYjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRIU0w6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIHQgKSB7XG5cbiAgICAgICAgICAgIGlmICggdCA8IDAgKSB0ICs9IDE7XG4gICAgICAgICAgICBpZiAoIHQgPiAxICkgdCAtPSAxO1xuICAgICAgICAgICAgaWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xuICAgICAgICAgICAgaWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcbiAgICAgICAgICAgIGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGgsIHMsIGwgKSB7XG5cbiAgICAgICAgICAgIC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG4gICAgICAgICAgICBoID0gVEhSRUUuTWF0aC5ldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcbiAgICAgICAgICAgIHMgPSBUSFJFRS5NYXRoLmNsYW1wKCBzLCAwLCAxICk7XG4gICAgICAgICAgICBsID0gVEhSRUUuTWF0aC5jbGFtcCggbCwgMCwgMSApO1xuXG4gICAgICAgICAgICBpZiAoIHMgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBwID0gbCA8PSAwLjUgPyBsICogKCAxICsgcyApIDogbCArIHMgLSAoIGwgKiBzICk7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSAoIDIgKiBsICkgLSBwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xuICAgICAgICAgICAgICAgIHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oIHN0eWxlICkge1xuXG4gICAgICAgIHZhciBwYXJzZUFscGhhID0gZnVuY3Rpb24oIHN0ckFscGhhICkge1xuXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KCBzdHJBbHBoYSApO1xuXG4gICAgICAgICAgICBpZiAoIGFscGhhIDwgMSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgY29sb3IgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbHBoYTtcblxuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgbTtcblxuICAgICAgICBpZiAoIG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKFxccyooW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XG5cbiAgICAgICAgICAgIC8vIHJnYiAvIGhzbFxuXG4gICAgICAgICAgICB2YXIgY29sb3I7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG1bIDEgXTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gbVsgMiBdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBuYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiJzpcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZ2IoMjU1LDAsMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29sb3IgPSAvXihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJnYigxMDAlLDAlLDAlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2JhJzpcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZ2JhKDI1NSwwLDAsMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VBbHBoYSggY29sb3JbIDQgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmdiYSgxMDAlLDAlLDAlLDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQWxwaGEoIGNvbG9yWyA0IF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsJzpcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoc2woMTIwLDUwJSw1MCUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApIC8gMTAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gcGFyc2VGbG9hdCggY29sb3JbIDEgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUFscGhhKCBjb2xvclsgNCBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEhTTCggaCwgcywgbCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcblxuICAgICAgICAgICAgLy8gaGV4IGNvbG9yXG5cbiAgICAgICAgICAgIHZhciBoZXggPSBtWyAxIF07XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGhleC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICggc2l6ZSA9PT0gMyApIHtcblxuICAgICAgICAgICAgICAgIC8vICNmZjBcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMCApLCAxNiApIC8gMjU1O1xuICAgICAgICAgICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAxICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDIgKSwgMTYgKSAvIDI1NTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcblxuICAgICAgICAgICAgICAgIC8vICNmZjAwMDBcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xuICAgICAgICAgICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XG4gICAgICAgICAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDQgKSArIGhleC5jaGFyQXQoIDUgKSwgMTYgKSAvIDI1NTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc3R5bGUgJiYgc3R5bGUubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgLy8gY29sb3Iga2V5d29yZHNcbiAgICAgICAgICAgIHZhciBoZXggPSBUSFJFRS5Db2xvcktleXdvcmRzWyBzdHlsZSBdO1xuXG4gICAgICAgICAgICBpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gcmVkXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIZXgoIGhleCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHVua25vd24gY29sb3JcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIGNvbG9yICkge1xuXG4gICAgICAgIHRoaXMuciA9IGNvbG9yLnI7XG4gICAgICAgIHRoaXMuZyA9IGNvbG9yLmc7XG4gICAgICAgIHRoaXMuYiA9IGNvbG9yLmI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XG5cbiAgICAgICAgaWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cbiAgICAgICAgdGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIGdhbW1hRmFjdG9yICk7XG4gICAgICAgIHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBnYW1tYUZhY3RvciApO1xuICAgICAgICB0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24oIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuICAgICAgICBpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcblxuICAgICAgICB2YXIgc2FmZUludmVyc2UgPSAoIGdhbW1hRmFjdG9yID4gMCApID8gKCAxLjAgLyBnYW1tYUZhY3RvciApIDogMS4wO1xuXG4gICAgICAgIHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xuICAgICAgICB0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcbiAgICAgICAgdGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIHNhZmVJbnZlcnNlICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29udmVydEdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciByID0gdGhpcy5yLFxuICAgICAgICAgICAgZyA9IHRoaXMuZyxcbiAgICAgICAgICAgIGIgPSB0aGlzLmI7XG5cbiAgICAgICAgdGhpcy5yID0gciAqIHI7XG4gICAgICAgIHRoaXMuZyA9IGcgKiBnO1xuICAgICAgICB0aGlzLmIgPSBiICogYjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5yID0gTWF0aC5zcXJ0KCB0aGlzLnIgKTtcbiAgICAgICAgdGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcbiAgICAgICAgdGhpcy5iID0gTWF0aC5zcXJ0KCB0aGlzLmIgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRIZXg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xuXG4gICAgfSxcblxuICAgIGdldEhleFN0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC02ICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0SFNMOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgLy8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcblxuICAgICAgICB2YXIgaHNsID0gb3B0aW9uYWxUYXJnZXQgfHwge1xuICAgICAgICAgICAgaDogMCxcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICBsOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLnIsXG4gICAgICAgICAgICBnID0gdGhpcy5nLFxuICAgICAgICAgICAgYiA9IHRoaXMuYjtcblxuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XG5cbiAgICAgICAgdmFyIGh1ZSwgc2F0dXJhdGlvbjtcbiAgICAgICAgdmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XG5cbiAgICAgICAgaWYgKCBtaW4gPT09IG1heCApIHtcblxuICAgICAgICAgICAgaHVlID0gMDtcbiAgICAgICAgICAgIHNhdHVyYXRpb24gPSAwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblxuICAgICAgICAgICAgc2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvICggbWF4ICsgbWluICkgOiBkZWx0YSAvICggMiAtIG1heCAtIG1pbiApO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBtYXggKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICAgICAgICAgIGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgICAgICAgICAgaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgICAgICAgICAgIGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaHVlIC89IDY7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGhzbC5oID0gaHVlO1xuICAgICAgICBoc2wucyA9IHNhdHVyYXRpb247XG4gICAgICAgIGhzbC5sID0gbGlnaHRuZXNzO1xuXG4gICAgICAgIHJldHVybiBoc2w7XG5cbiAgICB9LFxuXG4gICAgZ2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XG5cbiAgICB9LFxuXG4gICAgb2Zmc2V0SFNMOiBmdW5jdGlvbiggaCwgcywgbCApIHtcblxuICAgICAgICB2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcblxuICAgICAgICBoc2wuaCArPSBoO1xuICAgICAgICBoc2wucyArPSBzO1xuICAgICAgICBoc2wubCArPSBsO1xuXG4gICAgICAgIHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICAgICAgdGhpcy5yICs9IGNvbG9yLnI7XG4gICAgICAgIHRoaXMuZyArPSBjb2xvci5nO1xuICAgICAgICB0aGlzLmIgKz0gY29sb3IuYjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRDb2xvcnM6IGZ1bmN0aW9uKCBjb2xvcjEsIGNvbG9yMiApIHtcblxuICAgICAgICB0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuICAgICAgICB0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuICAgICAgICB0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy5yICs9IHM7XG4gICAgICAgIHRoaXMuZyArPSBzO1xuICAgICAgICB0aGlzLmIgKz0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oIGNvbG9yICkge1xuXG4gICAgICAgIHRoaXMuciAqPSBjb2xvci5yO1xuICAgICAgICB0aGlzLmcgKj0gY29sb3IuZztcbiAgICAgICAgdGhpcy5iICo9IGNvbG9yLmI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMuciAqPSBzO1xuICAgICAgICB0aGlzLmcgKj0gcztcbiAgICAgICAgdGhpcy5iICo9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVycDogZnVuY3Rpb24oIGNvbG9yLCBhbHBoYSApIHtcblxuICAgICAgICB0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XG4gICAgICAgIHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIGMgKSB7XG5cbiAgICAgICAgcmV0dXJuICggYy5yID09PSB0aGlzLnIgKSAmJiAoIGMuZyA9PT0gdGhpcy5nICkgJiYgKCBjLmIgPT09IHRoaXMuYiApO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5ICkge1xuXG4gICAgICAgIHRoaXMuciA9IGFycmF5WyAwIF07XG4gICAgICAgIHRoaXMuZyA9IGFycmF5WyAxIF07XG4gICAgICAgIHRoaXMuYiA9IGFycmF5WyAyIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5nO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuQ29sb3JLZXl3b3JkcyA9IHtcbiAgICAnYWxpY2VibHVlJzogMHhGMEY4RkYsXG4gICAgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LFxuICAgICdhcXVhJzogMHgwMEZGRkYsXG4gICAgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCxcbiAgICAnYXp1cmUnOiAweEYwRkZGRixcbiAgICAnYmVpZ2UnOiAweEY1RjVEQyxcbiAgICAnYmlzcXVlJzogMHhGRkU0QzQsXG4gICAgJ2JsYWNrJzogMHgwMDAwMDAsXG4gICAgJ2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsXG4gICAgJ2JsdWUnOiAweDAwMDBGRixcbiAgICAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuICAgICdicm93bic6IDB4QTUyQTJBLFxuICAgICdidXJseXdvb2QnOiAweERFQjg4NyxcbiAgICAnY2FkZXRibHVlJzogMHg1RjlFQTAsXG4gICAgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCxcbiAgICAnY2hvY29sYXRlJzogMHhEMjY5MUUsXG4gICAgJ2NvcmFsJzogMHhGRjdGNTAsXG4gICAgJ2Nvcm5mbG93ZXJibHVlJzogMHg2NDk1RUQsXG4gICAgJ2Nvcm5zaWxrJzogMHhGRkY4REMsXG4gICAgJ2NyaW1zb24nOiAweERDMTQzQyxcbiAgICAnY3lhbic6IDB4MDBGRkZGLFxuICAgICdkYXJrYmx1ZSc6IDB4MDAwMDhCLFxuICAgICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuICAgICdkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsXG4gICAgJ2RhcmtncmF5JzogMHhBOUE5QTksXG4gICAgJ2RhcmtncmVlbic6IDB4MDA2NDAwLFxuICAgICdkYXJrZ3JleSc6IDB4QTlBOUE5LFxuICAgICdkYXJra2hha2knOiAweEJEQjc2QixcbiAgICAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcbiAgICAnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRixcbiAgICAnZGFya29yYW5nZSc6IDB4RkY4QzAwLFxuICAgICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsXG4gICAgJ2RhcmtyZWQnOiAweDhCMDAwMCxcbiAgICAnZGFya3NhbG1vbic6IDB4RTk5NjdBLFxuICAgICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcbiAgICAnZGFya3NsYXRlYmx1ZSc6IDB4NDgzRDhCLFxuICAgICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsXG4gICAgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RixcbiAgICAnZGFya3R1cnF1b2lzZSc6IDB4MDBDRUQxLFxuICAgICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG4gICAgJ2RlZXBwaW5rJzogMHhGRjE0OTMsXG4gICAgJ2RlZXBza3libHVlJzogMHgwMEJGRkYsXG4gICAgJ2RpbWdyYXknOiAweDY5Njk2OSxcbiAgICAnZGltZ3JleSc6IDB4Njk2OTY5LFxuICAgICdkb2RnZXJibHVlJzogMHgxRTkwRkYsXG4gICAgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuICAgICdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLFxuICAgICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLFxuICAgICdmdWNoc2lhJzogMHhGRjAwRkYsXG4gICAgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLFxuICAgICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsXG4gICAgJ2dvbGQnOiAweEZGRDcwMCxcbiAgICAnZ29sZGVucm9kJzogMHhEQUE1MjAsXG4gICAgJ2dyYXknOiAweDgwODA4MCxcbiAgICAnZ3JlZW4nOiAweDAwODAwMCxcbiAgICAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRixcbiAgICAnZ3JleSc6IDB4ODA4MDgwLFxuICAgICdob25leWRldyc6IDB4RjBGRkYwLFxuICAgICdob3RwaW5rJzogMHhGRjY5QjQsXG4gICAgJ2luZGlhbnJlZCc6IDB4Q0Q1QzVDLFxuICAgICdpbmRpZ28nOiAweDRCMDA4MixcbiAgICAnaXZvcnknOiAweEZGRkZGMCxcbiAgICAna2hha2knOiAweEYwRTY4QyxcbiAgICAnbGF2ZW5kZXInOiAweEU2RTZGQSxcbiAgICAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LFxuICAgICdsYXduZ3JlZW4nOiAweDdDRkMwMCxcbiAgICAnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsXG4gICAgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LFxuICAgICdsaWdodGNvcmFsJzogMHhGMDgwODAsXG4gICAgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLFxuICAgICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLFxuICAgICdsaWdodGdyYXknOiAweEQzRDNEMyxcbiAgICAnbGlnaHRncmVlbic6IDB4OTBFRTkwLFxuICAgICdsaWdodGdyZXknOiAweEQzRDNEMyxcbiAgICAnbGlnaHRwaW5rJzogMHhGRkI2QzEsXG4gICAgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsXG4gICAgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSxcbiAgICAnbGlnaHRza3libHVlJzogMHg4N0NFRkEsXG4gICAgJ2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksXG4gICAgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksXG4gICAgJ2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsXG4gICAgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsXG4gICAgJ2xpbWUnOiAweDAwRkYwMCxcbiAgICAnbGltZWdyZWVuJzogMHgzMkNEMzIsXG4gICAgJ2xpbmVuJzogMHhGQUYwRTYsXG4gICAgJ21hZ2VudGEnOiAweEZGMDBGRixcbiAgICAnbWFyb29uJzogMHg4MDAwMDAsXG4gICAgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSxcbiAgICAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELFxuICAgICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcbiAgICAnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsXG4gICAgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsXG4gICAgJ21lZGl1bXNsYXRlYmx1ZSc6IDB4N0I2OEVFLFxuICAgICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLFxuICAgICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcbiAgICAnbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsXG4gICAgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLFxuICAgICdtaW50Y3JlYW0nOiAweEY1RkZGQSxcbiAgICAnbWlzdHlyb3NlJzogMHhGRkU0RTEsXG4gICAgJ21vY2Nhc2luJzogMHhGRkU0QjUsXG4gICAgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG4gICAgJ25hdnknOiAweDAwMDA4MCxcbiAgICAnb2xkbGFjZSc6IDB4RkRGNUU2LFxuICAgICdvbGl2ZSc6IDB4ODA4MDAwLFxuICAgICdvbGl2ZWRyYWInOiAweDZCOEUyMyxcbiAgICAnb3JhbmdlJzogMHhGRkE1MDAsXG4gICAgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLFxuICAgICdvcmNoaWQnOiAweERBNzBENixcbiAgICAncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLFxuICAgICdwYWxlZ3JlZW4nOiAweDk4RkI5OCxcbiAgICAncGFsZXR1cnF1b2lzZSc6IDB4QUZFRUVFLFxuICAgICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsXG4gICAgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSxcbiAgICAncGVhY2hwdWZmJzogMHhGRkRBQjksXG4gICAgJ3BlcnUnOiAweENEODUzRixcbiAgICAncGluayc6IDB4RkZDMENCLFxuICAgICdwbHVtJzogMHhEREEwREQsXG4gICAgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNixcbiAgICAncHVycGxlJzogMHg4MDAwODAsXG4gICAgJ3JlZCc6IDB4RkYwMDAwLFxuICAgICdyb3N5YnJvd24nOiAweEJDOEY4RixcbiAgICAncm95YWxibHVlJzogMHg0MTY5RTEsXG4gICAgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsXG4gICAgJ3NhbG1vbic6IDB4RkE4MDcyLFxuICAgICdzYW5keWJyb3duJzogMHhGNEE0NjAsXG4gICAgJ3NlYWdyZWVuJzogMHgyRThCNTcsXG4gICAgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXG4gICAgJ3NpZW5uYSc6IDB4QTA1MjJELFxuICAgICdzaWx2ZXInOiAweEMwQzBDMCxcbiAgICAnc2t5Ymx1ZSc6IDB4ODdDRUVCLFxuICAgICdzbGF0ZWJsdWUnOiAweDZBNUFDRCxcbiAgICAnc2xhdGVncmF5JzogMHg3MDgwOTAsXG4gICAgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLFxuICAgICdzbm93JzogMHhGRkZBRkEsXG4gICAgJ3NwcmluZ2dyZWVuJzogMHgwMEZGN0YsXG4gICAgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LFxuICAgICd0YW4nOiAweEQyQjQ4QyxcbiAgICAndGVhbCc6IDB4MDA4MDgwLFxuICAgICd0aGlzdGxlJzogMHhEOEJGRDgsXG4gICAgJ3RvbWF0byc6IDB4RkY2MzQ3LFxuICAgICd0dXJxdW9pc2UnOiAweDQwRTBEMCxcbiAgICAndmlvbGV0JzogMHhFRTgyRUUsXG4gICAgJ3doZWF0JzogMHhGNURFQjMsXG4gICAgJ3doaXRlJzogMHhGRkZGRkYsXG4gICAgJ3doaXRlc21va2UnOiAweEY1RjVGNSxcbiAgICAneWVsbG93JzogMHhGRkZGMDAsXG4gICAgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzJcbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUXVhdGVybmlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5RdWF0ZXJuaW9uID0gZnVuY3Rpb24oIHgsIHksIHosIHcgKSB7XG5cbiAgICB0aGlzLl94ID0geCB8fCAwO1xuICAgIHRoaXMuX3kgPSB5IHx8IDA7XG4gICAgdGhpcy5feiA9IHogfHwgMDtcbiAgICB0aGlzLl93ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG59O1xuXG5USFJFRS5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxuXG4gICAgZ2V0IHgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG5cbiAgICB9LFxuXG4gICAgc2V0IHgoIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgZ2V0IHkoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG5cbiAgICB9LFxuXG4gICAgc2V0IHkoIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgZ2V0IHooKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XG5cbiAgICB9LFxuXG4gICAgc2V0IHooIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX3ogPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgZ2V0IHcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG5cbiAgICB9LFxuXG4gICAgc2V0IHcoIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuX3cgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiggeCwgeSwgeiwgdyApIHtcblxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHRoaXMuX3ogPSB6O1xuICAgICAgICB0aGlzLl93ID0gdztcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHF1YXRlcm5pb24gKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IHF1YXRlcm5pb24ueDtcbiAgICAgICAgdGhpcy5feSA9IHF1YXRlcm5pb24ueTtcbiAgICAgICAgdGhpcy5feiA9IHF1YXRlcm5pb24uejtcbiAgICAgICAgdGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uKCBldWxlciwgdXBkYXRlICkge1xuXG4gICAgICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG4gICAgICAgIC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXG4gICAgICAgIC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuICAgICAgICB2YXIgYzEgPSBNYXRoLmNvcyggZXVsZXIuX3ggLyAyICk7XG4gICAgICAgIHZhciBjMiA9IE1hdGguY29zKCBldWxlci5feSAvIDIgKTtcbiAgICAgICAgdmFyIGMzID0gTWF0aC5jb3MoIGV1bGVyLl96IC8gMiApO1xuICAgICAgICB2YXIgczEgPSBNYXRoLnNpbiggZXVsZXIuX3ggLyAyICk7XG4gICAgICAgIHZhciBzMiA9IE1hdGguc2luKCBldWxlci5feSAvIDIgKTtcbiAgICAgICAgdmFyIHMzID0gTWF0aC5zaW4oIGV1bGVyLl96IC8gMiApO1xuXG4gICAgICAgIHZhciBvcmRlciA9IGV1bGVyLm9yZGVyO1xuXG4gICAgICAgIGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uKCBheGlzLCBhbmdsZSApIHtcblxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cbiAgICAgICAgLy8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuICAgICAgICB2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuICAgICAgICB0aGlzLl94ID0gYXhpcy54ICogcztcbiAgICAgICAgdGhpcy5feSA9IGF4aXMueSAqIHM7XG4gICAgICAgIHRoaXMuX3ogPSBheGlzLnogKiBzO1xuICAgICAgICB0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgICAgIHZhciB0ZSA9IG0uZWxlbWVudHMsXG5cbiAgICAgICAgICAgIG0xMSA9IHRlWyAwIF0sXG4gICAgICAgICAgICBtMTIgPSB0ZVsgNCBdLFxuICAgICAgICAgICAgbTEzID0gdGVbIDggXSxcbiAgICAgICAgICAgIG0yMSA9IHRlWyAxIF0sXG4gICAgICAgICAgICBtMjIgPSB0ZVsgNSBdLFxuICAgICAgICAgICAgbTIzID0gdGVbIDkgXSxcbiAgICAgICAgICAgIG0zMSA9IHRlWyAyIF0sXG4gICAgICAgICAgICBtMzIgPSB0ZVsgNiBdLFxuICAgICAgICAgICAgbTMzID0gdGVbIDEwIF0sXG5cbiAgICAgICAgICAgIHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuICAgICAgICAgICAgcztcblxuICAgICAgICBpZiAoIHRyYWNlID4gMCApIHtcblxuICAgICAgICAgICAgcyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcblxuICAgICAgICAgICAgdGhpcy5fdyA9IDAuMjUgLyBzO1xuICAgICAgICAgICAgdGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xuICAgICAgICAgICAgdGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xuICAgICAgICAgICAgdGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG4gICAgICAgICAgICB0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG4gICAgICAgICAgICB0aGlzLl94ID0gMC4yNSAqIHM7XG4gICAgICAgICAgICB0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG4gICAgICAgICAgICB0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG4gICAgICAgICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuICAgICAgICAgICAgdGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuICAgICAgICAgICAgdGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuICAgICAgICAgICAgdGhpcy5feSA9IDAuMjUgKiBzO1xuICAgICAgICAgICAgdGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xuXG4gICAgICAgICAgICB0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG4gICAgICAgICAgICB0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG4gICAgICAgICAgICB0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG4gICAgICAgICAgICB0aGlzLl96ID0gMC4yNSAqIHM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gaHR0cDovL2xvbGVuZ2luZS5uZXQvYmxvZy8yMDE0LzAyLzI0L3F1YXRlcm5pb24tZnJvbS10d28tdmVjdG9ycy1maW5hbFxuXG4gICAgICAgIC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG4gICAgICAgIHZhciB2MSwgcjtcblxuICAgICAgICB2YXIgRVBTID0gMC4wMDAwMDE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2RnJvbSwgdlRvICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuICAgICAgICAgICAgaWYgKCByIDwgRVBTICkge1xuXG4gICAgICAgICAgICAgICAgciA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHYxLnNldCggLXZGcm9tLnksIHZGcm9tLngsIDAgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB2MS5zZXQoIDAsIC12RnJvbS56LCB2RnJvbS55ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdjEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5feCA9IHYxLng7XG4gICAgICAgICAgICB0aGlzLl95ID0gdjEueTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSB2MS56O1xuICAgICAgICAgICAgdGhpcy5fdyA9IHI7XG5cbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgIH0oKSxcblxuICAgIGludmVyc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29uanVnYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLl94ICo9IC0xO1xuICAgICAgICB0aGlzLl95ICo9IC0xO1xuICAgICAgICB0aGlzLl96ICo9IC0xO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRvdDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aFNxOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmICggbCA9PT0gMCApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgICAgICAgdGhpcy5fdyA9IDE7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgbCA9IDEgLyBsO1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5feCAqIGw7XG4gICAgICAgICAgICB0aGlzLl95ID0gdGhpcy5feSAqIGw7XG4gICAgICAgICAgICB0aGlzLl96ID0gdGhpcy5feiAqIGw7XG4gICAgICAgICAgICB0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiggcSwgcCApIHtcblxuICAgICAgICBpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgLy8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cbiAgICAgICAgdmFyIHFheCA9IGEuX3gsXG4gICAgICAgICAgICBxYXkgPSBhLl95LFxuICAgICAgICAgICAgcWF6ID0gYS5feixcbiAgICAgICAgICAgIHFhdyA9IGEuX3c7XG4gICAgICAgIHZhciBxYnggPSBiLl94LFxuICAgICAgICAgICAgcWJ5ID0gYi5feSxcbiAgICAgICAgICAgIHFieiA9IGIuX3osXG4gICAgICAgICAgICBxYncgPSBiLl93O1xuXG4gICAgICAgIHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG4gICAgICAgIHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG4gICAgICAgIHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG4gICAgICAgIHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBzbGVycDogZnVuY3Rpb24oIHFiLCB0ICkge1xuXG4gICAgICAgIGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICAgICAgeiA9IHRoaXMuX3osXG4gICAgICAgICAgICB3ID0gdGhpcy5fdztcblxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG4gICAgICAgIHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cbiAgICAgICAgaWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG4gICAgICAgICAgICB0aGlzLl93ID0gLXFiLl93O1xuICAgICAgICAgICAgdGhpcy5feCA9IC1xYi5feDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSAtcWIuX3k7XG4gICAgICAgICAgICB0aGlzLl96ID0gLXFiLl96O1xuXG4gICAgICAgICAgICBjb3NIYWxmVGhldGEgPSAtY29zSGFsZlRoZXRhO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuY29weSggcWIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuXG4gICAgICAgICAgICB0aGlzLl93ID0gdztcbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgICAgICB0aGlzLl96ID0gejtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApO1xuICAgICAgICB2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcblxuICAgICAgICBpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuXG4gICAgICAgICAgICB0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xuICAgICAgICAgICAgdGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XG4gICAgICAgICAgICB0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcbiAgICAgICAgICAgIHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cbiAgICAgICAgdGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcbiAgICAgICAgdGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcbiAgICAgICAgdGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcbiAgICAgICAgdGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBxdWF0ZXJuaW9uICkge1xuXG4gICAgICAgIHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgICAgIHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgICAgICB0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcbiAgICAgICAgdGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbigpIHt9XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiggcWEsIHFiLCBxbSwgdCApIHtcblxuICAgIHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxuVEhSRUUuVmVjdG9yMiA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuXG4gICAgdGhpcy54ID0geCB8fCAwO1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMixcblxuICAgIHNldDogZnVuY3Rpb24oIHgsIHkgKSB7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbiggeCApIHtcblxuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFk6IGZ1bmN0aW9uKCB5ICkge1xuXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiggaW5kZXgsIHZhbHVlICkge1xuXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICAgIHRoaXMueSArPSB2Lnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnggKz0gcztcbiAgICAgICAgdGhpcy55ICs9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkVmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xuICAgICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiggdiwgcyApIHtcblxuICAgICAgICB0aGlzLnggKz0gdi54ICogcztcbiAgICAgICAgdGhpcy55ICs9IHYueSAqIHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViOiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgICAgdGhpcy55IC09IHYueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWJTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMueCAtPSBzO1xuICAgICAgICB0aGlzLnkgLT0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWJWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgICAgdGhpcy55ICo9IHYueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICo9IHM7XG4gICAgICAgIHRoaXMueSAqPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpdmlkZTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdGhpcy54IC89IHYueDtcbiAgICAgICAgdGhpcy55IC89IHYueTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgaWYgKCBzY2FsYXIgIT09IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG4gICAgICAgICAgICB0aGlzLnggKj0gaW52U2NhbGFyO1xuICAgICAgICAgICAgdGhpcy55ICo9IGludlNjYWxhcjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgdGhpcy55ID0gMDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBpZiAoIHRoaXMueCA+IHYueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA+IHYueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGlmICggdGhpcy54IDwgdi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsYW1wOiBmdW5jdGlvbiggbWluLCBtYXggKSB7XG5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgICAgICBpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSBtaW4ueDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gbWF4Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IG1pbi55O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSBtYXgueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xhbXBTY2FsYXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtaW4sIG1heDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICAgICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbWluID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XG4gICAgICAgICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZmxvb3I6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjZWlsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmRUb1plcm86IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgICAgIHRoaXMueSA9IC10aGlzLnk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZG90OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aFNxOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApO1xuXG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHZhciBkeCA9IHRoaXMueCAtIHYueCxcbiAgICAgICAgICAgIGR5ID0gdGhpcy55IC0gdi55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICB9LFxuXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbiggbCApIHtcblxuICAgICAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgICAgICBpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cbiAgICAgICAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVycDogZnVuY3Rpb24oIHYsIGFscGhhICkge1xuXG4gICAgICAgIHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG4gICAgICAgIHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgICAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24oIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcbiAgICAgICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24oIHgsIHksIHogKSB7XG5cbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICAgIHRoaXMueiA9IHogfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMyxcblxuICAgIHNldDogZnVuY3Rpb24oIHgsIHksIHogKSB7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbiggeCApIHtcblxuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFk6IGZ1bmN0aW9uKCB5ICkge1xuXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WjogZnVuY3Rpb24oIHogKSB7XG5cbiAgICAgICAgdGhpcy56ID0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLnogPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuejtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgICAgdGhpcy55ICs9IHYueTtcbiAgICAgICAgdGhpcy56ICs9IHYuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMueCArPSBzO1xuICAgICAgICB0aGlzLnkgKz0gcztcbiAgICAgICAgdGhpcy56ICs9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkVmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xuICAgICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG4gICAgICAgIHRoaXMueiA9IGEueiArIGIuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uKCB2LCBzICkge1xuXG4gICAgICAgIHRoaXMueCArPSB2LnggKiBzO1xuICAgICAgICB0aGlzLnkgKz0gdi55ICogcztcbiAgICAgICAgdGhpcy56ICs9IHYueiAqIHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViOiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgICAgdGhpcy55IC09IHYueTtcbiAgICAgICAgdGhpcy56IC09IHYuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWJTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMueCAtPSBzO1xuICAgICAgICB0aGlzLnkgLT0gcztcbiAgICAgICAgdGhpcy56IC09IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViVmVjdG9yczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gYS54IC0gYi54O1xuICAgICAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG4gICAgICAgIHRoaXMueiA9IGEueiAtIGIuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAqPSB2Lng7XG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XG4gICAgICAgIHRoaXMueiAqPSB2Lno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgICAgdGhpcy56ICo9IHNjYWxhcjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCAqIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55ICogYi55O1xuICAgICAgICB0aGlzLnogPSBhLnogKiBiLno7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlFdWxlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHF1YXRlcm5pb247XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXVsZXIoIGV1bGVyICkge1xuXG4gICAgICAgICAgICBpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcXVhdGVybmlvbjtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBhcHBseU1hdHJpeDM6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcbiAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuICAgICAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICAgICAgeiA9IHRoaXMuejtcblxuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXTtcbiAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXTtcbiAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxuXG4gICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgeSA9IHRoaXMueSxcbiAgICAgICAgICAgIHogPSB0aGlzLno7XG5cbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgICAgICB2YXIgZCA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7IC8vIHBlcnNwZWN0aXZlIGRpdmlkZVxuXG4gICAgICAgIHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSApICogZDtcbiAgICAgICAgdGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiBkO1xuICAgICAgICB0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiBkO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24oIHEgKSB7XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgICAgICB2YXIgcXggPSBxLng7XG4gICAgICAgIHZhciBxeSA9IHEueTtcbiAgICAgICAgdmFyIHF6ID0gcS56O1xuICAgICAgICB2YXIgcXcgPSBxLnc7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuICAgICAgICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgICAgIHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgICAgICAgdmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgICAgICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuICAgICAgICB0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgICAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgICAgICB0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXRyaXg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcblxuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXRyaXg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVucHJvamVjdCggY2FtZXJhICkge1xuXG4gICAgICAgICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuICAgICAgICAvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuICAgICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgICAgICB6ID0gdGhpcy56O1xuXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XG4gICAgICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcbiAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcblxuICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpdmlkZTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgdGhpcy54IC89IHYueDtcbiAgICAgICAgdGhpcy55IC89IHYueTtcbiAgICAgICAgdGhpcy56IC89IHYuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgaWYgKCBzY2FsYXIgIT09IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG4gICAgICAgICAgICB0aGlzLnggKj0gaW52U2NhbGFyO1xuICAgICAgICAgICAgdGhpcy55ICo9IGludlNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueiAqPSBpbnZTY2FsYXI7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICB0aGlzLnogPSAwO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGlmICggdGhpcy54ID4gdi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55ID4gdi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy56ID4gdi56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHYueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IHYueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnogPCB2LnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IHYuejtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xhbXA6IGZ1bmN0aW9uKCBtaW4sIG1heCApIHtcblxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgICAgIGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cbiAgICAgICAgICAgIHRoaXMueCA9IG1pbi54O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSBtYXgueDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gbWluLnk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IG1heC55O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueiA8IG1pbi56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSBtaW4uejtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gbWF4Lno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsYW1wU2NhbGFyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWluLCBtYXg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgICAgICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICAgICAgbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG4gICAgICAgICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBmbG9vcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjZWlsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kVG9aZXJvOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICAgICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkb3Q6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuICAgIH0sXG5cbiAgICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIH0sXG5cbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uKCBsICkge1xuXG4gICAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcblxuICAgICAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsZXJwOiBmdW5jdGlvbiggdiwgYWxwaGEgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcbiAgICAgICAgdGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsZXJwVmVjdG9yczogZnVuY3Rpb24oIHYxLCB2MiwgYWxwaGEgKSB7XG5cbiAgICAgICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY3Jvc3M6IGZ1bmN0aW9uKCB2LCB3ICkge1xuXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgICAgICB6ID0gdGhpcy56O1xuXG4gICAgICAgIHRoaXMueCA9IHkgKiB2LnogLSB6ICogdi55O1xuICAgICAgICB0aGlzLnkgPSB6ICogdi54IC0geCAqIHYuejtcbiAgICAgICAgdGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB2YXIgYXggPSBhLngsXG4gICAgICAgICAgICBheSA9IGEueSxcbiAgICAgICAgICAgIGF6ID0gYS56O1xuICAgICAgICB2YXIgYnggPSBiLngsXG4gICAgICAgICAgICBieSA9IGIueSxcbiAgICAgICAgICAgIGJ6ID0gYi56O1xuXG4gICAgICAgIHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgICAgICB0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICAgICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEsIGRvdDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdjEuY29weSggdmVjdG9yICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIGRvdCA9IHRoaXMuZG90KCB2MSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3B5KCB2MSApLm11bHRpcGx5U2NhbGFyKCBkb3QgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuICAgICAgICB9XG5cbiAgICB9KCksXG5cbiAgICByZWZsZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcbiAgICAgICAgLy8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG4gICAgICAgIH1cblxuICAgIH0oKSxcblxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIHRoaXMubGVuZ3RoKCkgKiB2Lmxlbmd0aCgpICk7XG5cbiAgICAgICAgLy8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuICAgICAgICByZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLTEsIDEgKSApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB2YXIgZHggPSB0aGlzLnggLSB2Lng7XG4gICAgICAgIHZhciBkeSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgdmFyIGR6ID0gdGhpcy56IC0gdi56O1xuXG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cbiAgICB9LFxuXG4gICAgc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uKCBtLCBvcmRlciApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xuXG4gICAgfSxcblxuICAgIHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uKCBxLCBvcmRlciApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcblxuICAgIH0sXG5cbiAgICBnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRQb3NpdGlvbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4UG9zaXRpb24oKS4nICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XG5cbiAgICB9LFxuXG4gICAgZ2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0U2NhbGVGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFNjYWxlKCkuJyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xuXG4gICAgfSxcblxuICAgIGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uKCBpbmRleCwgbWF0cml4ICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB0aGlzLnggPSBtLmVsZW1lbnRzWyAxMiBdO1xuICAgICAgICB0aGlzLnkgPSBtLmVsZW1lbnRzWyAxMyBdO1xuICAgICAgICB0aGlzLnogPSBtLmVsZW1lbnRzWyAxNCBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdmFyIHN4ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDAgXSwgbS5lbGVtZW50c1sgMSBdLCBtLmVsZW1lbnRzWyAyIF0gKS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHN5ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDQgXSwgbS5lbGVtZW50c1sgNSBdLCBtLmVsZW1lbnRzWyA2IF0gKS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDggXSwgbS5lbGVtZW50c1sgOSBdLCBtLmVsZW1lbnRzWyAxMCBdICkubGVuZ3RoKCk7XG5cbiAgICAgICAgdGhpcy54ID0gc3g7XG4gICAgICAgIHRoaXMueSA9IHN5O1xuICAgICAgICB0aGlzLnogPSBzejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiggaW5kZXgsIG1hdHJpeCApIHtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xuXG4gICAgICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuICAgICAgICB0aGlzLnggPSBtZVsgb2Zmc2V0IF07XG4gICAgICAgIHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XG4gICAgICAgIHRoaXMueiA9IG1lWyBvZmZzZXQgKyAyIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgICAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgICAgICB0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24oIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcbiAgICAgICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcbiAgICAgICAgdGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3I0LmpzXG5cbi8qKlxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiggeCwgeSwgeiwgdyApIHtcblxuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgdGhpcy56ID0geiB8fCAwO1xuICAgIHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufTtcblxuVEhSRUUuVmVjdG9yNC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yNCxcblxuICAgIHNldDogZnVuY3Rpb24oIHgsIHksIHosIHcgKSB7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgdGhpcy53ID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbiggeCApIHtcblxuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFk6IGZ1bmN0aW9uKCB5ICkge1xuXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WjogZnVuY3Rpb24oIHogKSB7XG5cbiAgICAgICAgdGhpcy56ID0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRXOiBmdW5jdGlvbiggdyApIHtcblxuICAgICAgICB0aGlzLncgPSB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24oIGluZGV4LCB2YWx1ZSApIHtcblxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMueiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRoaXMudyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56O1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgICB0aGlzLnogPSB2Lno7XG4gICAgICAgIHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbiggdiwgdyApIHtcblxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgICAgdGhpcy55ICs9IHYueTtcbiAgICAgICAgdGhpcy56ICs9IHYuejtcbiAgICAgICAgdGhpcy53ICs9IHYudztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRTY2FsYXI6IGZ1bmN0aW9uKCBzICkge1xuXG4gICAgICAgIHRoaXMueCArPSBzO1xuICAgICAgICB0aGlzLnkgKz0gcztcbiAgICAgICAgdGhpcy56ICs9IHM7XG4gICAgICAgIHRoaXMudyArPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZFZlY3RvcnM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55ICsgYi55O1xuICAgICAgICB0aGlzLnogPSBhLnogKyBiLno7XG4gICAgICAgIHRoaXMudyA9IGEudyArIGIudztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uKCB2LCBzICkge1xuXG4gICAgICAgIHRoaXMueCArPSB2LnggKiBzO1xuICAgICAgICB0aGlzLnkgKz0gdi55ICogcztcbiAgICAgICAgdGhpcy56ICs9IHYueiAqIHM7XG4gICAgICAgIHRoaXMudyArPSB2LncgKiBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YjogZnVuY3Rpb24oIHYsIHcgKSB7XG5cbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICAgIHRoaXMueiAtPSB2Lno7XG4gICAgICAgIHRoaXMudyAtPSB2Lnc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViU2NhbGFyOiBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICB0aGlzLnggLT0gcztcbiAgICAgICAgdGhpcy55IC09IHM7XG4gICAgICAgIHRoaXMueiAtPSBzO1xuICAgICAgICB0aGlzLncgLT0gcztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzdWJWZWN0b3JzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcbiAgICAgICAgdGhpcy56ID0gYS56IC0gYi56O1xuICAgICAgICB0aGlzLncgPSBhLncgLSBiLnc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgICAgdGhpcy56ICo9IHNjYWxhcjtcbiAgICAgICAgdGhpcy53ICo9IHNjYWxhcjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcbiAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XG4gICAgICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcbiAgICAgICAgdGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24oIHNjYWxhciApIHtcblxuICAgICAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgICAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICAgICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuICAgICAgICAgICAgdGhpcy56ICo9IGludlNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMudyAqPSBpbnZTY2FsYXI7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICB0aGlzLnogPSAwO1xuICAgICAgICAgICAgdGhpcy53ID0gMTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uKCBxICkge1xuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cblxuICAgICAgICAvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgICAgIHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xuXG4gICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XG5cbiAgICAgICAgaWYgKCBzIDwgMC4wMDAxICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSAxO1xuICAgICAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgICAgIHRoaXMueiA9IDA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gcS54IC8gcztcbiAgICAgICAgICAgIHRoaXMueSA9IHEueSAvIHM7XG4gICAgICAgICAgICB0aGlzLnogPSBxLnogLyBzO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICAgICAgdmFyIGFuZ2xlLCB4LCB5LCB6LCAvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuICAgICAgICAgICAgZXBzaWxvbiA9IDAuMDEsIC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG4gICAgICAgICAgICBlcHNpbG9uMiA9IDAuMSwgLy8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblxuICAgICAgICAgICAgdGUgPSBtLmVsZW1lbnRzLFxuXG4gICAgICAgICAgICBtMTEgPSB0ZVsgMCBdLFxuICAgICAgICAgICAgbTEyID0gdGVbIDQgXSxcbiAgICAgICAgICAgIG0xMyA9IHRlWyA4IF0sXG4gICAgICAgICAgICBtMjEgPSB0ZVsgMSBdLFxuICAgICAgICAgICAgbTIyID0gdGVbIDUgXSxcbiAgICAgICAgICAgIG0yMyA9IHRlWyA5IF0sXG4gICAgICAgICAgICBtMzEgPSB0ZVsgMiBdLFxuICAgICAgICAgICAgbTMyID0gdGVbIDYgXSxcbiAgICAgICAgICAgIG0zMyA9IHRlWyAxMCBdO1xuXG4gICAgICAgIGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiYgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uICkgJiYgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XG5cbiAgICAgICAgICAgIC8vIHNpbmd1bGFyaXR5IGZvdW5kXG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG4gICAgICAgICAgICAvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cbiAgICAgICAgICAgIGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApICYmICggTWF0aC5hYnMoIG0xMyArIG0zMSApIDwgZXBzaWxvbjIgKSAmJiAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yICkgJiYgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5QSTtcblxuICAgICAgICAgICAgdmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xuICAgICAgICAgICAgdmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xuICAgICAgICAgICAgdmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xuICAgICAgICAgICAgdmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XG4gICAgICAgICAgICB2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcbiAgICAgICAgICAgIHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xuXG4gICAgICAgICAgICBpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuICAgICAgICAgICAgICAgIGlmICggeHggPCBlcHNpbG9uICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB5ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgICAgICAgICAgIHogPSAwLjcwNzEwNjc4MTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5zcXJ0KCB4eCApO1xuICAgICAgICAgICAgICAgICAgICB5ID0geHkgLyB4O1xuICAgICAgICAgICAgICAgICAgICB6ID0geHogLyB4O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggeXkgPiB6eiApIHtcblxuICAgICAgICAgICAgICAgIC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cbiAgICAgICAgICAgICAgICBpZiAoIHl5IDwgZXBzaWxvbiApIHtcblxuICAgICAgICAgICAgICAgICAgICB4ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB6ID0gMC43MDcxMDY3ODE7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGguc3FydCggeXkgKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHh5IC8geTtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHl6IC8geTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXG5cbiAgICAgICAgICAgICAgICBpZiAoIHp6IDwgZXBzaWxvbiApIHtcblxuICAgICAgICAgICAgICAgICAgICB4ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICAgICAgICAgICAgeiA9IDA7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgeiA9IE1hdGguc3FydCggenogKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHh6IC8gejtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHl6IC8gejtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcblxuICAgICAgICB2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKSArICggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXG5cbiAgICAgICAgaWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcblxuICAgICAgICAvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG4gICAgICAgIC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxuXG4gICAgICAgIHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xuICAgICAgICB0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcbiAgICAgICAgdGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG4gICAgICAgIHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICBpZiAoIHRoaXMueCA+IHYueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueSA+IHYueSApIHtcblxuICAgICAgICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMueiA+IHYueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMudyA+IHYudyApIHtcblxuICAgICAgICAgICAgdGhpcy53ID0gdi53O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGlmICggdGhpcy54IDwgdi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy56IDwgdi56ICkge1xuXG4gICAgICAgICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy53IDwgdi53ICkge1xuXG4gICAgICAgICAgICB0aGlzLncgPSB2Lnc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsYW1wOiBmdW5jdGlvbiggbWluLCBtYXggKSB7XG5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgICAgICBpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG4gICAgICAgICAgICB0aGlzLnggPSBtaW4ueDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuICAgICAgICAgICAgdGhpcy54ID0gbWF4Lng7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMueSA9IG1pbi55O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG4gICAgICAgICAgICB0aGlzLnkgPSBtYXgueTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnogPCBtaW4ueiApIHtcblxuICAgICAgICAgICAgdGhpcy56ID0gbWluLno7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XG5cbiAgICAgICAgICAgIHRoaXMueiA9IG1heC56O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMudyA8IG1pbi53ICkge1xuXG4gICAgICAgICAgICB0aGlzLncgPSBtaW4udztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLncgPiBtYXgudyApIHtcblxuICAgICAgICAgICAgdGhpcy53ID0gbWF4Lnc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsYW1wU2NhbGFyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWluLCBtYXg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgICAgICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG4gICAgICAgICAgICAgICAgbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcbiAgICAgICAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZmxvb3I6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgICAgIHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNlaWw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG4gICAgICAgIHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG4gICAgICAgIHRoaXMudyA9IE1hdGgucm91bmQoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kVG9aZXJvOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSAoIHRoaXMudyA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy53ICkgOiBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgICAgIHRoaXMueiA9IC10aGlzLno7XG4gICAgICAgIHRoaXMudyA9IC10aGlzLnc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZG90OiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aFNxOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xuXG4gICAgfSxcblxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICB9LFxuXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbiggbCApIHtcblxuICAgICAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgICAgICBpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cbiAgICAgICAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVycDogZnVuY3Rpb24oIHYsIGFscGhhICkge1xuXG4gICAgICAgIHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG4gICAgICAgIHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG4gICAgICAgIHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG4gICAgICAgIHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG4gICAgICAgIHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICAgICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgICAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuICAgICAgICB0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuICAgICAgICB0aGlzLncgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMyBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuRXVsZXIgPSBmdW5jdGlvbiggeCwgeSwgeiwgb3JkZXIgKSB7XG5cbiAgICB0aGlzLl94ID0geCB8fCAwO1xuICAgIHRoaXMuX3kgPSB5IHx8IDA7XG4gICAgdGhpcy5feiA9IHogfHwgMDtcbiAgICB0aGlzLl9vcmRlciA9IG9yZGVyIHx8IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcjtcblxufTtcblxuVEhSRUUuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cblRIUkVFLkV1bGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5FdWxlcixcblxuICAgIGdldCB4KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuXG4gICAgfSxcblxuICAgIHNldCB4KCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIGdldCB5KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuXG4gICAgfSxcblxuICAgIHNldCB5KCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIGdldCB6KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl96O1xuXG4gICAgfSxcblxuICAgIHNldCB6KCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl96ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgfSxcblxuICAgIGdldCBvcmRlcigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXI7XG5cbiAgICB9LFxuXG4gICAgc2V0IG9yZGVyKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLl9vcmRlciA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB4LCB5LCB6LCBvcmRlciApIHtcblxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHRoaXMuX3ogPSB6O1xuICAgICAgICB0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIGV1bGVyICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSBldWxlci5feDtcbiAgICAgICAgdGhpcy5feSA9IGV1bGVyLl95O1xuICAgICAgICB0aGlzLl96ID0gZXVsZXIuX3o7XG4gICAgICAgIHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24oIG0sIG9yZGVyLCB1cGRhdGUgKSB7XG5cbiAgICAgICAgdmFyIGNsYW1wID0gVEhSRUUuTWF0aC5jbGFtcDtcblxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgICAgIHZhciB0ZSA9IG0uZWxlbWVudHM7XG4gICAgICAgIHZhciBtMTEgPSB0ZVsgMCBdLFxuICAgICAgICAgICAgbTEyID0gdGVbIDQgXSxcbiAgICAgICAgICAgIG0xMyA9IHRlWyA4IF07XG4gICAgICAgIHZhciBtMjEgPSB0ZVsgMSBdLFxuICAgICAgICAgICAgbTIyID0gdGVbIDUgXSxcbiAgICAgICAgICAgIG0yMyA9IHRlWyA5IF07XG4gICAgICAgIHZhciBtMzEgPSB0ZVsgMiBdLFxuICAgICAgICAgICAgbTMyID0gdGVbIDYgXSxcbiAgICAgICAgICAgIG0zMyA9IHRlWyAxMCBdO1xuXG4gICAgICAgIG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cbiAgICAgICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0xLCAxICkgKTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC1tMjMsIG0zMyApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtbTEyLCBtMTEgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXNpbiggLWNsYW1wKCBtMjMsIC0xLCAxICkgKTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC1tMzEsIG0xMSApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtMSwgMSApICk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtbTMxLCBtMzMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLW0xMiwgbTIyICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmFzaW4oIC1jbGFtcCggbTMxLCAtMSwgMSApICk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtbTEyLCBtMjIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLTEsIDEgKSApO1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggLW0yMywgbTIyICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC1tMzEsIG0xMSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hc2luKCAtY2xhbXAoIG0xMiwgLTEsIDEgKSApO1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggLW0yMywgbTMzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG4gICAgICAgIGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWF0cml4O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICAgICAgICBtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiggdiwgb3JkZXIgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xuXG4gICAgfSxcblxuICAgIHJlb3JkZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuICAgICAgICB2YXIgcSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBuZXdPcmRlciApIHtcblxuICAgICAgICAgICAgcS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIHEsIG5ld09yZGVyICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIGV1bGVyICkge1xuXG4gICAgICAgIHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSApIHtcblxuICAgICAgICB0aGlzLl94ID0gYXJyYXlbIDAgXTtcbiAgICAgICAgdGhpcy5feSA9IGFycmF5WyAxIF07XG4gICAgICAgIHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuICAgICAgICBpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9LFxuXG4gICAgdG9WZWN0b3IzOiBmdW5jdGlvbiggb3B0aW9uYWxSZXN1bHQgKSB7XG5cbiAgICAgICAgaWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBvbkNoYW5nZTogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge31cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9MaW5lMy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkxpbmUzID0gZnVuY3Rpb24oIHN0YXJ0LCBlbmQgKSB7XG5cbiAgICB0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5MaW5lMy5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTGluZTMsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBzdGFydCwgZW5kICkge1xuXG4gICAgICAgIHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcbiAgICAgICAgdGhpcy5lbmQuY29weSggZW5kICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggbGluZSApIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcbiAgICAgICAgdGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICAgIH0sXG5cbiAgICBkZWx0YTogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VTcTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XG5cbiAgICB9LFxuXG4gICAgYXQ6IGZ1bmN0aW9uKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3RhcnRQID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHN0YXJ0RW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHBvaW50LCBjbGFtcFRvTGluZSApIHtcblxuICAgICAgICAgICAgc3RhcnRQLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLnN0YXJ0ICk7XG4gICAgICAgICAgICBzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnRFbmQyID0gc3RhcnRFbmQuZG90KCBzdGFydEVuZCApO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XG5cbiAgICAgICAgICAgIHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG4gICAgICAgICAgICBpZiAoIGNsYW1wVG9MaW5lICkge1xuXG4gICAgICAgICAgICAgICAgdCA9IFRIUkVFLk1hdGguY2xhbXAoIHQsIDAsIDEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdDtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24oIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24oIG1hdHJpeCApIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG4gICAgICAgIHRoaXMuZW5kLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggbGluZSApIHtcblxuICAgICAgICByZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94Mi5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkJveDIgPSBmdW5jdGlvbiggbWluLCBtYXggKSB7XG5cbiAgICB0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IyKCBJbmZpbml0eSwgSW5maW5pdHkgKTtcbiAgICB0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IyKCAtSW5maW5pdHksIC1JbmZpbml0eSApO1xuXG59O1xuXG5USFJFRS5Cb3gyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gyLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggbWluLCBtYXggKSB7XG5cbiAgICAgICAgdGhpcy5taW4uY29weSggbWluICk7XG4gICAgICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cbiAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGNlbnRlciwgc2l6ZSApIHtcblxuICAgICAgICAgICAgdmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcbiAgICAgICAgICAgIHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcbiAgICAgICAgICAgIHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICB0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG4gICAgICAgIHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlRW1wdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLUluZmluaXR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG4gICAgfSxcblxuICAgIGNlbnRlcjogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cbiAgICB9LFxuXG4gICAgZXhwYW5kQnlQb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHRoaXMubWluLm1pbiggcG9pbnQgKTtcbiAgICAgICAgdGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIHRoaXMubWluLnN1YiggdmVjdG9yICk7XG4gICAgICAgIHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgdGhpcy5taW4uYWRkU2NhbGFyKCAtc2NhbGFyICk7XG4gICAgICAgIHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSxcblxuICAgIGNvbnRhaW5zQm94OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxuICAgICAgICAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH0sXG5cbiAgICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgLy8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcbiAgICAgICAgLy8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldChcbiAgICAgICAgICAgICggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSwgKCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXG4gICAgICAgICk7XG5cbiAgICB9LFxuXG4gICAgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgLy8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cbiAgICAgICAgaWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBjbGFtcFBvaW50OiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgICAgICB2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuICAgICAgICB0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB1bmlvbjogZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICB0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcbiAgICAgICAgdGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiggb2Zmc2V0ICkge1xuXG4gICAgICAgIHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG4gICAgICAgIHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gzLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5Cb3gzID0gZnVuY3Rpb24oIG1pbiwgbWF4ICkge1xuXG4gICAgdGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuICAgIHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjMoIC1JbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHkgKTtcblxufTtcblxuVEhSRUUuQm94My5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQm94MyxcblxuICAgIHNldDogZnVuY3Rpb24oIG1pbiwgbWF4ICkge1xuXG4gICAgICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgICAgICB0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiggcG9pbnRzICkge1xuXG4gICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggY2VudGVyLCBzaXplICkge1xuXG4gICAgICAgICAgICB2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgICAgICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgICAgICAgICB0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiBhbiBvYmplY3QgKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLFxuICAgICAgICAvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgICAgICBvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcblxuICAgICAgICAgICAgb2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiggbm9kZSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MS5jb3B5KCB2ZXJ0aWNlc1sgaSBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdLmFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MS5zZXQoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgdGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuICAgICAgICB0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZUVtcHR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLUluZmluaXR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApIHx8ICggdGhpcy5tYXgueiA8IHRoaXMubWluLnogKTtcblxuICAgIH0sXG5cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICB9LFxuXG4gICAgc2l6ZTogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG4gICAgfSxcblxuICAgIGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICB0aGlzLm1pbi5taW4oIHBvaW50ICk7XG4gICAgICAgIHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICB0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuICAgICAgICB0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiggc2NhbGFyICkge1xuXG4gICAgICAgIHRoaXMubWluLmFkZFNjYWxhciggLXNjYWxhciApO1xuICAgICAgICB0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICBpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuICAgICAgICAgICAgcG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9LFxuXG4gICAgY29udGFpbnNCb3g6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgaWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG4gICAgICAgICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICYmXG4gICAgICAgICAgICAoIHRoaXMubWluLnogPD0gYm94Lm1pbi56ICkgJiYgKCBib3gubWF4LnogPD0gdGhpcy5tYXgueiApICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfSxcblxuICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuICAgICAgICAvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KFxuICAgICAgICAgICAgKCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLCAoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksICggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxuICAgICAgICApO1xuXG4gICAgfSxcblxuICAgIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG4gICAgICAgIGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcbiAgICAgICAgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBjbGFtcFBvaW50OiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgICAgICB2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZ2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgICAgICAgICAgcmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQucmFkaXVzID0gdGhpcy5zaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgdGhpcy5taW4ubWF4KCBib3gubWluICk7XG4gICAgICAgIHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHVuaW9uOiBmdW5jdGlvbiggYm94ICkge1xuXG4gICAgICAgIHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuICAgICAgICB0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggbWF0cml4ICkge1xuXG4gICAgICAgICAgICAvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuICAgICAgICAgICAgcG9pbnRzWyAwIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXG4gICAgICAgICAgICBwb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcbiAgICAgICAgICAgIHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxuICAgICAgICAgICAgcG9pbnRzWyAzIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXG4gICAgICAgICAgICBwb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcbiAgICAgICAgICAgIHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxuICAgICAgICAgICAgcG9pbnRzWyA2IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXG4gICAgICAgICAgICBwb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTFcblxuICAgICAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcbiAgICAgICAgdGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBib3ggKSB7XG5cbiAgICAgICAgcmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5NYXRyaXgzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG4gICAgICAgIDEsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsXG4gICAgICAgIDAsIDAsIDFcblxuICAgIF0gKTtcblxuICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRyaXgzLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHRlWyAwIF0gPSBuMTE7XG4gICAgICAgIHRlWyAzIF0gPSBuMTI7XG4gICAgICAgIHRlWyA2IF0gPSBuMTM7XG4gICAgICAgIHRlWyAxIF0gPSBuMjE7XG4gICAgICAgIHRlWyA0IF0gPSBuMjI7XG4gICAgICAgIHRlWyA3IF0gPSBuMjM7XG4gICAgICAgIHRlWyAyIF0gPSBuMzE7XG4gICAgICAgIHRlWyA1IF0gPSBuMzI7XG4gICAgICAgIHRlWyA4IF0gPSBuMzM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgaWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICAxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICBtZVsgMCBdLCBtZVsgMyBdLCBtZVsgNiBdLFxuICAgICAgICAgICAgbWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSxcbiAgICAgICAgICAgIG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF1cblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiggYSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcblxuICAgIH0sXG5cbiAgICBhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuICAgICAgICAgICAgICAgIHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcbiAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB2MS50b0FycmF5KCBhcnJheSwgaiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgYXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkrKywgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdjEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XG4gICAgICAgICAgICAgICAgdjEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XG4gICAgICAgICAgICAgICAgdjEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cbiAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0ZVsgMCBdICo9IHM7XG4gICAgICAgIHRlWyAzIF0gKj0gcztcbiAgICAgICAgdGVbIDYgXSAqPSBzO1xuICAgICAgICB0ZVsgMSBdICo9IHM7XG4gICAgICAgIHRlWyA0IF0gKj0gcztcbiAgICAgICAgdGVbIDcgXSAqPSBzO1xuICAgICAgICB0ZVsgMiBdICo9IHM7XG4gICAgICAgIHRlWyA1IF0gKj0gcztcbiAgICAgICAgdGVbIDggXSAqPSBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRldGVybWluYW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHZhciBhID0gdGVbIDAgXSxcbiAgICAgICAgICAgIGIgPSB0ZVsgMSBdLFxuICAgICAgICAgICAgYyA9IHRlWyAyIF0sXG4gICAgICAgICAgICBkID0gdGVbIDMgXSxcbiAgICAgICAgICAgIGUgPSB0ZVsgNCBdLFxuICAgICAgICAgICAgZiA9IHRlWyA1IF0sXG4gICAgICAgICAgICBnID0gdGVbIDYgXSxcbiAgICAgICAgICAgIGggPSB0ZVsgNyBdLFxuICAgICAgICAgICAgaSA9IHRlWyA4IF07XG5cbiAgICAgICAgcmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuICAgIH0sXG5cbiAgICBnZXRJbnZlcnNlOiBmdW5jdGlvbiggbWF0cml4LCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcblxuICAgICAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxuICAgICAgICAvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcblxuICAgICAgICB2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdGVbIDAgXSA9IG1lWyAxMCBdICogbWVbIDUgXSAtIG1lWyA2IF0gKiBtZVsgOSBdO1xuICAgICAgICB0ZVsgMSBdID0gLW1lWyAxMCBdICogbWVbIDEgXSArIG1lWyAyIF0gKiBtZVsgOSBdO1xuICAgICAgICB0ZVsgMiBdID0gbWVbIDYgXSAqIG1lWyAxIF0gLSBtZVsgMiBdICogbWVbIDUgXTtcbiAgICAgICAgdGVbIDMgXSA9IC1tZVsgMTAgXSAqIG1lWyA0IF0gKyBtZVsgNiBdICogbWVbIDggXTtcbiAgICAgICAgdGVbIDQgXSA9IG1lWyAxMCBdICogbWVbIDAgXSAtIG1lWyAyIF0gKiBtZVsgOCBdO1xuICAgICAgICB0ZVsgNSBdID0gLW1lWyA2IF0gKiBtZVsgMCBdICsgbWVbIDIgXSAqIG1lWyA0IF07XG4gICAgICAgIHRlWyA2IF0gPSBtZVsgOSBdICogbWVbIDQgXSAtIG1lWyA1IF0gKiBtZVsgOCBdO1xuICAgICAgICB0ZVsgNyBdID0gLW1lWyA5IF0gKiBtZVsgMCBdICsgbWVbIDEgXSAqIG1lWyA4IF07XG4gICAgICAgIHRlWyA4IF0gPSBtZVsgNSBdICogbWVbIDAgXSAtIG1lWyAxIF0gKiBtZVsgNCBdO1xuXG4gICAgICAgIHZhciBkZXQgPSBtZVsgMCBdICogdGVbIDAgXSArIG1lWyAxIF0gKiB0ZVsgMyBdICsgbWVbIDIgXSAqIHRlWyA2IF07XG5cbiAgICAgICAgLy8gbm8gaW52ZXJzZVxuXG4gICAgICAgIGlmICggZGV0ID09PSAwICkge1xuXG4gICAgICAgICAgICB2YXIgbXNnID0gXCJNYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG4gICAgICAgICAgICBpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIG1zZyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaWRlbnRpdHkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEuMCAvIGRldCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdG1wID0gbVsgMSBdO1xuICAgICAgICBtWyAxIF0gPSBtWyAzIF07XG4gICAgICAgIG1bIDMgXSA9IHRtcDtcbiAgICAgICAgdG1wID0gbVsgMiBdO1xuICAgICAgICBtWyAyIF0gPSBtWyA2IF07XG4gICAgICAgIG1bIDYgXSA9IHRtcDtcbiAgICAgICAgdG1wID0gbVsgNSBdO1xuICAgICAgICBtWyA1IF0gPSBtWyA3IF07XG4gICAgICAgIG1bIDcgXSA9IHRtcDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICBnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XG5cbiAgICAgICAgdGhpcy5nZXRJbnZlcnNlKCBtICkudHJhbnNwb3NlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiggciApIHtcblxuICAgICAgICB2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgclsgMCBdID0gbVsgMCBdO1xuICAgICAgICByWyAxIF0gPSBtWyAzIF07XG4gICAgICAgIHJbIDIgXSA9IG1bIDYgXTtcbiAgICAgICAgclsgMyBdID0gbVsgMSBdO1xuICAgICAgICByWyA0IF0gPSBtWyA0IF07XG4gICAgICAgIHJbIDUgXSA9IG1bIDcgXTtcbiAgICAgICAgclsgNiBdID0gbVsgMiBdO1xuICAgICAgICByWyA3IF0gPSBtWyA1IF07XG4gICAgICAgIHJbIDggXSA9IG1bIDggXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSApIHtcblxuICAgICAgICB0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLFxuICAgICAgICAgICAgdGVbIDMgXSwgdGVbIDQgXSwgdGVbIDUgXSxcbiAgICAgICAgICAgIHRlWyA2IF0sIHRlWyA3IF0sIHRlWyA4IF1cbiAgICAgICAgXTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9NYXRyaXg0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxuICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLk1hdHJpeDQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cbiAgICAgICAgMSwgMCwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMSwgMCxcbiAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgXSApO1xuXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1hdHJpeDQucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDQsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0ZVsgMCBdID0gbjExO1xuICAgICAgICB0ZVsgNCBdID0gbjEyO1xuICAgICAgICB0ZVsgOCBdID0gbjEzO1xuICAgICAgICB0ZVsgMTIgXSA9IG4xNDtcbiAgICAgICAgdGVbIDEgXSA9IG4yMTtcbiAgICAgICAgdGVbIDUgXSA9IG4yMjtcbiAgICAgICAgdGVbIDkgXSA9IG4yMztcbiAgICAgICAgdGVbIDEzIF0gPSBuMjQ7XG4gICAgICAgIHRlWyAyIF0gPSBuMzE7XG4gICAgICAgIHRlWyA2IF0gPSBuMzI7XG4gICAgICAgIHRlWyAxMCBdID0gbjMzO1xuICAgICAgICB0ZVsgMTQgXSA9IG4zNDtcbiAgICAgICAgdGVbIDMgXSA9IG40MTtcbiAgICAgICAgdGVbIDcgXSA9IG40MjtcbiAgICAgICAgdGVbIDExIF0gPSBuNDM7XG4gICAgICAgIHRlWyAxNSBdID0gbjQ0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGlkZW50aXR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgMSwgMCwgMCwgMCxcbiAgICAgICAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcblxuICAgIH0sXG5cbiAgICBjb3B5UG9zaXRpb246IGZ1bmN0aW9uKCBtICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgdGVbIDEyIF0gPSBtZVsgMTIgXTtcbiAgICAgICAgdGVbIDEzIF0gPSBtZVsgMTMgXTtcbiAgICAgICAgdGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBleHRyYWN0QmFzaXM6IGZ1bmN0aW9uKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgeEF4aXMuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICk7XG4gICAgICAgIHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xuICAgICAgICB6QXhpcy5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZUJhc2lzOiBmdW5jdGlvbiggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuICAgICAgICB0aGlzLnNldChcbiAgICAgICAgICAgIHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG4gICAgICAgICAgICB4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuICAgICAgICAgICAgeEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgICAgIHZhciBzY2FsZVggPSAxIC8gdjEuc2V0KCBtZVsgMCBdLCBtZVsgMSBdLCBtZVsgMiBdICkubGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gMSAvIHYxLnNldCggbWVbIDQgXSwgbWVbIDUgXSwgbWVbIDYgXSApLmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuICAgICAgICAgICAgdGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG4gICAgICAgICAgICB0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblxuICAgICAgICAgICAgdGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG4gICAgICAgICAgICB0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcbiAgICAgICAgICAgIHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXG4gICAgICAgICAgICB0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcbiAgICAgICAgICAgIHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuICAgICAgICAgICAgdGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24oIGV1bGVyICkge1xuXG4gICAgICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHZhciB4ID0gZXVsZXIueCxcbiAgICAgICAgICAgIHkgPSBldWxlci55LFxuICAgICAgICAgICAgeiA9IGV1bGVyLno7XG4gICAgICAgIHZhciBhID0gTWF0aC5jb3MoIHggKSxcbiAgICAgICAgICAgIGIgPSBNYXRoLnNpbiggeCApO1xuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCB5ICksXG4gICAgICAgICAgICBkID0gTWF0aC5zaW4oIHkgKTtcbiAgICAgICAgdmFyIGUgPSBNYXRoLmNvcyggeiApLFxuICAgICAgICAgICAgZiA9IE1hdGguc2luKCB6ICk7XG5cbiAgICAgICAgaWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgICAgICAgIHZhciBhZSA9IGEgKiBlLFxuICAgICAgICAgICAgICAgIGFmID0gYSAqIGYsXG4gICAgICAgICAgICAgICAgYmUgPSBiICogZSxcbiAgICAgICAgICAgICAgICBiZiA9IGIgKiBmO1xuXG4gICAgICAgICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICAgICAgICB0ZVsgNCBdID0gLWMgKiBmO1xuICAgICAgICAgICAgdGVbIDggXSA9IGQ7XG5cbiAgICAgICAgICAgIHRlWyAxIF0gPSBhZiArIGJlICogZDtcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhZSAtIGJmICogZDtcbiAgICAgICAgICAgIHRlWyA5IF0gPSAtYiAqIGM7XG5cbiAgICAgICAgICAgIHRlWyAyIF0gPSBiZiAtIGFlICogZDtcbiAgICAgICAgICAgIHRlWyA2IF0gPSBiZSArIGFmICogZDtcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICAgICAgICB2YXIgY2UgPSBjICogZSxcbiAgICAgICAgICAgICAgICBjZiA9IGMgKiBmLFxuICAgICAgICAgICAgICAgIGRlID0gZCAqIGUsXG4gICAgICAgICAgICAgICAgZGYgPSBkICogZjtcblxuICAgICAgICAgICAgdGVbIDAgXSA9IGNlICsgZGYgKiBiO1xuICAgICAgICAgICAgdGVbIDQgXSA9IGRlICogYiAtIGNmO1xuICAgICAgICAgICAgdGVbIDggXSA9IGEgKiBkO1xuXG4gICAgICAgICAgICB0ZVsgMSBdID0gYSAqIGY7XG4gICAgICAgICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICAgICAgICB0ZVsgOSBdID0gLWI7XG5cbiAgICAgICAgICAgIHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcbiAgICAgICAgICAgIHRlWyA2IF0gPSBkZiArIGNlICogYjtcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgICAgICAgICB2YXIgY2UgPSBjICogZSxcbiAgICAgICAgICAgICAgICBjZiA9IGMgKiBmLFxuICAgICAgICAgICAgICAgIGRlID0gZCAqIGUsXG4gICAgICAgICAgICAgICAgZGYgPSBkICogZjtcblxuICAgICAgICAgICAgdGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuICAgICAgICAgICAgdGVbIDQgXSA9IC1hICogZjtcbiAgICAgICAgICAgIHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuICAgICAgICAgICAgdGVbIDEgXSA9IGNmICsgZGUgKiBiO1xuICAgICAgICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgICAgICAgdGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG4gICAgICAgICAgICB0ZVsgMiBdID0gLWEgKiBkO1xuICAgICAgICAgICAgdGVbIDYgXSA9IGI7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuICAgICAgICAgICAgdmFyIGFlID0gYSAqIGUsXG4gICAgICAgICAgICAgICAgYWYgPSBhICogZixcbiAgICAgICAgICAgICAgICBiZSA9IGIgKiBlLFxuICAgICAgICAgICAgICAgIGJmID0gYiAqIGY7XG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcbiAgICAgICAgICAgIHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcbiAgICAgICAgICAgIHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuICAgICAgICAgICAgdGVbIDEgXSA9IGMgKiBmO1xuICAgICAgICAgICAgdGVbIDUgXSA9IGJmICogZCArIGFlO1xuICAgICAgICAgICAgdGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG4gICAgICAgICAgICB0ZVsgMiBdID0gLWQ7XG4gICAgICAgICAgICB0ZVsgNiBdID0gYiAqIGM7XG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuICAgICAgICAgICAgdmFyIGFjID0gYSAqIGMsXG4gICAgICAgICAgICAgICAgYWQgPSBhICogZCxcbiAgICAgICAgICAgICAgICBiYyA9IGIgKiBjLFxuICAgICAgICAgICAgICAgIGJkID0gYiAqIGQ7XG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcbiAgICAgICAgICAgIHRlWyA0IF0gPSBiZCAtIGFjICogZjtcbiAgICAgICAgICAgIHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuICAgICAgICAgICAgdGVbIDEgXSA9IGY7XG4gICAgICAgICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICAgICAgICB0ZVsgOSBdID0gLWIgKiBlO1xuXG4gICAgICAgICAgICB0ZVsgMiBdID0gLWQgKiBlO1xuICAgICAgICAgICAgdGVbIDYgXSA9IGFkICogZiArIGJjO1xuICAgICAgICAgICAgdGVbIDEwIF0gPSBhYyAtIGJkICogZjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICAgICAgICAgIHZhciBhYyA9IGEgKiBjLFxuICAgICAgICAgICAgICAgIGFkID0gYSAqIGQsXG4gICAgICAgICAgICAgICAgYmMgPSBiICogYyxcbiAgICAgICAgICAgICAgICBiZCA9IGIgKiBkO1xuXG4gICAgICAgICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICAgICAgICB0ZVsgNCBdID0gLWY7XG4gICAgICAgICAgICB0ZVsgOCBdID0gZCAqIGU7XG5cbiAgICAgICAgICAgIHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhICogZTtcbiAgICAgICAgICAgIHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuICAgICAgICAgICAgdGVbIDIgXSA9IGJjICogZiAtIGFkO1xuICAgICAgICAgICAgdGVbIDYgXSA9IGIgKiBlO1xuICAgICAgICAgICAgdGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFzdCBjb2x1bW5cbiAgICAgICAgdGVbIDMgXSA9IDA7XG4gICAgICAgIHRlWyA3IF0gPSAwO1xuICAgICAgICB0ZVsgMTEgXSA9IDA7XG5cbiAgICAgICAgLy8gYm90dG9tIHJvd1xuICAgICAgICB0ZVsgMTIgXSA9IDA7XG4gICAgICAgIHRlWyAxMyBdID0gMDtcbiAgICAgICAgdGVbIDE0IF0gPSAwO1xuICAgICAgICB0ZVsgMTUgXSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24oIHEgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG4gICAgfSxcblxuICAgIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiggcSApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIHZhciB4ID0gcS54LFxuICAgICAgICAgICAgeSA9IHEueSxcbiAgICAgICAgICAgIHogPSBxLnosXG4gICAgICAgICAgICB3ID0gcS53O1xuICAgICAgICB2YXIgeDIgPSB4ICsgeCxcbiAgICAgICAgICAgIHkyID0geSArIHksXG4gICAgICAgICAgICB6MiA9IHogKyB6O1xuICAgICAgICB2YXIgeHggPSB4ICogeDIsXG4gICAgICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgICAgIHh6ID0geCAqIHoyO1xuICAgICAgICB2YXIgeXkgPSB5ICogeTIsXG4gICAgICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgICAgIHp6ID0geiAqIHoyO1xuICAgICAgICB2YXIgd3ggPSB3ICogeDIsXG4gICAgICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgICAgIHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XG4gICAgICAgIHRlWyA0IF0gPSB4eSAtIHd6O1xuICAgICAgICB0ZVsgOCBdID0geHogKyB3eTtcblxuICAgICAgICB0ZVsgMSBdID0geHkgKyB3ejtcbiAgICAgICAgdGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcbiAgICAgICAgdGVbIDkgXSA9IHl6IC0gd3g7XG5cbiAgICAgICAgdGVbIDIgXSA9IHh6IC0gd3k7XG4gICAgICAgIHRlWyA2IF0gPSB5eiArIHd4O1xuICAgICAgICB0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcblxuICAgICAgICAvLyBsYXN0IGNvbHVtblxuICAgICAgICB0ZVsgMyBdID0gMDtcbiAgICAgICAgdGVbIDcgXSA9IDA7XG4gICAgICAgIHRlWyAxMSBdID0gMDtcblxuICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgIHRlWyAxMiBdID0gMDtcbiAgICAgICAgdGVbIDEzIF0gPSAwO1xuICAgICAgICB0ZVsgMTQgXSA9IDA7XG4gICAgICAgIHRlWyAxNSBdID0gMTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBsb29rQXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB4LCB5LCB6O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZXllLCB0YXJnZXQsIHVwICkge1xuXG4gICAgICAgICAgICBpZiAoIHggPT09IHVuZGVmaW5lZCApIHggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgaWYgKCB5ID09PSB1bmRlZmluZWQgKSB5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgICAgIHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgaWYgKCB6Lmxlbmd0aCgpID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgei56ID0gMTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgaWYgKCB4Lmxlbmd0aCgpID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgei54ICs9IDAuMDAwMTtcbiAgICAgICAgICAgICAgICB4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5LmNyb3NzVmVjdG9ycyggeiwgeCApO1xuXG5cbiAgICAgICAgICAgIHRlWyAwIF0gPSB4Lng7XG4gICAgICAgICAgICB0ZVsgNCBdID0geS54O1xuICAgICAgICAgICAgdGVbIDggXSA9IHoueDtcbiAgICAgICAgICAgIHRlWyAxIF0gPSB4Lnk7XG4gICAgICAgICAgICB0ZVsgNSBdID0geS55O1xuICAgICAgICAgICAgdGVbIDkgXSA9IHoueTtcbiAgICAgICAgICAgIHRlWyAyIF0gPSB4Lno7XG4gICAgICAgICAgICB0ZVsgNiBdID0geS56O1xuICAgICAgICAgICAgdGVbIDEwIF0gPSB6Lno7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oIG0sIG4gKSB7XG5cbiAgICAgICAgaWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgIHZhciBhZSA9IGEuZWxlbWVudHM7XG4gICAgICAgIHZhciBiZSA9IGIuZWxlbWVudHM7XG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdmFyIGExMSA9IGFlWyAwIF0sXG4gICAgICAgICAgICBhMTIgPSBhZVsgNCBdLFxuICAgICAgICAgICAgYTEzID0gYWVbIDggXSxcbiAgICAgICAgICAgIGExNCA9IGFlWyAxMiBdO1xuICAgICAgICB2YXIgYTIxID0gYWVbIDEgXSxcbiAgICAgICAgICAgIGEyMiA9IGFlWyA1IF0sXG4gICAgICAgICAgICBhMjMgPSBhZVsgOSBdLFxuICAgICAgICAgICAgYTI0ID0gYWVbIDEzIF07XG4gICAgICAgIHZhciBhMzEgPSBhZVsgMiBdLFxuICAgICAgICAgICAgYTMyID0gYWVbIDYgXSxcbiAgICAgICAgICAgIGEzMyA9IGFlWyAxMCBdLFxuICAgICAgICAgICAgYTM0ID0gYWVbIDE0IF07XG4gICAgICAgIHZhciBhNDEgPSBhZVsgMyBdLFxuICAgICAgICAgICAgYTQyID0gYWVbIDcgXSxcbiAgICAgICAgICAgIGE0MyA9IGFlWyAxMSBdLFxuICAgICAgICAgICAgYTQ0ID0gYWVbIDE1IF07XG5cbiAgICAgICAgdmFyIGIxMSA9IGJlWyAwIF0sXG4gICAgICAgICAgICBiMTIgPSBiZVsgNCBdLFxuICAgICAgICAgICAgYjEzID0gYmVbIDggXSxcbiAgICAgICAgICAgIGIxNCA9IGJlWyAxMiBdO1xuICAgICAgICB2YXIgYjIxID0gYmVbIDEgXSxcbiAgICAgICAgICAgIGIyMiA9IGJlWyA1IF0sXG4gICAgICAgICAgICBiMjMgPSBiZVsgOSBdLFxuICAgICAgICAgICAgYjI0ID0gYmVbIDEzIF07XG4gICAgICAgIHZhciBiMzEgPSBiZVsgMiBdLFxuICAgICAgICAgICAgYjMyID0gYmVbIDYgXSxcbiAgICAgICAgICAgIGIzMyA9IGJlWyAxMCBdLFxuICAgICAgICAgICAgYjM0ID0gYmVbIDE0IF07XG4gICAgICAgIHZhciBiNDEgPSBiZVsgMyBdLFxuICAgICAgICAgICAgYjQyID0gYmVbIDcgXSxcbiAgICAgICAgICAgIGI0MyA9IGJlWyAxMSBdLFxuICAgICAgICAgICAgYjQ0ID0gYmVbIDE1IF07XG5cbiAgICAgICAgdGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcbiAgICAgICAgdGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcbiAgICAgICAgdGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcbiAgICAgICAgdGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cbiAgICAgICAgdGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcbiAgICAgICAgdGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcbiAgICAgICAgdGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcbiAgICAgICAgdGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cbiAgICAgICAgdGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcbiAgICAgICAgdGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0MjtcbiAgICAgICAgdGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG4gICAgICAgIHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG4gICAgICAgIHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG4gICAgICAgIHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG4gICAgICAgIHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuICAgICAgICB0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVRvQXJyYXk6IGZ1bmN0aW9uKCBhLCBiLCByICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICk7XG5cbiAgICAgICAgclsgMCBdID0gdGVbIDAgXTtcbiAgICAgICAgclsgMSBdID0gdGVbIDEgXTtcbiAgICAgICAgclsgMiBdID0gdGVbIDIgXTtcbiAgICAgICAgclsgMyBdID0gdGVbIDMgXTtcbiAgICAgICAgclsgNCBdID0gdGVbIDQgXTtcbiAgICAgICAgclsgNSBdID0gdGVbIDUgXTtcbiAgICAgICAgclsgNiBdID0gdGVbIDYgXTtcbiAgICAgICAgclsgNyBdID0gdGVbIDcgXTtcbiAgICAgICAgclsgOCBdID0gdGVbIDggXTtcbiAgICAgICAgclsgOSBdID0gdGVbIDkgXTtcbiAgICAgICAgclsgMTAgXSA9IHRlWyAxMCBdO1xuICAgICAgICByWyAxMSBdID0gdGVbIDExIF07XG4gICAgICAgIHJbIDEyIF0gPSB0ZVsgMTIgXTtcbiAgICAgICAgclsgMTMgXSA9IHRlWyAxMyBdO1xuICAgICAgICByWyAxNCBdID0gdGVbIDE0IF07XG4gICAgICAgIHJbIDE1IF0gPSB0ZVsgMTUgXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB0ZVsgMCBdICo9IHM7XG4gICAgICAgIHRlWyA0IF0gKj0gcztcbiAgICAgICAgdGVbIDggXSAqPSBzO1xuICAgICAgICB0ZVsgMTIgXSAqPSBzO1xuICAgICAgICB0ZVsgMSBdICo9IHM7XG4gICAgICAgIHRlWyA1IF0gKj0gcztcbiAgICAgICAgdGVbIDkgXSAqPSBzO1xuICAgICAgICB0ZVsgMTMgXSAqPSBzO1xuICAgICAgICB0ZVsgMiBdICo9IHM7XG4gICAgICAgIHRlWyA2IF0gKj0gcztcbiAgICAgICAgdGVbIDEwIF0gKj0gcztcbiAgICAgICAgdGVbIDE0IF0gKj0gcztcbiAgICAgICAgdGVbIDMgXSAqPSBzO1xuICAgICAgICB0ZVsgNyBdICo9IHM7XG4gICAgICAgIHRlWyAxMSBdICo9IHM7XG4gICAgICAgIHRlWyAxNSBdICo9IHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgb3IgdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgbXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCBhICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xuXG4gICAgfSxcblxuICAgIGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgdjEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xuICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xuICAgICAgICAgICAgICAgIHYxLnRvQXJyYXkoIGFycmF5LCBqICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBhcHBseVRvQnVmZmVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrLCBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcbiAgICAgICAgICAgICAgICB2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcbiAgICAgICAgICAgICAgICB2MS56ID0gYnVmZmVyLmdldFooIGogKTtcblxuICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZUF4aXM6IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblxuICAgICAgICB2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNyb3NzVmVjdG9yOiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBkZXRlcm1pbmFudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB2YXIgbjExID0gdGVbIDAgXSxcbiAgICAgICAgICAgIG4xMiA9IHRlWyA0IF0sXG4gICAgICAgICAgICBuMTMgPSB0ZVsgOCBdLFxuICAgICAgICAgICAgbjE0ID0gdGVbIDEyIF07XG4gICAgICAgIHZhciBuMjEgPSB0ZVsgMSBdLFxuICAgICAgICAgICAgbjIyID0gdGVbIDUgXSxcbiAgICAgICAgICAgIG4yMyA9IHRlWyA5IF0sXG4gICAgICAgICAgICBuMjQgPSB0ZVsgMTMgXTtcbiAgICAgICAgdmFyIG4zMSA9IHRlWyAyIF0sXG4gICAgICAgICAgICBuMzIgPSB0ZVsgNiBdLFxuICAgICAgICAgICAgbjMzID0gdGVbIDEwIF0sXG4gICAgICAgICAgICBuMzQgPSB0ZVsgMTQgXTtcbiAgICAgICAgdmFyIG40MSA9IHRlWyAzIF0sXG4gICAgICAgICAgICBuNDIgPSB0ZVsgNyBdLFxuICAgICAgICAgICAgbjQzID0gdGVbIDExIF0sXG4gICAgICAgICAgICBuNDQgPSB0ZVsgMTUgXTtcblxuICAgICAgICAvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuICAgICAgICAvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbjQxICogKCArbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0ICkgK1xuICAgICAgICAgICAgbjQyICogKCArbjExICogbjIzICogbjM0IC0gbjExICogbjI0ICogbjMzICsgbjE0ICogbjIxICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICkgK1xuICAgICAgICAgICAgbjQzICogKCArbjExICogbjI0ICogbjMyIC0gbjExICogbjIyICogbjM0IC0gbjE0ICogbjIxICogbjMyICsgbjEyICogbjIxICogbjM0ICsgbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxICkgK1xuICAgICAgICAgICAgbjQ0ICogKCAtbjEzICogbjIyICogbjMxIC0gbjExICogbjIzICogbjMyICsgbjExICogbjIyICogbjMzICsgbjEzICogbjIxICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjEyICogbjIzICogbjMxIClcblxuICAgICAgICApO1xuXG4gICAgfSxcblxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHRtcDtcblxuICAgICAgICB0bXAgPSB0ZVsgMSBdO1xuICAgICAgICB0ZVsgMSBdID0gdGVbIDQgXTtcbiAgICAgICAgdGVbIDQgXSA9IHRtcDtcbiAgICAgICAgdG1wID0gdGVbIDIgXTtcbiAgICAgICAgdGVbIDIgXSA9IHRlWyA4IF07XG4gICAgICAgIHRlWyA4IF0gPSB0bXA7XG4gICAgICAgIHRtcCA9IHRlWyA2IF07XG4gICAgICAgIHRlWyA2IF0gPSB0ZVsgOSBdO1xuICAgICAgICB0ZVsgOSBdID0gdG1wO1xuXG4gICAgICAgIHRtcCA9IHRlWyAzIF07XG4gICAgICAgIHRlWyAzIF0gPSB0ZVsgMTIgXTtcbiAgICAgICAgdGVbIDEyIF0gPSB0bXA7XG4gICAgICAgIHRtcCA9IHRlWyA3IF07XG4gICAgICAgIHRlWyA3IF0gPSB0ZVsgMTMgXTtcbiAgICAgICAgdGVbIDEzIF0gPSB0bXA7XG4gICAgICAgIHRtcCA9IHRlWyAxMSBdO1xuICAgICAgICB0ZVsgMTEgXSA9IHRlWyAxNCBdO1xuICAgICAgICB0ZVsgMTQgXSA9IHRtcDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH0sXG5cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgICAgIHJldHVybiB2MS5zZXQoIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0gKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgdGVbIDEyIF0gPSB2Lng7XG4gICAgICAgIHRlWyAxMyBdID0gdi55O1xuICAgICAgICB0ZVsgMTQgXSA9IHYuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRJbnZlcnNlOiBmdW5jdGlvbiggbSwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cbiAgICAgICAgLy8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgdmFyIG4xMSA9IG1lWyAwIF0sXG4gICAgICAgICAgICBuMTIgPSBtZVsgNCBdLFxuICAgICAgICAgICAgbjEzID0gbWVbIDggXSxcbiAgICAgICAgICAgIG4xNCA9IG1lWyAxMiBdO1xuICAgICAgICB2YXIgbjIxID0gbWVbIDEgXSxcbiAgICAgICAgICAgIG4yMiA9IG1lWyA1IF0sXG4gICAgICAgICAgICBuMjMgPSBtZVsgOSBdLFxuICAgICAgICAgICAgbjI0ID0gbWVbIDEzIF07XG4gICAgICAgIHZhciBuMzEgPSBtZVsgMiBdLFxuICAgICAgICAgICAgbjMyID0gbWVbIDYgXSxcbiAgICAgICAgICAgIG4zMyA9IG1lWyAxMCBdLFxuICAgICAgICAgICAgbjM0ID0gbWVbIDE0IF07XG4gICAgICAgIHZhciBuNDEgPSBtZVsgMyBdLFxuICAgICAgICAgICAgbjQyID0gbWVbIDcgXSxcbiAgICAgICAgICAgIG40MyA9IG1lWyAxMSBdLFxuICAgICAgICAgICAgbjQ0ID0gbWVbIDE1IF07XG5cbiAgICAgICAgdGVbIDAgXSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NDtcbiAgICAgICAgdGVbIDQgXSA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NDtcbiAgICAgICAgdGVbIDggXSA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NDtcbiAgICAgICAgdGVbIDEyIF0gPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG4gICAgICAgIHRlWyAxIF0gPSBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQ7XG4gICAgICAgIHRlWyA1IF0gPSBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQ7XG4gICAgICAgIHRlWyA5IF0gPSBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQ7XG4gICAgICAgIHRlWyAxMyBdID0gbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0O1xuICAgICAgICB0ZVsgMiBdID0gbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0O1xuICAgICAgICB0ZVsgNiBdID0gbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0O1xuICAgICAgICB0ZVsgMTAgXSA9IG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NDtcbiAgICAgICAgdGVbIDE0IF0gPSBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQ7XG4gICAgICAgIHRlWyAzIF0gPSBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDM7XG4gICAgICAgIHRlWyA3IF0gPSBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDM7XG4gICAgICAgIHRlWyAxMSBdID0gbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzO1xuICAgICAgICB0ZVsgMTUgXSA9IG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMztcblxuICAgICAgICB2YXIgZGV0ID0gbjExICogdGVbIDAgXSArIG4yMSAqIHRlWyA0IF0gKyBuMzEgKiB0ZVsgOCBdICsgbjQxICogdGVbIDEyIF07XG5cbiAgICAgICAgaWYgKCBkZXQgPT09IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cbiAgICAgICAgICAgIGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggbXNnICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pZGVudGl0eSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oIHYgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICByb3RhdGVYOiBmdW5jdGlvbiggYW5nbGUgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgcm90YXRlWTogZnVuY3Rpb24oIGFuZ2xlICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uKCBhbmdsZSApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICByb3RhdGVCeUF4aXM6IGZ1bmN0aW9uKCBheGlzLCBhbmdsZSApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbiggdiApIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgeCA9IHYueCxcbiAgICAgICAgICAgIHkgPSB2LnksXG4gICAgICAgICAgICB6ID0gdi56O1xuXG4gICAgICAgIHRlWyAwIF0gKj0geDtcbiAgICAgICAgdGVbIDQgXSAqPSB5O1xuICAgICAgICB0ZVsgOCBdICo9IHo7XG4gICAgICAgIHRlWyAxIF0gKj0geDtcbiAgICAgICAgdGVbIDUgXSAqPSB5O1xuICAgICAgICB0ZVsgOSBdICo9IHo7XG4gICAgICAgIHRlWyAyIF0gKj0geDtcbiAgICAgICAgdGVbIDYgXSAqPSB5O1xuICAgICAgICB0ZVsgMTAgXSAqPSB6O1xuICAgICAgICB0ZVsgMyBdICo9IHg7XG4gICAgICAgIHRlWyA3IF0gKj0geTtcbiAgICAgICAgdGVbIDExIF0gKj0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICB2YXIgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG4gICAgICAgIHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcbiAgICAgICAgdmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBNYXRoLm1heCggc2NhbGVZU3EsIHNjYWxlWlNxICkgKSApO1xuXG4gICAgfSxcblxuICAgIG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24oIHgsIHksIHogKSB7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIDEsIDAsIDAsIHgsXG4gICAgICAgICAgICAwLCAxLCAwLCB5LFxuICAgICAgICAgICAgMCwgMCwgMSwgeixcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uKCB0aGV0YSApIHtcblxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICAxLCAwLCAwLCAwLFxuICAgICAgICAgICAgMCwgYywgLXMsIDAsXG4gICAgICAgICAgICAwLCBzLCBjLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZVJvdGF0aW9uWTogZnVuY3Rpb24oIHRoZXRhICkge1xuXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICAgICAgdGhpcy5zZXQoXG5cbiAgICAgICAgICAgIGMsIDAsIHMsIDAsXG4gICAgICAgICAgICAwLCAxLCAwLCAwLCAtcywgMCwgYywgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcblxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uKCB0aGV0YSApIHtcblxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgICAgIHRoaXMuc2V0KFxuXG4gICAgICAgICAgICBjLCAtcywgMCwgMCxcbiAgICAgICAgICAgIHMsIGMsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24oIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICAgIC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG4gICAgICAgIHZhciB0ID0gMSAtIGM7XG4gICAgICAgIHZhciB4ID0gYXhpcy54LFxuICAgICAgICAgICAgeSA9IGF4aXMueSxcbiAgICAgICAgICAgIHogPSBheGlzLno7XG4gICAgICAgIHZhciB0eCA9IHQgKiB4LFxuICAgICAgICAgICAgdHkgPSB0ICogeTtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgdHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuICAgICAgICAgICAgdHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuICAgICAgICAgICAgdHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbWFrZVNjYWxlOiBmdW5jdGlvbiggeCwgeSwgeiApIHtcblxuICAgICAgICB0aGlzLnNldChcblxuICAgICAgICAgICAgeCwgMCwgMCwgMCxcbiAgICAgICAgICAgIDAsIHksIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCB6LCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29tcG9zZTogZnVuY3Rpb24oIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuICAgICAgICB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG4gICAgICAgIHRoaXMuc2NhbGUoIHNjYWxlICk7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oIHBvc2l0aW9uICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdmVjdG9yLCBtYXRyaXg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgICAgIHZhciBzeCA9IHZlY3Rvci5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgICAgICAgICB2YXIgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuICAgICAgICAgICAgaWYgKCBkZXQgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgc3ggPSAtc3g7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuICAgICAgICAgICAgcG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuICAgICAgICAgICAgcG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG4gICAgICAgICAgICAvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcblxuICAgICAgICAgICAgdmFyIGludlNYID0gMSAvIHN4O1xuICAgICAgICAgICAgdmFyIGludlNZID0gMSAvIHN5O1xuICAgICAgICAgICAgdmFyIGludlNaID0gMSAvIHN6O1xuXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuICAgICAgICAgICAgcXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgICAgICAgICBzY2FsZS54ID0gc3g7XG4gICAgICAgICAgICBzY2FsZS55ID0gc3k7XG4gICAgICAgICAgICBzY2FsZS56ID0gc3o7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBtYWtlRnJ1c3R1bTogZnVuY3Rpb24oIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xuICAgICAgICB2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuICAgICAgICB2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xuICAgICAgICB2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xuICAgICAgICB2YXIgYyA9IC0oIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuICAgICAgICB2YXIgZCA9IC0yICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xuXG4gICAgICAgIHRlWyAwIF0gPSB4O1xuICAgICAgICB0ZVsgNCBdID0gMDtcbiAgICAgICAgdGVbIDggXSA9IGE7XG4gICAgICAgIHRlWyAxMiBdID0gMDtcbiAgICAgICAgdGVbIDEgXSA9IDA7XG4gICAgICAgIHRlWyA1IF0gPSB5O1xuICAgICAgICB0ZVsgOSBdID0gYjtcbiAgICAgICAgdGVbIDEzIF0gPSAwO1xuICAgICAgICB0ZVsgMiBdID0gMDtcbiAgICAgICAgdGVbIDYgXSA9IDA7XG4gICAgICAgIHRlWyAxMCBdID0gYztcbiAgICAgICAgdGVbIDE0IF0gPSBkO1xuICAgICAgICB0ZVsgMyBdID0gMDtcbiAgICAgICAgdGVbIDcgXSA9IDA7XG4gICAgICAgIHRlWyAxMSBdID0gLTE7XG4gICAgICAgIHRlWyAxNSBdID0gMDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG4gICAgICAgIHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xuICAgICAgICB2YXIgeW1pbiA9IC15bWF4O1xuICAgICAgICB2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XG4gICAgICAgIHZhciB4bWF4ID0geW1heCAqIGFzcGVjdDtcblxuICAgICAgICByZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XG5cbiAgICB9LFxuXG4gICAgbWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24oIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB3ID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICB2YXIgaCA9IHRvcCAtIGJvdHRvbTtcbiAgICAgICAgdmFyIHAgPSBmYXIgLSBuZWFyO1xuXG4gICAgICAgIHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAvIHc7XG4gICAgICAgIHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XG4gICAgICAgIHZhciB6ID0gKCBmYXIgKyBuZWFyICkgLyBwO1xuXG4gICAgICAgIHRlWyAwIF0gPSAyIC8gdztcbiAgICAgICAgdGVbIDQgXSA9IDA7XG4gICAgICAgIHRlWyA4IF0gPSAwO1xuICAgICAgICB0ZVsgMTIgXSA9IC14O1xuICAgICAgICB0ZVsgMSBdID0gMDtcbiAgICAgICAgdGVbIDUgXSA9IDIgLyBoO1xuICAgICAgICB0ZVsgOSBdID0gMDtcbiAgICAgICAgdGVbIDEzIF0gPSAteTtcbiAgICAgICAgdGVbIDIgXSA9IDA7XG4gICAgICAgIHRlWyA2IF0gPSAwO1xuICAgICAgICB0ZVsgMTAgXSA9IC0yIC8gcDtcbiAgICAgICAgdGVbIDE0IF0gPSAtejtcbiAgICAgICAgdGVbIDMgXSA9IDA7XG4gICAgICAgIHRlWyA3IF0gPSAwO1xuICAgICAgICB0ZVsgMTEgXSA9IDA7XG4gICAgICAgIHRlWyAxNSBdID0gMTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBtYXRyaXggKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpKysgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9LFxuXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSwgdGVbIDMgXSxcbiAgICAgICAgICAgIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0sIHRlWyA3IF0sXG4gICAgICAgICAgICB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSwgdGVbIDExIF0sXG4gICAgICAgICAgICB0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdLCB0ZVsgMTUgXVxuICAgICAgICBdO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1JheS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLlJheSA9IGZ1bmN0aW9uKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICAgIHRoaXMub3JpZ2luID0gKCBvcmlnaW4gIT09IHVuZGVmaW5lZCApID8gb3JpZ2luIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9ICggZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgKSA/IGRpcmVjdGlvbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLlJheS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUmF5LFxuXG4gICAgc2V0OiBmdW5jdGlvbiggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICAgICAgdGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHJheSApIHtcblxuICAgICAgICB0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhdDogZnVuY3Rpb24oIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgIH0sXG5cbiAgICByZWNhc3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG4gICAgICAgIHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICAgICAgaWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5vcmlnaW4gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgIH0sXG5cbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgICAgICAgICAvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG4gICAgICAgICAgICBpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHYxLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBkaXN0YW5jZVNxVG9TZWdtZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnQ2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHNlZ0RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG4gICAgICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0Rpc3RhbmNlL1dtNURpc3RSYXkzU2VnbWVudDMuY3BwXG4gICAgICAgICAgICAvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuICAgICAgICAgICAgLy8gZGVmaW5lZCBieSB2MCBhbmQgdjFcbiAgICAgICAgICAgIC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XG4gICAgICAgICAgICAvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcbiAgICAgICAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuICAgICAgICAgICAgc2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcbiAgICAgICAgICAgIHNlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xuXG4gICAgICAgICAgICB2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcbiAgICAgICAgICAgIHZhciBhMDEgPSAtdGhpcy5kaXJlY3Rpb24uZG90KCBzZWdEaXIgKTtcbiAgICAgICAgICAgIHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuICAgICAgICAgICAgdmFyIGIxID0gLWRpZmYuZG90KCBzZWdEaXIgKTtcbiAgICAgICAgICAgIHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xuICAgICAgICAgICAgdmFyIGRldCA9IE1hdGguYWJzKCAxIC0gYTAxICogYTAxICk7XG4gICAgICAgICAgICB2YXIgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XG5cbiAgICAgICAgICAgIGlmICggZGV0ID4gMCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuICAgICAgICAgICAgICAgIHMwID0gYTAxICogYjEgLSBiMDtcbiAgICAgICAgICAgICAgICBzMSA9IGEwMSAqIGIwIC0gYjE7XG4gICAgICAgICAgICAgICAgZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzMCA+PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggczEgPj0gLWV4dERldCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnZEZXQgPSAxIC8gZGV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwICo9IGludkRldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSAqPSBpbnZEZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IHMwICogKCBzMCArIGEwMSAqIHMxICsgMiAqIGIwICkgKyBzMSAqICggYTAxICogczAgKyBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gMVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBzZWdFeHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSggYTAxICogczEgKyBiMCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDVcblxuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSAtc2VnRXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSggYTAxICogczEgKyBiMCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggczEgPD0gLWV4dERldCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDRcblxuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSggLWEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gKCBzMCA+IDAgKSA/IC1zZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC1zZWdFeHRlbnQsIC1iMSApLCBzZWdFeHRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiAzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtc2VnRXh0ZW50LCAtYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiAyXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0oIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gKCBzMCA+IDAgKSA/IHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLXNlZ0V4dGVudCwgLWIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXG4gICAgICAgICAgICAgICAgczEgPSAoIGEwMSA+IDAgKSA/IC1zZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG4gICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSggYTAxICogczEgKyBiMCApICk7XG4gICAgICAgICAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xuXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHMwICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuICAgICAgICAgICAgICAgIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3FyRGlzdDtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG5cbiAgICBpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24oIHNwaGVyZSApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gZnJvbSBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktc3BoZXJlLWludGVyc2VjdGlvbi9cblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggc3BoZXJlLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgdjEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcblxuICAgICAgICAgICAgdmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgICAgICAgICAgdmFyIGQyID0gdjEuZG90KCB2MSApIC0gdGNhICogdGNhO1xuXG4gICAgICAgICAgICB2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXG4gICAgICAgICAgICBpZiAoIGQyID4gcmFkaXVzMiApIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgdGhjID0gTWF0aC5zcXJ0KCByYWRpdXMyIC0gZDIgKTtcblxuICAgICAgICAgICAgLy8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcbiAgICAgICAgICAgIHZhciB0MCA9IHRjYSAtIHRoYztcblxuICAgICAgICAgICAgLy8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxuICAgICAgICAgICAgdmFyIHQxID0gdGNhICsgdGhjO1xuXG4gICAgICAgICAgICAvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIGlmICggdDAgPCAwICYmIHQxIDwgMCApIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICAvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzLCB0aGUgcmF5IGlzIGluc2lkZSB0aGUgc3BoZXJlLCBzbyByZXR1cm4gdGhlIHNlY29uZCBleGl0IHBvaW50IHNjYWxlZCBieSB0MSxcbiAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIGFsd2F5cyByZXR1cm4gYW4gaW50ZXJzZWN0IHBvaW50IHRoYXQgaXMgaW4gZnJvbnQgb2YgdGhlIHJheS5cbiAgICAgICAgICAgIGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgICAgICAgICAvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgICAgIH1cblxuICAgIH0oKSxcblxuICAgIGlzSW50ZXJzZWN0aW9uUGxhbmU6IGZ1bmN0aW9uKCBwbGFuZSApIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XG5cbiAgICAgICAgdmFyIGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICAgIGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgICAgIGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9QbGFuZTogZnVuY3Rpb24oIHBsYW5lICkge1xuXG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG4gICAgICAgIGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cbiAgICAgICAgICAgIC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cbiAgICAgICAgICAgIGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSAtKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG4gICAgICAgIC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cbiAgICAgICAgcmV0dXJuIHQgPj0gMCA/IHQgOiBudWxsO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XG5cbiAgICAgICAgaWYgKCB0ID09PSBudWxsICkge1xuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICB9LFxuXG4gICAgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbiggYm94LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAvLyBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktYm94LWludGVyc2VjdGlvbi9cblxuICAgICAgICB2YXIgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XG5cbiAgICAgICAgdmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcbiAgICAgICAgICAgIGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcbiAgICAgICAgICAgIGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cbiAgICAgICAgaWYgKCBpbnZkaXJ4ID49IDAgKSB7XG5cbiAgICAgICAgICAgIHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuICAgICAgICAgICAgdG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG4gICAgICAgICAgICB0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cbiAgICAgICAgICAgIHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcbiAgICAgICAgICAgIHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0eW1pbiA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG4gICAgICAgICAgICB0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxuICAgICAgICAvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXG5cbiAgICAgICAgaWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcblxuICAgICAgICBpZiAoIHR5bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR5bWF4O1xuXG4gICAgICAgIGlmICggaW52ZGlyeiA+PSAwICkge1xuXG4gICAgICAgICAgICB0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgICAgICAgICB0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuICAgICAgICAgICAgdHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XG5cbiAgICAgICAgaWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcblxuICAgICAgICAvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cbiAgICAgICAgaWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RUcmlhbmdsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgb2Zmc2V0IG9yaWdpbiwgZWRnZXMsIGFuZCBub3JtYWwuXG4gICAgICAgIHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIGVkZ2UxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIGVkZ2UyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0ludGVyc2VjdGlvbi9XbTVJbnRyUmF5M1RyaWFuZ2xlMy5jcHBcblxuICAgICAgICAgICAgZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xuICAgICAgICAgICAgZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xuICAgICAgICAgICAgbm9ybWFsLmNyb3NzVmVjdG9ycyggZWRnZTEsIGVkZ2UyICk7XG5cbiAgICAgICAgICAgIC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxuICAgICAgICAgICAgLy8gRTEgPSBrRWRnZTEsIEUyID0ga0VkZ2UyLCBOID0gQ3Jvc3MoRTEsRTIpKSBieVxuICAgICAgICAgICAgLy8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXG4gICAgICAgICAgICAvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcbiAgICAgICAgICAgIC8vICAgfERvdChELE4pfCp0ID0gLXNpZ24oRG90KEQsTikpKkRvdChRLE4pXG4gICAgICAgICAgICB2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcbiAgICAgICAgICAgIHZhciBzaWduO1xuXG4gICAgICAgICAgICBpZiAoIERkTiA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHNpZ24gPSAxO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggRGROIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgICAgICBEZE4gPSAtRGROO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcbiAgICAgICAgICAgIHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuICAgICAgICAgICAgLy8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIGlmICggRGRReEUyIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMS5jcm9zcyggZGlmZiApICk7XG5cbiAgICAgICAgICAgIC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICBpZiAoIERkRTF4USA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxuICAgICAgICAgICAgaWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxuICAgICAgICAgICAgdmFyIFFkTiA9IC1zaWduICogZGlmZi5kb3QoIG5vcm1hbCApO1xuXG4gICAgICAgICAgICAvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICBpZiAoIFFkTiA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0KCBRZE4gLyBEZE4sIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24oIG1hdHJpeDQgKSB7XG5cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuICAgICAgICB0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCByYXkgKSB7XG5cbiAgICAgICAgcmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwaGVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmUgPSBmdW5jdGlvbiggY2VudGVyLCByYWRpdXMgKSB7XG5cbiAgICB0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG59O1xuXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlNwaGVyZSxcblxuICAgIHNldDogZnVuY3Rpb24oIGNlbnRlciwgcmFkaXVzICkge1xuXG4gICAgICAgIHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XG5cbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCBvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgYm94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmNlbnRlciggY2VudGVyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc3BoZXJlICkge1xuXG4gICAgICAgIHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gKCB0aGlzLnJhZGl1cyA8PSAwICk7XG5cbiAgICB9LFxuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgcmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24oIHNwaGVyZSApIHtcblxuICAgICAgICB2YXIgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xuXG4gICAgICAgIHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XG5cbiAgICB9LFxuXG4gICAgY2xhbXBQb2ludDogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXN1bHQuY29weSggcG9pbnQgKTtcblxuICAgICAgICBpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuICAgICAgICAgICAgcmVzdWx0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgYm94ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkJveDMoKTtcblxuICAgICAgICBib3guc2V0KCB0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIgKTtcbiAgICAgICAgYm94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG4gICAgICAgIHJldHVybiBib3g7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiggbWF0cml4ICkge1xuXG4gICAgICAgIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdGhpcy5jZW50ZXIuYWRkKCBvZmZzZXQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBzcGhlcmUgKSB7XG5cbiAgICAgICAgcmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9GcnVzdHVtLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5GcnVzdHVtID0gZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cbiAgICB0aGlzLnBsYW5lcyA9IFtcblxuICAgICAgICAoIHAwICE9PSB1bmRlZmluZWQgKSA/IHAwIDogbmV3IFRIUkVFLlBsYW5lKCksICggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgVEhSRUUuUGxhbmUoKSwgKCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLCAoIHAzICE9PSB1bmRlZmluZWQgKSA/IHAzIDogbmV3IFRIUkVFLlBsYW5lKCksICggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgVEhSRUUuUGxhbmUoKSwgKCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXG5cbiAgICBdO1xuXG59O1xuXG5USFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5GcnVzdHVtLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICAgICAgcGxhbmVzWyAwIF0uY29weSggcDAgKTtcbiAgICAgICAgcGxhbmVzWyAxIF0uY29weSggcDEgKTtcbiAgICAgICAgcGxhbmVzWyAyIF0uY29weSggcDIgKTtcbiAgICAgICAgcGxhbmVzWyAzIF0uY29weSggcDMgKTtcbiAgICAgICAgcGxhbmVzWyA0IF0uY29weSggcDQgKTtcbiAgICAgICAgcGxhbmVzWyA1IF0uY29weSggcDUgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBmcnVzdHVtICkge1xuXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgIHBsYW5lc1sgaSBdLmNvcHkoIGZydXN0dW0ucGxhbmVzWyBpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbU1hdHJpeDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuICAgICAgICB2YXIgbWUwID0gbWVbIDAgXSxcbiAgICAgICAgICAgIG1lMSA9IG1lWyAxIF0sXG4gICAgICAgICAgICBtZTIgPSBtZVsgMiBdLFxuICAgICAgICAgICAgbWUzID0gbWVbIDMgXTtcbiAgICAgICAgdmFyIG1lNCA9IG1lWyA0IF0sXG4gICAgICAgICAgICBtZTUgPSBtZVsgNSBdLFxuICAgICAgICAgICAgbWU2ID0gbWVbIDYgXSxcbiAgICAgICAgICAgIG1lNyA9IG1lWyA3IF07XG4gICAgICAgIHZhciBtZTggPSBtZVsgOCBdLFxuICAgICAgICAgICAgbWU5ID0gbWVbIDkgXSxcbiAgICAgICAgICAgIG1lMTAgPSBtZVsgMTAgXSxcbiAgICAgICAgICAgIG1lMTEgPSBtZVsgMTEgXTtcbiAgICAgICAgdmFyIG1lMTIgPSBtZVsgMTIgXSxcbiAgICAgICAgICAgIG1lMTMgPSBtZVsgMTMgXSxcbiAgICAgICAgICAgIG1lMTQgPSBtZVsgMTQgXSxcbiAgICAgICAgICAgIG1lMTUgPSBtZVsgMTUgXTtcblxuICAgICAgICBwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XG4gICAgICAgIHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xuICAgICAgICBwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xuICAgICAgICBwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuICAgICAgICAgICAgc3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiggc3BoZXJlICkge1xuXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcbiAgICAgICAgdmFyIGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG4gICAgICAgIHZhciBuZWdSYWRpdXMgPSAtc3BoZXJlLnJhZGl1cztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XG5cbiAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0c0JveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHAxID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIHAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGJveCApIHtcblxuICAgICAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcblxuICAgICAgICAgICAgICAgIHAxLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWluLnggOiBib3gubWF4Lng7XG4gICAgICAgICAgICAgICAgcDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcbiAgICAgICAgICAgICAgICBwMS55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1pbi55IDogYm94Lm1heC55O1xuICAgICAgICAgICAgICAgIHAyLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XG4gICAgICAgICAgICAgICAgcDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcbiAgICAgICAgICAgICAgICBwMi56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXG4gICAgICAgICAgICAgICAgdmFyIGQxID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMSApO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXG5cbiAgICAgICAgICAgICAgICBpZiAoIGQxIDwgMCAmJiBkMiA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cblxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKCBwb2ludCApIHtcblxuICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICBpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUGxhbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5QbGFuZSA9IGZ1bmN0aW9uKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG4gICAgdGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuICAgIHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxufTtcblxuVEhSRUUuUGxhbmUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlBsYW5lLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggbm9ybWFsLCBjb25zdGFudCApIHtcblxuICAgICAgICB0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldENvbXBvbmVudHM6IGZ1bmN0aW9uKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgICAgIHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xuICAgICAgICB0aGlzLmNvbnN0YW50ID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludDogZnVuY3Rpb24oIG5vcm1hbCwgcG9pbnQgKSB7XG5cbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSAtcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApOyAvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYSwgYiwgYyApIHtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggcGxhbmUgKSB7XG5cbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxuXG4gICAgICAgIHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG4gICAgICAgIHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XG4gICAgICAgIHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY29uc3RhbnQgKj0gLTE7XG4gICAgICAgIHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24oIHBvaW50ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xuXG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uKCBzcGhlcmUgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgLSBzcGhlcmUucmFkaXVzO1xuXG4gICAgfSxcblxuICAgIHByb2plY3RQb2ludDogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XG5cbiAgICB9LFxuXG4gICAgb3J0aG9Qb2ludDogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgKTtcblxuICAgIH0sXG5cbiAgICBpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uKCBsaW5lICkge1xuXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxuXG4gICAgICAgIHZhciBzdGFydFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApO1xuICAgICAgICB2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xuXG4gICAgICAgIHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gbGluZS5kZWx0YSggdjEgKTtcblxuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcblxuICAgICAgICAgICAgaWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ID0gLSggbGluZS5zdGFydC5kb3QoIHRoaXMubm9ybWFsICkgKyB0aGlzLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuICAgICAgICAgICAgaWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cblxuICAgIGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtdGhpcy5jb25zdGFudCApO1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbmV3IG5vcm1hbCBiYXNlZCBvbiB0aGVvcnkgaGVyZTpcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9ub3JtYWx0cmFuc2Zvcm0uaHRtbFxuICAgICAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IG0xLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG4gICAgICAgICAgICB2YXIgbmV3Tm9ybWFsID0gdjEuY29weSggdGhpcy5ub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApO1xuXG4gICAgICAgICAgICB2YXIgbmV3Q29wbGFuYXJQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjIgKTtcbiAgICAgICAgICAgIG5ld0NvcGxhbmFyUG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbmV3Tm9ybWFsLCBuZXdDb3BsYW5hclBvaW50ICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdGhpcy5jb25zdGFudCA9IHRoaXMuY29uc3RhbnQgLSBvZmZzZXQuZG90KCB0aGlzLm5vcm1hbCApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oIHBsYW5lICkge1xuXG4gICAgICAgIHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9NYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTWF0aCA9IHtcblxuICAgIGdlbmVyYXRlVVVJRDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5icm9vZmEuY29tL1Rvb2xzL01hdGgudXVpZC5odG1cblxuICAgICAgICB2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCAnJyApO1xuICAgICAgICB2YXIgdXVpZCA9IG5ldyBBcnJheSggMzYgKTtcbiAgICAgICAgdmFyIHJuZCA9IDAsXG4gICAgICAgICAgICByO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgMzY7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggaSA9PT0gOCB8fCBpID09PSAxMyB8fCBpID09PSAxOCB8fCBpID09PSAyMyApIHtcblxuICAgICAgICAgICAgICAgICAgICB1dWlkWyBpIF0gPSAnLSc7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIGkgPT09IDE0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHV1aWRbIGkgXSA9ICc0JztcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJuZCA8PSAweDAyICkgcm5kID0gMHgyMDAwMDAwICsgKCBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwICkgfCAwO1xuICAgICAgICAgICAgICAgICAgICByID0gcm5kICYgMHhmO1xuICAgICAgICAgICAgICAgICAgICBybmQgPSBybmQgPj4gNDtcbiAgICAgICAgICAgICAgICAgICAgdXVpZFsgaSBdID0gY2hhcnNbICggaSA9PT0gMTkgKSA/ICggciAmIDB4MyApIHwgMHg4IDogciBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dWlkLmpvaW4oICcnICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIC8vIENsYW1wIHZhbHVlIHRvIHJhbmdlIDxhLCBiPlxuXG4gICAgY2xhbXA6IGZ1bmN0aW9uKCB4LCBhLCBiICkge1xuXG4gICAgICAgIHJldHVybiAoIHggPCBhICkgPyBhIDogKCAoIHggPiBiICkgPyBiIDogeCApO1xuXG4gICAgfSxcblxuICAgIC8vIENsYW1wIHZhbHVlIHRvIHJhbmdlIDxhLCBpbmYpXG5cbiAgICBjbGFtcEJvdHRvbTogZnVuY3Rpb24oIHgsIGEgKSB7XG5cbiAgICAgICAgcmV0dXJuIHggPCBhID8gYSA6IHg7XG5cbiAgICB9LFxuXG4gICAgLy8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG4gICAgZXVjbGlkZWFuTW9kdWxvOiBmdW5jdGlvbiggbiwgbSApIHtcblxuICAgICAgICByZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xuXG4gICAgfSxcblxuICAgIC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuICAgIG1hcExpbmVhcjogZnVuY3Rpb24oIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG4gICAgICAgIHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xuXG4gICAgfSxcblxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG4gICAgc21vb3Roc3RlcDogZnVuY3Rpb24oIHgsIG1pbiwgbWF4ICkge1xuXG4gICAgICAgIGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgICAgIHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cbiAgICAgICAgcmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxuICAgIH0sXG5cbiAgICBzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uKCB4LCBtaW4sIG1heCApIHtcblxuICAgICAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgICAgIGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuICAgICAgICB4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG4gICAgICAgIHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cbiAgICB9LFxuXG4gICAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPDAsIDE+IHdpdGggMTYgYml0cyBvZiByYW5kb21uZXNzXG4gICAgLy8gKHN0YW5kYXJkIE1hdGgucmFuZG9tKCkgY3JlYXRlcyByZXBldGl0aXZlIHBhdHRlcm5zIHdoZW4gYXBwbGllZCBvdmVyIGxhcmdlciBzcGFjZSlcblxuICAgIHJhbmRvbTE2OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gKCA2NTI4MCAqIE1hdGgucmFuZG9tKCkgKyAyNTUgKiBNYXRoLnJhbmRvbSgpICkgLyA2NTUzNTtcblxuICAgIH0sXG5cbiAgICAvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cbiAgICByYW5kSW50OiBmdW5jdGlvbiggbG93LCBoaWdoICkge1xuXG4gICAgICAgIHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XG5cbiAgICB9LFxuXG4gICAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuICAgIHJhbmRGbG9hdDogZnVuY3Rpb24oIGxvdywgaGlnaCApIHtcblxuICAgICAgICByZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xuXG4gICAgfSxcblxuICAgIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuICAgIHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24oIHJhbmdlICkge1xuXG4gICAgICAgIHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG4gICAgfSxcblxuICAgIGRlZ1RvUmFkOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZGVncmVlVG9SYWRpYW5zRmFjdG9yID0gTWF0aC5QSSAvIDE4MDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRlZ3JlZXMgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWdyZWVzICogZGVncmVlVG9SYWRpYW5zRmFjdG9yO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByYWRUb0RlZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHJhZGlhblRvRGVncmVlc0ZhY3RvciA9IDE4MCAvIE1hdGguUEk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCByYWRpYW5zICkge1xuXG4gICAgICAgICAgICByZXR1cm4gcmFkaWFucyAqIHJhZGlhblRvRGVncmVlc0ZhY3RvcjtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgaXNQb3dlck9mVHdvOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgcmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbiAgICB9LFxuXG4gICAgbmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB2YWx1ZS0tO1xuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAyO1xuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiA0O1xuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAxNjtcbiAgICAgICAgdmFsdWUrKztcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvU3BsaW5lLmpzXG5cbi8qKlxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXG4gKiBodHRwOi8vc29sZS5naXRodWIuY29tL3R3ZWVuLmpzL2V4YW1wbGVzLzA1X3NwbGluZS5odG1sXG4gKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BsaW5lID0gZnVuY3Rpb24oIHBvaW50cyApIHtcblxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgdmFyIGMgPSBbXSxcbiAgICAgICAgdjMgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHo6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcbiAgICAgICAgcGEsIHBiLCBwYywgcGQ7XG5cbiAgICB0aGlzLmluaXRGcm9tQXJyYXkgPSBmdW5jdGlvbiggYSApIHtcblxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRzWyBpIF0gPSB7XG4gICAgICAgICAgICAgICAgeDogYVsgaSBdWyAwIF0sXG4gICAgICAgICAgICAgICAgeTogYVsgaSBdWyAxIF0sXG4gICAgICAgICAgICAgICAgejogYVsgaSBdWyAyIF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbiggayApIHtcblxuICAgICAgICBwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcbiAgICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgICAgIGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG4gICAgICAgIGNbIDEgXSA9IGludFBvaW50O1xuICAgICAgICBjWyAyIF0gPSBpbnRQb2ludCA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDIgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxO1xuICAgICAgICBjWyAzIF0gPSBpbnRQb2ludCA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xuXG4gICAgICAgIHBhID0gdGhpcy5wb2ludHNbIGNbIDAgXSBdO1xuICAgICAgICBwYiA9IHRoaXMucG9pbnRzWyBjWyAxIF0gXTtcbiAgICAgICAgcGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XG4gICAgICAgIHBkID0gdGhpcy5wb2ludHNbIGNbIDMgXSBdO1xuXG4gICAgICAgIHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xuICAgICAgICB3MyA9IHdlaWdodCAqIHcyO1xuXG4gICAgICAgIHYzLnggPSBpbnRlcnBvbGF0ZSggcGEueCwgcGIueCwgcGMueCwgcGQueCwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICAgICAgdjMueSA9IGludGVycG9sYXRlKCBwYS55LCBwYi55LCBwYy55LCBwZC55LCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgICB2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XG5cbiAgICAgICAgcmV0dXJuIHYzO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q29udHJvbFBvaW50c0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjb29yZHMgPSBbXTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgcCA9IHRoaXMucG9pbnRzWyBpIF07XG4gICAgICAgICAgICBjb29yZHNbIGkgXSA9IFsgcC54LCBwLnksIHAueiBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29vcmRzO1xuXG4gICAgfTtcblxuICAgIC8vIGFwcHJveGltYXRlIGxlbmd0aCBieSBzdW1taW5nIGxpbmVhciBzZWdtZW50c1xuXG4gICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiggblN1YkRpdmlzaW9ucyApIHtcblxuICAgICAgICB2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcbiAgICAgICAgICAgIHBvaW50ID0gMCxcbiAgICAgICAgICAgIGludFBvaW50ID0gMCxcbiAgICAgICAgICAgIG9sZEludFBvaW50ID0gMCxcbiAgICAgICAgICAgIG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBjaHVua0xlbmd0aHMgPSBbXSxcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgICAgICAvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcblxuICAgICAgICBjaHVua0xlbmd0aHNbIDAgXSA9IDA7XG5cbiAgICAgICAgaWYgKCAhblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XG5cbiAgICAgICAgblNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xuXG4gICAgICAgIG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcblxuICAgICAgICBmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGluZGV4ID0gaSAvIG5TYW1wbGVzO1xuXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG4gICAgICAgICAgICB0bXBWZWMuY29weSggcG9zaXRpb24gKTtcblxuICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XG5cbiAgICAgICAgICAgIG9sZFBvc2l0aW9uLmNvcHkoIHBvc2l0aW9uICk7XG5cbiAgICAgICAgICAgIHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBpbmRleDtcbiAgICAgICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblxuICAgICAgICAgICAgaWYgKCBpbnRQb2ludCAhPT0gb2xkSW50UG9pbnQgKSB7XG5cbiAgICAgICAgICAgICAgICBjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcbiAgICAgICAgICAgICAgICBvbGRJbnRQb2ludCA9IGludFBvaW50O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxhc3QgcG9pbnQgZW5kcyB3aXRoIHRvdGFsIGxlbmd0aFxuXG4gICAgICAgIGNodW5rTGVuZ3Roc1sgY2h1bmtMZW5ndGhzLmxlbmd0aCBdID0gdG90YWxMZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNodW5rczogY2h1bmtMZW5ndGhzLFxuICAgICAgICAgICAgdG90YWw6IHRvdGFsTGVuZ3RoXG4gICAgICAgIH07XG5cbiAgICB9O1xuXG4gICAgdGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiggc2FtcGxpbmdDb2VmICkge1xuXG4gICAgICAgIHZhciBpLCBqLFxuICAgICAgICAgICAgaW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxuICAgICAgICAgICAgcmVhbERpc3RhbmNlLFxuICAgICAgICAgICAgc2FtcGxpbmcsIHBvc2l0aW9uLFxuICAgICAgICAgICAgbmV3cG9pbnRzID0gW10sXG4gICAgICAgICAgICB0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgc2wgPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIDAgXSApLmNsb25lKCkgKTtcblxuICAgICAgICBmb3IgKCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAvL3RtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSAtIDEgXSApO1xuICAgICAgICAgICAgLy9saW5lYXJEaXN0YW5jZSA9IHRtcFZlYy5kaXN0YW5jZVRvKCB0aGlzLnBvaW50c1sgaSBdICk7XG5cbiAgICAgICAgICAgIHJlYWxEaXN0YW5jZSA9IHNsLmNodW5rc1sgaSBdIC0gc2wuY2h1bmtzWyBpIC0gMSBdO1xuXG4gICAgICAgICAgICBzYW1wbGluZyA9IE1hdGguY2VpbCggc2FtcGxpbmdDb2VmICogcmVhbERpc3RhbmNlIC8gc2wudG90YWwgKTtcblxuICAgICAgICAgICAgaW5kZXhDdXJyZW50ID0gKCBpIC0gMSApIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG4gICAgICAgICAgICBpbmRleE5leHQgPSBpIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG5cbiAgICAgICAgICAgIGZvciAoIGogPSAxOyBqIDwgc2FtcGxpbmcgLSAxOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4Q3VycmVudCArIGogKiAoIDEgLyBzYW1wbGluZyApICogKCBpbmRleE5leHQgLSBpbmRleEN1cnJlbnQgKTtcblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcbiAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgXSApLmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb2ludHMgPSBuZXdwb2ludHM7XG5cbiAgICB9O1xuXG4gICAgLy8gQ2F0bXVsbC1Sb21cblxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKCBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzICkge1xuXG4gICAgICAgIHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LFxuICAgICAgICAgICAgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblxuICAgICAgICByZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLTMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1RyaWFuZ2xlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRyaWFuZ2xlID0gZnVuY3Rpb24oIGEsIGIsIGMgKSB7XG5cbiAgICB0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMuYyA9ICggYyAhPT0gdW5kZWZpbmVkICkgPyBjIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuVHJpYW5nbGUubm9ybWFsID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xuICAgICAgICB2MC5zdWJWZWN0b3JzKCBhLCBiICk7XG4gICAgICAgIHJlc3VsdC5jcm9zcyggdjAgKTtcblxuICAgICAgICB2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcbiAgICAgICAgaWYgKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHJlc3VsdExlbmd0aFNxICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcblxuICAgIH07XG5cbn0oKTtcblxuLy8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcbi8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXG5USFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBwb2ludCwgYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgdjAuc3ViVmVjdG9ycyggYywgYSApO1xuICAgICAgICB2MS5zdWJWZWN0b3JzKCBiLCBhICk7XG4gICAgICAgIHYyLnN1YlZlY3RvcnMoIHBvaW50LCBhICk7XG5cbiAgICAgICAgdmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xuICAgICAgICB2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG4gICAgICAgIHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcbiAgICAgICAgdmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xuICAgICAgICB2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cbiAgICAgICAgdmFyIGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuICAgICAgICBpZiAoIGRlbm9tID09PSAwICkge1xuXG4gICAgICAgICAgICAvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cbiAgICAgICAgICAgIC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAtMiwgLTEsIC0xICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcbiAgICAgICAgdmFyIHUgPSAoIGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyICkgKiBpbnZEZW5vbTtcbiAgICAgICAgdmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcblxuICAgICAgICAvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggMSAtIHUgLSB2LCB2LCB1ICk7XG5cbiAgICB9O1xuXG59KCk7XG5cblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIHBvaW50LCBhLCBiLCBjICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xuXG4gICAgICAgIHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcblxuICAgIH07XG5cbn0oKTtcblxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlRyaWFuZ2xlLFxuXG4gICAgc2V0OiBmdW5jdGlvbiggYSwgYiwgYyApIHtcblxuICAgICAgICB0aGlzLmEuY29weSggYSApO1xuICAgICAgICB0aGlzLmIuY29weSggYiApO1xuICAgICAgICB0aGlzLmMuY29weSggYyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xuXG4gICAgICAgIHRoaXMuYS5jb3B5KCBwb2ludHNbIGkwIF0gKTtcbiAgICAgICAgdGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuICAgICAgICB0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggdHJpYW5nbGUgKSB7XG5cbiAgICAgICAgdGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcbiAgICAgICAgdGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcbiAgICAgICAgdGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhcmVhOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdjAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcbiAgICAgICAgICAgIHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cbiAgICAgICAgICAgIHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbWlkcG9pbnQ6IGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsOiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIH0sXG5cbiAgICBwbGFuZTogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuUGxhbmUoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG4gICAgfSxcblxuICAgIGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24oIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIH0sXG5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiggcG9pbnQgKSB7XG5cbiAgICAgICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiggdHJpYW5nbGUgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0Nsb2NrLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uKCBhdXRvU3RhcnQgKSB7XG5cbiAgICB0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XG5cbiAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5vbGRUaW1lID0gMDtcbiAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5DbG9jay5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ2xvY2ssXG5cbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCA/IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuXG4gICAgICAgIHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgZ2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZ2V0RGVsdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cbiAgICB9LFxuXG4gICAgZ2V0RGVsdGE6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkaWZmID0gMDtcblxuICAgICAgICBpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICF0aGlzLnJ1bm5pbmcgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cbiAgICAgICAgICAgIHZhciBuZXdUaW1lID0gc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWQgPyBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XG4gICAgICAgICAgICB0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaWZmO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qc1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge307XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRXZlbnREaXNwYXRjaGVyLFxuXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgIG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xuICAgICAgICBvYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQ7XG5cbiAgICB9LFxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtMSApIHtcblxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLTEgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcblxuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSAtMSApIHtcblxuICAgICAgICAgICAgICAgIGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGFycmF5WyBpIF0gPSBsaXN0ZW5lckFycmF5WyBpIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvUmF5Y2FzdGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbS9cbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xuICovXG5cbiggZnVuY3Rpb24oIFRIUkVFICkge1xuXG4gICAgVEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24oIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XG5cbiAgICAgICAgdGhpcy5yYXkgPSBuZXcgVEhSRUUuUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuICAgICAgICAvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG4gICAgICAgIHRoaXMubmVhciA9IG5lYXIgfHwgMDtcbiAgICAgICAgdGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cbiAgICAgICAgdGhpcy5wYXJhbXMgPSB7XG4gICAgICAgICAgICBNZXNoOiB7fSxcbiAgICAgICAgICAgIExpbmU6IHt9LFxuICAgICAgICAgICAgTE9EOiB7fSxcbiAgICAgICAgICAgIFBvaW50czoge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNwcml0ZToge31cbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5wYXJhbXMsIHtcbiAgICAgICAgICAgIFBvaW50Q2xvdWQ6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlBvaW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gKTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZXNjU29ydCggYSwgYiApIHtcblxuICAgICAgICByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJzZWN0T2JqZWN0ID0gZnVuY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgaWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgb2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG4gICAgICAgIGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy9cblxuICAgIFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuICAgICAgICBsaW5lUHJlY2lzaW9uOiAxLFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24oIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG4gICAgICAgICAgICAvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG4gICAgICAgICAgICB0aGlzLnJheS5zZXQoIG9yaWdpbiwgZGlyZWN0aW9uICk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiggY29vcmRzLCBjYW1lcmEgKSB7XG5cbiAgICAgICAgICAgIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLTEgKS51bnByb2plY3QoIGNhbWVyYSApO1xuICAgICAgICAgICAgICAgIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0xICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIGludGVyc2VjdE9iamVjdDogZnVuY3Rpb24oIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cbiAgICAgICAgICAgIGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiggb2JqZWN0cywgcmVjdXJzaXZlICkge1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSggVEhSRUUgKSApO1xuXG4vLyBGaWxlOnNyYy9jb3JlL09iamVjdDNELmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXG4gKi9cblxuVEhSRUUuT2JqZWN0M0QgPSBmdW5jdGlvbigpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogVEhSRUUuT2JqZWN0M0RJZENvdW50KytcbiAgICB9ICk7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLnVwID0gVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICB2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xuXG4gICAgdmFyIG9uUm90YXRpb25DaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XG5cbiAgICB9O1xuXG4gICAgdmFyIG9uUXVhdGVybmlvbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XG5cbiAgICB9O1xuXG4gICAgcm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcbiAgICBxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHBvc2l0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHJvdGF0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIHF1YXRlcm5pb246IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcXVhdGVybmlvblxuICAgICAgICB9LFxuICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBzY2FsZVxuICAgICAgICB9LFxuICAgICAgICBtb2RlbFZpZXdNYXRyaXg6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpXG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1hbE1hdHJpeDoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5NYXRyaXgzKClcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gdHJ1ZTtcblxuICAgIHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xuICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXG4gICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcblxufTtcblxuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblRIUkVFLk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk9iamVjdDNELFxuXG4gICAgZ2V0IGV1bGVyT3JkZXIoKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGhhcyBiZWVuIG1vdmVkIHRvIC5yb3RhdGlvbi5vcmRlci4nICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XG5cbiAgICB9LFxuXG4gICAgc2V0IGV1bGVyT3JkZXIoIHZhbHVlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byAucm90YXRpb24ub3JkZXIuJyApO1xuXG4gICAgICAgIHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBnZXQgdXNlUXVhdGVybmlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG5cbiAgICB9LFxuXG4gICAgc2V0IHVzZVF1YXRlcm5pb24oIHZhbHVlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuICAgIH0sXG5cbiAgICBzZXQgcmVuZGVyRGVwdGgoIHZhbHVlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCBtYXRyaXggKSB7XG5cbiAgICAgICAgdGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xuXG4gICAgICAgIHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgICAgLy8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuICAgIH0sXG5cbiAgICBzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24oIGV1bGVyICkge1xuXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiggbSApIHtcblxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcblxuICAgIH0sXG5cbiAgICBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiggcSApIHtcblxuICAgICAgICAvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cbiAgICB9LFxuXG4gICAgcm90YXRlT25BeGlzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG4gICAgICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICAgICAgdmFyIHExID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG4gICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVYOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgcm90YXRlWjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGFuZ2xlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICB0cmFuc2xhdGVPbkF4aXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcbiAgICAgICAgLy8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYXhpcywgZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgIHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oIGRpc3RhbmNlLCBheGlzICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKTtcblxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGVYOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHRyYW5zbGF0ZVk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBkaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlWjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIH0sXG5cbiAgICB3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgbG9va0F0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcblxuICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggdmVjdG9yICkge1xuXG4gICAgICAgICAgICBtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xuXG4gICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICBvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSggYXJndW1lbnRzWyBpIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IC0xICkge1xuXG4gICAgICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlZCdcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldENoaWxkQnlOYW1lOiBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcblxuICAgIH0sXG5cbiAgICBnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiggaWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuICAgIH0sXG5cbiAgICBnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xuXG4gICAgfSxcblxuICAgIGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICB9LFxuXG4gICAgZ2V0V29ybGRQb3NpdGlvbjogZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgfSxcblxuICAgIGdldFdvcmxkUXVhdGVybmlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZ2V0V29ybGRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuRXVsZXIoKTtcblxuICAgICAgICAgICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZ2V0V29ybGRTY2FsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJheWNhc3Q6IGZ1bmN0aW9uKCkge30sXG5cbiAgICB0cmF2ZXJzZTogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG4gICAgICAgIGNhbGxiYWNrKCB0aGlzICk7XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRyYXZlcnNlVmlzaWJsZTogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG4gICAgICAgIGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICBjYWxsYmFjayggdGhpcyApO1xuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICBjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKCBwYXJlbnQgKTtcblxuICAgICAgICAgICAgcGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9LFxuXG4gICAgdXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uKCBmb3JjZSApIHtcblxuICAgICAgICBpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgICAgaWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgY2hpbGRyZW5cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgICAgIHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCApO1xuXG4gICAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgICAgLy8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cbiAgICAgICAgLy8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcbiAgICAgICAgLy8gYmVpbmcgc2VyaWFsaXplZC5cbiAgICAgICAgaWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgbWV0YSBvYmpcbiAgICAgICAgICAgIG1ldGEgPSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cmllczoge30sXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzOiB7fSxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlczoge30sXG4gICAgICAgICAgICAgICAgaW1hZ2VzOiB7fVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGF0YS5tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdCcsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxuXG4gICAgICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICAgICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgaWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG4gICAgICAgIGlmICggdGhpcy52aXNpYmxlICE9PSB0cnVlICkgZGF0YS52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgICAgIGRhdGEubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXG4gICAgICAgIGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICBkYXRhLmNoaWxkcmVuID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBkYXRhLmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0ge307XG5cbiAgICAgICAgaWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIHZhciBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XG4gICAgICAgICAgICBpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcblxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0Lm9iamVjdCA9IGRhdGE7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgICAgICAvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuICAgICAgICAvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXG4gICAgICAgIC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggZGF0YSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgaWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cbiAgICAgICAgdGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcbiAgICAgICAgdGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuICAgICAgICB0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHNvdXJjZS5yb3RhdGlvbkF1dG9VcGRhdGU7XG5cbiAgICAgICAgdGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuICAgICAgICB0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuICAgICAgICB0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcbiAgICAgICAgdGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XG5cbiAgICAgICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XG4gICAgICAgIHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XG5cbiAgICAgICAgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xuXG4gICAgICAgIGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuT2JqZWN0M0RJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvY29yZS9GYWNlMy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZhY2UzID0gZnVuY3Rpb24oIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG4gICAgdGhpcy5jID0gYztcblxuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy52ZXJ0ZXhOb3JtYWxzID0gQXJyYXkuaXNBcnJheSggbm9ybWFsICkgPyBub3JtYWwgOiBbXTtcblxuICAgIHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IEFycmF5LmlzQXJyYXkoIGNvbG9yICkgPyBjb2xvciA6IFtdO1xuXG4gICAgdGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cbn07XG5cblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5GYWNlMyxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB0aGlzLmEgPSBzb3VyY2UuYTtcbiAgICAgICAgdGhpcy5iID0gc291cmNlLmI7XG4gICAgICAgIHRoaXMuYyA9IHNvdXJjZS5jO1xuXG4gICAgICAgIHRoaXMubm9ybWFsLmNvcHkoIHNvdXJjZS5ub3JtYWwgKTtcbiAgICAgICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgICAgICB0aGlzLm1hdGVyaWFsSW5kZXggPSBzb3VyY2UubWF0ZXJpYWxJbmRleDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSBzb3VyY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4Q29sb3JzWyBpIF0gPSBzb3VyY2UudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24oIGEsIGIsIGMsIGQsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cbiAgICB0aGlzLmR5bmFtaWMgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlID0ge1xuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGNvdW50OiAtMVxuICAgIH07XG5cbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuXG59O1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSxcblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgLmNvdW50LicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuXG4gICAgfSxcblxuICAgIGdldCBjb3VudCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggLyB0aGlzLml0ZW1TaXplO1xuXG4gICAgfSxcblxuICAgIHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbisrO1xuXG4gICAgfSxcblxuICAgIHNldER5bmFtaWM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IHNvdXJjZS5pdGVtU2l6ZTtcblxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5QXQ6IGZ1bmN0aW9uKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG4gICAgICAgIGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xuICAgICAgICBpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5QXJyYXk6IGZ1bmN0aW9uKCBhcnJheSApIHtcblxuICAgICAgICB0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5Q29sb3JzQXJyYXk6IGZ1bmN0aW9uKCBjb2xvcnMgKSB7XG5cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgICAgICAgICAgICAgIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSBjb2xvci5yO1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSBjb2xvci5nO1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSBjb2xvci5iO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5SW5kaWNlc0FycmF5OiBmdW5jdGlvbiggaW5kaWNlcyApIHtcblxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5kaWNlc1sgaSBdO1xuXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IGluZGV4LmE7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IGluZGV4LmI7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IGluZGV4LmM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiggdmVjdG9ycyApIHtcblxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgICAgICAgICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IueDtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLnk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvcHlWZWN0b3Izc0FycmF5OiBmdW5jdGlvbiggdmVjdG9ycyApIHtcblxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgICAgICAgICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IueDtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLnk7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci56O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24oIHZlY3RvcnMgKSB7XG5cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLng7XG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0KysgXSA9IHZlY3Rvci55O1xuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCsrIF0gPSB2ZWN0b3IuejtcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQrKyBdID0gdmVjdG9yLnc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBnZXRYOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xuXG4gICAgfSxcblxuICAgIHNldFg6IGZ1bmN0aW9uKCBpbmRleCwgeCApIHtcblxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0WTogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XG5cbiAgICB9LFxuXG4gICAgc2V0WTogZnVuY3Rpb24oIGluZGV4LCB5ICkge1xuXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0WjogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF07XG5cbiAgICB9LFxuXG4gICAgc2V0WjogZnVuY3Rpb24oIGluZGV4LCB6ICkge1xuXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgZ2V0VzogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XG5cbiAgICB9LFxuXG4gICAgc2V0VzogZnVuY3Rpb24oIGluZGV4LCB3ICkge1xuXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WFk6IGZ1bmN0aW9uKCBpbmRleCwgeCwgeSApIHtcblxuICAgICAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFhZWjogZnVuY3Rpb24oIGluZGV4LCB4LCB5LCB6ICkge1xuXG4gICAgICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRYWVpXOiBmdW5jdGlvbiggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cbiAgICAgICAgaW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH1cblxufTtcblxuLy9cblxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDhBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuSW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuSW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuXG4vLyBEZXByZWNhdGVkXG5cblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSgpLnNldER5bmFtaWMoIHRydWUgKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkuc2V0RHluYW1pYyggdHJ1ZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbVNpemUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgYXJyYXksIGl0ZW1TaXplICk7XG5cbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24oIGFycmF5LCBzdHJpZGUgKSB7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuXG4gICAgdGhpcy5keW5hbWljID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVSYW5nZSA9IHtcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBjb3VudDogLTFcbiAgICB9O1xuXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcblxufTtcblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkludGVybGVhdmVkQnVmZmVyLFxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgICB9LFxuXG4gICAgZ2V0IGNvdW50KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCAvIHRoaXMuc3RyaWRlO1xuXG4gICAgfSxcblxuICAgIHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbisrO1xuXG4gICAgfSxcblxuICAgIHNldER5bmFtaWM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcbiAgICAgICAgdGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xuICAgICAgICB0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcblxuICAgIH0sXG5cbiAgICBjb3B5QXQ6IGZ1bmN0aW9uKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG4gICAgICAgIGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcbiAgICAgICAgaW5kZXgyICo9IGF0dHJpYnV0ZS5zdHJpZGU7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24oIGFycmF5LCBzdHJpZGUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5jYWxsKCB0aGlzLCBhcnJheSwgc3RyaWRlICk7XG5cbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSApO1xuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI7XG5cblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24oIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0ICkge1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xuICAgIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcblxufTtcblxuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsXG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICAgIH0sXG5cbiAgICBnZXQgY291bnQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheS5sZW5ndGggLyB0aGlzLmRhdGEuc3RyaWRlO1xuXG4gICAgfSxcblxuICAgIHNldFg6IGZ1bmN0aW9uKCBpbmRleCwgeCApIHtcblxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFk6IGZ1bmN0aW9uKCBpbmRleCwgeSApIHtcblxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzZXRaOiBmdW5jdGlvbiggaW5kZXgsIHogKSB7XG5cbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXSA9IHo7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0VzogZnVuY3Rpb24oIGluZGV4LCB3ICkge1xuXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGdldFg6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xuXG4gICAgfSxcblxuICAgIGdldFk6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXTtcblxuICAgIH0sXG5cbiAgICBnZXRaOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF07XG5cbiAgICB9LFxuXG4gICAgZ2V0VzogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xuXG4gICAgfSxcblxuICAgIHNldFhZOiBmdW5jdGlvbiggaW5kZXgsIHgsIHkgKSB7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0WFlaOiBmdW5jdGlvbiggaW5kZXgsIHgsIHksIHogKSB7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNldFhZWlc6IGZ1bmN0aW9uKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuICAgICAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50KytcbiAgICB9ICk7XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy50eXBlID0gJ0dlb21ldHJ5JztcblxuICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgIHRoaXMuZmFjZXMgPSBbXTtcbiAgICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbXG4gICAgICAgIFtdXG4gICAgXTtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gW107XG4gICAgdGhpcy5tb3JwaENvbG9ycyA9IFtdO1xuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gW107XG5cbiAgICB0aGlzLnNraW5XZWlnaHRzID0gW107XG4gICAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gICAgdGhpcy5saW5lRGlzdGFuY2VzID0gW107XG5cbiAgICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICAgIC8vIHVwZGF0ZSBmbGFnc1xuXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5HZW9tZXRyeSxcblxuICAgIGFwcGx5TWF0cml4OiBmdW5jdGlvbiggbWF0cml4ICkge1xuXG4gICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcbiAgICAgICAgICAgIHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcbiAgICAgICAgICAgIGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICB9LFxuXG4gICAgcm90YXRlWDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVZOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBzY2FsZSBnZW9tZXRyeVxuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBsb29rQXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBvYmo7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG4gICAgICAgICAgICBpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgICAgICAgICAgIG9iai5sb29rQXQoIHZlY3RvciApO1xuXG4gICAgICAgICAgICBvYmoudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgZnJvbUJ1ZmZlckdlb21ldHJ5OiBmdW5jdGlvbiggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2LmFycmF5IDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdXZzMiA9IGF0dHJpYnV0ZXMudXYyICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2Mi5hcnJheSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gW107XG5cbiAgICAgICAgdmFyIHRlbXBOb3JtYWxzID0gW107XG4gICAgICAgIHZhciB0ZW1wVVZzID0gW107XG4gICAgICAgIHZhciB0ZW1wVVZzMiA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDMsIGogKz0gMiwgayArPSA0ICkge1xuXG4gICAgICAgICAgICBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIHZlcnRpY2VzWyBpICsgMiBdICkgKTtcblxuICAgICAgICAgICAgaWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdGVtcFVWcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZzWyBqIF0sIHV2c1sgaiArIDEgXSApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZW1wVVZzMi5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZzMlsgaiBdLCB1dnMyWyBqICsgMSBdICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWRkRmFjZSA9IGZ1bmN0aW9uKCBhLCBiLCBjICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XG4gICAgICAgICAgICB2YXIgdmVydGV4Q29sb3JzID0gY29sb3JzICE9PSB1bmRlZmluZWQgPyBbIHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYiBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgdmVydGV4Tm9ybWFscywgdmVydGV4Q29sb3JzICk7XG5cbiAgICAgICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgICAgICAgICAgaWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMSBdLnB1c2goIFsgdGVtcFVWczJbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYiBdLmNsb25lKCksIHRlbXBVVnMyWyBjIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgICAgICAgICBpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICBhZGRGYWNlKCBpbmRpY2VzWyBpIF0sIGluZGljZXNbIGkgKyAxIF0sIGluZGljZXNbIGkgKyAyIF0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgIGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuXG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcblxuICAgICAgICB2YXIgcyA9IHJhZGl1cyA9PT0gMCA/IDEgOiAxLjAgLyByYWRpdXM7XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICAgIG1hdHJpeC5zZXQoXG4gICAgICAgICAgICBzLCAwLCAwLCAtcyAqIGNlbnRlci54LFxuICAgICAgICAgICAgMCwgcywgMCwgLXMgKiBjZW50ZXIueSxcbiAgICAgICAgICAgIDAsIDAsIHMsIC1zICogY2VudGVyLnosXG4gICAgICAgICAgICAwLCAwLCAwLCAxXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIGZvciAoIHZhciBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgICAgICAgdmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG4gICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICAgICAgY2Iubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiggYXJlYVdlaWdodGVkICkge1xuXG4gICAgICAgIHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xuXG4gICAgICAgIHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xuXG4gICAgICAgIGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYrKyApIHtcblxuICAgICAgICAgICAgdmVydGljZXNbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYXJlYVdlaWdodGVkICkge1xuXG4gICAgICAgICAgICAvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvbm9ybWFscy9ub3JtYWxzLmh0bVxuXG4gICAgICAgICAgICB2YXIgdkEsIHZCLCB2QztcbiAgICAgICAgICAgIHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICAgICAgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgICAgICAgICAgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICAgICAgICAgICAgICB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgICAgICAgICAgIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICAgICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcbiAgICAgICAgICAgICAgICBhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcbiAgICAgICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYiBdLmFkZCggZmFjZS5ub3JtYWwgKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYrKyApIHtcblxuICAgICAgICAgICAgdmVydGljZXNbIHYgXS5ub3JtYWxpemUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgICAgICAgICAgaWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggdmVydGljZXNbIGZhY2UuYiBdICk7XG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XG5cbiAgICAgICAgLy8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXG4gICAgICAgIC8vIC0gY3JlYXRlIHRlbXAgdmFyaWFibGVzIG9uIGZpcnN0IGFjY2Vzc1xuICAgICAgICAvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXG5cbiAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgICAgICBpZiAoICFmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggIWZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxuXG4gICAgICAgIHZhciB0bXBHZW8gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgdG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXG5cbiAgICAgICAgICAgIGlmICggIXRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcbiAgICAgICAgICAgICAgICB2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcblxuICAgICAgICAgICAgICAgIHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgICAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VOb3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjOiBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xuICAgICAgICAgICAgICAgICAgICBkc3ROb3JtYWxzVmVydGV4LnB1c2goIHZlcnRleE5vcm1hbHMgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcblxuICAgICAgICAgICAgLy8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxuXG4gICAgICAgICAgICB0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG4gICAgICAgICAgICAvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcblxuICAgICAgICAgICAgdG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgICAgICAgdG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcblxuICAgICAgICAgICAgdmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgICAgICAgICBmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFscy52ZXJ0ZXhOb3JtYWxzWyBmIF07XG5cbiAgICAgICAgICAgICAgICBmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcblxuICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgICAgIGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcbiAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH0sXG5cbiAgICBjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICBpZiAoIGkgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcblxuICAgIH0sXG5cbiAgICBtZXJnZTogZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5HZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9ybWFsTWF0cml4LFxuICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICB2ZXJ0aWNlczEgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICAgICAgdmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXG4gICAgICAgICAgICBmYWNlczEgPSB0aGlzLmZhY2VzLFxuICAgICAgICAgICAgZmFjZXMyID0gZ2VvbWV0cnkuZmFjZXMsXG4gICAgICAgICAgICB1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXG4gICAgICAgICAgICB1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXJ0aWNlc1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlczIubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xuXG4gICAgICAgICAgICBpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYWNlc1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLFxuICAgICAgICAgICAgICAgIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxuICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxuICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgICAgICAgICAgZmFjZUNvcHkgPSBuZXcgVEhSRUUuRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcbiAgICAgICAgICAgIGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG4gICAgICAgICAgICBpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmFjZUNvcHkudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Q29sb3JzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcbiAgICAgICAgICAgICAgICBmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXggKyBtYXRlcmlhbEluZGV4T2Zmc2V0O1xuXG4gICAgICAgICAgICBmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXZzXG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdXYgPSB1dnMyWyBpIF0sXG4gICAgICAgICAgICAgICAgdXZDb3B5ID0gW107XG5cbiAgICAgICAgICAgIGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHV2czEucHVzaCggdXZDb3B5ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1lcmdlTWVzaDogZnVuY3Rpb24oIG1lc2ggKSB7XG5cbiAgICAgICAgaWYgKCBtZXNoIGluc3RhbmNlb2YgVEhSRUUuTWVzaCA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZU1lc2goKTogbWVzaCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuTWVzaC4nLCBtZXNoICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lc2gubWF0cml4QXV0b1VwZGF0ZSAmJiBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICAgIHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XG5cbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXG4gICAgICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuICAgICAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXG4gICAgICovXG5cbiAgICBtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcbiAgICAgICAgdmFyIHVuaXF1ZSA9IFtdLFxuICAgICAgICAgICAgY2hhbmdlcyA9IFtdO1xuXG4gICAgICAgIHZhciB2LCBrZXk7XG4gICAgICAgIHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG4gICAgICAgIHZhciBpLCBpbCwgZmFjZTtcbiAgICAgICAgdmFyIGluZGljZXMsIGosIGpsO1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdiA9IHRoaXMudmVydGljZXNbIGkgXTtcbiAgICAgICAgICAgIGtleSA9IE1hdGgucm91bmQoIHYueCAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi55ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnogKiBwcmVjaXNpb24gKTtcblxuICAgICAgICAgICAgaWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XG4gICAgICAgICAgICAgICAgdW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xuICAgICAgICAgICAgICAgIGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXG4gICAgICAgIHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG4gICAgICAgICAgICBmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcbiAgICAgICAgICAgIGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xuICAgICAgICAgICAgZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XG5cbiAgICAgICAgICAgIGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcblxuICAgICAgICAgICAgdmFyIGR1cEluZGV4ID0gLTE7XG5cbiAgICAgICAgICAgIC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXG4gICAgICAgICAgICBmb3IgKCB2YXIgbiA9IDA7IG4gPCAzOyBuKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluZGljZXNbIG4gXSA9PT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGR1cEluZGV4ID0gbjtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGljZXNUb1JlbW92ZS5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnNwbGljZSggaWR4LCAxICk7XG5cbiAgICAgICAgICAgIGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xuXG4gICAgICAgIHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xuICAgICAgICByZXR1cm4gZGlmZjtcblxuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0dlb21ldHJ5JyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG4gICAgICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICAgICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgICAgaWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmYWNlcyA9IFtdO1xuICAgICAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgICAgICB2YXIgbm9ybWFsc0hhc2ggPSB7fTtcbiAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgICAgICB2YXIgY29sb3JzSGFzaCA9IHt9O1xuICAgICAgICB2YXIgdXZzID0gW107XG4gICAgICAgIHZhciB1dnNIYXNoID0ge307XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cbiAgICAgICAgICAgIHZhciBoYXNNYXRlcmlhbCA9IGZhbHNlOyAvLyBmYWNlLm1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBoYXNGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwubGVuZ3RoKCkgPiAwO1xuICAgICAgICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHZhciBoYXNGYWNlQ29sb3IgPSBmYWNlLmNvbG9yLnIgIT09IDEgfHwgZmFjZS5jb2xvci5nICE9PSAxIHx8IGZhY2UuY29sb3IuYiAhPT0gMTtcbiAgICAgICAgICAgIHZhciBoYXNGYWNlVmVydGV4Q29sb3IgPSBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgICB2YXIgZmFjZVR5cGUgPSAwO1xuXG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTtcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMiwgaGFzRmFjZVV2ICk7XG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDUsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKTtcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xuXG4gICAgICAgICAgICBmYWNlcy5wdXNoKCBmYWNlVHlwZSApO1xuICAgICAgICAgICAgZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xuXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgICAgICAgICAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDAgXSApLFxuICAgICAgICAgICAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAxIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goIGdldE5vcm1hbEluZGV4KCBmYWNlLm5vcm1hbCApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXG4gICAgICAgICAgICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDIgXSApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAyIF0gKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+KCAxIDw8IHBvc2l0aW9uICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Tm9ybWFsSW5kZXgoIG5vcm1hbCApIHtcblxuICAgICAgICAgICAgdmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmICggbm9ybWFsc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgIG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XG5cbiAgICAgICAgICAgIHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAoIGNvbG9yc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xvcnNIYXNoWyBoYXNoIF0gPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICAgICAgY29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFV2SW5kZXgoIHV2ICkge1xuXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICB1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmRhdGEgPSB7fTtcblxuICAgICAgICBkYXRhLmRhdGEudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xuICAgICAgICBpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcbiAgICAgICAgaWYgKCB1dnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS51dnMgPSBbIHV2cyBdOyAvLyB0ZW1wb3JhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gW107XG4gICAgICAgIHRoaXMuZmFjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzID0gW1xuICAgICAgICAgICAgW11cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmYWNlcyA9IHNvdXJjZS5mYWNlcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBmYWNlc1sgaSBdLmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSxcbiAgICAgICAgICAgICAgICAgICAgdXZzQ29weSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwLCBrbCA9IHV2cy5sZW5ndGg7IGsgPCBrbDsgaysrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1diA9IHV2c1sgayBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICAgIH0gKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblRIUkVFLkdlb21ldHJ5SWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL2NvcmUvRGlyZWN0R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkRpcmVjdEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCsrXG4gICAgfSApO1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMudHlwZSA9ICdEaXJlY3RHZW9tZXRyeSc7XG5cbiAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG4gICAgdGhpcy5ub3JtYWxzID0gW107XG4gICAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgICB0aGlzLnV2cyA9IFtdO1xuICAgIHRoaXMudXZzMiA9IFtdO1xuXG4gICAgdGhpcy5ncm91cHMgPSBbXTtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0ge307XG5cbiAgICB0aGlzLnNraW5XZWlnaHRzID0gW107XG4gICAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gICAgLy8gdGhpcy5saW5lRGlzdGFuY2VzID0gW107XG5cbiAgICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICAgIC8vIHVwZGF0ZSBmbGFnc1xuXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5EaXJlY3RHZW9tZXRyeSxcblxuICAgIGNvbXB1dGVCb3VuZGluZ0JveDogVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ0JveCxcbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdTcGhlcmUsXG5cbiAgICBjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlRmFjZU5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcblxuICAgIH0sXG5cbiAgICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZUdyb3VwczogZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciBncm91cDtcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICB2YXIgbWF0ZXJpYWxJbmRleDtcblxuICAgICAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgICAgICAvLyBtYXRlcmlhbHNcblxuICAgICAgICAgICAgaWYgKCBmYWNlLm1hdGVyaWFsSW5kZXggIT09IG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpICogMyxcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xuICAgICAgICAgICAgZ3JvdXBzLnB1c2goIGdyb3VwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuXG4gICAgfSxcblxuICAgIGZyb21HZW9tZXRyeTogZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xuXG4gICAgICAgIHZhciBoYXNGYWNlVmVydGV4VXYgPSBmYWNlVmVydGV4VXZzWyAwIF0gJiYgZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDA7XG4gICAgICAgIHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xuXG4gICAgICAgIC8vIG1vcnBoc1xuXG4gICAgICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XG4gICAgICAgIHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgIGlmICggbW9ycGhUYXJnZXRzTGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRzLnBvc2l0aW9uID0gbW9ycGhUYXJnZXRzUG9zaXRpb247XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XG4gICAgICAgIHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xuXG4gICAgICAgIGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0c05vcm1hbCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0c05vcm1hbFsgaSBdID0gW107XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMubm9ybWFsID0gbW9ycGhUYXJnZXRzTm9ybWFsO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBza2luc1xuXG4gICAgICAgIHZhciBza2luSW5kaWNlcyA9IGdlb21ldHJ5LnNraW5JbmRpY2VzO1xuICAgICAgICB2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcblxuICAgICAgICB2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIGhhc1NraW5XZWlnaHRzID0gc2tpbldlaWdodHMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgICAgIGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHMucHVzaCggdmVydGV4Tm9ybWFsc1sgMCBdLCB2ZXJ0ZXhOb3JtYWxzWyAxIF0sIHZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcblxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5wdXNoKCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG4gICAgICAgICAgICBpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dnMucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdjIgJywgaSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXZzMi5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW9ycGhzXG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBqIF0udmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGorKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaiBdLnZlcnRleE5vcm1hbHNbIGkgXTtcblxuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0c05vcm1hbFsgaiBdLnB1c2goIG1vcnBoTm9ybWFsLmEsIG1vcnBoTm9ybWFsLmIsIG1vcnBoTm9ybWFsLmMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBza2luc1xuXG4gICAgICAgICAgICBpZiAoIGhhc1NraW5JbmRpY2VzICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBoYXNTa2luV2VpZ2h0cyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGZhY2UuYSBdLCBza2luV2VpZ2h0c1sgZmFjZS5iIF0sIHNraW5XZWlnaHRzWyBmYWNlLmMgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcHV0ZUdyb3VwcyggZ2VvbWV0cnkgKTtcblxuICAgICAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcbiAgICAgICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuICAgICAgICB0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuICAgICAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuICAgICAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICAgIH0gKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQrK1xuICAgIH0gKTtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLnR5cGUgPSAnQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgdGhpcy5pbmRleCA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgICB0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgdGhpcy5ncm91cHMgPSBbXTtcblxuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG4gICAgdGhpcy5kcmF3UmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBjb3VudDogSW5maW5pdHlcbiAgICB9O1xuXG59O1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnksXG5cbiAgICBhZGRJbmRleDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkSW5kZXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRJbmRleCgpLicgKTtcbiAgICAgICAgdGhpcy5zZXRJbmRleCggaW5kZXggKTtcblxuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG5cbiAgICB9LFxuXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICB9LFxuXG4gICAgYWRkQXR0cmlidXRlOiBmdW5jdGlvbiggbmFtZSwgYXR0cmlidXRlICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSAmJiBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKSApO1xuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuYWRkQXR0cmlidXRlOiBVc2UgLnNldEluZGV4KCkgZm9yIGluZGV4IGF0dHJpYnV0ZS4nICk7XG4gICAgICAgICAgICB0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XG5cbiAgICB9LFxuXG4gICAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICB9LFxuXG4gICAgcmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICB9LFxuXG4gICAgZ2V0IGRyYXdjYWxscygpIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzO1xuXG4gICAgfSxcblxuICAgIGdldCBvZmZzZXRzKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAub2Zmc2V0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHM7XG5cbiAgICB9LFxuXG4gICAgYWRkRHJhd0NhbGw6IGZ1bmN0aW9uKCBzdGFydCwgY291bnQsIGluZGV4T2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggaW5kZXhPZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIG5vIGxvbmdlciBzdXBwb3J0cyBpbmRleE9mZnNldC4nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBpcyBub3cgLmFkZEdyb3VwKCkuJyApO1xuICAgICAgICB0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcblxuICAgIH0sXG5cbiAgICBjbGVhckRyYXdDYWxsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jbGVhckRyYXdDYWxscygpIGlzIG5vdyAuY2xlYXJHcm91cHMoKS4nICk7XG4gICAgICAgIHRoaXMuY2xlYXJHcm91cHMoKTtcblxuICAgIH0sXG5cbiAgICBhZGRHcm91cDogZnVuY3Rpb24oIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgICAgICB0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgIG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXG5cbiAgICAgICAgfSApO1xuXG4gICAgfSxcblxuICAgIGNsZWFyR3JvdXBzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmdyb3VwcyA9IFtdO1xuXG4gICAgfSxcblxuICAgIHNldERyYXdSYW5nZTogZnVuY3Rpb24oIHN0YXJ0LCBjb3VudCApIHtcblxuICAgICAgICB0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xuXG4gICAgfSxcblxuICAgIGFwcGx5TWF0cml4OiBmdW5jdGlvbiggbWF0cml4ICkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBwb3NpdGlvbi5hcnJheSApO1xuICAgICAgICAgICAgcG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgICAgICBpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgICAgICAgICBub3JtYWxNYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggbm9ybWFsLmFycmF5ICk7XG4gICAgICAgICAgICBub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcm90YXRlWDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICByb3RhdGVZOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cbiAgICAgICAgdmFyIG0xO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuICAgICAgICB2YXIgbTE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICBtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBzY2FsZSBnZW9tZXRyeVxuXG4gICAgICAgIHZhciBtMTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICAgICAgbTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KCksXG5cbiAgICBsb29rQXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBvYmo7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG4gICAgICAgICAgICBpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgICAgICAgICAgIG9iai5sb29rQXQoIHZlY3RvciApO1xuXG4gICAgICAgICAgICBvYmoudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY2VudGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMywgMyApO1xuXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZURpc3RhbmNlcyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCwgMSApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBsaW5lRGlzdGFuY2VzLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuICAgICAgICAgICAgdmFyIGRpcmVjdCA9IGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnk7XG5cbiAgICAgICAgICAgIGlmICggZGlyZWN0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcbiAgICAgICAgICAgIGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuICAgICAgICAgICAgZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuICAgICAgICAgICAgZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuICAgICAgICAgICAgZGlyZWN0Lmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xuXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZGlyZWN0O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xuXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xuXG4gICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlR3JvdXBzKCBvYmplY3QuZ2VvbWV0cnkgKTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgICAgICAgICBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGZyb21HZW9tZXRyeTogZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG4gICAgICAgIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgVEhSRUUuRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XG5cbiAgICB9LFxuXG4gICAgZnJvbURpcmVjdEdlb21ldHJ5OiBmdW5jdGlvbiggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKiAzICk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMyApO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2cy5sZW5ndGggKiAyICk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkudXZzMi5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgdXZzMiA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2czIubGVuZ3RoICogMiApO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1djInLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMyLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2czIgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIFR5cGVBcnJheSA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XG4gICAgICAgICAgICB0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdyb3Vwc1xuXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgICAgIC8vIG1vcnBoc1xuXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcblxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xuXG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCggYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBtb3JwaFRhcmdldCApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBza2lubmluZ1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgdmFyIHNraW5JbmRpY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAqIDQsIDQgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbkluZGV4Jywgc2tpbkluZGljZXMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5JbmRpY2VzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgc2tpbldlaWdodHMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdza2luV2VpZ2h0Jywgc2tpbldlaWdodHMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5XZWlnaHRzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICBpZiAoIHBvc2l0aW9ucyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3g7XG4gICAgICAgICAgICAgICAgYmIubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgICAgICAgICAgIGJiLmV4cGFuZEJ5UG9pbnQoIHZlY3RvciApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggcG9zaXRpb25zID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3gubWluLnNldCggMCwgMCwgMCApO1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3gubWF4LnNldCggMCwgMCwgMCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94OiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgfSgpLFxuXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgIGlmICggcG9zaXRpb25zICkge1xuXG4gICAgICAgICAgICAgICAgYm94Lm1ha2VFbXB0eSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgICAgICAgICAgICBib3guZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib3guY2VudGVyKCBjZW50ZXIgKTtcblxuICAgICAgICAgICAgICAgIC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG4gICAgICAgICAgICAgICAgdmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgIH0oKSxcblxuICAgIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICAgIH0sXG5cbiAgICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9ucy5sZW5ndGggKSwgMyApICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXG5cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpIF0gPSAwO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICAgICAgICAgIHZhciB2QSwgdkIsIHZDLFxuXG4gICAgICAgICAgICAgICAgcEEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgICAgIHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgICAgICBwQyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgICAgICAgICAgICBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICAgICAgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICAvLyBpbmRleGVkIGVsZW1lbnRzXG5cbiAgICAgICAgICAgIGlmICggaW5kZXggKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArK2ogKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBqIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdkMgPSBpbmRpY2VzWyBpICsgMiBdICogMztcblxuICAgICAgICAgICAgICAgICAgICAgICAgcEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZBICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY3Jvc3MoIGFiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QiBdICs9IGNiLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkMgXSArPSBjYi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZDICsgMiBdICs9IGNiLno7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgICAgICAgICAgIHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xuICAgICAgICAgICAgICAgICAgICBwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDYgKTtcblxuICAgICAgICAgICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcbiAgICAgICAgICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgXSA9IGNiLng7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAxIF0gPSBjYi55O1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgMiBdID0gY2IuejtcblxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgMyBdID0gY2IueDtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA1IF0gPSBjYi56O1xuXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA2IF0gPSBjYi54O1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgNyBdID0gY2IueTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDggXSA9IGNiLno7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7XG5cbiAgICAgICAgICAgIGF0dHJpYnV0ZXMubm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiggc2l6ZSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVPZmZzZXRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nIClcblxuICAgIH0sXG5cbiAgICBtZXJnZTogZnVuY3Rpb24oIGdlb21ldHJ5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUyID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF07XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGUyLml0ZW1TaXplO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBhdHRyaWJ1dGVTaXplICogb2Zmc2V0OyBpIDwgYXR0cmlidXRlQXJyYXkyLmxlbmd0aDsgaSsrLCBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZU5vcm1hbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgICAgICB2YXIgeCwgeSwgeiwgbjtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICB4ID0gbm9ybWFsc1sgaSBdO1xuICAgICAgICAgICAgeSA9IG5vcm1hbHNbIGkgKyAxIF07XG4gICAgICAgICAgICB6ID0gbm9ybWFsc1sgaSArIDIgXTtcblxuICAgICAgICAgICAgbiA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XG5cbiAgICAgICAgICAgIG5vcm1hbHNbIGkgXSAqPSBuO1xuICAgICAgICAgICAgbm9ybWFsc1sgaSArIDEgXSAqPSBuO1xuICAgICAgICAgICAgbm9ybWFsc1sgaSArIDIgXSAqPSBuO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0J1ZmZlckdlb21ldHJ5JyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG4gICAgICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICAgICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgICAgaWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZGF0YSA9IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggaW5kZXguYXJyYXkgKTtcblxuICAgICAgICAgICAgZGF0YS5kYXRhLmluZGV4ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJyYXk6IGFycmF5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuICAgICAgICAgICAgdmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xuXG4gICAgICAgICAgICBkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XG4gICAgICAgICAgICAgICAgaXRlbVNpemU6IGF0dHJpYnV0ZS5pdGVtU2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuICAgICAgICBpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICBkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cbiAgICAgICAgaWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xuICAgICAgICAgICAgICAgIGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcbiAgICAgICAgICAgIHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgICB9ICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDY1NTM1O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XG4gICAgdGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IHVuZGVmaW5lZDtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24oIHN0YXJ0LCBjb3VudCwgaW5zdGFuY2VzICkge1xuXG4gICAgdGhpcy5ncm91cHMucHVzaCgge1xuXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlc1xuXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICB2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XG5cbiAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgIHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcblxuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xuXG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuICAgICAgICB0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLmluc3RhbmNlcyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblxuICAgIHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG59O1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0xICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICB9O1xuXG59KCk7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBjYW1lcmFzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcblxuICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIHZlY3RvciApIHtcblxuICAgICAgICBtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xuXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cbiAgICB9O1xuXG59KCk7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvQ3ViZUNhbWVyYS5qc1xuXG4vKipcbiAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xuICpcdC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXG4gKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5DdWJlQ2FtZXJhID0gZnVuY3Rpb24oIG5lYXIsIGZhciwgY3ViZVJlc29sdXRpb24gKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XG5cbiAgICB2YXIgZm92ID0gOTAsXG4gICAgICAgIGFzcGVjdCA9IDE7XG5cbiAgICB2YXIgY2FtZXJhUFggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBjYW1lcmFQWC51cC5zZXQoIDAsIC0xLCAwICk7XG4gICAgY2FtZXJhUFgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApICk7XG4gICAgdGhpcy5hZGQoIGNhbWVyYVBYICk7XG5cbiAgICB2YXIgY2FtZXJhTlggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBjYW1lcmFOWC51cC5zZXQoIDAsIC0xLCAwICk7XG4gICAgY2FtZXJhTlgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggLTEsIDAsIDAgKSApO1xuICAgIHRoaXMuYWRkKCBjYW1lcmFOWCApO1xuXG4gICAgdmFyIGNhbWVyYVBZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgY2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XG4gICAgY2FtZXJhUFkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XG4gICAgdGhpcy5hZGQoIGNhbWVyYVBZICk7XG5cbiAgICB2YXIgY2FtZXJhTlkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBjYW1lcmFOWS51cC5zZXQoIDAsIDAsIC0xICk7XG4gICAgY2FtZXJhTlkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTEsIDAgKSApO1xuICAgIHRoaXMuYWRkKCBjYW1lcmFOWSApO1xuXG4gICAgdmFyIGNhbWVyYVBaID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgY2FtZXJhUFoudXAuc2V0KCAwLCAtMSwgMCApO1xuICAgIGNhbWVyYVBaLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSApO1xuICAgIHRoaXMuYWRkKCBjYW1lcmFQWiApO1xuXG4gICAgdmFyIGNhbWVyYU5aID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgY2FtZXJhTloudXAuc2V0KCAwLCAtMSwgMCApO1xuICAgIGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0xICkgKTtcbiAgICB0aGlzLmFkZCggY2FtZXJhTlogKTtcblxuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCB7XG4gICAgICAgIGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LFxuICAgICAgICBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlcixcbiAgICAgICAgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXJcbiAgICB9ICk7XG5cbiAgICB0aGlzLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiggcmVuZGVyZXIsIHNjZW5lICkge1xuXG4gICAgICAgIGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgICAgICB2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcztcblxuICAgICAgICByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAyO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDU7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcblxuICAgIH07XG5cbn07XG5cblRIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVDYW1lcmE7XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgPSBmdW5jdGlvbiggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cbiAgICBUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5cbiAgICB0aGlzLnpvb20gPSAxO1xuXG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG5cbiAgICB0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcbiAgICB0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDIwMDA7XG5cbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmE7XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGR4ID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcbiAgICB2YXIgZHkgPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvICggMiAqIHRoaXMuem9vbSApO1xuICAgIHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcbiAgICB2YXIgY3kgPSAoIHRoaXMudG9wICsgdGhpcy5ib3R0b20gKSAvIDI7XG5cbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggY3ggLSBkeCwgY3ggKyBkeCwgY3kgKyBkeSwgY3kgLSBkeSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcbiAgICB0aGlzLnRvcCA9IHNvdXJjZS50b3A7XG4gICAgdGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xuICAgIHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuICAgIHRoaXMuZmFyID0gc291cmNlLmZhcjtcblxuICAgIHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcbiAgICBkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgICBkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcbiAgICBkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcbiAgICBkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuICAgIGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBncmVnZ21hbiAvIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuICAgIFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG4gICAgdGhpcy56b29tID0gMTtcblxuICAgIHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcbiAgICB0aGlzLmFzcGVjdCA9IGFzcGVjdCAhPT0gdW5kZWZpbmVkID8gYXNwZWN0IDogMTtcbiAgICB0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xuICAgIHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xuXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhO1xuXG5cbi8qKlxuICogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxuICogMzVtbSAoZnVsbC1mcmFtZSkgY2FtZXJhIGlzIHVzZWQgaWYgZnJhbWUgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkO1xuICogRm9ybXVsYSBiYXNlZCBvbiBodHRwOi8vd3d3LmJvYmF0a2lucy5jb20vcGhvdG9ncmFwaHkvdGVjaG5pY2FsL2ZpZWxkX29mX3ZpZXcuaHRtbFxuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRMZW5zID0gZnVuY3Rpb24oIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcblxuICAgIGlmICggZnJhbWVIZWlnaHQgPT09IHVuZGVmaW5lZCApIGZyYW1lSGVpZ2h0ID0gMjQ7XG5cbiAgICB0aGlzLmZvdiA9IDIgKiBUSFJFRS5NYXRoLnJhZFRvRGVnKCBNYXRoLmF0YW4oIGZyYW1lSGVpZ2h0IC8gKCBmb2NhbExlbmd0aCAqIDIgKSApICk7XG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblxuLyoqXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG4gKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG4gKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG4gKlxuICogICArLS0tKy0tLSstLS0rXG4gKiAgIHwgQSB8IEIgfCBDIHxcbiAqICAgKy0tLSstLS0rLS0tK1xuICogICB8IEQgfCBFIHwgRiB8XG4gKiAgICstLS0rLS0tKy0tLStcbiAqXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG4gKlxuICogICB2YXIgdyA9IDE5MjA7XG4gKiAgIHZhciBoID0gMTA4MDtcbiAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xuICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xuICpcbiAqICAgLS1BLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1CLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1DLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1ELS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1FLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1GLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcbiAqXG4gKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQgPSBmdW5jdGlvbiggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgdGhpcy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XG4gICAgdGhpcy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBmb3YgPSBUSFJFRS5NYXRoLnJhZFRvRGVnKCAyICogTWF0aC5hdGFuKCBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhpcy5mb3YgKSAqIDAuNSApIC8gdGhpcy56b29tICkgKTtcblxuICAgIGlmICggdGhpcy5mdWxsV2lkdGggKSB7XG5cbiAgICAgICAgdmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xuICAgICAgICB2YXIgdG9wID0gTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICkgKiB0aGlzLm5lYXI7XG4gICAgICAgIHZhciBib3R0b20gPSAtdG9wO1xuICAgICAgICB2YXIgbGVmdCA9IGFzcGVjdCAqIGJvdHRvbTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmFicyggcmlnaHQgLSBsZWZ0ICk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyggdG9wIC0gYm90dG9tICk7XG5cbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKFxuICAgICAgICAgICAgbGVmdCArIHRoaXMueCAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXG4gICAgICAgICAgICBsZWZ0ICsgKCB0aGlzLnggKyB0aGlzLndpZHRoICkgKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxuICAgICAgICAgICAgdG9wIC0gKCB0aGlzLnkgKyB0aGlzLmhlaWdodCApICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxuICAgICAgICAgICAgdG9wIC0gdGhpcy55ICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxuICAgICAgICAgICAgdGhpcy5uZWFyLFxuICAgICAgICAgICAgdGhpcy5mYXJcbiAgICAgICAgKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBmb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuZm92ID0gc291cmNlLmZvdjtcbiAgICB0aGlzLmFzcGVjdCA9IHNvdXJjZS5hc3BlY3Q7XG4gICAgdGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG4gICAgdGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXG4gICAgdGhpcy56b29tID0gc291cmNlLnpvb207XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG4gICAgZGF0YS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XG4gICAgZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG4gICAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcbiAgICBkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MaWdodCA9IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdMaWdodCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG59O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpZ2h0O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcbi8vIEZpbGU6c3JjL2xpZ2h0cy9BbWJpZW50TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkFtYmllbnRMaWdodCA9IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxufTtcblxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFtYmllbnRMaWdodDtcblxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0ID0gZnVuY3Rpb24oIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gICAgdGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgIHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFMZWZ0ID0gLTUwMDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYVJpZ2h0ID0gNTAwO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhVG9wID0gNTAwO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhQm90dG9tID0gLTUwMDtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5zaGFkb3dCaWFzID0gMDtcbiAgICB0aGlzLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuXG4gICAgdGhpcy5zaGFkb3dNYXBXaWR0aCA9IDUxMjtcbiAgICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcblxuICAgIHRoaXMuc2hhZG93TWFwID0gbnVsbDtcbiAgICB0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ7XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG4gICAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cbiAgICB0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcbiAgICB0aGlzLm9ubHlTaGFkb3cgPSBzb3VyY2Uub25seVNoYWRvdztcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFOZWFyO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gc291cmNlLnNoYWRvd0NhbWVyYUZhcjtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhTGVmdCA9IHNvdXJjZS5zaGFkb3dDYW1lcmFMZWZ0O1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhUmlnaHQ7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFUb3AgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhVG9wO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhQm90dG9tID0gc291cmNlLnNoYWRvd0NhbWVyYUJvdHRvbTtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IHNvdXJjZS5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXG4gICAgdGhpcy5zaGFkb3dCaWFzID0gc291cmNlLnNoYWRvd0JpYXM7XG4gICAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IHNvdXJjZS5zaGFkb3dEYXJrbmVzcztcblxuICAgIHRoaXMuc2hhZG93TWFwV2lkdGggPSBzb3VyY2Uuc2hhZG93TWFwV2lkdGg7XG4gICAgdGhpcy5zaGFkb3dNYXBIZWlnaHQgPSBzb3VyY2Uuc2hhZG93TWFwSGVpZ2h0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvSGVtaXNwaGVyZUxpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQgPSBmdW5jdGlvbiggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBza3lDb2xvciApO1xuXG4gICAgdGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cbiAgICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xuICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICB0aGlzLmdyb3VuZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBncm91bmRDb2xvciApO1xuICAgIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkhlbWlzcGhlcmVMaWdodDtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5ncm91bmRDb2xvci5jb3B5KCBzb3VyY2UuZ3JvdW5kQ29sb3IgKTtcbiAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gICAgZGF0YS5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xuICAgIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9Qb2ludExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludExpZ2h0ID0gZnVuY3Rpb24oIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XG5cbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG4gICAgdGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuICAgIHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTsgLy8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuICAgIHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG4gICAgdGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gICAgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG4gICAgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuICAgIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvU3BvdExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcG90TGlnaHQgPSBmdW5jdGlvbiggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBleHBvbmVudCwgZGVjYXkgKSB7XG5cbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gICAgdGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XG5cbiAgICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xuICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuICAgIHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcbiAgICB0aGlzLmFuZ2xlID0gKCBhbmdsZSAhPT0gdW5kZWZpbmVkICkgPyBhbmdsZSA6IE1hdGguUEkgLyAzO1xuICAgIHRoaXMuZXhwb25lbnQgPSAoIGV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGV4cG9uZW50IDogMTA7XG4gICAgdGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxOyAvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cbiAgICB0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgICB0aGlzLm9ubHlTaGFkb3cgPSBmYWxzZTtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IDUwO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcbiAgICB0aGlzLnNoYWRvd0NhbWVyYUZvdiA9IDUwO1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cbiAgICB0aGlzLnNoYWRvd0JpYXMgPSAwO1xuICAgIHRoaXMuc2hhZG93RGFya25lc3MgPSAwLjU7XG5cbiAgICB0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xuICAgIHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xuXG4gICAgdGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuICAgIHRoaXMuc2hhZG93TWFwU2l6ZSA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmEgPSBudWxsO1xuICAgIHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodDtcblxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuICAgIHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG4gICAgdGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcbiAgICB0aGlzLmV4cG9uZW50ID0gc291cmNlLmV4cG9uZW50O1xuICAgIHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cbiAgICB0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuICAgIHRoaXMub25seVNoYWRvdyA9IHNvdXJjZS5vbmx5U2hhZG93O1xuXG4gICAgdGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gc291cmNlLnNoYWRvd0NhbWVyYU5lYXI7XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFGYXIgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhRmFyO1xuICAgIHRoaXMuc2hhZG93Q2FtZXJhRm92ID0gc291cmNlLnNoYWRvd0NhbWVyYUZvdjtcblxuICAgIHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IHNvdXJjZS5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXG4gICAgdGhpcy5zaGFkb3dCaWFzID0gc291cmNlLnNoYWRvd0JpYXM7XG4gICAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IHNvdXJjZS5zaGFkb3dEYXJrbmVzcztcblxuICAgIHRoaXMuc2hhZG93TWFwV2lkdGggPSBzb3VyY2Uuc2hhZG93TWFwV2lkdGg7XG4gICAgdGhpcy5zaGFkb3dNYXBIZWlnaHQgPSBzb3VyY2Uuc2hhZG93TWFwSGVpZ2h0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICAgIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuICAgIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcbiAgICBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgZGF0YS5vYmplY3QuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xuICAgIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NhY2hlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DYWNoZSA9IHtcblxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuXG4gICAgZmlsZXM6IHt9LFxuXG4gICAgYWRkOiBmdW5jdGlvbigga2V5LCBmaWxlICkge1xuXG4gICAgICAgIGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cbiAgICAgICAgdGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oIGtleSApIHtcblxuICAgICAgICBpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xuXG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oIGtleSApIHtcblxuICAgICAgICBkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XG5cbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZmlsZXMgPSB7fTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxvYWRlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge307XG5cbn07XG5cblRIUkVFLkxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTG9hZGVyLFxuXG4gICAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuICAgIGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiggdXJsICkge1xuXG4gICAgICAgIHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cbiAgICAgICAgaWYgKCBwYXJ0cy5sZW5ndGggPT09IDEgKSByZXR1cm4gJy4vJztcblxuICAgICAgICBwYXJ0cy5wb3AoKTtcblxuICAgICAgICByZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XG5cbiAgICB9LFxuXG4gICAgaW5pdE1hdGVyaWFsczogZnVuY3Rpb24oIG1hdGVyaWFscywgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xuXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsraSApIHtcblxuICAgICAgICAgICAgYXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfSxcblxuICAgIGNyZWF0ZU1hdGVyaWFsOiAoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpbWFnZUxvYWRlcjtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWF0ZXJpYWwoIG0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCBjcm9zc09yaWdpbiA9PT0gdW5kZWZpbmVkICYmIHNjb3BlLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSBjcm9zc09yaWdpbiA9IHNjb3BlLmNyb3NzT3JpZ2luO1xuXG4gICAgICAgICAgICBpZiAoIGltYWdlTG9hZGVyID09PSB1bmRlZmluZWQgKSBpbWFnZUxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBuZWFyZXN0X3BvdzIoIG4gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbCA9IE1hdGgubG9nKCBuICkgLyBNYXRoLkxOMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoIGwgKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZV90ZXh0dXJlKCB3aGVyZSwgbmFtZSwgc291cmNlRmlsZSwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZnVsbFBhdGggPSB0ZXh0dXJlUGF0aCArIHNvdXJjZUZpbGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIHZhciBsb2FkZXIgPSBUSFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlciA9IGltYWdlTG9hZGVyO1xuICAgICAgICAgICAgICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlci5sb2FkKCBmdWxsUGF0aCwgZnVuY3Rpb24oIGltYWdlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBuZWFyZXN0X3BvdzIoIGltYWdlLndpZHRoICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IG5lYXJlc3RfcG93MiggaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGNhbnZhcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5zb3VyY2VGaWxlID0gc291cmNlRmlsZTtcblxuICAgICAgICAgICAgICAgIGlmICggcmVwZWF0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUucmVwZWF0LnNldCggcmVwZWF0WyAwIF0sIHJlcGVhdFsgMSBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZXBlYXRbIDAgXSAhPT0gMSApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZXBlYXRbIDEgXSAhPT0gMSApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUub2Zmc2V0LnNldCggb2Zmc2V0WyAwIF0sIG9mZnNldFsgMSBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHdyYXAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBNYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAncmVwZWF0JzogVEhSRUUuUmVwZWF0V3JhcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWlycm9yJzogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggd3JhcE1hcFsgd3JhcFsgMCBdIF0gIT09IHVuZGVmaW5lZCApIHRleHR1cmUud3JhcFMgPSB3cmFwTWFwWyB3cmFwWyAwIF0gXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB3cmFwTWFwWyB3cmFwWyAxIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwVCA9IHdyYXBNYXBbIHdyYXBbIDEgXSBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGVyZVsgbmFtZSBdID0gdGV4dHVyZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZ2IyaGV4KCByZ2IgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCByZ2JbIDAgXSAqIDI1NSA8PCAxNiApICsgKCByZ2JbIDEgXSAqIDI1NSA8PCA4ICkgKyByZ2JbIDIgXSAqIDI1NTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkZWZhdWx0c1xuXG4gICAgICAgICAgICB2YXIgbXR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG4gICAgICAgICAgICB2YXIgbXBhcnMgPSB7fTtcblxuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBmcm9tIG1vZGVsIGZpbGVcblxuICAgICAgICAgICAgaWYgKCBtLnNoYWRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2hhZGluZyA9IG0uc2hhZGluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzaGFkaW5nID09PSAncGhvbmcnICkgbXR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBzaGFkaW5nID09PSAnYmFzaWMnICkgbXR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbS5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICYmIFRIUkVFWyBtLmJsZW5kaW5nIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLmJsZW5kaW5nID0gVEhSRUVbIG0uYmxlbmRpbmcgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLnRyYW5zcGFyZW50ID0gbS50cmFuc3BhcmVudDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG0ub3BhY2l0eSA8IDEuMCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5kZXB0aFRlc3QgPSBtLmRlcHRoVGVzdDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuZGVwdGhXcml0ZSA9IG0uZGVwdGhXcml0ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMudmlzaWJsZSA9IG0udmlzaWJsZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0uZmxpcFNpZGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5zaWRlID0gVEhSRUUuQmFja1NpZGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLmRvdWJsZVNpZGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy5zaWRlID0gVEhSRUUuRG91YmxlU2lkZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtcGFycy53aXJlZnJhbWUgPSBtLndpcmVmcmFtZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0udmVydGV4Q29sb3JzID09PSAnZmFjZScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggbS52ZXJ0ZXhDb2xvcnMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbG9yc1xuXG4gICAgICAgICAgICBpZiAoIG0uY29sb3JEaWZmdXNlICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuY29sb3IgPSByZ2IyaGV4KCBtLmNvbG9yRGlmZnVzZSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbS5EYmdDb2xvciApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG0uY29sb3JFbWlzc2l2ZSApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLmVtaXNzaXZlID0gcmdiMmhleCggbS5jb2xvckVtaXNzaXZlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtdHlwZSA9PT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggbS5jb2xvclNwZWN1bGFyICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1wYXJzLnNwZWN1bGFyID0gcmdiMmhleCggbS5jb2xvclNwZWN1bGFyICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0uc3BlY3VsYXJDb2VmICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1wYXJzLnNoaW5pbmVzcyA9IG0uc3BlY3VsYXJDb2VmO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vZGlmaWVyc1xuXG4gICAgICAgICAgICBpZiAoIG0udHJhbnNwYXJlbmN5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXI6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XG4gICAgICAgICAgICAgICAgbS5vcGFjaXR5ID0gbS50cmFuc3BhcmVuY3k7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLm9wYWNpdHkgPSBtLm9wYWNpdHk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGV4dHVyZXNcblxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggbS5tYXBEaWZmdXNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ21hcCcsIG0ubWFwRGlmZnVzZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbS5tYXBMaWdodCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdsaWdodE1hcCcsIG0ubWFwTGlnaHQsIG0ubWFwTGlnaHRSZXBlYXQsIG0ubWFwTGlnaHRPZmZzZXQsIG0ubWFwTGlnaHRXcmFwLCBtLm1hcExpZ2h0QW5pc290cm9weSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtLm1hcEFPICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ2FvTWFwJywgbS5tYXBBTywgbS5tYXBBT1JlcGVhdCwgbS5tYXBBT09mZnNldCwgbS5tYXBBT1dyYXAsIG0ubWFwQU9Bbmlzb3Ryb3B5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0ubWFwQnVtcCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdidW1wTWFwJywgbS5tYXBCdW1wLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtLm1hcE5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdub3JtYWxNYXAnLCBtLm1hcE5vcm1hbCwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBtLm1hcFNwZWN1bGFyICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ3NwZWN1bGFyTWFwJywgbS5tYXBTcGVjdWxhciwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG0ubWFwQWxwaGEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYWxwaGFNYXAnLCBtLm1hcEFscGhhLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBpZiAoIG0ubWFwQnVtcFNjYWxlICkge1xuXG4gICAgICAgICAgICAgICAgbXBhcnMuYnVtcFNjYWxlID0gbS5tYXBCdW1wU2NhbGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtLm1hcE5vcm1hbEZhY3RvciApIHtcblxuICAgICAgICAgICAgICAgIG1wYXJzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIG0ubWFwTm9ybWFsRmFjdG9yLCBtLm1hcE5vcm1hbEZhY3RvciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbXR5cGUgXSggbXBhcnMgKTtcblxuICAgICAgICAgICAgaWYgKCBtLkRiZ05hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBtLkRiZ05hbWU7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbDtcblxuICAgICAgICB9O1xuXG4gICAgfSApKClcblxufTtcblxuVEhSRUUuTG9hZGVyLkhhbmRsZXJzID0ge1xuXG4gICAgaGFuZGxlcnM6IFtdLFxuXG4gICAgYWRkOiBmdW5jdGlvbiggcmVnZXgsIGxvYWRlciApIHtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goIHJlZ2V4LCBsb2FkZXIgKTtcblxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCBmaWxlICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xuXG4gICAgICAgICAgICB2YXIgcmVnZXggPSB0aGlzLmhhbmRsZXJzWyBpIF07XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5oYW5kbGVyc1sgaSArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1hIUkxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuWEhSTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuWEhSTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5YSFJMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcblxuICAgICAgICBpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIHtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCggY2FjaGVkICk7XG5cbiAgICAgICAgICAgICAgICB9LCAwICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgVEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHRoaXMucmVzcG9uc2UgKTtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMucmVzcG9uc2UgKTtcblxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgICAgICB9LCBmYWxzZSApO1xuXG4gICAgICAgIGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIH0sIGZhbHNlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cbiAgICAgICAgfSwgZmFsc2UgKTtcblxuICAgICAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgICBpZiAoIHRoaXMucmVzcG9uc2VUeXBlICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICBpZiAoIHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG4gICAgICAgIHJlcXVlc3Quc2VuZCggbnVsbCApO1xuXG4gICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcblxuICAgIH0sXG5cbiAgICBzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvSW1hZ2VMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkltYWdlTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuSW1hZ2VMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XG5cbiAgICAgICAgaWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBvbkxvYWQoIGNhY2hlZCApO1xuXG4gICAgICAgICAgICAgICAgfSwgMCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbWcnICk7XG5cbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIFRIUkVFLkNhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XG5cbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICAgICAgfSwgZmFsc2UgKTtcblxuICAgICAgICBpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcblxuICAgICAgICAgICAgfSwgZmFsc2UgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cbiAgICAgICAgfSwgZmFsc2UgKTtcblxuICAgICAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xuXG4gICAgICAgIHJldHVybiBpbWFnZTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9KU09OTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSlNPTkxvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgaWYgKCB0eXBlb2YgbWFuYWdlciA9PT0gJ2Jvb2xlYW4nICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IHNob3dTdGF0dXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBjb25zdHJ1Y3Rvci4nICk7XG4gICAgICAgIG1hbmFnZXIgPSB1bmRlZmluZWQ7XG5cbiAgICB9XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkpTT05Mb2FkZXIsXG5cbiAgICAvLyBEZXByZWNhdGVkXG5cbiAgICBnZXQgc3RhdHVzRG9tRWxlbWVudCgpIHtcblxuICAgICAgICBpZiAoIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IC5zdGF0dXNEb21FbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzRG9tRWxlbWVudDtcblxuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgdGV4dHVyZVBhdGggPSB0aGlzLnRleHR1cmVQYXRoICYmICggdHlwZW9mIHRoaXMudGV4dHVyZVBhdGggPT09IFwic3RyaW5nXCIgKSA/IHRoaXMudGV4dHVyZVBhdGggOiBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgICAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggdGV4dCApIHtcblxuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xuXG4gICAgICAgICAgICBpZiAoIG1ldGFkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1ldGFkYXRhLnR5cGUgPT09ICdvYmplY3QnICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuT2JqZWN0TG9hZGVyIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1ldGFkYXRhLnR5cGUgPT09ICdzY2VuZScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5TY2VuZUxvYWRlciBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBzY29wZS5wYXJzZSgganNvbiwgdGV4dHVyZVBhdGggKTtcbiAgICAgICAgICAgIG9uTG9hZCggb2JqZWN0Lmdlb21ldHJ5LCBvYmplY3QubWF0ZXJpYWxzICk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbigganNvbiwgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXG4gICAgICAgICAgICBzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xuXG4gICAgICAgIHBhcnNlTW9kZWwoIHNjYWxlICk7XG5cbiAgICAgICAgcGFyc2VTa2luKCk7XG4gICAgICAgIHBhcnNlTW9ycGhpbmcoIHNjYWxlICk7XG5cbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTW9kZWwoIHNjYWxlICkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0JpdFNldCggdmFsdWUsIHBvc2l0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGksIGosIGZpLFxuXG4gICAgICAgICAgICAgICAgb2Zmc2V0LCB6TGVuZ3RoLFxuXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsIG1hdGVyaWFsSW5kZXgsXG5cbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGlzUXVhZCxcbiAgICAgICAgICAgICAgICBoYXNNYXRlcmlhbCxcbiAgICAgICAgICAgICAgICBoYXNGYWNlVmVydGV4VXYsXG4gICAgICAgICAgICAgICAgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcbiAgICAgICAgICAgICAgICBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcblxuICAgICAgICAgICAgICAgIHZlcnRleCwgZmFjZSwgZmFjZUEsIGZhY2VCLCBoZXgsIG5vcm1hbCxcblxuICAgICAgICAgICAgICAgIHV2TGF5ZXIsIHV2LCB1LCB2LFxuXG4gICAgICAgICAgICAgICAgZmFjZXMgPSBqc29uLmZhY2VzLFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzID0ganNvbi52ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICBub3JtYWxzID0ganNvbi5ub3JtYWxzLFxuICAgICAgICAgICAgICAgIGNvbG9ycyA9IGpzb24uY29sb3JzLFxuXG4gICAgICAgICAgICAgICAgblV2TGF5ZXJzID0gMDtcblxuICAgICAgICAgICAgaWYgKCBqc29uLnV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gZGlzcmVnYXJkIGVtcHR5IGFycmF5c1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzKys7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB6TGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICAgICAgdmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0KysgXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCsrIF0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBvZmZzZXQrKyBdICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgdHlwZSA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuXG5cbiAgICAgICAgICAgICAgICBpc1F1YWQgPSBpc0JpdFNldCggdHlwZSwgMCApO1xuICAgICAgICAgICAgICAgIGhhc01hdGVyaWFsID0gaXNCaXRTZXQoIHR5cGUsIDEgKTtcbiAgICAgICAgICAgICAgICBoYXNGYWNlVmVydGV4VXYgPSBpc0JpdFNldCggdHlwZSwgMyApO1xuICAgICAgICAgICAgICAgIGhhc0ZhY2VOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNCApO1xuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xuICAgICAgICAgICAgICAgIGhhc0ZhY2VDb2xvciA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XG4gICAgICAgICAgICAgICAgaGFzRmFjZVZlcnRleENvbG9yID0gaXNCaXRTZXQoIHR5cGUsIDcgKTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzUXVhZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlQSA9IG5ldyBUSFJFRS5GYWNlMygpO1xuICAgICAgICAgICAgICAgICAgICBmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xuICAgICAgICAgICAgICAgICAgICBmYWNlQS5iID0gZmFjZXNbIG9mZnNldCArIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZUIgPSBuZXcgVEhSRUUuRmFjZTMoKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XG4gICAgICAgICAgICAgICAgICAgIGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xuICAgICAgICAgICAgICAgICAgICBmYWNlQi5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc01hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlQS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VCLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuICAgICAgICAgICAgICAgICAgICBmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCA0OyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGogIT09IDAgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdLnB1c2goIHV2ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdICogMztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUEubm9ybWFsLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF0gKiAzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlQS5jb2xvci5zZXRIZXgoIGhleCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA0OyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCsrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUEgKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUIgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICBmYWNlLmIgPSBmYWNlc1sgb2Zmc2V0KysgXTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5jID0gZmFjZXNbIG9mZnNldCsrIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCAzOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0KysgXSAqIDM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXgrKyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdICogMztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCsrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4KysgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgMzsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQrKyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggY29sb3JzWyBjb2xvckluZGV4IF0gKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VTa2luKCkge1xuXG4gICAgICAgICAgICB2YXIgaW5mbHVlbmNlc1BlclZlcnRleCA9ICgganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4ICE9PSB1bmRlZmluZWQgKSA/IGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCA6IDI7XG5cbiAgICAgICAgICAgIGlmICgganNvbi5za2luV2VpZ2h0cyApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0ganNvbi5za2luV2VpZ2h0c1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF0gOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAyIF0gOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGpzb24uc2tpbkluZGljZXMgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGpzb24uc2tpbkluZGljZXNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvbWV0cnkuYm9uZXMgPSBqc29uLmJvbmVzO1xuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgJiYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggIT09IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCB8fCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggIT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICsgJyksIGFuZCBza2luV2VpZ2h0cyAoJyArIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCArICcpIHNob3VsZCBtYXRjaC4nICk7XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBjb3VsZCBjaGFuZ2UgdGhpcyB0byBqc29uLmFuaW1hdGlvbnNbMF0gb3IgcmVtb3ZlIGNvbXBsZXRlbHlcblxuICAgICAgICAgICAgZ2VvbWV0cnkuYW5pbWF0aW9uID0ganNvbi5hbmltYXRpb247XG4gICAgICAgICAgICBnZW9tZXRyeS5hbmltYXRpb25zID0ganNvbi5hbmltYXRpb25zO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpLCBsLCB2LCB2bCwgZHN0VmVydGljZXMsIHNyY1ZlcnRpY2VzO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuICAgICAgICAgICAgICAgICAgICBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleC56ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgganNvbi5tb3JwaENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGksIGwsIGMsIGNsLCBkc3RDb2xvcnMsIHNyY0NvbG9ycywgY29sb3I7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhDb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5uYW1lID0ganNvbi5tb3JwaENvbG9yc1sgaSBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZHN0Q29sb3JzID0gZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnM7XG4gICAgICAgICAgICAgICAgICAgIHNyY0NvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnM7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggYyA9IDAsIGNsID0gc3JjQ29sb3JzLmxlbmd0aDsgYyA8IGNsOyBjICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmYWEwMCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3Iuc2V0UkdCKCBzcmNDb2xvcnNbIGMgXSwgc3JjQ29sb3JzWyBjICsgMSBdLCBzcmNDb2xvcnNbIGMgKyAyIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdENvbG9ycy5wdXNoKCBjb2xvciApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoLCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsczogbWF0ZXJpYWxzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTG9hZGluZ01hbmFnZXIgPSBmdW5jdGlvbiggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBpc0xvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgaXRlbXNMb2FkZWQgPSAwLFxuICAgICAgICBpdGVtc1RvdGFsID0gMDtcblxuICAgIHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uTG9hZCA9IG9uTG9hZDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cbiAgICB0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cbiAgICAgICAgaXRlbXNUb3RhbCsrO1xuXG4gICAgICAgIGlmICggaXNMb2FkaW5nID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5vblN0YXJ0KCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaXNMb2FkaW5nID0gdHJ1ZTtcblxuICAgIH07XG5cbiAgICB0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiggdXJsICkge1xuXG4gICAgICAgIGl0ZW1zTG9hZGVkKys7XG5cbiAgICAgICAgaWYgKCBzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcblxuICAgICAgICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5vbkxvYWQoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cbiAgICAgICAgaWYgKCBzY29wZS5vbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLm9uRXJyb3IoIHVybCApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn07XG5cblRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0J1ZmZlckdlb21ldHJ5TG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggdGV4dCApIHtcblxuICAgICAgICAgICAgb25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCBqc29uICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGluZGV4LnR5cGUgXSggaW5kZXguYXJyYXkgKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCAxICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcblxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICAgICAgICAgIHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xuXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IGpzb24uZGF0YS5ncm91cHMgfHwganNvbi5kYXRhLmRyYXdjYWxscyB8fCBqc29uLmRhdGEub2Zmc2V0cztcblxuICAgICAgICBpZiAoIGdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArK2kgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XG5cbiAgICAgICAgaWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgICAgaWYgKCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRlcmlhbExvYWRlciA9IGZ1bmN0aW9uKCBtYW5hZ2VyICkge1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG4gICAgdGhpcy50ZXh0dXJlcyA9IHt9O1xuXG59O1xuXG5USFJFRS5NYXRlcmlhbExvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWxMb2FkZXIsXG5cbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIHRleHQgKSB7XG5cbiAgICAgICAgICAgIG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHNldFRleHR1cmVzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIGdldFRleHR1cmU6IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XG5cbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCBqc29uICkge1xuXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsganNvbi50eXBlIF07XG4gICAgICAgIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XG5cbiAgICAgICAgaWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XG4gICAgICAgIGlmICgganNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XG4gICAgICAgIGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XG4gICAgICAgIGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KCBqc29uLnNwZWN1bGFyICk7XG4gICAgICAgIGlmICgganNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IGpzb24uc2hpbmluZXNzO1xuICAgICAgICBpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3JtcztcbiAgICAgICAgaWYgKCBqc29uLnZlcnRleFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0ganNvbi52ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIGlmICgganNvbi5mcmFnbWVudFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBqc29uLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcbiAgICAgICAgaWYgKCBqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRpbmcgPSBqc29uLnNoYWRpbmc7XG4gICAgICAgIGlmICgganNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xuICAgICAgICBpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcbiAgICAgICAgaWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG4gICAgICAgIGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xuICAgICAgICBpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcbiAgICAgICAgaWYgKCBqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XG4gICAgICAgIGlmICgganNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0ganNvbi5kZXB0aFdyaXRlO1xuICAgICAgICBpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcbiAgICAgICAgaWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICAgICAgLy8gZm9yIFBvaW50c01hdGVyaWFsXG4gICAgICAgIGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuICAgICAgICBpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcblxuICAgICAgICAvLyBtYXBzXG5cbiAgICAgICAgaWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm1hcCApO1xuXG4gICAgICAgIGlmICgganNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xuICAgICAgICAgICAgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XG4gICAgICAgIGlmICgganNvbi5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xuXG4gICAgICAgIGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcbiAgICAgICAgaWYgKCBqc29uLm5vcm1hbFNjYWxlICkgbWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMigganNvbi5ub3JtYWxTY2FsZSwganNvbi5ub3JtYWxTY2FsZSApO1xuXG4gICAgICAgIGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcbiAgICAgICAgaWYgKCBqc29uLmRpc3BsYWNlbWVudFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IGpzb24uZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgICAgIGlmICgganNvbi5kaXNwbGFjZW1lbnRCaWFzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgICAgIGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJNYXAgKTtcblxuICAgICAgICBpZiAoIGpzb24uZW52TWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcbiAgICAgICAgICAgIG1hdGVyaWFsLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBqc29uLnJlZmxlY3Rpdml0eSApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuXG4gICAgICAgIGlmICgganNvbi5saWdodE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubGlnaHRNYXAgKTtcbiAgICAgICAgaWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgaWYgKCBqc29uLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hb01hcCApO1xuICAgICAgICBpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcblxuICAgICAgICAvLyBNZXNoRmFjZU1hdGVyaWFsXG5cbiAgICAgICAgaWYgKCBqc29uLm1hdGVyaWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5wYXJzZSgganNvbi5tYXRlcmlhbHNbIGkgXSApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL09iamVjdExvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuT2JqZWN0TG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcbiAgICB0aGlzLnRleHR1cmVQYXRoID0gJyc7XG5cbn07XG5cblRIUkVFLk9iamVjdExvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0TG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIGlmICggdGhpcy50ZXh0dXJlUGF0aCA9PT0gJycgKSB7XG5cbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVBhdGggPSB1cmwuc3Vic3RyaW5nKCAwLCB1cmwubGFzdEluZGV4T2YoICcvJyApICsgMSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiggdGV4dCApIHtcblxuICAgICAgICAgICAgc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSwgb25Mb2FkICk7XG5cbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgfSxcblxuICAgIHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbigganNvbiwgb25Mb2FkICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcyApO1xuXG4gICAgICAgIHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG4gICAgICAgIH0gKTtcblxuICAgICAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xuICAgICAgICB2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XG4gICAgICAgIHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XG5cbiAgICAgICAgaWYgKCBqc29uLmltYWdlcyA9PT0gdW5kZWZpbmVkIHx8IGpzb24uaW1hZ2VzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9LFxuXG4gICAgcGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbigganNvbiApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG4gICAgICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuSlNPTkxvYWRlcigpO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5O1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0ganNvblsgaSBdO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICggZGF0YS50eXBlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUVbIGRhdGEudHlwZSBdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0JveEdlb21ldHJ5JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ3ViZUdlb21ldHJ5JzogLy8gYmFja3dhcmRzIGNvbXBhdGlibGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGVwdGhTZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDaXJjbGVHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0N5bGluZGVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzQm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9wZW5FbmRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3BoZXJlR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGV0YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RldHJhaGVkcm9uR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGV0YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdSaW5nR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbm5lclJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm91dGVyUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaVNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUb3J1c0dlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnR1YmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnR1YnVsYXJTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFyY1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG9ydXNLbm90R2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnR1YmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnR1YnVsYXJTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RleHRHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnR2VvbWV0cnknOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLmRhdGEsIHRoaXMudGV4dHVyZVBhdGggKS5nZW9tZXRyeTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIGdlb21ldHJ5Lm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzO1xuXG4gICAgfSxcblxuICAgIHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbigganNvbiwgdGV4dHVyZXMgKSB7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFscyA9IHt9O1xuXG4gICAgICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyKCk7XG4gICAgICAgICAgICBsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gbG9hZGVyLnBhcnNlKCBqc29uWyBpIF0gKTtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHNbIG1hdGVyaWFsLnV1aWQgXSA9IG1hdGVyaWFsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRlcmlhbHM7XG5cbiAgICB9LFxuXG4gICAgcGFyc2VJbWFnZXM6IGZ1bmN0aW9uKCBqc29uLCBvbkxvYWQgKSB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgdmFyIGltYWdlcyA9IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xuXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgbWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XG5cbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcbiAgICAgICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGpzb25bIGkgXTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggaW1hZ2UudXJsICkgPyBpbWFnZS51cmwgOiBzY29wZS50ZXh0dXJlUGF0aCArIGltYWdlLnVybDtcblxuICAgICAgICAgICAgICAgIGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbG9hZEltYWdlKCBwYXRoICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGltYWdlcztcblxuICAgIH0sXG5cbiAgICBwYXJzZVRleHR1cmVzOiBmdW5jdGlvbigganNvbiwgaW1hZ2VzICkge1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlICkge1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiggdmFsdWUgKSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRIUkVFWyB2YWx1ZSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dHVyZXMgPSB7fTtcblxuICAgICAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggaW1hZ2VzWyBkYXRhLmltYWdlIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEub2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBkYXRhLm9mZnNldFsgMCBdLCBkYXRhLm9mZnNldFsgMSBdICk7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5yZXBlYXRbIDAgXSwgZGF0YS5yZXBlYXRbIDEgXSApO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5taW5GaWx0ZXIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyICk7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcbiAgICAgICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEud3JhcCApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSApO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAxIF0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmVzO1xuXG4gICAgfSxcblxuICAgIHBhcnNlT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApIHtcblxuICAgICAgICAgICAgdmFyIG9iamVjdDtcblxuICAgICAgICAgICAgdmFyIGdldEdlb21ldHJ5ID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJpZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgbmFtZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldE1hdGVyaWFsID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ1NjZW5lJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnQW1iaWVudExpZ2h0JzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ1BvaW50TGlnaHQnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnU3BvdExpZ2h0JzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5hbmdsZSwgZGF0YS5leHBvbmVudCwgZGF0YS5kZWNheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnTWVzaCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ0xPRCc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkxPRCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnTGluZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnUG9pbnRDbG91ZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnUG9pbnRzJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdTcHJpdGUnOlxuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ0dyb3VwJzpcblxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICAgICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgICAgIGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIG1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XG4gICAgICAgICAgICAgICAgbWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnNjYWxlICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KCBkYXRhLnNjYWxlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBkYXRhLmNhc3RTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xuICAgICAgICAgICAgaWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xuXG4gICAgICAgICAgICBpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XG4gICAgICAgICAgICBpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cbiAgICAgICAgICAgIGlmICggZGF0YS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGRhdGEudHlwZSA9PT0gJ0xPRCcgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG9iamVjdC5nZXRPYmplY3RCeVByb3BlcnR5KCAndXVpZCcsIGxldmVsLm9iamVjdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2hpbGQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmFkZExldmVsKCBjaGlsZCwgbGV2ZWwuZGlzdGFuY2UgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgICAgICB9XG5cbiAgICB9KClcblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9UZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5UZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVGV4dHVyZUxvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCBpbWFnZSApIHtcblxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2UgKTtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICB9LFxuXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQmluYXJ5VGV4dHVyZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgTmlrb3MgTS4gLyBodHRwczovL2dpdGh1Yi5jb20vZm9vMTIzL1xuICpcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZUxvYWRlciA9IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgLy8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcbiAgICB0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG59O1xuXG5USFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLFxuXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgICAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIGJ1ZmZlciApIHtcblxuICAgICAgICAgICAgdmFyIHRleERhdGEgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIgKTtcblxuICAgICAgICAgICAgaWYgKCAhdGV4RGF0YSApIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuaW1hZ2UgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5kYXRhICkge1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dHVyZS53cmFwUyA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS53cmFwUyA/IHRleERhdGEud3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgICAgICAgICAgdGV4dHVyZS53cmFwVCA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS53cmFwVCA/IHRleERhdGEud3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5tYWdGaWx0ZXIgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcbiAgICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pbkZpbHRlciA/IHRleERhdGEubWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLmFuaXNvdHJvcHkgPSB1bmRlZmluZWQgIT09IHRleERhdGEuYW5pc290cm9weSA/IHRleERhdGEuYW5pc290cm9weSA6IDE7XG5cbiAgICAgICAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLnR5cGUgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcblxuICAgICAgICAgICAgICAgIHRleHR1cmUubWlwbWFwcyA9IHRleERhdGEubWlwbWFwcztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIDEgPT09IHRleERhdGEubWlwbWFwQ291bnQgKSB7XG5cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcblxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcblxuICAgIH0sXG5cbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKlxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXG4gKi9cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgLy8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcbiAgICB0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG59O1xuXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlcixcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbWFnZXMgPSBbXTtcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xuICAgICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xuXG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gMDtcblxuICAgICAgICAgICAgdmFyIGxvYWRUZXh0dXJlID0gZnVuY3Rpb24oIGkgKSB7XG5cbiAgICAgICAgICAgICAgICBsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBpIF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGV4RGF0YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZCArPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsraSApIHtcblxuICAgICAgICAgICAgICAgIGxvYWRUZXh0dXJlKCBpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcblxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24oIGJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXBtYXBzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gICAgfSxcblxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRlcmlhbCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBUSFJFRS5NYXRlcmlhbElkQ291bnQrK1xuICAgIH0gKTtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5zaWRlID0gVEhSRUUuRnJvbnRTaWRlO1xuXG4gICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICB0aGlzLmJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cbiAgICB0aGlzLmJsZW5kU3JjID0gVEhSRUUuU3JjQWxwaGFGYWN0b3I7XG4gICAgdGhpcy5ibGVuZERzdCA9IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG4gICAgdGhpcy5ibGVuZEVxdWF0aW9uID0gVEhSRUUuQWRkRXF1YXRpb247XG4gICAgdGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcbiAgICB0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsO1xuICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblxuICAgIHRoaXMuZGVwdGhGdW5jID0gVEhSRUUuTGVzc0VxdWFsRGVwdGg7XG4gICAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuICAgIHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XG5cbiAgICB0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xuXG4gICAgdGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcbiAgICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cbiAgICB0aGlzLmFscGhhVGVzdCA9IDA7XG5cbiAgICB0aGlzLm92ZXJkcmF3ID0gMDsgLy8gT3ZlcmRyYXduIHBpeGVscyAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxuXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsLFxuXG4gICAgZ2V0IG5lZWRzVXBkYXRlKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuICAgIH0sXG5cbiAgICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgc2V0VmFsdWVzOiBmdW5jdGlvbiggdmFsdWVzICkge1xuXG4gICAgICAgIGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgZm9yICggdmFyIGtleSBpbiB2YWx1ZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XG5cbiAgICAgICAgICAgIGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XG5cbiAgICAgICAgICAgIGlmICggY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgKyBcIjogJ1wiICsga2V5ICsgXCInIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoaXMgbWF0ZXJpYWwuXCIgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xuXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnNldCggbmV3VmFsdWUgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkge1xuXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXG4gICAgICAgICAgICAgICAgdGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ01hdGVyaWFsJyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxuICAgICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICAgIGlmICggdGhpcy5jb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gICAgICAgIGlmICggdGhpcy5lbWlzc2l2ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XG4gICAgICAgIGlmICggdGhpcy5zcGVjdWxhciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XG4gICAgICAgIGlmICggdGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cbiAgICAgICAgaWYgKCB0aGlzLm1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgIGlmICggdGhpcy5hbHBoYU1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICBpZiAoIHRoaXMubGlnaHRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgaWYgKCB0aGlzLmJ1bXBNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG4gICAgICAgICAgICBkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgICAgIGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMubm9ybWFsTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgICAgICAgZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGU7IC8vIFJlbW92ZWQgZm9yIG5vdywgY2F1c2VzIGlzc3VlIGluIGVkaXRvciB1aS5qc1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0aGlzLmRpc3BsYWNlbWVudE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgICAgICAgIGRhdGEuZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgZGF0YS5kaXNwbGFjZW1lbnRCaWFzID0gdGhpcy5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0aGlzLnNwZWN1bGFyTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgIGlmICggdGhpcy5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG4gICAgICAgICAgICBkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICAgICAgICBkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5OyAvLyBTY2FsZSBiZWhpbmQgZW52TWFwXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cbiAgICAgICAgaWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIGRhdGEudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG4gICAgICAgIGlmICggdGhpcy5zaGFkaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaGFkaW5nICE9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICkgZGF0YS5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuICAgICAgICBpZiAoIHRoaXMuYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJsZW5kaW5nICE9PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuICAgICAgICBpZiAoIHRoaXMuc2lkZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2lkZSAhPT0gVEhSRUUuRnJvbnRTaWRlICkgZGF0YS5zaWRlID0gdGhpcy5zaWRlO1xuXG4gICAgICAgIGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgaWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG4gICAgICAgIGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcbiAgICAgICAgaWYgKCB0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSApIGRhdGEud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG4gICAgICAgIGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cbiAgICAgICAgdGhpcy5zaWRlID0gc291cmNlLnNpZGU7XG5cbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgdGhpcy5ibGVuZGluZyA9IHNvdXJjZS5ibGVuZGluZztcblxuICAgICAgICB0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xuICAgICAgICB0aGlzLmJsZW5kRHN0ID0gc291cmNlLmJsZW5kRHN0O1xuICAgICAgICB0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcbiAgICAgICAgdGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XG4gICAgICAgIHRoaXMuYmxlbmREc3RBbHBoYSA9IHNvdXJjZS5ibGVuZERzdEFscGhhO1xuICAgICAgICB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cbiAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xuICAgICAgICB0aGlzLmRlcHRoVGVzdCA9IHNvdXJjZS5kZXB0aFRlc3Q7XG4gICAgICAgIHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuXG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gc291cmNlLnByZWNpc2lvbjtcblxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcblxuICAgICAgICB0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XG5cbiAgICAgICAgdGhpcy5vdmVyZHJhdyA9IHNvdXJjZS5vdmVyZHJhdztcblxuICAgICAgICB0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZSdcbiAgICAgICAgfSApO1xuXG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICAgIH0gKTtcblxuICAgIH0sXG5cbiAgICAvLyBEZXByZWNhdGVkXG5cbiAgICBnZXQgd3JhcEFyb3VuZCgpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgc2V0IHdyYXBBcm91bmQoIGJvb2xlYW4gKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfSxcblxuICAgIGdldCB3cmFwUkdCKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcFJHQiBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5Db2xvcigpO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTWF0ZXJpYWxJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuICogIGxpbmVjYXA6IFwicm91bmRcIixcbiAqICBsaW5lam9pbjogXCJyb3VuZFwiLFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTGluZUJhc2ljTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuICAgIHRoaXMubGluZXdpZHRoID0gMTtcbiAgICB0aGlzLmxpbmVjYXAgPSAncm91bmQnO1xuICAgIHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWw7XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcbiAgICB0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcbiAgICB0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lRGFzaGVkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgc2NhbGU6IDxmbG9hdD4sXG4gKiAgZGFzaFNpemU6IDxmbG9hdD4sXG4gKiAgZ2FwU2l6ZTogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuICAgIHRoaXMubGluZXdpZHRoID0gMTtcblxuICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgIHRoaXMuZGFzaFNpemUgPSAzO1xuICAgIHRoaXMuZ2FwU2l6ZSA9IDE7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IGZhbHNlO1xuXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbDtcblxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcblxuICAgIHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XG4gICAgdGhpcy5kYXNoU2l6ZSA9IHNvdXJjZS5kYXNoU2l6ZTtcbiAgICB0aGlzLmdhcFNpemUgPSBzb3VyY2UuZ2FwU2l6ZTtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcblxuICAgIHRoaXMubWFwID0gbnVsbDtcblxuICAgIHRoaXMuYW9NYXAgPSBudWxsO1xuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICAgIHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5lbnZNYXAgPSBudWxsO1xuICAgIHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgICB0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgICB0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG4gICAgdGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cbiAgICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gICAgdGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuICAgIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICB0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTGFtYmVydE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKlx0Zm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG4gICAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcblxuICAgIHRoaXMubWFwID0gbnVsbDtcblxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmVudk1hcCA9IG51bGw7XG4gICAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcblxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gICAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuICAgIHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG4gICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICB0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoUGhvbmdNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIGVtaXNzaXZlOiA8aGV4PixcbiAqICBzcGVjdWxhcjogPGhleD4sXG4gKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuICpcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcbiAqXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKlx0Zm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcbiAgICB0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuICAgIHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICk7XG4gICAgdGhpcy5zaGluaW5lc3MgPSAzMDtcblxuICAgIHRoaXMubWV0YWwgPSBmYWxzZTtcblxuICAgIHRoaXMubWFwID0gbnVsbDtcblxuICAgIHRoaXMubGlnaHRNYXAgPSBudWxsO1xuICAgIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICB0aGlzLmFvTWFwID0gbnVsbDtcbiAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgdGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmJ1bXBNYXAgPSBudWxsO1xuICAgIHRoaXMuYnVtcFNjYWxlID0gMTtcblxuICAgIHRoaXMubm9ybWFsTWFwID0gbnVsbDtcbiAgICB0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcbiAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgICB0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICAgIHRoaXMuZW52TWFwID0gbnVsbDtcbiAgICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gICAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gICAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgICB0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuICAgIHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XG4gICAgdGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xuXG4gICAgdGhpcy5tZXRhbCA9IHNvdXJjZS5tZXRhbDtcblxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG4gICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuICAgIHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG4gICAgdGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuICAgIHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cbiAgICB0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcbiAgICB0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cbiAgICB0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG4gICAgdGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cbiAgICB0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gICAgdGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICAgIHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xuXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoRGVwdGhNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbDtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTm9ybWFsTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTWVzaE5vcm1hbE1hdGVyaWFsJztcblxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL011bHRpTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk11bHRpTWF0ZXJpYWwgPSBmdW5jdGlvbiggbWF0ZXJpYWxzICkge1xuXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIHRoaXMudHlwZSA9ICdNdWx0aU1hdGVyaWFsJztcblxuICAgIHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcblxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLk11bHRpTWF0ZXJpYWwucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk11bHRpTWF0ZXJpYWwsXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuMixcbiAgICAgICAgICAgICAgICB0eXBlOiAnbWF0ZXJpYWwnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ01hdGVyaWFsRXhwb3J0ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXVpZDogdGhpcy51dWlkLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgbWF0ZXJpYWxzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgb3V0cHV0Lm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLnRvSlNPTigpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG5cbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgbWF0ZXJpYWwudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XG5cbiAgICB9XG5cbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBUSFJFRS5NdWx0aU1hdGVyaWFsO1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvUG9pbnRzTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc2l6ZTogPGZsb2F0PixcbiAqICBzaXplQXR0ZW51YXRpb246IDxib29sPixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG4gICAgdGhpcy5tYXAgPSBudWxsO1xuXG4gICAgdGhpcy5zaXplID0gMTtcbiAgICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludHNNYXRlcmlhbDtcblxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgdGhpcy5zaXplID0gc291cmNlLnNpemU7XG4gICAgdGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCA9IGZ1bmN0aW9uKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG4gKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdHlwZTogXCJpXCIgdmFsdWUyOiAyIH0gfSxcbiAqXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBsaWdodHM6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cbiAgICB0aGlzLmRlZmluZXMgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge307XG5cbiAgICB0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xuXG4gICAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICAgIHRoaXMubGluZXdpZHRoID0gMTtcblxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gICAgdGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuICAgIHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXG5cbiAgICB0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggdGFyZ2V0c1xuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xuXG4gICAgdGhpcy5kZXJpdmF0aXZlcyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXG5cbiAgICAvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcbiAgICAvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuICAgICAgICAnY29sb3InOiBbIDEsIDEsIDEgXSxcbiAgICAgICAgJ3V2JzogWyAwLCAwIF0sXG4gICAgICAgICd1djInOiBbIDAsIDAgXVxuICAgIH07XG5cbiAgICB0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBkZWZpbmVkIGluIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYWRlck1hdGVyaWFsO1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBzb3VyY2UuZnJhZ21lbnRTaGFkZXI7XG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xuXG4gICAgdGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNvdXJjZS51bmlmb3JtcyApO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG4gICAgdGhpcy5kZWZpbmVzID0gc291cmNlLmRlZmluZXM7XG5cbiAgICB0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICB0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XG5cbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICB0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuICAgIHRoaXMuZGVyaXZhdGl2ZXMgPSBzb3VyY2UuZGVyaXZhdGl2ZXM7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGRhdGEuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBkYXRhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xuICAgIGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9SYXdTaGFkZXJNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIFRIUkVFLlNoYWRlck1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XG5cbn07XG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWw7XG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAqXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlNwcml0ZU1hdGVyaWFsID0gZnVuY3Rpb24oIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcbiAgICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcblxuICAgIHRoaXMuZm9nID0gZmFsc2U7XG5cbiAgICAvLyBzZXQgcGFyYW1ldGVyc1xuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGVNYXRlcmlhbDtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cblRIUkVFLlRleHR1cmUgPSBmdW5jdGlvbiggaW1hZ2UsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogVEhSRUUuVGV4dHVyZUlkQ291bnQrK1xuICAgIH0gKTtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSAnJztcblxuICAgIHRoaXMuaW1hZ2UgPSBpbWFnZSAhPT0gdW5kZWZpbmVkID8gaW1hZ2UgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0U7XG4gICAgdGhpcy5taXBtYXBzID0gW107XG5cbiAgICB0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XG5cbiAgICB0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICAgIHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICAgIHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IGFuaXNvdHJvcHkgOiAxO1xuXG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XG5cbiAgICB0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XG4gICAgdGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuICAgIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuICAgIHRoaXMuZmxpcFkgPSB0cnVlO1xuICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDsgLy8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXG5cbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIHRoaXMub25VcGRhdGUgPSBudWxsO1xuXG59O1xuXG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFRIUkVFLlVWTWFwcGluZztcblxuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVGV4dHVyZSxcblxuICAgIHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbisrO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xuICAgICAgICB0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xuXG4gICAgICAgIHRoaXMubWFwcGluZyA9IHNvdXJjZS5tYXBwaW5nO1xuXG4gICAgICAgIHRoaXMud3JhcFMgPSBzb3VyY2Uud3JhcFM7XG4gICAgICAgIHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cbiAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xuICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG5cbiAgICAgICAgdGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xuICAgICAgICB0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblxuICAgICAgICB0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XG4gICAgICAgIHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcblxuICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG4gICAgICAgIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xuICAgICAgICB0aGlzLmZsaXBZID0gc291cmNlLmZsaXBZO1xuICAgICAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgICAgICBpZiAoIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGF0YVVSTCggaW1hZ2UgKSB7XG5cbiAgICAgICAgICAgIHZhciBjYW52YXM7XG5cbiAgICAgICAgICAgIGlmICggaW1hZ2UudG9EYXRhVVJMICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjYW52YXMgPSBpbWFnZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApLmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ1RleHR1cmUnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ1RleHR1cmUudG9KU09OJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXVpZDogdGhpcy51dWlkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuXG4gICAgICAgICAgICBtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cbiAgICAgICAgICAgIHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXG4gICAgICAgICAgICBvZmZzZXQ6IFsgdGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSBdLFxuICAgICAgICAgICAgd3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXG5cbiAgICAgICAgICAgIG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxuICAgICAgICAgICAgYW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdG8gVEhSRUUuSW1hZ2VcblxuICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuICAgICAgICAgICAgaWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBpbWFnZS51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTsgLy8gVUdIXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID0ge1xuICAgICAgICAgICAgICAgICAgICB1dWlkOiBpbWFnZS51dWlkLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdldERhdGFVUkwoIGltYWdlIClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dHB1dC5pbWFnZSA9IGltYWdlLnV1aWQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdID0gb3V0cHV0O1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG5cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7XG4gICAgICAgICAgICB0eXBlOiAnZGlzcG9zZSdcbiAgICAgICAgfSApO1xuXG4gICAgfSxcblxuICAgIHRyYW5zZm9ybVV2OiBmdW5jdGlvbiggdXYgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLm1hcHBpbmcgIT09IFRIUkVFLlVWTWFwcGluZyApIHJldHVybjtcblxuICAgICAgICB1di5tdWx0aXBseSggdGhpcy5yZXBlYXQgKTtcbiAgICAgICAgdXYuYWRkKCB0aGlzLm9mZnNldCApO1xuXG4gICAgICAgIGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIHRoaXMud3JhcFMgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxuXG4gICAgICAgICAgICAgICAgICAgIHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuICAgICAgICAgICAgICAgICAgICB1di54ID0gdXYueCA8IDAgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueCApICUgMiApID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcblxuICAgICAgICAgICAgc3dpdGNoICggdGhpcy53cmFwVCApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuUmVwZWF0V3JhcHBpbmc6XG5cbiAgICAgICAgICAgICAgICAgICAgdXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG4gICAgICAgICAgICAgICAgICAgIHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di55ICkgJSAyICkgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHV2LnkgPSBNYXRoLmNlaWwoIHV2LnkgKSAtIHV2Lnk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuZmxpcFkgKSB7XG5cbiAgICAgICAgICAgIHV2LnkgPSAxIC0gdXYueTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5cblRIUkVFLlRleHR1cmVJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ2FudmFzVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ2FudmFzVGV4dHVyZSA9IGZ1bmN0aW9uKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbnZhc1RleHR1cmU7XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DdWJlVGV4dHVyZSA9IGZ1bmN0aW9uKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICAgIG1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gICAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViZVRleHR1cmU7XG5cblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLmltYWdlcyA9IHNvdXJjZS5pbWFnZXM7XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcbi8vIEZpbGU6c3JjL3RleHR1cmVzL0NvbXByZXNzZWRUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZSA9IGZ1bmN0aW9uKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gICAgdGhpcy5pbWFnZSA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gICAgdGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuICAgIC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXG4gICAgLy8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuICAgIC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcbiAgICAvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXG5cbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0RhdGFUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZSA9IGZ1bmN0aW9uKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gICAgdGhpcy5pbWFnZSA9IHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG5cbiAgICB0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICB0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcblxuICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGF0YVRleHR1cmU7XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL1ZpZGVvVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuVmlkZW9UZXh0dXJlID0gZnVuY3Rpb24oIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlICk7XG5cbiAgICAgICAgaWYgKCB2aWRlby5yZWFkeVN0YXRlID09PSB2aWRlby5IQVZFX0VOT1VHSF9EQVRBICkge1xuXG4gICAgICAgICAgICBzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WaWRlb1RleHR1cmU7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvR3JvdXAuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnR3JvdXAnO1xuXG59O1xuXG5USFJFRS5Hcm91cC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkdyb3VwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkdyb3VwO1xuLy8gRmlsZTpzcmMvb2JqZWN0cy9Qb2ludHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlBvaW50cyA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUG9pbnRzJztcblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZcbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLlBvaW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludHM7XG5cblRIUkVFLlBvaW50cy5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcblxuICAgICAgICBpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcbiAgICAgICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xuICAgICAgICB2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XG5cbiAgICAgICAgICAgIHZhciByYXlQb2ludERpc3RhbmNlU3EgPSByYXkuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICk7XG5cbiAgICAgICAgICAgIGlmICggcmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3RQb2ludCA9IHJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCApO1xuICAgICAgICAgICAgICAgIGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KCByYXlQb2ludERpc3RhbmNlU3EgKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3RcblxuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGluZGljZXNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXN0UG9pbnQoIHBvc2l0aW9uLCBhICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpICk7XG5cblRIUkVFLlBvaW50cy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBnZW9tZXRyaWVzIGNhY2hlXG4gICAgaWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCk7XG5cbiAgICB9XG5cbiAgICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG5cbiAgICB9XG5cbiAgICBkYXRhLm9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcbiAgICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5USFJFRS5Qb2ludENsb3VkID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuVEhSRUUuUGFydGljbGVTeXN0ZW0gPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcblxuICAgIGlmICggbW9kZSA9PT0gMSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lOiBwYXJhbWV0ZXIgVEhSRUUuTGluZVBpZWNlcyBubyBsb25nZXIgc3VwcG9ydGVkLiBDcmVhdGVkIFRIUkVFLkxpbmVTZWdtZW50cyBpbnN0ZWFkLicgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5MaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgfVxuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0xpbmUnO1xuXG4gICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZlxuICAgIH0gKTtcblxufTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcbiAgICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gcmF5Y2FzdGVyLmxpbmVQcmVjaXNpb247XG4gICAgICAgIHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuICAgICAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICAgICAgc3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIGlmICggcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuICAgICAgICByYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG4gICAgICAgIHZhciB2U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBpbnRlclNlZ21lbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgaW50ZXJSYXkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgc3RlcCA9IHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgPyAyIDogMTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGluZGljZXNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcbiAgICAgICAgICAgICAgICAgICAgdkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSApO1xuICAgICAgICAgICAgICAgICAgICB2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSArIDMgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICAgICAgICAgIHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSArPSBzdGVwICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpICk7XG5cblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cblRIUkVFLkxpbmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCBtZXRhICkge1xuXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIGdlb21ldHJpZXMgY2FjaGVcbiAgICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oKTtcblxuICAgIH1cblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICAgIGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oKTtcblxuICAgIH1cblxuICAgIGRhdGEub2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuICAgIGRhdGEub2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIERFUFJFQ0FURURcblxuVEhSRUUuTGluZVN0cmlwID0gMDtcblRIUkVFLkxpbmVQaWVjZXMgPSAxO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmVTZWdtZW50cy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTGluZVNlZ21lbnRzID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcblxufTtcblxuVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZVNlZ21lbnRzO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL01lc2guanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXG4gKi9cblxuVEhSRUUuTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnTWVzaCc7XG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmXG4gICAgfSApO1xuXG4gICAgdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaDtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0QmFzZSA9IC0xO1xuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG4gICAgICAgIGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSsrICkge1xuXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHNbIG0gXS5uYW1lIF0gPSBtO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZSA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgaWYgKCB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF07XG5cbiAgICB9XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcblxuICAgIHJldHVybiAwO1xuXG59O1xuXG5cblRIUkVFLk1lc2gucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XG4gICAgdmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHZCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdkMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIHRlbXBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdGVtcEIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB0ZW1wQyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgdXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB2YXIgdXZCID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB2YXIgdXZDID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIHZhciBiYXJ5Y29vcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmdW5jdGlvbiB1dkludGVyc2VjdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMgKSB7XG5cbiAgICAgICAgVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XG5cbiAgICAgICAgdXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xuICAgICAgICB1djIubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC55ICk7XG4gICAgICAgIHV2My5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnogKTtcblxuICAgICAgICB1djEuYWRkKCB1djIgKS5hZGQoIHV2MyApO1xuXG4gICAgICAgIHJldHVybiB1djEuY2xvbmUoKTtcblxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuICAgICAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgaWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcblxuICAgICAgICBpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcbiAgICAgICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEsIGIsIGM7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICBhID0gaW5kaWNlc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICBiID0gaW5kaWNlc1sgaSArIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGluZGljZXNbIGkgKyAyIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG4gICAgICAgICAgICAgICAgICAgIHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuICAgICAgICAgICAgICAgICAgICB2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkMsIHZCLCB2QSwgdHJ1ZSwgaW50ZXJzZWN0aW9uUG9pbnQgKSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QSwgdkIsIHZDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBpbnRlcnNlY3Rpb25Qb2ludCApID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggaW50ZXJzZWN0aW9uUG9pbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1djtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dkEuZnJvbUFycmF5KCB1dnMsIGEgKiAyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dkIuZnJvbUFycmF5KCB1dnMsIGIgKiAyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2QyApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2OiB1dixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2U6IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogTWF0aC5mbG9vciggaSAvIDMgKSwgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGljZXMgYnVmZmVyIHNlbWFudGljc1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkgKz0gOSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgICAgICAgICAgICB2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDMgKTtcbiAgICAgICAgICAgICAgICAgICAgdkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZDLCB2QiwgdkEsIHRydWUsIGludGVyc2VjdGlvblBvaW50ICkgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkEsIHZCLCB2QywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSwgaW50ZXJzZWN0aW9uUG9pbnQgKSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIGludGVyc2VjdGlvblBvaW50ICk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2LmFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdXZBLmZyb21BcnJheSggdXZzLCBpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dkIuZnJvbUFycmF5KCB1dnMsIGkgKyAyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dkMuZnJvbUFycmF5KCB1dnMsIGkgKyA0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2QyApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhID0gaSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBhICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGEgKyAyO1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXY6IHV2LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZTogbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGEsIC8vIHRyaWFuZ2xlIG51bWJlciBpbiBwb3NpdGlvbnMgYnVmZmVyIHNlbWFudGljc1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIGlzRmFjZU1hdGVyaWFsID0gbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWwubWF0ZXJpYWxzIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgICAgICAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblxuICAgICAgICAgICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBmIF07XG4gICAgICAgICAgICAgICAgdmFyIGZhY2VNYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG1hdGVyaWFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmYWNlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgYSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICAgICAgICAgICAgICBiID0gdmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgICAgICAgICAgIGMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZhY2VNYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgICAgICAgICAgICAgICAgIHZBLnNldCggMCwgMCwgMCApO1xuICAgICAgICAgICAgICAgICAgICB2Qi5zZXQoIDAsIDAsIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgdkMuc2V0KCAwLCAwLCAwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZBLmFkZFNjYWxlZFZlY3RvciggdGVtcEEuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5hIF0sIGEgKSwgaW5mbHVlbmNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBiICksIGluZmx1ZW5jZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdkMuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQy5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmMgXSwgYyApLCBpbmZsdWVuY2UgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdkEuYWRkKCBhICk7XG4gICAgICAgICAgICAgICAgICAgIHZCLmFkZCggYiApO1xuICAgICAgICAgICAgICAgICAgICB2Qy5hZGQoIGMgKTtcblxuICAgICAgICAgICAgICAgICAgICBhID0gdkE7XG4gICAgICAgICAgICAgICAgICAgIGIgPSB2QjtcbiAgICAgICAgICAgICAgICAgICAgYyA9IHZDO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBmYWNlTWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIGMsIGIsIGEsIHRydWUsIGludGVyc2VjdGlvblBvaW50ICkgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJheS5pbnRlcnNlY3RUcmlhbmdsZSggYSwgYiwgYywgZmFjZU1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUsIGludGVyc2VjdGlvblBvaW50ICkgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggaW50ZXJzZWN0aW9uUG9pbnQgKTtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHV2O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdWyBmIF07XG4gICAgICAgICAgICAgICAgICAgIHV2QS5jb3B5KCB1dnNbIDAgXSApO1xuICAgICAgICAgICAgICAgICAgICB1dkIuY29weSggdXZzWyAxIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgdXZDLmNvcHkoIHV2c1sgMiBdICk7XG4gICAgICAgICAgICAgICAgICAgIHV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCBhLCBiLCBjLCB1dkEsIHV2QiwgdXZDICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIHV2OiB1dixcbiAgICAgICAgICAgICAgICAgICAgZmFjZTogZmFjZSxcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBmLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSApO1xuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5NZXNoLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBnZW9tZXRyaWVzIGNhY2hlXG4gICAgaWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCBtZXRhICk7XG5cbiAgICB9XG5cbiAgICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCBtZXRhICk7XG5cbiAgICB9XG5cbiAgICBkYXRhLm9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcbiAgICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0JvbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLkJvbmUgPSBmdW5jdGlvbiggc2tpbiApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdCb25lJztcblxuICAgIHRoaXMuc2tpbiA9IHNraW47XG5cbn07XG5cblRIUkVFLkJvbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5Cb25lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJvbmU7XG5cblRIUkVFLkJvbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICB0aGlzLnNraW4gPSBzb3VyY2Uuc2tpbjtcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NrZWxldG9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pY2hhZWwgZ3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tlbGV0b24gPSBmdW5jdGlvbiggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgIHRoaXMudXNlVmVydGV4VGV4dHVyZSA9IHVzZVZlcnRleFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IHVzZVZlcnRleFRleHR1cmUgOiB0cnVlO1xuXG4gICAgdGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAvLyBjb3B5IHRoZSBib25lIGFycmF5XG5cbiAgICBib25lcyA9IGJvbmVzIHx8IFtdO1xuXG4gICAgdGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XG5cbiAgICAvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXG5cbiAgICBpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgICAvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG4gICAgICAgIC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcbiAgICAgICAgLy8gIHdpdGggIDh4OCAgcGl4ZWwgdGV4dHVyZSBtYXggICAxNiBib25lcyAqIDQgcGl4ZWxzID0gICg4ICogOClcbiAgICAgICAgLy8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXG4gICAgICAgIC8vICAgICAgIDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgYm9uZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxuICAgICAgICAvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICogNCBwaXhlbHMgPSAoNjQgKiA2NClcblxuXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLmJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxuICAgICAgICBzaXplID0gVEhSRUUuTWF0aC5uZXh0UG93ZXJPZlR3byggTWF0aC5jZWlsKCBzaXplICkgKTtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XG5cbiAgICAgICAgdGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcbiAgICAgICAgdGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XG5cbiAgICAgICAgdGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLmJvbmVUZXh0dXJlV2lkdGggKiB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxuICAgICAgICB0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBUSFJFRS5SR0JBRm9ybWF0LCBUSFJFRS5GbG9hdFR5cGUgKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICB0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdGhpcy5ib25lcy5sZW5ndGggKTtcblxuICAgIH1cblxuICAgIC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXG5cbiAgICBpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcy5zbGljZSggMCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uIGJvbkludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xuXG4gICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYisrICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IFRIUkVFLk1hdHJpeDQoKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2FsY3VsYXRlSW52ZXJzZXMgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cbiAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYisrICkge1xuXG4gICAgICAgIHZhciBpbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgICBpZiAoIHRoaXMuYm9uZXNbIGIgXSApIHtcblxuICAgICAgICAgICAgaW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGJvbmU7XG5cbiAgICAvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcblxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiKysgKSB7XG5cbiAgICAgICAgYm9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuICAgICAgICBpZiAoIGJvbmUgKSB7XG5cbiAgICAgICAgICAgIGJvbmUubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXG5cbiAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYisrICkge1xuXG4gICAgICAgIGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cbiAgICAgICAgaWYgKCBib25lICkge1xuXG4gICAgICAgICAgICBpZiAoIGJvbmUucGFyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgYm9uZS5tYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICBib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgb2Zmc2V0TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICAgICAgLy8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XG5cbiAgICAgICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIrKyApIHtcblxuICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cblxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuYm9uZXNbIGIgXSA/IHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCA6IHRoaXMuaWRlbnRpdHlNYXRyaXg7XG5cbiAgICAgICAgICAgIG9mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcbiAgICAgICAgICAgIG9mZnNldE1hdHJpeC5mbGF0dGVuVG9BcnJheU9mZnNldCggdGhpcy5ib25lTWF0cmljZXMsIGIgKiAxNiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgICAgICAgdGhpcy5ib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSApKCk7XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Ta2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NraW5uZWRNZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgdGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcblxuICAgIHRoaXMuYmluZE1vZGUgPSBcImF0dGFjaGVkXCI7XG4gICAgdGhpcy5iaW5kTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIC8vIGluaXQgYm9uZXNcblxuICAgIC8vIFRPRE86IHJlbW92ZSBib25lIGNyZWF0aW9uIGFzIHRoZXJlIGlzIG5vIHJlYXNvbiAob3RoZXIgdGhhblxuICAgIC8vIGNvbnZlbmllbmNlKSBmb3IgVEhSRUUuU2tpbm5lZE1lc2ggdG8gZG8gdGhpcy5cblxuICAgIHZhciBib25lcyA9IFtdO1xuXG4gICAgaWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgYm9uZSwgZ2JvbmU7XG5cbiAgICAgICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrYiApIHtcblxuICAgICAgICAgICAgZ2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XG5cbiAgICAgICAgICAgIGJvbmUgPSBuZXcgVEhSRUUuQm9uZSggdGhpcyApO1xuICAgICAgICAgICAgYm9uZXMucHVzaCggYm9uZSApO1xuXG4gICAgICAgICAgICBib25lLm5hbWUgPSBnYm9uZS5uYW1lO1xuICAgICAgICAgICAgYm9uZS5wb3NpdGlvbi5mcm9tQXJyYXkoIGdib25lLnBvcyApO1xuICAgICAgICAgICAgYm9uZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggZ2JvbmUucm90cSApO1xuICAgICAgICAgICAgaWYgKCBnYm9uZS5zY2wgIT09IHVuZGVmaW5lZCApIGJvbmUuc2NhbGUuZnJvbUFycmF5KCBnYm9uZS5zY2wgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrYiApIHtcblxuICAgICAgICAgICAgZ2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XG5cbiAgICAgICAgICAgIGlmICggZ2JvbmUucGFyZW50ICE9PSAtMSApIHtcblxuICAgICAgICAgICAgICAgIGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBiIF0gKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZCggYm9uZXNbIGIgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG4gICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuICAgIHRoaXMuYmluZCggbmV3IFRIUkVFLlNrZWxldG9uKCBib25lcywgdW5kZWZpbmVkLCB1c2VWZXJ0ZXhUZXh0dXJlICksIHRoaXMubWF0cml4V29ybGQgKTtcblxufTtcblxuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tpbm5lZE1lc2g7XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xuXG4gICAgdGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG4gICAgaWYgKCBiaW5kTWF0cml4ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICAgIHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuICAgICAgICBiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuICAgIH1cblxuICAgIHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XG4gICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCBiaW5kTWF0cml4ICk7XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLnNrZWxldG9uLnBvc2UoKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLm5vcm1hbGl6ZVNraW5XZWlnaHRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoIHRoaXMuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XG5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xuXG4gICAgICAgICAgICBpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuICAgICAgICAgICAgICAgIHN3Lm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIC8vIHNraW5uaW5nIHdlaWdodHMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIGZvciBUSFJFRS5CdWZmZXJHZW9tZXRyeVxuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiggZm9yY2UgKSB7XG5cbiAgICBUSFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cbiAgICBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiYXR0YWNoZWRcIiApIHtcblxuICAgICAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIH1cbiAgICBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJkZXRhY2hlZFwiICkge1xuXG4gICAgICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuU2tpbm5lZE1lc2ggdW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCwgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkuY29weSggdGhpcyApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL01vcnBoQW5pbU1lc2guanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1vcnBoQW5pbU1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIHRoaXMudHlwZSA9ICdNb3JwaEFuaW1NZXNoJztcblxuICAgIC8vIEFQSVxuXG4gICAgdGhpcy5kdXJhdGlvbiA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICAgIHRoaXMubWlycm9yZWRMb29wID0gZmFsc2U7XG4gICAgdGhpcy50aW1lID0gMDtcblxuICAgIC8vIGludGVybmFsc1xuXG4gICAgdGhpcy5sYXN0S2V5ZnJhbWUgPSAwO1xuICAgIHRoaXMuY3VycmVudEtleWZyYW1lID0gMDtcblxuICAgIHRoaXMuZGlyZWN0aW9uID0gMTtcbiAgICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRGcmFtZVJhbmdlKCAwLCBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoIC0gMSApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1vcnBoQW5pbU1lc2g7XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEZyYW1lUmFuZ2UgPSBmdW5jdGlvbiggc3RhcnQsIGVuZCApIHtcblxuICAgIHRoaXMuc3RhcnRLZXlmcmFtZSA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kS2V5ZnJhbWUgPSBlbmQ7XG5cbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZW5kS2V5ZnJhbWUgLSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyAxO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXREaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmRpcmVjdGlvbiA9IDE7XG4gICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuZGlyZWN0aW9uID0gLTE7XG4gICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5wYXJzZUFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgICBpZiAoICFnZW9tZXRyeS5hbmltYXRpb25zICkgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZpcnN0QW5pbWF0aW9uLCBhbmltYXRpb25zID0gZ2VvbWV0cnkuYW5pbWF0aW9ucztcblxuICAgIHZhciBwYXR0ZXJuID0gLyhbYS16XSspXz8oXFxkKykvO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBtb3JwaCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdO1xuICAgICAgICB2YXIgcGFydHMgPSBtb3JwaC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XG5cbiAgICAgICAgaWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBwYXJ0c1sgMSBdO1xuXG4gICAgICAgICAgICBpZiAoICFhbmltYXRpb25zWyBsYWJlbCBdICkgYW5pbWF0aW9uc1sgbGFiZWwgXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgZW5kOiAtSW5maW5pdHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zWyBsYWJlbCBdO1xuXG4gICAgICAgICAgICBpZiAoIGkgPCBhbmltYXRpb24uc3RhcnQgKSBhbmltYXRpb24uc3RhcnQgPSBpO1xuICAgICAgICAgICAgaWYgKCBpID4gYW5pbWF0aW9uLmVuZCApIGFuaW1hdGlvbi5lbmQgPSBpO1xuXG4gICAgICAgICAgICBpZiAoICFmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbGFiZWw7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ2VvbWV0cnkuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uTGFiZWwgPSBmdW5jdGlvbiggbGFiZWwsIHN0YXJ0LCBlbmQgKSB7XG5cbiAgICBpZiAoICF0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgKSB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgPSB7fTtcblxuICAgIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXSA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgIH07XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiggbGFiZWwsIGZwcyApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnNbIGxhYmVsIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICB0aGlzLnNldEZyYW1lUmFuZ2UoIGFuaW1hdGlvbi5zdGFydCwgYW5pbWF0aW9uLmVuZCApO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMTAwMCAqICggKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBmcHMgKTtcbiAgICAgICAgdGhpcy50aW1lID0gMDtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Nb3JwaEFuaW1NZXNoOiBhbmltYXRpb25bJyArIGxhYmVsICsgJ10gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKCknICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBkZWx0YSApIHtcblxuICAgIHZhciBmcmFtZVRpbWUgPSB0aGlzLmR1cmF0aW9uIC8gdGhpcy5sZW5ndGg7XG5cbiAgICB0aGlzLnRpbWUgKz0gdGhpcy5kaXJlY3Rpb24gKiBkZWx0YTtcblxuICAgIGlmICggdGhpcy5taXJyb3JlZExvb3AgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uIHx8IHRoaXMudGltZSA8IDAgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uICo9IC0xO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMudGltZSA+IHRoaXMuZHVyYXRpb24gKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXMudGltZSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgdGhpcy50aW1lID0gdGhpcy50aW1lICUgdGhpcy5kdXJhdGlvbjtcblxuICAgICAgICBpZiAoIHRoaXMudGltZSA8IDAgKSB0aGlzLnRpbWUgKz0gdGhpcy5kdXJhdGlvbjtcblxuICAgIH1cblxuICAgIHZhciBrZXlmcmFtZSA9IHRoaXMuc3RhcnRLZXlmcmFtZSArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIHRoaXMudGltZSAvIGZyYW1lVGltZSApLCAwLCB0aGlzLmxlbmd0aCAtIDEgKTtcblxuICAgIHZhciBpbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICBpZiAoIGtleWZyYW1lICE9PSB0aGlzLmN1cnJlbnRLZXlmcmFtZSApIHtcblxuICAgICAgICBpbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMDtcbiAgICAgICAgaW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IDE7XG4gICAgICAgIGluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xuXG4gICAgICAgIHRoaXMubGFzdEtleWZyYW1lID0gdGhpcy5jdXJyZW50S2V5ZnJhbWU7XG4gICAgICAgIHRoaXMuY3VycmVudEtleWZyYW1lID0ga2V5ZnJhbWU7XG5cbiAgICB9XG5cbiAgICB2YXIgbWl4ID0gKCB0aGlzLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcblxuICAgIGlmICggdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgKSB7XG5cbiAgICAgICAgbWl4ID0gMSAtIG1peDtcblxuICAgIH1cblxuICAgIGluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSBtaXg7XG4gICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDEgLSBtaXg7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmludGVycG9sYXRlVGFyZ2V0cyA9IGZ1bmN0aW9uKCBhLCBiLCB0ICkge1xuXG4gICAgdmFyIGluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIGluZmx1ZW5jZXNbIGkgXSA9IDA7XG5cbiAgICB9XG5cbiAgICBpZiAoIGEgPiAtMSApIGluZmx1ZW5jZXNbIGEgXSA9IDEgLSB0O1xuICAgIGlmICggYiA+IC0xICkgaW5mbHVlbmNlc1sgYiBdID0gdDtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5NZXNoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5kdXJhdGlvbiA9IHNvdXJjZS5kdXJhdGlvbjtcbiAgICB0aGlzLm1pcnJvcmVkTG9vcCA9IHNvdXJjZS5taXJyb3JlZExvb3A7XG4gICAgdGhpcy50aW1lID0gc291cmNlLnRpbWU7XG5cbiAgICB0aGlzLmxhc3RLZXlmcmFtZSA9IHNvdXJjZS5sYXN0S2V5ZnJhbWU7XG4gICAgdGhpcy5jdXJyZW50S2V5ZnJhbWUgPSBzb3VyY2UuY3VycmVudEtleWZyYW1lO1xuXG4gICAgdGhpcy5kaXJlY3Rpb24gPSBzb3VyY2UuZGlyZWN0aW9uO1xuICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gc291cmNlLmRpcmVjdGlvbkJhY2t3YXJkcztcblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xPRC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MT0QgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdMT0QnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcbiAgICAgICAgbGV2ZWxzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIG9iamVjdHM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy4nICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxzO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbn07XG5cblxuVEhSRUUuTE9ELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTE9ELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxPRDtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5hZGRMZXZlbCA9IGZ1bmN0aW9uKCBvYmplY3QsIGRpc3RhbmNlICkge1xuXG4gICAgaWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xuXG4gICAgZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcblxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgIGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwrKyApIHtcblxuICAgICAgICBpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGxldmVscy5zcGxpY2UoIGwsIDAsIHtcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH0gKTtcblxuICAgIHRoaXMuYWRkKCBvYmplY3QgKTtcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5nZXRPYmplY3RGb3JEaXN0YW5jZSA9IGZ1bmN0aW9uKCBkaXN0YW5jZSApIHtcblxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgIGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgICAgIG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIG1hdHJpeFBvc2l0aW9uICk7XG5cbiAgICAgICAgdGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuICAgIH07XG5cbn0oKSApO1xuXG5USFJFRS5MT0QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xuXG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgICAgICBpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xuXG4gICAgICAgICAgICB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XG5cbiAgICAgICAgICAgIGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPj0gbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxzWyBpIC0gMSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpO1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCBmYWxzZSApO1xuXG4gICAgdmFyIGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xuXG4gICAgICAgIHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgZGF0YS5vYmplY3QubGV2ZWxzID0gW107XG5cbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xuXG4gICAgICAgIGRhdGEub2JqZWN0LmxldmVscy5wdXNoKCB7XG4gICAgICAgICAgICBvYmplY3Q6IGxldmVsLm9iamVjdC51dWlkLFxuICAgICAgICAgICAgZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXG4gICAgICAgIH0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1Nwcml0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwcml0ZSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAyLCAwLCAyLCAzIF0gKTtcbiAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIC0wLjUsIC0wLjUsIDAsIDAuNSwgLTAuNSwgMCwgMC41LCAwLjUsIDAsIC0wLjUsIDAuNSwgMCBdICk7XG4gICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSBdICk7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFNwcml0ZSggbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgICAgIHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoKTtcblxuICAgIH07XG5cbn0gKSgpO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICAgICAgbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlU3EgPSByYXljYXN0ZXIucmF5LmRpc3RhbmNlU3FUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xuICAgICAgICB2YXIgZ3Vlc3NTaXplU3EgPSB0aGlzLnNjYWxlLnggKiB0aGlzLnNjYWxlLnk7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZVNxID4gZ3Vlc3NTaXplU3EgKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoIGRpc3RhbmNlU3EgKSxcbiAgICAgICAgICAgIHBvaW50OiB0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgIH0gKTtcblxuICAgIH07XG5cbn0oKSApO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgbWF0ZXJpYWxzIGNhY2hlXG4gICAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTigpO1xuXG4gICAgfVxuXG4gICAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGVuc0ZsYXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24oIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLmxlbnNGbGFyZXMgPSBbXTtcblxuICAgIHRoaXMucG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIHRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGVuc0ZsYXJlO1xuXG5cbi8qXG4gKiBBZGQ6IGFkZHMgYW5vdGhlciBmbGFyZVxuICovXG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IsIG9wYWNpdHkgKSB7XG5cbiAgICBpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtMTtcbiAgICBpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG4gICAgaWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcbiAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcbiAgICBpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG4gICAgZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cbiAgICB0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xuICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLCAvLyBUSFJFRS5UZXh0dXJlXG4gICAgICAgIHNpemU6IHNpemUsIC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsIC8vIGRpc3RhbmNlICgwLTEpIGZyb20gbGlnaHQgc291cmNlICgwPWF0IGxpZ2h0IHNvdXJjZSlcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgejogMCwgLy8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXG4gICAgICAgIHNjYWxlOiAxLCAvLyBzY2FsZVxuICAgICAgICByb3RhdGlvbjogMCwgLy8gcm90YXRpb25cbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eSwgLy8gb3BhY2l0eVxuICAgICAgICBjb2xvcjogY29sb3IsIC8vIGNvbG9yXG4gICAgICAgIGJsZW5kaW5nOiBibGVuZGluZyAvLyBibGVuZGluZ1xuICAgIH0gKTtcblxufTtcblxuLypcbiAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxuICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBmLCBmbCA9IHRoaXMubGVuc0ZsYXJlcy5sZW5ndGg7XG4gICAgdmFyIGZsYXJlO1xuICAgIHZhciB2ZWNYID0gLXRoaXMucG9zaXRpb25TY3JlZW4ueCAqIDI7XG4gICAgdmFyIHZlY1kgPSAtdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcblxuICAgIGZvciAoIGYgPSAwOyBmIDwgZmw7IGYrKyApIHtcblxuICAgICAgICBmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xuXG4gICAgICAgIGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XG4gICAgICAgIGZsYXJlLnkgPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKyB2ZWNZICogZmxhcmUuZGlzdGFuY2U7XG5cbiAgICAgICAgZmxhcmUud2FudGVkUm90YXRpb24gPSBmbGFyZS54ICogTWF0aC5QSSAqIDAuMjU7XG4gICAgICAgIGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgdGhpcy5wb3NpdGlvblNjcmVlbi5jb3B5KCBzb3VyY2UucG9zaXRpb25TY3JlZW4gKTtcbiAgICB0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gc291cmNlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmxlbnNGbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHRoaXMubGVuc0ZsYXJlcy5wdXNoKCBzb3VyY2UubGVuc0ZsYXJlc1sgaSBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvc2NlbmVzL1NjZW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TY2VuZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1NjZW5lJztcblxuICAgIHRoaXMuZm9nID0gbnVsbDtcbiAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxufTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiggc291cmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBpZiAoIHNvdXJjZS5mb2cgIT09IG51bGwgKSB0aGlzLmZvZyA9IHNvdXJjZS5mb2cuY2xvbmUoKTtcbiAgICBpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcblxuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHNvdXJjZS5hdXRvVXBkYXRlO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2cgPSBmdW5jdGlvbiggY29sb3IsIG5lYXIsIGZhciApIHtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcblxuICAgIHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcbiAgICB0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XG5cbn07XG5cblRIUkVFLkZvZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuRm9nKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2dFeHAyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRm9nRXhwMiA9IGZ1bmN0aW9uKCBjb2xvciwgZGVuc2l0eSApIHtcblxuICAgIHRoaXMubmFtZSA9ICcnO1xuXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcbiAgICB0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XG5cbn07XG5cblRIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay5qc1xuXG5USFJFRS5TaGFkZXJDaHVuayA9IHt9O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYXRlc3RfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhdGVzdF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIEFMUEhBVEVTVFxcblxcblx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcblx0dG90YWxBbWJpZW50TGlnaHQgKj0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYmVnaW5fdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdiZWdpbl92ZXJ0ZXgnIF0gPSBcIlxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JlZ2lubm9ybWFsX3ZlcnRleCcgXSA9IFwiXFxudmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYnVtcG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdidW1wbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcblx0Ly8gRGVyaXZhdGl2ZSBtYXBzIC0gYnVtcCBtYXBwaW5nIHVucGFyYW1ldHJpemVkIHN1cmZhY2VzIGJ5IE1vcnRlbiBNaWtrZWxzZW5cXG5cdC8vIGh0dHA6Ly9tbWlra2Vsc2VuM2QuYmxvZ3Nwb3Quc2svMjAxMS8wNy9kZXJpdmF0aXZlLW1hcHMuaHRtbFxcblxcblx0Ly8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXFxuXFxuXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXG5cdFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblx0XHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFxuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cdFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXHRcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcblx0XHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXG5cdH1cXG5cXG5cdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFxuXHRcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdk4gPSBzdXJmX25vcm07XHRcdC8vIG5vcm1hbGl6ZWRcXG5cXG5cdFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblx0XHR2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFxuXHRcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxuXFxuXHRcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblx0XHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdHZDb2xvci54eXogPSBjb2xvci54eXo7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbW1vbi5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29tbW9uJyBdID0gXCIjZGVmaW5lIFBJIDMuMTQxNTlcXG4jZGVmaW5lIFBJMiA2LjI4MzE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0XFxuI2RlZmluZSBMT0cyIDEuNDQyNjk1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG5cXG4jZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2RlZmluZSB3aGl0ZUNvbXBsaW1lbnQoYSkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5cXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBub3JtYWwsIGluIG1hdDQgbWF0cml4ICkge1xcblxcblx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBub3JtYWwsIDAuMCApICkueHl6ICk7XFxuXFxufVxcblxcbi8vIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvR0xTTF9Qcm9ncmFtbWluZy9BcHBseWluZ19NYXRyaXhfVHJhbnNmb3JtYXRpb25zXFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIG5vcm1hbCwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIG5vcm1hbCwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG5cXG59XFxuXFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG5cdGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQgLSBwb2ludE9uUGxhbmUgKTtcXG5cXG5cdHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXG5cXG59XFxuXFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblx0cmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXG5cXG59XFxuXFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXHRyZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxuXFxufVxcblxcbmZsb2F0IGNhbGNMaWdodEF0dGVudWF0aW9uKCBmbG9hdCBsaWdodERpc3RhbmNlLCBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXG5cdGlmICggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG5cXG5cdCAgcmV0dXJuIHBvdyggc2F0dXJhdGUoIC1saWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApO1xcblxcblx0fVxcblxcblx0cmV0dXJuIDEuMDtcXG5cXG59XFxuXFxudmVjMyBGX1NjaGxpY2soIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgZG90TEggKSB7XFxuXFxuXHQvLyBPcmlnaW5hbCBhcHByb3hpbWF0aW9uIGJ5IENocmlzdG9waGUgU2NobGljayAnOTRcXG5cdC8vO2Zsb2F0IGZyZXNuZWwgPSBwb3coIDEuMCAtIGRvdExILCA1LjAgKTtcXG5cXG5cdC8vIE9wdGltaXplZCB2YXJpYW50IChwcmVzZW50ZWQgYnkgRXBpYyBhdCBTSUdHUkFQSCAnMTMpXFxuXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQzNyAqIGRvdExIIC0gNi45ODMxNiApICogZG90TEggKTtcXG5cXG5cdHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIGZyZXNuZWwgKyBzcGVjdWxhckNvbG9yO1xcblxcbn1cXG5cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGluIGZsb2F0IGRvdE5MLCBpbiBmbG9hdCBkb3ROViAqLyApIHtcXG5cXG5cdC8vIGdlb21ldHJ5IHRlcm0gaXMgKG7ii4VsKShu4ouFdikgLyA0KG7ii4VsKShu4ouFdilcXG5cXG5cdHJldHVybiAwLjI1O1xcblxcbn1cXG5cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gZmxvYXQgZG90TkggKSB7XFxuXFxuXHQvLyBmYWN0b3Igb2YgMS9QSSBpbiBkaXN0cmlidXRpb24gdGVybSBvbWl0dGVkXFxuXFxuXHRyZXR1cm4gKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcblxcbn1cXG5cXG52ZWMzIEJSREZfQmxpbm5QaG9uZyggaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBpbiBmbG9hdCBzaGluaW5lc3MsIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWMzIGxpZ2h0RGlyLCBpbiB2ZWMzIHZpZXdEaXIgKSB7XFxuXFxuXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcblx0Ly9mbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblx0Ly9mbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGxpZ2h0RGlyLCBoYWxmRGlyICkgKTtcXG5cXG5cdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cXG5cdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGRvdE5MLCBkb3ROViAqLyApO1xcblxcblx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcblx0cmV0dXJuIEYgKiBHICogRDtcXG5cXG59XFxuXFxudmVjMyBpbnB1dFRvTGluZWFyKCBpbiB2ZWMzIGEgKSB7XFxuXFxuXHQjaWZkZWYgR0FNTUFfSU5QVVRcXG5cXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHJldHVybiBhO1xcblxcblx0I2VuZGlmXFxuXFxufVxcblxcbnZlYzMgbGluZWFyVG9PdXRwdXQoIGluIHZlYzMgYSApIHtcXG5cXG5cdCNpZmRlZiBHQU1NQV9PVVRQVVRcXG5cXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggMS4wIC8gZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHJldHVybiBhO1xcblxcblx0I2VuZGlmXFxuXFxufVxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kZWZhdWx0bm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZGVmYXVsdG5vcm1hbF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBGTElQX1NJREVEXFxuXFxuXHRvYmplY3ROb3JtYWwgPSAtb2JqZWN0Tm9ybWFsO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBvYmplY3ROb3JtYWw7XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Rpc3BsYWNlbWVudG1hcF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFxuXHR0cmFuc2Zvcm1lZCArPSBub3JtYWwgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB1diApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW1pc3NpdmVtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXG5cdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdiApO1xcblxcblx0ZW1pc3NpdmVDb2xvci5yZ2IgPSBpbnB1dFRvTGluZWFyKCBlbWlzc2l2ZUNvbG9yLnJnYiApO1xcblxcblx0dG90YWxFbWlzc2l2ZUxpZ2h0ICo9IGVtaXNzaXZlQ29sb3IucmdiO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0XHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXHRcdC8vIFRyYW5zZm9ybWluZyBOb3JtYWwgVmVjdG9ycyB3aXRoIHRoZSBJbnZlcnNlIFRyYW5zZm9ybWF0aW9uXFxuXHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXG5cdFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG5cdFx0I2Vsc2VcXG5cXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBmbGlwTm9ybWFsID0gMS4wO1xcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXHRcdHZlYzIgc2FtcGxlVVY7XFxuXHRcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblx0XHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXHRcdHZlYzMgcmVmbGVjdFZpZXcgPSBmbGlwTm9ybWFsICogbm9ybWFsaXplKCh2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkpLnh5eiArIHZlYzMoMC4wLDAuMCwxLjApKTtcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSApO1xcblx0I2VuZGlmXFxuXFxuXHRlbnZDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCBlbnZDb2xvci54eXogKTtcXG5cXG5cdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cXG5cdFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXFxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXFxuXHRcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXHRcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcblx0I2Vsc2VcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcblx0I2VuZGlmXFxuXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFxuXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2ZWMzIHdvcmxkTm9ybWFsID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBvYmplY3ROb3JtYWwsIG1vZGVsTWF0cml4ICk7XFxuXFxuXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcblx0XHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZm9nX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdGZsb2F0IGZvZ0ZhY3RvciA9IHdoaXRlQ29tcGxpbWVudCggZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTtcXG5cXG5cdCNlbmRpZlxcblx0XFxuXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBmb2dDb2xvciwgZm9nRmFjdG9yICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cXG5cdCNpZmRlZiBGT0dfRVhQMlxcblxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dG90YWxBbWJpZW50TGlnaHQgKz0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleCcgXSA9IFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREZWNheVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4JyBdID0gXCJ2TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcblxcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHBvaW50TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSAtIG12UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdC8vIGF0dGVudWF0aW9uXFxuXFxuXHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiAtIG12UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBsaWdodERpciApO1xcblxcblx0XHRpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcblxcblx0XHRcdHNwb3RFZmZlY3QgPSBzYXR1cmF0ZSggcG93KCBzYXR1cmF0ZSggc3BvdEVmZmVjdCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICkgKTtcXG5cXG5cdFx0XHQvLyBhdHRlbnVhdGlvblxcblxcblx0XHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXHRcdFx0YXR0ZW51YXRpb24gKj0gc3BvdEVmZmVjdDtcXG5cXG5cdFx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdFx0dkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdH1cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHR2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdHZMaWdodEJhY2sgKz0gbGlnaHRDb2xvciAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblx0XHR2TGlnaHRGcm9udCArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgPSAtIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0QmFjayApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG52TGlnaHRGcm9udCArPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHR2TGlnaHRCYWNrICs9IGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19mcmFnbWVudCcgXSA9IFwiI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcblx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0bm9ybWFsID0gbm9ybWFsICogKCAtMS4wICsgMi4wICogZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbHNlXFxuXFxuXHR2ZWMzIGZkeCA9IGRGZHgoIHZWaWV3UG9zaXRpb24gKTtcXG5cdHZlYzMgZmR5ID0gZEZkeSggdlZpZXdQb3NpdGlvbiApO1xcblx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBmZHgsIGZkeSApICk7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXG52ZWMzIHRvdGFsRGlmZnVzZUxpZ2h0ID0gdmVjMyggMC4wICk7XFxudmVjMyB0b3RhbFNwZWN1bGFyTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHBvaW50TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0UG9zaXRpb24gPSBwb2ludExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiArIHZWaWV3UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdC8vIGF0dGVudWF0aW9uXFxuXFxuXHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBjb3NpbmVUZXJtID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFxuXHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXHRcdC8vIHNwZWN1bGFyXFxuXFxuXHRcdHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcblx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHNwb3RMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHRQb3NpdGlvbiA9IHNwb3RMaWdodFBvc2l0aW9uWyBpIF07XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxpZ2h0UG9zaXRpb24gKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbGlnaHREaXIgKTtcXG5cXG5cdFx0aWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5cXG5cdFx0XHRzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApICk7XFxuXFxuXHRcdFx0Ly8gYXR0ZW51YXRpb25cXG5cXG5cdFx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHRcdGF0dGVudWF0aW9uICo9IHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRcdGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG5cdFx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblx0XHRcdC8vIHNwZWN1bGFyXFxuXFxuXHRcdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cdFx0fVxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG5cdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGNvc2luZVRlcm07XFxuXFxuXHRcdC8vIHNwZWN1bGFyXFxuXFxuXHRcdHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcblx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogY29zaW5lVGVybTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcblx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yO1xcblxcblx0XHQvLyBzcGVjdWxhciAoc2t5IHRlcm0gb25seSlcXG5cXG5cdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBNRVRBTFxcblxcblx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB0b3RhbERpZmZ1c2VMaWdodCArIHRvdGFsQW1iaWVudExpZ2h0ICkgKiBzcGVjdWxhciArIHRvdGFsU3BlY3VsYXJMaWdodCArIHRvdGFsRW1pc3NpdmVMaWdodDtcXG5cXG4jZWxzZVxcblxcblx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB0b3RhbERpZmZ1c2VMaWdodCArIHRvdGFsQW1iaWVudExpZ2h0ICkgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCcgXSA9IFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREZWNheVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcblx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4JyBdID0gXCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3ZlcnRleCcgXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpbmVhcl90b19nYW1tYV9mcmFnbWVudCcgXSA9IFwiXFxuXHRvdXRnb2luZ0xpZ2h0ID0gbGluZWFyVG9PdXRwdXQoIG91dGdvaW5nTGlnaHQgKTtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX2ZyYWdtZW50JyBdID0gXCIjaWYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUYpICYmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGX0VYVClcXG5cXG5cdGdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIodkZyYWdEZXB0aCkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdGdsX1Bvc2l0aW9uLnogPSBsb2cyKG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApKSAqIGxvZ0RlcHRoQnVmRkM7XFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXG4jZWxzZVxcblxcblx0XHRnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXG5cXG5cdHRleGVsQ29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggdGV4ZWxDb2xvci54eXogKTtcXG5cXG5cdGRpZmZ1c2VDb2xvciAqPSB0ZXhlbENvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBobm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGhub3JtYWxfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblxcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcblx0I2Vsc2VcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDIgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXG5cdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcblxcblx0Ly8gUGVyLVBpeGVsIFRhbmdlbnQgU3BhY2UgTm9ybWFsIE1hcHBpbmdcXG5cdC8vIGh0dHA6Ly9oYWNrc29mbGlmZS5ibG9nc3BvdC5jaC8yMDA5LzExL3Blci1waXhlbC10YW5nZW50LXNwYWNlLW5vcm1hbC1tYXBwaW5nLmh0bWxcXG5cXG5cdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxuXFxuXHRcdHZlYzMgcTAgPSBkRmR4KCBleWVfcG9zLnh5eiApO1xcblx0XHR2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXG5cdFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcXG5cXG5cdFx0dmVjMyBTID0gbm9ybWFsaXplKCBxMCAqIHN0MS50IC0gcTEgKiBzdDAudCApO1xcblx0XHR2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1xcblx0XHR2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1xcblxcblx0XHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblx0XHRtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1xcblx0XHRtYXQzIHRzbiA9IG1hdDMoIFMsIFQsIE4gKTtcXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9wcm9qZWN0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAncHJvamVjdF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XFxuXFxuI2Vsc2VcXG5cXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXG4jZW5kaWZcXG5cXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdCNpZmRlZiBTSEFET1dNQVBfREVCVUdcXG5cXG5cdFx0dmVjMyBmcnVzdHVtQ29sb3JzWzNdO1xcblx0XHRmcnVzdHVtQ29sb3JzWzBdID0gdmVjMyggMS4wLCAwLjUsIDAuMCApO1xcblx0XHRmcnVzdHVtQ29sb3JzWzFdID0gdmVjMyggMC4wLCAxLjAsIDAuOCApO1xcblx0XHRmcnVzdHVtQ29sb3JzWzJdID0gdmVjMyggMC4wLCAwLjUsIDEuMCApO1xcblxcblx0I2VuZGlmXFxuXFxuXHRmbG9hdCBmRGVwdGg7XFxuXHR2ZWMzIHNoYWRvd0NvbG9yID0gdmVjMyggMS4wICk7XFxuXFxuXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcXG5cXG5cdFx0XHRcdC8vIGlmICggc29tZXRoaW5nICYmIHNvbWV0aGluZyApIGJyZWFrcyBBVEkgT3BlbkdMIHNoYWRlciBjb21waWxlclxcblx0XHRcdFx0Ly8gaWYgKCBhbGwoIHNvbWV0aGluZywgc29tZXRoaW5nICkgKSB1c2luZyB0aGlzIGluc3RlYWRcXG5cXG5cdFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcblx0XHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFxuXHRcdGJ2ZWMyIGZydXN0dW1UZXN0VmVjID0gYnZlYzIoIGluRnJ1c3R1bSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXG5cdFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXG5cXG5cdFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXG5cdFx0XHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG5cXG5cdFx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXG5cdFx0XHRcdFx0XHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xcblx0XHRcdFx0XHRcdC8vICg5IHBpeGVsIGtlcm5lbClcXG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXFxuXFxuXHRcdFx0XHRmbG9hdCBzaGFkb3cgPSAwLjA7XFxuXFxuXHRcdC8qXFxuXHRcdFx0XHRcdFx0Ly8gbmVzdGVkIGxvb3BzIGJyZWFrcyBzaGFkZXIgY29tcGlsZXIgLyB2YWxpZGF0b3Igb24gc29tZSBBVEkgY2FyZHMgd2hlbiB1c2luZyBPcGVuR0xcXG5cdFx0XHRcdFx0XHQvLyBtdXN0IGVucm9sbCBsb29wIG1hbnVhbGx5XFxuXFxuXHRcdFx0XHRmb3IgKCBmbG9hdCB5ID0gLTEuMjU7IHkgPD0gMS4yNTsgeSArPSAxLjI1IClcXG5cdFx0XHRcdFx0Zm9yICggZmxvYXQgeCA9IC0xLjI1OyB4IDw9IDEuMjU7IHggKz0gMS4yNSApIHtcXG5cXG5cdFx0XHRcdFx0XHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXFxuXHRcdFx0XHRcdFx0XHRcdC8vIGRvZXNuJ3Qgc2VlbSB0byBwcm9kdWNlIGFueSBub3RpY2VhYmxlIHZpc3VhbCBkaWZmZXJlbmNlIGNvbXBhcmVkIHRvIHNpbXBsZSB0ZXh0dXJlMkQgbG9va3VwXFxuXHRcdFx0XHRcdFx0XHRcdC8vdmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkRQcm9qKCBzaGFkb3dNYXBbIGkgXSwgdmVjNCggdlNoYWRvd0Nvb3JkWyBpIF0udyAqICggdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKSwgMC4wNSwgdlNoYWRvd0Nvb3JkWyBpIF0udyApICk7XFxuXFxuXHRcdFx0XHRcdFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblxcblx0XHRcdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0XHRcdFx0XHRzaGFkb3cgKz0gMS4wO1xcblxcblx0XHRcdFx0fVxcblxcblx0XHRcdFx0c2hhZG93IC89IDkuMDtcXG5cXG5cdFx0Ki9cXG5cXG5cdFx0XHRcdGNvbnN0IGZsb2F0IHNoYWRvd0RlbHRhID0gMS4wIC8gOS4wO1xcblxcblx0XHRcdFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuXHRcdFx0XHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cdFx0XHRcdGZsb2F0IGR4MCA9IC0xLjI1ICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkwID0gLTEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeDEgPSAxLjI1ICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkxID0gMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0c2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XFxuXFxuXHRcdFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcblx0XHRcdFx0XHRcdC8vIFBlcmNlbnRhZ2UtY2xvc2UgZmlsdGVyaW5nXFxuXHRcdFx0XHRcdFx0Ly8gKDkgcGl4ZWwga2VybmVsKVxcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cXG5cXG5cdFx0XHRcdGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG5cdFx0XHRcdGZsb2F0IHhQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS54O1xcblx0XHRcdFx0ZmxvYXQgeVBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XFxuXFxuXHRcdFx0XHRmbG9hdCBkeDAgPSAtMS4wICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkwID0gLTEuMCAqIHlQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR4MSA9IDEuMCAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MSA9IDEuMCAqIHlQaXhlbE9mZnNldDtcXG5cXG5cdFx0XHRcdG1hdDMgc2hhZG93S2VybmVsO1xcblx0XHRcdFx0bWF0MyBkZXB0aEtlcm5lbDtcXG5cXG5cdFx0XHRcdGRlcHRoS2VybmVsWzBdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFswXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMF1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzFdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsxXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsxXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMl1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzJdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsyXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcblxcblx0XHRcdFx0dmVjMyBzaGFkb3daID0gdmVjMyggc2hhZG93Q29vcmQueiApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzBdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFswXSwgc2hhZG93WiApKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFswXSAqPSB2ZWMzKDAuMjUpO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWzFdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFsxXSwgc2hhZG93WiApKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsxXSAqPSB2ZWMzKDAuMjUpO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWzJdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFsyXSwgc2hhZG93WiApKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsyXSAqPSB2ZWMzKDAuMjUpO1xcblxcblx0XHRcdFx0dmVjMiBmcmFjdGlvbmFsQ29vcmQgPSAxLjAgLSBmcmFjdCggc2hhZG93Q29vcmQueHkgKiBzaGFkb3dNYXBTaXplW2ldLnh5ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMF0gPSBtaXgoIHNoYWRvd0tlcm5lbFsxXSwgc2hhZG93S2VybmVsWzBdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzFdID0gbWl4KCBzaGFkb3dLZXJuZWxbMl0sIHNoYWRvd0tlcm5lbFsxXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cXG5cdFx0XHRcdHZlYzQgc2hhZG93VmFsdWVzO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLnggPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsxXSwgc2hhZG93S2VybmVsWzBdWzBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsyXSwgc2hhZG93S2VybmVsWzBdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLnogPSBtaXgoIHNoYWRvd0tlcm5lbFsxXVsxXSwgc2hhZG93S2VybmVsWzFdWzBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLncgPSBtaXgoIHNoYWRvd0tlcm5lbFsxXVsyXSwgc2hhZG93S2VybmVsWzFdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblxcblx0XHRcdFx0c2hhZG93ID0gZG90KCBzaGFkb3dWYWx1ZXMsIHZlYzQoIDEuMCApICk7XFxuXFxuXHRcdFx0XHRzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcXG5cXG5cdFx0XHQjZWxzZVxcblxcblx0XHRcdFx0dmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApO1xcblx0XHRcdFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblxcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cXG5cdFx0Ly8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaXMgZGFya2VyXFxuXFxuXHRcdFx0XHRcdHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICk7XFxuXFxuXHRcdC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGhhcyB0aGUgc2FtZSBjb2xvciBhcyBzaW5nbGUgc2hhZG93IHNwb3RcXG5cXG5cdFx0Ly8gXHRcdFx0XHRcdHNoYWRvd0NvbG9yID0gbWluKCBzaGFkb3dDb2xvciwgdmVjMyggc2hhZG93RGFya25lc3NbIGkgXSApICk7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdH1cXG5cXG5cXG5cdFx0I2lmZGVmIFNIQURPV01BUF9ERUJVR1xcblxcblx0XHRcdGlmICggaW5GcnVzdHVtICkgb3V0Z29pbmdMaWdodCAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcblx0b3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiBzaGFkb3dDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93TWFwWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG5cdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuXHRcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0ZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1xcblx0XHRyZXR1cm4gZGVwdGg7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cdHVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE1BWF9TSEFET1dTIF07XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblx0XHR2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2luYmFzZV92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblx0bWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxuXHRtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcXG5cdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ19wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcblxcblx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XFxuXFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cdFx0XHRmbG9hdCBqID0gaSAqIDQuMDtcXG5cdFx0XHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXHRcdFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblxcblx0XHRcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKTtcXG5cdFx0XHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1xcblxcblx0XHRcdHkgPSBkeSAqICggeSArIDAuNSApO1xcblxcblx0XHRcdHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cXG5cdFx0XHRtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcblx0XHRcdHJldHVybiBib25lO1xcblxcblx0XHR9XFxuXFxuXHQjZWxzZVxcblxcblx0XHR1bmlmb3JtIG1hdDQgYm9uZUdsb2JhbE1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXG5cdFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcblx0XHRcdG1hdDQgYm9uZSA9IGJvbmVHbG9iYWxNYXRyaWNlc1sgaW50KGkpIF07XFxuXHRcdFx0cmV0dXJuIGJvbmU7XFxuXFxuXHRcdH1cXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXG5cdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5ub3JtYWxfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuXHRza2luTWF0cml4ICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XFxuXFxuXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50JyBdID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcblxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG5cdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcblx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG5cXG4jZWxzZVxcblxcblx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcblx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml92ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcblx0dlV2MiA9IHV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl92ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG5cdHZVdiA9IHV2ICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay93b3JsZHBvc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3dvcmxkcG9zX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXFxuXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zVXRpbHMuanNcblxuLyoqXG4gKiBVbmlmb3JtIFV0aWxpdGllc1xuICovXG5cblRIUkVFLlVuaWZvcm1zVXRpbHMgPSB7XG5cbiAgICBtZXJnZTogZnVuY3Rpb24oIHVuaWZvcm1zICkge1xuXG4gICAgICAgIHZhciBtZXJnZWQgPSB7fTtcblxuICAgICAgICBmb3IgKCB2YXIgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUrKyApIHtcblxuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIHAgaW4gdG1wICkge1xuXG4gICAgICAgICAgICAgICAgbWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiggdW5pZm9ybXNfc3JjICkge1xuXG4gICAgICAgIHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcblxuICAgICAgICBmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdID0ge307XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDMgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuaWZvcm1zX2RzdDtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNMaWIuanNcblxuLyoqXG4gKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuICovXG5cblRIUkVFLlVuaWZvcm1zTGliID0ge1xuXG4gICAgY29tbW9uOiB7XG5cbiAgICAgICAgXCJkaWZmdXNlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKVxuICAgICAgICB9LFxuICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcIm9mZnNldFJlcGVhdFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInY0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKVxuICAgICAgICB9LFxuXG4gICAgICAgIFwic3BlY3VsYXJNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcImFscGhhTWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBcImVudk1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmxpcEVudk1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAtMVxuICAgICAgICB9LFxuICAgICAgICBcInJlZmxlY3Rpdml0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZWZyYWN0aW9uUmF0aW9cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMC45OFxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYW9tYXA6IHtcblxuICAgICAgICBcImFvTWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJhb01hcEludGVuc2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0sXG5cbiAgICB9LFxuXG4gICAgbGlnaHRtYXA6IHtcblxuICAgICAgICBcImxpZ2h0TWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaWdodE1hcEludGVuc2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0sXG5cbiAgICB9LFxuXG4gICAgZW1pc3NpdmVtYXA6IHtcblxuICAgICAgICBcImVtaXNzaXZlTWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcblxuICAgIH0sXG5cbiAgICBidW1wbWFwOiB7XG5cbiAgICAgICAgXCJidW1wTWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJidW1wU2NhbGVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsbWFwOiB7XG5cbiAgICAgICAgXCJub3JtYWxNYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcIm5vcm1hbFNjYWxlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidjJcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkaXNwbGFjZW1lbnRtYXA6IHtcblxuICAgICAgICBcImRpc3BsYWNlbWVudE1hcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlzcGxhY2VtZW50U2NhbGVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICB9LFxuICAgICAgICBcImRpc3BsYWNlbWVudEJpYXNcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZm9nOiB7XG5cbiAgICAgICAgXCJmb2dEZW5zaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDAuMDAwMjVcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dOZWFyXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dGYXJcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMjAwMFxuICAgICAgICB9LFxuICAgICAgICBcImZvZ0NvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbGlnaHRzOiB7XG5cbiAgICAgICAgXCJhbWJpZW50TGlnaHRDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcblxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodENvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuXG4gICAgICAgIFwiaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcImhlbWlzcGhlcmVMaWdodFNreUNvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcImhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuXG4gICAgICAgIFwicG9pbnRMaWdodENvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50TGlnaHRQb3NpdGlvblwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2ludExpZ2h0RGlzdGFuY2VcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50TGlnaHREZWNheVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJzcG90TGlnaHRDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHRQb3NpdGlvblwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHREaXJlY3Rpb25cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdlwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0RGlzdGFuY2VcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodEFuZ2xlQ29zXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnYxXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHRFeHBvbmVudFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0RGVjYXlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcG9pbnRzOiB7XG5cbiAgICAgICAgXCJwc0NvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKVxuICAgICAgICB9LFxuICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIFwic2l6ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJzY2FsZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcIm9mZnNldFJlcGVhdFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInY0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKVxuICAgICAgICB9LFxuXG4gICAgICAgIFwiZm9nRGVuc2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLjAwMDI1XG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9nTmVhclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9nRmFyXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDIwMDBcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dDb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmIClcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHNoYWRvd21hcDoge1xuXG4gICAgICAgIFwic2hhZG93TWFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidHZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuICAgICAgICBcInNoYWRvd01hcFNpemVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJ2MnZcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuXG4gICAgICAgIFwic2hhZG93Qmlhc1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ2MVwiLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhZG93RGFya25lc3NcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmdjFcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9LFxuXG4gICAgICAgIFwic2hhZG93TWF0cml4XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibTR2XCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIuanNcblxuLyoqXG4gKiBXZWJnbCBTaGFkZXIgTGlicmFyeSBmb3IgdGhyZWUuanNcbiAqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxuXG5USFJFRS5TaGFkZXJMaWIgPSB7XG5cbiAgICAnYmFzaWMnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXG5cbiAgICAgICAgXSApLFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHQjaWZkZWYgVVNFX0VOVk1BUFwiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG4gICAgICAgICAgICBcIlx0dmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IHZlYzMoIDEuMCApO1wiLCAvLyBoYXJkd2lyZWRcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYiAqIHRvdGFsQW1iaWVudExpZ2h0O1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLCAvLyBUT0RPOiBTaGFkb3dzIG9uIGFuIG90aGVyd2lzZSB1bmxpdCBzdXJmYWNlIGRvZXNuJ3QgbWFrZSBzZW5zZS5cblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAnbGFtYmVydCc6IHtcblxuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJlbWlzc2l2ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIF0gKSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCIjZGVmaW5lIExBTUJFUlRcIixcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXG5cbiAgICAgICAgICAgIFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxuXG4gICAgICAgICAgICBcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXG5cbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXG5cbiAgICAgICAgICAgIFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxuXG4gICAgICAgICAgICBcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXG5cbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLCAvLyBvdXRnb2luZyBsaWdodCBkb2VzIG5vdCBoYXZlIGFuIGFscGhhLCB0aGUgc3VyZmFjZSBkb2VzXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0I2lmZGVmIERPVUJMRV9TSURFRFwiLFxuXG4gICAgICAgICAgICBcIlx0XHRpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcbiAgICAgICAgICAgIFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0RnJvbnQgKyBlbWlzc2l2ZTtcIixcbiAgICAgICAgICAgIFwiXHRcdGVsc2VcIixcbiAgICAgICAgICAgIFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0QmFjayArIGVtaXNzaXZlO1wiLFxuXG4gICAgICAgICAgICBcIlx0I2Vsc2VcIixcblxuICAgICAgICAgICAgXCJcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0RnJvbnQgKyBlbWlzc2l2ZTtcIixcblxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAncGhvbmcnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0bWFwXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImVtaXNzaXZlbWFwXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBtYXBcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibm9ybWFsbWFwXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImRpc3BsYWNlbWVudG1hcFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImVtaXNzaXZlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwIClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3BlY3VsYXJcIjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzaGluaW5lc3NcIjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDMwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIF0gKSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCIjZGVmaW5lIFBIT05HXCIsXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxuXG4gICAgICAgICAgICBcIlx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcblxuICAgICAgICAgICAgXCJcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XCIsXG5cbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwiI2RlZmluZSBQSE9OR1wiLFxuXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSBhbWJpZW50TGlnaHRDb2xvcjtcIixcbiAgICAgICAgICAgIFwiXHR2ZWMzIHRvdGFsRW1pc3NpdmVMaWdodCA9IGVtaXNzaXZlO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgJ3BvaW50cyc6IHtcblxuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwb2ludHNcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXVxuXG4gICAgICAgIF0gKSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNpemU7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuICAgICAgICAgICAgXCJcdCNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXCIsXG4gICAgICAgICAgICBcIlx0XHRnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIGxlbmd0aCggbXZQb3NpdGlvbi54eXogKSApO1wiLFxuICAgICAgICAgICAgXCJcdCNlbHNlXCIsXG4gICAgICAgICAgICBcIlx0XHRnbF9Qb2ludFNpemUgPSBzaXplO1wiLFxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxuXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBwc0NvbG9yO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxuICAgICAgICAgICAgXCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggcHNDb2xvciwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgICdkYXNoZWQnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInNjYWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRhc2hTaXplXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRvdGFsU2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICBdICksXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcbiAgICAgICAgICAgIFwiYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcIixcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIlx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1wiLFxuXG4gICAgICAgICAgICBcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuICAgICAgICAgICAgXCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1wiLFxuXG4gICAgICAgICAgICBcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHRcdGRpc2NhcmQ7XCIsXG5cbiAgICAgICAgICAgIFwiXHR9XCIsXG5cbiAgICAgICAgICAgIFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XCIsIC8vIHNpbXBsZSBzaGFkZXJcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAnZGVwdGgnOiB7XG5cbiAgICAgICAgdW5pZm9ybXM6IHtcblxuICAgICAgICAgICAgXCJtTmVhclwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibUZhclwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDIwMDAuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcblxuICAgICAgICAgICAgXCJcdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcIixcblxuICAgICAgICAgICAgXCJcdCNlbHNlXCIsXG5cbiAgICAgICAgICAgIFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcblxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxuXG4gICAgICAgICAgICBcIlx0ZmxvYXQgY29sb3IgPSAxLjAgLSBzbW9vdGhzdGVwKCBtTmVhciwgbUZhciwgZGVwdGggKTtcIixcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBjb2xvciApLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAnbm9ybWFsJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiB7XG5cbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgIH0sXG5cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcblx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICdjdWJlJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICBcInRDdWJlXCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidEZsaXBcIjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAtMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XCIsXG5cbiAgICAgICAgICAgIFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgfSxcblxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgJ2VxdWlyZWN0Jzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICBcInRFcXVpcmVjdFwiOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRGbGlwXCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxuXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1wiLFxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxuXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgLy8gXCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG4gICAgICAgICAgICBcInZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1wiLFxuICAgICAgICAgICAgXCJ2ZWMyIHNhbXBsZVVWO1wiLFxuICAgICAgICAgICAgXCJzYW1wbGVVVi55ID0gc2F0dXJhdGUoIHRGbGlwICogZGlyZWN0aW9uLnkgKiAtMC41ICsgMC41ICk7XCIsXG4gICAgICAgICAgICBcInNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1wiLFxuICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcIixcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9LFxuXG4gICAgLyogRGVwdGggZW5jb2RpbmcgaW50byBSR0JBIHRleHR1cmVcbiAgICAgKlxuICAgICAqIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgZXhhbXBsZVxuICAgICAqIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxuICAgICAqXG4gICAgICogb3JpZ2luYWxseSBmcm9tXG4gICAgICogaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy80NDIxMzgtcGFja2luZy1hLWZsb2F0LWludG8tYS1hOHI4ZzhiOC10ZXh0dXJlLXNoYWRlci9wYWdlX193aGljaHBhZ2VfXzElMjVFRiUyNUJGJTI1QkRcbiAgICAgKlxuICAgICAqIHNlZSBhbHNvXG4gICAgICogaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXG4gICAgICovXG5cbiAgICAnZGVwdGhSR0JBJzoge1xuXG4gICAgICAgIHVuaWZvcm1zOiB7fSxcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgICAgICBcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXG5cbiAgICAgICAgICAgIFwiXHRjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxuICAgICAgICAgICAgXCJcdGNvbnN0IHZlYzQgYml0X21hc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcbiAgICAgICAgICAgIFwiXHR2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLCAvLyBcIlx0dmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcbiAgICAgICAgICAgIFwiXHRyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcbiAgICAgICAgICAgIFwiXHRyZXR1cm4gcmVzO1wiLFxuXG4gICAgICAgICAgICBcIn1cIixcblxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICAgICAgXCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXG5cbiAgICAgICAgICAgIFwiXHRcdGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnRGVwdGhFWFQgKTtcIixcblxuICAgICAgICAgICAgXCJcdCNlbHNlXCIsXG5cbiAgICAgICAgICAgIFwiXHRcdGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxuXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXG5cbiAgICAgICAgICAgIC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApO1wiLFxuICAgICAgICAgICAgLy9cImZsb2F0IHogPSAoICggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApIC0gMy4wICkgLyAoIDQwMDAuMCAtIDMuMCApO1wiLFxuICAgICAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXG4gICAgICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHZlYzQoIHosIHosIHosIDEuMCApO1wiLFxuXG4gICAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlcmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cblRIUkVFLldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiggcGFyYW1ldGVycyApIHtcblxuICAgIGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcicsIFRIUkVFLlJFVklTSU9OICk7XG5cbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgIHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcbiAgICAgICAgX2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cbiAgICAgICAgX3dpZHRoID0gX2NhbnZhcy53aWR0aCxcbiAgICAgICAgX2hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXG4gICAgICAgIHBpeGVsUmF0aW8gPSAxLFxuXG4gICAgICAgIF9hbHBoYSA9IHBhcmFtZXRlcnMuYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGEgOiBmYWxzZSxcbiAgICAgICAgX2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG4gICAgICAgIF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxuICAgICAgICBfYW50aWFsaWFzID0gcGFyYW1ldGVycy5hbnRpYWxpYXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYW50aWFsaWFzIDogZmFsc2UsXG4gICAgICAgIF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuICAgICAgICBfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXG5cbiAgICAgICAgX2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXG4gICAgICAgIF9jbGVhckFscGhhID0gMDtcblxuICAgIHZhciBsaWdodHMgPSBbXTtcblxuICAgIHZhciBvcGFxdWVPYmplY3RzID0gW107XG4gICAgdmFyIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtMTtcbiAgICB2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gW107XG4gICAgdmFyIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuXG4gICAgdmFyIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHMgPSBbXTtcbiAgICB2YXIgb3BhcXVlSW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuICAgIHZhciB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHMgPSBbXTtcbiAgICB2YXIgdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4ID0gLTE7XG5cbiAgICB2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xuXG5cbiAgICB2YXIgc3ByaXRlcyA9IFtdO1xuICAgIHZhciBsZW5zRmxhcmVzID0gW107XG5cbiAgICAvLyBwdWJsaWMgcHJvcGVydGllc1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gX2NhbnZhcztcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgLy8gY2xlYXJpbmdcblxuICAgIHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0cnVlO1xuXG4gICAgLy8gc2NlbmUgZ3JhcGhcblxuICAgIHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xuXG4gICAgLy8gcGh5c2ljYWxseSBiYXNlZCBzaGFkaW5nXG5cbiAgICB0aGlzLmdhbW1hRmFjdG9yID0gMi4wOyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcbiAgICB0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cbiAgICAvLyBtb3JwaHNcblxuICAgIHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcbiAgICB0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XG5cbiAgICAvLyBmbGFnc1xuXG4gICAgdGhpcy5hdXRvU2NhbGVDdWJlbWFwcyA9IHRydWU7XG5cbiAgICAvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuXG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cbiAgICAgICAgX2N1cnJlbnRQcm9ncmFtID0gbnVsbCxcbiAgICAgICAgX2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXG4gICAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xLFxuICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxuICAgICAgICBfY3VycmVudENhbWVyYSA9IG51bGwsXG5cbiAgICAgICAgX3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxuXG4gICAgICAgIF92aWV3cG9ydFggPSAwLFxuICAgICAgICBfdmlld3BvcnRZID0gMCxcbiAgICAgICAgX3ZpZXdwb3J0V2lkdGggPSBfY2FudmFzLndpZHRoLFxuICAgICAgICBfdmlld3BvcnRIZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcbiAgICAgICAgX2N1cnJlbnRXaWR0aCA9IDAsXG4gICAgICAgIF9jdXJyZW50SGVpZ2h0ID0gMCxcblxuICAgICAgICAvLyBmcnVzdHVtXG5cbiAgICAgICAgX2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxuXG4gICAgICAgIC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxuXG4gICAgICAgIF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuICAgICAgICBfdmVjdG9yMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgICAgLy8gbGlnaHQgYXJyYXlzIGNhY2hlXG5cbiAgICAgICAgX2RpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlLFxuXG4gICAgICAgIF9saWdodHMgPSB7XG5cbiAgICAgICAgICAgIGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uYWw6IHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlczogW10sXG4gICAgICAgICAgICAgICAgZGVjYXlzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwb3Q6IHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlczogW10sXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uczogW10sXG4gICAgICAgICAgICAgICAgYW5nbGVzQ29zOiBbXSxcbiAgICAgICAgICAgICAgICBleHBvbmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIGRlY2F5czogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZW1pOiB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgICAgIHNreUNvbG9yczogW10sXG4gICAgICAgICAgICAgICAgZ3JvdW5kQ29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IFtdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvXG5cbiAgICAgICAgX2luZm9NZW1vcnkgPSB7XG5cbiAgICAgICAgICAgIGdlb21ldHJpZXM6IDAsXG4gICAgICAgICAgICB0ZXh0dXJlczogMFxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luZm9SZW5kZXIgPSB7XG5cbiAgICAgICAgICAgIGNhbGxzOiAwLFxuICAgICAgICAgICAgdmVydGljZXM6IDAsXG4gICAgICAgICAgICBmYWNlczogMCxcbiAgICAgICAgICAgIHBvaW50czogMFxuXG4gICAgICAgIH07XG5cbiAgICB0aGlzLmluZm8gPSB7XG5cbiAgICAgICAgcmVuZGVyOiBfaW5mb1JlbmRlcixcbiAgICAgICAgbWVtb3J5OiBfaW5mb01lbW9yeSxcbiAgICAgICAgcHJvZ3JhbXM6IG51bGxcblxuICAgIH07XG5cblxuICAgIC8vIGluaXRpYWxpemVcblxuICAgIHZhciBfZ2w7XG5cbiAgICB0cnkge1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgYWxwaGE6IF9hbHBoYSxcbiAgICAgICAgICAgIGRlcHRoOiBfZGVwdGgsXG4gICAgICAgICAgICBzdGVuY2lsOiBfc3RlbmNpbCxcbiAgICAgICAgICAgIGFudGlhbGlhczogX2FudGlhbGlhcyxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgICAgICB9O1xuXG4gICAgICAgIF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcblxuICAgICAgICBpZiAoIF9nbCA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcblxuICAgIH1cbiAgICBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IgKTtcblxuICAgIH1cblxuICAgIHZhciBleHRlbnNpb25zID0gbmV3IFRIUkVFLldlYkdMRXh0ZW5zaW9ucyggX2dsICk7XG5cbiAgICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcbiAgICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuICAgIGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgIGlmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xuXG4gICAgICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNDI5NDk2NzI5NjtcblxuICAgIH1cblxuICAgIHZhciBjYXBhYmlsaXRpZXMgPSBuZXcgVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xuXG4gICAgdmFyIHN0YXRlID0gbmV3IFRIUkVFLldlYkdMU3RhdGUoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKTtcbiAgICB2YXIgcHJvcGVydGllcyA9IG5ldyBUSFJFRS5XZWJHTFByb3BlcnRpZXMoKTtcbiAgICB2YXIgb2JqZWN0cyA9IG5ldyBUSFJFRS5XZWJHTE9iamVjdHMoIF9nbCwgcHJvcGVydGllcywgdGhpcy5pbmZvICk7XG4gICAgdmFyIHByb2dyYW1DYWNoZSA9IG5ldyBUSFJFRS5XZWJHTFByb2dyYW1zKCB0aGlzLCBjYXBhYmlsaXRpZXMgKTtcblxuICAgIHRoaXMuaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcblxuICAgIHZhciBidWZmZXJSZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XG4gICAgdmFyIGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIGdsQ2xlYXJDb2xvciggciwgZywgYiwgYSApIHtcblxuICAgICAgICBpZiAoIF9wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIHIgKj0gYTtcbiAgICAgICAgICAgIGcgKj0gYTtcbiAgICAgICAgICAgIGIgKj0gYTtcblxuICAgICAgICB9XG5cbiAgICAgICAgX2dsLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldERlZmF1bHRHTFN0YXRlKCkge1xuXG4gICAgICAgIHN0YXRlLmluaXQoKTtcblxuICAgICAgICBfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcblxuICAgICAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldEdMU3RhdGUoKSB7XG5cbiAgICAgICAgX2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcbiAgICAgICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG4gICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG4gICAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xuXG4gICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICBzdGF0ZS5yZXNldCgpO1xuXG4gICAgfVxuXG4gICAgc2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuICAgIHRoaXMuY29udGV4dCA9IF9nbDtcbiAgICB0aGlzLmNhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcztcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIC8vIHNoYWRvdyBtYXBcblxuICAgIHZhciBzaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xTaGFkb3dNYXAoIHRoaXMsIGxpZ2h0cywgb2JqZWN0cyApO1xuXG4gICAgdGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XG5cblxuICAgIC8vIFBsdWdpbnNcblxuICAgIHZhciBzcHJpdGVQbHVnaW4gPSBuZXcgVEhSRUUuU3ByaXRlUGx1Z2luKCB0aGlzLCBzcHJpdGVzICk7XG4gICAgdmFyIGxlbnNGbGFyZVBsdWdpbiA9IG5ldyBUSFJFRS5MZW5zRmxhcmVQbHVnaW4oIHRoaXMsIGxlbnNGbGFyZXMgKTtcblxuICAgIC8vIEFQSVxuXG4gICAgdGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIF9nbDtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldENvbnRleHRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbG9zZV9jb250ZXh0JyApLmxvc2VDb250ZXh0KCk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gKCBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldE1heEFuaXNvdHJvcHkoKSB7XG5cbiAgICAgICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG4gICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgfVxuXG4gICAgfSApKCk7XG5cbiAgICB0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSBwaXhlbFJhdGlvID0gdmFsdWU7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUgKSB7XG5cbiAgICAgICAgX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIF9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgX2NhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXG4gICAgICAgIGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgICAgIF92aWV3cG9ydFggPSB4ICogcGl4ZWxSYXRpbztcbiAgICAgICAgX3ZpZXdwb3J0WSA9IHkgKiBwaXhlbFJhdGlvO1xuXG4gICAgICAgIF92aWV3cG9ydFdpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICBfdmlld3BvcnRIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXG4gICAgICAgIF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgICAgIF9nbC5zY2lzc29yKFxuICAgICAgICAgICAgeCAqIHBpeGVsUmF0aW8sXG4gICAgICAgICAgICB5ICogcGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIHdpZHRoICogcGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIGhlaWdodCAqIHBpeGVsUmF0aW9cbiAgICAgICAgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmVuYWJsZVNjaXNzb3JUZXN0ID0gZnVuY3Rpb24oIGJvb2xlYW4gKSB7XG5cbiAgICAgICAgc3RhdGUuc2V0U2Npc3NvclRlc3QoIGJvb2xlYW4gKTtcblxuICAgIH07XG5cbiAgICAvLyBDbGVhcmluZ1xuXG4gICAgdGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIF9jbGVhckNvbG9yO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uKCBjb2xvciwgYWxwaGEgKSB7XG5cbiAgICAgICAgX2NsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xuXG4gICAgICAgIF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcblxuICAgICAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIF9jbGVhckFscGhhO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uKCBhbHBoYSApIHtcblxuICAgICAgICBfY2xlYXJBbHBoYSA9IGFscGhhO1xuXG4gICAgICAgIGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24oIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuICAgICAgICB2YXIgYml0cyA9IDA7XG5cbiAgICAgICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcbiAgICAgICAgaWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcbiAgICAgICAgaWYgKCBzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCApIGJpdHMgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcblxuICAgICAgICBfZ2wuY2xlYXIoIGJpdHMgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBfZ2wuY2xlYXIoIF9nbC5DT0xPUl9CVUZGRVJfQklUICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgX2dsLmNsZWFyKCBfZ2wuREVQVEhfQlVGRkVSX0JJVCApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgX2dsLmNsZWFyKCBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUICk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uKCByZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG4gICAgICAgIHRoaXMuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xuXG4gICAgfTtcblxuICAgIC8vIFJlc2V0XG5cbiAgICB0aGlzLnJlc2V0R0xTdGF0ZSA9IHJlc2V0R0xTdGF0ZTtcblxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG4gICAgfTtcblxuICAgIC8vIEV2ZW50c1xuXG4gICAgZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICByZXNldEdMU3RhdGUoKTtcbiAgICAgICAgc2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmNsZWFyKCk7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgdGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuICAgICAgICBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXG4gICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzLS07XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICByZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcblxuICAgICAgICBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcy0tO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICBtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cbiAgICAgICAgZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIGRlYWxsb2NhdGlvblxuXG4gICAgZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XG5cbiAgICAgICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuICAgICAgICBpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuICAgICAgICAgICAgLy8gY3ViZSB0ZXh0dXJlXG5cbiAgICAgICAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gMkQgdGV4dHVyZVxuXG4gICAgICAgICAgICBpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYWxsIHdlYmdsIHByb3BlcnRpZXNcbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIHRleHR1cmUgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICBpZiAoICFyZW5kZXJUYXJnZXQgfHwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuICAgICAgICAgICAgICAgIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG4gICAgICAgICAgICBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIHJlbmRlclRhcmdldCApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuICAgICAgICByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xuXG4gICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCBtYXRlcmlhbCApO1xuXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApIHtcblxuICAgICAgICB2YXIgcHJvZ3JhbUluZm8gPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5wcm9ncmFtO1xuXG4gICAgICAgIG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtSW5mbyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW1JbmZvICk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIEJ1ZmZlciByZW5kZXJpbmdcblxuICAgIHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24oIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICB2YXIgYnVmZmVycyA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcblxuICAgICAgICBpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgIWJ1ZmZlcnMucG9zaXRpb24gKSBidWZmZXJzLnBvc2l0aW9uID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICFidWZmZXJzLm5vcm1hbCApIGJ1ZmZlcnMubm9ybWFsID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBpZiAoIG9iamVjdC5oYXNVdnMgJiYgIWJ1ZmZlcnMudXYgKSBidWZmZXJzLnV2ID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgIWJ1ZmZlcnMuY29sb3IgKSBidWZmZXJzLmNvbG9yID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgaWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICkge1xuXG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbiApO1xuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcblxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMubm9ybWFsICk7XG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyAmJiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdC5jb3VudCAqIDM7IGkgPCBsOyBpICs9IDkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBueCA9ICggYXJyYXlbIGkgKyAwIF0gKyBhcnJheVsgaSArIDMgXSArIGFycmF5WyBpICsgNiBdICkgLyAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyAwIF0gPSBueDtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyAxIF0gPSBueTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyAyIF0gPSBuejtcblxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDMgXSA9IG54O1xuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDQgXSA9IG55O1xuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDUgXSA9IG56O1xuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgNiBdID0gbng7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgNyBdID0gbnk7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgOCBdID0gbno7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XG5cbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9iamVjdC5oYXNVdnMgJiYgbWF0ZXJpYWwubWFwICkge1xuXG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy51diApO1xuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC51dkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuXG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIHtcblxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IgKTtcbiAgICAgICAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcblxuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XG5cbiAgICAgICAgb2JqZWN0LmNvdW50ID0gMDtcblxuICAgIH07XG5cbiAgICB0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKSB7XG5cbiAgICAgICAgc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgdmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArIG1hdGVyaWFsLndpcmVmcmFtZTtcblxuICAgICAgICBpZiAoIGdlb21ldHJ5UHJvZ3JhbSAhPT0gX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gKSB7XG5cbiAgICAgICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnlQcm9ncmFtO1xuICAgICAgICAgICAgdXBkYXRlQnVmZmVycyA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vcnBoIHRhcmdldHNcblxuICAgICAgICB2YXIgbW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgICAgICBpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgYWN0aXZlSW5mbHVlbmNlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xuICAgICAgICAgICAgICAgIGFjdGl2ZUluZmx1ZW5jZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFjdGl2ZUluZmx1ZW5jZXMuc29ydCggbnVtZXJpY2FsU29ydCApO1xuXG4gICAgICAgICAgICBpZiAoIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID4gOCApIHtcblxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID0gODtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmZsdWVuY2UgPSBhY3RpdmVJbmZsdWVuY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgbW9ycGhJbmZsdWVuY2VzWyBpIF0gPSBpbmZsdWVuY2VbIDAgXTtcblxuICAgICAgICAgICAgICAgIGlmICggaW5mbHVlbmNlWyAwIF0gIT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5mbHVlbmNlWyAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpbmRleCBdICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5ub3JtYWwgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsWyBpbmRleCBdICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblxuICAgICAgICAgICAgaWYgKCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmdiggdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLCBtb3JwaEluZmx1ZW5jZXMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cblxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgaW5kZXggPSBvYmplY3RzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyO1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0SW5kZXgoIGluZGV4ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmVuZGVyZXIgPSBidWZmZXJSZW5kZXJlcjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGluZGV4ICkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGdyb3VwID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBjb3VudDtcblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IGluZGV4LmNvdW50O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggcG9zaXRpb24gaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgICAgIGNvdW50ID0gcG9zaXRpb24uZGF0YS5hcnJheS5sZW5ndGggLyAzO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IHBvc2l0aW9uLmNvdW50O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG5cbiAgICAgICAgICAgIGdyb3VwID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkcmF3UmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgY291bnQ6IE1hdGgubWluKCBkcmF3UmFuZ2UuY291bnQsIGNvdW50IClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIHBpeGVsUmF0aW8gKTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblxuICAgICAgICAgICAgaWYgKCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCApIGxpbmVXaWR0aCA9IDE7IC8vIE5vdCB1c2luZyBMaW5lKk1hdGVyaWFsXG5cbiAgICAgICAgICAgIHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogcGl4ZWxSYXRpbyApO1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyApIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuUE9JTlRTICk7XG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcblxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xuXG4gICAgICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgdmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XG5cbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgICAgICAgaWYgKCBwcm9ncmFtQXR0cmlidXRlID49IDAgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGdlb21ldHJ5QXR0cmlidXRlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGdlb21ldHJ5QXR0cmlidXRlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaWRlID0gZGF0YS5zdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBwcm9ncmFtQXR0cmlidXRlLCBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIEZsb2F0MzJcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggcHJvZ3JhbUF0dHJpYnV0ZSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliNGZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgIH1cblxuICAgIC8vIFNvcnRpbmdcblxuICAgIGZ1bmN0aW9uIG51bWVyaWNhbFNvcnQoIGEsIGIgKSB7XG5cbiAgICAgICAgcmV0dXJuIGJbIDAgXSAtIGFbIDAgXTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG4gICAgICAgIGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG4gICAgICAgICAgICByZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gYS5tYXRlcmlhbC5pZCAtIGIubWF0ZXJpYWwuaWQ7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuICAgICAgICBpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgICAgICAgICByZXR1cm4gYi56IC0gYS56O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBSZW5kZXJpbmdcblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuICAgICAgICBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG4gICAgICAgIC8vIHJlc2V0IGNhY2hpbmcgZm9yIHRoaXMgZnJhbWVcblxuICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuICAgICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcbiAgICAgICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuICAgICAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cbiAgICAgICAgaWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgICAvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cbiAgICAgICAgaWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgICAgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgICAgICBfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgICAgICBfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgICAgIGxpZ2h0cy5sZW5ndGggPSAwO1xuXG4gICAgICAgIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtMTtcbiAgICAgICAgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLTE7XG5cbiAgICAgICAgb3BhcXVlSW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuICAgICAgICB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXggPSAtMTtcblxuICAgICAgICBzcHJpdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGxlbnNGbGFyZXMubGVuZ3RoID0gMDtcblxuICAgICAgICBwcm9qZWN0T2JqZWN0KCBzY2VuZSApO1xuXG4gICAgICAgIG9wYXF1ZU9iamVjdHMubGVuZ3RoID0gb3BhcXVlT2JqZWN0c0xhc3RJbmRleCArIDE7XG4gICAgICAgIHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPSB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggKyAxO1xuXG4gICAgICAgIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHMubGVuZ3RoID0gb3BhcXVlSW1tZWRpYXRlT2JqZWN0c0xhc3RJbmRleCArIDE7XG4gICAgICAgIHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0cy5sZW5ndGggPSB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHNMYXN0SW5kZXggKyAxO1xuXG4gICAgICAgIGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcbiAgICAgICAgICAgIHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cblxuICAgICAgICBzaGFkb3dNYXAucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBfaW5mb1JlbmRlci5jYWxscyA9IDA7XG4gICAgICAgIF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcbiAgICAgICAgX2luZm9SZW5kZXIuZmFjZXMgPSAwO1xuICAgICAgICBfaW5mb1JlbmRlci5wb2ludHMgPSAwO1xuXG4gICAgICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICBpZiAoIHRoaXMuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL1xuXG4gICAgICAgIGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgdmFyIG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgICAgICAgICByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG4gICAgICAgICAgICByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggb3BhcXVlSW1tZWRpYXRlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuICAgICAgICAgICAgcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gb3BhcXVlIHBhc3MgKGZyb250LXRvLWJhY2sgb3JkZXIpXG5cbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XG5cbiAgICAgICAgICAgIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2cgKTtcbiAgICAgICAgICAgIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2cgKTtcblxuICAgICAgICAgICAgLy8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuICAgICAgICAgICAgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG4gICAgICAgICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2cgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VzdG9tIHJlbmRlciBwbHVnaW5zIChwb3N0IHBhc3MpXG5cbiAgICAgICAgc3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuICAgICAgICBsZW5zRmxhcmVQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFdpZHRoLCBfY3VycmVudEhlaWdodCApO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHJlbmRlclRhcmdldC5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcblxuICAgICAgICAgICAgdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIGRlcHRoIGJ1ZmZlciB3cml0aW5nIGlzIGVuYWJsZWQgc28gaXQgY2FuIGJlIGNsZWFyZWQgb24gbmV4dCByZW5kZXJcblxuICAgICAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcbiAgICAgICAgc3RhdGUuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xuICAgICAgICBzdGF0ZS5zZXRDb2xvcldyaXRlKCB0cnVlICk7XG5cbiAgICAgICAgLy8gX2dsLmZpbmlzaCgpO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHB1c2hJbW1lZGlhdGVSZW5kZXJJdGVtKCBvYmplY3QgKSB7XG5cbiAgICAgICAgdmFyIGFycmF5LCBpbmRleDtcblxuICAgICAgICAvLyBhbGxvY2F0ZSB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXlcblxuICAgICAgICBpZiAoIG9iamVjdC5tYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuICAgICAgICAgICAgYXJyYXkgPSB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHM7XG4gICAgICAgICAgICBpbmRleCA9ICsrdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGFycmF5ID0gb3BhcXVlSW1tZWRpYXRlT2JqZWN0cztcbiAgICAgICAgICAgIGluZGV4ID0gKytvcGFxdWVJbW1lZGlhdGVPYmplY3RzTGFzdEluZGV4O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN5Y2xlIGV4aXN0aW5nIHBvc2l0aW9uIG9yIGdyb3cgdGhlIGFycmF5XG5cbiAgICAgICAgaWYgKCBpbmRleCA8IGFycmF5Lmxlbmd0aCApIHtcblxuICAgICAgICAgICAgYXJyYXlbIGluZGV4IF0gPSBvYmplY3Q7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gYXNzZXJ0KCBpbmRleCA9PT0gYXJyYXkubGVuZ3RoICk7XG4gICAgICAgICAgICBhcnJheS5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgeiwgZ3JvdXAgKSB7XG5cbiAgICAgICAgdmFyIGFycmF5LCBpbmRleDtcblxuICAgICAgICAvLyBhbGxvY2F0ZSB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXlcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xuXG4gICAgICAgICAgICBhcnJheSA9IHRyYW5zcGFyZW50T2JqZWN0cztcbiAgICAgICAgICAgIGluZGV4ID0gKyt0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXg7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgYXJyYXkgPSBvcGFxdWVPYmplY3RzO1xuICAgICAgICAgICAgaW5kZXggPSArK29wYXF1ZU9iamVjdHNMYXN0SW5kZXg7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3ljbGUgZXhpc3RpbmcgcmVuZGVyIGl0ZW0gb3IgZ3JvdyB0aGUgYXJyYXlcblxuICAgICAgICB2YXIgcmVuZGVySXRlbSA9IGFycmF5WyBpbmRleCBdO1xuXG4gICAgICAgIGlmICggcmVuZGVySXRlbSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICByZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xuICAgICAgICAgICAgcmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgICByZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICByZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgICAgICByZW5kZXJJdGVtLnogPSBfdmVjdG9yMy56O1xuICAgICAgICAgICAgcmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJlbmRlckl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG9iamVjdC5pZCxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsLFxuICAgICAgICAgICAgICAgIHo6IF92ZWN0b3IzLnosXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBhc3NlcnQoIGluZGV4ID09PSBhcnJheS5sZW5ndGggKTtcbiAgICAgICAgICAgIGFycmF5LnB1c2goIHJlbmRlckl0ZW0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QgKSB7XG5cbiAgICAgICAgaWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcblxuICAgICAgICAgICAgbGlnaHRzLnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSApIHtcblxuICAgICAgICAgICAgc3ByaXRlcy5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmUgKSB7XG5cbiAgICAgICAgICAgIGxlbnNGbGFyZXMucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ICkge1xuXG4gICAgICAgICAgICBwdXNoSW1tZWRpYXRlUmVuZGVySXRlbSggb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuICAgICAgICAgICAgICAgIG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBfdmVjdG9yMy56LCBncm91cCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgcmVuZGVySXRlbSA9IHJlbmRlckxpc3RbIGkgXTtcblxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcblxuICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XG5cbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBsaWdodHMsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggcmVuZGVyTGlzdCwgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXG4gICAgICAgICAgICBvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgb2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblxuICAgICAgICAgICAgaWYgKCBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgICAgICAgc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuXG4gICAgICAgICAgICBvYmplY3QucmVuZGVyKCBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xuXG4gICAgICAgIHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xuICAgICAgICB2YXIgY29kZSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ29kZSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xuICAgICAgICB2YXIgcHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIC8vIG5ldyBtYXRlcmlhbFxuICAgICAgICAgICAgbWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHByb2dyYW0uY29kZSAhPT0gY29kZSApIHtcblxuICAgICAgICAgICAgLy8gY2hhbmdlZCBnbHNsIG9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAvLyBzYW1lIGdsc2wgYW5kIHVuaWZvcm0gbGlzdFxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgcmVidWlsZCB1bmlmb3JtIGxpc3RcbiAgICAgICAgICAgIHByb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtQ2hhbmdlICkge1xuXG4gICAgICAgICAgICBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBwYXJhbWV0ZXJzLnNoYWRlcklEIF07XG5cbiAgICAgICAgICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbWF0ZXJpYWwudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRlcmlhbC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtczogbWF0ZXJpYWwudW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlcjtcblxuICAgICAgICAgICAgcHJvZ3JhbSA9IHByb2dyYW1DYWNoZS5hY3F1aXJlUHJvZ3JhbSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMsIGNvZGUgKTtcblxuICAgICAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICAgICAgbWF0ZXJpYWwucHJvZ3JhbSA9IHByb2dyYW07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XG5cbiAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgaSBdID49IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzKys7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XG5cbiAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhOb3JtYWxzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMrKztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gW107XG5cbiAgICAgICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbS5nZXRVbmlmb3JtcygpO1xuXG4gICAgICAgIGZvciAoIHZhciB1IGluIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zICkge1xuXG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3JtTG9jYXRpb25zWyB1IF07XG5cbiAgICAgICAgICAgIGlmICggbG9jYXRpb24gKSB7XG5cbiAgICAgICAgICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LnB1c2goIFsgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbIHUgXSwgbG9jYXRpb24gXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnNldERlcHRoRnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG4gICAgICAgIHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG4gICAgICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcbiAgICAgICAgc3RhdGUuc2V0Q29sb3JXcml0ZSggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xuICAgICAgICBzdGF0ZS5zZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICkge1xuXG4gICAgICAgIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgPyBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKSA6IHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcbiAgICAgICAgc3RhdGUuc2V0RmxpcFNpZGVkKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuICAgICAgICBfdXNlZFRleHR1cmVVbml0cyA9IDA7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgfHwgIW1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtICkge1xuXG4gICAgICAgICAgICBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICk7XG4gICAgICAgICAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0sXG4gICAgICAgICAgICBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuICAgICAgICAgICAgbV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xuXG4gICAgICAgIGlmICggcHJvZ3JhbS5pZCAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xuXG4gICAgICAgICAgICBfZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICk7XG4gICAgICAgICAgICBfY3VycmVudFByb2dyYW0gPSBwcm9ncmFtLmlkO1xuXG4gICAgICAgICAgICByZWZyZXNoUHJvZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICByZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuICAgICAgICAgICAgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcblxuICAgICAgICAgICAgaWYgKCBfY3VycmVudE1hdGVyaWFsSWQgPT09IC0xICkgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG4gICAgICAgICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcblxuICAgICAgICAgICAgcmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZWZyZXNoUHJvZ3JhbSB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xuXG4gICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWYoIHBfdW5pZm9ybXMubG9nRGVwdGhCdWZGQywgMi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkgX2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XG5cbiAgICAgICAgICAgIC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcbiAgICAgICAgICAgIC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5za2lubmluZyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy52aWV3TWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgLy8gYXV0by1zZXR0aW5nIG9mIHRleHR1cmUgdW5pdCBmb3IgYm9uZSB0ZXh0dXJlIG11c3QgZ28gYmVmb3JlIG90aGVyIHRleHR1cmVzXG4gICAgICAgIC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXgsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0LmJpbmRNYXRyaXhJbnZlcnNlICYmIHBfdW5pZm9ybXMuYmluZE1hdHJpeEludmVyc2UgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlLCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXhJbnZlcnNlLmVsZW1lbnRzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUsIHRleHR1cmVVbml0ICk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZUhlaWdodCwgb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlSGVpZ2h0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLmJvbmVNYXRyaWNlcyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZWZyZXNoTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXG5cbiAgICAgICAgICAgIGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0ZvZyggbV91bmlmb3JtcywgZm9nICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwubGlnaHRzICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBfbGlnaHRzTmVlZFVwZGF0ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBMaWdodHMoIGxpZ2h0cywgY2FtZXJhICk7XG4gICAgICAgICAgICAgICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJlZnJlc2hMaWdodHMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGlnaHRzKCBtX3VuaWZvcm1zLCBfbGlnaHRzICk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIGZhbHNlICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0Rhc2goIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50c01hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgbV91bmlmb3Jtcy5tTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xuICAgICAgICAgICAgICAgIG1fdW5pZm9ybXMubUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XG4gICAgICAgICAgICAgICAgbV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICAgICAgbV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmICFtYXRlcmlhbC5fc2hhZG93UGFzcyApIHtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc1NoYWRvdyggbV91bmlmb3JtcywgbGlnaHRzICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9hZCBjb21tb24gdW5pZm9ybXNcblxuICAgICAgICAgICAgbG9hZFVuaWZvcm1zR2VuZXJpYyggbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBsb2FkVW5pZm9ybXNNYXRyaWNlcyggcF91bmlmb3Jtcywgb2JqZWN0ICk7XG5cbiAgICAgICAgaWYgKCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkLmVsZW1lbnRzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuXG4gICAgfVxuXG4gICAgLy8gVW5pZm9ybXMgKHJlZnJlc2ggdW5pZm9ybXMgb2JqZWN0cylcblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgICAgIHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlO1xuXG4gICAgICAgIH1cblxuICAgICAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG4gICAgICAgIHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5hb01hcCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcbiAgICAgICAgICAgIHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuICAgICAgICAvLyAxLiBjb2xvciBtYXBcbiAgICAgICAgLy8gMi4gc3BlY3VsYXIgbWFwXG4gICAgICAgIC8vIDMuIG5vcm1hbCBtYXBcbiAgICAgICAgLy8gNC4gYnVtcCBtYXBcbiAgICAgICAgLy8gNS4gYWxwaGEgbWFwXG4gICAgICAgIC8vIDYuIGVtaXNzaXZlIG1hcFxuXG4gICAgICAgIHZhciB1dlNjYWxlTWFwO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwubWFwICkge1xuXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xuXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcblxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcbiAgICAgICAgdW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggbWF0ZXJpYWwuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkgPyAxIDogLTE7XG5cbiAgICAgICAgdW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuICAgICAgICB1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuICAgICAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2goIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgICAgICB1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuICAgICAgICB1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XG4gICAgICAgIHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHVuaWZvcm1zLnBzQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcbiAgICAgICAgdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG4gICAgICAgIHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplO1xuICAgICAgICB1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxuXG4gICAgICAgIHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG1hdGVyaWFsLm1hcC5vZmZzZXQ7XG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcblxuICAgICAgICAgICAgdW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2coIHVuaWZvcm1zLCBmb2cgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XG5cbiAgICAgICAgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcbiAgICAgICAgICAgIHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhcjtcbiAgICAgICAgdW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gbWF0ZXJpYWwuc2hpbmluZXNzO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG4gICAgICAgICAgICB1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG4gICAgICAgICAgICB1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuICAgICAgICAgICAgdW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuICAgICAgICAgICAgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcbiAgICAgICAgICAgIHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaWdodHMoIHVuaWZvcm1zLCBsaWdodHMgKSB7XG5cbiAgICAgICAgdW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuYW1iaWVudDtcblxuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzO1xuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucztcblxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0UG9zaXRpb24udmFsdWUgPSBsaWdodHMucG9pbnQucG9zaXRpb25zO1xuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMucG9pbnQuZGlzdGFuY2VzO1xuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMucG9pbnQuZGVjYXlzO1xuXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnNwb3QuY29sb3JzO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LnBvc2l0aW9ucztcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMuc3BvdC5kaXN0YW5jZXM7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpcmVjdGlvbnM7XG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodEFuZ2xlQ29zLnZhbHVlID0gbGlnaHRzLnNwb3QuYW5nbGVzQ29zO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC52YWx1ZSA9IGxpZ2h0cy5zcG90LmV4cG9uZW50cztcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMuc3BvdC5kZWNheXM7XG5cbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5za3lDb2xvcnM7XG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzO1xuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuaGVtaS5wb3NpdGlvbnM7XG5cbiAgICB9XG5cbiAgICAvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cbiAgICBmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggdW5pZm9ybXMsIHZhbHVlICkge1xuXG4gICAgICAgIHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGVjYXkubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1NoYWRvdyggdW5pZm9ybXMsIGxpZ2h0cyApIHtcblxuICAgICAgICBpZiAoIHVuaWZvcm1zLnNoYWRvd01hdHJpeCApIHtcblxuICAgICAgICAgICAgdmFyIGogPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggIWxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgfHwgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXAudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hcDtcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwU2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXRyaXgudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcblxuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93RGFya25lc3M7XG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd0JpYXMudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd0JpYXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaisrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gVW5pZm9ybXMgKGxvYWQgdG8gR1BVKVxuXG4gICAgZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMoIHVuaWZvcm1zLCBvYmplY3QgKSB7XG5cbiAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIG9iamVjdC5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgICBpZiAoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCApIHtcblxuICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5ub3JtYWxNYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcblxuICAgICAgICB2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcblxuICAgICAgICBpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmVVbml0O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFVuaWZvcm1zR2VuZXJpYyggdW5pZm9ybXMgKSB7XG5cbiAgICAgICAgdmFyIHRleHR1cmUsIHRleHR1cmVVbml0O1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB1bmlmb3Jtcy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zWyBqIF1bIDAgXTtcblxuICAgICAgICAgICAgLy8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cbiAgICAgICAgICAgIGlmICggdW5pZm9ybS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gdW5pZm9ybXNbIGogXVsgMSBdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCB0eXBlICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnMWknOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICcxZic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzJmJzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICczZic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnNGYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSwgdmFsdWVbIDMgXSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzFpdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICczaXYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnMWZ2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJzJmdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICczZnYnOlxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnNGZ2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ01hdHJpeDNmdic6XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnTWF0cml4NGZ2JzpcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgIGNhc2UgJ2knOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGZsb2F0XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndjInOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd2Myc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnogKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3Y0JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLkNvbG9yXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS5yLCB2YWx1ZS5nLCB2YWx1ZS5iICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpdjEnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpdic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdmdjEnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZnYnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3Yydic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yMlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAyICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaTIgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpKyssIGkyICs9IDIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMiArIDAgXSA9IHZhbHVlWyBpIF0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMiArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndjN2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDMgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpMyA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkrKywgaTMgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkzICsgMCBdID0gdmFsdWVbIGkgXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkzICsgMSBdID0gdmFsdWVbIGkgXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkzICsgMiBdID0gdmFsdWVbIGkgXS56O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd2NHYnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjRcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGk0ID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSsrLCBpNCArPSA0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTQgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTQgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTQgKyAzIF0gPSB2YWx1ZVsgaSBdLnc7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ20zJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuTWF0cml4M1xuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbTN2JzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXgzXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogOSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbTQnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5NYXRyaXg0XG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtNHYnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDRcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogMTYgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5UZXh0dXJlICgyZCBvciBjdWJlKVxuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXRleHR1cmUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5DdWJlVGV4dHVyZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndHYnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkgXSA9IGdldFRleHR1cmVVbml0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZVsgaSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICF0ZXh0dXJlICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmtub3duIHVuaWZvcm0gdHlwZTogJyArIHR5cGUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldENvbG9yTGluZWFyKCBhcnJheSwgb2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAwIF0gPSBjb2xvci5yICogaW50ZW5zaXR5O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZyAqIGludGVuc2l0eTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKSB7XG5cbiAgICAgICAgdmFyIGwsIGxsLCBsaWdodCxcbiAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgZyA9IDAsXG4gICAgICAgICAgICBiID0gMCxcbiAgICAgICAgICAgIGNvbG9yLCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBpbnRlbnNpdHksXG4gICAgICAgICAgICBkaXN0YW5jZSxcblxuICAgICAgICAgICAgemxpZ2h0cyA9IF9saWdodHMsXG5cbiAgICAgICAgICAgIHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLFxuXG4gICAgICAgICAgICBkaXJDb2xvcnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycyxcbiAgICAgICAgICAgIGRpclBvc2l0aW9ucyA9IHpsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zLFxuXG4gICAgICAgICAgICBwb2ludENvbG9ycyA9IHpsaWdodHMucG9pbnQuY29sb3JzLFxuICAgICAgICAgICAgcG9pbnRQb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcbiAgICAgICAgICAgIHBvaW50RGlzdGFuY2VzID0gemxpZ2h0cy5wb2ludC5kaXN0YW5jZXMsXG4gICAgICAgICAgICBwb2ludERlY2F5cyA9IHpsaWdodHMucG9pbnQuZGVjYXlzLFxuXG4gICAgICAgICAgICBzcG90Q29sb3JzID0gemxpZ2h0cy5zcG90LmNvbG9ycyxcbiAgICAgICAgICAgIHNwb3RQb3NpdGlvbnMgPSB6bGlnaHRzLnNwb3QucG9zaXRpb25zLFxuICAgICAgICAgICAgc3BvdERpc3RhbmNlcyA9IHpsaWdodHMuc3BvdC5kaXN0YW5jZXMsXG4gICAgICAgICAgICBzcG90RGlyZWN0aW9ucyA9IHpsaWdodHMuc3BvdC5kaXJlY3Rpb25zLFxuICAgICAgICAgICAgc3BvdEFuZ2xlc0NvcyA9IHpsaWdodHMuc3BvdC5hbmdsZXNDb3MsXG4gICAgICAgICAgICBzcG90RXhwb25lbnRzID0gemxpZ2h0cy5zcG90LmV4cG9uZW50cyxcbiAgICAgICAgICAgIHNwb3REZWNheXMgPSB6bGlnaHRzLnNwb3QuZGVjYXlzLFxuXG4gICAgICAgICAgICBoZW1pU2t5Q29sb3JzID0gemxpZ2h0cy5oZW1pLnNreUNvbG9ycyxcbiAgICAgICAgICAgIGhlbWlHcm91bmRDb2xvcnMgPSB6bGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzLFxuICAgICAgICAgICAgaGVtaVBvc2l0aW9ucyA9IHpsaWdodHMuaGVtaS5wb3NpdGlvbnMsXG5cbiAgICAgICAgICAgIGRpckxlbmd0aCA9IDAsXG4gICAgICAgICAgICBwb2ludExlbmd0aCA9IDAsXG4gICAgICAgICAgICBzcG90TGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGhlbWlMZW5ndGggPSAwLFxuXG4gICAgICAgICAgICBkaXJDb3VudCA9IDAsXG4gICAgICAgICAgICBwb2ludENvdW50ID0gMCxcbiAgICAgICAgICAgIHNwb3RDb3VudCA9IDAsXG4gICAgICAgICAgICBoZW1pQ291bnQgPSAwLFxuXG4gICAgICAgICAgICBkaXJPZmZzZXQgPSAwLFxuICAgICAgICAgICAgcG9pbnRPZmZzZXQgPSAwLFxuICAgICAgICAgICAgc3BvdE9mZnNldCA9IDAsXG4gICAgICAgICAgICBoZW1pT2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwrKyApIHtcblxuICAgICAgICAgICAgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuICAgICAgICAgICAgaWYgKCBsaWdodC5vbmx5U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbG9yID0gbGlnaHQuY29sb3I7XG4gICAgICAgICAgICBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgciArPSBjb2xvci5yO1xuICAgICAgICAgICAgICAgIGcgKz0gY29sb3IuZztcbiAgICAgICAgICAgICAgICBiICs9IGNvbG9yLmI7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICBkaXJDb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgZGlyT2Zmc2V0ID0gZGlyTGVuZ3RoICogMztcblxuICAgICAgICAgICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICAgICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuICAgICAgICAgICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIGRpckNvbG9ycywgZGlyT2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICAgICAgICBkaXJMZW5ndGggKz0gMTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuICAgICAgICAgICAgICAgIHBvaW50Q291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmICggIWxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHBvaW50T2Zmc2V0ID0gcG9pbnRMZW5ndGggKiAzO1xuXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIF92ZWN0b3IzLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgcG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMCBdID0gX3ZlY3RvcjMueDtcbiAgICAgICAgICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xuICAgICAgICAgICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XG5cbiAgICAgICAgICAgICAgICAvLyBkaXN0YW5jZSBpcyAwIGlmIGRlY2F5IGlzIDAsIGJlY2F1c2UgdGhlcmUgaXMgbm8gYXR0ZW51YXRpb24gYXQgYWxsLlxuICAgICAgICAgICAgICAgIHBvaW50RGlzdGFuY2VzWyBwb2ludExlbmd0aCBdID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgcG9pbnREZWNheXNbIHBvaW50TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuICAgICAgICAgICAgICAgIHBvaW50TGVuZ3RoICs9IDE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuICAgICAgICAgICAgICAgIHNwb3RDb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgc3BvdE9mZnNldCA9IHNwb3RMZW5ndGggKiAzO1xuXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIF92ZWN0b3IzLmNvcHkoIF9kaXJlY3Rpb24gKS5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuICAgICAgICAgICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAwIF0gPSBfdmVjdG9yMy54O1xuICAgICAgICAgICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xuICAgICAgICAgICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfdmVjdG9yMy56O1xuXG4gICAgICAgICAgICAgICAgc3BvdERpc3RhbmNlc1sgc3BvdExlbmd0aCBdID0gZGlzdGFuY2U7XG5cbiAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcbiAgICAgICAgICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcbiAgICAgICAgICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuICAgICAgICAgICAgICAgIHNwb3RBbmdsZXNDb3NbIHNwb3RMZW5ndGggXSA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xuICAgICAgICAgICAgICAgIHNwb3RFeHBvbmVudHNbIHNwb3RMZW5ndGggXSA9IGxpZ2h0LmV4cG9uZW50O1xuICAgICAgICAgICAgICAgIHNwb3REZWNheXNbIHNwb3RMZW5ndGggXSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xuXG4gICAgICAgICAgICAgICAgc3BvdExlbmd0aCArPSAxO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICBoZW1pQ291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmICggIWxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgICBoZW1pT2Zmc2V0ID0gaGVtaUxlbmd0aCAqIDM7XG5cbiAgICAgICAgICAgICAgICBoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICAgICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgICAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuICAgICAgICAgICAgICAgIHNreUNvbG9yID0gbGlnaHQuY29sb3I7XG4gICAgICAgICAgICAgICAgZ3JvdW5kQ29sb3IgPSBsaWdodC5ncm91bmRDb2xvcjtcblxuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBoZW1pU2t5Q29sb3JzLCBoZW1pT2Zmc2V0LCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIGhlbWlHcm91bmRDb2xvcnMsIGhlbWlPZmZzZXQsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgICAgICAgICAgICAgIGhlbWlMZW5ndGggKz0gMTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBudWxsIGV2ZW50dWFsIHJlbWFpbnMgZnJvbSByZW1vdmVkIGxpZ2h0c1xuICAgICAgICAvLyAodGhpcyBpcyB0byBhdm9pZCBpZiBpbiBzaGFkZXIpXG5cbiAgICAgICAgZm9yICggbCA9IGRpckxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGRpckNvbG9ycy5sZW5ndGgsIGRpckNvdW50ICogMyApOyBsIDwgbGw7IGwrKyApIGRpckNvbG9yc1sgbCBdID0gMC4wO1xuICAgICAgICBmb3IgKCBsID0gcG9pbnRMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBwb2ludENvbG9ycy5sZW5ndGgsIHBvaW50Q291bnQgKiAzICk7IGwgPCBsbDsgbCsrICkgcG9pbnRDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICAgICAgZm9yICggbCA9IHNwb3RMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBzcG90Q29sb3JzLmxlbmd0aCwgc3BvdENvdW50ICogMyApOyBsIDwgbGw7IGwrKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICAgICAgZm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pU2t5Q29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwrKyApIGhlbWlTa3lDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICAgICAgZm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pR3JvdW5kQ29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwrKyApIGhlbWlHcm91bmRDb2xvcnNbIGwgXSA9IDAuMDtcblxuICAgICAgICB6bGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpckxlbmd0aDtcbiAgICAgICAgemxpZ2h0cy5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcbiAgICAgICAgemxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG4gICAgICAgIHpsaWdodHMuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xuXG4gICAgICAgIHpsaWdodHMuYW1iaWVudFsgMCBdID0gcjtcbiAgICAgICAgemxpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xuICAgICAgICB6bGlnaHRzLmFtYmllbnRbIDIgXSA9IGI7XG5cbiAgICB9XG5cbiAgICAvLyBHTCBzdGF0ZSBzZXR0aW5nXG5cbiAgICB0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24oIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XG5cbiAgICAgICAgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VOb25lICkge1xuXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKCBmcm9udEZhY2VEaXJlY3Rpb24gPT09IFRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLmZyb250RmFjZSggX2dsLkNXICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgX2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlQmFjayApIHtcblxuICAgICAgICAgICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVF9BTkRfQkFDSyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBUZXh0dXJlc1xuXG4gICAgZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMoIHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgICAgIGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xuXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcblxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLiAoICcgKyB0ZXh0dXJlLnNvdXJjZUZpbGUgKyAnICknICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuICggJyArIHRleHR1cmUuc291cmNlRmlsZSArICcgKScgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiApIHtcblxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcbiAgICAgICAgICAgIGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XG5cbiAgICAgICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyZiggdGV4dHVyZVR5cGUsIGV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oIHRleHR1cmUuYW5pc290cm9weSwgX3RoaXMuZ2V0TWF4QW5pc290cm9weSgpICkgKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApIHtcblxuICAgICAgICBpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGV4dHVyZS5fX3dlYmdsSW5pdCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMrKztcblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XG5cbiAgICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZSxcbiAgICAgICAgICAgIGlzSW1hZ2VQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApLFxuICAgICAgICAgICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcbiAgICAgICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cbiAgICAgICAgdmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuICAgICAgICBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgLy8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuICAgICAgICAgICAgLy8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cbiAgICAgICAgICAgIGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXG4gICAgICAgICAgICAvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG4gICAgICAgICAgICAvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuICAgICAgICAgICAgaWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmltYWdlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24oIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICAgICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuICAgICAgICBpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cbiAgICAgICAgICAgIGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJywgdGV4dHVyZSApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSggaW1hZ2UsIG1heFNpemUgKSB7XG5cbiAgICAgICAgaWYgKCBpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSApIHtcblxuICAgICAgICAgICAgLy8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcbiAgICAgICAgICAgIC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXG5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG1heFNpemUgLyBNYXRoLm1heCggaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBzY2FsZSApO1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICAgICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuICAgICAgICBpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xuXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICF0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMrKztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuICAgICAgICAgICAgICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblxuICAgICAgICAgICAgICAgIHZhciBpc0NvbXByZXNzZWQgPSB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XG4gICAgICAgICAgICAgICAgdmFyIGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIHZhciBjdWJlSW1hZ2UgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIF90aGlzLmF1dG9TY2FsZUN1YmVtYXBzICYmICFpc0NvbXByZXNzZWQgJiYgIWlzRGF0YVRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1YmVJbWFnZVsgaSBdID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2VbIGkgXSwgY2FwYWJpbGl0aWVzLm1heEN1YmVtYXBTaXplICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGN1YmVJbWFnZVsgMCBdLFxuICAgICAgICAgICAgICAgICAgICBpc0ltYWdlUG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcbiAgICAgICAgICAgICAgICAgICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcbiAgICAgICAgICAgICAgICAgICAgZ2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG4gICAgICAgICAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzQ29tcHJlc3NlZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0RhdGFUZXh0dXJlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBqIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldEN1YmVUZXh0dXJlKClcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZSwgc2xvdCApIHtcblxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIHRhcmdldHNcblxuICAgIGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXIoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIHRleHR1cmVUYXJnZXQgKSB7XG5cbiAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuICAgICAgICBfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbFRleHR1cmUsIDAgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgICBfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgIXJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICAgICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcbiAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgICAgIC8qIEZvciBzb21lIHJlYXNvbiB0aGlzIGlzIG5vdCB3b3JraW5nLiBEZWZhdWx0aW5nIHRvIFJHQkE0LlxuXHRcdH0gZWxzZSBpZiAoICEgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlNURU5DSUxfSU5ERVg4LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblx0XHQqL1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcbiAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICAgICAgdmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgJiYgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9IHRydWU7XG5cbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG4gICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMrKztcblxuICAgICAgICAgICAgLy8gU2V0dXAgdGV4dHVyZSwgY3JlYXRlIHJlbmRlciBhbmQgZnJhbWUgYnVmZmVyc1xuXG4gICAgICAgICAgICB2YXIgaXNUYXJnZXRQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQuaGVpZ2h0ICksXG4gICAgICAgICAgICAgICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLFxuICAgICAgICAgICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudHlwZSApO1xuXG4gICAgICAgICAgICBpZiAoIGlzQ3ViZSApIHtcblxuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gW107XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgICAgICAgICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tLl9fd2ViZ2xSZW5kZXJidWZmZXI7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG4gICAgICAgICAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuICAgICAgICAgICAgICAgIHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFXzJEICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWxlYXNlIGV2ZXJ5dGhpbmdcblxuICAgICAgICAgICAgaWYgKCBpc0N1YmUgKSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuICAgICAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcmFtZWJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgdngsIHZ5O1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICAgICAgaWYgKCBpc0N1YmUgKSB7XG5cbiAgICAgICAgICAgICAgICBmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblxuICAgICAgICAgICAgdnggPSAwO1xuICAgICAgICAgICAgdnkgPSAwO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGZyYW1lYnVmZmVyID0gbnVsbDtcblxuICAgICAgICAgICAgd2lkdGggPSBfdmlld3BvcnRXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IF92aWV3cG9ydEhlaWdodDtcblxuICAgICAgICAgICAgdnggPSBfdmlld3BvcnRYO1xuICAgICAgICAgICAgdnkgPSBfdmlld3BvcnRZO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xuXG4gICAgICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG4gICAgICAgICAgICBfZ2wudmlld3BvcnQoIHZ4LCB2eSwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgICAgICAgICBfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF9jdXJyZW50V2lkdGggPSB3aWR0aDtcbiAgICAgICAgX2N1cnJlbnRIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzID0gZnVuY3Rpb24oIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyICkge1xuXG4gICAgICAgIGlmICggISggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciApIHtcblxuICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIGZvcm1hdC4gcmVhZFBpeGVscyBjYW4gcmVhZCBvbmx5IFJHQkEgZm9ybWF0LicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cbiAgICAgICAgICAgICAgICByZXN0b3JlID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIF9nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCBfZ2wuRlJBTUVCVUZGRVIgKSA9PT0gX2dsLkZSQU1FQlVGRkVSX0NPTVBMRVRFICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIF9nbC5SR0JBLCBfZ2wuVU5TSUdORURfQllURSwgYnVmZmVyICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS4nICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCByZXN0b3JlICkge1xuXG4gICAgICAgICAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xUZXh0dXJlICk7XG4gICAgICAgICAgICBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG4gICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsVGV4dHVyZSApO1xuICAgICAgICAgICAgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcblxuICAgIGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrKCBmICkge1xuXG4gICAgICAgIGlmICggZiA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG4gICAgICAgICAgICByZXR1cm4gX2dsLk5FQVJFU1Q7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZ2wuTElORUFSO1xuXG4gICAgfVxuXG4gICAgLy8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcblxuICAgIGZ1bmN0aW9uIHBhcmFtVGhyZWVUb0dMKCBwICkge1xuXG4gICAgICAgIHZhciBleHRlbnNpb247XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gX2dsLkNMQU1QX1RPX0VER0U7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUO1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5CeXRlVHlwZSApIHJldHVybiBfZ2wuQllURTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5TaG9ydFR5cGUgKSByZXR1cm4gX2dsLlNIT1JUO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5JbnRUeXBlICkgcmV0dXJuIF9nbC5JTlQ7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcblxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSApIHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkZvcm1hdCApIHJldHVybiBfZ2wuUkdCO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFGb3JtYXQgKSByZXR1cm4gX2dsLlJHQkE7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRV9BTFBIQTtcblxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkFkZEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX0FERDtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5TdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1NVQlRSQUNUO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XG5cbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5aZXJvRmFjdG9yICkgcmV0dXJuIF9nbC5aRVJPO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZUZhY3RvciApIHJldHVybiBfZ2wuT05FO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQ09MT1I7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQUxQSEE7XG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9BTFBIQTtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xuXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9DT0xPUjtcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0NPTE9SO1xuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcblxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXG4gICAgICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuXG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5NaW5FcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUlOX0VYVDtcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuTWF4RXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1BWF9FWFQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgfVxuXG4gICAgLy8gREVQUkVDQVRFRFxuXG4gICAgdGhpcy5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfZmxvYXRcXCcgKS4nICk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcJyApLicgKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXCcgKS4nICk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcXCcgKS4nICk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcJyApLicgKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3VwcG9ydHNCbGVuZE1pbk1heCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnRVhUX2JsZW5kX21pbm1heFxcJyApLicgKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgfTtcblxuICAgIC8vXG5cbiAgICB0aGlzLmluaXRNYXRlcmlhbCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmFkZFByZVBsdWdpbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmFkZFBvc3RQbHVnaW4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlU2hhZG93TWFwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgICAgIHNoYWRvd01hcEVuYWJsZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLmVuYWJsZWQ7XG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xuICAgICAgICAgICAgICAgIHNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93TWFwVHlwZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dNYXAudHlwZTtcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcFR5cGUgaXMgbm93IC5zaGFkb3dNYXAudHlwZS4nICk7XG4gICAgICAgICAgICAgICAgc2hhZG93TWFwLnR5cGUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3dNYXBDdWxsRmFjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dNYXAuY3VsbEZhY2U7XG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS4nICk7XG4gICAgICAgICAgICAgICAgc2hhZG93TWFwLmN1bGxGYWNlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93TWFwRGVidWc6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLmRlYnVnO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRGVidWcgaXMgbm93IC5zaGFkb3dNYXAuZGVidWcuJyApO1xuICAgICAgICAgICAgICAgIHNoYWRvd01hcC5kZWJ1ZyA9IHZhbHVlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMud3JhcFMgPSBvcHRpb25zLndyYXBTICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLndyYXBUID0gb3B0aW9ucy53cmFwVCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cbiAgICB0aGlzLm1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcbiAgICB0aGlzLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICAgIHRoaXMuYW5pc290cm9weSA9IG9wdGlvbnMuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmlzb3Ryb3B5IDogMTtcblxuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcbiAgICB0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xuICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVuY2lsQnVmZmVyIDogdHJ1ZTtcblxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblxuICAgIHRoaXMuc2hhcmVEZXB0aEZyb20gPSBvcHRpb25zLnNoYXJlRGVwdGhGcm9tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNoYXJlRGVwdGhGcm9tIDogbnVsbDtcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oIHNvdXJjZSApIHtcblxuICAgICAgICB0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcbiAgICAgICAgdGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblxuICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG4gICAgICAgIHRoaXMubWluRmlsdGVyID0gc291cmNlLm1pbkZpbHRlcjtcblxuICAgICAgICB0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblxuICAgICAgICB0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XG4gICAgICAgIHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcblxuICAgICAgICB0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xuXG4gICAgICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBzb3VyY2UuZGVwdGhCdWZmZXI7XG4gICAgICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcblxuICAgICAgICB0aGlzLnNoYXJlRGVwdGhGcm9tID0gc291cmNlLnNoYXJlRGVwdGhGcm9tO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuICAgICAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICAgIH0gKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldEN1YmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cbiAgICBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5jYWxsKCB0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cbiAgICB0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDsgLy8gUFggMCwgTlggMSwgUFkgMiwgTlkgMywgUFogNCwgTlogNVxuXG59O1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xCdWZmZXJSZW5kZXJlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICkge1xuXG4gICAgdmFyIG1vZGU7XG5cbiAgICBmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuICAgICAgICBtb2RlID0gdmFsdWU7XG5cbiAgICB9XG5cbiAgICB2YXIgdHJhY2VDb3VudCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcbiAgICAgICAgaWYgKCB0cmFjZUNvdW50ID09PSAwICkge1xuICAgICAgICAgICAgdHJhY2VDb3VudCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XG5cbiAgICAgICAgX2luZm9SZW5kZXIuY2FsbHMrKztcbiAgICAgICAgX2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XG4gICAgICAgIGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICBpZiAoIHBvc2l0aW9uIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgIGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIHBvc2l0aW9uLmRhdGEuY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcbiAgICB0aGlzLnJlbmRlciA9IHJlbmRlcjtcbiAgICB0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICkge1xuXG4gICAgdmFyIG1vZGU7XG5cbiAgICBmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuICAgICAgICBtb2RlID0gdmFsdWU7XG5cbiAgICB9XG5cbiAgICB2YXIgdHlwZSwgc2l6ZTtcblxuICAgIGZ1bmN0aW9uIHNldEluZGV4KCBpbmRleCApIHtcblxuICAgICAgICBpZiAoIGluZGV4LmFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xuXG4gICAgICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX0lOVDtcbiAgICAgICAgICAgIHNpemUgPSA0O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHR5cGUgPSBfZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgICAgICAgICBzaXplID0gMjtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcblxuICAgICAgICBfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBzaXplICk7XG5cbiAgICAgICAgX2luZm9SZW5kZXIuY2FsbHMrKztcbiAgICAgICAgX2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XG4gICAgICAgIGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cbiAgICAgICAgZXh0ZW5zaW9uLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKCBtb2RlLCBpbmRleC5hcnJheS5sZW5ndGgsIHR5cGUsIDAsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuICAgIHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcbiAgICB0aGlzLnJlbmRlciA9IHJlbmRlcjtcbiAgICB0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMRXh0ZW5zaW9ucy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xFeHRlbnNpb25zID0gZnVuY3Rpb24oIGdsICkge1xuXG4gICAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICAgICAgaWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4dGVuc2lvbjtcblxuICAgICAgICBzd2l0Y2ggKCBuYW1lICkge1xuXG4gICAgICAgICAgICBjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG5cbiAgICB9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xDYXBhYmlsaXRpZXMuanNcblxuVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcblxuICAgICAgICBpZiAoIHByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcblxuICAgICAgICAgICAgaWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG4gICAgICAgICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWdocCc7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlY2lzaW9uID0gJ21lZGl1bXAnO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xuXG4gICAgICAgICAgICBpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxuICAgICAgICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZWRpdW1wJztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ2xvd3AnO1xuXG4gICAgfVxuXG4gICAgdGhpcy5nZXRNYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb247XG5cbiAgICB0aGlzLnByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXG4gICAgdGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgOiBmYWxzZTtcblxuICAgIHRoaXMubWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG4gICAgdGhpcy5tYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG4gICAgdGhpcy5tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xuICAgIHRoaXMubWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcblxuICAgIHRoaXMubWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG4gICAgdGhpcy5tYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcbiAgICB0aGlzLm1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XG4gICAgdGhpcy5tYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XG5cbiAgICB0aGlzLnZlcnRleFRleHR1cmVzID0gdGhpcy5tYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG4gICAgdGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhIWV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG4gICAgdGhpcy5mbG9hdFZlcnRleFRleHR1cmVzID0gdGhpcy52ZXJ0ZXhUZXh0dXJlcyAmJiB0aGlzLmZsb2F0RnJhZ21lbnRUZXh0dXJlcztcblxuICAgIHZhciBfbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCB0aGlzLnByZWNpc2lvbiApO1xuXG4gICAgaWYgKCBfbWF4UHJlY2lzaW9uICE9PSB0aGlzLnByZWNpc2lvbiApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHRoaXMucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBfbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gX21heFByZWNpc2lvbjtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xuXG4gICAgICAgIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9ICEhZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMR2VvbWV0cmllcy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xHZW9tZXRyaWVzID0gZnVuY3Rpb24oIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgICBpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuICAgICAgICB2YXIgYnVmZmVyZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IGJ1ZmZlcmdlb21ldHJ5O1xuXG4gICAgICAgIGluZm8ubWVtb3J5Lmdlb21ldHJpZXMrKztcblxuICAgICAgICByZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgICAgIGRlbGV0ZUF0dHJpYnV0ZXMoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKTtcblxuICAgICAgICBnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cbiAgICAgICAgZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XG4gICAgICAgIGlmICggcHJvcGVydHkud2lyZWZyYW1lICkgZGVsZXRlQXR0cmlidXRlKCBwcm9wZXJ0eS53aXJlZnJhbWUgKTtcblxuICAgICAgICBpbmZvLm1lbW9yeS5nZW9tZXRyaWVzLS07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICk7XG5cbiAgICAgICAgaWYgKCBidWZmZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKCBidWZmZXIgKTtcbiAgICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICBkZWxldGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUuZGF0YSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmdldCA9IGdldDtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMT2JqZWN0cy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xPYmplY3RzID0gZnVuY3Rpb24oIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSBuZXcgVEhSRUUuV2ViR0xHZW9tZXRyaWVzKCBnbCwgcHJvcGVydGllcywgaW5mbyApO1xuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG4gICAgICAgIC8vIFRPRE86IEF2b2lkIHVwZGF0aW5nIHR3aWNlICh3aGVuIHVzaW5nIHNoYWRvd01hcCkuIE1heWJlIGFkZCBmcmFtZSBjb3VudGVyLlxuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QgKTtcblxuICAgICAgICBpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICBnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoIGluZGV4LCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vcnBoIHRhcmdldHNcblxuICAgICAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgdmFyIGFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgPyBhdHRyaWJ1dGUuZGF0YSA6IGF0dHJpYnV0ZTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBkYXRhICk7XG5cbiAgICAgICAgaWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiAhPT0gZGF0YS52ZXJzaW9uICkge1xuXG4gICAgICAgICAgICB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cbiAgICAgICAgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xuXG4gICAgICAgIHZhciB1c2FnZSA9IGRhdGEuZHluYW1pYyA/IGdsLkRZTkFNSUNfRFJBVyA6IGdsLlNUQVRJQ19EUkFXO1xuICAgICAgICBnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLmFycmF5LCB1c2FnZSApO1xuXG4gICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApIHtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcblxuICAgICAgICBpZiAoIGRhdGEuZHluYW1pYyA9PT0gZmFsc2UgfHwgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gLTEgKSB7XG5cbiAgICAgICAgICAgIC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBkYXRhLmFycmF5ICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMT2JqZWN0cy51cGRhdGVCdWZmZXI6IGR5bmFtaWMgVEhSRUUuQnVmZmVyQXR0cmlidXRlIG1hcmtlZCBhcyBuZWVkc1VwZGF0ZSBidXQgdXBkYXRlUmFuZ2UuY291bnQgaXMgMCwgZW5zdXJlIHlvdSBhcmUgdXNpbmcgc2V0IG1ldGhvZHMgb3IgdXBkYXRpbmcgbWFudWFsbHkuJyApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgICAgICAgICAgZGF0YS5hcnJheS5zdWJhcnJheSggZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICsgZGF0YS51cGRhdGVSYW5nZS5jb3VudCApICk7XG5cbiAgICAgICAgICAgIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPSAwOyAvLyByZXNldCByYW5nZVxuXG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcblxuICAgICAgICBpZiAoIHByb3BlcnR5LndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHkud2lyZWZyYW1lO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgLy8gY29uc29sZS50aW1lKCAnd2lyZWZyYW1lJyApO1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHZhciBlZGdlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gaW5kZXguYXJyYXk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBhID0gYXJyYXlbIGkgKyAwIF07XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBhcnJheVsgaSArIDEgXTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGFycmF5WyBpICsgMiBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBhLCBiICkgKSBpbmRpY2VzLnB1c2goIGEsIGIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGIsIGMgKSApIGluZGljZXMucHVzaCggYiwgYyApO1xuICAgICAgICAgICAgICAgIGlmICggY2hlY2tFZGdlKCBlZGdlcywgYywgYSApICkgaW5kaWNlcy5wdXNoKCBjLCBhICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYSA9IGkgKyAwO1xuICAgICAgICAgICAgICAgIHZhciBiID0gaSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBpICsgMjtcblxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcblxuICAgICAgICB2YXIgVHlwZUFycmF5ID0gcG9zaXRpb24uY291bnQgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVHlwZUFycmF5KCBpbmRpY2VzICksIDEgKTtcblxuICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuICAgICAgICBwcm9wZXJ0eS53aXJlZnJhbWUgPSBhdHRyaWJ1dGU7XG5cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrRWRnZSggZWRnZXMsIGEsIGIgKSB7XG5cbiAgICAgICAgaWYgKCBhID4gYiApIHtcblxuICAgICAgICAgICAgdmFyIHRtcCA9IGE7XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgIGIgPSB0bXA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ID0gZWRnZXNbIGEgXTtcblxuICAgICAgICBpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgZWRnZXNbIGEgXSA9IFsgYiBdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbGlzdC5pbmRleE9mKCBiICkgPT09IC0xICkge1xuXG4gICAgICAgICAgICBsaXN0LnB1c2goIGIgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICB0aGlzLmdldEF0dHJpYnV0ZUJ1ZmZlciA9IGdldEF0dHJpYnV0ZUJ1ZmZlcjtcbiAgICB0aGlzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSA9IGdldFdpcmVmcmFtZUF0dHJpYnV0ZTtcblxuICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtLmpzXG5cblRIUkVFLldlYkdMUHJvZ3JhbSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICkge1xuXG4gICAgICAgIHZhciBjaHVua3MgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGlmICggdmFsdWUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuXG4gICAgICAgIHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVU5JRk9STTpcIiwgbmFtZSk7XG5cbiAgICAgICAgICAgIHZhciBzdWZmaXhQb3MgPSBuYW1lLmxhc3RJbmRleE9mKCAnWzBdJyApO1xuICAgICAgICAgICAgaWYgKCBzdWZmaXhQb3MgIT09IC0xICYmIHN1ZmZpeFBvcyA9PT0gbmFtZS5sZW5ndGggLSAzICkge1xuXG4gICAgICAgICAgICAgICAgdW5pZm9ybXNbIG5hbWUuc3Vic3RyKCAwLCBzdWZmaXhQb3MgKSBdID0gbG9jYXRpb247XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdW5pZm9ybXNbIG5hbWUgXSA9IGxvY2F0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5pZm9ybXM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG5cbiAgICAgICAgdmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6XCIsIG5hbWUsIGkgKTtcblxuICAgICAgICAgICAgYXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcblxuICAgICAgICByZXR1cm4gc3RyaW5nICE9PSAnJztcblxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXG4gICAgICAgIHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcblxuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIuZnJhZ21lbnRTaGFkZXI7XG5cbiAgICAgICAgdmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xuXG4gICAgICAgIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XG5cbiAgICAgICAgICAgIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cbiAgICAgICAgICAgIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcbiAgICAgICAgdmFyIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGTEVDVElPTic7XG4gICAgICAgIHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuXG4gICAgICAgIGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgICAgICAgICAgIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgICAgICAgICAgIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfU1BIRVJFJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRlJBQ1RJT04nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5jb21iaW5lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk1peE9wZXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5BZGRPcGVyYXRpb246XG4gICAgICAgICAgICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2FtbWFGYWN0b3JEZWZpbmUgPSAoIHJlbmRlcmVyLmdhbW1hRmFjdG9yID4gMCApID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XG5cbiAgICAgICAgLy9cblxuICAgICAgICB2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICAgICAgdmFyIHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsICkge1xuXG4gICAgICAgICAgICBwcmVmaXhWZXJ0ZXggPSAnJztcbiAgICAgICAgICAgIHByZWZpeEZyYWdtZW50ID0gJyc7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcHJlZml4VmVydGV4ID0gW1xuXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcblxuICAgICAgICAgICAgICAgIGN1c3RvbURlZmluZXMsXG5cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBWRVJURVhfVEVYVFVSRVMnIDogJycsXG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfUE9JTlRfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1NIQURPV1MgJyArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcblxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCAmJiBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gJyNkZWZpbmUgQk9ORV9URVhUVVJFJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gJyNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gPyAnI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlIHZlYzMgcG9zaXRpb247JyxcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cbiAgICAgICAgICAgICAgICAnI2lmZGVmIFVTRV9DT0xPUicsXG5cbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjsnLFxuXG4gICAgICAgICAgICAgICAgJyNlbmRpZicsXG5cbiAgICAgICAgICAgICAgICAnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLFxuXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXG5cbiAgICAgICAgICAgICAgICAnXHQjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXG5cbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLFxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7JyxcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLFxuXG4gICAgICAgICAgICAgICAgJ1x0I2Vsc2UnLFxuXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcblxuICAgICAgICAgICAgICAgICdcdCNlbmRpZicsXG5cbiAgICAgICAgICAgICAgICAnI2VuZGlmJyxcblxuICAgICAgICAgICAgICAgICcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcblxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLFxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7JyxcblxuICAgICAgICAgICAgICAgICcjZW5kaWYnLFxuXG4gICAgICAgICAgICAgICAgJ1xcbidcblxuICAgICAgICAgICAgXS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cbiAgICAgICAgICAgIHByZWZpeEZyYWdtZW50ID0gW1xuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5idW1wTWFwIHx8IHBhcmFtZXRlcnMubm9ybWFsTWFwIHx8IHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgfHwgbWF0ZXJpYWwuZGVyaXZhdGl2ZXMgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJyxcblxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcblxuICAgICAgICAgICAgICAgICcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXG5cbiAgICAgICAgICAgICAgICBjdXN0b21EZWZpbmVzLFxuXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXG5cbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfU0hBRE9XUyAnICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBBTFBIQVRFU1QgJyArIHBhcmFtZXRlcnMuYWxwaGFUZXN0IDogJycsXG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuICAgICAgICAgICAgICAgICggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsICggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubWV0YWwgPyAnI2RlZmluZSBNRVRBTCcgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gJyNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHJyA6ICcnLFxuXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcblxuICAgICAgICAgICAgICAgICdcXG4nXG5cbiAgICAgICAgICAgIF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGV4R2xzbCA9IHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcbiAgICAgICAgdmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XG5cbiAgICAgICAgdmFyIGdsVmVydGV4U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XG4gICAgICAgIHZhciBnbEZyYWdtZW50U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xuXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XG5cbiAgICAgICAgLy8gRm9yY2UgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSB0byBpbmRleCAwLlxuXG4gICAgICAgIGlmICggbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgLy8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXG4gICAgICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgICAgICB2YXIgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XG4gICAgICAgIHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xuICAgICAgICB2YXIgZnJhZ21lbnRMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbEZyYWdtZW50U2hhZGVyICk7XG5cbiAgICAgICAgdmFyIHJ1bm5hYmxlID0gdHJ1ZTtcbiAgICAgICAgdmFyIGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgcnVubmFibGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2csIHZlcnRleExvZywgZnJhZ21lbnRMb2cgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBwcm9ncmFtTG9nICE9PSAnJyApIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgcHJvZ3JhbUxvZyApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHZlcnRleExvZyA9PT0gJycgfHwgZnJhZ21lbnRMb2cgPT09ICcnICkge1xuXG4gICAgICAgICAgICBoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSB7XG5cbiAgICAgICAgICAgICAgICBydW5uYWJsZTogcnVubmFibGUsXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsLFxuXG4gICAgICAgICAgICAgICAgcHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcblxuICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjoge1xuXG4gICAgICAgICAgICAgICAgICAgIGxvZzogdmVydGV4TG9nLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeFZlcnRleFxuXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9nOiBmcmFnbWVudExvZyxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhGcmFnbWVudFxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiB1cFxuXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XG5cbiAgICAgICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cbiAgICAgICAgdmFyIGNhY2hlZFVuaWZvcm1zO1xuXG4gICAgICAgIHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKCBjYWNoZWRVbmlmb3JtcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY2FjaGVkVW5pZm9ybXMgPSBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcblxuICAgICAgICB2YXIgY2FjaGVkQXR0cmlidXRlcztcblxuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKCBjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmcmVlIHJlc291cmNlXG5cbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERFUFJFQ0FURURcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXG4gICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLicgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5pZm9ybXMoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuJyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSApO1xuXG5cbiAgICAgICAgLy9cblxuICAgICAgICB0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQrKztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy51c2VkVGltZXMgPSAxO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtcy5qc1xuXG5USFJFRS5XZWJHTFByb2dyYW1zID0gZnVuY3Rpb24oIHJlbmRlcmVyLCBjYXBhYmlsaXRpZXMgKSB7XG5cbiAgICB2YXIgcHJvZ3JhbXMgPSBbXTtcblxuICAgIHZhciBzaGFkZXJJRHMgPSB7XG4gICAgICAgIE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuICAgICAgICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICAgICAgICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICAgICAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICAgICAgICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgICAgICAgTGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgICAgIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gICAgICAgIFBvaW50c01hdGVyaWFsOiAncG9pbnRzJ1xuICAgIH07XG5cbiAgICB2YXIgcGFyYW1ldGVyTmFtZXMgPSBbXG4gICAgICAgIFwicHJlY2lzaW9uXCIsIFwic3VwcG9ydHNWZXJ0ZXhUZXh0dXJlc1wiLCBcIm1hcFwiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIixcbiAgICAgICAgXCJsaWdodE1hcFwiLCBcImFvTWFwXCIsIFwiZW1pc3NpdmVNYXBcIiwgXCJidW1wTWFwXCIsIFwibm9ybWFsTWFwXCIsIFwic3BlY3VsYXJNYXBcIixcbiAgICAgICAgXCJhbHBoYU1hcFwiLCBcImNvbWJpbmVcIiwgXCJ2ZXJ0ZXhDb2xvcnNcIiwgXCJmb2dcIiwgXCJ1c2VGb2dcIiwgXCJmb2dFeHBcIixcbiAgICAgICAgXCJmbGF0U2hhZGluZ1wiLCBcInNpemVBdHRlbnVhdGlvblwiLCBcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcIiwgXCJza2lubmluZ1wiLFxuICAgICAgICBcIm1heEJvbmVzXCIsIFwidXNlVmVydGV4VGV4dHVyZVwiLCBcIm1vcnBoVGFyZ2V0c1wiLCBcIm1vcnBoTm9ybWFsc1wiLFxuICAgICAgICBcIm1heE1vcnBoVGFyZ2V0c1wiLCBcIm1heE1vcnBoTm9ybWFsc1wiLCBcIm1heERpckxpZ2h0c1wiLCBcIm1heFBvaW50TGlnaHRzXCIsXG4gICAgICAgIFwibWF4U3BvdExpZ2h0c1wiLCBcIm1heEhlbWlMaWdodHNcIiwgXCJtYXhTaGFkb3dzXCIsIFwic2hhZG93TWFwRW5hYmxlZFwiLFxuICAgICAgICBcInNoYWRvd01hcFR5cGVcIiwgXCJzaGFkb3dNYXBEZWJ1Z1wiLCBcImFscGhhVGVzdFwiLCBcIm1ldGFsXCIsIFwiZG91YmxlU2lkZWRcIixcbiAgICAgICAgXCJmbGlwU2lkZWRcIlxuICAgIF07XG5cblxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMoIG9iamVjdCApIHtcblxuICAgICAgICBpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAxMDI0O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vICggZm9yIGV4YW1wbGUgd2hlbiBwcmVidWlsZGluZyBzaGFkZXIgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXG4gICAgICAgICAgICAvLyAgLSBsaW1pdCBoZXJlIGlzIEFOR0xFJ3MgMjU0IG1heCB1bmlmb3JtIHZlY3RvcnNcbiAgICAgICAgICAgIC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcblxuICAgICAgICAgICAgdmFyIG5WZXJ0ZXhVbmlmb3JtcyA9IGNhcGFiaWxpdGllcy5tYXhWZXJ0ZXhVbmlmb3JtcztcbiAgICAgICAgICAgIHZhciBuVmVydGV4TWF0cmljZXMgPSBNYXRoLmZsb29yKCAoIG5WZXJ0ZXhVbmlmb3JtcyAtIDIwICkgLyA0ICk7XG5cbiAgICAgICAgICAgIHZhciBtYXhCb25lcyA9IG5WZXJ0ZXhNYXRyaWNlcztcblxuICAgICAgICAgICAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuICAgICAgICAgICAgICAgIG1heEJvbmVzID0gTWF0aC5taW4oIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGgsIG1heEJvbmVzICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtICcgKyBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICsgJywgdGhpcyBHUFUgc3VwcG9ydHMganVzdCAnICsgbWF4Qm9uZXMgKyAnICh0cnkgT3BlbkdMIGluc3RlYWQgb2YgQU5HTEUpJyApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXhCb25lcztcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxvY2F0ZUxpZ2h0cyggbGlnaHRzICkge1xuXG4gICAgICAgIHZhciBkaXJMaWdodHMgPSAwO1xuICAgICAgICB2YXIgcG9pbnRMaWdodHMgPSAwO1xuICAgICAgICB2YXIgc3BvdExpZ2h0cyA9IDA7XG4gICAgICAgIHZhciBoZW1pTGlnaHRzID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG4gICAgICAgICAgICBpZiAoIGxpZ2h0Lm9ubHlTaGFkb3cgfHwgbGlnaHQudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBkaXJMaWdodHMrKztcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkgcG9pbnRMaWdodHMrKztcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBzcG90TGlnaHRzKys7XG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkgaGVtaUxpZ2h0cysrO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2RpcmVjdGlvbmFsJzogZGlyTGlnaHRzLFxuICAgICAgICAgICAgJ3BvaW50JzogcG9pbnRMaWdodHMsXG4gICAgICAgICAgICAnc3BvdCc6IHNwb3RMaWdodHMsXG4gICAgICAgICAgICAnaGVtaSc6IGhlbWlMaWdodHNcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICkge1xuXG4gICAgICAgIHZhciBtYXhTaGFkb3dzID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG4gICAgICAgICAgICBpZiAoICFsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBtYXhTaGFkb3dzKys7XG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIG1heFNoYWRvd3MrKztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heFNoYWRvd3M7XG5cbiAgICB9XG5cbiAgICB0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKSB7XG5cbiAgICAgICAgdmFyIHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XG4gICAgICAgIC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG4gICAgICAgIC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cbiAgICAgICAgdmFyIG1heExpZ2h0Q291bnQgPSBhbGxvY2F0ZUxpZ2h0cyggbGlnaHRzICk7XG4gICAgICAgIHZhciBtYXhTaGFkb3dzID0gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKTtcbiAgICAgICAgdmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSByZW5kZXJlci5nZXRQcmVjaXNpb24oKTtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgcHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XG5cbiAgICAgICAgICAgIGlmICggcHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24gKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyLmluaXRNYXRlcmlhbDonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0ge1xuXG4gICAgICAgICAgICBzaGFkZXJJRDogc2hhZGVySUQsXG5cbiAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLFxuXG4gICAgICAgICAgICBtYXA6ICEhbWF0ZXJpYWwubWFwLFxuICAgICAgICAgICAgZW52TWFwOiAhIW1hdGVyaWFsLmVudk1hcCxcbiAgICAgICAgICAgIGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcbiAgICAgICAgICAgIGxpZ2h0TWFwOiAhIW1hdGVyaWFsLmxpZ2h0TWFwLFxuICAgICAgICAgICAgYW9NYXA6ICEhbWF0ZXJpYWwuYW9NYXAsXG4gICAgICAgICAgICBlbWlzc2l2ZU1hcDogISFtYXRlcmlhbC5lbWlzc2l2ZU1hcCxcbiAgICAgICAgICAgIGJ1bXBNYXA6ICEhbWF0ZXJpYWwuYnVtcE1hcCxcbiAgICAgICAgICAgIG5vcm1hbE1hcDogISFtYXRlcmlhbC5ub3JtYWxNYXAsXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRNYXA6ICEhbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuICAgICAgICAgICAgc3BlY3VsYXJNYXA6ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXG4gICAgICAgICAgICBhbHBoYU1hcDogISFtYXRlcmlhbC5hbHBoYU1hcCxcblxuICAgICAgICAgICAgY29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcblxuICAgICAgICAgICAgdmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cbiAgICAgICAgICAgIGZvZzogZm9nLFxuICAgICAgICAgICAgdXNlRm9nOiBtYXRlcmlhbC5mb2csXG4gICAgICAgICAgICBmb2dFeHA6IGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIsXG5cbiAgICAgICAgICAgIGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyxcblxuICAgICAgICAgICAgc2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXG4gICAgICAgICAgICBsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiByZW5kZXJlci5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG4gICAgICAgICAgICBza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcsXG4gICAgICAgICAgICBtYXhCb25lczogbWF4Qm9uZXMsXG4gICAgICAgICAgICB1c2VWZXJ0ZXhUZXh0dXJlOiBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlLFxuXG4gICAgICAgICAgICBtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxuICAgICAgICAgICAgbWF4TW9ycGhUYXJnZXRzOiByZW5kZXJlci5tYXhNb3JwaFRhcmdldHMsXG4gICAgICAgICAgICBtYXhNb3JwaE5vcm1hbHM6IHJlbmRlcmVyLm1heE1vcnBoTm9ybWFscyxcblxuICAgICAgICAgICAgbWF4RGlyTGlnaHRzOiBtYXhMaWdodENvdW50LmRpcmVjdGlvbmFsLFxuICAgICAgICAgICAgbWF4UG9pbnRMaWdodHM6IG1heExpZ2h0Q291bnQucG9pbnQsXG4gICAgICAgICAgICBtYXhTcG90TGlnaHRzOiBtYXhMaWdodENvdW50LnNwb3QsXG4gICAgICAgICAgICBtYXhIZW1pTGlnaHRzOiBtYXhMaWdodENvdW50LmhlbWksXG5cbiAgICAgICAgICAgIG1heFNoYWRvd3M6IG1heFNoYWRvd3MsXG4gICAgICAgICAgICBzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBtYXhTaGFkb3dzID4gMCxcbiAgICAgICAgICAgIHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxuICAgICAgICAgICAgc2hhZG93TWFwRGVidWc6IHJlbmRlcmVyLnNoYWRvd01hcC5kZWJ1ZyxcblxuICAgICAgICAgICAgYWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXG4gICAgICAgICAgICBtZXRhbDogbWF0ZXJpYWwubWV0YWwsXG4gICAgICAgICAgICBkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcbiAgICAgICAgICAgIGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGVcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UHJvZ3JhbUNvZGUgPSBmdW5jdGlvbiggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAgICAgdmFyIGNodW5rcyA9IFtdO1xuXG4gICAgICAgIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcblxuICAgICAgICAgICAgY2h1bmtzLnB1c2goIHBhcmFtZXRlcnMuc2hhZGVySUQgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XG5cbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaCggbmFtZSApO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC5kZWZpbmVzWyBuYW1lIF0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJOYW1lcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lc1sgaSBdO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goIHBhcmFtZXRlck5hbWUgKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzWyBwYXJhbWV0ZXJOYW1lIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNodW5rcy5qb2luKCk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5hY3F1aXJlUHJvZ3JhbSA9IGZ1bmN0aW9uKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApIHtcblxuICAgICAgICB2YXIgcHJvZ3JhbTtcblxuICAgICAgICAvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcbiAgICAgICAgZm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmFtSW5mbyA9IHByb2dyYW1zWyBwIF07XG5cbiAgICAgICAgICAgIGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcblxuICAgICAgICAgICAgICAgIHByb2dyYW0gPSBwcm9ncmFtSW5mbztcbiAgICAgICAgICAgICAgICArK3Byb2dyYW0udXNlZFRpbWVzO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcbiAgICAgICAgICAgIHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG5cbiAgICB9O1xuXG4gICAgdGhpcy5yZWxlYXNlUHJvZ3JhbSA9IGZ1bmN0aW9uKCBwcm9ncmFtICkge1xuXG4gICAgICAgIGlmICggLS1wcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxuICAgICAgICAgICAgdmFyIGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XG4gICAgICAgICAgICBwcm9ncmFtc1sgaSBdID0gcHJvZ3JhbXNbIHByb2dyYW1zLmxlbmd0aCAtIDEgXTtcbiAgICAgICAgICAgIHByb2dyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgICAvLyBGcmVlIFdlYkdMIHJlc291cmNlc1xuICAgICAgICAgICAgcHJvZ3JhbS5kZXN0cm95KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIEV4cG9zZWQgZm9yIHJlc291cmNlIG1vbml0b3JpbmcgJiBlcnJvciBmZWVkYmFjayB2aWEgcmVuZGVyZXIuaW5mbzpcbiAgICB0aGlzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb3BlcnRpZXMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGZvcmRhY2lvdXMgLyBmb3JkYWNpb3VzLmdpdGh1Yi5pb1xuICovXG5cblRIUkVFLldlYkdMUHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICB2YXIgdXVpZCA9IG9iamVjdC51dWlkO1xuICAgICAgICB2YXIgbWFwID0gcHJvcGVydGllc1sgdXVpZCBdO1xuXG4gICAgICAgIGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIG1hcCA9IHt9O1xuICAgICAgICAgICAgcHJvcGVydGllc1sgdXVpZCBdID0gbWFwO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZGVsZXRlID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgICAgICBkZWxldGUgcHJvcGVydGllc1sgb2JqZWN0LnV1aWQgXTtcblxuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgfTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZGVyLmpzXG5cblRIUkVFLldlYkdMU2hhZGVyID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBhZGRMaW5lTnVtYmVycyA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cbiAgICAgICAgdmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICBsaW5lc1sgaSBdID0gKCBpICsgMSApICsgJzogJyArIGxpbmVzWyBpIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBXZWJHTFNoYWRlciggZ2wsIHR5cGUsIHN0cmluZyApIHtcblxuICAgICAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIHN0cmluZyApO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcblxuICAgICAgICBpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tZW5hYmxlLXByaXZpbGVnZWQtd2ViZ2wtZXh0ZW5zaW9uXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcblxuICAgIH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkb3dNYXAuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTFNoYWRvd01hcCA9IGZ1bmN0aW9uKCBfcmVuZGVyZXIsIF9saWdodHMsIF9vYmplY3RzICkge1xuXG4gICAgdmFyIF9nbCA9IF9yZW5kZXJlci5jb250ZXh0LFxuICAgICAgICBfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGUsXG4gICAgICAgIF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcbiAgICAgICAgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG4gICAgICAgIF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgICAgICBfbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICAgIF9yZW5kZXJMaXN0ID0gW107XG5cbiAgICAvLyBpbml0XG5cbiAgICB2YXIgZGVwdGhTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGVwdGhSR0JBXCIgXTtcbiAgICB2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XG5cbiAgICB2YXIgX2RlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICAgICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXJcbiAgICB9ICk7XG5cbiAgICB2YXIgX2RlcHRoTWF0ZXJpYWxNb3JwaCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgICAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICAgICAgbW9ycGhUYXJnZXRzOiB0cnVlXG4gICAgfSApO1xuXG4gICAgdmFyIF9kZXB0aE1hdGVyaWFsU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgICAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICAgICAgc2tpbm5pbmc6IHRydWVcbiAgICB9ICk7XG5cbiAgICB2YXIgX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICAgICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgIG1vcnBoVGFyZ2V0czogdHJ1ZSxcbiAgICAgICAgc2tpbm5pbmc6IHRydWVcbiAgICB9ICk7XG5cbiAgICBfZGVwdGhNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XG4gICAgX2RlcHRoTWF0ZXJpYWxNb3JwaC5fc2hhZG93UGFzcyA9IHRydWU7XG4gICAgX2RlcHRoTWF0ZXJpYWxTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcbiAgICBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XG5cbiAgICAvL1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLnR5cGUgPSBUSFJFRS5QQ0ZTaGFkb3dNYXA7XG4gICAgdGhpcy5jdWxsRmFjZSA9IFRIUkVFLkN1bGxGYWNlRnJvbnQ7XG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCBzY2VuZSwgY2FtZXJhICkge1xuXG4gICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG4gICAgICAgIGlmICggc2NvcGUuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2NvcGUubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwXG5cbiAgICAgICAgX2dsLmNsZWFyQ29sb3IoIDEsIDEsIDEsIDEgKTtcbiAgICAgICAgX3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXG4gICAgICAgIF9zdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcbiAgICAgICAgX2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG4gICAgICAgIGlmICggc2NvcGUuY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cbiAgICAgICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGRlcHRoIG1hcFxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBfbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBsaWdodCA9IF9saWdodHNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCAhbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoICFsaWdodC5zaGFkb3dNYXAgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzY29wZS50eXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyOiBzaGFkb3dGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIG1hZ0ZpbHRlcjogc2hhZG93RmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXRcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbGlnaHQuc2hhZG93TWFwID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCBsaWdodC5zaGFkb3dNYXBXaWR0aCwgbGlnaHQuc2hhZG93TWFwSGVpZ2h0LCBwYXJzICk7XG4gICAgICAgICAgICAgICAgbGlnaHQuc2hhZG93TWFwU2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsaWdodC5zaGFkb3dNYXBXaWR0aCwgbGlnaHQuc2hhZG93TWFwSGVpZ2h0ICk7XG5cbiAgICAgICAgICAgICAgICBsaWdodC5zaGFkb3dNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggIWxpZ2h0LnNoYWRvd0NhbWVyYSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlnaHQuc2hhZG93Q2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBsaWdodC5zaGFkb3dDYW1lcmFGb3YsIGxpZ2h0LnNoYWRvd01hcFdpZHRoIC8gbGlnaHQuc2hhZG93TWFwSGVpZ2h0LCBsaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBsaWdodC5zaGFkb3dDYW1lcmFGYXIgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUxlZnQsIGxpZ2h0LnNoYWRvd0NhbWVyYVJpZ2h0LCBsaWdodC5zaGFkb3dDYW1lcmFUb3AsIGxpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbSwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5TaGFkb3dNYXBQbHVnaW46IFVuc3VwcG9ydGVkIGxpZ2h0IHR5cGUgZm9yIHNoYWRvd1wiLCBsaWdodCApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjZW5lLmFkZCggbGlnaHQuc2hhZG93Q2FtZXJhICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSAmJiAhbGlnaHQuY2FtZXJhSGVscGVyICkge1xuXG4gICAgICAgICAgICAgICAgbGlnaHQuY2FtZXJhSGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggbGlnaHQuc2hhZG93Q2FtZXJhICk7XG4gICAgICAgICAgICAgICAgc2NlbmUuYWRkKCBsaWdodC5jYW1lcmFIZWxwZXIgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2hhZG93TWFwID0gbGlnaHQuc2hhZG93TWFwO1xuICAgICAgICAgICAgdmFyIHNoYWRvd01hdHJpeCA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcbiAgICAgICAgICAgIHZhciBzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmE7XG5cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICBfbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIHNoYWRvd0NhbWVyYS5sb29rQXQoIF9tYXRyaXhQb3NpdGlvbiApO1xuICAgICAgICAgICAgc2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgICAgICAgIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGlmICggbGlnaHQuY2FtZXJhSGVscGVyICkgbGlnaHQuY2FtZXJhSGVscGVyLnZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuICAgICAgICAgICAgaWYgKCBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlICkgbGlnaHQuY2FtZXJhSGVscGVyLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcblxuICAgICAgICAgICAgc2hhZG93TWF0cml4LnNldChcbiAgICAgICAgICAgICAgICAwLjUsIDAuMCwgMC4wLCAwLjUsXG4gICAgICAgICAgICAgICAgMC4wLCAwLjUsIDAuMCwgMC41LFxuICAgICAgICAgICAgICAgIDAuMCwgMC4wLCAwLjUsIDAuNSxcbiAgICAgICAgICAgICAgICAwLjAsIDAuMCwgMC4wLCAxLjBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcbiAgICAgICAgICAgIHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cbiAgICAgICAgICAgIF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgICAgICAgICBfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgICAgICAgICAvLyByZW5kZXIgc2hhZG93IG1hcFxuXG4gICAgICAgICAgICBfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcbiAgICAgICAgICAgIF9yZW5kZXJlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXG5cbiAgICAgICAgICAgIF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHByb2plY3RPYmplY3QoIHNjZW5lLCBzaGFkb3dDYW1lcmEgKTtcblxuXG4gICAgICAgICAgICAvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBfcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IF9yZW5kZXJMaXN0WyBqIF07XG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgbnVsbCwgZ2VvbWV0cnksIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgZ3JvdXBNYXRlcmlhbCApLCBvYmplY3QsIGdyb3VwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBfbGlnaHRzLCBudWxsLCBnZW9tZXRyeSwgZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCApLCBvYmplY3QgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIEdMIHN0YXRlXG5cbiAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxuICAgICAgICAgICAgY2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cbiAgICAgICAgX3JlbmRlcmVyLnNldENsZWFyQ29sb3IoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcbiAgICAgICAgX3N0YXRlLmVuYWJsZSggX2dsLkJMRU5EICk7XG5cbiAgICAgICAgaWYgKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcblxuICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgICAgICAgc2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgICB2YXIgdXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCAmJiBtYXRlcmlhbC5tb3JwaFRhcmdldHM7XG4gICAgICAgIHZhciB1c2VTa2lubmluZyA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xuXG4gICAgICAgIHZhciBkZXB0aE1hdGVyaWFsO1xuXG4gICAgICAgIGlmICggb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCB1c2VTa2lubmluZyApIHtcblxuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbCA9IHVzZU1vcnBoaW5nID8gX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gOiBfZGVwdGhNYXRlcmlhbFNraW47XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdXNlTW9ycGhpbmcgKSB7XG5cbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbE1vcnBoO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgZGVwdGhNYXRlcmlhbC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcbiAgICAgICAgZGVwdGhNYXRlcmlhbC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XG4gICAgICAgIGRlcHRoTWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEgKSB7XG5cbiAgICAgICAgaWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xuXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5jYXN0U2hhZG93ICYmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgICAgICAgICAgX3JlbmRlckxpc3QucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgcHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xTdGF0ZSA9IGZ1bmN0aW9uKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcbiAgICB2YXIgZW5hYmxlZEF0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcblxuICAgIHZhciBjYXBhYmlsaXRpZXMgPSB7fTtcblxuICAgIHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG4gICAgdmFyIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG4gICAgdmFyIGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuICAgIHZhciBjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XG5cbiAgICB2YXIgY3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xuXG4gICAgdmFyIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuXG4gICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xuXG4gICAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcbiAgICB2YXIgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cbiAgICB2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cbiAgICB2YXIgY3VycmVudFRleHR1cmVTbG90ID0gdW5kZWZpbmVkO1xuICAgIHZhciBjdXJyZW50Qm91bmRUZXh0dXJlcyA9IHt9O1xuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZ2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuICAgICAgICBnbC5jbGVhckRlcHRoKCAxICk7XG4gICAgICAgIGdsLmNsZWFyU3RlbmNpbCggMCApO1xuXG4gICAgICAgIHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG4gICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cbiAgICAgICAgZ2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcbiAgICAgICAgZ2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcbiAgICAgICAgdGhpcy5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG4gICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG4gICAgfTtcblxuICAgIHRoaXMuaW5pdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgbmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5lbmFibGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXR0cmlidXRlICkge1xuXG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuICAgICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuICAgICAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XG5cbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcbiAgICAgICAgICAgICAgICBlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uKCBpZCApIHtcblxuICAgICAgICBpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgZ2wuZW5hYmxlKCBpZCApO1xuICAgICAgICAgICAgY2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24oIGlkICkge1xuXG4gICAgICAgIGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgZ2wuZGlzYWJsZSggaWQgKTtcbiAgICAgICAgICAgIGNhcGFiaWxpdGllc1sgaWQgXSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICggY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID09PSBudWxsICkge1xuXG4gICAgICAgICAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0cyA9IGdsLmdldFBhcmFtZXRlciggZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLnB1c2goIGZvcm1hdHNbIGkgXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHM7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRCbGVuZGluZyA9IGZ1bmN0aW9uKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEgKSB7XG5cbiAgICAgICAgaWYgKCBibGVuZGluZyAhPT0gY3VycmVudEJsZW5kaW5nICkge1xuXG4gICAgICAgICAgICBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5Ob0JsZW5kaW5nICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCBnbC5CTEVORCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXG5cbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cblxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xuXG4gICAgICAgICAgICBibGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGEgfHwgYmxlbmRFcXVhdGlvbjtcbiAgICAgICAgICAgIGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xuICAgICAgICAgICAgYmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cbiAgICAgICAgICAgIGlmICggYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICkge1xuXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xuXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjQWxwaGEgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0QWxwaGEgKSApO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kU3JjID0gYmxlbmRTcmM7XG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG4gICAgICAgICAgICBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG4gICAgICAgICAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gICAgICAgICAgICBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0RGVwdGhGdW5jID0gZnVuY3Rpb24oIGRlcHRoRnVuYyApIHtcblxuICAgICAgICBpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcblxuICAgICAgICAgICAgaWYgKCBkZXB0aEZ1bmMgKSB7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5OZXZlckRlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLk5FVkVSICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkFsd2F5c0RlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkFMV0FZUyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5MZXNzRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5MZXNzRXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuRXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5FUVVBTCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuR3JlYXRlckRlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkdSRUFURVIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTm90RXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5OT1RFUVVBTCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0RGVwdGhUZXN0ID0gZnVuY3Rpb24oIGRlcHRoVGVzdCApIHtcblxuICAgICAgICBpZiAoIGRlcHRoVGVzdCApIHtcblxuICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXREZXB0aFdyaXRlID0gZnVuY3Rpb24oIGRlcHRoV3JpdGUgKSB7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50RGVwdGhXcml0ZSAhPT0gZGVwdGhXcml0ZSApIHtcblxuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKCBkZXB0aFdyaXRlICk7XG4gICAgICAgICAgICBjdXJyZW50RGVwdGhXcml0ZSA9IGRlcHRoV3JpdGU7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0Q29sb3JXcml0ZSA9IGZ1bmN0aW9uKCBjb2xvcldyaXRlICkge1xuXG4gICAgICAgIGlmICggY3VycmVudENvbG9yV3JpdGUgIT09IGNvbG9yV3JpdGUgKSB7XG5cbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayggY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSApO1xuICAgICAgICAgICAgY3VycmVudENvbG9yV3JpdGUgPSBjb2xvcldyaXRlO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldEZsaXBTaWRlZCA9IGZ1bmN0aW9uKCBmbGlwU2lkZWQgKSB7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XG5cbiAgICAgICAgICAgIGlmICggZmxpcFNpZGVkICkge1xuXG4gICAgICAgICAgICAgICAgZ2wuZnJvbnRGYWNlKCBnbC5DVyApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRMaW5lV2lkdGggPSBmdW5jdGlvbiggd2lkdGggKSB7XG5cbiAgICAgICAgaWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcblxuICAgICAgICAgICAgZ2wubGluZVdpZHRoKCB3aWR0aCApO1xuXG4gICAgICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gd2lkdGg7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2V0UG9seWdvbk9mZnNldCA9IGZ1bmN0aW9uKCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG4gICAgICAgIGlmICggcG9seWdvbk9mZnNldCApIHtcblxuICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwb2x5Z29uT2Zmc2V0ICYmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApICkge1xuXG4gICAgICAgICAgICBnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xuICAgICAgICAgICAgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24oIHNjaXNzb3JUZXN0ICkge1xuXG4gICAgICAgIGlmICggc2Npc3NvclRlc3QgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyB0ZXh0dXJlXG5cbiAgICB0aGlzLmFjdGl2ZVRleHR1cmUgPSBmdW5jdGlvbiggd2ViZ2xTbG90ICkge1xuXG4gICAgICAgIGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcblxuICAgICAgICBpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xuXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmJpbmRUZXh0dXJlID0gZnVuY3Rpb24oIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICkge1xuXG4gICAgICAgIGlmICggY3VycmVudFRleHR1cmVTbG90ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZVRleHR1cmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcblxuICAgICAgICBpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBib3VuZFRleHR1cmUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXSA9IGJvdW5kVGV4dHVyZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApO1xuXG4gICAgICAgICAgICBib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcbiAgICAgICAgICAgIGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB0aGlzLmNvbXByZXNzZWRUZXhJbWFnZTJEID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuICAgICAgICB9XG4gICAgICAgIGNhdGNoICggZXJyb3IgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMudGV4SW1hZ2UyRCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuICAgICAgICB9XG4gICAgICAgIGNhdGNoICggZXJyb3IgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vXG5cbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuICAgICAgICAgICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhcGFiaWxpdGllcyA9IHt9O1xuXG4gICAgICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cbiAgICAgICAgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcblxuICAgICAgICBjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcblxuICAgICAgICBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblxuICAgIH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL0xlbnNGbGFyZVBsdWdpbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxlbnNGbGFyZVBsdWdpbiA9IGZ1bmN0aW9uKCByZW5kZXJlciwgZmxhcmVzICkge1xuXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICB2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcblxuICAgIHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG4gICAgdmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xuICAgIHZhciBoYXNWZXJ0ZXhUZXh0dXJlO1xuXG4gICAgdmFyIHRlbXBUZXh0dXJlLCBvY2NsdXNpb25UZXh0dXJlO1xuXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIC0xLCAtMSwgMCwgMCxcbiAgICAgICAgICAgIDEsIC0xLCAxLCAwLFxuICAgICAgICAgICAgMSwgMSwgMSwgMSwgLTEsIDEsIDAsIDFcbiAgICAgICAgXSApO1xuXG4gICAgICAgIHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuICAgICAgICAgICAgMCwgMSwgMixcbiAgICAgICAgICAgIDAsIDIsIDNcbiAgICAgICAgXSApO1xuXG4gICAgICAgIC8vIGJ1ZmZlcnNcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgICAgIC8vIHRleHR1cmVzXG5cbiAgICAgICAgdGVtcFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIG9jY2x1c2lvblRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDE2LCAxNiwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cbiAgICAgICAgaGFzVmVydGV4VGV4dHVyZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICkgPiAwO1xuXG4gICAgICAgIHZhciBzaGFkZXI7XG5cbiAgICAgICAgaWYgKCBoYXNWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICAgICAgICBzaGFkZXIgPSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidlVWID0gdXY7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZlYzQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuMSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuOSApICk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIixcblxuICAgICAgICAgICAgICAgICAgICBcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgICAgICAgICAvLyBwaW5rIHNxdWFyZVxuXG4gICAgICAgICAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmVcblxuICAgICAgICAgICAgICAgICAgICBcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXJlXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9IGVsc2Uge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdlZpc2liaWxpdHk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHNoYWRlciA9IHtcblxuICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidlVWID0gdXY7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcIn1cIixcblxuICAgICAgICAgICAgICAgICAgICBcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICAgICAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcGluayBzcXVhcmVcblxuICAgICAgICAgICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblxuICAgICAgICAgICAgICAgICAgICAvLyBmbGFyZVxuXG4gICAgICAgICAgICAgICAgICAgIFwifSBlbHNlIHtcIixcblxuICAgICAgICAgICAgICAgICAgICBcImZsb2F0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApLmE7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApLmE7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApLmE7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApLmE7XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSA9ICggMS4wIC0gdmlzaWJpbGl0eSAvIDQuMCApO1wiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuICAgICAgICAgICAgICAgICAgICBcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdmlzaWJpbGl0eTtcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ9XCJcblxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcblxuICAgICAgICBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgdmVydGV4OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgXCJwb3NpdGlvblwiICksXG4gICAgICAgICAgICB1djogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIFwidXZcIiApXG4gICAgICAgIH07XG5cbiAgICAgICAgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgICByZW5kZXJUeXBlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicmVuZGVyVHlwZVwiICksXG4gICAgICAgICAgICBtYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxuICAgICAgICAgICAgb2NjbHVzaW9uTWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib2NjbHVzaW9uTWFwXCIgKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvcGFjaXR5XCIgKSxcbiAgICAgICAgICAgIGNvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxuICAgICAgICAgICAgc2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY2FsZVwiICksXG4gICAgICAgICAgICByb3RhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJvdGF0aW9uXCIgKSxcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXG4gICAgICAgIH07XG5cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBSZW5kZXIgbGVucyBmbGFyZXNcbiAgICAgKiBNZXRob2Q6IHJlbmRlcnMgMTZ4MTYgMHhmZjAwZmYtY29sb3JlZCBwb2ludHMgc2NhdHRlcmVkIG92ZXIgdGhlIGxpZ2h0IHNvdXJjZSBhcmVhLFxuICAgICAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXG4gICAgICovXG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCApIHtcblxuICAgICAgICBpZiAoIGZsYXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmFyIGludkFzcGVjdCA9IHZpZXdwb3J0SGVpZ2h0IC8gdmlld3BvcnRXaWR0aCxcbiAgICAgICAgICAgIGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAqIDAuNSxcbiAgICAgICAgICAgIGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHZhciBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodCxcbiAgICAgICAgICAgIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcblxuICAgICAgICB2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMCApLFxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gICAgICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuICAgICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XG4gICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuICAgICAgICBzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXG4gICAgICAgIC8vIHNldHVwIGdsIGFuZCBjb21tb24gdXNlZCBhdHRyaWJzL3VuaWZvcm1zXG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5vY2NsdXNpb25NYXAsIDAgKTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnZlcnRleCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuICAgICAgICBzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICAgICAgZ2wuZGVwdGhNYXNrKCBmYWxzZSApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHNpemUgPSAxNiAvIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAgICAgc2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cbiAgICAgICAgICAgIC8vIGNhbGMgb2JqZWN0IHNjcmVlbiBwb3NpdGlvblxuXG4gICAgICAgICAgICB2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcblxuICAgICAgICAgICAgdGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEyIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMyBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTQgXSApO1xuXG4gICAgICAgICAgICB0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgICAgICAgICB0ZW1wUG9zaXRpb24uYXBwbHlQcm9qZWN0aW9uKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgICAgICAgICAvLyBzZXR1cCBhcnJheXMgZm9yIGdsIHByb2dyYW1zXG5cbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xuXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcblxuICAgICAgICAgICAgLy8gc2NyZWVuIGN1bGxcblxuICAgICAgICAgICAgaWYgKCBoYXNWZXJ0ZXhUZXh0dXJlIHx8IChcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54ID4gMCAmJlxuICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPCB2aWV3cG9ydFdpZHRoICYmXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueSA+IDAgJiZcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55IDwgdmlld3BvcnRIZWlnaHQgKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIHNhdmUgY3VycmVudCBSR0IgdG8gdGVtcCB0ZXh0dXJlXG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICAgICAgICAgICAgICBnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSAtIDgsIDE2LCAxNiwgMCApO1xuXG5cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgcGluayBxdWFkXG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDAgKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcbiAgICAgICAgICAgICAgICBnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBncmFwaGljc1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAxICk7XG4gICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9iamVjdCBwb3NpdGlvbnNcblxuICAgICAgICAgICAgICAgIGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrKCBmbGFyZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGZsYXJlLnVwZGF0ZUxlbnNGbGFyZXMoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBmbGFyZXNcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMiApO1xuICAgICAgICAgICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmbGFyZS5sZW5zRmxhcmVzLmxlbmd0aDsgaiA8IGpsOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IGZsYXJlLmxlbnNGbGFyZXNbIGogXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUueSA9IHNpemU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgZ2xcblxuICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcbiAgICAgICAgZ2wuZGVwdGhNYXNrKCB0cnVlICk7XG5cbiAgICAgICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICkge1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblxuICAgICAgICB2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1xcblwiO1xuXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xuXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xuXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcblxuICAgICAgICBnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9TcHJpdGVQbHVnaW4uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcHJpdGVQbHVnaW4gPSBmdW5jdGlvbiggcmVuZGVyZXIsIHNwcml0ZXMgKSB7XG5cbiAgICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuICAgIHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXG4gICAgdmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcbiAgICB2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cbiAgICB2YXIgdGV4dHVyZTtcblxuICAgIC8vIGRlY29tcG9zZSBtYXRyaXhXb3JsZFxuXG4gICAgdmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgIHZhciBzcHJpdGVTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgLTAuNSwgLTAuNSwgMCwgMCxcbiAgICAgICAgICAgIDAuNSwgLTAuNSwgMSwgMCxcbiAgICAgICAgICAgIDAuNSwgMC41LCAxLCAxLCAtMC41LCAwLjUsIDAsIDFcbiAgICAgICAgXSApO1xuXG4gICAgICAgIHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuICAgICAgICAgICAgMCwgMSwgMixcbiAgICAgICAgICAgIDAsIDIsIDNcbiAgICAgICAgXSApO1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuICAgICAgICBnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oKTtcblxuICAgICAgICBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAncG9zaXRpb24nICksXG4gICAgICAgICAgICB1djogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICd1dicgKVxuICAgICAgICB9O1xuXG4gICAgICAgIHVuaWZvcm1zID0ge1xuICAgICAgICAgICAgdXZPZmZzZXQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxuICAgICAgICAgICAgdXZTY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZTY2FsZScgKSxcblxuICAgICAgICAgICAgcm90YXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxuICAgICAgICAgICAgc2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxuXG4gICAgICAgICAgICBjb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXG4gICAgICAgICAgICBtYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ29wYWNpdHknICksXG5cbiAgICAgICAgICAgIG1vZGVsVmlld01hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbW9kZWxWaWV3TWF0cml4JyApLFxuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcblxuICAgICAgICAgICAgZm9nVHlwZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nVHlwZScgKSxcbiAgICAgICAgICAgIGZvZ0RlbnNpdHk6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXG4gICAgICAgICAgICBmb2dOZWFyOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxuICAgICAgICAgICAgZm9nRmFyOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXG4gICAgICAgICAgICBmb2dDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nQ29sb3InICksXG5cbiAgICAgICAgICAgIGFscGhhVGVzdDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnYWxwaGFUZXN0JyApXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSA4O1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XG5cbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBjYW52YXMgKTtcbiAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiggc2NlbmUsIGNhbWVyYSApIHtcblxuICAgICAgICBpZiAoIHNwcml0ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNldHVwIGdsXG5cbiAgICAgICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGluaXQoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcbiAgICAgICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcblxuICAgICAgICB2YXIgb2xkRm9nVHlwZSA9IDA7XG4gICAgICAgIHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xuICAgICAgICB2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG4gICAgICAgIGlmICggZm9nICkge1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cbiAgICAgICAgICAgIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dOZWFyLCBmb2cubmVhciApO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRmFyLCBmb2cuZmFyICk7XG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcbiAgICAgICAgICAgICAgICBvbGRGb2dUeXBlID0gMTtcbiAgICAgICAgICAgICAgICBzY2VuZUZvZ1R5cGUgPSAxO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRGVuc2l0eSwgZm9nLmRlbnNpdHkgKTtcblxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuICAgICAgICAgICAgICAgIG9sZEZvZ1R5cGUgPSAyO1xuICAgICAgICAgICAgICAgIHNjZW5lRm9nVHlwZSA9IDI7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcbiAgICAgICAgICAgIG9sZEZvZ1R5cGUgPSAwO1xuICAgICAgICAgICAgc2NlbmVGb2dUeXBlID0gMDtcblxuICAgICAgICB9XG5cblxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XG5cbiAgICAgICAgICAgIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICBzcHJpdGUueiA9IC1zcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGFsbCBzcHJpdGVzXG5cbiAgICAgICAgdmFyIHNjYWxlID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgICAgICAgc3ByaXRlLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggc3ByaXRlUG9zaXRpb24sIHNwcml0ZVJvdGF0aW9uLCBzcHJpdGVTY2FsZSApO1xuXG4gICAgICAgICAgICBzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcbiAgICAgICAgICAgIHNjYWxlWyAxIF0gPSBzcHJpdGVTY2FsZS55O1xuXG4gICAgICAgICAgICB2YXIgZm9nVHlwZSA9IDA7XG5cbiAgICAgICAgICAgIGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuICAgICAgICAgICAgICAgIGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xuXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCBmb2dUeXBlICk7XG4gICAgICAgICAgICAgICAgb2xkRm9nVHlwZSA9IGZvZ1R5cGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgbWF0ZXJpYWwubWFwLnJlcGVhdC54LCBtYXRlcmlhbC5tYXAucmVwZWF0LnkgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCAwLCAwICk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XG4gICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcblxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcbiAgICAgICAgICAgIHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG4gICAgICAgICAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG5cbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5pbWFnZSAmJiBtYXRlcmlhbC5tYXAuaW1hZ2Uud2lkdGggKSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCBtYXRlcmlhbC5tYXAsIDAgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCB0ZXh0dXJlLCAwICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgZ2xcblxuICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG4gICAgICAgIHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oKSB7XG5cbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXG5cbiAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCByb3RhdGlvbjsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1dlNjYWxlOycsXG5cbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcblxuICAgICAgICAgICAgJ3ZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlOycsXG5cbiAgICAgICAgICAgICd2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7JyxcblxuICAgICAgICAgICAgJ3ZlYzIgcm90YXRlZFBvc2l0aW9uOycsXG4gICAgICAgICAgICAncm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG4gICAgICAgICAgICAncm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG5cbiAgICAgICAgICAgICd2ZWM0IGZpbmFsUG9zaXRpb247JyxcblxuICAgICAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxuICAgICAgICAgICAgJ2ZpbmFsUG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOycsXG4gICAgICAgICAgICAnZmluYWxQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IGZpbmFsUG9zaXRpb247JyxcblxuICAgICAgICAgICAgJ30nXG5cbiAgICAgICAgXS5qb2luKCAnXFxuJyApICk7XG5cbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xuXG4gICAgICAgICAgICAncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxuXG4gICAgICAgICAgICAndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7JyxcblxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VVY7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuXG4gICAgICAgICAgICAndmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXG5cbiAgICAgICAgICAgICdpZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7JyxcblxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxuXG4gICAgICAgICAgICAnaWYgKCBmb2dUeXBlID4gMCApIHsnLFxuXG4gICAgICAgICAgICAnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXG4gICAgICAgICAgICAnZmxvYXQgZm9nRmFjdG9yID0gMC4wOycsXG5cbiAgICAgICAgICAgICdpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxuXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXG5cbiAgICAgICAgICAgICd9IGVsc2UgeycsXG5cbiAgICAgICAgICAgICdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7JyxcbiAgICAgICAgICAgICdmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKTsnLFxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcblxuICAgICAgICAgICAgJ30nLFxuXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxuXG4gICAgICAgICAgICAnfScsXG5cbiAgICAgICAgICAgICd9J1xuXG4gICAgICAgIF0uam9pbiggJ1xcbicgKSApO1xuXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xuXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcblxuICAgICAgICBnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cbiAgICAgICAgaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGIueiAtIGEuejtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gYi5pZCAtIGEuaWQ7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvR2VvbWV0cnlVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR2VvbWV0cnlVdGlscyA9IHtcblxuICAgIG1lcmdlOiBmdW5jdGlvbiggZ2VvbWV0cnkxLCBnZW9tZXRyeTIsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLicgKTtcblxuICAgICAgICB2YXIgbWF0cml4O1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkyIGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuICAgICAgICAgICAgZ2VvbWV0cnkyLm1hdHJpeEF1dG9VcGRhdGUgJiYgZ2VvbWV0cnkyLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICAgICAgICBtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xuICAgICAgICAgICAgZ2VvbWV0cnkyID0gZ2VvbWV0cnkyLmdlb21ldHJ5O1xuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeTEubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICk7XG5cbiAgICB9LFxuXG4gICAgY2VudGVyOiBmdW5jdGlvbiggZ2VvbWV0cnkgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLmNlbnRlcigpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkuY2VudGVyKCkgaW5zdGVhZC4nICk7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeS5jZW50ZXIoKTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL0ltYWdlVXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgRGFvc2hlbmcgTXUgLyBodHRwczovL2dpdGh1Yi5jb20vRGFvc2hlbmdNdS9cbiAqL1xuXG5USFJFRS5JbWFnZVV0aWxzID0ge1xuXG4gICAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuICAgIGxvYWRUZXh0dXJlOiBmdW5jdGlvbiggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuICAgICAgICBsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIHVuZGVmaW5lZCwgbWFwcGluZyApO1xuXG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uKCBpbWFnZSApIHtcblxuICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgICAgIHRleHR1cmUuc291cmNlRmlsZSA9IHVybDtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcblxuICAgIH0sXG5cbiAgICBsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uKCBhcnJheSwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xuXG4gICAgICAgIHZhciBpbWFnZXMgPSBbXTtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG4gICAgICAgIGxvYWRlci5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIGltYWdlcywgbWFwcGluZyApO1xuXG4gICAgICAgIHZhciBsb2FkZWQgPSAwO1xuXG4gICAgICAgIHZhciBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uKCBpICkge1xuXG4gICAgICAgICAgICBsb2FkZXIubG9hZCggYXJyYXlbIGkgXSwgZnVuY3Rpb24oIGltYWdlICkge1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xuXG4gICAgICAgICAgICAgICAgbG9hZGVkICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKytpICkge1xuXG4gICAgICAgICAgICBsb2FkVGV4dHVyZSggaSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcblxuICAgIH0sXG5cbiAgICBsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cbiAgICB9LFxuXG4gICAgbG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cbiAgICB9LFxuXG4gICAgZ2V0Tm9ybWFsTWFwOiBmdW5jdGlvbiggaW1hZ2UsIGRlcHRoICkge1xuXG4gICAgICAgIC8vIEFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9sYWIvaGVpZ2h0bm9ybWFsL1xuXG4gICAgICAgIHZhciBjcm9zcyA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgICAgICByZXR1cm4gWyBhWyAxIF0gKiBiWyAyIF0gLSBhWyAyIF0gKiBiWyAxIF0sIGFbIDIgXSAqIGJbIDAgXSAtIGFbIDAgXSAqIGJbIDIgXSwgYVsgMCBdICogYlsgMSBdIC0gYVsgMSBdICogYlsgMCBdIF07XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3VidHJhY3QgPSBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICAgICAgcmV0dXJuIFsgYVsgMCBdIC0gYlsgMCBdLCBhWyAxIF0gLSBiWyAxIF0sIGFbIDIgXSAtIGJbIDIgXSBdO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCBhICkge1xuXG4gICAgICAgICAgICB2YXIgbCA9IE1hdGguc3FydCggYVsgMCBdICogYVsgMCBdICsgYVsgMSBdICogYVsgMSBdICsgYVsgMiBdICogYVsgMiBdICk7XG4gICAgICAgICAgICByZXR1cm4gWyBhWyAwIF0gLyBsLCBhWyAxIF0gLyBsLCBhWyAyIF0gLyBsIF07XG5cbiAgICAgICAgfTtcblxuICAgICAgICBkZXB0aCA9IGRlcHRoIHwgMTtcblxuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcblxuICAgICAgICB2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICkuZGF0YTtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICAgIHZhciBvdXRwdXQgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBseSA9IHkgLSAxIDwgMCA/IDAgOiB5IC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgdXkgPSB5ICsgMSA+IGhlaWdodCAtIDEgPyBoZWlnaHQgLSAxIDogeSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGx4ID0geCAtIDEgPCAwID8gMCA6IHggLSAxO1xuICAgICAgICAgICAgICAgIHZhciB1eCA9IHggKyAxID4gd2lkdGggLSAxID8gd2lkdGggLSAxIDogeCArIDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IFsgMCwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIC0xLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgLTEsIC0xLCBkYXRhWyAoIGx5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIDAsIC0xLCBkYXRhWyAoIGx5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgMSwgLTEsIGRhdGFbICggbHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIFsgMCwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbIC0xLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtX3BvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1fcG9pbnRzOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gcG9pbnRzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2MiA9IHBvaW50c1sgKCBpICsgMSApICUgbnVtX3BvaW50cyBdO1xuICAgICAgICAgICAgICAgICAgICB2MSA9IHN1YnRyYWN0KCB2MSwgb3JpZ2luICk7XG4gICAgICAgICAgICAgICAgICAgIHYyID0gc3VidHJhY3QoIHYyLCBvcmlnaW4gKTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFscy5wdXNoKCBub3JtYWxpemUoIGNyb3NzKCB2MSwgdjIgKSApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gWyAwLCAwLCAwIF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFsgMCBdICs9IG5vcm1hbHNbIGkgXVsgMCBdO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxbIDEgXSArPSBub3JtYWxzWyBpIF1bIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsWyAyIF0gKz0gbm9ybWFsc1sgaSBdWyAyIF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub3JtYWxbIDAgXSAvPSBub3JtYWxzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBub3JtYWxbIDEgXSAvPSBub3JtYWxzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBub3JtYWxbIDIgXSAvPSBub3JtYWxzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHZhciBpZHggPSAoIHkgKiB3aWR0aCArIHggKSAqIDQ7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXRbIGlkeCBdID0gKCAoIG5vcm1hbFsgMCBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XG4gICAgICAgICAgICAgICAgb3V0cHV0WyBpZHggKyAxIF0gPSAoICggbm9ybWFsWyAxIF0gKyAxLjAgKSAvIDIuMCAqIDI1NSApIHwgMDtcbiAgICAgICAgICAgICAgICBvdXRwdXRbIGlkeCArIDIgXSA9ICggbm9ybWFsWyAyIF0gKiAyNTUgKSB8IDA7XG4gICAgICAgICAgICAgICAgb3V0cHV0WyBpZHggKyAzIF0gPSAyNTU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlRGF0YSwgMCwgMCApO1xuXG4gICAgICAgIHJldHVybiBjYW52YXM7XG5cbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVEYXRhVGV4dHVyZTogZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIGNvbG9yICkge1xuXG4gICAgICAgIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoIDMgKiBzaXplICk7XG5cbiAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCBjb2xvci5yICogMjU1ICk7XG4gICAgICAgIHZhciBnID0gTWF0aC5mbG9vciggY29sb3IuZyAqIDI1NSApO1xuICAgICAgICB2YXIgYiA9IE1hdGguZmxvb3IoIGNvbG9yLmIgKiAyNTUgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGRhdGFbIGkgKiAzIF0gPSByO1xuICAgICAgICAgICAgZGF0YVsgaSAqIDMgKyAxIF0gPSBnO1xuICAgICAgICAgICAgZGF0YVsgaSAqIDMgKyAyIF0gPSBiO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggZGF0YSwgd2lkdGgsIGhlaWdodCwgVEhSRUUuUkdCRm9ybWF0ICk7XG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvU2NlbmVVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU2NlbmVVdGlscyA9IHtcblxuICAgIGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWxzICkge1xuXG4gICAgICAgIHZhciBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cDtcblxuICAgIH0sXG5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcblxuICAgICAgICBjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XG4gICAgICAgIHNjZW5lLmFkZCggY2hpbGQgKTtcblxuICAgIH0sXG5cbiAgICBhdHRhY2g6IGZ1bmN0aW9uKCBjaGlsZCwgc2NlbmUsIHBhcmVudCApIHtcblxuICAgICAgICB2YXIgbWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgbWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgICAgICBjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XG5cbiAgICAgICAgc2NlbmUucmVtb3ZlKCBjaGlsZCApO1xuICAgICAgICBwYXJlbnQuYWRkKCBjaGlsZCApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvRm9udFV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBGb3IgVGV4dCBvcGVyYXRpb25zIGluIHRocmVlLmpzIChTZWUgVGV4dEdlb21ldHJ5KVxuICpcbiAqIEl0IHVzZXMgdGVjaG5pcXVlcyB1c2VkIGluOlxuICpcbiAqXHRUcmlhbmd1bGF0aW9uIHBvcnRlZCBmcm9tIEFTM1xuICpcdFx0U2ltcGxlIFBvbHlnb24gVHJpYW5ndWxhdGlvblxuICpcdFx0aHR0cDovL2FjdGlvbnNuaXBwZXQuY29tLz9wPTE0NjJcbiAqXG4gKiBcdEEgTWV0aG9kIHRvIHRyaWFuZ3VsYXRlIHNoYXBlcyB3aXRoIGhvbGVzXG4gKlx0XHRodHRwOi8vd3d3LnNha3JpLm5ldC9ibG9nLzIwMDkvMDYvMTIvYW4tYXBwcm9hY2gtdG8tdHJpYW5ndWxhdGluZy1wb2x5Z29ucy13aXRoLWhvbGVzL1xuICpcbiAqL1xuXG5USFJFRS5Gb250VXRpbHMgPSB7XG5cbiAgICBmYWNlczoge30sXG5cbiAgICAvLyBKdXN0IGZvciBub3cuIGZhY2Vbd2VpZ2h0XVtzdHlsZV1cblxuICAgIGZhY2U6ICdoZWx2ZXRpa2VyJyxcbiAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICBzaXplOiAxNTAsXG4gICAgZGl2aXNpb25zOiAxMCxcblxuICAgIGdldEZhY2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY2VzWyB0aGlzLmZhY2UudG9Mb3dlckNhc2UoKSBdWyB0aGlzLndlaWdodCBdWyB0aGlzLnN0eWxlIF07XG5cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgIHRocm93IFwiVGhlIGZvbnQgXCIgKyB0aGlzLmZhY2UgKyBcIiB3aXRoIFwiICsgdGhpcy53ZWlnaHQgKyBcIiB3ZWlnaHQgYW5kIFwiICsgdGhpcy5zdHlsZSArIFwiIHN0eWxlIGlzIG1pc3NpbmcuXCJcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbG9hZEZhY2U6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gICAgICAgIHZhciBmYW1pbHkgPSBkYXRhLmZhbWlseU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICB2YXIgVGhyZWVGb250ID0gdGhpcztcblxuICAgICAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXSB8fCB7fTtcblxuICAgICAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdIHx8IHt9O1xuICAgICAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XG5cbiAgICAgICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF1bIGRhdGEuY3NzRm9udFN0eWxlIF0gPSBkYXRhO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfSxcblxuICAgIGRyYXdUZXh0OiBmdW5jdGlvbiggdGV4dCApIHtcblxuICAgICAgICAvLyBSZW5kZXJUZXh0XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBmYWNlID0gdGhpcy5nZXRGYWNlKCksXG4gICAgICAgICAgICBzY2FsZSA9IHRoaXMuc2l6ZSAvIGZhY2UucmVzb2x1dGlvbixcbiAgICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgICBjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApLFxuICAgICAgICAgICAgbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBmb250UGF0aHMgPSBbXTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgcGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLmV4dHJhY3RHbHlwaFBvaW50cyggY2hhcnNbIGkgXSwgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHJldC5vZmZzZXQ7XG5cbiAgICAgICAgICAgIGZvbnRQYXRocy5wdXNoKCByZXQucGF0aCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIHdpZHRoXG5cbiAgICAgICAgdmFyIHdpZHRoID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZm9yICggcCA9IDA7IHAgPCBhbGxQdHMubGVuZ3RoOyBwKysgKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFx0YWxsUHRzWyBwIF0ueCAtPSB3aWR0aDtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vdmFyIGV4dHJhY3QgPSB0aGlzLmV4dHJhY3RQb2ludHMoIGFsbFB0cywgY2hhcmFjdGVyUHRzICk7XG4gICAgICAgIC8vZXh0cmFjdC5jb250b3VyID0gYWxsUHRzO1xuXG4gICAgICAgIC8vZXh0cmFjdC5wYXRocyA9IGZvbnRQYXRocztcbiAgICAgICAgLy9leHRyYWN0Lm9mZnNldCA9IHdpZHRoO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoczogZm9udFBhdGhzLFxuICAgICAgICAgICAgb2Zmc2V0OiB3aWR0aFxuICAgICAgICB9O1xuXG4gICAgfSxcblxuXG5cblxuICAgIGV4dHJhY3RHbHlwaFBvaW50czogZnVuY3Rpb24oIGMsIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKSB7XG5cbiAgICAgICAgdmFyIHB0cyA9IFtdO1xuXG4gICAgICAgIHZhciBpLCBpMiwgZGl2aXNpb25zLFxuICAgICAgICAgICAgb3V0bGluZSwgYWN0aW9uLCBsZW5ndGgsXG4gICAgICAgICAgICBzY2FsZVgsIHNjYWxlWSxcbiAgICAgICAgICAgIHgsIHksIGNweCwgY3B5LCBjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLFxuICAgICAgICAgICAgbGFzdGUsXG4gICAgICAgICAgICBnbHlwaCA9IGZhY2UuZ2x5cGhzWyBjIF0gfHwgZmFjZS5nbHlwaHNbICc/JyBdO1xuXG4gICAgICAgIGlmICggIWdseXBoICkgcmV0dXJuO1xuXG4gICAgICAgIGlmICggZ2x5cGgubyApIHtcblxuICAgICAgICAgICAgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xuICAgICAgICAgICAgbGVuZ3RoID0gb3V0bGluZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlO1xuICAgICAgICAgICAgc2NhbGVZID0gc2NhbGU7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyApIHtcblxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IG91dGxpbmVbIGkrKyBdO1xuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggYWN0aW9uICk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBhY3Rpb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgVG9cblxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLm1vdmVUbyggeCwgeSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmUgVG9cblxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5saW5lVG8oIHgsIHkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWFkcmF0aWNDdXJ2ZVRvXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4LCBjcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGFzdGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHkwID0gbGFzdGUueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkyID0gMSwgZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnM7IGkyIDw9IGRpdmlzaW9uczsgaTIrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3ViaWMgQmV6aWVyIEN1cnZlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHgyID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkyID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgY3B4LCBjcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGFzdGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHkwID0gbGFzdGUueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkyID0gMSwgZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnM7IGkyIDw9IGRpdmlzaW9uczsgaTIrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9mZnNldDogZ2x5cGguaGEgKiBzY2FsZSxcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfTtcblxuICAgIH1cblxufTtcblxuXG5USFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMgPSBmdW5jdGlvbiggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuICAgIC8vIFBhcmFtZXRlcnNcblxuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgdmFyIHNpemUgPSBwYXJhbWV0ZXJzLnNpemUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc2l6ZSA6IDEwMDtcbiAgICB2YXIgY3VydmVTZWdtZW50cyA9IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzIDogNDtcblxuICAgIHZhciBmb250ID0gcGFyYW1ldGVycy5mb250ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvbnQgOiAnaGVsdmV0aWtlcic7XG4gICAgdmFyIHdlaWdodCA9IHBhcmFtZXRlcnMud2VpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndlaWdodCA6ICdub3JtYWwnO1xuICAgIHZhciBzdHlsZSA9IHBhcmFtZXRlcnMuc3R5bGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3R5bGUgOiAnbm9ybWFsJztcblxuICAgIFRIUkVFLkZvbnRVdGlscy5zaXplID0gc2l6ZTtcbiAgICBUSFJFRS5Gb250VXRpbHMuZGl2aXNpb25zID0gY3VydmVTZWdtZW50cztcblxuICAgIFRIUkVFLkZvbnRVdGlscy5mYWNlID0gZm9udDtcbiAgICBUSFJFRS5Gb250VXRpbHMud2VpZ2h0ID0gd2VpZ2h0O1xuICAgIFRIUkVFLkZvbnRVdGlscy5zdHlsZSA9IHN0eWxlO1xuXG4gICAgLy8gR2V0IGEgRm9udCBkYXRhIGpzb24gb2JqZWN0XG5cbiAgICB2YXIgZGF0YSA9IFRIUkVFLkZvbnRVdGlscy5kcmF3VGV4dCggdGV4dCApO1xuXG4gICAgdmFyIHBhdGhzID0gZGF0YS5wYXRocztcbiAgICB2YXIgc2hhcGVzID0gW107XG5cbiAgICBmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHArKyApIHtcblxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggc2hhcGVzLCBwYXRoc1sgcCBdLnRvU2hhcGVzKCkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBzaGFwZXM7XG5cbn07XG5cblxuLyoqXG4gKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xuICogZmxpcGNvZGUuY29tIGJ5IEpvaG4gVy4gUmF0Y2xpZmYgIC8vIEp1bHkgMjIsIDIwMDBcbiAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XG4gKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXG4gKlxuICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcbiAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxuICpcbiAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cbiAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKi9cblxuXG4oIGZ1bmN0aW9uKCBuYW1lc3BhY2UgKSB7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgIC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcblxuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24oIGNvbnRvdXIsIGluZGljZXMgKSB7XG5cbiAgICAgICAgdmFyIG4gPSBjb250b3VyLmxlbmd0aDtcblxuICAgICAgICBpZiAoIG4gPCAzICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdmVydHMgPSBbXSxcbiAgICAgICAgICAgIHZlcnRJbmRpY2VzID0gW107XG5cbiAgICAgICAgLyogd2Ugd2FudCBhIGNvdW50ZXItY2xvY2t3aXNlIHBvbHlnb24gaW4gdmVydHMgKi9cblxuICAgICAgICB2YXIgdSwgdiwgdztcblxuICAgICAgICBpZiAoIGFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcblxuICAgICAgICAgICAgZm9yICggdiA9IDA7IHYgPCBuOyB2KysgKSB2ZXJ0c1sgdiBdID0gdjtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBmb3IgKCB2ID0gMDsgdiA8IG47IHYrKyApIHZlcnRzWyB2IF0gPSAoIG4gLSAxICkgLSB2O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnYgPSBuO1xuXG4gICAgICAgIC8qICByZW1vdmUgbnYgLSAyIHZlcnRpY2VzLCBjcmVhdGluZyAxIHRyaWFuZ2xlIGV2ZXJ5IHRpbWUgKi9cblxuICAgICAgICB2YXIgY291bnQgPSAyICogbnY7IC8qIGVycm9yIGRldGVjdGlvbiAqL1xuXG4gICAgICAgIGZvciAoIHYgPSBudiAtIDE7IG52ID4gMjsgKSB7XG5cbiAgICAgICAgICAgIC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXG5cbiAgICAgICAgICAgIGlmICggKCBjb3VudC0tICkgPD0gMCApIHtcblxuICAgICAgICAgICAgICAgIC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXG5cbiAgICAgICAgICAgICAgICAvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIHdhcm5pbmcgaXMgZmluZSwgZXNwZWNpYWxseSBwb2x5Z29ucyBhcmUgdHJpYW5ndWxhdGVkIGluIHJldmVyc2UuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRm9udFV0aWxzOiBXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiEgaW4gVHJpYW5ndWxhdGUucHJvY2VzcygpJyApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXG5cbiAgICAgICAgICAgIHUgPSB2O1xuICAgICAgICAgICAgaWYgKCBudiA8PSB1ICkgdSA9IDA7IC8qIHByZXZpb3VzICovXG4gICAgICAgICAgICB2ID0gdSArIDE7XG4gICAgICAgICAgICBpZiAoIG52IDw9IHYgKSB2ID0gMDsgLyogbmV3IHYgICAgKi9cbiAgICAgICAgICAgIHcgPSB2ICsgMTtcbiAgICAgICAgICAgIGlmICggbnYgPD0gdyApIHcgPSAwOyAvKiBuZXh0ICAgICAqL1xuXG4gICAgICAgICAgICBpZiAoIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG52LCB2ZXJ0cyApICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGEsIGIsIGMsIHMsIHQ7XG5cbiAgICAgICAgICAgICAgICAvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG4gICAgICAgICAgICAgICAgYSA9IHZlcnRzWyB1IF07XG4gICAgICAgICAgICAgICAgYiA9IHZlcnRzWyB2IF07XG4gICAgICAgICAgICAgICAgYyA9IHZlcnRzWyB3IF07XG5cbiAgICAgICAgICAgICAgICAvKiBvdXRwdXQgVHJpYW5nbGUgKi9cblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCBbIGNvbnRvdXJbIGEgXSxcbiAgICAgICAgICAgICAgICAgICAgY29udG91clsgYiBdLFxuICAgICAgICAgICAgICAgICAgICBjb250b3VyWyBjIF1cbiAgICAgICAgICAgICAgICBdICk7XG5cblxuICAgICAgICAgICAgICAgIHZlcnRJbmRpY2VzLnB1c2goIFsgdmVydHNbIHUgXSwgdmVydHNbIHYgXSwgdmVydHNbIHcgXSBdICk7XG5cbiAgICAgICAgICAgICAgICAvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG4gICAgICAgICAgICAgICAgZm9yICggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzKyssIHQrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG52LS07XG5cbiAgICAgICAgICAgICAgICAvKiByZXNldCBlcnJvciBkZXRlY3Rpb24gY291bnRlciAqL1xuXG4gICAgICAgICAgICAgICAgY291bnQgPSAyICogbnY7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfTtcblxuICAgIC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cblxuICAgIHZhciBhcmVhID0gZnVuY3Rpb24oIGNvbnRvdXIgKSB7XG5cbiAgICAgICAgdmFyIG4gPSBjb250b3VyLmxlbmd0aDtcbiAgICAgICAgdmFyIGEgPSAwLjA7XG5cbiAgICAgICAgZm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSsrICkge1xuXG4gICAgICAgICAgICBhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSAqIDAuNTtcblxuICAgIH07XG5cbiAgICB2YXIgc25pcCA9IGZ1bmN0aW9uKCBjb250b3VyLCB1LCB2LCB3LCBuLCB2ZXJ0cyApIHtcblxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdmFyIGF4LCBheSwgYngsIGJ5O1xuICAgICAgICB2YXIgY3gsIGN5LCBweCwgcHk7XG5cbiAgICAgICAgYXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcbiAgICAgICAgYXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuICAgICAgICBieCA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS54O1xuICAgICAgICBieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xuXG4gICAgICAgIGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG4gICAgICAgIGN5ID0gY29udG91clsgdmVydHNbIHcgXSBdLnk7XG5cbiAgICAgICAgaWYgKCBFUFNJTE9OID4gKCAoICggYnggLSBheCApICogKCBjeSAtIGF5ICkgKSAtICggKCBieSAtIGF5ICkgKiAoIGN4IC0gYXggKSApICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGFYLCBhWSwgYlgsIGJZLCBjWCwgY1k7XG4gICAgICAgIHZhciBhcHgsIGFweSwgYnB4LCBicHksIGNweCwgY3B5O1xuICAgICAgICB2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcblxuICAgICAgICBhWCA9IGN4IC0gYng7XG4gICAgICAgIGFZID0gY3kgLSBieTtcbiAgICAgICAgYlggPSBheCAtIGN4O1xuICAgICAgICBiWSA9IGF5IC0gY3k7XG4gICAgICAgIGNYID0gYnggLSBheDtcbiAgICAgICAgY1kgPSBieSAtIGF5O1xuXG4gICAgICAgIGZvciAoIHAgPSAwOyBwIDwgbjsgcCsrICkge1xuXG4gICAgICAgICAgICBweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54O1xuICAgICAgICAgICAgcHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcblxuICAgICAgICAgICAgaWYgKCAoICggcHggPT09IGF4ICkgJiYgKCBweSA9PT0gYXkgKSApIHx8XG4gICAgICAgICAgICAgICAgKCAoIHB4ID09PSBieCApICYmICggcHkgPT09IGJ5ICkgKSB8fFxuICAgICAgICAgICAgICAgICggKCBweCA9PT0gY3ggKSAmJiAoIHB5ID09PSBjeSApICkgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgYXB4ID0gcHggLSBheDtcbiAgICAgICAgICAgIGFweSA9IHB5IC0gYXk7XG4gICAgICAgICAgICBicHggPSBweCAtIGJ4O1xuICAgICAgICAgICAgYnB5ID0gcHkgLSBieTtcbiAgICAgICAgICAgIGNweCA9IHB4IC0gY3g7XG4gICAgICAgICAgICBjcHkgPSBweSAtIGN5O1xuXG4gICAgICAgICAgICAvLyBzZWUgaWYgcCBpcyBpbnNpZGUgdHJpYW5nbGUgYWJjXG5cbiAgICAgICAgICAgIGFDUk9TU2JwID0gYVggKiBicHkgLSBhWSAqIGJweDtcbiAgICAgICAgICAgIGNDUk9TU2FwID0gY1ggKiBhcHkgLSBjWSAqIGFweDtcbiAgICAgICAgICAgIGJDUk9TU2NwID0gYlggKiBjcHkgLSBiWSAqIGNweDtcblxuICAgICAgICAgICAgaWYgKCAoIGFDUk9TU2JwID49IC1FUFNJTE9OICkgJiYgKCBiQ1JPU1NjcCA+PSAtRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLUVQU0lMT04gKSApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9O1xuXG5cbiAgICBuYW1lc3BhY2UuVHJpYW5ndWxhdGUgPSBwcm9jZXNzO1xuICAgIG5hbWVzcGFjZS5Ucmlhbmd1bGF0ZS5hcmVhID0gYXJlYTtcblxuICAgIHJldHVybiBuYW1lc3BhY2U7XG5cbn0gKSggVEhSRUUuRm9udFV0aWxzICk7XG5cbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXG5cblRIUkVFLnR5cGVmYWNlX2pzID0ge1xuICAgIGZhY2VzOiBUSFJFRS5Gb250VXRpbHMuZmFjZXMsXG4gICAgbG9hZEZhY2U6IFRIUkVFLkZvbnRVdGlscy5sb2FkRmFjZVxufTtcbmlmICggdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICkgc2VsZi5fdHlwZWZhY2VfanMgPSBUSFJFRS50eXBlZmFjZV9qcztcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2F1ZGlvL0F1ZGlvLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BdWRpbyA9IGZ1bmN0aW9uKCBsaXN0ZW5lciApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBsaXN0ZW5lci5jb250ZXh0O1xuICAgIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgIHRoaXMuc291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCggdGhpcyApO1xuXG4gICAgdGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cbiAgICB0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcbiAgICB0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcblxuICAgIHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpbztcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiggZmlsZSApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbiggJ0dFVCcsIGZpbGUsIHRydWUgKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiggZSApIHtcblxuICAgICAgICBzY29wZS5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggdGhpcy5yZXNwb25zZSwgZnVuY3Rpb24oIGJ1ZmZlciApIHtcblxuICAgICAgICAgICAgc2NvcGUuc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5hdXRvcGxheSApIHNjb3BlLnBsYXkoKTtcblxuICAgICAgICB9ICk7XG5cbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuJyApO1xuICAgICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXG4gICAgc291cmNlLmJ1ZmZlciA9IHRoaXMuc291cmNlLmJ1ZmZlcjtcbiAgICBzb3VyY2UubG9vcCA9IHRoaXMuc291cmNlLmxvb3A7XG4gICAgc291cmNlLm9uZW5kZWQgPSB0aGlzLnNvdXJjZS5vbmVuZGVkO1xuICAgIHNvdXJjZS5zdGFydCggMCwgdGhpcy5zdGFydFRpbWUgKTtcbiAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIHRoaXMuY29ubmVjdCgpO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuc291cmNlLnN0b3AoKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuc291cmNlLnN0b3AoKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoIHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcbiAgICAgICAgdGhpcy5maWx0ZXIuY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLnBhbm5lciApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCB0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG4gICAgICAgIHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHRoaXMuZmlsdGVyID0gdmFsdWU7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB0aGlzLmZpbHRlcjtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgIHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgICAgIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5vbkVuZGVkID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuc291cmNlLmxvb3AgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldExvb3AgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB0aGlzLnNvdXJjZS5sb29wO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UmVmRGlzdGFuY2UgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0UmVmRGlzdGFuY2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG4gICAgICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG4gICAgICAgIHBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHRoaXMucGFubmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cbiAgICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2F1ZGlvL0F1ZGlvTGlzdGVuZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcblxuICAgIHRoaXMuY29udGV4dCA9IG5ldyggd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0ICkoKTtcblxufTtcblxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXVkaW9MaXN0ZW5lcjtcblxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciBvcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG4gICAgICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcbiAgICAgICAgdmFyIHVwID0gdGhpcy51cDtcblxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICk7XG5cbiAgICAgICAgb3JpZW50YXRpb24uc2V0KCAwLCAwLCAtMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgICAgIGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG4gICAgICAgIGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCB1cC54LCB1cC55LCB1cC56ICk7XG5cbiAgICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxuICpcbiAqIFNvbWUgY29tbW9uIG9mIEN1cnZlIG1ldGhvZHNcbiAqIC5nZXRQb2ludCh0KSwgZ2V0VGFuZ2VudCh0KVxuICogLmdldFBvaW50QXQodSksIGdldFRhZ2VudEF0KHUpXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY2xhc3NlcyBzdWJjbGFzc2VzIFRIUkVFLkN1cnZlOlxuICpcbiAqIC0tIDJkIGNsYXNzZXMgLS1cbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKiBUSFJFRS5BcmNDdXJ2ZVxuICogVEhSRUUuRWxsaXBzZUN1cnZlXG4gKlxuICogLS0gM2QgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuU3BsaW5lQ3VydmUzXG4gKiBUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTNcbiAqXG4gKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlID0gZnVuY3Rpb24oKSB7XG5cbn07XG5cbi8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuLy9cdC0gdCBbMCAuLiAxXVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcbiAgICByZXR1cm4gbnVsbDtcblxufTtcblxuLy8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG4vLyAtIHUgWzAgLi4gMV1cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiggdSApIHtcblxuICAgIHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50KCB0ICk7XG5cbn07XG5cbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cbiAgICB2YXIgZCwgcHRzID0gW107XG5cbiAgICBmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQrKyApIHtcblxuICAgICAgICBwdHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcHRzO1xuXG59O1xuXG4vLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cbiAgICB2YXIgZCwgcHRzID0gW107XG5cbiAgICBmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQrKyApIHtcblxuICAgICAgICBwdHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG4gICAgcmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG59O1xuXG4vLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RocyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA/ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApIDogMjAwO1xuXG4gICAgaWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3RocyAmJiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSApICYmICF0aGlzLm5lZWRzVXBkYXRlICkge1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuICAgIH1cblxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBjYWNoZSA9IFtdO1xuICAgIHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuICAgIHZhciBwLCBzdW0gPSAwO1xuXG4gICAgY2FjaGUucHVzaCggMCApO1xuXG4gICAgZm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwKysgKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0UG9pbnQoIHAgLyBkaXZpc2lvbnMgKTtcbiAgICAgICAgc3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuICAgICAgICBjYWNoZS5wdXNoKCBzdW0gKTtcbiAgICAgICAgbGFzdCA9IGN1cnJlbnQ7XG5cbiAgICB9XG5cbiAgICB0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG4gICAgcmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06c3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG59O1xuXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS51cGRhdGVBcmNMZW5ndGhzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmdldExlbmd0aHMoKTtcblxufTtcblxuLy8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VXRvVG1hcHBpbmcgPSBmdW5jdGlvbiggdSwgZGlzdGFuY2UgKSB7XG5cbiAgICB2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuXG4gICAgdmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XG5cbiAgICBpZiAoIGRpc3RhbmNlICkge1xuXG4gICAgICAgIHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcblxuICAgIH1cblxuICAgIC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuICAgIHZhciBsb3cgPSAwLFxuICAgICAgICBoaWdoID0gaWwgLSAxLFxuICAgICAgICBjb21wYXJpc29uO1xuXG4gICAgd2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcblxuICAgICAgICBpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuICAgICAgICBjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xuXG4gICAgICAgIGlmICggY29tcGFyaXNvbiA8IDAgKSB7XG5cbiAgICAgICAgICAgIGxvdyA9IGkgKyAxO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xuXG4gICAgICAgICAgICBoaWdoID0gaSAtIDE7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgaGlnaCA9IGk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gRE9ORVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGkgPSBoaWdoO1xuXG4gICAgLy9jb25zb2xlLmxvZygnYicgLCBpLCBsb3csIGhpZ2gsIERhdGUubm93KCktIHRpbWUpO1xuXG4gICAgaWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuICAgICAgICB2YXIgdCA9IGkgLyAoIGlsIC0gMSApO1xuICAgICAgICByZXR1cm4gdDtcblxuICAgIH1cblxuICAgIC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cbiAgICB2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xuICAgIHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XG5cbiAgICB2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcblxuICAgIHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcblxuICAgIC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcblxuICAgIHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xuXG4gICAgcmV0dXJuIHQ7XG5cbn07XG5cbi8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcbi8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcbi8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XG4vLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgZGVsdGEgPSAwLjAwMDE7XG4gICAgdmFyIHQxID0gdCAtIGRlbHRhO1xuICAgIHZhciB0MiA9IHQgKyBkZWx0YTtcblxuICAgIC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcblxuICAgIGlmICggdDEgPCAwICkgdDEgPSAwO1xuICAgIGlmICggdDIgPiAxICkgdDIgPSAxO1xuXG4gICAgdmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XG4gICAgdmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cbiAgICB2YXIgdmVjID0gcHQyLmNsb25lKCkuc3ViKCBwdDEgKTtcbiAgICByZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50QXQgPSBmdW5jdGlvbiggdSApIHtcblxuICAgIHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuICAgIHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcblxufTtcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZS5VdGlscyA9IHtcblxuICAgIHRhbmdlbnRRdWFkcmF0aWNCZXppZXI6IGZ1bmN0aW9uKCB0LCBwMCwgcDEsIHAyICkge1xuXG4gICAgICAgIHJldHVybiAyICogKCAxIC0gdCApICogKCBwMSAtIHAwICkgKyAyICogdCAqICggcDIgLSBwMSApO1xuXG4gICAgfSxcblxuICAgIC8vIFB1YXkgQmluZywgdGhhbmtzIGZvciBoZWxwaW5nIHdpdGggdGhpcyBkZXJpdmF0aXZlIVxuXG4gICAgdGFuZ2VudEN1YmljQmV6aWVyOiBmdW5jdGlvbiggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cbiAgICAgICAgcmV0dXJuIC0zICogcDAgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgK1xuICAgICAgICAgICAgMyAqIHAxICogKCAxIC0gdCApICogKCAxIC0gdCApIC0gNiAqIHQgKiBwMSAqICggMSAtIHQgKSArXG4gICAgICAgICAgICA2ICogdCAqIHAyICogKCAxIC0gdCApIC0gMyAqIHQgKiB0ICogcDIgK1xuICAgICAgICAgICAgMyAqIHQgKiB0ICogcDM7XG5cbiAgICB9LFxuXG4gICAgdGFuZ2VudFNwbGluZTogZnVuY3Rpb24oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgICAgIC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XG5cbiAgICAgICAgdmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyAvLyBkZXJpdmVkIGZyb20gMnReMyDiiJIgM3ReMiArIDFcbiAgICAgICAgdmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxuICAgICAgICB2YXIgaDAxID0gLTYgKiB0ICogdCArIDYgKiB0OyAvLyDiiJIgMnQzICsgM3QyXG4gICAgICAgIHZhciBoMTEgPSAzICogdCAqIHQgLSAyICogdDsgLy8gdDMg4oiSIHQyXG5cbiAgICAgICAgcmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcblxuICAgIH0sXG5cbiAgICAvLyBDYXRtdWxsLVJvbVxuXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcblxuICAgICAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG4gICAgICAgIHZhciB0MiA9IHQgKiB0O1xuICAgICAgICB2YXIgdDMgPSB0ICogdDI7XG4gICAgICAgIHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgICB9XG5cbn07XG5cblxuLy8gVE9ETzogVHJhbnNmb3JtYXRpb24gZm9yIEN1cnZlcz9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0M0QgQ3VydmVzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEEgRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBjdXJ2ZSBzdWJjbGFzc2VzXG5cblRIUkVFLkN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uKCBjb25zdHJ1Y3RvciwgZ2V0UG9pbnRGdW5jICkge1xuXG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlLmdldFBvaW50ID0gZ2V0UG9pbnRGdW5jO1xuXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZVBhdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZVBhdGggPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuY3VydmVzID0gW107XG4gICAgdGhpcy5iZW5kcyA9IFtdO1xuXG4gICAgdGhpcy5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1cnZlUGF0aDtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiggY3VydmUgKSB7XG5cbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE9cbiAgICAvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXG4gICAgLy8gb3IgdGhlIG5leHQgY3VydmUsIHRoZW4sIHRoaXMgaXMgbm90IGEgcmVhbCBwYXRoXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gVE9ETyBUZXN0XG4gICAgLy8gYW5kIHZlcmlmeSBmb3IgdmVjdG9yMyAobmVlZHMgdG8gaW1wbGVtZW50IGVxdWFscylcbiAgICAvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcbiAgICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcbiAgICB2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1sgdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMSBdLmdldFBvaW50KCAxICk7XG5cbiAgICBpZiAoICFzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcblxuICAgICAgICB0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuLy8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuLy8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxuXG4vLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG4vLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcbi8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcbi8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xuICAgIHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgZGlmZiwgY3VydmU7XG5cbiAgICAvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuICAgIHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XG5cbiAgICAgICAgaWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG4gICAgICAgICAgICBkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xuICAgICAgICAgICAgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXG4gICAgICAgICAgICB2YXIgdSA9IDEgLSBkaWZmIC8gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcblxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuXG4gICAgLy8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG5cbn07XG5cbi8qXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcbn07Ki9cblxuXG4vLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG4vLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcbi8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcbiAgICByZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuICAgIC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuICAgIGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xuXG4gICAgfVxuXG4gICAgLy8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcbiAgICAvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcblxuICAgIHZhciBsZW5ndGhzID0gW10sXG4gICAgICAgIHN1bXMgPSAwO1xuICAgIHZhciBpLCBpbCA9IHRoaXMuY3VydmVzLmxlbmd0aDtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XG4gICAgICAgIGxlbmd0aHMucHVzaCggc3VtcyApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG4gICAgcmV0dXJuIGxlbmd0aHM7XG5cbn07XG5cblxuXG4vLyBSZXR1cm5zIG1pbiBhbmQgbWF4IGNvb3JkaW5hdGVzXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xuXG4gICAgdmFyIG1heFgsIG1heFksIG1heFo7XG4gICAgdmFyIG1pblgsIG1pblksIG1pblo7XG5cbiAgICBtYXhYID0gbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBtaW5YID0gbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIHZhciBwLCBpLCBpbCwgc3VtO1xuXG4gICAgdmFyIHYzID0gcG9pbnRzWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzO1xuXG4gICAgc3VtID0gdjMgPyBuZXcgVEhSRUUuVmVjdG9yMygpIDogbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHAgPSBwb2ludHNbIGkgXTtcblxuICAgICAgICBpZiAoIHAueCA+IG1heFggKSBtYXhYID0gcC54O1xuICAgICAgICBlbHNlIGlmICggcC54IDwgbWluWCApIG1pblggPSBwLng7XG5cbiAgICAgICAgaWYgKCBwLnkgPiBtYXhZICkgbWF4WSA9IHAueTtcbiAgICAgICAgZWxzZSBpZiAoIHAueSA8IG1pblkgKSBtaW5ZID0gcC55O1xuXG4gICAgICAgIGlmICggdjMgKSB7XG5cbiAgICAgICAgICAgIGlmICggcC56ID4gbWF4WiApIG1heFogPSBwLno7XG4gICAgICAgICAgICBlbHNlIGlmICggcC56IDwgbWluWiApIG1pblogPSBwLno7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN1bS5hZGQoIHAgKTtcblxuICAgIH1cblxuICAgIHZhciByZXQgPSB7XG5cbiAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgbWF4WTogbWF4WVxuXG4gICAgfTtcblxuICAgIGlmICggdjMgKSB7XG5cbiAgICAgICAgcmV0Lm1heFogPSBtYXhaO1xuICAgICAgICByZXQubWluWiA9IG1pblo7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICB2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxufTtcblxuLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBvaW50cyApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBwb2ludHNbIGkgXS54LCBwb2ludHNbIGkgXS55LCBwb2ludHNbIGkgXS56IHx8IDAgKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEJlbmQgLyBXcmFwIEhlbHBlciBNZXRob2RzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIFdyYXAgcGF0aCAvIEJlbmQgbW9kaWZpZXJzP1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZFdyYXBQYXRoID0gZnVuY3Rpb24oIGJlbmRwYXRoICkge1xuXG4gICAgdGhpcy5iZW5kcy5wdXNoKCBiZW5kcGF0aCApO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnRzID0gZnVuY3Rpb24oIHNlZ21lbnRzLCBiZW5kcyApIHtcblxuICAgIHZhciBvbGRQdHMgPSB0aGlzLmdldFBvaW50cyggc2VnbWVudHMgKTsgLy8gZ2V0UG9pbnRzIGdldFNwYWNlZFBvaW50c1xuICAgIHZhciBpLCBpbDtcblxuICAgIGlmICggIWJlbmRzICkge1xuXG4gICAgICAgIGJlbmRzID0gdGhpcy5iZW5kcztcblxuICAgIH1cblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgb2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvbGRQdHM7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiggc2VnbWVudHMsIGJlbmRzICkge1xuXG4gICAgdmFyIG9sZFB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBzZWdtZW50cyApO1xuXG4gICAgdmFyIGksIGlsO1xuXG4gICAgaWYgKCAhYmVuZHMgKSB7XG5cbiAgICAgICAgYmVuZHMgPSB0aGlzLmJlbmRzO1xuXG4gICAgfVxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gYmVuZHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBvbGRQdHMgPSB0aGlzLmdldFdyYXBQb2ludHMoIG9sZFB0cywgYmVuZHNbIGkgXSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gVGhpcyByZXR1cm5zIGdldFBvaW50cygpIGJlbmQvd3JhcHBlZCBhcm91bmQgdGhlIGNvbnRvdXIgb2YgYSBwYXRoLlxuLy8gUmVhZCBodHRwOi8vd3d3LnBsYW5ldGNsZWdnLmNvbS9wcm9qZWN0cy9XYXJwaW5nVGV4dFRvU3BsaW5lcy5odG1sXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cyA9IGZ1bmN0aW9uKCBvbGRQdHMsIHBhdGggKSB7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZLCB4Tm9ybTtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IG9sZFB0cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHAgPSBvbGRQdHNbIGkgXTtcblxuICAgICAgICBvbGRYID0gcC54O1xuICAgICAgICBvbGRZID0gcC55O1xuXG4gICAgICAgIHhOb3JtID0gb2xkWCAvIGJvdW5kcy5tYXhYO1xuXG4gICAgICAgIC8vIElmIHVzaW5nIGFjdHVhbCBkaXN0YW5jZSwgZm9yIGxlbmd0aCA+IHBhdGgsIHJlcXVpcmVzIGxpbmUgZXh0cnVzaW9uc1xuICAgICAgICAvL3hOb3JtID0gcGF0aC5nZXRVdG9UbWFwcGluZyh4Tm9ybSwgb2xkWCk7IC8vIDMgc3R5bGVzLiAxKSB3cmFwIHN0cmV0Y2hlZC4gMikgd3JhcCBzdHJldGNoIGJ5IGFyYyBsZW5ndGggMykgd2FycCBieSBhY3R1YWwgZGlzdGFuY2VcblxuICAgICAgICB4Tm9ybSA9IHBhdGguZ2V0VXRvVG1hcHBpbmcoIHhOb3JtLCBvbGRYICk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG5cbiAgICAgICAgdmFyIHBhdGhQdCA9IHBhdGguZ2V0UG9pbnQoIHhOb3JtICk7XG4gICAgICAgIHZhciBub3JtYWwgPSBwYXRoLmdldFRhbmdlbnQoIHhOb3JtICk7XG4gICAgICAgIG5vcm1hbC5zZXQoIC1ub3JtYWwueSwgbm9ybWFsLnggKS5tdWx0aXBseVNjYWxhciggb2xkWSApO1xuXG4gICAgICAgIHAueCA9IHBhdGhQdC54ICsgbm9ybWFsLng7XG4gICAgICAgIHAueSA9IHBhdGhQdC55ICsgbm9ybWFsLnk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2xkUHRzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9QYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXG4gKlxuICoqL1xuXG5USFJFRS5QYXRoID0gZnVuY3Rpb24oIHBvaW50cyApIHtcblxuICAgIFRIUkVFLkN1cnZlUGF0aC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLmFjdGlvbnMgPSBbXTtcblxuICAgIGlmICggcG9pbnRzICkge1xuXG4gICAgICAgIHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSApO1xuVEhSRUUuUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXRoO1xuXG5USFJFRS5QYXRoQWN0aW9ucyA9IHtcblxuICAgIE1PVkVfVE86ICdtb3ZlVG8nLFxuICAgIExJTkVfVE86ICdsaW5lVG8nLFxuICAgIFFVQURSQVRJQ19DVVJWRV9UTzogJ3F1YWRyYXRpY0N1cnZlVG8nLCAvLyBCZXppZXIgcXVhZHJhdGljIGN1cnZlXG4gICAgQkVaSUVSX0NVUlZFX1RPOiAnYmV6aWVyQ3VydmVUbycsIC8vIEJlemllciBjdWJpYyBjdXJ2ZVxuICAgIENTUExJTkVfVEhSVTogJ3NwbGluZVRocnUnLCAvLyBDYXRtdWxsLVJvbSBzcGxpbmVcbiAgICBBUkM6ICdhcmMnLCAvLyBDaXJjbGVcbiAgICBFTExJUFNFOiAnZWxsaXBzZSdcbn07XG5cbi8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcblxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXG4vLyAtIHZlY3RvcnM6IGFycmF5IG9mIFZlY3RvcjJcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uKCB2ZWN0b3JzICkge1xuXG4gICAgdGhpcy5tb3ZlVG8oIHZlY3RvcnNbIDAgXS54LCB2ZWN0b3JzWyAwIF0ueSApO1xuXG4gICAgZm9yICggdmFyIHYgPSAxLCB2bGVuID0gdmVjdG9ycy5sZW5ndGg7IHYgPCB2bGVuOyB2KysgKSB7XG5cbiAgICAgICAgdGhpcy5saW5lVG8oIHZlY3RvcnNbIHYgXS54LCB2ZWN0b3JzWyB2IF0ueSApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBzdGFydFBhdGgoKSBlbmRQYXRoKCk/XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHtcbiAgICAgICAgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuTGluZUN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICkgKTtcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHtcbiAgICAgICAgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFDUHgsIGFDUHkgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApICk7XG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7XG4gICAgICAgIGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuUVVBRFJBVElDX0NVUlZFX1RPLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSxcbiAgICBhQ1AyeCwgYUNQMnksXG4gICAgYVgsIGFZICkge1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5DdWJpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHtcbiAgICAgICAgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE8sXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnNwbGluZVRocnUgPSBmdW5jdGlvbiggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcbiAgICAvLy0tLVxuICAgIHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggbnB0cywgcHRzICk7XG5cbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIG5wdHMgKTtcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHtcbiAgICAgICAgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlUsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9ICk7XG5cbn07XG5cbi8vIEZVVFVSRTogQ2hhbmdlIHRoZSBBUEkgb3IgZm9sbG93IGNhbnZhcyBBUEk/XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uKCBhWCwgYVksIGFSYWRpdXMsXG4gICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICAgIHRoaXMuYWJzYXJjKCBhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxuICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2FyYyA9IGZ1bmN0aW9uKCBhWCwgYVksIGFSYWRpdXMsXG4gICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuICAgIHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICAgIHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cbn07XG5cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzZWxsaXBzZSA9IGZ1bmN0aW9uKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG4gICAgdmFyIGFyZ3MgPSBbXG4gICAgICAgIGFYLCBhWSxcbiAgICAgICAgeFJhZGl1cywgeVJhZGl1cyxcbiAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSxcbiAgICAgICAgYUNsb2Nrd2lzZSxcbiAgICAgICAgYVJvdGF0aW9uIHx8IDAgLy8gYVJvdGF0aW9uIGlzIG9wdGlvbmFsLlxuICAgIF07XG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgdmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XG4gICAgYXJncy5wdXNoKCBsYXN0UG9pbnQueCApO1xuICAgIGFyZ3MucHVzaCggbGFzdFBvaW50LnkgKTtcblxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7XG4gICAgICAgIGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRSxcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuICAgIGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDQwO1xuXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpKysgKSB7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG4gICAgICAgIC8vaWYoICF0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKSB0aHJvdyBcIkRJRVwiO1xuXG4gICAgfVxuXG4gICAgLy8gaWYgKCBjbG9zZWRQYXRoICkge1xuICAgIC8vXG4gICAgLy8gXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcbiAgICAvL1xuICAgIC8vIH1cblxuICAgIHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8qIFJldHVybiBhbiBhcnJheSBvZiB2ZWN0b3JzIGJhc2VkIG9uIGNvbnRvdXIgb2YgdGhlIHBhdGggKi9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuICAgIGlmICggdGhpcy51c2VTcGFjZWRQb2ludHMgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKTtcblxuICAgIH1cblxuICAgIGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcblxuICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgIHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xuICAgIHZhciBjcHgsIGNweSwgY3B4MiwgY3B5MiwgY3B4MSwgY3B5MSwgY3B4MCwgY3B5MCxcbiAgICAgICAgbGFzdGUsIGosXG4gICAgICAgIHQsIHR4LCB0eTtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcblxuICAgICAgICBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcbiAgICAgICAgYXJncyA9IGl0ZW0uYXJncztcblxuICAgICAgICBzd2l0Y2ggKCBhY3Rpb24gKSB7XG5cbiAgICAgICAgICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcblxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTElORV9UTzpcblxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuUVVBRFJBVElDX0NVUlZFX1RPOlxuXG4gICAgICAgICAgICAgICAgY3B4ID0gYXJnc1sgMiBdO1xuICAgICAgICAgICAgICAgIGNweSA9IGFyZ3NbIDMgXTtcblxuICAgICAgICAgICAgICAgIGNweDEgPSBhcmdzWyAwIF07XG4gICAgICAgICAgICAgICAgY3B5MSA9IGFyZ3NbIDEgXTtcblxuICAgICAgICAgICAgICAgIGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdCA9IGogLyBkaXZpc2lvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG4gICAgICAgICAgICAgICAgICAgIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkJFWklFUl9DVVJWRV9UTzpcblxuICAgICAgICAgICAgICAgIGNweCA9IGFyZ3NbIDQgXTtcbiAgICAgICAgICAgICAgICBjcHkgPSBhcmdzWyA1IF07XG5cbiAgICAgICAgICAgICAgICBjcHgxID0gYXJnc1sgMCBdO1xuICAgICAgICAgICAgICAgIGNweTEgPSBhcmdzWyAxIF07XG5cbiAgICAgICAgICAgICAgICBjcHgyID0gYXJnc1sgMiBdO1xuICAgICAgICAgICAgICAgIGNweTIgPSBhcmdzWyAzIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICAgICAgICAgICAgICBjcHkwID0gbGFzdGUueTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuICAgICAgICAgICAgICAgICAgICBjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdCA9IGogLyBkaXZpc2lvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XG4gICAgICAgICAgICAgICAgICAgIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVTpcblxuICAgICAgICAgICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdLCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdICk7XG4gICAgICAgICAgICAgICAgdmFyIHNwdHMgPSBbIGxhc3QgXTtcblxuICAgICAgICAgICAgICAgIHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHNwdHMgPSBzcHRzLmNvbmNhdCggYXJnc1sgMCBdICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3BsaW5lID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBzcHRzICk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMTsgaiA8PSBuOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5BUkM6XG5cbiAgICAgICAgICAgICAgICB2YXIgYVggPSBhcmdzWyAwIF0sXG4gICAgICAgICAgICAgICAgICAgIGFZID0gYXJnc1sgMSBdLFxuICAgICAgICAgICAgICAgICAgICBhUmFkaXVzID0gYXJnc1sgMiBdLFxuICAgICAgICAgICAgICAgICAgICBhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSxcbiAgICAgICAgICAgICAgICAgICAgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxuICAgICAgICAgICAgICAgICAgICBhQ2xvY2t3aXNlID0gISFhcmdzWyA1IF07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZTtcbiAgICAgICAgICAgICAgICB2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdCA9IGogLyB0ZGl2aXNpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWFDbG9ja3dpc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAxIC0gdDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgICAgICAgICAgICAgICAgIHR5ID0gYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkVMTElQU0U6XG5cbiAgICAgICAgICAgICAgICB2YXIgYVggPSBhcmdzWyAwIF0sXG4gICAgICAgICAgICAgICAgICAgIGFZID0gYXJnc1sgMSBdLFxuICAgICAgICAgICAgICAgICAgICB4UmFkaXVzID0gYXJnc1sgMiBdLFxuICAgICAgICAgICAgICAgICAgICB5UmFkaXVzID0gYXJnc1sgMyBdLFxuICAgICAgICAgICAgICAgICAgICBhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSxcbiAgICAgICAgICAgICAgICAgICAgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxuICAgICAgICAgICAgICAgICAgICBhQ2xvY2t3aXNlID0gISFhcmdzWyA2IF0sXG4gICAgICAgICAgICAgICAgICAgIGFSb3RhdGlvbiA9IGFyZ3NbIDcgXTtcblxuXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGU7XG4gICAgICAgICAgICAgICAgdmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvcywgc2luO1xuICAgICAgICAgICAgICAgIGlmICggYVJvdGF0aW9uICE9PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKCBhUm90YXRpb24gKTtcbiAgICAgICAgICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oIGFSb3RhdGlvbiApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDE7IGogPD0gdGRpdmlzaW9uczsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHQgPSBqIC8gdGRpdmlzaW9ucztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFhQ2xvY2t3aXNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gMSAtIHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblxuICAgICAgICAgICAgICAgICAgICB0eCA9IGFYICsgeFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICAgICAgICAgICAgICAgICAgICB0eSA9IGFZICsgeVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggYVJvdGF0aW9uICE9PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0eTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSAoIHggLSBhWCApICogY29zIC0gKCB5IC0gYVkgKSAqIHNpbiArIGFYO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSAoIHggLSBhWCApICogc2luICsgKCB5IC0gYVkgKSAqIGNvcyArIGFZO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwb2ludHMpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfSAvLyBlbmQgc3dpdGNoXG5cbiAgICB9XG5cblxuXG4gICAgLy8gTm9ybWFsaXplIHRvIHJlbW92ZSB0aGUgY2xvc2luZyBwb2ludCBieSBkZWZhdWx0LlxuICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG4gICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG4gICAgaWYgKCBNYXRoLmFicyggbGFzdFBvaW50LnggLSBwb2ludHNbIDAgXS54ICkgPCBFUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKCBsYXN0UG9pbnQueSAtIHBvaW50c1sgMCBdLnkgKSA8IEVQU0lMT04gKVxuICAgICAgICBwb2ludHMuc3BsaWNlKCBwb2ludHMubGVuZ3RoIC0gMSwgMSApO1xuICAgIGlmICggY2xvc2VkUGF0aCApIHtcblxuICAgICAgICBwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8vXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xuLy9cbi8vXHRBc3N1bXB0aW9ucyAoaWYgcGFyYW1ldGVyIGlzQ0NXPT10cnVlIHRoZSBvcHBvc2l0ZSBob2xkcyk6XG4vL1x0LSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcbi8vXHQtIGhvbGVzIGFyZSBkZWZpbmVkIGNvdW50ZXJjbG9ja3dpc2UgKENDVylcbi8vXG4vL1x0SWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XG4vLyAgLSBhbGwgc3ViUGF0aHMgYXJlIHJlZ2FyZGVkIGFzIHNvbGlkIHNoYXBlc1xuLy8gIC0gZGVmaW5pdGlvbiBvcmRlciBDVy9DQ1cgaGFzIG5vIHJlbGV2YW5jZVxuLy9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiggaXNDQ1csIG5vSG9sZXMgKSB7XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0U3VicGF0aHMoIGluQWN0aW9ucyApIHtcblxuICAgICAgICB2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcblxuICAgICAgICB2YXIgc3ViUGF0aHMgPSBbXSxcbiAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBpbkFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgaXRlbSA9IGluQWN0aW9uc1sgaSBdO1xuXG4gICAgICAgICAgICBhcmdzID0gaXRlbS5hcmdzO1xuICAgICAgICAgICAgYWN0aW9uID0gaXRlbS5hY3Rpb247XG5cbiAgICAgICAgICAgIGlmICggYWN0aW9uID09PSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xuXG4gICAgICAgICAgICBzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzdWJQYXRocyk7XG5cbiAgICAgICAgcmV0dXJuIHN1YlBhdGhzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xuXG4gICAgICAgIHZhciBzaGFwZXMgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcblxuICAgICAgICAgICAgdmFyIHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XG4gICAgICAgICAgICB0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuICAgICAgICAgICAgdG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cbiAgICAgICAgICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuICAgICAgICByZXR1cm4gc2hhcGVzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcblxuICAgICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgICB2YXIgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XG5cbiAgICAgICAgLy8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3JcbiAgICAgICAgLy8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuICAgICAgICAvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XG4gICAgICAgIC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXG4gICAgICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICggdmFyIHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSsrICkge1xuXG4gICAgICAgICAgICB2YXIgZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBwIF07XG4gICAgICAgICAgICB2YXIgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcSBdO1xuXG4gICAgICAgICAgICB2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XG4gICAgICAgICAgICB2YXIgZWRnZUR5ID0gZWRnZUhpZ2hQdC55IC0gZWRnZUxvd1B0Lnk7XG5cbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgICAgIC8vIG5vdCBwYXJhbGxlbFxuICAgICAgICAgICAgICAgIGlmICggZWRnZUR5IDwgMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBlZGdlTG93UHQgPSBpblBvbHlnb25bIHEgXTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZUR4ID0gLWVkZ2VEeDtcbiAgICAgICAgICAgICAgICAgICAgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdO1xuICAgICAgICAgICAgICAgICAgICBlZGdlRHkgPSAtZWRnZUR5O1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKSByZXR1cm4gdHJ1ZTsgLy8gaW5QdCBpcyBvbiBjb250b3VyID9cbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XHRcdFx0XHQvLyBubyBpbnRlcnNlY3Rpb24gb3IgZWRnZUxvd1B0ID0+IGRvZXNuJ3QgY291bnQgISEhXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnBFZGdlID0gZWRnZUR5ICogKCBpblB0LnggLSBlZGdlTG93UHQueCApIC0gZWRnZUR4ICogKCBpblB0LnkgLSBlZGdlTG93UHQueSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHBlcnBFZGdlID09PSAwICkgcmV0dXJuIHRydWU7IC8vIGluUHQgaXMgb24gY29udG91ciA/XG4gICAgICAgICAgICAgICAgICAgIGlmICggcGVycEVkZ2UgPCAwICkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7IC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgICAgICAgICAgICAgIGlmICggaW5QdC55ICE9PSBlZGdlTG93UHQueSApIGNvbnRpbnVlOyAvLyBwYXJhbGxlbFxuICAgICAgICAgICAgICAgIC8vIGVkZ2UgbGllcyBvbiB0aGUgc2FtZSBob3Jpem9udGFsIGxpbmUgYXMgaW5QdFxuICAgICAgICAgICAgICAgIGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKSByZXR1cm4gdHJ1ZTsgLy8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc2lkZTtcblxuICAgIH1cblxuXG4gICAgdmFyIHN1YlBhdGhzID0gZXh0cmFjdFN1YnBhdGhzKCB0aGlzLmFjdGlvbnMgKTtcbiAgICBpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuICAgIGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApIHJldHVybiB0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XG5cblxuICAgIHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xuXG4gICAgaWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDEgKSB7XG5cbiAgICAgICAgdG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XG4gICAgICAgIHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XG4gICAgICAgIHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG4gICAgICAgIHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuICAgICAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcbiAgICAgICAgcmV0dXJuIHNoYXBlcztcblxuICAgIH1cblxuICAgIHZhciBob2xlc0ZpcnN0ID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XG4gICAgaG9sZXNGaXJzdCA9IGlzQ0NXID8gIWhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xuXG4gICAgLy8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcblxuICAgIHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG4gICAgdmFyIG5ld1NoYXBlcyA9IFtdO1xuICAgIHZhciBuZXdTaGFwZUhvbGVzID0gW107XG4gICAgdmFyIG1haW5JZHggPSAwO1xuICAgIHZhciB0bXBQb2ludHM7XG5cbiAgICBuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcbiAgICBuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuICAgIHZhciBpLCBpbDtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgdG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XG4gICAgICAgIHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XG4gICAgICAgIHNvbGlkID0gVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xuICAgICAgICBzb2xpZCA9IGlzQ0NXID8gIXNvbGlkIDogc29saWQ7XG5cbiAgICAgICAgaWYgKCBzb2xpZCApIHtcblxuICAgICAgICAgICAgaWYgKCAoICFob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApICkgbWFpbklkeCsrO1xuXG4gICAgICAgICAgICBuZXdTaGFwZXNbIG1haW5JZHggXSA9IHtcbiAgICAgICAgICAgICAgICBzOiBuZXcgVEhSRUUuU2hhcGUoKSxcbiAgICAgICAgICAgICAgICBwOiB0bXBQb2ludHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuZXdTaGFwZXNbIG1haW5JZHggXS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG4gICAgICAgICAgICBuZXdTaGFwZXNbIG1haW5JZHggXS5zLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG4gICAgICAgICAgICBpZiAoIGhvbGVzRmlyc3QgKSBtYWluSWR4Kys7XG4gICAgICAgICAgICBuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY3cnLCBpKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCgge1xuICAgICAgICAgICAgICAgIGg6IHRtcFBhdGgsXG4gICAgICAgICAgICAgICAgcDogdG1wUG9pbnRzWyAwIF1cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXG4gICAgaWYgKCAhbmV3U2hhcGVzWyAwIF0gKSByZXR1cm4gdG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cbiAgICBpZiAoIG5ld1NoYXBlcy5sZW5ndGggPiAxICkge1xuXG4gICAgICAgIHZhciBhbWJpZ3VvdXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRvQ2hhbmdlID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHgrKyApIHtcblxuICAgICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdID0gW107XG5cbiAgICAgICAgfVxuICAgICAgICBmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgc2hvID0gbmV3U2hhcGVIb2xlc1sgc0lkeCBdO1xuICAgICAgICAgICAgZm9yICggdmFyIGhJZHggPSAwOyBoSWR4IDwgc2hvLmxlbmd0aDsgaElkeCsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGhvID0gc2hvWyBoSWR4IF07XG4gICAgICAgICAgICAgICAgdmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNQb2ludEluc2lkZVBvbHlnb24oIGhvLnAsIG5ld1NoYXBlc1sgczJJZHggXS5wICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc0lkeCAhPT0gczJJZHggKSB0b0NoYW5nZS5wdXNoKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbXM6IHNJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9zOiBzMklkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlOiBoSWR4XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggaG9sZV91bmFzc2lnbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbIHNJZHggXS5wdXNoKCBobyApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XG4gICAgICAgIGlmICggdG9DaGFuZ2UubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0byBjaGFuZ2U6IFwiLCB0b0NoYW5nZSk7XG4gICAgICAgICAgICBpZiAoICFhbWJpZ3VvdXMgKSBuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgdG1wSG9sZXMsIGosIGpsO1xuICAgIGZvciAoIGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcbiAgICAgICAgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG4gICAgICAgIHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1sgaSBdO1xuICAgICAgICBmb3IgKCBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICB0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuICAgIHJldHVybiBzaGFwZXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1NoYXBlLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogRGVmaW5lcyBhIDJkIHNoYXBlIHBsYW5lIHVzaW5nIHBhdGhzLlxuICoqL1xuXG4vLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cbi8vIFNURVAgMiBUdXJuIHBhdGggaW50byBzaGFwZS5cbi8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXG4vLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXG4vLyBTVEVQIDNiIC0gVHJpYW5ndWxhdGUgZWFjaCBzaGFwZSwgYWRkIGZhY2VzLlxuXG5USFJFRS5TaGFwZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuUGF0aC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgdGhpcy5ob2xlcyA9IFtdO1xuXG59O1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5QYXRoLnByb3RvdHlwZSApO1xuVEhSRUUuU2hhcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhcGU7XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gRXh0cnVkZUdlb21ldHJ5XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgZXh0cnVkZWQgPSBuZXcgVEhSRUUuRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG4gICAgcmV0dXJuIGV4dHJ1ZGVkO1xuXG59O1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIFNoYXBlR2VvbWV0cnlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEdldCBwb2ludHMgb2YgaG9sZXNcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLFxuICAgICAgICBob2xlc1B0cyA9IFtdO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGhvbGVzUHRzO1xuXG59O1xuXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzIChzcGFjZWQgYnkgcmVndWxhciBkaXN0YW5jZSlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50c0hvbGVzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLFxuICAgICAgICBob2xlc1B0cyA9IFtdO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGhvbGVzUHRzO1xuXG59O1xuXG5cbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIHNoYXBlOiB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCBkaXZpc2lvbnMgKSxcbiAgICAgICAgaG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cbiAgICB9O1xuXG59O1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBpZiAoIHRoaXMudXNlU3BhY2VkUG9pbnRzICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyggZGl2aXNpb25zICk7XG5cbn07XG5cbi8vXG4vLyBUSFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50c1dpdGhCZW5kID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGJlbmQgKSB7XG4vL1xuLy8gXHRyZXR1cm4ge1xuLy9cbi8vIFx0XHRzaGFwZTogdGhpcy50cmFuc2Zvcm0oIGJlbmQsIGRpdmlzaW9ucyApLFxuLy8gXHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMsIGJlbmQgKVxuLy9cbi8vIFx0fTtcbi8vXG4vLyB9O1xuXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoc3BhY2VkIGJ5IHJlZ3VsYXIgZGlzdGFuY2UpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsU3BhY2VkUG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgc2hhcGU6IHRoaXMuZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApLFxuICAgICAgICBob2xlczogdGhpcy5nZXRTcGFjZWRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuICAgIH07XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFV0aWxzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlNoYXBlLlV0aWxzID0ge1xuXG4gICAgdHJpYW5ndWxhdGVTaGFwZTogZnVuY3Rpb24oIGNvbnRvdXIsIGhvbGVzICkge1xuXG4gICAgICAgIGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xuXG4gICAgICAgICAgICAvLyBpbk90aGVyUHQgbmVlZHMgdG8gYmUgY29sbGluZWFyIHRvIHRoZSBpblNlZ21lbnRcbiAgICAgICAgICAgIGlmICggaW5TZWdQdDEueCAhPT0gaW5TZWdQdDIueCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggaW5TZWdQdDEueCA8IGluU2VnUHQyLnggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAoIGluU2VnUHQyLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQxLnggKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICggaW5TZWdQdDEueSA8IGluU2VnUHQyLnkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSB7XG5cbiAgICAgICAgICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgICAgICAgICB2YXIgc2VnMWR4ID0gaW5TZWcxUHQyLnggLSBpblNlZzFQdDEueCxcbiAgICAgICAgICAgICAgICBzZWcxZHkgPSBpblNlZzFQdDIueSAtIGluU2VnMVB0MS55O1xuICAgICAgICAgICAgdmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsXG4gICAgICAgICAgICAgICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcblxuICAgICAgICAgICAgdmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xuICAgICAgICAgICAgdmFyIHNlZzFzZWcyZHkgPSBpblNlZzFQdDEueSAtIGluU2VnMlB0MS55O1xuXG4gICAgICAgICAgICB2YXIgbGltaXQgPSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XG4gICAgICAgICAgICB2YXIgcGVycFNlZzEgPSBzZWcxZHkgKiBzZWcxc2VnMmR4IC0gc2VnMWR4ICogc2VnMXNlZzJkeTtcblxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbGltaXQgKSA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBub3QgcGFyYWxsZWxcblxuICAgICAgICAgICAgICAgIHZhciBwZXJwU2VnMjtcbiAgICAgICAgICAgICAgICBpZiAoIGxpbWl0ID4gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMiA8IDAgKSB8fCAoIHBlcnBTZWcyID4gbGltaXQgKSApIHJldHVybiBbXTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzEgPiAwICkgfHwgKCBwZXJwU2VnMSA8IGxpbWl0ICkgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMiA+IDAgKSB8fCAoIHBlcnBTZWcyIDwgbGltaXQgKSApIHJldHVybiBbXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XG4gICAgICAgICAgICAgICAgaWYgKCBwZXJwU2VnMiA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBwZXJwU2VnMiA9PT0gbGltaXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MiBdO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XG4gICAgICAgICAgICAgICAgaWYgKCBwZXJwU2VnMSA9PT0gMCApIHJldHVybiBbIGluU2VnMlB0MSBdO1xuICAgICAgICAgICAgICAgIGlmICggcGVycFNlZzEgPT09IGxpbWl0ICkgcmV0dXJuIFsgaW5TZWcyUHQyIF07XG5cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVhbCBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsge1xuICAgICAgICAgICAgICAgICAgICB4OiBpblNlZzFQdDEueCArIGZhY3RvclNlZzEgKiBzZWcxZHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGluU2VnMVB0MS55ICsgZmFjdG9yU2VnMSAqIHNlZzFkeVxuICAgICAgICAgICAgICAgIH0gXTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcbiAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzEgIT09IDAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIHNlZzJkeSAqIHNlZzFzZWcyZHggIT09IHNlZzJkeCAqIHNlZzFzZWcyZHkgKSApIHJldHVybiBbXTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZXkgYXJlIGNvbGxpbmVhciBvciBkZWdlbmVyYXRlXG4gICAgICAgICAgICAgICAgdmFyIHNlZzFQdCA9ICggKCBzZWcxZHggPT09IDAgKSAmJiAoIHNlZzFkeSA9PT0gMCApICk7IC8vIHNlZ21lbnQxIGlzIGp1c3QgYSBwb2ludD9cbiAgICAgICAgICAgICAgICB2YXIgc2VnMlB0ID0gKCAoIHNlZzJkeCA9PT0gMCApICYmICggc2VnMmR5ID09PSAwICkgKTsgLy8gc2VnbWVudDIgaXMganVzdCBhIHBvaW50P1xuICAgICAgICAgICAgICAgIC8vIGJvdGggc2VnbWVudHMgYXJlIHBvaW50c1xuICAgICAgICAgICAgICAgIGlmICggc2VnMVB0ICYmIHNlZzJQdCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggaW5TZWcxUHQxLnggIT09IGluU2VnMlB0MS54ICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKSByZXR1cm4gW107IC8vIHRoZXkgYXJlIGRpc3RpbmN0ICBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07IC8vIHRoZXkgYXJlIHRoZSBzYW1lIHBvaW50XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudCMxICBpcyBhIHNpbmdsZSBwb2ludFxuICAgICAgICAgICAgICAgIGlmICggc2VnMVB0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApIHJldHVybiBbXTsgLy8gYnV0IG5vdCBpbiBzZWdtZW50IzJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudCMyICBpcyBhIHNpbmdsZSBwb2ludFxuICAgICAgICAgICAgICAgIGlmICggc2VnMlB0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEgKSApIHJldHVybiBbXTsgLy8gYnV0IG5vdCBpbiBzZWdtZW50IzFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgaW5TZWcyUHQxIF07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSBjb2xsaW5lYXIgc2VnbWVudHMsIHdoaWNoIG1pZ2h0IG92ZXJsYXBcbiAgICAgICAgICAgICAgICB2YXIgc2VnMW1pbiwgc2VnMW1heCwgc2VnMW1pblZhbCwgc2VnMW1heFZhbDtcbiAgICAgICAgICAgICAgICB2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzFkeCAhPT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VnbWVudHMgYXJlIE5PVCBvbiBhIHZlcnRpY2FsIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblNlZzFQdDEueCA8IGluU2VnMVB0Mi54ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pblZhbCA9IGluU2VnMVB0MS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueDtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5TZWcyUHQxLnggPCBpblNlZzJQdDIueCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4VmFsID0gaW5TZWcyUHQyLng7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4VmFsID0gaW5TZWcyUHQxLng7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWdtZW50cyBhcmUgb24gYSB2ZXJ0aWNhbCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluU2VnMlB0MS55IDwgaW5TZWcyUHQyLnkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi55O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluVmFsID0gaW5TZWcyUHQyLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPD0gc2VnMm1pblZhbCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPCBzZWcybWluVmFsICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPT09IHNlZzJtaW5WYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgc2VnMm1pbiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKSByZXR1cm4gWyBzZWcybWluLCBzZWcxbWF4IF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHNlZzJtaW4sIHNlZzJtYXggXTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPiBzZWcybWF4VmFsICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPT09IHNlZzJtYXhWYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgc2VnMW1pbiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKSByZXR1cm4gWyBzZWcxbWluLCBzZWcxbWF4IF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHNlZzFtaW4sIHNlZzJtYXggXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XG5cbiAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiBsZWdzIGlzIGltcG9ydGFudFxuXG4gICAgICAgICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb24gb2YgYWxsIHBvaW50cywgc28gdGhhdCBWZXJ0ZXggaXMgYXQgKDAsMClcbiAgICAgICAgICAgIHZhciBsZWdGcm9tUHRYID0gaW5MZWdGcm9tUHQueCAtIGluVmVydGV4LngsXG4gICAgICAgICAgICAgICAgbGVnRnJvbVB0WSA9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xuICAgICAgICAgICAgdmFyIGxlZ1RvUHRYID0gaW5MZWdUb1B0LnggLSBpblZlcnRleC54LFxuICAgICAgICAgICAgICAgIGxlZ1RvUHRZID0gaW5MZWdUb1B0LnkgLSBpblZlcnRleC55O1xuICAgICAgICAgICAgdmFyIG90aGVyUHRYID0gaW5PdGhlclB0LnggLSBpblZlcnRleC54LFxuICAgICAgICAgICAgICAgIG90aGVyUHRZID0gaW5PdGhlclB0LnkgLSBpblZlcnRleC55O1xuXG4gICAgICAgICAgICAvLyBtYWluIGFuZ2xlID4wOiA8IDE4MCBkZWcuOyAwOiAxODAgZGVnLjsgPDA6ID4gMTgwIGRlZy5cbiAgICAgICAgICAgIHZhciBmcm9tMnRvQW5nbGUgPSBsZWdGcm9tUHRYICogbGVnVG9QdFkgLSBsZWdGcm9tUHRZICogbGVnVG9QdFg7XG4gICAgICAgICAgICB2YXIgZnJvbTJvdGhlckFuZ2xlID0gbGVnRnJvbVB0WCAqIG90aGVyUHRZIC0gbGVnRnJvbVB0WSAqIG90aGVyUHRYO1xuXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBmcm9tMnRvQW5nbGUgKSA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhbmdsZSAhPSAxODAgZGVnLlxuXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyMnRvQW5nbGUgPSBvdGhlclB0WCAqIGxlZ1RvUHRZIC0gb3RoZXJQdFkgKiBsZWdUb1B0WDtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJmcm9tMnRvOiBcIiArIGZyb20ydG9BbmdsZSArIFwiLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSArIFwiLCBvdGhlcjJ0bzogXCIgKyBvdGhlcjJ0b0FuZ2xlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZyb20ydG9BbmdsZSA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSAmJiAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFpbiBhbmdsZSA+IDE4MCBkZWcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSB8fCAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gYW5nbGUgPT0gMTgwIGRlZy5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJmcm9tMnRvOiAxODAgZGVnLiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggZnJvbTJvdGhlckFuZ2xlID4gMCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xuXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBjb250b3VyLmNvbmNhdCgpOyAvLyB3b3JrIG9uIHRoaXMgc2hhcGVcbiAgICAgICAgICAgIHZhciBob2xlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIGluU2hhcGVJZHgsIGluSG9sZUlkeCApIHtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldlNoYXBlSWR4ID0gaW5TaGFwZUlkeCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKCBwcmV2U2hhcGVJZHggPCAwICkgcHJldlNoYXBlSWR4ID0gbGFzdFNoYXBlSWR4O1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHRTaGFwZUlkeCA9IGluU2hhcGVJZHggKyAxO1xuICAgICAgICAgICAgICAgIGlmICggbmV4dFNoYXBlSWR4ID4gbGFzdFNoYXBlSWR4ICkgbmV4dFNoYXBlSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggc2hhcGVbIGluU2hhcGVJZHggXSwgc2hhcGVbIHByZXZTaGFwZUlkeCBdLCBzaGFwZVsgbmV4dFNoYXBlSWR4IF0sIGhvbGVbIGluSG9sZUlkeCBdICk7XG4gICAgICAgICAgICAgICAgaWYgKCAhaW5zaWRlQW5nbGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiVmVydGV4IChTaGFwZSk6IFwiICsgaW5TaGFwZUlkeCArIFwiLCBQb2ludDogXCIgKyBob2xlW2luSG9sZUlkeF0ueCArIFwiL1wiICsgaG9sZVtpbkhvbGVJZHhdLnkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc2hhcGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIGhvbGUgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgbGFzdEhvbGVJZHggPSBob2xlLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldkhvbGVJZHggPSBpbkhvbGVJZHggLSAxO1xuICAgICAgICAgICAgICAgIGlmICggcHJldkhvbGVJZHggPCAwICkgcHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcblxuICAgICAgICAgICAgICAgIHZhciBuZXh0SG9sZUlkeCA9IGluSG9sZUlkeCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKCBuZXh0SG9sZUlkeCA+IGxhc3RIb2xlSWR4ICkgbmV4dEhvbGVJZHggPSAwO1xuXG4gICAgICAgICAgICAgICAgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIGhvbGVbIGluSG9sZUlkeCBdLCBob2xlWyBwcmV2SG9sZUlkeCBdLCBob2xlWyBuZXh0SG9sZUlkeCBdLCBzaGFwZVsgaW5TaGFwZUlkeCBdICk7XG4gICAgICAgICAgICAgICAgaWYgKCAhaW5zaWRlQW5nbGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzU2hhcGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggc2hhcGUgZWRnZXNcbiAgICAgICAgICAgICAgICB2YXIgc0lkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAoIHNJZHggPSAwOyBzSWR4IDwgc2hhcGUubGVuZ3RoOyBzSWR4KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV4dElkeCA9IHNJZHggKyAxO1xuICAgICAgICAgICAgICAgICAgICBuZXh0SWR4ICU9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBzaGFwZVsgc0lkeCBdLCBzaGFwZVsgbmV4dElkeCBdLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXBIb2xlcyA9IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzSG9sZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBob2xlIGVkZ2VzXG4gICAgICAgICAgICAgICAgdmFyIGloSWR4LCBjaGtIb2xlLFxuICAgICAgICAgICAgICAgICAgICBoSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XG4gICAgICAgICAgICAgICAgZm9yICggaWhJZHggPSAwOyBpaElkeCA8IGluZGVwSG9sZXMubGVuZ3RoOyBpaElkeCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNoa0hvbGUgPSBob2xlc1sgaW5kZXBIb2xlc1sgaWhJZHggXSBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBoSWR4ID0gMDsgaElkeCA8IGNoa0hvbGUubGVuZ3RoOyBoSWR4KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZHggPSBoSWR4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZHggJT0gY2hrSG9sZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIGNoa0hvbGVbIGhJZHggXSwgY2hrSG9sZVsgbmV4dElkeCBdLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwICkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaG9sZUluZGV4LCBzaGFwZUluZGV4LFxuICAgICAgICAgICAgICAgIHNoYXBlUHQsIGhvbGVQdCxcbiAgICAgICAgICAgICAgICBob2xlSWR4LCBjdXRLZXksIGZhaWxlZEN1dHMgPSBbXSxcbiAgICAgICAgICAgICAgICB0bXBTaGFwZTEsIHRtcFNoYXBlMixcbiAgICAgICAgICAgICAgICB0bXBIb2xlMSwgdG1wSG9sZTI7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICAgICAgaW5kZXBIb2xlcy5wdXNoKCBoICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1pblNoYXBlSW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBpbmRlcEhvbGVzLmxlbmd0aCAqIDI7XG4gICAgICAgICAgICB3aGlsZSAoIGluZGVwSG9sZXMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICBpZiAoIGNvdW50ZXIgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNoYXBlLXZlcnRleCBhbmQgaG9sZS12ZXJ0ZXgsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKCBzaGFwZUluZGV4ID0gbWluU2hhcGVJbmRleDsgc2hhcGVJbmRleCA8IHNoYXBlLmxlbmd0aDsgc2hhcGVJbmRleCsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xuICAgICAgICAgICAgICAgICAgICBob2xlSW5kZXggPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGhvbGUgd2hpY2ggY2FuIGJlIHJlYWNoZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBoID0gMDsgaCA8IGluZGVwSG9sZXMubGVuZ3RoOyBoKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVJZHggPSBpbmRlcEhvbGVzWyBoIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbXVsdGlwbGUgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZmFpbGVkQ3V0c1sgY3V0S2V5IF0gIT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xlID0gaG9sZXNbIGhvbGVJZHggXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBoMiA9IDA7IGgyIDwgaG9sZS5sZW5ndGg7IGgyKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlUHQgPSBob2xlWyBoMiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWlzQ3V0TGluZUluc2lkZUFuZ2xlcyggc2hhcGVJbmRleCwgaDIgKSApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0c1NoYXBlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdHNIb2xlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVJbmRleCA9IGgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVwSG9sZXMuc3BsaWNlKCBoLCAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBTaGFwZTEgPSBzaGFwZS5zbGljZSggMCwgc2hhcGVJbmRleCArIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEhvbGUxID0gaG9sZS5zbGljZSggaG9sZUluZGV4ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKyAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IHRtcFNoYXBlMS5jb25jYXQoIHRtcEhvbGUxICkuY29uY2F0KCB0bXBIb2xlMiApLmNvbmNhdCggdG1wU2hhcGUyICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5TaGFwZUluZGV4ID0gc2hhcGVJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnbG9iX0N1dExpbmVzLnB1c2goIFsgc2hhcGVQdCwgaG9sZVB0IF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhvbGVJbmRleCA+PSAwICkgYnJlYWs7IC8vIGhvbGUtdmVydGV4IGZvdW5kXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZEN1dHNbIGN1dEtleSBdID0gdHJ1ZTsgLy8gcmVtZW1iZXIgZmFpbHVyZVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBob2xlSW5kZXggPj0gMCApIGJyZWFrOyAvLyBob2xlLXZlcnRleCBmb3VuZFxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzaGFwZTsgLyogc2hhcGUgd2l0aCBubyBob2xlcyAqL1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBpLCBpbCwgZiwgZmFjZSxcbiAgICAgICAgICAgIGtleSwgaW5kZXgsXG4gICAgICAgICAgICBhbGxQb2ludHNNYXAgPSB7fTtcblxuICAgICAgICAvLyBUbyBtYWludGFpbiByZWZlcmVuY2UgdG8gb2xkIHNoYXBlLCBvbmUgbXVzdCBtYXRjaCBjb29yZGluYXRlcywgb3Igb2Zmc2V0IHRoZSBpbmRpY2VzIGZyb20gb3JpZ2luYWwgYXJyYXlzLiBJdCdzIHByb2JhYmx5IGVhc2llciB0byBkbyB0aGUgZmlyc3QuXG5cbiAgICAgICAgdmFyIGFsbHBvaW50cyA9IGNvbnRvdXIuY29uY2F0KCk7XG5cbiAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBhbGxwb2ludHMsIGhvbGVzWyBoIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyggXCJhbGxwb2ludHNcIixhbGxwb2ludHMsIGFsbHBvaW50cy5sZW5ndGggKTtcblxuICAgICAgICAvLyBwcmVwYXJlIGFsbCBwb2ludHMgbWFwXG5cbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWxscG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XG5cbiAgICAgICAgICAgIGlmICggYWxsUG9pbnRzTWFwWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLlNoYXBlOiBEdXBsaWNhdGUgcG9pbnRcIiwga2V5ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWxsUG9pbnRzTWFwWyBrZXkgXSA9IGk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBob2xlcyBieSBjdXR0aW5nIHBhdGhzIHRvIGhvbGVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgc2hhcGVcbiAgICAgICAgdmFyIHNoYXBlV2l0aG91dEhvbGVzID0gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICk7XG5cbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZSggc2hhcGVXaXRob3V0SG9sZXMsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxuICAgICAgICAvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xuXG4gICAgICAgIC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgZmFjZSA9IHRyaWFuZ2xlc1sgaSBdO1xuXG4gICAgICAgICAgICBmb3IgKCBmID0gMDsgZiA8IDM7IGYrKyApIHtcblxuICAgICAgICAgICAgICAgIGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcblxuICAgICAgICAgICAgICAgIGluZGV4ID0gYWxsUG9pbnRzTWFwWyBrZXkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlWyBmIF0gPSBpbmRleDtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCgpO1xuXG4gICAgfSxcblxuICAgIGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiggcHRzICkge1xuXG4gICAgICAgIHJldHVybiBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggcHRzICkgPCAwO1xuXG4gICAgfSxcblxuICAgIC8vIEJlemllciBDdXJ2ZXMgZm9ybXVsYXMgb2J0YWluZWQgZnJvbVxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcblxuICAgIC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjJwMDogZnVuY3Rpb24oIHQsIHAgKSB7XG5cbiAgICAgICAgdmFyIGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogcDtcblxuICAgIH0sXG5cbiAgICBiMnAxOiBmdW5jdGlvbiggdCwgcCApIHtcblxuICAgICAgICByZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG4gICAgfSxcblxuICAgIGIycDI6IGZ1bmN0aW9uKCB0LCBwICkge1xuXG4gICAgICAgIHJldHVybiB0ICogdCAqIHA7XG5cbiAgICB9LFxuXG4gICAgYjI6IGZ1bmN0aW9uKCB0LCBwMCwgcDEsIHAyICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmIycDAoIHQsIHAwICkgKyB0aGlzLmIycDEoIHQsIHAxICkgKyB0aGlzLmIycDIoIHQsIHAyICk7XG5cbiAgICB9LFxuXG4gICAgLy8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjNwMDogZnVuY3Rpb24oIHQsIHAgKSB7XG5cbiAgICAgICAgdmFyIGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIHA7XG5cbiAgICB9LFxuXG4gICAgYjNwMTogZnVuY3Rpb24oIHQsIHAgKSB7XG5cbiAgICAgICAgdmFyIGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXG4gICAgfSxcblxuICAgIGIzcDI6IGZ1bmN0aW9uKCB0LCBwICkge1xuXG4gICAgICAgIHZhciBrID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogayAqIHQgKiB0ICogcDtcblxuICAgIH0sXG5cbiAgICBiM3AzOiBmdW5jdGlvbiggdCwgcCApIHtcblxuICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogcDtcblxuICAgIH0sXG5cbiAgICBiMzogZnVuY3Rpb24oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmIzcDAoIHQsIHAwICkgKyB0aGlzLmIzcDEoIHQsIHAxICkgKyB0aGlzLmIzcDIoIHQsIHAyICkgKyB0aGlzLmIzcDMoIHQsIHAzICk7XG5cbiAgICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuTGluZUN1cnZlID0gZnVuY3Rpb24oIHYxLCB2MiApIHtcblxuICAgIHRoaXMudjEgPSB2MTtcbiAgICB0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQ3VydmU7XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcbiAgICBwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG4gICAgcmV0dXJuIHBvaW50O1xuXG59O1xuXG4vLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24oIHUgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xuXG4gICAgcmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24oIHYwLCB2MSwgdjIgKSB7XG5cbiAgICB0aGlzLnYwID0gdjA7XG4gICAgdGhpcy52MSA9IHYxO1xuICAgIHRoaXMudjIgPSB2MjtcblxufTtcblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTtcblxuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgdmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuICAgIHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblxuICAgIHJldHVybiB2ZWN0b3I7XG5cbn07XG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG4gICAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XG5cbiAgICAvLyByZXR1cm5zIHVuaXQgdmVjdG9yXG5cbiAgICByZXR1cm4gdmVjdG9yLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3ViaWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiggdjAsIHYxLCB2MiwgdjMgKSB7XG5cbiAgICB0aGlzLnYwID0gdjA7XG4gICAgdGhpcy52MSA9IHYxO1xuICAgIHRoaXMudjIgPSB2MjtcbiAgICB0aGlzLnYzID0gdjM7XG5cbn07XG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmljQmV6aWVyQ3VydmU7XG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgdHgsIHR5O1xuXG4gICAgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG4gICAgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xuXG59O1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgdHgsIHR5O1xuXG4gICAgdHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuICAgIHR5ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcblxuICAgIHZhciB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xuICAgIHRhbmdlbnQubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gdGFuZ2VudDtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRTcGxpbmUgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuU3BsaW5lQ3VydmUgPSBmdW5jdGlvbiggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XG5cbiAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbn07XG5cblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BsaW5lQ3VydmU7XG5cblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XG5cbiAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgdmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuICAgIHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgdmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG4gICAgdmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcbiAgICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRFbGxpcHNlIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkVsbGlwc2VDdXJ2ZSA9IGZ1bmN0aW9uKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuICAgIHRoaXMuYVggPSBhWDtcbiAgICB0aGlzLmFZID0gYVk7XG5cbiAgICB0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuICAgIHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cbiAgICB0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG4gICAgdGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cbiAgICB0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG4gICAgdGhpcy5hUm90YXRpb24gPSBhUm90YXRpb24gfHwgMDtcblxufTtcblxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVsbGlwc2VDdXJ2ZTtcblxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG5cbiAgICBpZiAoIGRlbHRhQW5nbGUgPCAwICkgZGVsdGFBbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICBpZiAoIGRlbHRhQW5nbGUgPiBNYXRoLlBJICogMiApIGRlbHRhQW5nbGUgLT0gTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgYW5nbGU7XG5cbiAgICBpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICBhbmdsZSA9IHRoaXMuYUVuZEFuZ2xlICsgKCAxIC0gdCApICogKCBNYXRoLlBJICogMiAtIGRlbHRhQW5nbGUgKTtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblxuICAgIH1cblxuICAgIHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICAgIHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgaWYgKCB0aGlzLmFSb3RhdGlvbiAhPT0gMCApIHtcblxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoIHRoaXMuYVJvdGF0aW9uICk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcblxuICAgICAgICB2YXIgdHggPSB4LFxuICAgICAgICAgICAgdHkgPSB5O1xuXG4gICAgICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICAgICAgeCA9ICggdHggLSB0aGlzLmFYICkgKiBjb3MgLSAoIHR5IC0gdGhpcy5hWSApICogc2luICsgdGhpcy5hWDtcbiAgICAgICAgeSA9ICggdHggLSB0aGlzLmFYICkgKiBzaW4gKyAoIHR5IC0gdGhpcy5hWSApICogY29zICsgdGhpcy5hWTtcblxuICAgIH1cblxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFyYyBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgICBUSFJFRS5FbGxpcHNlQ3VydmUuY2FsbCggdGhpcywgYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbn07XG5cblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFyY0N1cnZlO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0TGluZTNEXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICBmdW5jdGlvbiggdjEsIHYyICkge1xuXG4gICAgICAgIHRoaXMudjEgPSB2MTtcbiAgICAgICAgdGhpcy52MiA9IHYyO1xuXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcbiAgICAgICAgdmVjdG9yLm11bHRpcGx5U2NhbGFyKCB0ICk7XG4gICAgICAgIHZlY3Rvci5hZGQoIHRoaXMudjEgKTtcblxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuXG4gICAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICAgIGZ1bmN0aW9uKCB2MCwgdjEsIHYyICkge1xuXG4gICAgICAgIHRoaXMudjAgPSB2MDtcbiAgICAgICAgdGhpcy52MSA9IHYxO1xuICAgICAgICB0aGlzLnYyID0gdjI7XG5cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuICAgICAgICB2ZWN0b3IueSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XG4gICAgICAgIHZlY3Rvci56ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKTtcblxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuXG4gICAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1YmljIEJlemllciAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICAgIGZ1bmN0aW9uKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuICAgICAgICB0aGlzLnYwID0gdjA7XG4gICAgICAgIHRoaXMudjEgPSB2MTtcbiAgICAgICAgdGhpcy52MiA9IHYyO1xuICAgICAgICB0aGlzLnYzID0gdjM7XG5cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG4gICAgICAgIHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xuICAgICAgICB2ZWN0b3IueiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56LCB0aGlzLnYzLnogKTtcblxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuXG4gICAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICBmdW5jdGlvbiggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIHdpbGwgYmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzJyApO1xuICAgICAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG4gICAgICAgIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgICAgIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgICAgIHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuICAgICAgICB2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcbiAgICAgICAgdmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuICAgICAgICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG4gICAgICAgIHZlY3Rvci56ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKTtcblxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuXG4gICAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0NhdG11bGxSb21DdXJ2ZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuICpcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuICovXG5cblRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyXG4gICAgICAgIHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIHB4ID0gbmV3IEN1YmljUG9seSgpLFxuICAgICAgICBweSA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICAgICAgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XG5cbiAgICAvKlxuXHRCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG5cdCAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXG5cdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG5cdFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcblx0YnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXG5cdHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cblx0Ki9cblxuICAgIGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcblxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxuICAgICAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xuICAgICAqIHN1Y2ggdGhhdFxuICAgICAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcbiAgICAgKiAgYW5kXG4gICAgICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuICAgICAqL1xuICAgIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCB4MCwgeDEsIHQwLCB0MSApIHtcblxuICAgICAgICB0aGlzLmMwID0geDA7XG4gICAgICAgIHRoaXMuYzEgPSB0MDtcbiAgICAgICAgdGhpcy5jMiA9IC0zICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcbiAgICAgICAgdGhpcy5jMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XG5cbiAgICB9O1xuXG4gICAgQ3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuICAgICAgICB2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuICAgICAgICB2YXIgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xuXG4gICAgICAgIC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxuICAgICAgICB0MSAqPSBkdDE7XG4gICAgICAgIHQyICo9IGR0MTtcblxuICAgICAgICAvLyBpbml0Q3ViaWNQb2x5XG4gICAgICAgIHRoaXMuaW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuICAgIH07XG5cbiAgICAvLyBzdGFuZGFyZCBDYXRtdWxsLVJvbSBzcGxpbmU6IGludGVycG9sYXRlIGJldHdlZW4geDEgYW5kIHgyIHdpdGggcHJldmlvdXMvZm9sbG93aW5nIHBvaW50cyB4MS94NFxuICAgIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cbiAgICAgICAgdGhpcy5pbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XG5cbiAgICB9O1xuXG4gICAgQ3ViaWNQb2x5LnByb3RvdHlwZS5jYWxjID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgICAgIHZhciB0MyA9IHQyICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYzAgKyB0aGlzLmMxICogdCArIHRoaXMuYzIgKiB0MiArIHRoaXMuYzMgKiB0MztcblxuICAgIH07XG5cbiAgICAvLyBTdWJjbGFzcyBUaHJlZS5qcyBjdXJ2ZVxuICAgIHJldHVybiBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICAgICAgZnVuY3Rpb24oIHAgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBwIHx8IFtdO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgICAgICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgbDtcblxuICAgICAgICAgICAgbCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICggbCA8IDIgKSBjb25zb2xlLmxvZyggJ2R1aCwgeW91IG5lZWQgYXQgbGVhc3QgMiBwb2ludHMnICk7XG5cbiAgICAgICAgICAgIHBvaW50ID0gKCBsIC0gMSApICogdDtcbiAgICAgICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgICAgICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgICAgICAgIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcblxuICAgICAgICAgICAgICAgIGludFBvaW50ID0gbCAtIDI7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gMTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcDAsIHAxLCBwMiwgcDM7XG5cbiAgICAgICAgICAgIGlmICggaW50UG9pbnQgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxuICAgICAgICAgICAgICAgIHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0gKS5hZGQoIHBvaW50c1sgMCBdICk7XG4gICAgICAgICAgICAgICAgcDAgPSB0bXA7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbIGludFBvaW50IC0gMSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuICAgICAgICAgICAgcDIgPSBwb2ludHNbIGludFBvaW50ICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIGludFBvaW50ICsgMiA8IGwgKSB7XG5cbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1sgaW50UG9pbnQgKyAyIF1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG4gICAgICAgICAgICAgICAgdG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAyIF0gKTtcbiAgICAgICAgICAgICAgICBwMyA9IHRtcDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXMudHlwZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyApIHtcblxuICAgICAgICAgICAgICAgIC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG4gICAgICAgICAgICAgICAgdmFyIHBvdyA9IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcbiAgICAgICAgICAgICAgICB2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcbiAgICAgICAgICAgICAgICB2YXIgZHQxID0gTWF0aC5wb3coIHAxLmRpc3RhbmNlVG9TcXVhcmVkKCBwMiApLCBwb3cgKTtcbiAgICAgICAgICAgICAgICB2YXIgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcblxuICAgICAgICAgICAgICAgIC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xuICAgICAgICAgICAgICAgIGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcbiAgICAgICAgICAgICAgICBpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cbiAgICAgICAgICAgICAgICBweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcbiAgICAgICAgICAgICAgICBweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcbiAgICAgICAgICAgICAgICBwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gJ2NhdG11bGxyb20nICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRlbnNpb24gPSB0aGlzLnRlbnNpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMudGVuc2lvbiA6IDAuNTtcbiAgICAgICAgICAgICAgICBweC5pbml0Q2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgdGVuc2lvbiApO1xuICAgICAgICAgICAgICAgIHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0ZW5zaW9uICk7XG4gICAgICAgICAgICAgICAgcHouaW5pdENhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIHRlbnNpb24gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgICAgIHB4LmNhbGMoIHdlaWdodCApLFxuICAgICAgICAgICAgICAgIHB5LmNhbGMoIHdlaWdodCApLFxuICAgICAgICAgICAgICAgIHB6LmNhbGMoIHdlaWdodCApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gdjtcblxuICAgICAgICB9XG5cbiAgICApO1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DbG9zZWRTcGxpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q2xvc2VkIFNwbGluZSAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICAgIGZ1bmN0aW9uKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuICAgICAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAwICkgKiB0OyAvLyBUaGlzIG5lZWRzIHRvIGJlIGZyb20gMC1sZW5ndGggKzFcblxuICAgICAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgICAgICBpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIHBvaW50cy5sZW5ndGggKSArIDEgKSAqIHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHBvaW50MCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcbiAgICAgICAgdmFyIHBvaW50MSA9IHBvaW50c1sgKCBpbnRQb2ludCApICUgcG9pbnRzLmxlbmd0aCBdO1xuICAgICAgICB2YXIgcG9pbnQyID0gcG9pbnRzWyAoIGludFBvaW50ICsgMSApICUgcG9pbnRzLmxlbmd0aCBdO1xuICAgICAgICB2YXIgcG9pbnQzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgcG9pbnRzLmxlbmd0aCBdO1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcbiAgICAgICAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApO1xuICAgICAgICB2ZWN0b3IueiA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueiwgcG9pbnQxLnosIHBvaW50Mi56LCBwb2ludDMueiwgd2VpZ2h0ICk7XG5cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcblxuICAgIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9BbmltYXRpb25IYW5kbGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5USFJFRS5BbmltYXRpb25IYW5kbGVyID0ge1xuXG4gICAgTElORUFSOiAwLFxuICAgIENBVE1VTExST006IDEsXG4gICAgQ0FUTVVMTFJPTV9GT1JXQVJEOiAyLFxuXG4gICAgLy9cblxuICAgIGFkZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTtcblxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLmdldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApO1xuXG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7XG5cbiAgICB9LFxuXG4gICAgLy9cblxuICAgIGFuaW1hdGlvbnM6IFtdLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cbiAgICAgICAgaWYgKCBkYXRhLmluaXRpYWxpemVkID09PSB0cnVlICkgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBrZXlzXG5cbiAgICAgICAgZm9yICggdmFyIGggPSAwOyBoIDwgZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBoKysgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsrKyApIHtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBtaW51cyB0aW1lc1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lIDwgMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID0gMDtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBxdWF0ZXJuaW9uc1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAhKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgaW5zdGFuY2VvZiBUSFJFRS5RdWF0ZXJuaW9uICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1YXQgPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3Q7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuZnJvbUFycmF5KCBxdWF0ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJlcGFyZSBtb3JwaCB0YXJnZXQga2V5c1xuXG4gICAgICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGggJiYgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF0ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIHVzZWRcblxuICAgICAgICAgICAgICAgIHZhciB1c2VkTW9ycGhUYXJnZXRzID0ge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIG0gPSAwOyBtIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXROYW1lID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkTW9ycGhUYXJnZXRzWyBtb3JwaFRhcmdldE5hbWUgXSA9IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0udXNlZE1vcnBoVGFyZ2V0cyA9IHVzZWRNb3JwaFRhcmdldHM7XG5cblxuICAgICAgICAgICAgICAgIC8vIHNldCBhbGwgdXNlZCBvbiBhbGwgZnJhbWVzXG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZXMgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIHVzZWRNb3JwaFRhcmdldHMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0rKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF0gPT09IG1vcnBoVGFyZ2V0TmFtZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXNbIG0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbHVlbmNlc1sgbW9ycGhUYXJnZXROYW1lIF0gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXMgPSBpbmZsdWVuY2VzO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBrZXlzIHRoYXQgYXJlIG9uIHRoZSBzYW1lIHRpbWVcblxuICAgICAgICAgICAgZm9yICggdmFyIGsgPSAxOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgaysrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgLSAxIF0udGltZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMuc3BsaWNlKCBrLCAxICk7XG4gICAgICAgICAgICAgICAgICAgIGstLTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIHNldCBpbmRleFxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrKysgKSB7XG5cbiAgICAgICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5pbmRleCA9IGs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCByb290ICkge1xuXG4gICAgICAgIHZhciBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkgPSBmdW5jdGlvbiggcm9vdCwgaGllcmFyY2h5ICkge1xuXG4gICAgICAgICAgICBoaWVyYXJjaHkucHVzaCggcm9vdCApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgYyA9IDA7IGMgPCByb290LmNoaWxkcmVuLmxlbmd0aDsgYysrIClcbiAgICAgICAgICAgICAgICBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QuY2hpbGRyZW5bIGMgXSwgaGllcmFyY2h5ICk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXR1cCBoaWVyYXJjaHlcblxuICAgICAgICB2YXIgaGllcmFyY2h5ID0gW107XG5cbiAgICAgICAgaWYgKCByb290IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBiID0gMDsgYiA8IHJvb3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBiKysgKSB7XG5cbiAgICAgICAgICAgICAgICBoaWVyYXJjaHkucHVzaCggcm9vdC5za2VsZXRvbi5ib25lc1sgYiBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QsIGhpZXJhcmNoeSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGllcmFyY2h5O1xuXG4gICAgfSxcblxuICAgIHBsYXk6IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICkgPT09IC0xICkge1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMucHVzaCggYW5pbWF0aW9uICk7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5hbmltYXRpb25zLmluZGV4T2YoIGFuaW1hdGlvbiApO1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IC0xICkge1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCBkZWx0YVRpbWVNUyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1sgaSBdLnJlc2V0QmxlbmRXZWlnaHRzKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zWyBpIF0udXBkYXRlKCBkZWx0YVRpbWVNUyApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9BbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQW5pbWF0aW9uID0gZnVuY3Rpb24oIHJvb3QsIGRhdGEgKSB7XG5cbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMuZGF0YSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuaW5pdCggZGF0YSApO1xuICAgIHRoaXMuaGllcmFyY2h5ID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZSggcm9vdCApO1xuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy50aW1lU2NhbGUgPSAxO1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxvb3AgPSB0cnVlO1xuICAgIHRoaXMud2VpZ2h0ID0gMDtcblxuICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUjtcblxufTtcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb24sXG5cbiAgICBrZXlUeXBlczogWyBcInBvc1wiLCBcInJvdFwiLCBcInNjbFwiIF0sXG5cbiAgICBwbGF5OiBmdW5jdGlvbiggc3RhcnRUaW1lLCB3ZWlnaHQgKSB7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gc3RhcnRUaW1lIDogMDtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHdlaWdodCA6IDE7XG5cbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkoIHRoaXMgKTtcblxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgICAgICAgIGlmICggb2JqZWN0LmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBibGVuZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25XZWlnaHQ6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXRlcm5pb25XZWlnaHQ6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlV2VpZ2h0OiAwLjBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmRhdGEubmFtZTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25zID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnM7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uQ2FjaGUgPSBhbmltYXRpb25zWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGlmICggYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3Q6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2w6IDBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dEtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm90OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NsOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTWF0cml4OiBvYmplY3QubWF0cml4XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNbIG5hbWUgXSA9IGFuaW1hdGlvbkNhY2hlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBrZXlzIHRvIG1hdGNoIG91ciBjdXJyZW50IHRpbWVcblxuICAgICAgICAgICAgZm9yICggdmFyIHQgPSAwOyB0IDwgMzsgdCsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmtleVR5cGVzWyB0IF07XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldktleSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG4gICAgICAgICAgICAgICAgdmFyIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIG5leHRLZXkudGltZSA8IHRoaXMuY3VycmVudFRpbWUgJiYgbmV4dEtleS5pbmRleCA+IHByZXZLZXkuaW5kZXggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldktleSA9IG5leHRLZXk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJlc2V0QmxlbmRXZWlnaHRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uQ2FjaGUgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGU7XG5cbiAgICAgICAgICAgIGlmICggYW5pbWF0aW9uQ2FjaGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBibGVuZGluZyA9IGFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nO1xuXG4gICAgICAgICAgICAgICAgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgPSAwLjA7XG4gICAgICAgICAgICAgICAgYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCA9IDAuMDtcbiAgICAgICAgICAgICAgICBibGVuZGluZy5zY2FsZVdlaWdodCA9IDAuMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB1cGRhdGU6ICggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIG5ld1ZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBuZXdRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgICAvLyBDYXRtdWxsLVJvbSBzcGxpbmVcblxuICAgICAgICB2YXIgaW50ZXJwb2xhdGVDYXRtdWxsUm9tID0gZnVuY3Rpb24oIHBvaW50cywgc2NhbGUgKSB7XG5cbiAgICAgICAgICAgIHZhciBjID0gW10sXG4gICAgICAgICAgICAgICAgdjMgPSBbXSxcbiAgICAgICAgICAgICAgICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxuICAgICAgICAgICAgICAgIHBhLCBwYiwgcGMsIHBkO1xuXG4gICAgICAgICAgICBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHNjYWxlO1xuICAgICAgICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgICAgICAgICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgICAgICAgICAgY1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcbiAgICAgICAgICAgIGNbIDEgXSA9IGludFBvaW50O1xuICAgICAgICAgICAgY1sgMiBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IGludFBvaW50IDogaW50UG9pbnQgKyAxO1xuICAgICAgICAgICAgY1sgMyBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IGludFBvaW50IDogaW50UG9pbnQgKyAyO1xuXG4gICAgICAgICAgICBwYSA9IHBvaW50c1sgY1sgMCBdIF07XG4gICAgICAgICAgICBwYiA9IHBvaW50c1sgY1sgMSBdIF07XG4gICAgICAgICAgICBwYyA9IHBvaW50c1sgY1sgMiBdIF07XG4gICAgICAgICAgICBwZCA9IHBvaW50c1sgY1sgMyBdIF07XG5cbiAgICAgICAgICAgIHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xuICAgICAgICAgICAgdzMgPSB3ZWlnaHQgKiB3MjtcblxuICAgICAgICAgICAgdjNbIDAgXSA9IGludGVycG9sYXRlKCBwYVsgMCBdLCBwYlsgMCBdLCBwY1sgMCBdLCBwZFsgMCBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgICAgICAgdjNbIDEgXSA9IGludGVycG9sYXRlKCBwYVsgMSBdLCBwYlsgMSBdLCBwY1sgMSBdLCBwZFsgMSBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgICAgICAgdjNbIDIgXSA9IGludGVycG9sYXRlKCBwYVsgMiBdLCBwYlsgMiBdLCBwY1sgMiBdLCBwZFsgMiBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuXG4gICAgICAgICAgICByZXR1cm4gdjM7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcblxuICAgICAgICAgICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXG4gICAgICAgICAgICAgICAgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblxuICAgICAgICAgICAgcmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0zICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGVsdGEgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy53ZWlnaHQgPT09IDAgKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLmN1cnJlbnRUaW1lID4gZHVyYXRpb24gfHwgdGhpcy5jdXJyZW50VGltZSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubG9vcCApIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICU9IGR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5jdXJyZW50VGltZSA8IDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkdXJhdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uQ2FjaGUgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9uc1sgdGhpcy5kYXRhLm5hbWUgXTtcbiAgICAgICAgICAgICAgICB2YXIgYmxlbmRpbmcgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYmxlbmRpbmc7XG5cbiAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggcG9zL3JvdC9zY2xcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciB0ID0gMDsgdCA8IDM7IHQrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQga2V5c1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5rZXlUeXBlc1sgdCBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRLZXkgPSBhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHRoaXMudGltZVNjYWxlID4gMCAmJiBuZXh0S2V5LnRpbWUgPD0gdGhpcy5jdXJyZW50VGltZSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIHRoaXMudGltZVNjYWxlIDwgMCAmJiBwcmV2S2V5LnRpbWUgPj0gdGhpcy5jdXJyZW50VGltZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZLZXkgPSBuZXh0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXSA9IHByZXZLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSAoIHRoaXMuY3VycmVudFRpbWUgLSBwcmV2S2V5LnRpbWUgKSAvICggbmV4dEtleS50aW1lIC0gcHJldktleS50aW1lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZYWVogPSBwcmV2S2V5WyB0eXBlIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0WFlaID0gbmV4dEtleVsgdHlwZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NhbGUgPCAwICkgc2NhbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjYWxlID4gMSApIHNjYWxlID0gMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnBvbGF0ZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJwb3NcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmxlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QucG9zaXRpb24ubGVycCggbmV3VmVjdG9yLCBwcm9wb3J0aW9uYWxXZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGVuZGluZy5wb3NpdGlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWyAwIF0gPSB0aGlzLmdldFByZXZLZXlXaXRoKCBcInBvc1wiLCBoLCBwcmV2S2V5LmluZGV4IC0gMSApWyBcInBvc1wiIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWyAxIF0gPSBwcmV2WFlaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sgMiBdID0gbmV4dFhZWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbIDMgXSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIFwicG9zXCIsIGgsIG5leHRLZXkuaW5kZXggKyAxIClbIFwicG9zXCIgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlID0gc2NhbGUgKiAwLjMzICsgMC4zMztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UG9pbnQgPSBpbnRlcnBvbGF0ZUNhdG11bGxSb20oIHBvaW50cywgc2NhbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGVuZGluZy5wb3NpdGlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJsZW5kXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gb2JqZWN0LnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjdG9yLnggPSB2ZWN0b3IueCArICggY3VycmVudFBvaW50WyAwIF0gLSB2ZWN0b3IueCApICogcHJvcG9ydGlvbmFsV2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlY3Rvci55ID0gdmVjdG9yLnkgKyAoIGN1cnJlbnRQb2ludFsgMSBdIC0gdmVjdG9yLnkgKSAqIHByb3BvcnRpb25hbFdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWN0b3IueiA9IHZlY3Rvci56ICsgKCBjdXJyZW50UG9pbnRbIDIgXSAtIHZlY3Rvci56ICkgKiBwcm9wb3J0aW9uYWxXZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3J3YXJkUG9pbnQgPSBpbnRlcnBvbGF0ZUNhdG11bGxSb20oIHBvaW50cywgc2NhbGUgKiAxLjAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldCggZm9yd2FyZFBvaW50WyAwIF0sIGZvcndhcmRQb2ludFsgMSBdLCBmb3J3YXJkUG9pbnRbIDIgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc3ViKCB2ZWN0b3IgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGFyZ2V0LngsIHRhcmdldC56ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGlvbi5zZXQoIDAsIGFuZ2xlLCAwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCB0eXBlID09PSBcInJvdFwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwKCBwcmV2WFlaLCBuZXh0WFlaLCBuZXdRdWF0LCBzY2FsZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBwYXlpbmcgdGhlIGNvc3Qgb2YgYW4gYWRkaXRpb25hbCBzbGVycCBpZiB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QucXVhdGVybmlvbi5jb3B5KCBuZXdRdWF0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCA9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuUXVhdGVybmlvbi5zbGVycCggb2JqZWN0LnF1YXRlcm5pb24sIG5ld1F1YXQsIG9iamVjdC5xdWF0ZXJuaW9uLCBwcm9wb3J0aW9uYWxXZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdHlwZSA9PT0gXCJzY2xcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmVjdG9yLnggPSBwcmV2WFlaWyAwIF0gKyAoIG5leHRYWVpbIDAgXSAtIHByZXZYWVpbIDAgXSApICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcuc2NhbGVXZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5zY2FsZS5sZXJwKCBuZXdWZWN0b3IsIHByb3BvcnRpb25hbFdlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmcuc2NhbGVXZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH07XG5cbiAgICB9ICkoKSxcblxuICAgIGdldE5leHRLZXlXaXRoOiBmdW5jdGlvbiggdHlwZSwgaCwga2V5ICkge1xuXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG5cbiAgICAgICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICAgICAgICBrZXkgPSBrZXkgPCBrZXlzLmxlbmd0aCAtIDEgPyBrZXkgOiBrZXlzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAga2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSsrICkge1xuXG4gICAgICAgICAgICBpZiAoIGtleXNbIGtleSBdWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcblxuICAgIH0sXG5cbiAgICBnZXRQcmV2S2V5V2l0aDogZnVuY3Rpb24oIHR5cGUsIGgsIGtleSApIHtcblxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgICAgIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAgICAgICAga2V5ID0ga2V5ID4gMCA/IGtleSA6IDA7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAga2V5ID0ga2V5ID49IDAgPyBrZXkgOiBrZXkgKyBrZXlzLmxlbmd0aDtcblxuICAgICAgICB9XG5cblxuICAgICAgICBmb3IgKCA7IGtleSA+PSAwOyBrZXktLSApIHtcblxuICAgICAgICAgICAgaWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1sga2V5IF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrZXlzLmxlbmd0aCAtIDEgXTtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9LZXlGcmFtZUFuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Iga2hhbmcgZHVvbmdcbiAqIEBhdXRob3IgZXJpayBraXRzb25cbiAqL1xuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gICAgdGhpcy5yb290ID0gZGF0YS5ub2RlO1xuICAgIHRoaXMuZGF0YSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuaW5pdCggZGF0YSApO1xuICAgIHRoaXMuaGllcmFyY2h5ID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZSggdGhpcy5yb290ICk7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy50aW1lU2NhbGUgPSAwLjAwMTtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMubG9vcCA9IHRydWU7XG5cbiAgICAvLyBpbml0aWFsaXplIHRvIGZpcnN0IGtleWZyYW1lc1xuXG4gICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cyxcbiAgICAgICAgICAgIHNpZHMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0uc2lkcyxcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgICAgaWYgKCBrZXlzLmxlbmd0aCAmJiBzaWRzICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgcyA9IDA7IHMgPCBzaWRzLmxlbmd0aDsgcysrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNpZCA9IHNpZHNbIHMgXSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHNpZCwgaCwgMCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBuZXh0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG5leHQuYXBwbHkoIHNpZCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgICAgIG9iai5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5LZXlGcmFtZUFuaW1hdGlvbixcblxuICAgIHBsYXk6IGZ1bmN0aW9uKCBzdGFydFRpbWUgKSB7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gc3RhcnRUaW1lIDogMDtcblxuICAgICAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyByZXNldCBrZXkgY2FjaGVcblxuICAgICAgICAgICAgdmFyIGgsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICBub2RlO1xuXG4gICAgICAgICAgICBmb3IgKCBoID0gMDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgICAgICBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIG5vZGUuYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlID0ge307XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUucHJldktleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXggPSBvYmplY3QubWF0cml4O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcblxuICAgICAgICAgICAgICAgIGlmICgga2V5cy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0ga2V5c1sgMCBdO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBrZXlzWyAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbigga2V5c1sgMCBdLnRpbWUsIHRoaXMuc3RhcnRUaW1lICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kVGltZSA9IE1hdGgubWF4KCBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXS50aW1lLCB0aGlzLmVuZFRpbWUgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSggMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wbGF5KCB0aGlzICk7XG5cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG4gICAgICAgIC8vIHJlc2V0IEpJVCBtYXRyaXggYW5kIHJlbW92ZSBjYWNoZVxuXG4gICAgICAgIGZvciAoIHZhciBoID0gMDsgaCA8IHRoaXMuZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBoKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgICAgICAgIGlmICggbm9kZS5hbmltYXRpb25DYWNoZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gbm9kZS5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeDtcblxuICAgICAgICAgICAgICAgIG9yaWdpbmFsLmNvcHkoIG9iai5tYXRyaXggKTtcbiAgICAgICAgICAgICAgICBvYmoubWF0cml4ID0gb3JpZ2luYWw7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5hbmltYXRpb25DYWNoZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCBkZWx0YSApIHtcblxuICAgICAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cbiAgICAgICAgLy9cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG4gICAgICAgIGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiBkdXJhdGlvbiApIHtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSAlPSBkdXJhdGlvbjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IE1hdGgubWluKCB0aGlzLmN1cnJlbnRUaW1lLCBkdXJhdGlvbiApO1xuXG4gICAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICAgICAgICB2YXIga2V5cyA9IG5vZGUua2V5cyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25DYWNoZSA9IG5vZGUuYW5pbWF0aW9uQ2FjaGU7XG5cblxuICAgICAgICAgICAgaWYgKCBrZXlzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBwcmV2S2V5ID0gYW5pbWF0aW9uQ2FjaGUucHJldktleTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEtleSA9IGFuaW1hdGlvbkNhY2hlLm5leHRLZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG5leHRLZXkudGltZSA8PSB0aGlzLmN1cnJlbnRUaW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldktleSA9IG5leHRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5c1sgcHJldktleS5pbmRleCArIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUucHJldktleSA9IHByZXZLZXk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBuZXh0S2V5O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBuZXh0S2V5LnRpbWUgPj0gdGhpcy5jdXJyZW50VGltZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCB0aGlzLmN1cnJlbnRUaW1lICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldktleS5pbnRlcnBvbGF0ZSggbmV4dEtleSwgbmV4dEtleS50aW1lICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ2V0TmV4dEtleVdpdGg6IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcblxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuICAgICAgICBrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkrKyApIHtcblxuICAgICAgICAgICAgaWYgKCBrZXlzWyBrZXkgXS5oYXNUYXJnZXQoIHNpZCApICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlzWyAwIF07XG5cbiAgICB9LFxuXG4gICAgZ2V0UHJldktleVdpdGg6IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcblxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuICAgICAgICBrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIDsga2V5ID49IDA7IGtleS0tICkge1xuXG4gICAgICAgICAgICBpZiAoIGtleXNbIGtleSBdLmhhc1RhcmdldCggc2lkICkgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1sga2V5IF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL01vcnBoQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxuICogQGF1dGhvciB3aWxseS12dnUgLyBodHRwOi8vd2lsbHktdnZ1LmdpdGh1Yi5pb1xuICovXG5cblRIUkVFLk1vcnBoQW5pbWF0aW9uID0gZnVuY3Rpb24oIG1lc2ggKSB7XG5cbiAgICB0aGlzLm1lc2ggPSBtZXNoO1xuICAgIHRoaXMuZnJhbWVzID0gbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwO1xuICAgIHRoaXMubG9vcCA9IHRydWU7XG4gICAgdGhpcy5sYXN0RnJhbWUgPSAwO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Nb3JwaEFuaW1hdGlvbixcblxuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCBkZWx0YSApIHtcblxuICAgICAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhO1xuXG4gICAgICAgIGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICU9IHRoaXMuZHVyYXRpb247XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1pbiggdGhpcy5jdXJyZW50VGltZSwgdGhpcy5kdXJhdGlvbiApO1xuXG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSB0aGlzLmR1cmF0aW9uIC8gdGhpcy5mcmFtZXM7XG4gICAgICAgIHZhciBmcmFtZSA9IE1hdGguZmxvb3IoIHRoaXMuY3VycmVudFRpbWUgLyBmcmFtZVRpbWUgKTtcblxuICAgICAgICB2YXIgaW5mbHVlbmNlcyA9IHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICAgICAgaWYgKCBmcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUgKSB7XG5cbiAgICAgICAgICAgIGluZmx1ZW5jZXNbIHRoaXMubGFzdEZyYW1lIF0gPSAwO1xuICAgICAgICAgICAgaW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50RnJhbWUgXSA9IDE7XG4gICAgICAgICAgICBpbmZsdWVuY2VzWyBmcmFtZSBdID0gMDtcblxuICAgICAgICAgICAgdGhpcy5sYXN0RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaXggPSAoIHRoaXMuY3VycmVudFRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcblxuICAgICAgICBpbmZsdWVuY2VzWyBmcmFtZSBdID0gbWl4O1xuICAgICAgICBpbmZsdWVuY2VzWyB0aGlzLmxhc3RGcmFtZSBdID0gMSAtIG1peDtcblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL0N1YmUuYXNcbiAqL1xuXG5USFJFRS5Cb3hHZW9tZXRyeSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICAgICAgZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuICAgIH07XG5cbiAgICB0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XG4gICAgdGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG4gICAgdGhpcy5kZXB0aFNlZ21lbnRzID0gZGVwdGhTZWdtZW50cyB8fCAxO1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICAgIHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XG5cbiAgICBidWlsZFBsYW5lKCAneicsICd5JywgLTEsIC0xLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aF9oYWxmLCAwICk7IC8vIHB4XG4gICAgYnVpbGRQbGFuZSggJ3onLCAneScsIDEsIC0xLCBkZXB0aCwgaGVpZ2h0LCAtd2lkdGhfaGFsZiwgMSApOyAvLyBueFxuICAgIGJ1aWxkUGxhbmUoICd4JywgJ3onLCAxLCAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmLCAyICk7IC8vIHB5XG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneicsIDEsIC0xLCB3aWR0aCwgZGVwdGgsIC1oZWlnaHRfaGFsZiwgMyApOyAvLyBueVxuICAgIGJ1aWxkUGxhbmUoICd4JywgJ3knLCAxLCAtMSwgd2lkdGgsIGhlaWdodCwgZGVwdGhfaGFsZiwgNCApOyAvLyBwelxuICAgIGJ1aWxkUGxhbmUoICd4JywgJ3knLCAtMSwgLTEsIHdpZHRoLCBoZWlnaHQsIC1kZXB0aF9oYWxmLCA1ICk7IC8vIG56XG5cbiAgICBmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgICAgICB2YXIgdywgaXgsIGl5LFxuICAgICAgICAgICAgZ3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgZ3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgICAgIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXG4gICAgICAgICAgICBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgICBvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcblxuICAgICAgICAgICAgdyA9ICd6JztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneicgKSB8fCAoIHUgPT09ICd6JyAmJiB2ID09PSAneCcgKSApIHtcblxuICAgICAgICAgICAgdyA9ICd5JztcbiAgICAgICAgICAgIGdyaWRZID0gc2NvcGUuZGVwdGhTZWdtZW50cztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAoIHUgPT09ICd6JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneicgKSApIHtcblxuICAgICAgICAgICAgdyA9ICd4JztcbiAgICAgICAgICAgIGdyaWRYID0gc2NvcGUuZGVwdGhTZWdtZW50cztcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyaWRYMSA9IGdyaWRYICsgMSxcbiAgICAgICAgICAgIGdyaWRZMSA9IGdyaWRZICsgMSxcbiAgICAgICAgICAgIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYLFxuICAgICAgICAgICAgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWSxcbiAgICAgICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgbm9ybWFsWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLTE7XG5cbiAgICAgICAgZm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkrKyApIHtcblxuICAgICAgICAgICAgZm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXgrKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICAgIHZlY3RvclsgdSBdID0gKCBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmICkgKiB1ZGlyO1xuICAgICAgICAgICAgICAgIHZlY3RvclsgdiBdID0gKCBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGYgKSAqIHZkaXI7XG4gICAgICAgICAgICAgICAgdmVjdG9yWyB3IF0gPSBkZXB0aDtcblxuICAgICAgICAgICAgICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkrKyApIHtcblxuICAgICAgICAgICAgZm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuICAgICAgICAgICAgICAgIHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgICAgICAgICAgIHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XG4gICAgICAgICAgICAgICAgdmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XG4gICAgICAgICAgICAgICAgdmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcbiAgICAgICAgICAgICAgICB2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcblxuICAgICAgICAgICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhICsgb2Zmc2V0LCBiICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcbiAgICAgICAgICAgICAgICBmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiArIG9mZnNldCwgYyArIG9mZnNldCwgZCArIG9mZnNldCApO1xuICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG4gICAgICAgICAgICAgICAgZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufTtcblxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3hHZW9tZXRyeTtcblxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRlcHRoLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGVwdGhTZWdtZW50c1xuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblRIUkVFLkN1YmVHZW9tZXRyeSA9IFRIUkVFLkJveEdlb21ldHJ5OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgaHVnaGVzXG4gKi9cblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIGksIHV2cyA9IFtdLFxuICAgICAgICBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBjZW50ZXJVViA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLjUsIDAuNSApO1xuXG4gICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBjZW50ZXIgKTtcbiAgICB1dnMucHVzaCggY2VudGVyVVYgKTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG4gICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICAgICAgdmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG4gICAgICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggKCB2ZXJ0ZXgueCAvIHJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyByYWRpdXMgKyAxICkgLyAyICkgKTtcblxuICAgIH1cblxuICAgIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICAgIGZvciAoIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpKysgKSB7XG5cbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGksIGkgKyAxLCAwLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBpIF0uY2xvbmUoKSwgdXZzWyBpICsgMSBdLmNsb25lKCksIGNlbnRlclVWLmNsb25lKCkgXSApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVHZW9tZXRyeTtcblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5zZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gc2VnbWVudHMgKyAyO1xuXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xuICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKiAzICk7XG4gICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMiApO1xuXG4gICAgLy8gY2VudGVyIGRhdGEgaXMgYWxyZWFkeSB6ZXJvLCBidXQgbmVlZCB0byBzZXQgYSBmZXcgZXh0cmFzXG4gICAgbm9ybWFsc1sgMyBdID0gMS4wO1xuICAgIHV2c1sgMCBdID0gMC41O1xuICAgIHV2c1sgMSBdID0gMC41O1xuXG4gICAgZm9yICggdmFyIHMgPSAwLCBpID0gMywgaWkgPSAyOyBzIDw9IHNlZ21lbnRzOyBzKyssIGkgKz0gMywgaWkgKz0gMiApIHtcblxuICAgICAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuICAgICAgICBwb3NpdGlvbnNbIGkgXSA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG4gICAgICAgIHBvc2l0aW9uc1sgaSArIDEgXSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cbiAgICAgICAgbm9ybWFsc1sgaSArIDIgXSA9IDE7IC8vIG5vcm1hbCB6XG5cbiAgICAgICAgdXZzWyBpaSBdID0gKCBwb3NpdGlvbnNbIGkgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG4gICAgICAgIHV2c1sgaWkgKyAxIF0gPSAoIHBvc2l0aW9uc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG5cbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpKysgKSB7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKCBpICk7XG4gICAgICAgIGluZGljZXMucHVzaCggaSArIDEgKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKCAwICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeTtcblxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5zZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICAgICk7XG5cbiAgICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXNUb3A6IHJhZGl1c1RvcCxcbiAgICAgICAgcmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICAgICAgb3BlbkVuZGVkOiBvcGVuRW5kZWQsXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIH07XG5cbiAgICByYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDIwO1xuICAgIHJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbSAhPT0gdW5kZWZpbmVkID8gcmFkaXVzQm90dG9tIDogMjA7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XG5cbiAgICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XG4gICAgaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xuXG4gICAgb3BlbkVuZGVkID0gb3BlbkVuZGVkICE9PSB1bmRlZmluZWQgPyBvcGVuRW5kZWQgOiBmYWxzZTtcbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiAyICogTWF0aC5QSTtcblxuICAgIHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblxuICAgIHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICB1dnMgPSBbXTtcblxuICAgIGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5KysgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzUm93ID0gW107XG4gICAgICAgIHZhciB1dnNSb3cgPSBbXTtcblxuICAgICAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcbiAgICAgICAgdmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xuXG4gICAgICAgIGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4KysgKSB7XG5cbiAgICAgICAgICAgIHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcbiAgICAgICAgICAgIHZlcnRleC55ID0gLXYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xuICAgICAgICAgICAgdmVydGV4LnogPSByYWRpdXMgKiBNYXRoLmNvcyggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcbiAgICAgICAgICAgIHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuICAgICAgICB1dnMucHVzaCggdXZzUm93ICk7XG5cbiAgICB9XG5cbiAgICB2YXIgdGFuVGhldGEgPSAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApIC8gaGVpZ2h0O1xuICAgIHZhciBuYSwgbmI7XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4KysgKSB7XG5cbiAgICAgICAgaWYgKCByYWRpdXNUb3AgIT09IDAgKSB7XG5cbiAgICAgICAgICAgIG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCBdIF0uY2xvbmUoKTtcbiAgICAgICAgICAgIG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCArIDEgXSBdLmNsb25lKCk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgbmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4IF0gXS5jbG9uZSgpO1xuICAgICAgICAgICAgbmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgbmEuc2V0WSggTWF0aC5zcXJ0KCBuYS54ICogbmEueCArIG5hLnogKiBuYS56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xuICAgICAgICBuYi5zZXRZKCBNYXRoLnNxcnQoIG5iLnggKiBuYi54ICsgbmIueiAqIG5iLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgZm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSsrICkge1xuXG4gICAgICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG4gICAgICAgICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xuICAgICAgICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG4gICAgICAgICAgICB2YXIgdjQgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuXG4gICAgICAgICAgICB2YXIgbjEgPSBuYS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIG4yID0gbmEuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBuMyA9IG5iLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbjQgPSBuYi5jbG9uZSgpO1xuXG4gICAgICAgICAgICB2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHV2MiA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MiwgdjMsIHY0LCBbIG4yLmNsb25lKCksIG4zLCBuNC5jbG9uZSgpIF0gKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gdG9wIGNhcFxuXG4gICAgaWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c1RvcCA+IDAgKSB7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICk7XG5cbiAgICAgICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgMCBdWyB4IF07XG4gICAgICAgICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdO1xuICAgICAgICAgICAgdmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICB2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuICAgICAgICAgICAgdmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcbiAgICAgICAgICAgIHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICAgICAgICAgIHZhciB1djEgPSB1dnNbIDAgXVsgeCBdLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgdXYyID0gdXZzWyAwIF1bIHggKyAxIF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciB1djMgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYyLngsIDAgKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdLCB1bmRlZmluZWQsIDEgKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBib3R0b20gY2FwXG5cbiAgICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzQm90dG9tID4gMCApIHtcblxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtaGVpZ2h0SGFsZiwgMCApICk7XG5cbiAgICAgICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXTtcbiAgICAgICAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF07XG4gICAgICAgICAgICB2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtMSwgMCApO1xuICAgICAgICAgICAgdmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0xLCAwICk7XG4gICAgICAgICAgICB2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTEsIDAgKTtcblxuICAgICAgICAgICAgdmFyIHV2MSA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXS5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIHV2MiA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSwgdW5kZWZpbmVkLCAyICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeTtcblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzVG9wLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzQm90dG9tLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLm9wZW5FbmRlZCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0VkZ2VzR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5FZGdlc0dlb21ldHJ5ID0gZnVuY3Rpb24oIGdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApIHtcblxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRocmVzaG9sZEFuZ2xlID0gKCB0aHJlc2hvbGRBbmdsZSAhPT0gdW5kZWZpbmVkICkgPyB0aHJlc2hvbGRBbmdsZSA6IDE7XG5cbiAgICB2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRocmVzaG9sZEFuZ2xlICkgKTtcblxuICAgIHZhciBlZGdlID0gWyAwLCAwIF0sXG4gICAgICAgIGhhc2ggPSB7fTtcbiAgICB2YXIgc29ydEZ1bmN0aW9uID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuXG4gICAgfTtcblxuICAgIHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cbiAgICB2YXIgZ2VvbWV0cnkyO1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgIGdlb21ldHJ5MiA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICBnZW9tZXRyeTIuZnJvbUJ1ZmZlckdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICBnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xuICAgIGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5Mi52ZXJ0aWNlcztcbiAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGorKyApIHtcblxuICAgICAgICAgICAgZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgICAgICAgICBlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcbiAgICAgICAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICAgICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGhhc2hbIGtleSBdID0ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0MTogZWRnZVsgMCBdLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0MjogZWRnZVsgMSBdLFxuICAgICAgICAgICAgICAgICAgICBmYWNlMTogaSxcbiAgICAgICAgICAgICAgICAgICAgZmFjZTI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaGFzaFsga2V5IF0uZmFjZTIgPSBpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGtleSBpbiBoYXNoICkge1xuXG4gICAgICAgIHZhciBoID0gaGFzaFsga2V5IF07XG5cbiAgICAgICAgaWYgKCBoLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGguZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgaC5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnggKTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnggKTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGNvb3JkcyApLCAzICkgKTtcblxufTtcblxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cbiAqICBhbW91bnQ6IDxpbnQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxuICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXG4gKlxuICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcbiAqICBmcmFtZXM6IDxUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzPiAvLyBjb250YWluaW5nIGFycmF5cyBvZiB0YW5nZW50cywgbm9ybWFscywgYmlub3JtYWxzXG4gKlxuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gKlxuICogfVxuICoqL1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkgPSBmdW5jdGlvbiggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gICAgaWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xuXG4gICAgICAgIHNoYXBlcyA9IFtdO1xuICAgICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcblxuICAgIHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcblxuICAgIHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICAvLyBjYW4ndCByZWFsbHkgdXNlIGF1dG9tYXRpYyB2ZXJ0ZXggbm9ybWFsc1xuICAgIC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xuICAgIC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcblxuICAgIC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgLy9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnk7XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24oIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICAgIHZhciBzbCA9IHNoYXBlcy5sZW5ndGg7XG5cbiAgICBmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcysrICkge1xuXG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1sgcyBdO1xuICAgICAgICB0aGlzLmFkZFNoYXBlKCBzaGFwZSwgb3B0aW9ucyApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oIHNoYXBlLCBvcHRpb25zICkge1xuXG4gICAgdmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcblxuICAgIHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxuICAgIHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcbiAgICB2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblxuICAgIHZhciBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlOyAvLyBmYWxzZVxuXG4gICAgdmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG4gICAgdmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XG5cbiAgICB2YXIgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xuICAgIHZhciBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XG5cbiAgICAvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cbiAgICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XG5cbiAgICB2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuICAgIGlmICggZXh0cnVkZVBhdGggKSB7XG5cbiAgICAgICAgZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuICAgICAgICBleHRydWRlQnlQYXRoID0gdHJ1ZTtcbiAgICAgICAgYmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxuXG4gICAgICAgIC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuICAgICAgICAvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxuICAgICAgICAvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xuXG4gICAgICAgIHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggZXh0cnVkZVBhdGgsIHN0ZXBzLCBmYWxzZSApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG4gICAgICAgIGJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxuXG4gICAgaWYgKCAhYmV2ZWxFbmFibGVkICkge1xuXG4gICAgICAgIGJldmVsU2VnbWVudHMgPSAwO1xuICAgICAgICBiZXZlbFRoaWNrbmVzcyA9IDA7XG4gICAgICAgIGJldmVsU2l6ZSA9IDA7XG5cbiAgICB9XG5cbiAgICAvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cblxuICAgIHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG4gICAgdmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG4gICAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cbiAgICB2YXIgcmV2ZXJzZSA9ICFUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuICAgIGlmICggcmV2ZXJzZSApIHtcblxuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuICAgICAgICAvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG4gICAgICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgICAgICAgICAgaWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcblxuICAgICAgICAgICAgICAgIGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlOyAvLyBJZiB2ZXJ0aWNlcyBhcmUgaW4gb3JkZXIgbm93LCB3ZSBzaG91bGRuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVtIGFnYWluIChob3BlZnVsbHkpIVxuXG4gICAgfVxuXG5cbiAgICB2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuICAgIC8qIFZlcnRpY2VzICovXG5cbiAgICB2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG4gICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG5cbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XG5cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHNjYWxlUHQyKCBwdCwgdmVjLCBzaXplICkge1xuXG4gICAgICAgIGlmICggIXZlYyApIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3RcIiApO1xuXG4gICAgICAgIHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcblxuICAgIH1cblxuICAgIHZhciBiLCBicywgdCwgeixcbiAgICAgICAgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG4gICAgLy8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxuXG5cbiAgICBmdW5jdGlvbiBnZXRCZXZlbFZlYyggaW5QdCwgaW5QcmV2LCBpbk5leHQgKSB7XG5cbiAgICAgICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAgICAgLy8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuICAgICAgICAvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG4gICAgICAgIC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxuICAgICAgICAvL1xuICAgICAgICAvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuICAgICAgICAvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxuXG4gICAgICAgIHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5ID0gMTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG4gICAgICAgIC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcbiAgICAgICAgLy8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuICAgICAgICB2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCxcbiAgICAgICAgICAgIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG4gICAgICAgIHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LFxuICAgICAgICAgICAgdl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcblxuICAgICAgICB2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcbiAgICAgICAgdmFyIGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cbiAgICAgICAgaWYgKCBNYXRoLmFicyggY29sbGluZWFyMCApID4gRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgLy8gbm90IGNvbGxpbmVhclxuXG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcblxuICAgICAgICAgICAgdmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuICAgICAgICAgICAgdmFyIHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XG5cbiAgICAgICAgICAgIC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcblxuICAgICAgICAgICAgdmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XG4gICAgICAgICAgICB2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblxuICAgICAgICAgICAgdmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XG4gICAgICAgICAgICB2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcblxuICAgICAgICAgICAgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuICAgICAgICAgICAgdmFyIHNmID0gKCAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXG4gICAgICAgICAgICAgICAgICAgICggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICkgL1xuICAgICAgICAgICAgICAgICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuICAgICAgICAgICAgLy8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuICAgICAgICAgICAgdl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xuICAgICAgICAgICAgdl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuICAgICAgICAgICAgLy8gIGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xuICAgICAgICAgICAgdmFyIHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xuICAgICAgICAgICAgaWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuICAgICAgICAgICAgaWYgKCB2X3ByZXZfeCA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZfbmV4dF94ID4gRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICggdl9wcmV2X3ggPCAtRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZfbmV4dF94IDwgLUVQU0lMT04gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZGlyZWN0aW9uX2VxICkge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcbiAgICAgICAgICAgICAgICB2X3RyYW5zX3ggPSAtdl9wcmV2X3k7XG4gICAgICAgICAgICAgICAgdl90cmFuc195ID0gdl9wcmV2X3g7XG4gICAgICAgICAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuICAgICAgICAgICAgICAgIHZfdHJhbnNfeCA9IHZfcHJldl94O1xuICAgICAgICAgICAgICAgIHZfdHJhbnNfeSA9IHZfcHJldl95O1xuICAgICAgICAgICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcblxuICAgIH1cblxuXG4gICAgdmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkrKywgaisrLCBrKysgKSB7XG5cbiAgICAgICAgaWYgKCBqID09PSBpbCApIGogPSAwO1xuICAgICAgICBpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cbiAgICAgICAgLy8gIChqKS0tLShpKS0tLShrKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcblxuICAgICAgICBjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG4gICAgfVxuXG4gICAgdmFyIGhvbGVzTW92ZW1lbnRzID0gW10sXG4gICAgICAgIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG4gICAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcblxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpKyssIGorKywgaysrICkge1xuXG4gICAgICAgICAgICBpZiAoIGogPT09IGlsICkgaiA9IDA7XG4gICAgICAgICAgICBpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cbiAgICAgICAgICAgIC8vICAoaiktLS0oaSktLS0oaylcbiAgICAgICAgICAgIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcbiAgICAgICAgdmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcblxuICAgIH1cblxuXG4gICAgLy8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cbiAgICBmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIrKyApIHtcblxuICAgICAgICAvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuICAgICAgICB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG4gICAgICAgIHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcblxuICAgICAgICAvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XG4gICAgICAgIGJzID0gYmV2ZWxTaXplICogKCBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICkgKTsgLy8gY3VydmVkXG4gICAgICAgIC8vYnMgPSBiZXZlbFNpemUgKiB0OyAvLyBsaW5lYXJcblxuICAgICAgICAvLyBjb250cmFjdCBzaGFwZVxuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksIC16ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4cGFuZCBob2xlc1xuXG4gICAgICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcbiAgICAgICAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgLXogKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGJzID0gYmV2ZWxTaXplO1xuXG4gICAgLy8gQmFjayBmYWNpbmcgdmVydGljZXNcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSsrICkge1xuXG4gICAgICAgIHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cbiAgICAgICAgaWYgKCAhZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuXG4gICAgICAgICAgICBub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG4gICAgICAgICAgICBiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG4gICAgICAgICAgICBwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cbiAgICAgICAgICAgIHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuICAgIC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuICAgIHZhciBzO1xuXG4gICAgZm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMrKyApIHtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkrKyApIHtcblxuICAgICAgICAgICAgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCAhZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgICAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cbiAgICAgICAgICAgICAgICBub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG4gICAgICAgICAgICAgICAgYmlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuICAgICAgICAgICAgICAgIHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLy8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG4gICAgLy9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuICAgIGZvciAoIGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiLS0gKSB7XG5cbiAgICAgICAgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuICAgICAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG4gICAgICAgIC8vYnMgPSBiZXZlbFNpemUgKiAoIDEtTWF0aC5zaW4gKCAoIDEgLSB0ICkgKiBNYXRoLlBJLzIgKSApO1xuICAgICAgICBicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKTtcblxuICAgICAgICAvLyBjb250cmFjdCBzaGFwZVxuXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcbiAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgKyB6ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4cGFuZCBob2xlc1xuXG4gICAgICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcbiAgICAgICAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFleHRydWRlQnlQYXRoICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgKyB6ICk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyogRmFjZXMgKi9cblxuICAgIC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cbiAgICBidWlsZExpZEZhY2VzKCk7XG5cbiAgICAvLyBTaWRlcyBmYWNlc1xuXG4gICAgYnVpbGRTaWRlRmFjZXMoKTtcblxuXG4gICAgLy8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG4gICAgZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcblxuICAgICAgICBpZiAoIGJldmVsRW5hYmxlZCApIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG4gICAgICAgICAgICAvLyBCb3R0b20gZmFjZXNcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcbiAgICAgICAgICAgIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuICAgICAgICAgICAgLy8gVG9wIGZhY2VzXG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEJvdHRvbSBmYWNlc1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICAgICAgICAgIGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVG9wIGZhY2VzXG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgICAgICAgICAgICAgZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cbiAgICBmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcblxuICAgICAgICB2YXIgbGF5ZXJvZmZzZXQgPSAwO1xuICAgICAgICBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XG4gICAgICAgIGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cbiAgICAgICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcbiAgICAgICAgICAgIHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XG5cbiAgICAgICAgICAgIC8vLCB0cnVlXG4gICAgICAgICAgICBsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcblxuICAgICAgICB2YXIgaiwgaztcbiAgICAgICAgaSA9IGNvbnRvdXIubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICggLS1pID49IDAgKSB7XG5cbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgayA9IGkgLSAxO1xuICAgICAgICAgICAgaWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICB2YXIgcyA9IDAsXG4gICAgICAgICAgICAgICAgc2wgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXG4gICAgICAgICAgICBmb3IgKCBzID0gMDsgcyA8IHNsOyBzKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2xlbjEgPSB2bGVuICogcztcbiAgICAgICAgICAgICAgICB2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcbiAgICAgICAgICAgICAgICAgICAgYiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxuICAgICAgICAgICAgICAgICAgICBjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXG4gICAgICAgICAgICAgICAgICAgIGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuICAgICAgICAgICAgICAgIGY0KCBhLCBiLCBjLCBkLCBjb250b3VyLCBzLCBzbCwgaiwgayApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG4gICAgICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xuXG4gICAgICAgIGEgKz0gc2hhcGVzT2Zmc2V0O1xuICAgICAgICBiICs9IHNoYXBlc09mZnNldDtcbiAgICAgICAgYyArPSBzaGFwZXNPZmZzZXQ7XG5cbiAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjICkgKTtcblxuICAgICAgICB2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIGEsIGIsIGMgKTtcblxuICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZzICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XG5cbiAgICAgICAgYSArPSBzaGFwZXNPZmZzZXQ7XG4gICAgICAgIGIgKz0gc2hhcGVzT2Zmc2V0O1xuICAgICAgICBjICs9IHNoYXBlc09mZnNldDtcbiAgICAgICAgZCArPSBzaGFwZXNPZmZzZXQ7XG5cbiAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblxuICAgICAgICB2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKCBzY29wZSwgYSwgYiwgYywgZCApO1xuXG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMCBdLCB1dnNbIDEgXSwgdXZzWyAzIF0gXSApO1xuICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDEgXSwgdXZzWyAyIF0sIHV2c1sgMyBdIF0gKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgPSB7XG5cbiAgICBnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgdmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XG4gICAgICAgIHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuICAgICAgICB2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgYS55ICksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi54LCBiLnkgKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIGMueSApXG4gICAgICAgIF07XG5cbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgICB2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcbiAgICAgICAgdmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XG4gICAgICAgIHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuICAgICAgICB2YXIgZCA9IHZlcnRpY2VzWyBpbmRleEQgXTtcblxuICAgICAgICBpZiAoIE1hdGguYWJzKCBhLnkgLSBiLnkgKSA8IDAuMDEgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIDEgLSBiLnogKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYy54LCAxIC0gYy56ICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueSwgMSAtIGEueiApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYy55LCAxIC0gYy56ICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGQueSwgMSAtIGQueiApXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgIH1cblxuICAgIH1cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NoYXBlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cbiAqXG4gKiBDcmVhdGVzIGEgb25lLXNpZGVkIHBvbHlnb25hbCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS4gU2ltaWxhciB0b1xuICogRXh0cnVkZUdlb21ldHJ5LlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICpcdGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXG4gKlxuICpcdG1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZnJvbnQgYW5kIGJhY2sgZmFjZXNcbiAqXHR1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqKi9cblxuVEhSRUUuU2hhcGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHNoYXBlcyA9IFsgc2hhcGVzIF07XG5cbiAgICB0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZUdlb21ldHJ5O1xuXG4vKipcbiAqIEFkZCBhbiBhcnJheSBvZiBzaGFwZXMgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24oIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgdGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIEFkZHMgYSBzaGFwZSB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LCBiYXNlZCBvbiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuXG4gKi9cblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oIHNoYXBlLCBvcHRpb25zICkge1xuXG4gICAgaWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSBvcHRpb25zID0ge307XG4gICAgdmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG4gICAgdmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcbiAgICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yID09PSB1bmRlZmluZWQgPyBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA6IG9wdGlvbnMuVVZHZW5lcmF0b3I7XG5cbiAgICAvL1xuXG4gICAgdmFyIGksIGwsIGhvbGU7XG5cbiAgICB2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgdmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG4gICAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cbiAgICB2YXIgcmV2ZXJzZSA9ICFUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuICAgIGlmICggcmV2ZXJzZSApIHtcblxuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuICAgICAgICAvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlLi4uXG5cbiAgICAgICAgZm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGhvbGUgPSBob2xlc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBob2xlICkgKSB7XG5cbiAgICAgICAgICAgICAgICBob2xlc1sgaSBdID0gaG9sZS5yZXZlcnNlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgdmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cbiAgICAvLyBWZXJ0aWNlc1xuXG4gICAgZm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgaG9sZSA9IGhvbGVzWyBpIF07XG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgdmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgdmFyIGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkrKyApIHtcblxuICAgICAgICB2ZXJ0ID0gdmVydGljZXNbIGkgXTtcblxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0LngsIHZlcnQueSwgMCApICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkrKyApIHtcblxuICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICB2YXIgYSA9IGZhY2VbIDAgXSArIHNoYXBlc09mZnNldDtcbiAgICAgICAgdmFyIGIgPSBmYWNlWyAxIF0gKyBzaGFwZXNPZmZzZXQ7XG4gICAgICAgIHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtYXRlcmlhbCApICk7XG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHRoaXMsIGEsIGIsIGMgKSApO1xuXG4gICAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9MYXRoZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG4vLyBwb2ludHMgLSB0byBjcmVhdGUgYSBjbG9zZWQgdG9ydXMsIG9uZSBtdXN0IHVzZSBhIHNldCBvZiBwb2ludHNcbi8vICAgIGxpa2Ugc286IFsgYSwgYiwgYywgZCwgYSBdLCBzZWUgZmlyc3QgaXMgdGhlIHNhbWUgYXMgbGFzdC5cbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxuLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXG4vLyBwaGlMZW5ndGggLSB0aGUgcmFkaWFuICgwIHRvIDIqUEkpIHJhbmdlIG9mIHRoZSBsYXRoZWQgc2VjdGlvblxuLy8gICAgMipwaSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXG5cblRIUkVFLkxhdGhlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICAgICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgICAgICBwaGlMZW5ndGg6IHBoaUxlbmd0aFxuICAgIH07XG5cbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDEyO1xuICAgIHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcbiAgICBwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XG5cbiAgICB2YXIgaW52ZXJzZVBvaW50TGVuZ3RoID0gMS4wIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8PSBpbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggcGhpICksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oIHBoaSApO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgdmFyIHB0ID0gcG9pbnRzWyBqIF07XG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICB2ZXJ0ZXgueCA9IGMgKiBwdC54IC0gcyAqIHB0Lnk7XG4gICAgICAgICAgICB2ZXJ0ZXgueSA9IHMgKiBwdC54ICsgYyAqIHB0Lnk7XG4gICAgICAgICAgICB2ZXJ0ZXgueiA9IHB0Lno7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIG5wID0gcG9pbnRzLmxlbmd0aDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGggLSAxOyBqIDwgamw7IGorKyApIHtcblxuICAgICAgICAgICAgdmFyIGJhc2UgPSBqICsgbnAgKiBpO1xuICAgICAgICAgICAgdmFyIGEgPSBiYXNlO1xuICAgICAgICAgICAgdmFyIGIgPSBiYXNlICsgbnA7XG4gICAgICAgICAgICB2YXIgYyA9IGJhc2UgKyAxICsgbnA7XG4gICAgICAgICAgICB2YXIgZCA9IGJhc2UgKyAxO1xuXG4gICAgICAgICAgICB2YXIgdTAgPSBpICogaW52ZXJzZVNlZ21lbnRzO1xuICAgICAgICAgICAgdmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcbiAgICAgICAgICAgIHZhciB1MSA9IHUwICsgaW52ZXJzZVNlZ21lbnRzO1xuICAgICAgICAgICAgdmFyIHYxID0gdjAgKyBpbnZlcnNlUG9pbnRMZW5ndGg7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MCApLFxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuICAgICAgICAgICAgXSApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYxICksXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXG5cbiAgICAgICAgICAgIF0gKTtcblxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MYXRoZUdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cblRIUkVFLlBsYW5lR2VvbWV0cnkgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuICAgIH07XG5cbiAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkgKTtcblxufTtcblxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGxhbmVHZW9tZXRyeTtcblxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGgsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHNcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuICAgIH07XG5cbiAgICB2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXG4gICAgdmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XG4gICAgdmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuXG4gICAgdmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcbiAgICB2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG4gICAgdmFyIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuICAgIHZhciBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAyICk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgb2Zmc2V0MiA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkrKyApIHtcblxuICAgICAgICB2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuICAgICAgICBmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXgrKyApIHtcblxuICAgICAgICAgICAgdmFyIHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlc1sgb2Zmc2V0IF0gPSB4O1xuICAgICAgICAgICAgdmVydGljZXNbIG9mZnNldCArIDEgXSA9IC15O1xuXG4gICAgICAgICAgICBub3JtYWxzWyBvZmZzZXQgKyAyIF0gPSAxO1xuXG4gICAgICAgICAgICB1dnNbIG9mZnNldDIgXSA9IGl4IC8gZ3JpZFg7XG4gICAgICAgICAgICB1dnNbIG9mZnNldDIgKyAxIF0gPSAxIC0gKCBpeSAvIGdyaWRZICk7XG5cbiAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgb2Zmc2V0MiArPSAyO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG9mZnNldCA9IDA7XG5cbiAgICB2YXIgaW5kaWNlcyA9IG5ldyggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggZ3JpZFggKiBncmlkWSAqIDYgKTtcblxuICAgIGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5KysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDsgaXgrKyApIHtcblxuICAgICAgICAgICAgdmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuICAgICAgICAgICAgdmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgICAgICAgICB2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgICAgICAgdmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCBdID0gYTtcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDEgXSA9IGI7XG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgKyAyIF0gPSBkO1xuXG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgKyAzIF0gPSBiO1xuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgNCBdID0gYztcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDUgXSA9IGQ7XG5cbiAgICAgICAgICAgIG9mZnNldCArPSA2O1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxufTtcblxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeTtcblxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGgsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHQsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHNcbiAgICApO1xuXG4gICAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9SaW5nR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIEthbGViIE11cnBoeVxuICovXG5cblRIUkVFLlJpbmdHZW9tZXRyeSA9IGZ1bmN0aW9uKCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICAgICAgdGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcbiAgICAgICAgcGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuXG4gICAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAwO1xuICAgIG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XG5cbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICAgIHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcbiAgICBwaGlTZWdtZW50cyA9IHBoaVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKSA6IDg7XG5cbiAgICB2YXIgaSwgbywgdXZzID0gW10sXG4gICAgICAgIHJhZGl1cyA9IGlubmVyUmFkaXVzLFxuICAgICAgICByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzICsgMTsgaSsrICkge1xuXG4gICAgICAgIC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xuXG4gICAgICAgIGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyArIDE7IG8rKyApIHtcblxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHNlZ21lbnRzIHBlciBjaXJjbGVcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBvIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuICAgICAgICAgICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuICAgICAgICAgICAgdmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuICAgICAgICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cbiAgICB9XG5cbiAgICB2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzOyBpKysgKSB7XG5cbiAgICAgICAgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cbiAgICAgICAgdmFyIHRoZXRhU2VnbWVudCA9IGkgKiAoIHRoZXRhU2VnbWVudHMgKyAxICk7XG5cbiAgICAgICAgZm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzOyBvKysgKSB7XG5cbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gbyArIHRoZXRhU2VnbWVudDtcblxuICAgICAgICAgICAgdmFyIHYxID0gc2VnbWVudDtcbiAgICAgICAgICAgIHZhciB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcbiAgICAgICAgICAgIHZhciB2MyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgICAgICAgIHYxID0gc2VnbWVudDtcbiAgICAgICAgICAgIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuICAgICAgICAgICAgdjMgPSBzZWdtZW50ICsgMTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJpbmdHZW9tZXRyeTtcblxuVEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmlubmVyUmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMub3V0ZXJSYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVNlZ21lbnRzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucGhpU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgICAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuXG4gICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xuXG59O1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUdlb21ldHJ5O1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBoaVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucGhpTGVuZ3RoLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqIGJhc2VkIG9uIFRIUkVFLlNwaGVyZUdlb21ldHJ5XG4gKi9cblxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgICAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuXG4gICAgd2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xuICAgIGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xuXG4gICAgcGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xuICAgIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xuXG4gICAgdmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xuXG4gICAgdmFyIHZlcnRleENvdW50ID0gKCAoIHdpZHRoU2VnbWVudHMgKyAxICkgKiAoIGhlaWdodFNlZ21lbnRzICsgMSApICk7XG5cbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICB2YXIgbm9ybWFscyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gICAgdmFyIHV2cyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMiApLCAyICk7XG5cbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZm9yICggdmFyIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5KysgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzUm93ID0gW107XG5cbiAgICAgICAgdmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cbiAgICAgICAgZm9yICggdmFyIHggPSAwOyB4IDw9IHdpZHRoU2VnbWVudHM7IHgrKyApIHtcblxuICAgICAgICAgICAgdmFyIHUgPSB4IC8gd2lkdGhTZWdtZW50cztcblxuICAgICAgICAgICAgdmFyIHB4ID0gLXJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG4gICAgICAgICAgICB2YXIgcHkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgICAgICAgICAgdmFyIHB6ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblxuICAgICAgICAgICAgbm9ybWFsLnNldCggcHgsIHB5LCBweiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICBwb3NpdGlvbnMuc2V0WFlaKCBpbmRleCwgcHgsIHB5LCBweiApO1xuICAgICAgICAgICAgbm9ybWFscy5zZXRYWVooIGluZGV4LCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG4gICAgICAgICAgICB1dnMuc2V0WFkoIGluZGV4LCB1LCAxIC0gdiApO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCBpbmRleCApO1xuXG4gICAgICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG4gICAgfVxuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgIGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5KysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCsrICkge1xuXG4gICAgICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuICAgICAgICAgICAgdmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xuICAgICAgICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcbiAgICAgICAgICAgIHZhciB2NCA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIHkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIHYxLCB2MiwgdjQgKTtcbiAgICAgICAgICAgIGlmICggeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggdjIsIHYzLCB2NCApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggaW5kaWNlcyApLCAxICkgKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xuXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xuXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBoaVN0YXJ0LFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucGhpTGVuZ3RoLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVGV4dEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBGb3IgY3JlYXRpbmcgM0QgdGV4dCBnZW9tZXRyeSBpbiB0aHJlZS5qc1xuICpcbiAqIFRleHQgPSAzRCBUZXh0XG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBzaXplOiBcdFx0XHQ8ZmxvYXQ+LCBcdC8vIHNpemUgb2YgdGhlIHRleHRcbiAqICBoZWlnaHQ6IFx0XHQ8ZmxvYXQ+LCBcdC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcbiAqICBjdXJ2ZVNlZ21lbnRzOiBcdDxpbnQ+LFx0XHQvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqXG4gKiAgZm9udDogXHRcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgbmFtZVxuICogIHdlaWdodDogXHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHdlaWdodCAobm9ybWFsLCBib2xkKVxuICogIHN0eWxlOiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBzdHlsZSAgKG5vcm1hbCwgaXRhbGljcylcbiAqXG4gKiAgYmV2ZWxFbmFibGVkOlx0PGJvb2w+LFx0XHRcdC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgXHRcdC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXG4gKiAgYmV2ZWxTaXplOlx0XHQ8ZmxvYXQ+LCBcdFx0Ly8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxuICogIH1cbiAqXG4gKi9cblxuLypcdFVzYWdlIEV4YW1wbGVzXG5cblx0Ly8gVGV4dEdlb21ldHJ5IHdyYXBwZXJcblxuXHR2YXIgdGV4dDNkID0gbmV3IFRleHRHZW9tZXRyeSggdGV4dCwgb3B0aW9ucyApO1xuXG5cdC8vIENvbXBsZXRlIG1hbm5lclxuXG5cdHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBvcHRpb25zICk7XG5cdHZhciB0ZXh0M2QgPSBuZXcgRXh0cnVkZUdlb21ldHJ5KCB0ZXh0U2hhcGVzLCBvcHRpb25zICk7XG5cbiovXG5cblxuVEhSRUUuVGV4dEdlb21ldHJ5ID0gZnVuY3Rpb24oIHRleHQsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgIHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzICk7XG5cbiAgICAvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXG5cbiAgICBwYXJhbWV0ZXJzLmFtb3VudCA9IHBhcmFtZXRlcnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmhlaWdodCA6IDUwO1xuXG4gICAgLy8gZGVmYXVsdHNcblxuICAgIGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xuICAgIGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcbiAgICBpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgVEhSRUUuRXh0cnVkZUdlb21ldHJ5LmNhbGwoIHRoaXMsIHRleHRTaGFwZXMsIHBhcmFtZXRlcnMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xuXG59O1xuXG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRleHRHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxuICovXG5cblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICB0dWJlOiB0dWJlLFxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgICAgICBhcmM6IGFyY1xuICAgIH07XG5cbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xuICAgIHR1YmUgPSB0dWJlIHx8IDQwO1xuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgICB0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjtcbiAgICBhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgdXZzID0gW10sXG4gICAgICAgIG5vcm1hbHMgPSBbXTtcblxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuICAgICAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuICAgICAgICAgICAgY2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xuICAgICAgICAgICAgY2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbiggdSApO1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcbiAgICAgICAgICAgIHZlcnRleC55ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcbiAgICAgICAgICAgIHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgICAgICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHR1YnVsYXJTZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICkgKTtcbiAgICAgICAgICAgIG5vcm1hbHMucHVzaCggdmVydGV4LmNsb25lKCkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIHZhciBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuICAgICAgICAgICAgdmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG4gICAgICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGEgXS5jbG9uZSgpLCB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgWyBub3JtYWxzWyBiIF0uY2xvbmUoKSwgbm9ybWFsc1sgYyBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGMgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ub3J1c0dlb21ldHJ5O1xuXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50dWJlLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy50dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5hcmNcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0tub3RHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0Qvc3JjL2F3YXkzZC9wcmltaXRpdmVzL1RvcnVzS25vdC5hcz9zcGVjPXN2bjI0NzMmcj0yNDczXG4gKi9cblxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICB0dWJlOiB0dWJlLFxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgICAgICBwOiBwLFxuICAgICAgICBxOiBxLFxuICAgICAgICBoZWlnaHRTY2FsZTogaGVpZ2h0U2NhbGVcbiAgICB9O1xuXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcbiAgICB0dWJlID0gdHViZSB8fCA0MDtcbiAgICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xuICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA4O1xuICAgIHAgPSBwIHx8IDI7XG4gICAgcSA9IHEgfHwgMztcbiAgICBoZWlnaHRTY2FsZSA9IGhlaWdodFNjYWxlIHx8IDE7XG5cbiAgICB2YXIgZ3JpZCA9IG5ldyBBcnJheSggcmFkaWFsU2VnbWVudHMgKTtcbiAgICB2YXIgdGFuZyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBiaXRhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKytpICkge1xuXG4gICAgICAgIGdyaWRbIGkgXSA9IG5ldyBBcnJheSggdHVidWxhclNlZ21lbnRzICk7XG4gICAgICAgIHZhciB1ID0gaSAvIHJhZGlhbFNlZ21lbnRzICogMiAqIHAgKiBNYXRoLlBJO1xuICAgICAgICB2YXIgcDEgPSBnZXRQb3MoIHUsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcbiAgICAgICAgdmFyIHAyID0gZ2V0UG9zKCB1ICsgMC4wMSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xuICAgICAgICB0YW5nLnN1YlZlY3RvcnMoIHAyLCBwMSApO1xuICAgICAgICBuLmFkZFZlY3RvcnMoIHAyLCBwMSApO1xuXG4gICAgICAgIGJpdGFuLmNyb3NzVmVjdG9ycyggdGFuZywgbiApO1xuICAgICAgICBuLmNyb3NzVmVjdG9ycyggYml0YW4sIHRhbmcgKTtcbiAgICAgICAgYml0YW4ubm9ybWFsaXplKCk7XG4gICAgICAgIG4ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArK2ogKSB7XG5cbiAgICAgICAgICAgIHZhciB2ID0gaiAvIHR1YnVsYXJTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgdmFyIGN4ID0gLXR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxuICAgICAgICAgICAgdmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cbiAgICAgICAgICAgIHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgcG9zLnggPSBwMS54ICsgY3ggKiBuLnggKyBjeSAqIGJpdGFuLng7XG4gICAgICAgICAgICBwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcbiAgICAgICAgICAgIHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xuXG4gICAgICAgICAgICBncmlkWyBpIF1bIGogXSA9IHRoaXMudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArK2kgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArK2ogKSB7XG5cbiAgICAgICAgICAgIHZhciBpcCA9ICggaSArIDEgKSAlIHJhZGlhbFNlZ21lbnRzO1xuICAgICAgICAgICAgdmFyIGpwID0gKCBqICsgMSApICUgdHVidWxhclNlZ21lbnRzO1xuXG4gICAgICAgICAgICB2YXIgYSA9IGdyaWRbIGkgXVsgaiBdO1xuICAgICAgICAgICAgdmFyIGIgPSBncmlkWyBpcCBdWyBqIF07XG4gICAgICAgICAgICB2YXIgYyA9IGdyaWRbIGlwIF1bIGpwIF07XG4gICAgICAgICAgICB2YXIgZCA9IGdyaWRbIGkgXVsganAgXTtcblxuICAgICAgICAgICAgdmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICAgICAgICAgIHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICAgICAgICAgIHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgICAgICAgdmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgIGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcblxuICAgICAgICB2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xuICAgICAgICB2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xuICAgICAgICB2YXIgcXVPdmVyUCA9IGluX3EgLyBpbl9wICogdTtcbiAgICAgICAgdmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcblxuICAgICAgICB2YXIgdHggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XG4gICAgICAgIHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcbiAgICAgICAgdmFyIHR6ID0gaGVpZ2h0U2NhbGUgKiByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdHgsIHR5LCB0eiApO1xuXG4gICAgfVxuXG59O1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5O1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeShcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnR1YmUsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnR1YnVsYXJTZWdtZW50cyxcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnAsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5xLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2NhbGVcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxuICpcbiAqIE1vZGlmaWVkIGZyb20gdGhlIFRvcnVzS25vdEdlb21ldHJ5IGJ5IEBvb3Ntb3hpZWNvZGVcbiAqXG4gKiBDcmVhdGVzIGEgdHViZSB3aGljaCBleHRydWRlcyBhbG9uZyBhIDNkIHNwbGluZVxuICpcbiAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cbiAqIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxuICovXG5cblRIUkVFLlR1YmVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwYXRoLCBzZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkLCB0YXBlciApIHtcblxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgICAgIGNsb3NlZDogY2xvc2VkXG4gICAgfTtcblxuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgfHwgNjQ7XG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICAgIGNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcbiAgICB0YXBlciA9IHRhcGVyIHx8IFRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyO1xuXG4gICAgdmFyIGdyaWQgPSBbXTtcblxuICAgIHZhciBzY29wZSA9IHRoaXMsXG5cbiAgICAgICAgdGFuZ2VudCxcbiAgICAgICAgbm9ybWFsLFxuICAgICAgICBiaW5vcm1hbCxcblxuICAgICAgICBudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXG5cbiAgICAgICAgdSwgdiwgcixcblxuICAgICAgICBjeCwgY3ksXG4gICAgICAgIHBvcywgcG9zMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIGksIGosXG4gICAgICAgIGlwLCBqcCxcbiAgICAgICAgYSwgYiwgYywgZCxcbiAgICAgICAgdXZhLCB1dmIsIHV2YywgdXZkO1xuXG4gICAgdmFyIGZyYW1lcyA9IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICksXG4gICAgICAgIHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxuICAgICAgICBub3JtYWxzID0gZnJhbWVzLm5vcm1hbHMsXG4gICAgICAgIGJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XG5cbiAgICAvLyBwcm94eSBpbnRlcm5hbHNcbiAgICB0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG4gICAgdGhpcy5ub3JtYWxzID0gbm9ybWFscztcbiAgICB0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuICAgIGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XG5cbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGdyaWRcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XG5cbiAgICAgICAgZ3JpZFsgaSBdID0gW107XG5cbiAgICAgICAgdSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcblxuICAgICAgICBwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcblxuICAgICAgICB0YW5nZW50ID0gdGFuZ2VudHNbIGkgXTtcbiAgICAgICAgbm9ybWFsID0gbm9ybWFsc1sgaSBdO1xuICAgICAgICBiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xuXG4gICAgICAgIHIgPSByYWRpdXMgKiB0YXBlciggdSApO1xuXG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGorKyApIHtcblxuICAgICAgICAgICAgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICAgICAgICBjeCA9IC1yICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cbiAgICAgICAgICAgIGN5ID0gciAqIE1hdGguc2luKCB2ICk7XG5cbiAgICAgICAgICAgIHBvczIuY29weSggcG9zICk7XG4gICAgICAgICAgICBwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcbiAgICAgICAgICAgIHBvczIueSArPSBjeCAqIG5vcm1hbC55ICsgY3kgKiBiaW5vcm1hbC55O1xuICAgICAgICAgICAgcG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XG5cbiAgICAgICAgICAgIGdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLy8gY29uc3RydWN0IHRoZSBtZXNoXG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKysgKSB7XG5cbiAgICAgICAgZm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaisrICkge1xuXG4gICAgICAgICAgICBpcCA9ICggY2xvc2VkICkgPyAoIGkgKyAxICkgJSBzZWdtZW50cyA6IGkgKyAxO1xuICAgICAgICAgICAganAgPSAoIGogKyAxICkgJSByYWRpYWxTZWdtZW50cztcblxuICAgICAgICAgICAgYSA9IGdyaWRbIGkgXVsgaiBdOyAvLyAqKiogTk9UIE5FQ0VTU0FSSUxZIFBMQU5BUiAhICoqKlxuICAgICAgICAgICAgYiA9IGdyaWRbIGlwIF1bIGogXTtcbiAgICAgICAgICAgIGMgPSBncmlkWyBpcCBdWyBqcCBdO1xuICAgICAgICAgICAgZCA9IGdyaWRbIGkgXVsganAgXTtcblxuICAgICAgICAgICAgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICAgICAgICB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xuICAgICAgICAgICAgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuICAgICAgICAgICAgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgKCBqICsgMSApIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UdWJlR2VvbWV0cnk7XG5cblRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyID0gZnVuY3Rpb24oIHUgKSB7XG5cbiAgICByZXR1cm4gMTtcblxufTtcblxuVEhSRUUuVHViZUdlb21ldHJ5LlNpbnVzb2lkYWxUYXBlciA9IGZ1bmN0aW9uKCB1ICkge1xuXG4gICAgcmV0dXJuIE1hdGguc2luKCBNYXRoLlBJICogdSApO1xuXG59O1xuXG4vLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcblRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMgPSBmdW5jdGlvbiggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcblxuICAgIHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICAgIHRhbmdlbnRzID0gW10sXG4gICAgICAgIG5vcm1hbHMgPSBbXSxcbiAgICAgICAgYmlub3JtYWxzID0gW10sXG5cbiAgICAgICAgdmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgbWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuICAgICAgICBudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXG4gICAgICAgIHRoZXRhLFxuICAgICAgICBlcHNpbG9uID0gMC4wMDAxLFxuICAgICAgICBzbWFsbGVzdCxcblxuICAgICAgICB0eCwgdHksIHR6LFxuICAgICAgICBpLCB1O1xuXG5cbiAgICAvLyBleHBvc2UgaW50ZXJuYWxzXG4gICAgdGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuICAgIHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XG4gICAgdGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XG5cbiAgICAvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcblxuICAgICAgICB1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgICAgIHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xuICAgICAgICB0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xuXG4gICAgfVxuXG4gICAgaW5pdGlhbE5vcm1hbDMoKTtcblxuICAgIC8qXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xuXHRcdC8vIGZpeGVkIHN0YXJ0IGJpbm9ybWFsLiBIYXMgZGFuZ2VycyBvZiAwIHZlY3RvcnNcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRpZiAobGFzdEJpbm9ybWFsPT09dW5kZWZpbmVkKSBsYXN0Qmlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcblxuXHRcdC8vIFRoaXMgdXNlcyB0aGUgRnJlbmV0LVNlcnJldCBmb3JtdWxhIGZvciBkZXJpdmluZyBiaW5vcm1hbFxuXHRcdHZhciB0MiA9IHBhdGguZ2V0VGFuZ2VudEF0KCBlcHNpbG9uICk7XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBiaW5vcm1hbHNbIDAgXSwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpOyAvLyBsYXN0IGJpbm9ybWFsIHggdGFuZ2VudFxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG5cblx0fVxuXHQqL1xuXG4gICAgZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDMoKSB7XG5cbiAgICAgICAgLy8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3RvcixcbiAgICAgICAgLy8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG4gICAgICAgIG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgc21hbGxlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcbiAgICAgICAgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XG4gICAgICAgIHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xuXG4gICAgICAgIGlmICggdHggPD0gc21hbGxlc3QgKSB7XG5cbiAgICAgICAgICAgIHNtYWxsZXN0ID0gdHg7XG4gICAgICAgICAgICBub3JtYWwuc2V0KCAxLCAwLCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHkgPD0gc21hbGxlc3QgKSB7XG5cbiAgICAgICAgICAgIHNtYWxsZXN0ID0gdHk7XG4gICAgICAgICAgICBub3JtYWwuc2V0KCAwLCAxLCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHogPD0gc21hbGxlc3QgKSB7XG5cbiAgICAgICAgICAgIG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XG4gICAgICAgIGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cbiAgICB9XG5cblxuICAgIC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXG5cbiAgICBmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSsrICkge1xuXG4gICAgICAgIG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuICAgICAgICBiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG4gICAgICAgIHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cbiAgICAgICAgaWYgKCB2ZWMubGVuZ3RoKCkgPiBlcHNpbG9uICkge1xuXG4gICAgICAgICAgICB2ZWMubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLTEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXG5cbiAgICAgICAgICAgIG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgYmlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuICAgIH1cblxuXG4gICAgLy8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxuXG4gICAgaWYgKCBjbG9zZWQgKSB7XG5cbiAgICAgICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApLCAtMSwgMSApICk7XG4gICAgICAgIHRoZXRhIC89ICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgICAgIGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICkgKSA+IDAgKSB7XG5cbiAgICAgICAgICAgIHRoZXRhID0gLXRoZXRhO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSsrICkge1xuXG4gICAgICAgICAgICAvLyB0d2lzdCBhIGxpdHRsZS4uLlxuICAgICAgICAgICAgbm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XG4gICAgICAgICAgICBiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUG9seWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICB9O1xuXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gICAgZGV0YWlsID0gZGV0YWlsIHx8IDA7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgcHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMudmVydGljZXM7XG5cbiAgICB2YXIgZmFjZXMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMywgaisrICkge1xuXG4gICAgICAgIHZhciB2MSA9IHBbIGluZGljZXNbIGkgXSBdO1xuICAgICAgICB2YXIgdjIgPSBwWyBpbmRpY2VzWyBpICsgMSBdIF07XG4gICAgICAgIHZhciB2MyA9IHBbIGluZGljZXNbIGkgKyAyIF0gXTtcblxuICAgICAgICBmYWNlc1sgaiBdID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBqICk7XG5cbiAgICB9XG5cbiAgICB2YXIgY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgIHN1YmRpdmlkZSggZmFjZXNbIGkgXSwgZGV0YWlsICk7XG5cbiAgICB9XG5cblxuICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgICAgICB2YXIgeDAgPSB1dnNbIDAgXS54O1xuICAgICAgICB2YXIgeDEgPSB1dnNbIDEgXS54O1xuICAgICAgICB2YXIgeDIgPSB1dnNbIDIgXS54O1xuXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heCggeDAsIE1hdGgubWF4KCB4MSwgeDIgKSApO1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oIHgwLCBNYXRoLm1pbiggeDEsIHgyICkgKTtcblxuICAgICAgICBpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XG5cbiAgICAgICAgICAgIC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcblxuICAgICAgICAgICAgaWYgKCB4MCA8IDAuMiApIHV2c1sgMCBdLnggKz0gMTtcbiAgICAgICAgICAgIGlmICggeDEgPCAwLjIgKSB1dnNbIDEgXS54ICs9IDE7XG4gICAgICAgICAgICBpZiAoIHgyIDwgMC4yICkgdXZzWyAyIF0ueCArPSAxO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLy8gQXBwbHkgcmFkaXVzXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICB0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBNZXJnZSB2ZXJ0aWNlc1xuXG4gICAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG5cbiAgICAvLyBQcm9qZWN0IHZlY3RvciBvbnRvIHNwaGVyZSdzIHN1cmZhY2VcblxuICAgIGZ1bmN0aW9uIHByZXBhcmUoIHZlY3RvciApIHtcblxuICAgICAgICB2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XG4gICAgICAgIHZlcnRleC5pbmRleCA9IHRoYXQudmVydGljZXMucHVzaCggdmVydGV4ICkgLSAxO1xuXG4gICAgICAgIC8vIFRleHR1cmUgY29vcmRzIGFyZSBlcXVpdmFsZW50IHRvIG1hcCBjb29yZHMsIGNhbGN1bGF0ZSBhbmdsZSBhbmQgY29udmVydCB0byBmcmFjdGlvbiBvZiBhIGNpcmNsZS5cblxuICAgICAgICB2YXIgdSA9IGF6aW11dGgoIHZlY3RvciApIC8gMiAvIE1hdGguUEkgKyAwLjU7XG4gICAgICAgIHZhciB2ID0gaW5jbGluYXRpb24oIHZlY3RvciApIC8gTWF0aC5QSSArIDAuNTtcbiAgICAgICAgdmVydGV4LnV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICk7XG5cbiAgICAgICAgcmV0dXJuIHZlcnRleDtcblxuICAgIH1cblxuXG4gICAgLy8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cblxuICAgIGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdLCB1bmRlZmluZWQsIG1hdGVyaWFsSW5kZXggKTtcbiAgICAgICAgdGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICAgICAgY2VudHJvaWQuY29weSggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xuXG4gICAgICAgIHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xuXG4gICAgICAgIHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcbiAgICAgICAgICAgIGNvcnJlY3RVViggdjEudXYsIHYxLCBhemkgKSxcbiAgICAgICAgICAgIGNvcnJlY3RVViggdjIudXYsIHYyLCBhemkgKSxcbiAgICAgICAgICAgIGNvcnJlY3RVViggdjMudXYsIHYzLCBhemkgKVxuICAgICAgICBdICk7XG5cbiAgICB9XG5cblxuICAgIC8vIEFuYWx5dGljYWxseSBzdWJkaXZpZGUgYSBmYWNlIHRvIHRoZSByZXF1aXJlZCBkZXRhaWwgbGV2ZWwuXG5cbiAgICBmdW5jdGlvbiBzdWJkaXZpZGUoIGZhY2UsIGRldGFpbCApIHtcblxuICAgICAgICB2YXIgY29scyA9IE1hdGgucG93KCAyLCBkZXRhaWwgKTtcbiAgICAgICAgdmFyIGEgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmEgXSApO1xuICAgICAgICB2YXIgYiA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYiBdICk7XG4gICAgICAgIHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcbiAgICAgICAgdmFyIHYgPSBbXTtcblxuICAgICAgICB2YXIgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvbi5cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gY29sczsgaSsrICkge1xuXG4gICAgICAgICAgICB2WyBpIF0gPSBbXTtcblxuICAgICAgICAgICAgdmFyIGFqID0gcHJlcGFyZSggYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcbiAgICAgICAgICAgIHZhciBiaiA9IHByZXBhcmUoIGIuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XG4gICAgICAgICAgICB2YXIgcm93cyA9IGNvbHMgLSBpO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPD0gcm93czsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBqIF0gPSBhajtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGogXSA9IHByZXBhcmUoIGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICkgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb2xzOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDIgKiAoIGNvbHMgLSBpICkgLSAxOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGogJSAyID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1ha2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGsgKyAxIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpICsgMSBdWyBrIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGsgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBtYWtlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBrICsgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSArIDEgXVsgayArIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLy8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxuXG4gICAgZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKCB2ZWN0b3IueiwgLXZlY3Rvci54ICk7XG5cbiAgICB9XG5cblxuICAgIC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuICAgIGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoIC12ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcblxuICAgIH1cblxuXG4gICAgLy8gVGV4dHVyZSBmaXhpbmcgaGVscGVyLiBTcGhlcmVzIGhhdmUgc29tZSBvZGQgYmVoYXZpb3Vycy5cblxuICAgIGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHZlY3RvciwgYXppbXV0aCApIHtcblxuICAgICAgICBpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2LnggLSAxLCB1di55ICk7XG4gICAgICAgIGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xuICAgICAgICByZXR1cm4gdXYuY2xvbmUoKTtcblxuICAgIH1cblxuXG59O1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5O1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMudmVydGljZXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5pbmRpY2VzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGV0YWlsXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbn07XG5cblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cbiAgICBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxuICovXG5cblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgdmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcbiAgICB2YXIgciA9IDEgLyB0O1xuXG4gICAgdmFyIHZlcnRpY2VzID0gW1xuXG4gICAgICAgIC8vICjCsTEsIMKxMSwgwrExKVxuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsXG4gICAgICAgIDEsIC0xLCAtMSwgMSwgLTEsIDEsXG4gICAgICAgIDEsIDEsIC0xLCAxLCAxLCAxLFxuXG4gICAgICAgIC8vICgwLCDCsTEvz4YsIMKxz4YpXG4gICAgICAgIDAsIC1yLCAtdCwgMCwgLXIsIHQsXG4gICAgICAgIDAsIHIsIC10LCAwLCByLCB0LFxuXG4gICAgICAgIC8vICjCsTEvz4YsIMKxz4YsIDApXG4gICAgICAgIC1yLCAtdCwgMCwgLXIsIHQsIDAsXG4gICAgICAgIHIsIC10LCAwLCByLCB0LCAwLFxuXG4gICAgICAgIC8vICjCsc+GLCAwLCDCsTEvz4YpXG4gICAgICAgIC10LCAwLCAtciwgdCwgMCwgLXIsIC10LCAwLCByLCB0LCAwLCByXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAzLCAxMSwgNywgMywgNywgMTUsIDMsIDE1LCAxMyxcbiAgICAgICAgNywgMTksIDE3LCA3LCAxNywgNiwgNywgNiwgMTUsXG4gICAgICAgIDE3LCA0LCA4LCAxNywgOCwgMTAsIDE3LCAxMCwgNixcbiAgICAgICAgOCwgMCwgMTYsIDgsIDE2LCAyLCA4LCAyLCAxMCxcbiAgICAgICAgMCwgMTIsIDEsIDAsIDEsIDE4LCAwLCAxOCwgMTYsXG4gICAgICAgIDYsIDEwLCAyLCA2LCAyLCAxMywgNiwgMTMsIDE1LFxuICAgICAgICAyLCAxNiwgMTgsIDIsIDE4LCAzLCAyLCAzLCAxMyxcbiAgICAgICAgMTgsIDEsIDksIDE4LCA5LCAxMSwgMTgsIDExLCAzLFxuICAgICAgICA0LCAxNCwgMTIsIDQsIDEyLCAwLCA0LCAwLCA4LFxuICAgICAgICAxMSwgOSwgNSwgMTEsIDUsIDE5LCAxMSwgMTksIDcsXG4gICAgICAgIDE5LCA1LCAxNCwgMTksIDE0LCA0LCAxOSwgNCwgMTcsXG4gICAgICAgIDEsIDEyLCAxNCwgMSwgMTQsIDUsIDEsIDUsIDlcbiAgICBdO1xuXG4gICAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gICAgdGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgfTtcblxufTtcblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG5cblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGV0YWlsXG4gICAgKTtcblxuICAgIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24oIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgdmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFsgLTEsIHQsIDAsIDEsIHQsIDAsIC0xLCAtdCwgMCwgMSwgLXQsIDAsXG4gICAgICAgIDAsIC0xLCB0LCAwLCAxLCB0LCAwLCAtMSwgLXQsIDAsIDEsIC10LFxuICAgICAgICB0LCAwLCAtMSwgdCwgMCwgMSwgLXQsIDAsIC0xLCAtdCwgMCwgMVxuICAgIF07XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgICAgMCwgMTEsIDUsIDAsIDUsIDEsIDAsIDEsIDcsIDAsIDcsIDEwLCAwLCAxMCwgMTEsXG4gICAgICAgIDEsIDUsIDksIDUsIDExLCA0LCAxMSwgMTAsIDIsIDEwLCA3LCA2LCA3LCAxLCA4LFxuICAgICAgICAzLCA5LCA0LCAzLCA0LCAyLCAzLCAyLCA2LCAzLCA2LCA4LCAzLCA4LCA5LFxuICAgICAgICA0LCA5LCA1LCAyLCA0LCAxMSwgNiwgMiwgMTAsIDgsIDYsIDcsIDksIDgsIDFcbiAgICBdO1xuXG4gICAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gICAgdGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICB9O1xuXG59O1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeTtcblxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGV0YWlsXG4gICAgKTtcblxuICAgIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvT2N0YWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICovXG5cblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uKCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgMSwgMCwgMCwgLTEsIDAsIDAsIDAsIDEsIDAsIDAsIC0xLCAwLCAwLCAwLCAxLCAwLCAwLCAtMVxuICAgIF07XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgICAgMCwgMiwgNCwgMCwgNCwgMywgMCwgMywgNSwgMCwgNSwgMiwgMSwgMiwgNSwgMSwgNSwgMywgMSwgMywgNCwgMSwgNCwgMlxuICAgIF07XG5cbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgfTtcblxufTtcblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XG5cblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5kZXRhaWxcbiAgICApO1xuXG4gICAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXRyYWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICovXG5cblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIDEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTFcbiAgICBdO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIDIsIDEsIDAsIDAsIDMsIDIsIDEsIDMsIDAsIDIsIDMsIDFcbiAgICBdO1xuXG4gICAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gICAgdGhpcy50eXBlID0gJ1RldHJhaGVkcm9uR2VvbWV0cnknO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICB9O1xuXG59O1xuXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeTtcblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGV0YWlsXG4gICAgKTtcblxuICAgIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGFyYW1ldHJpY0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XG4gKlxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcbiAqXG4gKi9cblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24oIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xuXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgIHNsaWNlczogc2xpY2VzLFxuICAgICAgICBzdGFja3M6IHN0YWNrc1xuICAgIH07XG5cbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG4gICAgdmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG4gICAgdmFyIGksIGosIHA7XG4gICAgdmFyIHUsIHY7XG5cbiAgICB2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkrKyApIHtcblxuICAgICAgICB2ID0gaSAvIHN0YWNrcztcblxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGorKyApIHtcblxuICAgICAgICAgICAgdSA9IGogLyBzbGljZXM7XG5cbiAgICAgICAgICAgIHAgPSBmdW5jKCB1LCB2ICk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKCBwICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGEsIGIsIGMsIGQ7XG4gICAgdmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpKysgKSB7XG5cbiAgICAgICAgZm9yICggaiA9IDA7IGogPCBzbGljZXM7IGorKyApIHtcblxuICAgICAgICAgICAgYSA9IGkgKiBzbGljZUNvdW50ICsgajtcbiAgICAgICAgICAgIGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xuICAgICAgICAgICAgYyA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcbiAgICAgICAgICAgIGQgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgajtcblxuICAgICAgICAgICAgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGogLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcbiAgICAgICAgICAgIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcbiAgICAgICAgICAgIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xuICAgICAgICAgICAgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGogLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xuXG4gICAgICAgICAgICBmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuICAgICAgICAgICAgdXZzLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cbiAgICAgICAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG4gICAgICAgICAgICB1dnMucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2codGhpcyk7XG5cbiAgICAvLyBtYWdpYyBidWxsZXRcbiAgICAvLyB2YXIgZGlmZiA9IHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1dpcmVmcmFtZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBnZW9tZXRyeSApIHtcblxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIHZhciBlZGdlID0gWyAwLCAwIF0sXG4gICAgICAgIGhhc2ggPSB7fTtcbiAgICB2YXIgc29ydEZ1bmN0aW9uID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuXG4gICAgfTtcblxuICAgIHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cbiAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuICAgICAgICB2YXIgbnVtRWRnZXMgPSAwO1xuXG4gICAgICAgIC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxuICAgICAgICB2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDYgKiBmYWNlcy5sZW5ndGggKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgICAgICAgICAgICAgZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG4gICAgICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuICAgICAgICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG51bUVkZ2VzKys7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMjsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBlZGdlc1sgMiAqIGkgKyBqIF0gXTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XG4gICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRleC54O1xuICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0ZXgueTtcbiAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGV4Lno7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgLy8gSW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4LmFycmF5O1xuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBkcmF3Y2FsbHMgPSBnZW9tZXRyeS5kcmF3Y2FsbHM7XG4gICAgICAgICAgICB2YXIgbnVtRWRnZXMgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIGRyYXdjYWxscy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5hZGREcmF3Q2FsbCggMCwgaW5kaWNlcy5sZW5ndGggKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggMiAqIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBvID0gMCwgb2wgPSBkcmF3Y2FsbHMubGVuZ3RoOyBvIDwgb2w7ICsrbyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBkcmF3Y2FsbCA9IGRyYXdjYWxsc1sgbyBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZHJhd2NhbGwuc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gZHJhd2NhbGwuY291bnQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVsgMCBdID0gaW5kaWNlc1sgaSArIGogXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VbIDEgXSA9IGluZGljZXNbIGkgKyAoIGogKyAxICkgJSAzIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtRWRnZXMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgyID0gZWRnZXNbIDIgKiBpICsgaiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlcy5nZXRYKCBpbmRleDIgKTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzLmdldFkoIGluZGV4MiApO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXMuZ2V0WiggaW5kZXgyICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgICAgICAgIHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICB2YXIgbnVtVHJpcyA9IG51bUVkZ2VzIC8gMztcblxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtVHJpczsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGorKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAxOCAqIGkgKyA2ICogajtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgxID0gOSAqIGkgKyAzICogajtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDEgXTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAxIF07XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDIgPSA5ICogaSArIDMgKiAoICggaiArIDEgKSAlIDMgKTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDMgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDQgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAxIF07XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA1IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMiBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXhpc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXhpc0hlbHBlciA9IGZ1bmN0aW9uKCBzaXplICkge1xuXG4gICAgc2l6ZSA9IHNpemUgfHwgMTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAgICAgMCwgMCwgMCwgc2l6ZSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMCwgc2l6ZSwgMCxcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgc2l6ZVxuICAgIF0gKTtcblxuICAgIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgICAgIDEsIDAsIDAsIDEsIDAuNiwgMCxcbiAgICAgICAgMCwgMSwgMCwgMC42LCAxLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLCAwLjYsIDFcbiAgICBdICk7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnNcbiAgICB9ICk7XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbn07XG5cblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BeGlzSGVscGVyO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BcnJvd0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xuICpcbiAqIFBhcmFtZXRlcnM6XG4gKiAgZGlyIC0gVmVjdG9yM1xuICogIG9yaWdpbiAtIFZlY3RvcjNcbiAqICBsZW5ndGggLSBOdW1iZXJcbiAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcbiAqICBoZWFkV2lkdGggLSBOdW1iZXJcbiAqL1xuXG5USFJFRS5BcnJvd0hlbHBlciA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgbGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblxuICAgIHZhciBjb25lR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC41LCAxLCA1LCAxICk7XG4gICAgY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLTAuNSwgMCApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIEFycm93SGVscGVyKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBjb2xvciwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG4gICAgICAgIC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgICAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICAgICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcbiAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XG4gICAgICAgIGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcbiAgICAgICAgaWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcblxuICAgICAgICBpZiAoIGhlYWRMZW5ndGggPCBsZW5ndGggKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0gKSApO1xuICAgICAgICAgICAgdGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBjb25lR2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgIH0gKSApO1xuICAgICAgICB0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cbiAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuICAgICAgICB0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblxuICAgIH1cblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJyb3dIZWxwZXI7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciByYWRpYW5zO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldERpcmVjdGlvbiggZGlyICkge1xuXG4gICAgICAgIC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgICAgICBpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGRpci55IDwgLTAuOTk5OTkgKSB7XG5cbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBheGlzLnNldCggZGlyLnosIDAsIC1kaXIueCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICByYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG4gICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24oIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG4gICAgaWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuICAgIGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG4gICAgaWYgKCBoZWFkTGVuZ3RoIDwgbGVuZ3RoICkge1xuICAgICAgICB0aGlzLmxpbmUuc2NhbGUuc2V0KCAxLCBsZW5ndGggLSBoZWFkTGVuZ3RoLCAxICk7XG4gICAgICAgIHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmUuc2NhbGUuc2V0KCBoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuICAgIHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xuICAgIHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblxufTtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24oIGNvbG9yICkge1xuXG4gICAgaWYgKCB0aGlzLmxpbmUgIT09IHVuZGVmaW5lZCApIHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XG4gICAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm94SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Cb3hIZWxwZXIgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICk7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IDB4ZmZmZjAwXG4gICAgfSApICk7XG5cbiAgICBpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlKCBvYmplY3QgKTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3hIZWxwZXI7XG5cblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICAgICAgYm94LnNldEZyb21PYmplY3QoIG9iamVjdCApO1xuXG4gICAgICAgIGlmICggYm94LmVtcHR5KCkgKSByZXR1cm47XG5cbiAgICAgICAgdmFyIG1pbiA9IGJveC5taW47XG4gICAgICAgIHZhciBtYXggPSBib3gubWF4O1xuXG4gICAgICAgIC8qXG5cdFx0ICA1X19fXzRcblx0XHQxL19fXzAvfFxuXHRcdHwgNl9ffF83XG5cdFx0Mi9fX18zL1xuXG5cdFx0MDogbWF4LngsIG1heC55LCBtYXguelxuXHRcdDE6IG1pbi54LCBtYXgueSwgbWF4Lnpcblx0XHQyOiBtaW4ueCwgbWluLnksIG1heC56XG5cdFx0MzogbWF4LngsIG1pbi55LCBtYXguelxuXHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcblx0XHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XG5cdFx0NjogbWluLngsIG1pbi55LCBtaW4uelxuXHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcblx0XHQqL1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgYXJyYXlbIDAgXSA9IG1heC54O1xuICAgICAgICBhcnJheVsgMSBdID0gbWF4Lnk7XG4gICAgICAgIGFycmF5WyAyIF0gPSBtYXguejtcbiAgICAgICAgYXJyYXlbIDMgXSA9IG1pbi54O1xuICAgICAgICBhcnJheVsgNCBdID0gbWF4Lnk7XG4gICAgICAgIGFycmF5WyA1IF0gPSBtYXguejtcbiAgICAgICAgYXJyYXlbIDYgXSA9IG1pbi54O1xuICAgICAgICBhcnJheVsgNyBdID0gbWluLnk7XG4gICAgICAgIGFycmF5WyA4IF0gPSBtYXguejtcbiAgICAgICAgYXJyYXlbIDkgXSA9IG1heC54O1xuICAgICAgICBhcnJheVsgMTAgXSA9IG1pbi55O1xuICAgICAgICBhcnJheVsgMTEgXSA9IG1heC56O1xuICAgICAgICBhcnJheVsgMTIgXSA9IG1heC54O1xuICAgICAgICBhcnJheVsgMTMgXSA9IG1heC55O1xuICAgICAgICBhcnJheVsgMTQgXSA9IG1pbi56O1xuICAgICAgICBhcnJheVsgMTUgXSA9IG1pbi54O1xuICAgICAgICBhcnJheVsgMTYgXSA9IG1heC55O1xuICAgICAgICBhcnJheVsgMTcgXSA9IG1pbi56O1xuICAgICAgICBhcnJheVsgMTggXSA9IG1pbi54O1xuICAgICAgICBhcnJheVsgMTkgXSA9IG1pbi55O1xuICAgICAgICBhcnJheVsgMjAgXSA9IG1pbi56O1xuICAgICAgICBhcnJheVsgMjEgXSA9IG1heC54O1xuICAgICAgICBhcnJheVsgMjIgXSA9IG1pbi55O1xuICAgICAgICBhcnJheVsgMjMgXSA9IG1pbi56O1xuXG4gICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgfVxuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm91bmRpbmdCb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG4vLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgPSBmdW5jdGlvbiggb2JqZWN0LCBoZXggKSB7XG5cbiAgICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweDg4ODg4ODtcblxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgdGhpcy5ib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuQm94R2VvbWV0cnkoIDEsIDEsIDEgKSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlXG4gICAgfSApICk7XG5cbn07XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3VuZGluZ0JveEhlbHBlcjtcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcblxuICAgIHRoaXMuYm94LnNpemUoIHRoaXMuc2NhbGUgKTtcblxuICAgIHRoaXMuYm94LmNlbnRlciggdGhpcy5wb3NpdGlvbiApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9DYW1lcmFIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcbiAqXHQtIHN1aXRhYmxlIGZvciBmYXN0IHVwZGF0ZXNcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxuICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuICovXG5cblRIUkVFLkNhbWVyYUhlbHBlciA9IGZ1bmN0aW9uKCBjYW1lcmEgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnNcbiAgICB9ICk7XG5cbiAgICB2YXIgcG9pbnRNYXAgPSB7fTtcblxuICAgIC8vIGNvbG9yc1xuXG4gICAgdmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcbiAgICB2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xuICAgIHZhciBoZXhVcCA9IDB4MDBhYWZmO1xuICAgIHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcbiAgICB2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcblxuICAgIC8vIG5lYXJcblxuICAgIGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJuMlwiLCBcIm40XCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcIm40XCIsIFwibjNcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XG5cbiAgICAvLyBmYXJcblxuICAgIGFkZExpbmUoIFwiZjFcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcImY0XCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwiZjNcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG5cbiAgICAvLyBzaWRlc1xuXG4gICAgYWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcbiAgICBhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuICAgIGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG4gICAgYWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcblxuICAgIC8vIGNvbmVcblxuICAgIGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcbiAgICBhZGRMaW5lKCBcInBcIiwgXCJuMlwiLCBoZXhDb25lICk7XG4gICAgYWRkTGluZSggXCJwXCIsIFwibjNcIiwgaGV4Q29uZSApO1xuICAgIGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcblxuICAgIC8vIHVwXG5cbiAgICBhZGRMaW5lKCBcInUxXCIsIFwidTJcIiwgaGV4VXAgKTtcbiAgICBhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcbiAgICBhZGRMaW5lKCBcInUzXCIsIFwidTFcIiwgaGV4VXAgKTtcblxuICAgIC8vIHRhcmdldFxuXG4gICAgYWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcbiAgICBhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XG5cbiAgICAvLyBjcm9zc1xuXG4gICAgYWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcbiAgICBhZGRMaW5lKCBcImNuM1wiLCBcImNuNFwiLCBoZXhDcm9zcyApO1xuXG4gICAgYWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcbiAgICBhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xuXG4gICAgZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xuXG4gICAgICAgIGFkZFBvaW50KCBhLCBoZXggKTtcbiAgICAgICAgYWRkUG9pbnQoIGIsIGhleCApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUG9pbnQoIGlkLCBoZXggKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuICAgICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXG4gICAgICAgIGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgcG9pbnRNYXBbIGlkIF0gPSBbXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnRNYXBbIGlkIF0ucHVzaCggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xuXG4gICAgfVxuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbWVyYUhlbHBlcjtcblxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgY2FtZXJhID0gbmV3IFRIUkVFLkNhbWVyYSgpO1xuXG4gICAgdmFyIHNldFBvaW50ID0gZnVuY3Rpb24oIHBvaW50LCB4LCB5LCB6ICkge1xuXG4gICAgICAgIHZlY3Rvci5zZXQoIHgsIHksIHogKS51bnByb2plY3QoIGNhbWVyYSApO1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcblxuICAgICAgICBpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgcG9pbnRzWyBpIF0gXS5jb3B5KCB2ZWN0b3IgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgICBwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XG5cbiAgICAgICAgdmFyIHcgPSAxLFxuICAgICAgICAgICAgaCA9IDE7XG5cbiAgICAgICAgLy8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICAvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxuXG4gICAgICAgIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgICAgICAvLyBjZW50ZXIgLyB0YXJnZXRcblxuICAgICAgICBzZXRQb2ludCggXCJjXCIsIDAsIDAsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcInRcIiwgMCwgMCwgMSApO1xuXG4gICAgICAgIC8vIG5lYXJcblxuICAgICAgICBzZXRQb2ludCggXCJuMVwiLCAtdywgLWgsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcIm4yXCIsIHcsIC1oLCAtMSApO1xuICAgICAgICBzZXRQb2ludCggXCJuM1wiLCAtdywgaCwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwibjRcIiwgdywgaCwgLTEgKTtcblxuICAgICAgICAvLyBmYXJcblxuICAgICAgICBzZXRQb2ludCggXCJmMVwiLCAtdywgLWgsIDEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiZjJcIiwgdywgLWgsIDEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiZjNcIiwgLXcsIGgsIDEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiZjRcIiwgdywgaCwgMSApO1xuXG4gICAgICAgIC8vIHVwXG5cbiAgICAgICAgc2V0UG9pbnQoIFwidTFcIiwgdyAqIDAuNywgaCAqIDEuMSwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwidTJcIiwgLXcgKiAwLjcsIGggKiAxLjEsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcInUzXCIsIDAsIGggKiAyLCAtMSApO1xuXG4gICAgICAgIC8vIGNyb3NzXG5cbiAgICAgICAgc2V0UG9pbnQoIFwiY2YxXCIsIC13LCAwLCAxICk7XG4gICAgICAgIHNldFBvaW50KCBcImNmMlwiLCB3LCAwLCAxICk7XG4gICAgICAgIHNldFBvaW50KCBcImNmM1wiLCAwLCAtaCwgMSApO1xuICAgICAgICBzZXRQb2ludCggXCJjZjRcIiwgMCwgaCwgMSApO1xuXG4gICAgICAgIHNldFBvaW50KCBcImNuMVwiLCAtdywgMCwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiY24yXCIsIHcsIDAsIC0xICk7XG4gICAgICAgIHNldFBvaW50KCBcImNuM1wiLCAwLCAtaCwgLTEgKTtcbiAgICAgICAgc2V0UG9pbnQoIFwiY240XCIsIDAsIGgsIC0xICk7XG5cbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIH07XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRGlyZWN0aW9uYWxMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IGZ1bmN0aW9uKCBsaWdodCwgc2l6ZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcbiAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgc2l6ZSA9IHNpemUgfHwgMTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtc2l6ZSwgc2l6ZSwgMCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggc2l6ZSwgc2l6ZSwgMCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggc2l6ZSwgLXNpemUsIDAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC1zaXplLCAtc2l6ZSwgMCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLXNpemUsIHNpemUsIDAgKVxuICAgICk7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgZm9nOiBmYWxzZVxuICAgIH0gKTtcbiAgICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICB0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgdGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xuXG4gICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgKTtcblxuICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGZvZzogZmFsc2VcbiAgICB9ICk7XG4gICAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgdGhpcy50YXJnZXRMaW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIHRoaXMuYWRkKCB0aGlzLnRhcmdldExpbmUgKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgICAgdjMuc3ViVmVjdG9ycyggdjIsIHYxICk7XG5cbiAgICAgICAgdGhpcy5saWdodFBsYW5lLmxvb2tBdCggdjMgKTtcbiAgICAgICAgdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgICAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB2MyApO1xuICAgICAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvciApO1xuXG4gICAgfTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9FZGdlc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQHBhcmFtIG9iamVjdCBUSFJFRS5NZXNoIHdob3NlIGdlb21ldHJ5IHdpbGwgYmUgdXNlZFxuICogQHBhcmFtIGhleCBsaW5lIGNvbG9yXG4gKiBAcGFyYW0gdGhyZXNob2xkQW5nbGUgdGhlIG1pbmltdW0gYW5nbGUgKGluIGRlZ3JlZXMpLFxuICogYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIGFkamFjZW50IGZhY2VzLFxuICogdGhhdCBpcyByZXF1aXJlZCB0byByZW5kZXIgYW4gZWRnZS4gQSB2YWx1ZSBvZiAxMCBtZWFuc1xuICogYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSBpcyBhdCBsZWFzdCAxMCBkZWdyZWVzLlxuICovXG5cblRIUkVFLkVkZ2VzSGVscGVyID0gZnVuY3Rpb24oIG9iamVjdCwgaGV4LCB0aHJlc2hvbGRBbmdsZSApIHtcblxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5FZGdlc0dlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICBjb2xvcjogY29sb3JcbiAgICB9ICkgKTtcblxuICAgIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0hlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRmFjZU5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuICAgIC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcblxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgdGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XG5cbiAgICB2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gICAgLy9cblxuICAgIHZhciBuTm9ybWFscyA9IDA7XG5cbiAgICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICAgIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICBuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLicgKTtcblxuICAgIH1cblxuICAgIC8vXG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgbGluZXdpZHRoOiB3aWR0aFxuICAgIH0gKSApO1xuXG4gICAgLy9cblxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyO1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgICBub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICAgIHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xuXG4gICAgICAgIHZhciBpZHggPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cbiAgICAgICAgICAgIHYxLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApXG4gICAgICAgICAgICAgICAgLmFkZCggdmVydGljZXNbIGZhY2UuYiBdIClcbiAgICAgICAgICAgICAgICAuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKVxuICAgICAgICAgICAgICAgIC5kaXZpZGVTY2FsYXIoIDMgKVxuICAgICAgICAgICAgICAgIC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG59KCkgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvR3JpZEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR3JpZEhlbHBlciA9IGZ1bmN0aW9uKCBzaXplLCBzdGVwICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzXG4gICAgfSApO1xuXG4gICAgdGhpcy5jb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoIDB4NDQ0NDQ0ICk7XG4gICAgdGhpcy5jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ODg4ODg4ICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IC1zaXplOyBpIDw9IHNpemU7IGkgKz0gc3RlcCApIHtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC1zaXplLCAwLCBpICksIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplLCAwLCBpICksXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgLXNpemUgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIHNpemUgKVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBjb2xvciA9IGkgPT09IDAgPyB0aGlzLmNvbG9yMSA6IHRoaXMuY29sb3IyO1xuXG4gICAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG4gICAgfVxuXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3JpZEhlbHBlcjtcblxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24oIGNvbG9yQ2VudGVyTGluZSwgY29sb3JHcmlkICkge1xuXG4gICAgdGhpcy5jb2xvcjEuc2V0KCBjb2xvckNlbnRlckxpbmUgKTtcbiAgICB0aGlzLmNvbG9yMi5zZXQoIGNvbG9yR3JpZCApO1xuXG4gICAgdGhpcy5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24oIGxpZ2h0LCBzcGhlcmVTaXplICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLmNvbG9ycyA9IFsgbmV3IFRIUkVFLkNvbG9yKCksIG5ldyBUSFJFRS5Db2xvcigpIF07XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcbiAgICBnZW9tZXRyeS5yb3RhdGVYKCAtTWF0aC5QSSAvIDIgKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSA4OyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICBnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcblxuICAgIH1cblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsXG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZVxuICAgIH0gKTtcblxuICAgIHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgdGhpcy5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNvbG9yc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcbiAgICAgICAgdGhpcy5jb2xvcnNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgdGhpcy5saWdodFNwaGVyZS5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xuICAgICAgICB0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgfVxuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1BvaW50TGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyID0gZnVuY3Rpb24oIGxpZ2h0LCBzcGhlcmVTaXplICkge1xuXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuICAgICAgICB3aXJlZnJhbWU6IHRydWUsXG4gICAgICAgIGZvZzogZmFsc2VcbiAgICB9ICk7XG4gICAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIC8qXG5cdHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcblx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcblxuXHR2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xuXG5cdGlmICggZCA9PT0gMC4wICkge1xuXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG5cdH1cblxuXHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XG5cdCovXG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodEhlbHBlcjtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICAvKlxuXHR2YXIgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cblx0aWYgKCBkID09PSAwLjAgKSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG5cdH1cblx0Ki9cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU2tlbGV0b25IZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxuICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlciA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICB0aGlzLmJvbmVzID0gdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0ICk7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cbiAgICAgICAgaWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDAsIDEgKSApO1xuICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMSwgMCApICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ2VvbWV0cnkuZHluYW1pYyA9IHRydWU7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHtcbiAgICAgICAgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMsXG4gICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZVxuICAgIH0gKTtcblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIHRoaXMucm9vdCA9IG9iamVjdDtcblxuICAgIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ta2VsZXRvbkhlbHBlcjtcblxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmdldEJvbmVMaXN0ID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgIHZhciBib25lTGlzdCA9IFtdO1xuXG4gICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG4gICAgICAgIGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgIGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gYm9uZUxpc3Q7XG5cbn07XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgICB2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgdmFyIGJvbmVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgdmFyIGogPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICB2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuICAgICAgICBpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuICAgICAgICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNbIGogXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcblxuICAgICAgICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBqICsgMSBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG4gICAgICAgICAgICBqICs9IDI7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9TcG90TGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlNwb3RMaWdodEhlbHBlciA9IGZ1bmN0aW9uKCBsaWdodCApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcbiAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDEsIDEsIDgsIDEsIHRydWUgKTtcblxuICAgIGdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLTAuNSwgMCApO1xuICAgIGdlb21ldHJ5LnJvdGF0ZVgoIC1NYXRoLlBJIC8gMiApO1xuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZSxcbiAgICAgICAgZm9nOiBmYWxzZVxuICAgIH0gKTtcblxuICAgIHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICB0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0SGVscGVyO1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDA7XG4gICAgICAgIHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcblxuICAgICAgICB0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xuXG4gICAgICAgIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgdmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XG5cbiAgICAgICAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIH07XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvVmVydGV4Tm9ybWFsc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24oIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xuXG4gICAgdmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuICAgIC8vXG5cbiAgICB2YXIgbk5vcm1hbHMgPSAwO1xuXG4gICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgbk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGggKiAzO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgIG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuY291bnRcblxuICAgIH1cblxuICAgIC8vXG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcblxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgbGluZXdpZHRoOiB3aWR0aFxuICAgIH0gKSApO1xuXG4gICAgLy9cblxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXI7XG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgICAgIHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cbiAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgICBub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgICAgIHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZmFjZVsga2V5c1sgaiBdIF0gXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdjEuY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuICAgICAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIG9ialBvcyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgICAgIHZhciBvYmpOb3JtID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuXG4gICAgICAgICAgICAvLyBmb3Igc2ltcGxpY2l0eSwgaWdub3JlIGluZGV4IGFuZCBkcmF3Y2FsbHMsIGFuZCByZW5kZXIgZXZlcnkgbm9ybWFsXG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBvYmpQb3MuY291bnQ7IGogPCBqbDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgdjEuc2V0KCBvYmpQb3MuZ2V0WCggaiApLCBvYmpQb3MuZ2V0WSggaiApLCBvYmpQb3MuZ2V0WiggaiApICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICAgICAgdjIuc2V0KCBvYmpOb3JtLmdldFgoIGogKSwgb2JqTm9ybS5nZXRZKCBqICksIG9iak5vcm0uZ2V0WiggaiApICk7XG5cbiAgICAgICAgICAgICAgICB2Mi5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufSgpICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1dpcmVmcmFtZUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyID0gZnVuY3Rpb24oIG9iamVjdCwgaGV4ICkge1xuXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XG5cbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgbmV3IFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0gKSApO1xuXG4gICAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lSGVscGVyO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9JbW1lZGlhdGVSZW5kZXJPYmplY3QuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcblxufTtcblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdDtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvTW9ycGhCbGVuZE1lc2guanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcbiAgICB0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XG5cbiAgICAvLyBwcmVwYXJlIGRlZmF1bHQgYW5pbWF0aW9uXG4gICAgLy8gKGFsbCBmcmFtZXMgcGxheWVkIHRvZ2V0aGVyIGluIDEgc2Vjb25kKVxuXG4gICAgdmFyIG51bUZyYW1lcyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDtcblxuICAgIHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcblxuICAgIHZhciBzdGFydEZyYW1lID0gMDtcbiAgICB2YXIgZW5kRnJhbWUgPSBudW1GcmFtZXMgLSAxO1xuXG4gICAgdmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XG5cbiAgICB0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xuICAgIHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Nb3JwaEJsZW5kTWVzaDtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBuYW1lLCBzdGFydCwgZW5kLCBmcHMgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0ge1xuXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG5cbiAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXG5cbiAgICAgICAgZnBzOiBmcHMsXG4gICAgICAgIGR1cmF0aW9uOiAoIGVuZCAtIHN0YXJ0ICkgLyBmcHMsXG5cbiAgICAgICAgbGFzdEZyYW1lOiAwLFxuICAgICAgICBjdXJyZW50RnJhbWU6IDAsXG5cbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcblxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBkaXJlY3Rpb246IDEsXG4gICAgICAgIHdlaWdodDogMSxcblxuICAgICAgICBkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxuICAgICAgICBtaXJyb3JlZExvb3A6IGZhbHNlXG5cbiAgICB9O1xuXG4gICAgdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XG4gICAgdGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmF1dG9DcmVhdGVBbmltYXRpb25zID0gZnVuY3Rpb24oIGZwcyApIHtcblxuICAgIHZhciBwYXR0ZXJuID0gLyhbYS16XSspXz8oXFxkKykvO1xuXG4gICAgdmFyIGZpcnN0QW5pbWF0aW9uLCBmcmFtZVJhbmdlcyA9IHt9O1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICB2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcbiAgICAgICAgdmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuICAgICAgICBpZiAoIGNodW5rcyAmJiBjaHVua3MubGVuZ3RoID4gMSApIHtcblxuICAgICAgICAgICAgdmFyIG5hbWUgPSBjaHVua3NbIDEgXTtcblxuICAgICAgICAgICAgaWYgKCAhZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGVuZDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICBpZiAoIGkgPCByYW5nZS5zdGFydCApIHJhbmdlLnN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGlmICggaSA+IHJhbmdlLmVuZCApIHJhbmdlLmVuZCA9IGk7XG5cbiAgICAgICAgICAgIGlmICggIWZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBuYW1lO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xuXG4gICAgICAgIHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG4gICAgICAgIHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBmcHMgKTtcblxuICAgIH1cblxuICAgIHRoaXMuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbiA9IC0xO1xuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uKCBuYW1lLCBmcHMgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24uZnBzID0gZnBzO1xuICAgICAgICBhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uKCBuYW1lLCBkdXJhdGlvbiApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICBhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25XZWlnaHQgPSBmdW5jdGlvbiggbmFtZSwgd2VpZ2h0ICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiggbmFtZSwgdGltZSApIHtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIGFuaW1hdGlvbi50aW1lID0gdGltZTtcblxuICAgIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgIHZhciB0aW1lID0gMDtcblxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICAgIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgICAgIHRpbWUgPSBhbmltYXRpb24udGltZTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aW1lO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiggbmFtZSApIHtcblxuICAgIHZhciBkdXJhdGlvbiA9IC0xO1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICAgICAgZHVyYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZHVyYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24udGltZSA9IDA7XG4gICAgICAgIGFuaW1hdGlvbi5hY3RpdmUgPSB0cnVlO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5Nb3JwaEJsZW5kTWVzaDogYW5pbWF0aW9uW1wiICsgbmFtZSArIFwiXSB1bmRlZmluZWQgaW4gLnBsYXlBbmltYXRpb24oKVwiICk7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICBhbmltYXRpb24uYWN0aXZlID0gZmFsc2U7XG5cbiAgICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiggZGVsdGEgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5hbmltYXRpb25zTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNMaXN0WyBpIF07XG5cbiAgICAgICAgaWYgKCAhYW5pbWF0aW9uLmFjdGl2ZSApIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gLyBhbmltYXRpb24ubGVuZ3RoO1xuXG4gICAgICAgIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcblxuICAgICAgICBpZiAoIGFuaW1hdGlvbi5taXJyb3JlZExvb3AgKSB7XG5cbiAgICAgICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gfHwgYW5pbWF0aW9uLnRpbWUgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtMTtcblxuICAgICAgICAgICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleWZyYW1lID0gYW5pbWF0aW9uLnN0YXJ0ICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcbiAgICAgICAgdmFyIHdlaWdodCA9IGFuaW1hdGlvbi53ZWlnaHQ7XG5cbiAgICAgICAgaWYgKCBrZXlmcmFtZSAhPT0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSApIHtcblxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gMSAqIHdlaWdodDtcblxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xuXG4gICAgICAgICAgICBhbmltYXRpb24ubGFzdEZyYW1lID0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZTtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcblxuICAgICAgICBpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xuXG4gICAgICAgIGlmICggYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSAhPT0gYW5pbWF0aW9uLmxhc3RGcmFtZSApIHtcblxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IG1peCAqIHdlaWdodDtcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gd2VpZ2h0O1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTsiLCIvKiBzaGFkZXItcGFydGljbGUtZW5naW5lIDEuMC4wXG4gKiBcbiAqIChjKSAyMDE1IEx1a2UgTW9vZHkgKGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9zcXVhcmVmZWV0KVxuICogICAgIE9yaWdpbmFsbHkgYmFzZWQgb24gTGVlIFN0ZW1rb3NraSdzIG9yaWdpbmFsIHdvcmsgKGh0dHBzOi8vZ2l0aHViLmNvbS9zdGVta29za2kvc3RlbWtvc2tpLmdpdGh1Yi5jb20vYmxvYi9tYXN0ZXIvVGhyZWUuanMvanMvUGFydGljbGVFbmdpbmUuanMpLlxuICpcbiAqIHNoYWRlci1wYXJ0aWNsZS1lbmdpbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKFNlZSBMSUNFTlNFIGF0IHJvb3Qgb2YgdGhpcyByZXBvc2l0b3J5LilcbiAqL1xudmFyIFNQRSA9IHtcbiAgICBkaXN0cmlidXRpb25zOiB7XG4gICAgICAgIEJPWDogMSxcbiAgICAgICAgU1BIRVJFOiAyLFxuICAgICAgICBESVNDOiAzXG4gICAgfSxcbiAgICB2YWx1ZU92ZXJMaWZldGltZUxlbmd0aDogNFxufTtcblwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoXCJzcGVcIiwgU1BFKSA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlICYmIChtb2R1bGUuZXhwb3J0cyA9IFNQRSksIFNQRS5UeXBlZEFycmF5SGVscGVyID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMuY29tcG9uZW50U2l6ZSA9IGMgfHwgMSwgdGhpcy5zaXplID0gYiB8fCAxLCB0aGlzLlR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGEgfHwgRmxvYXQzMkFycmF5LCB0aGlzLmFycmF5ID0gbmV3IGEoYiAqIHRoaXMuY29tcG9uZW50U2l6ZSksIHRoaXMuaW5kZXhPZmZzZXQgPSBkIHx8IDBcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLmNvbnN0cnVjdG9yID0gU1BFLlR5cGVkQXJyYXlIZWxwZXIsIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjID0gdGhpcy5hcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGIgfHwgKGEgKj0gdGhpcy5jb21wb25lbnRTaXplKSwgYyA+IGEgPyB0aGlzLnNocmluayhhKSA6IGEgPiBjID8gdGhpcy5ncm93KGEpIDogdm9pZCBjb25zb2xlLmluZm8oXCJUeXBlZEFycmF5IGlzIGFscmVhZHkgb2Ygc2l6ZTpcIiwgYSArIFwiLlwiLCBcIldpbGwgbm90IHJlc2l6ZS5cIilcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zaHJpbmsgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LnN1YmFycmF5KDAsIGEpLCB0aGlzLnNpemUgPSBhLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuZ3JvdyA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYiA9IHRoaXMuYXJyYXksXG4gICAgICAgIGMgPSBuZXcgdGhpcy5UeXBlZEFycmF5Q29uc3RydWN0b3IoYSk7XG4gICAgcmV0dXJuIGMuc2V0KGIpLCB0aGlzLmFycmF5ID0gYywgdGhpcy5zaXplID0gYSwgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBhICo9IHRoaXMuY29tcG9uZW50U2l6ZSwgYiAqPSB0aGlzLmNvbXBvbmVudFNpemU7XG4gICAgZm9yICh2YXIgYyA9IFtdLCBkID0gdGhpcy5hcnJheSwgZSA9IGQubGVuZ3RoLCBmID0gMDsgZSA+IGY7ICsrZilcbiAgICAgICAgKGEgPiBmIHx8IGYgPj0gYikgJiYgYy5wdXNoKGRbZl0pO1xuICAgIHJldHVybiB0aGlzLnNldEZyb21BcnJheSgwLCBjKSwgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldEZyb21BcnJheSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYyA9IGIubGVuZ3RoLFxuICAgICAgICBkID0gYSArIGM7XG4gICAgcmV0dXJuIGQgPiB0aGlzLmFycmF5Lmxlbmd0aCA/IHRoaXMuZ3JvdyhkKSA6IGQgPCB0aGlzLmFycmF5Lmxlbmd0aCAmJiB0aGlzLnNocmluayhkKSwgdGhpcy5hcnJheS5zZXQoYiwgdGhpcy5pbmRleE9mZnNldCArIGEpLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjMiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5zZXRWZWMyQ29tcG9uZW50cyhhLCBiLngsIGIueSlcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWMyQ29tcG9uZW50cyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZCA9IHRoaXMuYXJyYXksXG4gICAgICAgIGUgPSB0aGlzLmluZGV4T2Zmc2V0ICsgYSAqIHRoaXMuY29tcG9uZW50U2l6ZTtcbiAgICByZXR1cm4gZFtlXSA9IGIsIGRbZSArIDFdID0gYywgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzMgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVjM0NvbXBvbmVudHMoYSwgYi54LCBiLnksIGIueilcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWMzQ29tcG9uZW50cyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZSA9IHRoaXMuYXJyYXksXG4gICAgICAgIGYgPSB0aGlzLmluZGV4T2Zmc2V0ICsgYSAqIHRoaXMuY29tcG9uZW50U2l6ZTtcbiAgICByZXR1cm4gZVtmXSA9IGIsIGVbZiArIDFdID0gYywgZVtmICsgMl0gPSBkLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjNCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5zZXRWZWM0Q29tcG9uZW50cyhhLCBiLngsIGIueSwgYi56LCBiLncpXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjNENvbXBvbmVudHMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGYgPSB0aGlzLmFycmF5LFxuICAgICAgICBnID0gdGhpcy5pbmRleE9mZnNldCArIGEgKiB0aGlzLmNvbXBvbmVudFNpemU7XG4gICAgcmV0dXJuIGZbZ10gPSBiLCBmW2cgKyAxXSA9IGMsIGZbZyArIDJdID0gZCwgZltnICsgM10gPSBlLCB0aGlzXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0TWF0MyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tQXJyYXkodGhpcy5pbmRleE9mZnNldCArIGEgKiB0aGlzLmNvbXBvbmVudFNpemUsIGIuZWxlbWVudHMpXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0TWF0NCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tQXJyYXkodGhpcy5pbmRleE9mZnNldCArIGEgKiB0aGlzLmNvbXBvbmVudFNpemUsIGIuZWxlbWVudHMpXG59LCBTUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVjM0NvbXBvbmVudHMoYSwgYi5yLCBiLmcsIGIuYilcbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXROdW1iZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbdGhpcy5pbmRleE9mZnNldCArIGEgKiB0aGlzLmNvbXBvbmVudFNpemVdID0gYiwgdGhpc1xufSwgU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLmdldFZhbHVlQXRJbmRleCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5hcnJheVt0aGlzLmluZGV4T2Zmc2V0ICsgYV1cbn0sIFNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRWYWx1ZUF0SW5kZXggPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXkuc3ViYXJyYXkodGhpcy5pbmRleE9mZnNldCArIGEgKiB0aGlzLmNvbXBvbmVudFNpemUpO1xufSwgU1BFLlNoYWRlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZCA9IFNQRS5TaGFkZXJBdHRyaWJ1dGUudHlwZVNpemVNYXA7XG4gICAgdGhpcy50eXBlID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgYSAmJiBkLmhhc093blByb3BlcnR5KGEpID8gYSA6IFwiZlwiLCB0aGlzLmNvbXBvbmVudFNpemUgPSBkW3RoaXMudHlwZV0sIHRoaXMuYXJyYXlUeXBlID0gYyB8fCBGbG9hdDMyQXJyYXksIHRoaXMudHlwZWRBcnJheSA9IG51bGwsIHRoaXMuYnVmZmVyQXR0cmlidXRlID0gbnVsbCwgdGhpcy5keW5hbWljQnVmZmVyID0gISFiLCB0aGlzLnVwZGF0ZU1pbiA9IDAsIHRoaXMudXBkYXRlTWF4ID0gMFxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5jb25zdHJ1Y3RvciA9IFNQRS5TaGFkZXJBdHRyaWJ1dGUsIFNQRS5TaGFkZXJBdHRyaWJ1dGUudHlwZVNpemVNYXAgPSB7XG4gICAgZjogMSxcbiAgICB2MjogMixcbiAgICB2MzogMyxcbiAgICB2NDogNCxcbiAgICBjOiAzLFxuICAgIG0zOiA5LFxuICAgIG00OiAxNlxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuc2V0VXBkYXRlUmFuZ2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy51cGRhdGVNaW4gPSBNYXRoLm1pbihhICogdGhpcy5jb21wb25lbnRTaXplLCB0aGlzLnVwZGF0ZU1pbiAqIHRoaXMuY29tcG9uZW50U2l6ZSksIHRoaXMudXBkYXRlTWF4ID0gTWF0aC5tYXgoYiAqIHRoaXMuY29tcG9uZW50U2l6ZSwgdGhpcy51cGRhdGVNYXggKiB0aGlzLmNvbXBvbmVudFNpemUpXG59LCBTUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5mbGFnVXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGEgPSB0aGlzLmJ1ZmZlckF0dHJpYnV0ZSxcbiAgICAgICAgYiA9IGEudXBkYXRlUmFuZ2U7XG4gICAgYi5vZmZzZXQgPSB0aGlzLnVwZGF0ZU1pbiwgYi5jb3VudCA9IE1hdGgubWluKHRoaXMudXBkYXRlTWF4IC0gdGhpcy51cGRhdGVNaW4gKyB0aGlzLmNvbXBvbmVudFNpemUsIHRoaXMudHlwZWRBcnJheS5hcnJheS5sZW5ndGgpLCBhLm5lZWRzVXBkYXRlID0gITBcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLnJlc2V0VXBkYXRlUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLnVwZGF0ZU1pbiA9IDAsIHRoaXMudXBkYXRlTWF4ID0gMDtcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLnJlc2V0RHluYW1pYyA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMuYnVmZmVyQXR0cmlidXRlLmR5bmFtaWMgPSB0aGlzLmR5bmFtaWNCdWZmZXJcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLnR5cGVkQXJyYXkuc3BsaWNlKGEsIGIpLCB0aGlzLmZvcmNlVXBkYXRlQWxsKClcbn0sIFNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLmZvcmNlVXBkYXRlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5idWZmZXJBdHRyaWJ1dGUuYXJyYXkgPSB0aGlzLnR5cGVkQXJyYXkuYXJyYXksIHRoaXMuYnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlLm9mZnNldCA9IDAsIHRoaXMuYnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlLmNvdW50ID0gLTEsIHRoaXMuYnVmZmVyQXR0cmlidXRlLmR5bmFtaWMgPSAhMSwgdGhpcy5idWZmZXJBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSAhMFxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuX2Vuc3VyZVR5cGVkQXJyYXkgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgKG51bGwgPT09IHRoaXMudHlwZWRBcnJheSB8fCB0aGlzLnR5cGVkQXJyYXkuc2l6ZSAhPT0gYSAqIHRoaXMuY29tcG9uZW50U2l6ZSkgJiYgKG51bGwgIT09IHRoaXMudHlwZWRBcnJheSAmJiB0aGlzLnR5cGVkQXJyYXkuc2l6ZSAhPT0gYSA/IHRoaXMudHlwZWRBcnJheS5zZXRTaXplKGEpIDogbnVsbCA9PT0gdGhpcy50eXBlZEFycmF5ICYmICh0aGlzLnR5cGVkQXJyYXkgPSBuZXcgU1BFLlR5cGVkQXJyYXlIZWxwZXIodGhpcy5hcnJheVR5cGUsIGEsIHRoaXMuY29tcG9uZW50U2l6ZSkpKVxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuX2NyZWF0ZUJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5fZW5zdXJlVHlwZWRBcnJheShhKSwgbnVsbCAhPT0gdGhpcy5idWZmZXJBdHRyaWJ1dGUgPyAodGhpcy5idWZmZXJBdHRyaWJ1dGUuYXJyYXkgPSB0aGlzLnR5cGVkQXJyYXkuYXJyYXksXG4gICAgdm9pZCAodGhpcy5idWZmZXJBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSAhMCkpIDogKHRoaXMuYnVmZmVyQXR0cmlidXRlID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLnR5cGVkQXJyYXkuYXJyYXksIHRoaXMuY29tcG9uZW50U2l6ZSksIHZvaWQgKHRoaXMuYnVmZmVyQXR0cmlidXRlLmR5bmFtaWMgPSB0aGlzLmR5bmFtaWNCdWZmZXIpKVxufSwgU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIG51bGwgPT09IHRoaXMudHlwZWRBcnJheSA/IDAgOiB0aGlzLnR5cGVkQXJyYXkuYXJyYXkubGVuZ3RoXG59LCBTUEUuc2hhZGVyQ2h1bmtzID0ge1xuICAgIGRlZmluZXM6IFtcIiNkZWZpbmUgUEFDS0VEX0NPTE9SX1NJWkUgMjU2LjBcIiwgXCIjZGVmaW5lIFBBQ0tFRF9DT0xPUl9ESVZJU09SIDI1NS4wXCJdLmpvaW4oXCJcXG5cIiksXG4gICAgdW5pZm9ybXM6IFtcInVuaWZvcm0gZmxvYXQgZGVsdGFUaW1lO1wiLCBcInVuaWZvcm0gZmxvYXQgcnVuVGltZTtcIiwgXCJ1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1wiLCBcInVuaWZvcm0gdmVjNCB0ZXh0dXJlQW5pbWF0aW9uO1wiLCBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgYXR0cmlidXRlczogW1wiYXR0cmlidXRlIHZlYzQgYWNjZWxlcmF0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMzIHZlbG9jaXR5O1wiLCBcImF0dHJpYnV0ZSB2ZWM0IHJvdGF0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMzIHJvdGF0aW9uQ2VudGVyO1wiLCBcImF0dHJpYnV0ZSB2ZWM0IHBhcmFtcztcIiwgXCJhdHRyaWJ1dGUgdmVjNCBzaXplO1wiLCBcImF0dHJpYnV0ZSB2ZWM0IGFuZ2xlO1wiLCBcImF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1wiLCBcImF0dHJpYnV0ZSB2ZWM0IG9wYWNpdHk7XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgdmFyeWluZ3M6IFtcInZhcnlpbmcgdmVjNCB2Q29sb3I7XCIsIFwiI2lmZGVmIFNIT1VMRF9ST1RBVEVfVEVYVFVSRVwiLCBcIiAgICB2YXJ5aW5nIGZsb2F0IHZBbmdsZTtcIiwgXCIjZW5kaWZcIiwgXCIjaWZkZWYgU0hPVUxEX0NBTENVTEFURV9TUFJJVEVcIiwgXCIgICAgdmFyeWluZyB2ZWM0IHZTcHJpdGVTaGVldDtcIiwgXCIjZW5kaWZcIl0uam9pbihcIlxcblwiKSxcbiAgICBicmFuY2hBdm9pZGFuY2VGdW5jdGlvbnM6IFtcImZsb2F0IHdoZW5fZ3QoZmxvYXQgeCwgZmxvYXQgeSkge1wiLCBcIiAgICByZXR1cm4gbWF4KHNpZ24oeCAtIHkpLCAwLjApO1wiLCBcIn1cIiwgXCJmbG9hdCB3aGVuX2x0KGZsb2F0IHgsIGZsb2F0IHkpIHtcIiwgXCIgICAgcmV0dXJuIG1pbiggbWF4KDEuMCAtIHNpZ24oeCAtIHkpLCAwLjApLCAxLjAgKTtcIiwgXCJ9XCIsIFwiZmxvYXQgd2hlbl9lcSggZmxvYXQgeCwgZmxvYXQgeSApIHtcIiwgXCIgICAgcmV0dXJuIDEuMCAtIGFicyggc2lnbiggeCAtIHkgKSApO1wiLCBcIn1cIiwgXCJmbG9hdCB3aGVuX2dlKGZsb2F0IHgsIGZsb2F0IHkpIHtcIiwgXCIgIHJldHVybiAxLjAgLSB3aGVuX2x0KHgsIHkpO1wiLCBcIn1cIiwgXCJmbG9hdCB3aGVuX2xlKGZsb2F0IHgsIGZsb2F0IHkpIHtcIiwgXCIgIHJldHVybiAxLjAgLSB3aGVuX2d0KHgsIHkpO1wiLCBcIn1cIiwgXCJmbG9hdCBhbmQoZmxvYXQgYSwgZmxvYXQgYikge1wiLCBcIiAgICByZXR1cm4gYSAqIGI7XCIsIFwifVwiLCBcImZsb2F0IG9yKGZsb2F0IGEsIGZsb2F0IGIpIHtcIiwgXCIgICAgcmV0dXJuIG1pbihhICsgYiwgMS4wKTtcIiwgXCJ9XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgdW5wYWNrQ29sb3I6IFtcInZlYzMgdW5wYWNrQ29sb3IoIGluIGZsb2F0IGhleCApIHtcIiwgXCIgICB2ZWMzIGMgPSB2ZWMzKCAwLjAgKTtcIiwgXCIgICBmbG9hdCByID0gbW9kKCAoaGV4IC8gUEFDS0VEX0NPTE9SX1NJWkUgLyBQQUNLRURfQ09MT1JfU0laRSksIFBBQ0tFRF9DT0xPUl9TSVpFICk7XCIsIFwiICAgZmxvYXQgZyA9IG1vZCggKGhleCAvIFBBQ0tFRF9DT0xPUl9TSVpFKSwgUEFDS0VEX0NPTE9SX1NJWkUgKTtcIiwgXCIgICBmbG9hdCBiID0gbW9kKCBoZXgsIFBBQ0tFRF9DT0xPUl9TSVpFICk7XCIsIFwiICAgYy5yID0gciAvIFBBQ0tFRF9DT0xPUl9ESVZJU09SO1wiLCBcIiAgIGMuZyA9IGcgLyBQQUNLRURfQ09MT1JfRElWSVNPUjtcIiwgXCIgICBjLmIgPSBiIC8gUEFDS0VEX0NPTE9SX0RJVklTT1I7XCIsIFwiICAgcmV0dXJuIGM7XCIsIFwifVwiXS5qb2luKFwiXFxuXCIpLFxuICAgIGZsb2F0T3ZlckxpZmV0aW1lOiBbXCJmbG9hdCBnZXRGbG9hdE92ZXJMaWZldGltZSggaW4gZmxvYXQgcG9zaXRpb25JblRpbWUsIGluIHZlYzQgYXR0ciApIHtcIiwgXCIgICAgaGlnaHAgZmxvYXQgdmFsdWUgPSAwLjA7XCIsIFwiICAgIGZsb2F0IGRlbHRhQWdlID0gcG9zaXRpb25JblRpbWUgKiBmbG9hdCggVkFMVUVfT1ZFUl9MSUZFVElNRV9MRU5HVEggLSAxICk7XCIsIFwiICAgIGZsb2F0IGZJbmRleCA9IDAuMDtcIiwgXCIgICAgZmxvYXQgc2hvdWxkQXBwbHlWYWx1ZSA9IDAuMDtcIiwgXCIgICAgdmFsdWUgKz0gYXR0clsgMCBdICogd2hlbl9lcSggZGVsdGFBZ2UsIDAuMCApO1wiLCBcIlwiLCBcIiAgICBmb3IoIGludCBpID0gMDsgaSA8IFZBTFVFX09WRVJfTElGRVRJTUVfTEVOR1RIIC0gMTsgKytpICkge1wiLCBcIiAgICAgICBmSW5kZXggPSBmbG9hdCggaSApO1wiLCBcIiAgICAgICBzaG91bGRBcHBseVZhbHVlID0gYW5kKCB3aGVuX2d0KCBkZWx0YUFnZSwgZkluZGV4ICksIHdoZW5fbGUoIGRlbHRhQWdlLCBmSW5kZXggKyAxLjAgKSApO1wiLCBcIiAgICAgICB2YWx1ZSArPSBzaG91bGRBcHBseVZhbHVlICogbWl4KCBhdHRyWyBpIF0sIGF0dHJbIGkgKyAxIF0sIGRlbHRhQWdlIC0gZkluZGV4ICk7XCIsIFwiICAgIH1cIiwgXCJcIiwgXCIgICAgcmV0dXJuIHZhbHVlO1wiLCBcIn1cIl0uam9pbihcIlxcblwiKSxcbiAgICBjb2xvck92ZXJMaWZldGltZTogW1widmVjMyBnZXRDb2xvck92ZXJMaWZldGltZSggaW4gZmxvYXQgcG9zaXRpb25JblRpbWUsIGluIHZlYzMgY29sb3IxLCBpbiB2ZWMzIGNvbG9yMiwgaW4gdmVjMyBjb2xvcjMsIGluIHZlYzMgY29sb3I0ICkge1wiLCBcIiAgICB2ZWMzIHZhbHVlID0gdmVjMyggMC4wICk7XCIsIFwiICAgIHZhbHVlLnggPSBnZXRGbG9hdE92ZXJMaWZldGltZSggcG9zaXRpb25JblRpbWUsIHZlYzQoIGNvbG9yMS54LCBjb2xvcjIueCwgY29sb3IzLngsIGNvbG9yNC54ICkgKTtcIiwgXCIgICAgdmFsdWUueSA9IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgdmVjNCggY29sb3IxLnksIGNvbG9yMi55LCBjb2xvcjMueSwgY29sb3I0LnkgKSApO1wiLCBcIiAgICB2YWx1ZS56ID0gZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIHBvc2l0aW9uSW5UaW1lLCB2ZWM0KCBjb2xvcjEueiwgY29sb3IyLnosIGNvbG9yMy56LCBjb2xvcjQueiApICk7XCIsIFwiICAgIHJldHVybiB2YWx1ZTtcIiwgXCJ9XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgcGFyYW1GZXRjaGluZ0Z1bmN0aW9uczogW1wiZmxvYXQgZ2V0QWxpdmUoKSB7XCIsIFwiICAgcmV0dXJuIHBhcmFtcy54O1wiLCBcIn1cIiwgXCJmbG9hdCBnZXRBZ2UoKSB7XCIsIFwiICAgcmV0dXJuIHBhcmFtcy55O1wiLCBcIn1cIiwgXCJmbG9hdCBnZXRNYXhBZ2UoKSB7XCIsIFwiICAgcmV0dXJuIHBhcmFtcy56O1wiLCBcIn1cIiwgXCJmbG9hdCBnZXRXaWdnbGUoKSB7XCIsIFwiICAgcmV0dXJuIHBhcmFtcy53O1wiLCBcIn1cIl0uam9pbihcIlxcblwiKSxcbiAgICBmb3JjZUZldGNoaW5nRnVuY3Rpb25zOiBbXCJ2ZWM0IGdldFBvc2l0aW9uKCBpbiBmbG9hdCBhZ2UgKSB7XCIsIFwiICAgcmV0dXJuIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIiwgXCJ9XCIsIFwidmVjMyBnZXRWZWxvY2l0eSggaW4gZmxvYXQgYWdlICkge1wiLCBcIiAgIHJldHVybiB2ZWxvY2l0eSAqIGFnZTtcIiwgXCJ9XCIsIFwidmVjMyBnZXRBY2NlbGVyYXRpb24oIGluIGZsb2F0IGFnZSApIHtcIiwgXCIgICByZXR1cm4gYWNjZWxlcmF0aW9uLnh5eiAqIGFnZTtcIiwgXCJ9XCJdLmpvaW4oXCJcXG5cIiksXG4gICAgcm90YXRpb25GdW5jdGlvbnM6IFtcIiNpZmRlZiBTSE9VTERfUk9UQVRFX1BBUlRJQ0xFU1wiLCBcIiAgIG1hdDQgZ2V0Um90YXRpb25NYXRyaXgoIGluIHZlYzMgYXhpcywgaW4gZmxvYXQgYW5nbGUpIHtcIiwgXCIgICAgICAgYXhpcyA9IG5vcm1hbGl6ZShheGlzKTtcIiwgXCIgICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZSk7XCIsIFwiICAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGUpO1wiLCBcIiAgICAgICBmbG9hdCBvYyA9IDEuMCAtIGM7XCIsIFwiICAgICAgIHJldHVybiBtYXQ0KG9jICogYXhpcy54ICogYXhpcy54ICsgYywgICAgICAgICAgIG9jICogYXhpcy54ICogYXhpcy55IC0gYXhpcy56ICogcywgIG9jICogYXhpcy56ICogYXhpcy54ICsgYXhpcy55ICogcywgIDAuMCxcIiwgXCIgICAgICAgICAgICAgICAgICAgb2MgKiBheGlzLnggKiBheGlzLnkgKyBheGlzLnogKiBzLCAgb2MgKiBheGlzLnkgKiBheGlzLnkgKyBjLCAgICAgICAgICAgb2MgKiBheGlzLnkgKiBheGlzLnogLSBheGlzLnggKiBzLCAgMC4wLFwiLCBcIiAgICAgICAgICAgICAgICAgICBvYyAqIGF4aXMueiAqIGF4aXMueCAtIGF4aXMueSAqIHMsICBvYyAqIGF4aXMueSAqIGF4aXMueiArIGF4aXMueCAqIHMsICBvYyAqIGF4aXMueiAqIGF4aXMueiArIGMsICAgICAgICAgICAwLjAsXCIsIFwiICAgICAgICAgICAgICAgICAgIDAuMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCk7XCIsIFwiICAgfVwiLCBcIiAgIHZlYzMgZ2V0Um90YXRpb24oIGluIHZlYzMgcG9zLCBpbiBmbG9hdCBwb3NpdGlvbkluVGltZSApIHtcIiwgXCIgICAgICB2ZWMzIGF4aXMgPSB1bnBhY2tDb2xvciggcm90YXRpb24ueCApO1wiLCBcIiAgICAgIHZlYzMgY2VudGVyID0gcm90YXRpb25DZW50ZXI7XCIsIFwiICAgICAgdmVjMyB0cmFuc2xhdGVkO1wiLCBcIiAgICAgIG1hdDQgcm90YXRpb25NYXRyaXg7XCIsIFwiICAgICAgZmxvYXQgYW5nbGUgPSAwLjA7XCIsIFwiICAgICAgYW5nbGUgKz0gd2hlbl9lcSggcm90YXRpb24ueiwgMC4wICkgKiByb3RhdGlvbi55O1wiLCBcIiAgICAgIGFuZ2xlICs9IHdoZW5fZ3QoIHJvdGF0aW9uLnosIDAuMCApICogbWl4KCAwLjAsIHJvdGF0aW9uLnksIHBvc2l0aW9uSW5UaW1lICk7XCIsIFwiICAgICAgdHJhbnNsYXRlZCA9IHBvcyAtIHJvdGF0aW9uQ2VudGVyO1wiLCBcIiAgICAgIHJvdGF0aW9uTWF0cml4ID0gZ2V0Um90YXRpb25NYXRyaXgoIGF4aXMsIGFuZ2xlICk7XCIsIFwiICAgICAgcmV0dXJuIHZlYzMoIHJvdGF0aW9uTWF0cml4ICogdmVjNCggdHJhbnNsYXRlZCwgMC4wICkgKSAtIGNlbnRlcjtcIiwgXCIgICB9XCIsIFwiI2VuZGlmXCJdLmpvaW4oXCJcXG5cIiksXG4gICAgcm90YXRlVGV4dHVyZTogW1wiICAgIHZlYzIgdlV2ID0gdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKTtcIiwgXCJcIiwgXCIgICAgI2lmZGVmIFNIT1VMRF9ST1RBVEVfVEVYVFVSRVwiLCBcIiAgICAgICBmbG9hdCB4ID0gZ2xfUG9pbnRDb29yZC54IC0gMC41O1wiLCBcIiAgICAgICBmbG9hdCB5ID0gMS4wIC0gZ2xfUG9pbnRDb29yZC55IC0gMC41O1wiLCBcIiAgICAgICBmbG9hdCBjID0gY29zKCAtdkFuZ2xlICk7XCIsIFwiICAgICAgIGZsb2F0IHMgPSBzaW4oIC12QW5nbGUgKTtcIiwgXCIgICAgICAgdlV2ID0gdmVjMiggYyAqIHggKyBzICogeSArIDAuNSwgYyAqIHkgLSBzICogeCArIDAuNSApO1wiLCBcIiAgICAjZW5kaWZcIiwgXCJcIiwgXCIgICAgI2lmZGVmIFNIT1VMRF9DQUxDVUxBVEVfU1BSSVRFXCIsIFwiICAgICAgICBmbG9hdCBmcmFtZXNYID0gdlNwcml0ZVNoZWV0Lng7XCIsIFwiICAgICAgICBmbG9hdCBmcmFtZXNZID0gdlNwcml0ZVNoZWV0Lnk7XCIsIFwiICAgICAgICBmbG9hdCBjb2x1bW5Ob3JtID0gdlNwcml0ZVNoZWV0Lno7XCIsIFwiICAgICAgICBmbG9hdCByb3dOb3JtID0gdlNwcml0ZVNoZWV0Lnc7XCIsIFwiICAgICAgICB2VXYueCA9IGdsX1BvaW50Q29vcmQueCAqIGZyYW1lc1ggKyBjb2x1bW5Ob3JtO1wiLCBcIiAgICAgICAgdlV2LnkgPSAxLjAgLSAoZ2xfUG9pbnRDb29yZC55ICogZnJhbWVzWSArIHJvd05vcm0pO1wiLCBcIiAgICAjZW5kaWZcIiwgXCJcIiwgXCIgICAgdmVjNCByb3RhdGVkVGV4dHVyZSA9IHRleHR1cmUyRCggdGV4dHVyZSwgdlV2ICk7XCJdLmpvaW4oXCJcXG5cIilcbn0sIFNQRS5zaGFkZXJzID0ge1xuICAgIHZlcnRleDogW1NQRS5zaGFkZXJDaHVua3MuZGVmaW5lcywgU1BFLnNoYWRlckNodW5rcy51bmlmb3JtcywgU1BFLnNoYWRlckNodW5rcy5hdHRyaWJ1dGVzLCBTUEUuc2hhZGVyQ2h1bmtzLnZhcnlpbmdzLCBUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sIFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4LCBTUEUuc2hhZGVyQ2h1bmtzLmJyYW5jaEF2b2lkYW5jZUZ1bmN0aW9ucywgU1BFLnNoYWRlckNodW5rcy51bnBhY2tDb2xvciwgU1BFLnNoYWRlckNodW5rcy5mbG9hdE92ZXJMaWZldGltZSwgU1BFLnNoYWRlckNodW5rcy5jb2xvck92ZXJMaWZldGltZSwgU1BFLnNoYWRlckNodW5rcy5wYXJhbUZldGNoaW5nRnVuY3Rpb25zLCBTUEUuc2hhZGVyQ2h1bmtzLmZvcmNlRmV0Y2hpbmdGdW5jdGlvbnMsIFNQRS5zaGFkZXJDaHVua3Mucm90YXRpb25GdW5jdGlvbnMsIFwidm9pZCBtYWluKCkge1wiLCBcIiAgICBoaWdocCBmbG9hdCBhZ2UgPSBnZXRBZ2UoKTtcIiwgXCIgICAgaGlnaHAgZmxvYXQgYWxpdmUgPSBnZXRBbGl2ZSgpO1wiLCBcIiAgICBoaWdocCBmbG9hdCBtYXhBZ2UgPSBnZXRNYXhBZ2UoKTtcIiwgXCIgICAgaGlnaHAgZmxvYXQgcG9zaXRpb25JblRpbWUgPSAoYWdlIC8gbWF4QWdlKTtcIiwgXCIgICAgaGlnaHAgZmxvYXQgaXNBbGl2ZSA9IHdoZW5fZ3QoIGFsaXZlLCAwLjAgKTtcIiwgXCIgICAgI2lmZGVmIFNIT1VMRF9XSUdHTEVfUEFSVElDTEVTXCIsIFwiICAgICAgICBmbG9hdCB3aWdnbGVBbW91bnQgPSBwb3NpdGlvbkluVGltZSAqIGdldFdpZ2dsZSgpO1wiLCBcIiAgICAgICAgZmxvYXQgd2lnZ2xlU2luID0gaXNBbGl2ZSAqIHNpbiggd2lnZ2xlQW1vdW50ICk7XCIsIFwiICAgICAgICBmbG9hdCB3aWdnbGVDb3MgPSBpc0FsaXZlICogY29zKCB3aWdnbGVBbW91bnQgKTtcIiwgXCIgICAgI2VuZGlmXCIsIFwiICAgIHZlYzMgdmVsID0gZ2V0VmVsb2NpdHkoIGFnZSApO1wiLCBcIiAgICB2ZWMzIGFjY2VsID0gZ2V0QWNjZWxlcmF0aW9uKCBhZ2UgKTtcIiwgXCIgICAgdmVjMyBmb3JjZSA9IHZlYzMoIDAuMCApO1wiLCBcIiAgICB2ZWMzIHBvcyA9IHZlYzMoIHBvc2l0aW9uICk7XCIsIFwiICAgIGZsb2F0IGRyYWcgPSAxLjAgLSAocG9zaXRpb25JblRpbWUgKiAwLjUpICogYWNjZWxlcmF0aW9uLnc7XCIsIFwiICAgIGZvcmNlICs9IHZlbDtcIiwgXCIgICAgZm9yY2UgKj0gZHJhZztcIiwgXCIgICAgZm9yY2UgKz0gYWNjZWwgKiBhZ2U7XCIsIFwiICAgIHBvcyArPSBmb3JjZTtcIiwgXCIgICAgI2lmZGVmIFNIT1VMRF9XSUdHTEVfUEFSVElDTEVTXCIsIFwiICAgICAgICBwb3MueCArPSB3aWdnbGVTaW47XCIsIFwiICAgICAgICBwb3MueSArPSB3aWdnbGVDb3M7XCIsIFwiICAgICAgICBwb3MueiArPSB3aWdnbGVTaW47XCIsIFwiICAgICNlbmRpZlwiLCBcIiAgICAjaWZkZWYgU0hPVUxEX1JPVEFURV9QQVJUSUNMRVNcIiwgXCIgICAgICAgIHBvcyA9IGdldFJvdGF0aW9uKCBwb3MsIHBvc2l0aW9uSW5UaW1lICk7XCIsIFwiICAgICNlbmRpZlwiLCBcIiAgICB2ZWM0IG12UG9zID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zLCAxLjAgKTtcIiwgXCIgICAgaGlnaHAgZmxvYXQgcG9pbnRTaXplID0gZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIHBvc2l0aW9uSW5UaW1lLCBzaXplICkgKiBpc0FsaXZlO1wiLCBcIiAgICAjaWZkZWYgSEFTX1BFUlNQRUNUSVZFXCIsIFwiICAgICAgICBmbG9hdCBwZXJzcGVjdGl2ZSA9IHNjYWxlIC8gbGVuZ3RoKCBtdlBvcy54eXogKTtcIiwgXCIgICAgI2Vsc2VcIiwgXCIgICAgICAgIGZsb2F0IHBlcnNwZWN0aXZlID0gMS4wO1wiLCBcIiAgICAjZW5kaWZcIiwgXCIgICAgZmxvYXQgcG9pbnRTaXplUGVyc3BlY3RpdmUgPSBwb2ludFNpemUgKiBwZXJzcGVjdGl2ZTtcIiwgXCIgICAgI2lmZGVmIENPTE9SSVpFXCIsIFwiICAgICAgIHZlYzMgYyA9IGlzQWxpdmUgKiBnZXRDb2xvck92ZXJMaWZldGltZShcIiwgXCIgICAgICAgICAgIHBvc2l0aW9uSW5UaW1lLFwiLCBcIiAgICAgICAgICAgdW5wYWNrQ29sb3IoIGNvbG9yLnggKSxcIiwgXCIgICAgICAgICAgIHVucGFja0NvbG9yKCBjb2xvci55ICksXCIsIFwiICAgICAgICAgICB1bnBhY2tDb2xvciggY29sb3IueiApLFwiLCBcIiAgICAgICAgICAgdW5wYWNrQ29sb3IoIGNvbG9yLncgKVwiLCBcIiAgICAgICApO1wiLCBcIiAgICAjZWxzZVwiLCBcIiAgICAgICB2ZWMzIGMgPSB2ZWMzKDEuMCk7XCIsIFwiICAgICNlbmRpZlwiLCBcIiAgICBmbG9hdCBvID0gaXNBbGl2ZSAqIGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgb3BhY2l0eSApO1wiLCBcIiAgICB2Q29sb3IgPSB2ZWM0KCBjLCBvICk7XCIsIFwiICAgICNpZmRlZiBTSE9VTERfUk9UQVRFX1RFWFRVUkVcIiwgXCIgICAgICAgIHZBbmdsZSA9IGlzQWxpdmUgKiBnZXRGbG9hdE92ZXJMaWZldGltZSggcG9zaXRpb25JblRpbWUsIGFuZ2xlICk7XCIsIFwiICAgICNlbmRpZlwiLCBcIiAgICAjaWZkZWYgU0hPVUxEX0NBTENVTEFURV9TUFJJVEVcIiwgXCIgICAgICAgIGZsb2F0IGZyYW1lc1ggPSB0ZXh0dXJlQW5pbWF0aW9uLng7XCIsIFwiICAgICAgICBmbG9hdCBmcmFtZXNZID0gdGV4dHVyZUFuaW1hdGlvbi55O1wiLCBcIiAgICAgICAgZmxvYXQgbG9vcENvdW50ID0gdGV4dHVyZUFuaW1hdGlvbi53O1wiLCBcIiAgICAgICAgZmxvYXQgdG90YWxGcmFtZXMgPSB0ZXh0dXJlQW5pbWF0aW9uLno7XCIsIFwiICAgICAgICBmbG9hdCBmcmFtZU51bWJlciA9IG1vZCggKHBvc2l0aW9uSW5UaW1lICogbG9vcENvdW50KSAqIHRvdGFsRnJhbWVzLCB0b3RhbEZyYW1lcyApO1wiLCBcIiAgICAgICAgZmxvYXQgY29sdW1uID0gZmxvb3IobW9kKCBmcmFtZU51bWJlciwgZnJhbWVzWCApKTtcIiwgXCIgICAgICAgIGZsb2F0IHJvdyA9IGZsb29yKCAoZnJhbWVOdW1iZXIgLSBjb2x1bW4pIC8gZnJhbWVzWCApO1wiLCBcIiAgICAgICAgZmxvYXQgY29sdW1uTm9ybSA9IGNvbHVtbiAvIGZyYW1lc1g7XCIsIFwiICAgICAgICBmbG9hdCByb3dOb3JtID0gcm93IC8gZnJhbWVzWTtcIiwgXCIgICAgICAgIHZTcHJpdGVTaGVldC54ID0gMS4wIC8gZnJhbWVzWDtcIiwgXCIgICAgICAgIHZTcHJpdGVTaGVldC55ID0gMS4wIC8gZnJhbWVzWTtcIiwgXCIgICAgICAgIHZTcHJpdGVTaGVldC56ID0gY29sdW1uTm9ybTtcIiwgXCIgICAgICAgIHZTcHJpdGVTaGVldC53ID0gcm93Tm9ybTtcIiwgXCIgICAgI2VuZGlmXCIsIFwiICAgIGdsX1BvaW50U2l6ZSA9IHBvaW50U2l6ZVBlcnNwZWN0aXZlO1wiLCBcIiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvcztcIiwgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfdmVydGV4LCBcIn1cIl0uam9pbihcIlxcblwiKSxcbiAgICBmcmFnbWVudDogW1NQRS5zaGFkZXJDaHVua3MudW5pZm9ybXMsIFRIUkVFLlNoYWRlckNodW5rLmNvbW1vbiwgVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX3BhcnNfZnJhZ21lbnQsIFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsIFNQRS5zaGFkZXJDaHVua3MudmFyeWluZ3MsIFNQRS5zaGFkZXJDaHVua3MuYnJhbmNoQXZvaWRhbmNlRnVuY3Rpb25zLCBcInZvaWQgbWFpbigpIHtcIiwgXCIgICAgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdkNvbG9yLnh5ejtcIiwgXCIgICAgXCIsIFwiICAgICNpZmRlZiBBTFBIQVRFU1RcIiwgXCIgICAgICAgaWYgKCB2Q29sb3IudyA8IGZsb2F0KEFMUEhBVEVTVCkgKSBkaXNjYXJkO1wiLCBcIiAgICAjZW5kaWZcIiwgU1BFLnNoYWRlckNodW5rcy5yb3RhdGVUZXh0dXJlLCBUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9mcmFnbWVudCwgXCIgICAgb3V0Z29pbmdMaWdodCA9IHZDb2xvci54eXogKiByb3RhdGVkVGV4dHVyZS54eXo7XCIsIFRIUkVFLlNoYWRlckNodW5rLmZvZ19mcmFnbWVudCwgXCIgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodC54eXosIHJvdGF0ZWRUZXh0dXJlLncgKiB2Q29sb3IudyApO1wiLCBcIn1cIl0uam9pbihcIlxcblwiKVxufSwgU1BFLnV0aWxzID0ge1xuICAgIHR5cGVzOiB7XG4gICAgICAgIEJPT0xFQU46IFwiYm9vbGVhblwiLFxuICAgICAgICBTVFJJTkc6IFwic3RyaW5nXCIsXG4gICAgICAgIE5VTUJFUjogXCJudW1iZXJcIixcbiAgICAgICAgT0JKRUNUOiBcIm9iamVjdFwiXG4gICAgfSxcbiAgICBlbnN1cmVUeXBlZEFyZzogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSBiID8gYSA6IGNcbiAgICB9LFxuICAgIGVuc3VyZUFycmF5VHlwZWRBcmc6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gYS5sZW5ndGggLSAxOyBkID49IDA7IC0tZClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFbZF0gIT09IGIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVUeXBlZEFyZyhhLCBiLCBjKVxuICAgIH0sXG4gICAgZW5zdXJlSW5zdGFuY2VPZjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gYiAmJiBhIGluc3RhbmNlb2YgYiA/IGEgOiBjO1xuICAgIH0sXG4gICAgZW5zdXJlQXJyYXlJbnN0YW5jZU9mOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IGEubGVuZ3RoIC0gMTsgZCA+PSAwOyAtLWQpXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYiAmJiBhW2RdIGluc3RhbmNlb2YgYiA9PSAhMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluc3RhbmNlT2YoYSwgYiwgYylcbiAgICB9LFxuICAgIGVuc3VyZVZhbHVlT3ZlckxpZmV0aW1lQ29tcGxpYW5jZTogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgYiA9IGIgfHwgMywgYyA9IGMgfHwgMywgQXJyYXkuaXNBcnJheShhLl92YWx1ZSkgPT09ICExICYmIChhLl92YWx1ZSA9IFthLl92YWx1ZV0pLCBBcnJheS5pc0FycmF5KGEuX3NwcmVhZCkgPT09ICExICYmIChhLl9zcHJlYWQgPSBbYS5fc3ByZWFkXSk7XG4gICAgICAgIHZhciBkID0gdGhpcy5jbGFtcChhLl92YWx1ZS5sZW5ndGgsIGIsIGMpLFxuICAgICAgICAgICAgZSA9IHRoaXMuY2xhbXAoYS5fc3ByZWFkLmxlbmd0aCwgYiwgYyksXG4gICAgICAgICAgICBmID0gTWF0aC5tYXgoZCwgZSk7XG4gICAgICAgIGEuX3ZhbHVlLmxlbmd0aCAhPT0gZiAmJiAoYS5fdmFsdWUgPSB0aGlzLmludGVycG9sYXRlQXJyYXkoYS5fdmFsdWUsIGYpKSwgYS5fc3ByZWFkLmxlbmd0aCAhPT0gZiAmJiAoYS5fc3ByZWFkID0gdGhpcy5pbnRlcnBvbGF0ZUFycmF5KGEuX3NwcmVhZCwgZikpXG4gICAgfSxcbiAgICBpbnRlcnBvbGF0ZUFycmF5OiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmb3IgKHZhciBjID0gYS5sZW5ndGgsIGQgPSBbXCJmdW5jdGlvblwiID09IHR5cGVvZiBhWzBdLmNsb25lID8gYVswXS5jbG9uZSgpIDogYVswXV0sIGUgPSAoYyAtIDEpIC8gKGIgLSAxKSwgZiA9IDE7IGIgLSAxID4gZjsgKytmKSB7XG4gICAgICAgICAgICB2YXIgZyA9IGYgKiBlLFxuICAgICAgICAgICAgICAgIGggPSBNYXRoLmZsb29yKGcpLFxuICAgICAgICAgICAgICAgIGkgPSBNYXRoLmNlaWwoZyksXG4gICAgICAgICAgICAgICAgaiA9IGcgLSBoO1xuICAgICAgICAgICAgZFtmXSA9IHRoaXMubGVycFR5cGVBZ25vc3RpYyhhW2hdLCBhW2ldLCBqKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkLnB1c2goXCJmdW5jdGlvblwiID09IHR5cGVvZiBhW2MgLSAxXS5jbG9uZSA/IGFbYyAtIDFdLmNsb25lKCkgOiBhW2MgLSAxXSksIGRcbiAgICB9LFxuICAgIGNsYW1wOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoYiwgTWF0aC5taW4oYSwgYykpXG4gICAgfSxcbiAgICB6ZXJvVG9FcHNpbG9uOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgYyA9IDFlLTUsXG4gICAgICAgICAgICBkID0gYTtcbiAgICAgICAgcmV0dXJuIGQgPSBiID8gTWF0aC5yYW5kb20oKSAqIGMgKiAxMCA6IGMsIDAgPiBhICYmIGEgPiAtYyAmJiAoZCA9IC1kKSwgZFxuICAgIH0sXG4gICAgbGVycFR5cGVBZ25vc3RpYzogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGQsXG4gICAgICAgICAgICBlID0gdGhpcy50eXBlcztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSBlLk5VTUJFUiAmJiB0eXBlb2YgYiA9PT0gZS5OVU1CRVIgPyBhICsgKGIgLSBhKSAqIGMgOiBhIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiAmJiBiIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiA/IChkID0gYS5jbG9uZSgpLCBkLnggPSB0aGlzLmxlcnAoYS54LCBiLngsIGMpLCBkLnkgPSB0aGlzLmxlcnAoYS55LCBiLnksIGMpLCBkKSA6IGEgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICYmIGIgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gKGQgPSBhLmNsb25lKCksIGQueCA9IHRoaXMubGVycChhLngsIGIueCwgYyksIGQueSA9IHRoaXMubGVycChhLnksIGIueSwgYyksIGQueiA9IHRoaXMubGVycChhLnosIGIueiwgYyksIGQpIDogYSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgJiYgYiBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgPyAoZCA9IGEuY2xvbmUoKSwgZC54ID0gdGhpcy5sZXJwKGEueCwgYi54LCBjKSwgZC55ID0gdGhpcy5sZXJwKGEueSwgYi55LCBjKSwgZC56ID0gdGhpcy5sZXJwKGEueiwgYi56LCBjKSwgZC53ID0gdGhpcy5sZXJwKGEudywgYi53LCBjKSwgZCkgOiBhIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgJiYgYiBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gKGQgPSBhLmNsb25lKCksIGQuciA9IHRoaXMubGVycChhLnIsIGIuciwgYyksIGQuZyA9IHRoaXMubGVycChhLmcsIGIuZywgYyksIGQuYiA9IHRoaXMubGVycChhLmIsIGIuYiwgYyksIGQpIDogdm9pZCBjb25zb2xlLndhcm4oXCJJbnZhbGlkIGFyZ3VtZW50IHR5cGVzLCBvciBhcmd1bWVudCB0eXBlcyBkbyBub3QgbWF0Y2g6XCIsIGEsIGIpXG4gICAgfSxcbiAgICBsZXJwOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiBjXG4gICAgfSxcbiAgICByb3VuZFRvTmVhcmVzdE11bHRpcGxlOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHJldHVybiAwID09PSBiID8gYSA6IChjID0gTWF0aC5hYnMoYSkgJSBiLFxuICAgICAgICAwID09PSBjID8gYSA6IDAgPiBhID8gLShNYXRoLmFicyhhKSAtIGMpIDogYSArIGIgLSBjKVxuICAgIH0sXG4gICAgYXJyYXlWYWx1ZXNBcmVFcXVhbDogZnVuY3Rpb24oYSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBhLmxlbmd0aCAtIDE7ICsrYilcbiAgICAgICAgICAgIGlmIChhW2JdICE9PSBhW2IgKyAxXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIHJldHVybiAhMFxuICAgIH0sXG4gICAgcmFuZG9tRmxvYXQ6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiBhICsgYiAqIChNYXRoLnJhbmRvbSgpIC0gLjUpXG4gICAgfSxcbiAgICByYW5kb21WZWN0b3IzOiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZiA9IGMueCArIChNYXRoLnJhbmRvbSgpICogZC54IC0gLjUgKiBkLngpLFxuICAgICAgICAgICAgZyA9IGMueSArIChNYXRoLnJhbmRvbSgpICogZC55IC0gLjUgKiBkLnkpLFxuICAgICAgICAgICAgaCA9IGMueiArIChNYXRoLnJhbmRvbSgpICogZC56IC0gLjUgKiBkLnopO1xuICAgICAgICBlICYmIChmID0gLjUgKiAtZS54ICsgdGhpcy5yb3VuZFRvTmVhcmVzdE11bHRpcGxlKGYsIGUueCksIGcgPSAuNSAqIC1lLnkgKyB0aGlzLnJvdW5kVG9OZWFyZXN0TXVsdGlwbGUoZywgZS55KSwgaCA9IC41ICogLWUueiArIHRoaXMucm91bmRUb05lYXJlc3RNdWx0aXBsZShoLCBlLnopKSwgYS50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKGIsIGYsIGcsIGgpXG4gICAgfSxcbiAgICByYW5kb21Db2xvcjogZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGUgPSBjLnIgKyBNYXRoLnJhbmRvbSgpICogZC54LFxuICAgICAgICAgICAgZiA9IGMuZyArIE1hdGgucmFuZG9tKCkgKiBkLnksXG4gICAgICAgICAgICBnID0gYy5iICsgTWF0aC5yYW5kb20oKSAqIGQuejtcbiAgICAgICAgZSA9IHRoaXMuY2xhbXAoZSwgMCwgMSksIGYgPSB0aGlzLmNsYW1wKGYsIDAsIDEpLCBnID0gdGhpcy5jbGFtcChnLCAwLCAxKSwgYS50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKGIsIGUsIGYsIGcpXG4gICAgfSxcbiAgICByYW5kb21Db2xvckFzSGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBhID0gbmV3IFRIUkVFLkNvbG9yO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYiwgYywgZCwgZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9IGQubGVuZ3RoLCBnID0gW10sIGggPSAwOyBmID4gaDsgKytoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlW2hdO1xuICAgICAgICAgICAgICAgIGEuY29weShkW2hdKSwgYS5yICs9IE1hdGgucmFuZG9tKCkgKiBpLnggLSAuNSAqIGkueCwgYS5nICs9IE1hdGgucmFuZG9tKCkgKiBpLnkgLSAuNSAqIGkueSwgYS5iICs9IE1hdGgucmFuZG9tKCkgKiBpLnogLSAuNSAqIGkueixcbiAgICAgICAgICAgICAgICBhLnIgPSB0aGlzLmNsYW1wKGEuciwgMCwgMSksIGEuZyA9IHRoaXMuY2xhbXAoYS5nLCAwLCAxKSwgYS5iID0gdGhpcy5jbGFtcChhLmIsIDAsIDEpLCBnLnB1c2goYS5nZXRIZXgoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIudHlwZWRBcnJheS5zZXRWZWM0Q29tcG9uZW50cyhjLCBnWzBdLCBnWzFdLCBnWzJdLCBnWzNdKVxuICAgICAgICB9XG4gICAgfSgpLFxuICAgIHJhbmRvbVZlY3RvcjNPblNwaGVyZTogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGkgPSAyICogTWF0aC5yYW5kb20oKSAtIDEsXG4gICAgICAgICAgICBqID0gNi4yODMyICogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgIGsgPSBNYXRoLnNxcnQoMSAtIGkgKiBpKSxcbiAgICAgICAgICAgIGwgPSB0aGlzLnJhbmRvbUZsb2F0KGQsIGUpLFxuICAgICAgICAgICAgbSA9IDAsXG4gICAgICAgICAgICBuID0gMCxcbiAgICAgICAgICAgIG8gPSAwO1xuICAgICAgICBnICYmIChsID0gTWF0aC5yb3VuZChsIC8gZykgKiBnKSwgbSA9IGsgKiBNYXRoLmNvcyhqKSAqIGwsIG4gPSBrICogTWF0aC5zaW4oaikgKiBsLCBvID0gaSAqIGwsIG0gKj0gZi54LCBuICo9IGYueSwgbyAqPSBmLnosIG0gKz0gYy54LCBuICs9IGMueSwgbyArPSBjLnosIGEudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyhiLCBtLCBuLCBvKVxuICAgIH0sXG4gICAgc2VlZGVkUmFuZG9tOiBmdW5jdGlvbihhKSB7XG4gICAgICAgIHZhciBiID0gMWU0ICogTWF0aC5zaW4oYSk7XG4gICAgICAgIHJldHVybiBiIC0gKDAgfCBiKVxuICAgIH0sXG4gICAgcmFuZG9tVmVjdG9yM09uRGlzYzogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGggPSA2LjI4MzIgKiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgICAgaSA9IE1hdGguYWJzKHRoaXMucmFuZG9tRmxvYXQoZCwgZSkpLFxuICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICBrID0gMCxcbiAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICBnICYmIChpID0gTWF0aC5yb3VuZChpIC8gZykgKiBnKSwgaiA9IE1hdGguY29zKGgpICogaSwgayA9IE1hdGguc2luKGgpICogaSwgaiAqPSBmLngsIGsgKj0gZi55LCBqICs9IGMueCwgayArPSBjLnksIGwgKz0gYy56LCBhLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoYiwgaiwgaywgbClcbiAgICB9LFxuICAgIHJhbmRvbURpcmVjdGlvblZlY3RvcjNPblNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgYSA9IG5ldyBUSFJFRS5WZWN0b3IzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge1xuICAgICAgICAgICAgYS5jb3B5KGcpLCBhLnggLT0gZCwgYS55IC09IGUsIGEueiAtPSBmLCBhLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKC10aGlzLnJhbmRvbUZsb2F0KGgsIGkpKSwgYi50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKGMsIGEueCwgYS55LCBhLnopO1xuICAgICAgICB9XG4gICAgfSgpLFxuICAgIHJhbmRvbURpcmVjdGlvblZlY3RvcjNPbkRpc2M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGEgPSBuZXcgVEhSRUUuVmVjdG9yMztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGIsIGMsIGQsIGUsIGYsIGcsIGgsIGkpIHtcbiAgICAgICAgICAgIGEuY29weShnKSwgYS54IC09IGQsIGEueSAtPSBlLCBhLnogLT0gZiwgYS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigtdGhpcy5yYW5kb21GbG9hdChoLCBpKSksIGIudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyhjLCBhLngsIGEueSwgMClcbiAgICAgICAgfVxuICAgIH0oKSxcbiAgICBnZXRQYWNrZWRSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGEgPSBuZXcgVEhSRUUuVmVjdG9yMyxcbiAgICAgICAgICAgIGIgPSBuZXcgVEhSRUUuVmVjdG9yMyxcbiAgICAgICAgICAgIGMgPSBuZXcgVEhSRUUuQ29sb3I7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkLCBlKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb3B5KGQpLm5vcm1hbGl6ZSgpLCBiLmNvcHkoZSkubm9ybWFsaXplKCksIGEueCArPSAuNSAqIC1lLnggKyBNYXRoLnJhbmRvbSgpICogZS54LCBhLnkgKz0gLjUgKiAtZS55ICsgTWF0aC5yYW5kb20oKSAqIGUueSwgYS56ICs9IC41ICogLWUueiArIE1hdGgucmFuZG9tKCkgKiBlLnosIGEueCA9IE1hdGguYWJzKGEueCksIGEueSA9IE1hdGguYWJzKGEueSksIGEueiA9IE1hdGguYWJzKGEueiksIGEubm9ybWFsaXplKCksIGMuc2V0UkdCKGEueCwgYS55LCBhLnopLCBjLmdldEhleCgpXG4gICAgICAgIH1cbiAgICB9KClcbn0sIFNQRS5Hcm91cCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYiA9IFNQRS51dGlscyxcbiAgICAgICAgYyA9IGIudHlwZXM7XG4gICAgYSA9IGIuZW5zdXJlVHlwZWRBcmcoYSwgYy5PQkpFQ1QsIHt9KSwgYS50ZXh0dXJlID0gYi5lbnN1cmVUeXBlZEFyZyhhLnRleHR1cmUsIGMuT0JKRUNULCB7fSksIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCksIHRoaXMuZml4ZWRUaW1lU3RlcCA9IGIuZW5zdXJlVHlwZWRBcmcoYS5maXhlZFRpbWVTdGVwLCBjLk5VTUJFUiwgLjAxNiksIHRoaXMudGV4dHVyZSA9IGIuZW5zdXJlSW5zdGFuY2VPZihhLnRleHR1cmUudmFsdWUsIFRIUkVFLlRleHR1cmUsIG51bGwpLCB0aGlzLnRleHR1cmVGcmFtZXMgPSBiLmVuc3VyZUluc3RhbmNlT2YoYS50ZXh0dXJlLmZyYW1lcywgVEhSRUUuVmVjdG9yMiwgbmV3IFRIUkVFLlZlY3RvcjIoMSwgMSkpLFxuICAgIHRoaXMudGV4dHVyZUZyYW1lQ291bnQgPSBiLmVuc3VyZVR5cGVkQXJnKGEudGV4dHVyZS5mcmFtZUNvdW50LCBjLk5VTUJFUiwgdGhpcy50ZXh0dXJlRnJhbWVzLnggKiB0aGlzLnRleHR1cmVGcmFtZXMueSksIHRoaXMudGV4dHVyZUxvb3AgPSBiLmVuc3VyZVR5cGVkQXJnKGEudGV4dHVyZS5sb29wLCBjLk5VTUJFUiwgMSksIHRoaXMudGV4dHVyZUZyYW1lcy5tYXgobmV3IFRIUkVFLlZlY3RvcjIoMSwgMSkpLCB0aGlzLmhhc1BlcnNwZWN0aXZlID0gYi5lbnN1cmVUeXBlZEFyZyhhLmhhc1BlcnNwZWN0aXZlLCBjLkJPT0xFQU4sICEwKSwgdGhpcy5jb2xvcml6ZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5jb2xvcml6ZSwgYy5CT09MRUFOLCAhMCksIHRoaXMubWF4UGFydGljbGVDb3VudCA9IGIuZW5zdXJlVHlwZWRBcmcoYS5tYXhQYXJ0aWNsZUNvdW50LCBjLk5VTUJFUiwgbnVsbCksIHRoaXMuYmxlbmRpbmcgPSBiLmVuc3VyZVR5cGVkQXJnKGEuYmxlbmRpbmcsIGMuTlVNQkVSLCBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nKSwgdGhpcy50cmFuc3BhcmVudCA9IGIuZW5zdXJlVHlwZWRBcmcoYS50cmFuc3BhcmVudCwgYy5CT09MRUFOLCAhMCksIHRoaXMuYWxwaGFUZXN0ID0gcGFyc2VGbG9hdChiLmVuc3VyZVR5cGVkQXJnKGEuYWxwaGFUZXN0LCBjLk5VTUJFUiwgMCkpLCB0aGlzLmRlcHRoV3JpdGUgPSBiLmVuc3VyZVR5cGVkQXJnKGEuZGVwdGhXcml0ZSwgYy5CT09MRUFOLCAhMSksIHRoaXMuZGVwdGhUZXN0ID0gYi5lbnN1cmVUeXBlZEFyZyhhLmRlcHRoVGVzdCwgYy5CT09MRUFOLCAhMCksIHRoaXMuZm9nID0gYi5lbnN1cmVUeXBlZEFyZyhhLmZvZywgYy5CT09MRUFOLCAhMCksIHRoaXMuc2NhbGUgPSBiLmVuc3VyZVR5cGVkQXJnKGEuc2NhbGUsIGMuTlVNQkVSLCAzMDApLCB0aGlzLmVtaXR0ZXJzID0gW10sIHRoaXMuZW1pdHRlcklEcyA9IFtdLCB0aGlzLl9wb29sID0gW10sIHRoaXMuX3Bvb2xDcmVhdGlvblNldHRpbmdzID0gbnVsbCwgdGhpcy5fY3JlYXRlTmV3V2hlblBvb2xFbXB0eSA9IDAsIHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCA9ICExLCB0aGlzLl9hdHRyaWJ1dGVzTmVlZER5bmFtaWNSZXNldCA9ICExLFxuICAgIHRoaXMucGFydGljbGVDb3VudCA9IDAsIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidFwiLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudGV4dHVyZVxuICAgICAgICB9LFxuICAgICAgICB0ZXh0dXJlQW5pbWF0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcInY0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQodGhpcy50ZXh0dXJlRnJhbWVzLngsIHRoaXMudGV4dHVyZUZyYW1lcy55LCB0aGlzLnRleHR1cmVGcmFtZUNvdW50LCBNYXRoLm1heChNYXRoLmFicyh0aGlzLnRleHR1cmVMb29wKSwgMSkpXG4gICAgICAgIH0sXG4gICAgICAgIGZvZ0NvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGZvZ05lYXI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IDEwXG4gICAgICAgIH0sXG4gICAgICAgIGZvZ0Zhcjoge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMjAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvZ0RlbnNpdHk6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZlwiLFxuICAgICAgICAgICAgdmFsdWU6IC41XG4gICAgICAgIH0sXG4gICAgICAgIGRlbHRhVGltZToge1xuICAgICAgICAgICAgdHlwZTogXCJmXCIsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9LFxuICAgICAgICBydW5UaW1lOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZcIixcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYWxlXG4gICAgICAgIH1cbiAgICB9LCB0aGlzLmRlZmluZXMgPSB7XG4gICAgICAgIEhBU19QRVJTUEVDVElWRTogdGhpcy5oYXNQZXJzcGVjdGl2ZSxcbiAgICAgICAgQ09MT1JJWkU6IHRoaXMuY29sb3JpemUsXG4gICAgICAgIFZBTFVFX09WRVJfTElGRVRJTUVfTEVOR1RIOiBTUEUudmFsdWVPdmVyTGlmZXRpbWVMZW5ndGgsXG4gICAgICAgIFNIT1VMRF9ST1RBVEVfVEVYVFVSRTogITEsXG4gICAgICAgIFNIT1VMRF9ST1RBVEVfUEFSVElDTEVTOiAhMSxcbiAgICAgICAgU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVM6ICExLFxuICAgICAgICBTSE9VTERfQ0FMQ1VMQVRFX1NQUklURTogdGhpcy50ZXh0dXJlRnJhbWVzLnggPiAxIHx8IHRoaXMudGV4dHVyZUZyYW1lcy55ID4gMVxuICAgIH0sIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgcG9zaXRpb246IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjNcIiwgITApLFxuICAgICAgICBhY2NlbGVyYXRpb246IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjRcIiwgITApLFxuICAgICAgICB2ZWxvY2l0eTogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2M1wiLCAhMCksXG4gICAgICAgIHJvdGF0aW9uOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInY0XCIsICEwKSxcbiAgICAgICAgcm90YXRpb25DZW50ZXI6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjNcIiwgITApLFxuICAgICAgICBwYXJhbXM6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjRcIiwgITApLFxuICAgICAgICBzaXplOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZShcInY0XCIsICEwKSxcbiAgICAgICAgYW5nbGU6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjRcIiwgITApLFxuICAgICAgICBjb2xvcjogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoXCJ2NFwiLCAhMCksXG4gICAgICAgIG9wYWNpdHk6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKFwidjRcIiwgITApXG4gICAgfSwgdGhpcy5hdHRyaWJ1dGVLZXlzID0gT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKSwgdGhpcy5hdHRyaWJ1dGVDb3VudCA9IHRoaXMuYXR0cmlidXRlS2V5cy5sZW5ndGgsIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgICAgdmVydGV4U2hhZGVyOiBTUEUuc2hhZGVycy52ZXJ0ZXgsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBTUEUuc2hhZGVycy5mcmFnbWVudCxcbiAgICAgICAgYmxlbmRpbmc6IHRoaXMuYmxlbmRpbmcsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0aGlzLnRyYW5zcGFyZW50LFxuICAgICAgICBhbHBoYVRlc3Q6IHRoaXMuYWxwaGFUZXN0LFxuICAgICAgICBkZXB0aFdyaXRlOiB0aGlzLmRlcHRoV3JpdGUsXG4gICAgICAgIGRlcHRoVGVzdDogdGhpcy5kZXB0aFRlc3QsXG4gICAgICAgIGRlZmluZXM6IHRoaXMuZGVmaW5lcyxcbiAgICAgICAgZm9nOiB0aGlzLmZvZ1xuICAgIH0pLCB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LCB0aGlzLm1lc2ggPSBuZXcgVEhSRUUuUG9pbnRzKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpLCBudWxsID09PSB0aGlzLm1heFBhcnRpY2xlQ291bnQgJiYgY29uc29sZS53YXJuKFwiU1BFLkdyb3VwOiBObyBtYXhQYXJ0aWNsZUNvdW50IHNwZWNpZmllZC4gQWRkaW5nIGVtaXR0ZXJzIGFmdGVyIHJlbmRlcmluZyB3aWxsIHByb2JhYmx5IGNhdXNlIGVycm9ycy5cIilcbn0sIFNQRS5Hcm91cC5jb25zdHJ1Y3RvciA9IFNQRS5Hcm91cCwgU1BFLkdyb3VwLnByb3RvdHlwZS5fdXBkYXRlRGVmaW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhLFxuICAgICAgICBiID0gdGhpcy5lbWl0dGVycyxcbiAgICAgICAgYyA9IGIubGVuZ3RoIC0gMSxcbiAgICAgICAgZCA9IHRoaXMuZGVmaW5lcztcbiAgICBmb3IgKGM7IGMgPj0gMDsgLS1jKVxuICAgICAgICBhID0gYltjXSwgZC5TSE9VTERfQ0FMQ1VMQVRFX1NQUklURSB8fCAoZC5TSE9VTERfUk9UQVRFX1RFWFRVUkUgPSBkLlNIT1VMRF9ST1RBVEVfVEVYVFVSRSB8fCAhIU1hdGgubWF4KE1hdGgubWF4LmFwcGx5KG51bGwsIGEuYW5nbGUudmFsdWUpLCBNYXRoLm1heC5hcHBseShudWxsLCBhLmFuZ2xlLnNwcmVhZCkpKSxcbiAgICAgICAgZC5TSE9VTERfUk9UQVRFX1BBUlRJQ0xFUyA9IGQuU0hPVUxEX1JPVEFURV9QQVJUSUNMRVMgfHwgISFNYXRoLm1heChhLnJvdGF0aW9uLmFuZ2xlLCBhLnJvdGF0aW9uLmFuZ2xlU3ByZWFkKSwgZC5TSE9VTERfV0lHR0xFX1BBUlRJQ0xFUyA9IGQuU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVMgfHwgISFNYXRoLm1heChhLndpZ2dsZS52YWx1ZSwgYS53aWdnbGUuc3ByZWFkKTtcbiAgICB0aGlzLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gITBcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuX2FwcGx5QXR0cmlidXRlc1RvR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyA9IHRoaXMuYXR0cmlidXRlcyxcbiAgICAgICAgZCA9IHRoaXMuZ2VvbWV0cnksXG4gICAgICAgIGUgPSBkLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgZiBpbiBjKVxuICAgICAgICBjLmhhc093blByb3BlcnR5KGYpICYmIChhID0gY1tmXSwgYiA9IGVbZl0sIGIgPyBiLmFycmF5ID0gYS50eXBlZEFycmF5LmFycmF5IDogZC5hZGRBdHRyaWJ1dGUoZiwgYS5idWZmZXJBdHRyaWJ1dGUpLCBhLmJ1ZmZlckF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9ICEwKTtcbiAgICB0aGlzLmdlb21ldHJ5LnNldERyYXdSYW5nZSgwLCB0aGlzLnBhcnRpY2xlQ291bnQpXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLmFkZEVtaXR0ZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBTUEUuRW1pdHRlciA9PSAhMSlcbiAgICAgICAgcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcImBlbWl0dGVyYCBhcmd1bWVudCBtdXN0IGJlIGluc3RhbmNlIG9mIFNQRS5FbWl0dGVyLiBXYXMgcHJvdmlkZWQgd2l0aDpcIiwgYSk7XG4gICAgaWYgKHRoaXMuZW1pdHRlcklEcy5pbmRleE9mKGEudXVpZCkgPiAtMSlcbiAgICAgICAgcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIkVtaXR0ZXIgYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBncm91cC4gV2lsbCBub3QgYWRkIGFnYWluLlwiKTtcbiAgICBpZiAobnVsbCAhPT0gYS5ncm91cClcbiAgICAgICAgcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIkVtaXR0ZXIgYWxyZWFkeSBiZWxvbmdzIHRvIGFub3RoZXIgZ3JvdXAuIFdpbGwgbm90IGFkZCB0byByZXF1ZXN0ZWQgZ3JvdXAuXCIpO1xuICAgIHZhciBiID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICBjID0gdGhpcy5wYXJ0aWNsZUNvdW50LFxuICAgICAgICBkID0gYyArIGEucGFydGljbGVDb3VudDtcbiAgICB0aGlzLnBhcnRpY2xlQ291bnQgPSBkLCBudWxsICE9PSB0aGlzLm1heFBhcnRpY2xlQ291bnQgJiYgdGhpcy5wYXJ0aWNsZUNvdW50ID4gdGhpcy5tYXhQYXJ0aWNsZUNvdW50ICYmIGNvbnNvbGUud2FybihcIlNQRS5Hcm91cDogbWF4UGFydGljbGVDb3VudCBleGNlZWRlZC4gUmVxdWVzdGluZ1wiLCB0aGlzLnBhcnRpY2xlQ291bnQsIFwicGFydGljbGVzLCBjYW4gc3VwcG9ydCBvbmx5XCIsIHRoaXMubWF4UGFydGljbGVDb3VudCksIGEuX2NhbGN1bGF0ZVBQU1ZhbHVlKGEubWF4QWdlLl92YWx1ZSArIGEubWF4QWdlLl9zcHJlYWQpLCBhLl9zZXRCdWZmZXJVcGRhdGVSYW5nZXModGhpcy5hdHRyaWJ1dGVLZXlzKSwgYS5fc2V0QXR0cmlidXRlT2Zmc2V0KGMpLCBhLmdyb3VwID0gdGhpcywgYS5hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGUgaW4gYilcbiAgICAgICAgYi5oYXNPd25Qcm9wZXJ0eShlKSAmJiBiW2VdLl9jcmVhdGVCdWZmZXJBdHRyaWJ1dGUobnVsbCAhPT0gdGhpcy5tYXhQYXJ0aWNsZUNvdW50ID8gdGhpcy5tYXhQYXJ0aWNsZUNvdW50IDogdGhpcy5wYXJ0aWNsZUNvdW50KTtcbiAgICBmb3IgKHZhciBmID0gYzsgZCA+IGY7ICsrZilcbiAgICAgICAgYS5fYXNzaWduUG9zaXRpb25WYWx1ZShmKSwgYS5fYXNzaWduRm9yY2VWYWx1ZShmLCBcInZlbG9jaXR5XCIpLCBhLl9hc3NpZ25Gb3JjZVZhbHVlKGYsIFwiYWNjZWxlcmF0aW9uXCIpLCBhLl9hc3NpZ25BYnNMaWZldGltZVZhbHVlKGYsIFwib3BhY2l0eVwiKSwgYS5fYXNzaWduQWJzTGlmZXRpbWVWYWx1ZShmLCBcInNpemVcIiksIGEuX2Fzc2lnbkFuZ2xlVmFsdWUoZiksIGEuX2Fzc2lnblJvdGF0aW9uVmFsdWUoZiksIGEuX2Fzc2lnblBhcmFtc1ZhbHVlKGYpLCBhLl9hc3NpZ25Db2xvclZhbHVlKGYpO1xuICAgIHJldHVybiB0aGlzLl9hcHBseUF0dHJpYnV0ZXNUb0dlb21ldHJ5KCksIHRoaXMuZW1pdHRlcnMucHVzaChhKSwgdGhpcy5lbWl0dGVySURzLnB1c2goYS51dWlkKSwgdGhpcy5fdXBkYXRlRGVmaW5lcyhhKSwgdGhpcy5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9ICEwLCB0aGlzLmdlb21ldHJ5Lm5lZWRzVXBkYXRlID0gITAsIHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCA9ICEwLFxuICAgIHRoaXNcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUucmVtb3ZlRW1pdHRlciA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYiA9IHRoaXMuZW1pdHRlcklEcy5pbmRleE9mKGEudXVpZCk7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBTUEUuRW1pdHRlciA9PSAhMSlcbiAgICAgICAgcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcImBlbWl0dGVyYCBhcmd1bWVudCBtdXN0IGJlIGluc3RhbmNlIG9mIFNQRS5FbWl0dGVyLiBXYXMgcHJvdmlkZWQgd2l0aDpcIiwgYSk7XG4gICAgaWYgKC0xID09PSBiKVxuICAgICAgICByZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiRW1pdHRlciBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGdyb3VwLiBXaWxsIG5vdCByZW1vdmUuXCIpO1xuICAgIGZvciAodmFyIGMgPSBhLmF0dHJpYnV0ZU9mZnNldCwgZCA9IGMgKyBhLnBhcnRpY2xlQ291bnQsIGUgPSB0aGlzLmF0dHJpYnV0ZXMucGFyYW1zLnR5cGVkQXJyYXksIGYgPSBjOyBkID4gZjsgKytmKVxuICAgICAgICBlLmFycmF5WzQgKiBmXSA9IDAsIGUuYXJyYXlbNCAqIGYgKyAxXSA9IDA7XG4gICAgdGhpcy5lbWl0dGVycy5zcGxpY2UoYiwgMSksIHRoaXMuZW1pdHRlcklEcy5zcGxpY2UoYiwgMSk7XG4gICAgZm9yICh2YXIgZyBpbiB0aGlzLmF0dHJpYnV0ZXMpXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShnKSAmJiB0aGlzLmF0dHJpYnV0ZXNbZ10uc3BsaWNlKGMsIGQpO1xuICAgIHRoaXMucGFydGljbGVDb3VudCAtPSBhLnBhcnRpY2xlQ291bnQsIGEuX29uUmVtb3ZlKCksIHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCA9ICEwXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLmdldEZyb21Qb29sID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGEgPSB0aGlzLl9wb29sLFxuICAgICAgICBiID0gdGhpcy5fY3JlYXRlTmV3V2hlblBvb2xFbXB0eTtcbiAgICByZXR1cm4gYS5sZW5ndGggPyBhLnBvcCgpIDogYiA/IG5ldyBTUEUuRW1pdHRlcih0aGlzLl9wb29sQ3JlYXRpb25TZXR0aW5ncykgOiBudWxsXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLnJlbGVhc2VJbnRvUG9vbCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFNQRS5FbWl0dGVyID09ICExID8gdm9pZCBjb25zb2xlLmVycm9yKFwiQXJndW1lbnQgaXMgbm90IGluc3RhbmNlb2YgU1BFLkVtaXR0ZXI6XCIsIGEpIDogKGEucmVzZXQoKSxcbiAgICB0aGlzLl9wb29sLnVuc2hpZnQoYSksIHRoaXMpXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLmdldFBvb2wgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcy5fcG9vbFxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5hZGRQb29sID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkO1xuICAgIHRoaXMuX3Bvb2xDcmVhdGlvblNldHRpbmdzID0gYiwgdGhpcy5fY3JlYXRlTmV3V2hlblBvb2xFbXB0eSA9ICEhYztcbiAgICBmb3IgKHZhciBlID0gMDsgYSA+IGU7ICsrZSlcbiAgICAgICAgZCA9IEFycmF5LmlzQXJyYXkoYikgPyBuZXcgU1BFLkVtaXR0ZXIoYltlXSkgOiBuZXcgU1BFLkVtaXR0ZXIoYiksIHRoaXMuYWRkRW1pdHRlcihkKSwgdGhpcy5yZWxlYXNlSW50b1Bvb2woZCk7XG4gICAgcmV0dXJuIHRoaXNcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuX3RyaWdnZXJTaW5nbGVFbWl0dGVyID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiID0gdGhpcy5nZXRGcm9tUG9vbCgpLFxuICAgICAgICBjID0gdGhpcztcbiAgICByZXR1cm4gbnVsbCA9PT0gYiA/IHZvaWQgY29uc29sZS5sb2coXCJTUEUuR3JvdXAgcG9vbCByYW4gb3V0LlwiKSA6IChhIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiAoYi5wb3NpdGlvbi52YWx1ZS5jb3B5KGEpLCBiLnBvc2l0aW9uLnZhbHVlID0gYi5wb3NpdGlvbi52YWx1ZSksIGIuZW5hYmxlKCksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGIuZGlzYWJsZSgpLCBjLnJlbGVhc2VJbnRvUG9vbChiKVxuICAgIH0sIDFlMyAqIChiLm1heEFnZS52YWx1ZSArIGIubWF4QWdlLnNwcmVhZCkpLCB0aGlzKVxufSwgU1BFLkdyb3VwLnByb3RvdHlwZS50cmlnZ2VyUG9vbEVtaXR0ZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEgJiYgYSA+IDEpXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBhID4gYzsgKytjKVxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclNpbmdsZUVtaXR0ZXIoYik7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLl90cmlnZ2VyU2luZ2xlRW1pdHRlcihiKTtcbiAgICByZXR1cm4gdGhpc1xufSwgU1BFLkdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVW5pZm9ybXMgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy51bmlmb3Jtcy5ydW5UaW1lLnZhbHVlICs9IGEsXG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YVRpbWUudmFsdWUgPSBhXG59LCBTUEUuR3JvdXAucHJvdG90eXBlLl9yZXNldEJ1ZmZlclJhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhID0gdGhpcy5hdHRyaWJ1dGVLZXlzLFxuICAgICAgICBiID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDEsXG4gICAgICAgIGMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgZm9yIChiOyBiID49IDA7IC0tYilcbiAgICAgICAgY1thW2JdXS5yZXNldFVwZGF0ZVJhbmdlKClcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZUJ1ZmZlcnMgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGQsXG4gICAgICAgIGUgPSB0aGlzLmF0dHJpYnV0ZUtleXMsXG4gICAgICAgIGYgPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMSxcbiAgICAgICAgZyA9IHRoaXMuYXR0cmlidXRlcyxcbiAgICAgICAgaCA9IGEuYnVmZmVyVXBkYXRlUmFuZ2VzO1xuICAgIGZvciAoZjsgZiA+PSAwOyAtLWYpXG4gICAgICAgIGIgPSBlW2ZdLCBjID0gaFtiXSwgZCA9IGdbYl0sIGQuc2V0VXBkYXRlUmFuZ2UoYy5taW4sIGMubWF4KSwgZC5mbGFnVXBkYXRlKClcbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYixcbiAgICAgICAgYyA9IHRoaXMuZW1pdHRlcnMsXG4gICAgICAgIGQgPSBjLmxlbmd0aCxcbiAgICAgICAgZSA9IGEgfHwgdGhpcy5maXhlZFRpbWVTdGVwLFxuICAgICAgICBmID0gdGhpcy5hdHRyaWJ1dGVLZXlzLFxuICAgICAgICBnID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIGlmICh0aGlzLl91cGRhdGVVbmlmb3JtcyhlKSwgdGhpcy5fcmVzZXRCdWZmZXJSYW5nZXMoKSwgMCAhPT0gZCB8fCB0aGlzLl9hdHRyaWJ1dGVzTmVlZFJlZnJlc2ggIT09ICExIHx8IHRoaXMuX2F0dHJpYnV0ZXNOZWVkRHluYW1pY1Jlc2V0ICE9PSAhMSkge1xuICAgICAgICBmb3IgKHZhciBoLCBiID0gMDsgZCA+IGI7ICsrYilcbiAgICAgICAgICAgIGggPSBjW2JdLCBoLnRpY2soZSksIHRoaXMuX3VwZGF0ZUJ1ZmZlcnMoaCk7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzTmVlZER5bmFtaWNSZXNldCA9PT0gITApIHtcbiAgICAgICAgICAgIGZvciAoYiA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxOyBiID49IDA7IC0tYilcbiAgICAgICAgICAgICAgICBnW2ZbYl1dLnJlc2V0RHluYW1pYygpO1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgPSAhMVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzTmVlZFJlZnJlc2ggPT09ICEwKSB7XG4gICAgICAgICAgICBmb3IgKGIgPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMTsgYiA+PSAwOyAtLWIpXG4gICAgICAgICAgICAgICAgZ1tmW2JdXS5mb3JjZVVwZGF0ZUFsbCgpO1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID0gITEsIHRoaXMuX2F0dHJpYnV0ZXNOZWVkRHluYW1pY1Jlc2V0ID0gITBcbiAgICAgICAgfVxuICAgIH1cbn0sIFNQRS5Hcm91cC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKSwgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCksIHRoaXNcbn0sIFNQRS5FbWl0dGVyID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiID0gU1BFLnV0aWxzLFxuICAgICAgICBjID0gYi50eXBlcyxcbiAgICAgICAgZCA9IFNQRS52YWx1ZU92ZXJMaWZldGltZUxlbmd0aDtcbiAgICBhID0gYi5lbnN1cmVUeXBlZEFyZyhhLCBjLk9CSkVDVCwge30pLCBhLnBvc2l0aW9uID0gYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLCBjLk9CSkVDVCwge30pLCBhLnZlbG9jaXR5ID0gYi5lbnN1cmVUeXBlZEFyZyhhLnZlbG9jaXR5LCBjLk9CSkVDVCwge30pLCBhLmFjY2VsZXJhdGlvbiA9IGIuZW5zdXJlVHlwZWRBcmcoYS5hY2NlbGVyYXRpb24sIGMuT0JKRUNULCB7fSksIGEucmFkaXVzID0gYi5lbnN1cmVUeXBlZEFyZyhhLnJhZGl1cywgYy5PQkpFQ1QsIHt9KSwgYS5kcmFnID0gYi5lbnN1cmVUeXBlZEFyZyhhLmRyYWcsIGMuT0JKRUNULCB7fSksIGEucm90YXRpb24gPSBiLmVuc3VyZVR5cGVkQXJnKGEucm90YXRpb24sIGMuT0JKRUNULCB7fSksIGEuY29sb3IgPSBiLmVuc3VyZVR5cGVkQXJnKGEuY29sb3IsIGMuT0JKRUNULCB7fSksIGEub3BhY2l0eSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5vcGFjaXR5LCBjLk9CSkVDVCwge30pLCBhLnNpemUgPSBiLmVuc3VyZVR5cGVkQXJnKGEuc2l6ZSwgYy5PQkpFQ1QsIHt9KSwgYS5hbmdsZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5hbmdsZSwgYy5PQkpFQ1QsIHt9KSwgYS53aWdnbGUgPSBiLmVuc3VyZVR5cGVkQXJnKGEud2lnZ2xlLCBjLk9CSkVDVCwge30pLCBhLm1heEFnZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5tYXhBZ2UsIGMuT0JKRUNULCB7fSksIGEub25QYXJ0aWNsZVNwYXduICYmIGNvbnNvbGUud2FybihcIm9uUGFydGljbGVTcGF3biBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2Ugc2V0IHByb3BlcnRpZXMgZGlyZWN0bHkgdG8gYWx0ZXIgdmFsdWVzIGF0IHJ1bnRpbWUuXCIpLFxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCksIHRoaXMudHlwZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS50eXBlLCBjLk5VTUJFUiwgU1BFLmRpc3RyaWJ1dGlvbnMuQk9YKSwgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5wb3NpdGlvbi52YWx1ZSwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5wb3NpdGlvbi5zcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX3NwcmVhZENsYW1wOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5wb3NpdGlvbi5zcHJlYWRDbGFtcCwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfZGlzdHJpYnV0aW9uOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24uZGlzdHJpYnV0aW9uLCBjLk5VTUJFUiwgdGhpcy50eXBlKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIF9yYWRpdXM6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYWRpdXMsIGMuTlVNQkVSLCAxMCksXG4gICAgICAgIF9yYWRpdXNTY2FsZTogYi5lbnN1cmVJbnN0YW5jZU9mKGEucG9zaXRpb24uc2NhbGUsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpKSxcbiAgICAgICAgX2Rpc3RyaWJ1dGlvbkNsYW1wOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24uZGlzdHJpYnV0aW9uQ2xhbXAsIGMuTlVNQkVSLCAwKVxuICAgIH0sIHRoaXMudmVsb2NpdHkgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVJbnN0YW5jZU9mKGEudmVsb2NpdHkudmFsdWUsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVJbnN0YW5jZU9mKGEudmVsb2NpdHkuc3ByZWFkLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9kaXN0cmlidXRpb246IGIuZW5zdXJlVHlwZWRBcmcoYS52ZWxvY2l0eS5kaXN0cmlidXRpb24sIGMuTlVNQkVSLCB0aGlzLnR5cGUpLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMuYWNjZWxlcmF0aW9uID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlSW5zdGFuY2VPZihhLmFjY2VsZXJhdGlvbi52YWx1ZSwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZUluc3RhbmNlT2YoYS5hY2NlbGVyYXRpb24uc3ByZWFkLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyksXG4gICAgICAgIF9kaXN0cmlidXRpb246IGIuZW5zdXJlVHlwZWRBcmcoYS5hY2NlbGVyYXRpb24uZGlzdHJpYnV0aW9uLCBjLk5VTUJFUiwgdGhpcy50eXBlKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLmRyYWcgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVUeXBlZEFyZyhhLmRyYWcudmFsdWUsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVUeXBlZEFyZyhhLmRyYWcuc3ByZWFkLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy53aWdnbGUgPSB7XG4gICAgICAgIF92YWx1ZTogYi5lbnN1cmVUeXBlZEFyZyhhLndpZ2dsZS52YWx1ZSwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZVR5cGVkQXJnKGEud2lnZ2xlLnNwcmVhZCwgYy5OVU1CRVIsIDApXG4gICAgfSwgdGhpcy5yb3RhdGlvbiA9IHtcbiAgICAgICAgX2F4aXM6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnJvdGF0aW9uLmF4aXMsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApKSxcbiAgICAgICAgX2F4aXNTcHJlYWQ6IGIuZW5zdXJlSW5zdGFuY2VPZihhLnJvdGF0aW9uLmF4aXNTcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKSxcbiAgICAgICAgX2FuZ2xlOiBiLmVuc3VyZVR5cGVkQXJnKGEucm90YXRpb24uYW5nbGUsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX2FuZ2xlU3ByZWFkOiBiLmVuc3VyZVR5cGVkQXJnKGEucm90YXRpb24uYW5nbGVTcHJlYWQsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3N0YXRpYzogYi5lbnN1cmVUeXBlZEFyZyhhLnJvdGF0aW9uW1wic3RhdGljXCJdLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgX2NlbnRlcjogYi5lbnN1cmVJbnN0YW5jZU9mKGEucm90YXRpb24uY2VudGVyLCBUSFJFRS5WZWN0b3IzLCB0aGlzLnBvc2l0aW9uLl92YWx1ZS5jbG9uZSgpKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLm1heEFnZSA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZVR5cGVkQXJnKGEubWF4QWdlLnZhbHVlLCBjLk5VTUJFUiwgMiksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlVHlwZWRBcmcoYS5tYXhBZ2Uuc3ByZWFkLCBjLk5VTUJFUiwgMClcbiAgICB9LCB0aGlzLmNvbG9yID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlQXJyYXlJbnN0YW5jZU9mKGEuY29sb3IudmFsdWUsIFRIUkVFLkNvbG9yLCBuZXcgVEhSRUUuQ29sb3IpLFxuICAgICAgICBfc3ByZWFkOiBiLmVuc3VyZUFycmF5SW5zdGFuY2VPZihhLmNvbG9yLnNwcmVhZCwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMpLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMub3BhY2l0eSA9IHtcbiAgICAgICAgX3ZhbHVlOiBiLmVuc3VyZUFycmF5VHlwZWRBcmcoYS5vcGFjaXR5LnZhbHVlLCBjLk5VTUJFUiwgMSksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlQXJyYXlUeXBlZEFyZyhhLm9wYWNpdHkuc3ByZWFkLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9yYW5kb21pc2U6IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpXG4gICAgfSwgdGhpcy5zaXplID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlQXJyYXlUeXBlZEFyZyhhLnNpemUudmFsdWUsIGMuTlVNQkVSLCAxKSxcbiAgICAgICAgX3NwcmVhZDogYi5lbnN1cmVBcnJheVR5cGVkQXJnKGEuc2l6ZS5zcHJlYWQsIGMuTlVNQkVSLCAwKSxcbiAgICAgICAgX3JhbmRvbWlzZTogYi5lbnN1cmVUeXBlZEFyZyhhLnBvc2l0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLmFuZ2xlID0ge1xuICAgICAgICBfdmFsdWU6IGIuZW5zdXJlQXJyYXlUeXBlZEFyZyhhLmFuZ2xlLnZhbHVlLCBjLk5VTUJFUiwgMCksXG4gICAgICAgIF9zcHJlYWQ6IGIuZW5zdXJlQXJyYXlUeXBlZEFyZyhhLmFuZ2xlLnNwcmVhZCwgYy5OVU1CRVIsIDApLFxuICAgICAgICBfcmFuZG9taXNlOiBiLmVuc3VyZVR5cGVkQXJnKGEucG9zaXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKVxuICAgIH0sIHRoaXMucGFydGljbGVDb3VudCA9IGIuZW5zdXJlVHlwZWRBcmcoYS5wYXJ0aWNsZUNvdW50LCBjLk5VTUJFUiwgMTAwKSxcbiAgICB0aGlzLmR1cmF0aW9uID0gYi5lbnN1cmVUeXBlZEFyZyhhLmR1cmF0aW9uLCBjLk5VTUJFUiwgbnVsbCksIHRoaXMuaXNTdGF0aWMgPSBiLmVuc3VyZVR5cGVkQXJnKGEuaXNTdGF0aWMsIGMuQk9PTEVBTiwgITEpLCB0aGlzLmFjdGl2ZU11bHRpcGxpZXIgPSBiLmVuc3VyZVR5cGVkQXJnKGEuYWN0aXZlTXVsdGlwbGllciwgYy5OVU1CRVIsIDEpLCB0aGlzLmRpcmVjdGlvbiA9IGIuZW5zdXJlVHlwZWRBcmcoYS5kaXJlY3Rpb24sIGMuTlVNQkVSLCAxKSwgdGhpcy5hbGl2ZSA9IGIuZW5zdXJlVHlwZWRBcmcoYS5hbGl2ZSwgYy5CT09MRUFOLCAhMCksIHRoaXMucGFydGljbGVzUGVyU2Vjb25kID0gMCwgdGhpcy5hY3RpdmF0aW9uSW5kZXggPSAwLCB0aGlzLmF0dHJpYnV0ZU9mZnNldCA9IDAsIHRoaXMuYXR0cmlidXRlRW5kID0gMCwgdGhpcy5hZ2UgPSAwLCB0aGlzLmFjdGl2ZVBhcnRpY2xlQ291bnQgPSAwLCB0aGlzLmdyb3VwID0gbnVsbCwgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbCwgdGhpcy5wYXJhbXNBcnJheSA9IG51bGwsIHRoaXMucmVzZXRGbGFncyA9IHtcbiAgICAgICAgcG9zaXRpb246IGIuZW5zdXJlVHlwZWRBcmcoYS5wb3NpdGlvbi5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpIHx8IGIuZW5zdXJlVHlwZWRBcmcoYS5yYWRpdXMucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgdmVsb2NpdHk6IGIuZW5zdXJlVHlwZWRBcmcoYS52ZWxvY2l0eS5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICBhY2NlbGVyYXRpb246IGIuZW5zdXJlVHlwZWRBcmcoYS5hY2NlbGVyYXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSB8fCBiLmVuc3VyZVR5cGVkQXJnKGEuZHJhZy5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICByb3RhdGlvbjogYi5lbnN1cmVUeXBlZEFyZyhhLnJvdGF0aW9uLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSksXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyOiBiLmVuc3VyZVR5cGVkQXJnKGEucm90YXRpb24ucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgc2l6ZTogYi5lbnN1cmVUeXBlZEFyZyhhLnNpemUucmFuZG9taXNlLCBjLkJPT0xFQU4sICExKSxcbiAgICAgICAgY29sb3I6IGIuZW5zdXJlVHlwZWRBcmcoYS5jb2xvci5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICBvcGFjaXR5OiBiLmVuc3VyZVR5cGVkQXJnKGEub3BhY2l0eS5yYW5kb21pc2UsIGMuQk9PTEVBTiwgITEpLFxuICAgICAgICBhbmdsZTogYi5lbnN1cmVUeXBlZEFyZyhhLmFuZ2xlLnJhbmRvbWlzZSwgYy5CT09MRUFOLCAhMSlcbiAgICB9LCB0aGlzLnVwZGF0ZUZsYWdzID0ge30sIHRoaXMudXBkYXRlQ291bnRzID0ge30sIHRoaXMudXBkYXRlTWFwID0ge1xuICAgICAgICBtYXhBZ2U6IFwicGFyYW1zXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInBvc2l0aW9uXCIsXG4gICAgICAgIHZlbG9jaXR5OiBcInZlbG9jaXR5XCIsXG4gICAgICAgIGFjY2VsZXJhdGlvbjogXCJhY2NlbGVyYXRpb25cIixcbiAgICAgICAgZHJhZzogXCJhY2NlbGVyYXRpb25cIixcbiAgICAgICAgd2lnZ2xlOiBcInBhcmFtc1wiLFxuICAgICAgICByb3RhdGlvbjogXCJyb3RhdGlvblwiLFxuICAgICAgICBzaXplOiBcInNpemVcIixcbiAgICAgICAgY29sb3I6IFwiY29sb3JcIixcbiAgICAgICAgb3BhY2l0eTogXCJvcGFjaXR5XCIsXG4gICAgICAgIGFuZ2xlOiBcImFuZ2xlXCJcbiAgICB9O1xuICAgIGZvciAodmFyIGUgaW4gdGhpcy51cGRhdGVNYXApXG4gICAgICAgIHRoaXMudXBkYXRlTWFwLmhhc093blByb3BlcnR5KGUpICYmICh0aGlzLnVwZGF0ZUNvdW50c1t0aGlzLnVwZGF0ZU1hcFtlXV0gPSAwLCB0aGlzLnVwZGF0ZUZsYWdzW3RoaXMudXBkYXRlTWFwW2VdXSA9ICExLCB0aGlzLl9jcmVhdGVHZXR0ZXJTZXR0ZXJzKHRoaXNbZV0sIGUpKTtcbiAgICB0aGlzLmJ1ZmZlclVwZGF0ZVJhbmdlcyA9IHt9LCB0aGlzLmF0dHJpYnV0ZUtleXMgPSBudWxsLCB0aGlzLmF0dHJpYnV0ZUNvdW50ID0gMCwgYi5lbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2UodGhpcy5jb2xvciwgZCwgZCksIGIuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKHRoaXMub3BhY2l0eSwgZCwgZCksIGIuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKHRoaXMuc2l6ZSwgZCwgZCksIGIuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKHRoaXMuYW5nbGUsIGQsIGQpXG59LCBTUEUuRW1pdHRlci5jb25zdHJ1Y3RvciA9IFNQRS5FbWl0dGVyLCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2NyZWF0ZUdldHRlclNldHRlcnMgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGMgPSB0aGlzO1xuICAgIGZvciAodmFyIGQgaW4gYSlcbiAgICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkoZCkpIHtcbiAgICAgICAgICAgIHZhciBlID0gZC5yZXBsYWNlKFwiX1wiLCBcIlwiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBlLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2FdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KGQpLFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjLnVwZGF0ZU1hcFtiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gdGhpc1thXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gU1BFLnZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJfcm90YXRpb25DZW50ZXJcIiA9PT0gYSA/IChjLnVwZGF0ZUZsYWdzLnJvdGF0aW9uQ2VudGVyID0gITAsIGMudXBkYXRlQ291bnRzLnJvdGF0aW9uQ2VudGVyID0gMCkgOiBcIl9yYW5kb21pc2VcIiA9PT0gYSA/IGMucmVzZXRGbGFnc1tlXSA9IGQgOiAoYy51cGRhdGVGbGFnc1tlXSA9ICEwLCBjLnVwZGF0ZUNvdW50c1tlXSA9IDApLCBjLmdyb3VwLl91cGRhdGVEZWZpbmVzKCksIHRoaXNbYV0gPSBkLCBBcnJheS5pc0FycmF5KGYpICYmIFNQRS51dGlscy5lbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2UoY1tiXSwgZywgZylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fc2V0QnVmZmVyVXBkYXRlUmFuZ2VzID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMuYXR0cmlidXRlS2V5cyA9IGEsIHRoaXMuYXR0cmlidXRlQ291bnQgPSBhLmxlbmd0aDtcbiAgICBmb3IgKHZhciBiID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDE7IGIgPj0gMDsgLS1iKVxuICAgICAgICB0aGlzLmJ1ZmZlclVwZGF0ZVJhbmdlc1thW2JdXSA9IHtcbiAgICAgICAgICAgIG1pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgfVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9jYWxjdWxhdGVQUFNWYWx1ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYiA9IHRoaXMucGFydGljbGVDb3VudDtcbiAgICB0aGlzLmR1cmF0aW9uID8gdGhpcy5wYXJ0aWNsZXNQZXJTZWNvbmQgPSBiIC8gKGEgPCB0aGlzLmR1cmF0aW9uID8gYSA6IHRoaXMuZHVyYXRpb24pIDogdGhpcy5wYXJ0aWNsZXNQZXJTZWNvbmQgPSBiIC8gYVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9zZXRBdHRyaWJ1dGVPZmZzZXQgPSBmdW5jdGlvbihhKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVPZmZzZXQgPSBhLCB0aGlzLmFjdGl2YXRpb25JbmRleCA9IGEsXG4gICAgdGhpcy5hY3RpdmF0aW9uRW5kID0gYSArIHRoaXMucGFydGljbGVDb3VudFxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25WYWx1ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBzd2l0Y2ggKGEpIHtcbiAgICBjYXNlIFwicG9zaXRpb25cIjpcbiAgICAgICAgdGhpcy5fYXNzaWduUG9zaXRpb25WYWx1ZShiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInZlbG9jaXR5XCI6XG4gICAgY2FzZSBcImFjY2VsZXJhdGlvblwiOlxuICAgICAgICB0aGlzLl9hc3NpZ25Gb3JjZVZhbHVlKGIsIGEpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwic2l6ZVwiOlxuICAgIGNhc2UgXCJvcGFjaXR5XCI6XG4gICAgICAgIHRoaXMuX2Fzc2lnbkFic0xpZmV0aW1lVmFsdWUoYiwgYSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhbmdsZVwiOlxuICAgICAgICB0aGlzLl9hc3NpZ25BbmdsZVZhbHVlKGIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwicGFyYW1zXCI6XG4gICAgICAgIHRoaXMuX2Fzc2lnblBhcmFtc1ZhbHVlKGIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwicm90YXRpb25cIjpcbiAgICAgICAgdGhpcy5fYXNzaWduUm90YXRpb25WYWx1ZShiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgIHRoaXMuX2Fzc2lnbkNvbG9yVmFsdWUoYilcbiAgICB9XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnblBvc2l0aW9uVmFsdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIgPSBTUEUuZGlzdHJpYnV0aW9ucyxcbiAgICAgICAgYyA9IFNQRS51dGlscyxcbiAgICAgICAgZCA9IHRoaXMucG9zaXRpb24sXG4gICAgICAgIGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sXG4gICAgICAgIGYgPSBkLl92YWx1ZSxcbiAgICAgICAgZyA9IGQuX3NwcmVhZCxcbiAgICAgICAgaCA9IGQuX2Rpc3RyaWJ1dGlvbjtcbiAgICBzd2l0Y2ggKGgpIHtcbiAgICBjYXNlIGIuQk9YOlxuICAgICAgICBjLnJhbmRvbVZlY3RvcjMoZSwgYSwgZiwgZywgZC5fc3ByZWFkQ2xhbXApO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIGIuU1BIRVJFOlxuICAgICAgICBjLnJhbmRvbVZlY3RvcjNPblNwaGVyZShlLCBhLCBmLCBkLl9yYWRpdXMsIGQuX3NwcmVhZC54LCBkLl9yYWRpdXNTY2FsZSwgZC5fc3ByZWFkQ2xhbXAueCwgZC5fZGlzdHJpYnV0aW9uQ2xhbXAgfHwgdGhpcy5wYXJ0aWNsZUNvdW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBiLkRJU0M6XG4gICAgICAgIGMucmFuZG9tVmVjdG9yM09uRGlzYyhlLCBhLCBmLCBkLl9yYWRpdXMsIGQuX3NwcmVhZC54LCBkLl9yYWRpdXNTY2FsZSwgZC5fc3ByZWFkQ2xhbXAueClcbiAgICB9XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnbkZvcmNlVmFsdWUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGMsXG4gICAgICAgIGQsXG4gICAgICAgIGUsXG4gICAgICAgIGYsXG4gICAgICAgIGcsXG4gICAgICAgIGggPSBTUEUuZGlzdHJpYnV0aW9ucyxcbiAgICAgICAgaSA9IFNQRS51dGlscyxcbiAgICAgICAgaiA9IHRoaXNbYl0sXG4gICAgICAgIGsgPSBqLl92YWx1ZSxcbiAgICAgICAgbCA9IGouX3NwcmVhZCxcbiAgICAgICAgbSA9IGouX2Rpc3RyaWJ1dGlvbjtcbiAgICBzd2l0Y2ggKG0pIHtcbiAgICBjYXNlIGguQk9YOlxuICAgICAgICBpLnJhbmRvbVZlY3RvcjModGhpcy5hdHRyaWJ1dGVzW2JdLCBhLCBrLCBsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBoLlNQSEVSRTpcbiAgICAgICAgYyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi50eXBlZEFycmF5LmFycmF5LCBnID0gMyAqIGEsIGQgPSBjW2ddLCBlID0gY1tnICsgMV0sIGYgPSBjW2cgKyAyXSwgaS5yYW5kb21EaXJlY3Rpb25WZWN0b3IzT25TcGhlcmUodGhpcy5hdHRyaWJ1dGVzW2JdLCBhLCBkLCBlLCBmLCB0aGlzLnBvc2l0aW9uLl92YWx1ZSwgai5fdmFsdWUueCwgai5fc3ByZWFkLngpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIGguRElTQzpcbiAgICAgICAgYyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi50eXBlZEFycmF5LmFycmF5LCBnID0gMyAqIGEsIGQgPSBjW2ddLCBlID0gY1tnICsgMV0sIGYgPSBjW2cgKyAyXSwgaS5yYW5kb21EaXJlY3Rpb25WZWN0b3IzT25EaXNjKHRoaXMuYXR0cmlidXRlc1tiXSwgYSwgZCwgZSwgZiwgdGhpcy5wb3NpdGlvbi5fdmFsdWUsIGouX3ZhbHVlLngsIGouX3NwcmVhZC54KVxuICAgIH1cbiAgICBpZiAoXCJhY2NlbGVyYXRpb25cIiA9PT0gYikge1xuICAgICAgICB2YXIgbiA9IGkuY2xhbXAoaS5yYW5kb21GbG9hdCh0aGlzLmRyYWcuX3ZhbHVlLCB0aGlzLmRyYWcuX3NwcmVhZCksIDAsIDEpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuYWNjZWxlcmF0aW9uLnR5cGVkQXJyYXkuYXJyYXlbNCAqIGEgKyAzXSA9IG5cbiAgICB9XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnbkFic0xpZmV0aW1lVmFsdWUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGMsXG4gICAgICAgIGQgPSB0aGlzLmF0dHJpYnV0ZXNbYl0udHlwZWRBcnJheSxcbiAgICAgICAgZSA9IHRoaXNbYl0sXG4gICAgICAgIGYgPSBTUEUudXRpbHM7XG4gICAgZi5hcnJheVZhbHVlc0FyZUVxdWFsKGUuX3ZhbHVlKSAmJiBmLmFycmF5VmFsdWVzQXJlRXF1YWwoZS5fc3ByZWFkKSA/IChjID0gTWF0aC5hYnMoZi5yYW5kb21GbG9hdChlLl92YWx1ZVswXSwgZS5fc3ByZWFkWzBdKSksIGQuc2V0VmVjNENvbXBvbmVudHMoYSwgYywgYywgYywgYykpIDogZC5zZXRWZWM0Q29tcG9uZW50cyhhLCBNYXRoLmFicyhmLnJhbmRvbUZsb2F0KGUuX3ZhbHVlWzBdLCBlLl9zcHJlYWRbMF0pKSwgTWF0aC5hYnMoZi5yYW5kb21GbG9hdChlLl92YWx1ZVsxXSwgZS5fc3ByZWFkWzFdKSksIE1hdGguYWJzKGYucmFuZG9tRmxvYXQoZS5fdmFsdWVbMl0sIGUuX3NwcmVhZFsyXSkpLCBNYXRoLmFicyhmLnJhbmRvbUZsb2F0KGUuX3ZhbHVlWzNdLCBlLl9zcHJlYWRbM10pKSk7XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnbkFuZ2xlVmFsdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGIsXG4gICAgICAgIGMgPSB0aGlzLmF0dHJpYnV0ZXMuYW5nbGUudHlwZWRBcnJheSxcbiAgICAgICAgZCA9IHRoaXMuYW5nbGUsXG4gICAgICAgIGUgPSBTUEUudXRpbHM7XG4gICAgZS5hcnJheVZhbHVlc0FyZUVxdWFsKGQuX3ZhbHVlKSAmJiBlLmFycmF5VmFsdWVzQXJlRXF1YWwoZC5fc3ByZWFkKSA/IChiID0gZS5yYW5kb21GbG9hdChkLl92YWx1ZVswXSwgZC5fc3ByZWFkWzBdKSwgYy5zZXRWZWM0Q29tcG9uZW50cyhhLCBiLCBiLCBiLCBiKSkgOiBjLnNldFZlYzRDb21wb25lbnRzKGEsIGUucmFuZG9tRmxvYXQoZC5fdmFsdWVbMF0sIGQuX3NwcmVhZFswXSksIGUucmFuZG9tRmxvYXQoZC5fdmFsdWVbMV0sIGQuX3NwcmVhZFsxXSksIGUucmFuZG9tRmxvYXQoZC5fdmFsdWVbMl0sIGQuX3NwcmVhZFsyXSksIGUucmFuZG9tRmxvYXQoZC5fdmFsdWVbM10sIGQuX3NwcmVhZFszXSkpXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnblBhcmFtc1ZhbHVlID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMuYXR0cmlidXRlcy5wYXJhbXMudHlwZWRBcnJheS5zZXRWZWM0Q29tcG9uZW50cyhhLCB0aGlzLmlzU3RhdGljID8gMSA6IDAsIDAsIE1hdGguYWJzKFNQRS51dGlscy5yYW5kb21GbG9hdCh0aGlzLm1heEFnZS5fdmFsdWUsIHRoaXMubWF4QWdlLl9zcHJlYWQpKSwgU1BFLnV0aWxzLnJhbmRvbUZsb2F0KHRoaXMud2lnZ2xlLl92YWx1ZSwgdGhpcy53aWdnbGUuX3NwcmVhZCkpXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnblJvdGF0aW9uVmFsdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLnJvdGF0aW9uLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoYSwgU1BFLnV0aWxzLmdldFBhY2tlZFJvdGF0aW9uQXhpcyh0aGlzLnJvdGF0aW9uLl9heGlzLCB0aGlzLnJvdGF0aW9uLl9heGlzU3ByZWFkKSwgU1BFLnV0aWxzLnJhbmRvbUZsb2F0KHRoaXMucm90YXRpb24uX2FuZ2xlLCB0aGlzLnJvdGF0aW9uLl9hbmdsZVNwcmVhZCksIHRoaXMucm90YXRpb24uX3N0YXRpYyA/IDAgOiAxKSxcbiAgICB0aGlzLmF0dHJpYnV0ZXMucm90YXRpb25DZW50ZXIudHlwZWRBcnJheS5zZXRWZWMzKGEsIHRoaXMucm90YXRpb24uX2NlbnRlcilcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduQ29sb3JWYWx1ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBTUEUudXRpbHMucmFuZG9tQ29sb3JBc0hleCh0aGlzLmF0dHJpYnV0ZXMuY29sb3IsIGEsIHRoaXMuY29sb3IuX3ZhbHVlLCB0aGlzLmNvbG9yLl9zcHJlYWQpXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX3Jlc2V0UGFydGljbGUgPSBmdW5jdGlvbihhKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZm9yICh2YXIgYiwgYywgZCA9IHRoaXMucmVzZXRGbGFncywgZSA9IHRoaXMudXBkYXRlRmxhZ3MsIGYgPSB0aGlzLnVwZGF0ZUNvdW50cywgZyA9IHRoaXMuYXR0cmlidXRlS2V5cywgaCA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxOyBoID49IDA7IC0taClcbiAgICAgICAgYiA9IGdbaF0sIGMgPSBlW2JdLCAoZFtiXSA9PT0gITAgfHwgYyA9PT0gITApICYmICh0aGlzLl9hc3NpZ25WYWx1ZShiLCBhKSwgdGhpcy5fdXBkYXRlQXR0cmlidXRlVXBkYXRlUmFuZ2UoYiwgYSksIGMgPT09ICEwICYmIGZbYl0gPT09IHRoaXMucGFydGljbGVDb3VudCA/IChlW2JdID0gITEsIGZbYl0gPSAwKSA6IDEgPT0gYyAmJiArK2ZbYl0pXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX3VwZGF0ZUF0dHJpYnV0ZVVwZGF0ZVJhbmdlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjID0gdGhpcy5idWZmZXJVcGRhdGVSYW5nZXNbYV07XG4gICAgYy5taW4gPSBNYXRoLm1pbihiLCBjLm1pbiksIGMubWF4ID0gTWF0aC5tYXgoYiwgYy5tYXgpXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX3Jlc2V0QnVmZmVyUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGEsXG4gICAgICAgIGIgPSB0aGlzLmJ1ZmZlclVwZGF0ZVJhbmdlcyxcbiAgICAgICAgYyA9IHRoaXMuYnVmZmVyVXBkYXRlS2V5cyxcbiAgICAgICAgZCA9IHRoaXMuYnVmZmVyVXBkYXRlQ291bnQgLSAxO1xuICAgIGZvciAoZDsgZCA+PSAwOyAtLWQpXG4gICAgICAgIGEgPSBjW2RdLCBiW2FdLm1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgYlthXS5tYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLnBhcnRpY2xlc1BlclNlY29uZCA9IDAsIHRoaXMuYXR0cmlidXRlT2Zmc2V0ID0gMCwgdGhpcy5hY3RpdmF0aW9uSW5kZXggPSAwLCB0aGlzLmFjdGl2ZVBhcnRpY2xlQ291bnQgPSAwLCB0aGlzLmdyb3VwID0gbnVsbCwgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbCwgdGhpcy5wYXJhbXNBcnJheSA9IG51bGwsIHRoaXMuYWdlID0gMFxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9kZWNyZW1lbnRQYXJ0aWNsZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLS10aGlzLmFjdGl2ZVBhcnRpY2xlQ291bnRcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5faW5jcmVtZW50UGFydGljbGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgICsrdGhpcy5hY3RpdmVQYXJ0aWNsZUNvdW50XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2NoZWNrUGFydGljbGVBZ2VzID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZvciAodmFyIGUsIGYsIGcsIGgsIGkgPSBiIC0gMTsgaSA+PSBhOyAtLWkpXG4gICAgICAgIGUgPSA0ICogaSwgaCA9IGNbZV0sIDAgIT09IGggJiYgKGcgPSBjW2UgKyAxXSwgZiA9IGNbZSArIDJdLCAxID09PSB0aGlzLmRpcmVjdGlvbiA/IChnICs9IGQsIGcgPj0gZiAmJiAoZyA9IDAsIGggPSAwLCB0aGlzLl9kZWNyZW1lbnRQYXJ0aWNsZUNvdW50KCkpKSA6IChnIC09IGQsIDAgPj0gZyAmJiAoZyA9IGYsIGggPSAwLCB0aGlzLl9kZWNyZW1lbnRQYXJ0aWNsZUNvdW50KCkpKSwgY1tlXSA9IGgsIGNbZSArIDFdID0gZywgdGhpcy5fdXBkYXRlQXR0cmlidXRlVXBkYXRlUmFuZ2UoXCJwYXJhbXNcIiwgaSkpXG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUuX2FjdGl2YXRlUGFydGljbGVzID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZvciAodmFyIGUsIGYsIGcgPSB0aGlzLmRpcmVjdGlvbiwgaCA9IGE7IGIgPiBoOyArK2gpXG4gICAgICAgIGUgPSA0ICogaCwgKDAgPT0gY1tlXSB8fCAxID09PSB0aGlzLnBhcnRpY2xlQ291bnQpICYmICh0aGlzLl9pbmNyZW1lbnRQYXJ0aWNsZUNvdW50KCksIGNbZV0gPSAxLCB0aGlzLl9yZXNldFBhcnRpY2xlKGgpLCBmID0gZCAqIChoIC0gYSksIGNbZSArIDFdID0gLTEgPT09IGcgPyBjW2UgKyAyXSAtIGYgOiBmLCB0aGlzLl91cGRhdGVBdHRyaWJ1dGVVcGRhdGVSYW5nZShcInBhcmFtc1wiLCBoKSk7XG59LCBTUEUuRW1pdHRlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKGEpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAoIXRoaXMuaXNTdGF0aWMpIHtcbiAgICAgICAgbnVsbCA9PT0gdGhpcy5wYXJhbXNBcnJheSAmJiAodGhpcy5wYXJhbXNBcnJheSA9IHRoaXMuYXR0cmlidXRlcy5wYXJhbXMudHlwZWRBcnJheS5hcnJheSk7XG4gICAgICAgIHZhciBiID0gdGhpcy5hdHRyaWJ1dGVPZmZzZXQsXG4gICAgICAgICAgICBjID0gYiArIHRoaXMucGFydGljbGVDb3VudCxcbiAgICAgICAgICAgIGQgPSB0aGlzLnBhcmFtc0FycmF5LFxuICAgICAgICAgICAgZSA9IHRoaXMucGFydGljbGVzUGVyU2Vjb25kICogdGhpcy5hY3RpdmVNdWx0aXBsaWVyICogYSxcbiAgICAgICAgICAgIGYgPSB0aGlzLmFjdGl2YXRpb25JbmRleDtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2V0QnVmZmVyUmFuZ2VzKCksIHRoaXMuX2NoZWNrUGFydGljbGVBZ2VzKGIsIGMsIGQsIGEpLCB0aGlzLmFsaXZlID09PSAhMSlcbiAgICAgICAgICAgIHJldHVybiB2b2lkICh0aGlzLmFnZSA9IDApO1xuICAgICAgICBpZiAobnVsbCAhPT0gdGhpcy5kdXJhdGlvbiAmJiB0aGlzLmFnZSA+IHRoaXMuZHVyYXRpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGl2ZSA9ICExLCB2b2lkICh0aGlzLmFnZSA9IDApO1xuICAgICAgICB2YXIgZyA9IDEgPT09IHRoaXMucGFydGljbGVDb3VudCA/IGYgOiAwIHwgZixcbiAgICAgICAgICAgIGggPSBNYXRoLm1pbihnICsgZSwgdGhpcy5hY3RpdmF0aW9uRW5kKSxcbiAgICAgICAgICAgIGkgPSBoIC0gdGhpcy5hY3RpdmF0aW9uSW5kZXggfCAwLFxuICAgICAgICAgICAgaiA9IGkgPiAwID8gYSAvIGkgOiAwO1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZVBhcnRpY2xlcyhnLCBoLCBkLCBqKSwgdGhpcy5hY3RpdmF0aW9uSW5kZXggKz0gZSwgdGhpcy5hY3RpdmF0aW9uSW5kZXggPiBjICYmICh0aGlzLmFjdGl2YXRpb25JbmRleCA9IGIpLCB0aGlzLmFnZSArPSBhXG4gICAgfVxufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oYSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0aGlzLmFnZSA9IDAsIHRoaXMuYWxpdmUgPSAhMSwgYSA9PT0gITApIHtcbiAgICAgICAgZm9yICh2YXIgYiwgYyA9IHRoaXMuYXR0cmlidXRlT2Zmc2V0LCBkID0gYyArIHRoaXMucGFydGljbGVDb3VudCwgZSA9IHRoaXMucGFyYW1zQXJyYXksIGYgPSB0aGlzLmF0dHJpYnV0ZXMucGFyYW1zLmJ1ZmZlckF0dHJpYnV0ZSwgZyA9IGQgLSAxOyBnID49IGM7IC0tZylcbiAgICAgICAgICAgIGIgPSA0ICogZywgZVtiXSA9IDAsIGVbYiArIDFdID0gMDtcbiAgICAgICAgZi51cGRhdGVSYW5nZS5vZmZzZXQgPSAwLCBmLnVwZGF0ZVJhbmdlLmNvdW50ID0gLTEsXG4gICAgICAgIGYubmVlZHNVcGRhdGUgPSAhMFxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzLmFsaXZlID0gITAsIHRoaXNcbn0sIFNQRS5FbWl0dGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMuYWxpdmUgPSAhMSwgdGhpc1xufSwgU1BFLkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiBudWxsICE9PSB0aGlzLmdyb3VwID8gdGhpcy5ncm91cC5yZW1vdmVFbWl0dGVyKHRoaXMpIDogY29uc29sZS5lcnJvcihcIkVtaXR0ZXIgZG9lcyBub3QgYmVsb25nIHRvIGEgZ3JvdXAsIGNhbm5vdCByZW1vdmUuXCIpLCB0aGlzXG59O1xuIiwiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFJQUE7QURBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QURqeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FEMzJvQ0EsSUFBQSxnREFBQTtFQUFBOzs7QUFBTTs7O0VBRVEsbUJBQUMsT0FBRDs7TUFBQyxVQUFROztJQUNyQixJQUFDLENBQUEsVUFBRCxHQUFjO0lBQ2QsSUFBQyxDQUFBLGdCQUFELEdBQW9COztNQUNwQixPQUFPLENBQUMsa0JBQXNCLE9BQU8sQ0FBQyxLQUFYLEdBQXNCLHdCQUF0QixHQUFvRDs7O01BQy9FLE9BQU8sQ0FBQyxRQUFTOzs7TUFDakIsT0FBTyxDQUFDLGFBQWM7OztNQUN0QixPQUFPLENBQUMsYUFBYzs7O01BQ3RCLE9BQU8sQ0FBQyxXQUFZOzs7TUFDcEIsT0FBTyxDQUFDLE9BQVE7O0lBQ2hCLDJDQUFNLE9BQU47SUFDQSxJQUFDLENBQUEsS0FBSyxDQUFDLFVBQVAsR0FBb0I7SUFDcEIsSUFBQyxDQUFBLEtBQUssQ0FBQyxPQUFQLEdBQWlCO0VBWEw7O3NCQWFiLFFBQUEsR0FBVSxTQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCLFFBQWxCOztNQUFrQixXQUFXOztJQUN0QyxJQUFDLENBQUEsS0FBTSxDQUFBLFFBQUEsQ0FBUCxHQUFzQixRQUFILEdBQWlCLEtBQUEsR0FBTSxJQUF2QixHQUFpQztJQUNwRCxJQUFDLENBQUEsSUFBRCxDQUFNLFNBQUEsR0FBVSxRQUFoQixFQUE0QixLQUE1QjtJQUNBLElBQUcsSUFBQyxDQUFBLFVBQUo7YUFBb0IsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQUFwQjs7RUFIUzs7c0JBS1YsUUFBQSxHQUFVLFNBQUE7QUFDVCxRQUFBO0lBQUEsbUJBQUEsR0FDQztNQUFBLFVBQUEsRUFBWSxJQUFDLENBQUEsS0FBTSxDQUFBLGFBQUEsQ0FBbkI7TUFDQSxRQUFBLEVBQVUsSUFBQyxDQUFBLEtBQU0sQ0FBQSxXQUFBLENBRGpCO01BRUEsVUFBQSxFQUFZLElBQUMsQ0FBQSxLQUFNLENBQUEsYUFBQSxDQUZuQjtNQUdBLFVBQUEsRUFBWSxJQUFDLENBQUEsS0FBTSxDQUFBLGFBQUEsQ0FIbkI7TUFJQSxZQUFBLEVBQWMsSUFBQyxDQUFBLEtBQU0sQ0FBQSxlQUFBLENBSnJCO01BS0EsYUFBQSxFQUFlLElBQUMsQ0FBQSxLQUFNLENBQUEsZ0JBQUEsQ0FMdEI7TUFNQSxXQUFBLEVBQWEsSUFBQyxDQUFBLEtBQU0sQ0FBQSxjQUFBLENBTnBCO01BT0EsYUFBQSxFQUFlLElBQUMsQ0FBQSxLQUFNLENBQUEsZ0JBQUEsQ0FQdEI7TUFRQSxXQUFBLEVBQWEsSUFBQyxDQUFBLEtBQU0sQ0FBQSxjQUFBLENBUnBCO01BU0EsYUFBQSxFQUFlLElBQUMsQ0FBQSxLQUFNLENBQUEsZ0JBQUEsQ0FUdEI7TUFVQSxVQUFBLEVBQVksSUFBQyxDQUFBLEtBQU0sQ0FBQSxhQUFBLENBVm5CO01BV0EsU0FBQSxFQUFXLElBQUMsQ0FBQSxLQUFNLENBQUEsWUFBQSxDQVhsQjtNQVlBLFdBQUEsRUFBYSxJQUFDLENBQUEsS0FBTSxDQUFBLGNBQUEsQ0FacEI7O0lBYUQsV0FBQSxHQUFjO0lBQ2QsSUFBRyxJQUFDLENBQUEsZ0JBQUo7TUFBMEIsV0FBVyxDQUFDLEtBQVosR0FBb0IsSUFBQyxDQUFBLE1BQS9DOztJQUNBLElBQUEsR0FBTyxLQUFLLENBQUMsUUFBTixDQUFlLElBQUMsQ0FBQSxJQUFoQixFQUFzQixtQkFBdEIsRUFBMkMsV0FBM0M7SUFDUCxJQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsU0FBUCxLQUFvQixPQUF2QjtNQUNDLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBSSxDQUFDO01BQ2QsSUFBQyxDQUFBLENBQUQsR0FBSyxJQUFDLENBQUEsQ0FBRCxHQUFHLElBQUMsQ0FBQSxNQUZWO0tBQUEsTUFBQTtNQUlDLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBSSxDQUFDLE1BSmY7O1dBS0EsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFJLENBQUM7RUF2Qk47O0VBeUJWLFNBQUMsQ0FBQSxNQUFELENBQVEsVUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUE7SUFBSixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDtNQUNKLElBQUMsQ0FBQSxVQUFELEdBQWM7TUFDZCxJQUFHLElBQUMsQ0FBQSxVQUFKO2VBQW9CLElBQUMsQ0FBQSxRQUFELENBQUEsRUFBcEI7O0lBRkksQ0FETDtHQUREOztFQUtBLFNBQUMsQ0FBQSxNQUFELENBQVEsZ0JBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7TUFDSixJQUFDLENBQUEsVUFBRCxHQUFjO01BQ2QsSUFBQyxDQUFBLGdCQUFELEdBQW9CO01BQ3BCLElBQUcsSUFBQyxDQUFBLFVBQUo7ZUFBb0IsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQUFwQjs7SUFISSxDQUFMO0dBREQ7O0VBS0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxpQkFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUMsT0FBRDtNQUNKLElBQUMsQ0FBQSxRQUFRLENBQUMsZUFBVixHQUE0QjtNQUM1QixJQUFDLENBQUEsWUFBRCxHQUFnQixDQUFDO2FBQ2pCLElBQUMsQ0FBQSxFQUFELENBQUksT0FBSixFQUFhLFNBQUE7UUFBRyxJQUFlLElBQUMsQ0FBQSxVQUFoQjtpQkFBQSxJQUFDLENBQUEsUUFBRCxDQUFBLEVBQUE7O01BQUgsQ0FBYjtJQUhJLENBQUw7R0FERDs7RUFLQSxTQUFDLENBQUEsTUFBRCxDQUFRLE1BQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLFFBQVEsQ0FBQztJQUFiLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO01BQ0osSUFBQyxDQUFBLFFBQVEsQ0FBQyxXQUFWLEdBQXdCO01BQ3hCLElBQUMsQ0FBQSxJQUFELENBQU0sYUFBTixFQUFxQixLQUFyQjtNQUNBLElBQUcsSUFBQyxDQUFBLFVBQUo7ZUFBb0IsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQUFwQjs7SUFISSxDQURMO0dBREQ7O0VBTUEsU0FBQyxDQUFBLE1BQUQsQ0FBUSxZQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFBVixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsWUFBVixFQUF3QixLQUF4QjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLFVBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBaEIsQ0FBd0IsSUFBeEIsRUFBNkIsRUFBN0I7SUFBSCxDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsVUFBVixFQUFzQixLQUF0QixFQUE2QixJQUE3QjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLFlBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQztJQUFWLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxZQUFWLEVBQXdCLEtBQXhCO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsWUFBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUE7YUFBRyxJQUFDLENBQUEsS0FBSyxDQUFDO0lBQVYsQ0FBTDtJQUNBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLFlBQVYsRUFBd0IsS0FBeEI7SUFBWCxDQURMO0dBREQ7O0VBR0EsU0FBQyxDQUFBLE1BQUQsQ0FBUSxXQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFBVixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsV0FBVixFQUF1QixLQUF2QjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLGFBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQztJQUFWLENBQUw7SUFDQSxHQUFBLEVBQUssU0FBQyxLQUFEO2FBQVcsSUFBQyxDQUFBLFFBQUQsQ0FBVSxhQUFWLEVBQXlCLEtBQXpCO0lBQVgsQ0FETDtHQUREOztFQUdBLFNBQUMsQ0FBQSxNQUFELENBQVEsU0FBUixFQUNDO0lBQUEsR0FBQSxFQUFLLFNBQUMsS0FBRDtNQUNKLElBQUMsQ0FBQSxRQUFELENBQVUsWUFBVixFQUF3QixLQUF4QixFQUErQixJQUEvQjtNQUNBLElBQUMsQ0FBQSxRQUFELENBQVUsY0FBVixFQUEwQixLQUExQixFQUFpQyxJQUFqQztNQUNBLElBQUMsQ0FBQSxRQUFELENBQVUsZUFBVixFQUEyQixLQUEzQixFQUFrQyxJQUFsQzthQUNBLElBQUMsQ0FBQSxRQUFELENBQVUsYUFBVixFQUF5QixLQUF6QixFQUFnQyxJQUFoQztJQUpJLENBQUw7R0FERDs7RUFNQSxTQUFDLENBQUEsTUFBRCxDQUFRLFlBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBbEIsQ0FBMEIsSUFBMUIsRUFBK0IsRUFBL0I7SUFBSCxDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsWUFBVixFQUF3QixLQUF4QixFQUErQixJQUEvQjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLGNBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQyxZQUFZLENBQUMsT0FBcEIsQ0FBNEIsSUFBNUIsRUFBaUMsRUFBakM7SUFBSCxDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsY0FBVixFQUEwQixLQUExQixFQUFpQyxJQUFqQztJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLGVBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBckIsQ0FBNkIsSUFBN0IsRUFBa0MsRUFBbEM7SUFBSCxDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsZUFBVixFQUEyQixLQUEzQixFQUFrQyxJQUFsQztJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLGFBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBbkIsQ0FBMkIsSUFBM0IsRUFBZ0MsRUFBaEM7SUFBSCxDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsYUFBVixFQUF5QixLQUF6QixFQUFnQyxJQUFoQztJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLFdBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFDLEtBQUQ7YUFBVyxJQUFDLENBQUEsUUFBRCxDQUFVLFdBQVYsRUFBdUIsS0FBdkI7SUFBWCxDQUFMO0dBREQ7O0VBRUEsU0FBQyxDQUFBLE1BQUQsQ0FBUSxlQUFSLEVBQ0M7SUFBQSxHQUFBLEVBQUssU0FBQTthQUFHLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFBVixDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsZUFBVixFQUEyQixLQUEzQjtJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLGVBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBckIsQ0FBNkIsSUFBN0IsRUFBa0MsRUFBbEM7SUFBSCxDQUFMO0lBQ0EsR0FBQSxFQUFLLFNBQUMsS0FBRDthQUFXLElBQUMsQ0FBQSxRQUFELENBQVUsZUFBVixFQUEyQixLQUEzQixFQUFrQyxJQUFsQztJQUFYLENBREw7R0FERDs7RUFHQSxTQUFDLENBQUEsTUFBRCxDQUFRLFFBQVIsRUFDQztJQUFBLEdBQUEsRUFBSyxTQUFBO2FBQUcsSUFBQyxDQUFBLElBQUksQ0FBQztJQUFULENBQUw7R0FERDs7OztHQTlHdUI7O0FBaUh4QixrQkFBQSxHQUFxQixTQUFDLEtBQUQsRUFBUSxLQUFSO0FBR3BCLE1BQUE7RUFBQSxDQUFBLEdBQVEsSUFBQSxTQUFBLENBQ1A7SUFBQSxJQUFBLEVBQU0sS0FBSyxDQUFDLElBQVo7SUFDQSxLQUFBLEVBQU8sS0FBSyxDQUFDLEtBRGI7SUFFQSxNQUFBLEVBQVEsS0FBSyxDQUFDLE1BRmQ7SUFHQSxJQUFBLEVBQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFIM0I7R0FETztFQU9SLFFBQUEsR0FBVztFQUdYLEdBQUEsR0FBTSxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQztFQUczQixHQUFHLENBQUMsT0FBSixDQUFZLFNBQUMsSUFBRDtBQUdYLFFBQUE7SUFBQSxJQUFVLENBQUMsQ0FBQyxRQUFGLENBQVcsSUFBWCxFQUFpQixJQUFqQixDQUFWO0FBQUEsYUFBQTs7SUFHQSxHQUFBLEdBQU0sSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFYO0lBR04sSUFBQSxHQUFPLENBQUMsQ0FBQyxTQUFGLENBQVksR0FBSSxDQUFBLENBQUEsQ0FBaEI7SUFDUCxLQUFBLEdBQVEsR0FBSSxDQUFBLENBQUEsQ0FBRSxDQUFDLE9BQVAsQ0FBZSxHQUFmLEVBQW1CLEVBQW5CO0lBR1IsSUFBRyxDQUFDLFVBQUQsRUFBWSxlQUFaLEVBQTRCLFlBQTVCLENBQXlDLENBQUMsT0FBMUMsQ0FBa0QsSUFBbEQsQ0FBQSxHQUEwRCxDQUFDLENBQTlEO01BQ0MsS0FBQSxHQUFRLFFBQUEsQ0FBUyxLQUFULEVBRFQ7O1dBSUEsUUFBUyxDQUFBLElBQUEsQ0FBVCxHQUFpQjtFQWpCTixDQUFaO0VBb0JBLElBQUcsUUFBUSxDQUFDLGNBQVQsQ0FBd0IsWUFBeEIsQ0FBSDtJQUNDLFFBQVMsQ0FBQSxZQUFBLENBQVQsR0FBMEIsUUFBUSxDQUFDLFVBQVQsR0FBc0IsUUFBUSxDQUFDLFNBRDFEO0dBQUEsTUFBQTtJQUdDLFFBQVMsQ0FBQSxZQUFBLENBQVQsR0FBeUIsSUFIMUI7O0FBU0EsT0FBQSxlQUFBOztJQUNDLENBQUUsQ0FBQSxHQUFBLENBQUYsR0FBUztBQURWO0VBSUEsQ0FBQyxDQUFDLENBQUYsSUFBTyxDQUFDLENBQUMsQ0FBQyxRQUFGLEdBQWEsQ0FBQyxDQUFDLFVBQWhCLENBQUEsR0FBOEIsQ0FBQyxDQUFBLEdBQUksQ0FBQyxDQUFDLFVBQVA7RUFDckMsQ0FBQyxDQUFDLENBQUYsSUFBTyxDQUFDLENBQUMsUUFBRixHQUFhO0VBQ3BCLENBQUMsQ0FBQyxLQUFGLElBQVcsQ0FBQyxDQUFDLFFBQUYsR0FBYTtFQUl4QixJQUFHLEtBQUg7SUFBYyxLQUFLLENBQUMsT0FBTixHQUFnQixHQUE5QjtHQUFBLE1BQUE7SUFBc0MsS0FBSyxDQUFDLE9BQU4sQ0FBQSxFQUF0Qzs7QUFFQSxTQUFPO0FBekRhOztBQTJEckIsS0FBSyxDQUFBLFNBQUUsQ0FBQSxrQkFBUCxHQUE0QixTQUFDLEtBQUQ7U0FBVyxrQkFBQSxDQUFtQixJQUFuQixFQUFzQixLQUF0QjtBQUFYOztBQUU1QixpQkFBQSxHQUFvQixTQUFDLEdBQUQsRUFBTSxLQUFOO0FBQ25CLE1BQUE7QUFBQTtPQUFBLFdBQUE7O0lBQ0MsSUFBRyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQVosS0FBb0IsTUFBdkI7bUJBQ0MsR0FBSSxDQUFBLElBQUEsQ0FBSixHQUFZLGtCQUFBLENBQW1CLEtBQW5CLEVBQTBCLEtBQTFCLEdBRGI7S0FBQSxNQUFBOzJCQUFBOztBQUREOztBQURtQjs7QUFPcEIsS0FBSyxDQUFBLFNBQUUsQ0FBQSxnQkFBUCxHQUEwQixTQUFDLFVBQUQ7QUFDdEIsTUFBQTtFQUFBLENBQUEsR0FBSSxJQUFJO0VBQ1IsQ0FBQyxDQUFDLEtBQUYsR0FBVSxJQUFDLENBQUE7RUFDWCxDQUFDLENBQUMsVUFBRixHQUFlLElBQUMsQ0FBQTtFQUNoQixDQUFDLENBQUMsTUFBRixDQUFTLENBQVQsRUFBVyxVQUFYO0VBQ0EsSUFBQyxDQUFBLE9BQUQsQ0FBQTtTQUNBO0FBTnNCOztBQVExQixPQUFPLENBQUMsU0FBUixHQUFvQjs7QUFDcEIsT0FBTyxDQUFDLGlCQUFSLEdBQTRCOzs7O0FEM0w1QixPQUFPLENBQUMsS0FBUixHQUFnQjs7QUFFaEIsT0FBTyxDQUFDLFVBQVIsR0FBcUIsU0FBQTtTQUNwQixLQUFBLENBQU0sdUJBQU47QUFEb0I7O0FBR3JCLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQIn0=
